<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>Sampling collections</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April 10, 2016 at 12:00:00pm</p></header><div class="content"><p>In the playground:<br></p><p>    &quot;works?&quot;.capitalizedString // error: value of type &#39;String&#39; has no member &#39;capitalizedString&#39;<br></p><p>… but:<br></p><p>    import Foundation<br>    “works!”.capitalizedString // “Works!” <br></p><p>Would it not be nice if all the following likewise worked:<br></p><p>    import Foundation<br>    <br>    (1..&lt;4).sample<br>    [1,2,3].sample<br>    &quot;abc&quot;.characters.sample<br>    [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3].sample<br></p><p>Like so many users of Swift, I have extensions &lt;http://stackoverflow.com/a/30285125/1409907&gt; of IntegerType, ClosedInterval and CollectionType that avail me of the above methods and their family, but I’d much rather if such extensions came with Darwin or at least Foundation.<br></p><p>milos<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160410/6145a4dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Sampling collections</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>April 10, 2016 at 09:00:00am</p></header><div class="content"><p>It sounds like you’re suggesting that a “sample” property (that returns a randomly chosen element) should be added to the standard library? You could suggest that on the swift-evolution list, though IMHO it seems like a pretty obscure feature that not many users would need.<br></p><p>I don’t understand the comparison with capitalizedString; this works after importing Foundation because of the bridging between String and NSString, which is an artifact of the Mac/iOS Swift 2.x’s dependency on the Cocoa frameworks.<br></p><p>—Jens<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>Sampling collections</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April 10, 2016 at 09:00:00pm</p></header><div class="content"><p>Thank you, Jens, for your response. <br></p><p>I do however disagree with both points you are making. First, you write that sampling collection elements at random is:<br></p><p>&gt; a pretty obscure feature<br></p><p><br>But how can this be? When you teach students how to implement a card playing game in Swift, how do you shuffle the deck? And when you test your code, do you not feed your methods with randomly generated and sampled simulated data, or do so at random intervals? And when you’re simply checking out an idea in the playground, do you not want randomly sampled or reshuffled inputs? Should any of these activities qualify as obscure?<br></p><p>As for:<br></p><p>&gt; I don’t understand the comparison with capitalizedString; this works after importing Foundation because...<br></p><p><br>Indeed, nothing after that “because” would help understand what I meant by the comparison. It is the fact of the import that I was trying to highlight. That `Foundation` extends fundamental Standard Library types and protocols (like `String` in this case). The ObjC–Swift bridge is relevant here only in the sense that I would also like sampling methods added to `NSArray`, `NSSet` or `NSDictionary`...<br></p><p>At present, when we need a source of random bits on Apple’s platforms, we dip into `Darwin` or `GameplayKit` frameworks. This is fine, and even if it wasn’t, it is unlikely to change (even when new RNG algorithms get introduced). <br></p><p>What I would personally like to see, however (and what I was wondering the community feels about), is that one of these frameworks extends Standard Library data types and protocols with this functionality, which most of us gets the taste of right with our first encounters with computer programming and which we continue to rely on throughout our careers.<br></p><p>milos<br></p><p>&gt; On 10 Apr 2016, at 17:33, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; It sounds like you’re suggesting that a “sample” property (that returns a randomly chosen element) should be added to the standard library? You could suggest that on the swift-evolution list, though IMHO it seems like a pretty obscure feature that not many users would need.<br>&gt; <br>&gt; I don’t understand the comparison with capitalizedString; this works after importing Foundation because of the bridging between String and NSString, which is an artifact of the Mac/iOS Swift 2.x’s dependency on the Cocoa frameworks.<br>&gt; <br>&gt; —Jens<br>&gt; <br>&gt;&gt; In the playground:<br>&gt;&gt; <br>&gt;&gt;     &quot;works?&quot;.capitalizedString // error: value of type &#39;String&#39; has no member &#39;capitalizedString&#39;<br>&gt;&gt; <br>&gt;&gt; … but:<br>&gt;&gt; <br>&gt;&gt;     import Foundation<br>&gt;&gt;     “works!”.capitalizedString // “Works!” <br>&gt;&gt; <br>&gt;&gt; Would it not be nice if all the following likewise worked:<br>&gt;&gt; <br>&gt;&gt;     import Foundation<br>&gt;&gt;     <br>&gt;&gt;     (1..&lt;4).sample<br>&gt;&gt;     [1,2,3].sample<br>&gt;&gt;     &quot;abc&quot;.characters.sample<br>&gt;&gt;     [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3].sample<br>&gt;&gt; <br>&gt;&gt; Like so many users of Swift, I have extensions &lt;http://stackoverflow.com/a/30285125/1409907&gt; of IntegerType, ClosedInterval and CollectionType that avail me of the above methods and their family, but I’d much rather if such extensions came with Darwin or at least Foundation.<br>&gt;&gt; <br>&gt;&gt; milos<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160410/d2714199/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Sampling collections</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 10, 2016, at 2:00 PM, Milos Rankovic via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Thank you, Jens, for your response. <br>&gt; <br>&gt; I do however disagree with both points you are making. First, you write that sampling collection elements at random is:<br>&gt; <br>&gt;&gt; a pretty obscure feature<br>&gt; <br>&gt; <br>&gt; But how can this be? When you teach students how to implement a card playing game in Swift, how do you shuffle the deck? And when you test your code, do you not feed your methods with randomly generated and sampled simulated data, or do so at random intervals? And when you’re simply checking out an idea in the playground, do you not want randomly sampled or reshuffled inputs? Should any of these activities qualify as obscure?<br></p><p>I personally would vote against this. I do not think it&#39;s the role of a core language to worry about things like distributions, bias, and sampling.<br></p><p>At the same time, I agree it&#39;s a very common task for playgrounds. I&#39;ve developed a lot of  material for everything from random colors and shapes to placeholder APIs to shuffles.<br></p><p>Best regards,<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160410/e980255c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>Sampling collections</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April 10, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 10 Apr 2016, at 21:23, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; I do not think it&#39;s the role of a core language to worry about things like distributions, bias, and sampling.<br></p><p>Why do you mention “the role of a core language” here? That was explicitly not the ambition of my question. I’m talking about extending the Standard Library types and protocols in the Foundation framework (as this is already done on a large scale). Or, if this is what you mean by “core language”, how does capitalising strings according to the rules of grammar of every language on the planet qualify as any more fitting the domain of the core language?<br></p><p>milos<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160410/9651baa1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Sampling collections</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 10, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Apr 10, 2016, at 2:39 PM, Milos Rankovic &lt;milos at milos-and-slavica.net&gt; wrote:<br>&gt; <br>&gt;&gt; On 10 Apr 2016, at 21:23, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I do not think it&#39;s the role of a core language to worry about things like distributions, bias, and sampling.<br>&gt; <br>&gt; Why do you mention “the role of a core language” here? That was explicitly not the ambition of my question. I’m talking about extending the Standard Library types and protocols in the Foundation framework (as this is already done on a large scale). Or, if this is what you mean by “core language”, how does capitalising strings according to the rules of grammar of every language on the planet qualify as any more fitting the domain of the core language?<br>&gt; <br>&gt; milos<br>&gt; <br></p><p>While I don&#39;t think general random sources are a good fit for core functionality, apparently, NSRandomSpecifier exists: https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSRandomSpecifier_Class/index.html#//apple_ref/occ/cl/NSRandomSpecifier &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSRandomSpecifier_Class/index.html#//apple_ref/occ/cl/NSRandomSpecifier&gt;<br></p><p>Other material I consulted:<br>Standard Library: https://en.wikipedia.org/wiki/Standard_library &lt;https://en.wikipedia.org/wiki/Standard_library&gt;<br>Foundation: https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/ObjC_classic/ &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/ObjC_classic/&gt; <br>GameplayKit Randomization: https://developer.apple.com/library/ios/documentation/General/Conceptual/GameplayKit_Guide/RandomSources.html#//apple_ref/doc/uid/TP40015172-CH9-SW1 &lt;https://developer.apple.com/library/ios/documentation/General/Conceptual/GameplayKit_Guide/RandomSources.html#//apple_ref/doc/uid/TP40015172-CH9-SW1&gt;<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160410/84437feb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>Sampling collections</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April 10, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 10 Apr 2016, at 22:16, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; I don&#39;t think general random sources are a good fit for core functionality<br></p><p>I’m sorry, Erica, I still do not understand how your comments about “core functionality” reflect on my original question – have you seen it?<br></p><p>Certainly, there is plenty of precedent where Foundation extends Standard Library types and protocols:<br></p><p>// Foundation<br></p><p>extension String {<br>    public func enumerateLinguisticTagsInRange…<br>}<br></p><p>// CoreGraphics<br></p><p>extension Double {<br>    public init(_ value: CGFloat)<br>}<br></p><p>// Darwin<br></p><p>func yn(n: Int, _ x: Double) -&gt; Double //...which are the bessel functions of first and second kind!<br></p><p>What I’m talking about would not look out of place with linguistic tags and bassel functions:<br></p><p>// Foundation<br></p><p>extension UnsignedIntegerType {<br>    static var random: Self<br>}<br></p><p>extension ClosedInterval where Bound : UnsignedIntegerType {<br>    var random: Bound<br>}<br></p><p>extension ClosedInterval where Bound : SignedIntegerType {<br>    var random: Bound<br>}<br></p><p>extension CollectionType where Index.Distance == Int {<br>    var sample: Generator.Element?<br>}<br></p><p>… which we could use by:<br></p><p>    import Foundation<br>    <br>    (1..&lt;4).sample<br>    [1,2,3].sample<br>    &quot;abc&quot;.characters.sample<br>    [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3].sample<br></p><p>milos<br></p><p>&gt; On 10 Apr 2016, at 22:16, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 10, 2016, at 2:39 PM, Milos Rankovic &lt;milos at milos-and-slavica.net &lt;mailto:milos at milos-and-slavica.net&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 10 Apr 2016, at 21:23, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I do not think it&#39;s the role of a core language to worry about things like distributions, bias, and sampling.<br>&gt;&gt; <br>&gt;&gt; Why do you mention “the role of a core language” here? That was explicitly not the ambition of my question. I’m talking about extending the Standard Library types and protocols in the Foundation framework (as this is already done on a large scale). Or, if this is what you mean by “core language”, how does capitalising strings according to the rules of grammar of every language on the planet qualify as any more fitting the domain of the core language?<br>&gt;&gt; <br>&gt;&gt; milos<br>&gt;&gt; <br>&gt; <br>&gt; While I don&#39;t think general random sources are a good fit for core functionality, apparently, NSRandomSpecifier exists: https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSRandomSpecifier_Class/index.html#//apple_ref/occ/cl/NSRandomSpecifier &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSRandomSpecifier_Class/index.html#//apple_ref/occ/cl/NSRandomSpecifier&gt;<br>&gt; <br>&gt; Other material I consulted:<br>&gt; Standard Library: https://en.wikipedia.org/wiki/Standard_library &lt;https://en.wikipedia.org/wiki/Standard_library&gt;<br>&gt; Foundation: https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/ObjC_classic/ &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/ObjC_classic/&gt; <br>&gt; GameplayKit Randomization: https://developer.apple.com/library/ios/documentation/General/Conceptual/GameplayKit_Guide/RandomSources.html#//apple_ref/doc/uid/TP40015172-CH9-SW1 &lt;https://developer.apple.com/library/ios/documentation/General/Conceptual/GameplayKit_Guide/RandomSources.html#//apple_ref/doc/uid/TP40015172-CH9-SW1&gt;<br>&gt; <br>&gt; -- E<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160410/ea4a0fad/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Sampling collections</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>April 10, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Apr 10, 2016, at 1:00 PM, Milos Rankovic &lt;milos at milos-and-slavica.net&gt; wrote:<br>&gt; <br>&gt; The ObjC–Swift bridge is relevant here only in the sense that I would also like sampling methods added to `NSArray`, `NSSet` or `NSDictionary`…<br></p><p>Any library or program can add methods to any class using extensions. You can easily implement your own `sample` property. There may be a Swift library somewhere that provides one; all you’d have to do is import it.<br></p><p>If you want to implement it yourself, you can call the C functions `random` or `arc4random` directly from Swift. (You may need to add an #include to your bridging header in Xcode.)<br></p><p>&gt; What I would personally like to see, however (and what I was wondering the community feels about), is that one of these frameworks extends Standard Library data types and protocols with this functionality<br></p><p>So far Apple hasn’t added Swift-specific functionality to system frameworks; the frameworks are in Objective-C or C, and the Swift compiler and runtime bridge to that. What you’re suggesting would go the other direction, with a framework offering custom API wrappers. Maybe that will happen in the near future.<br></p><p>—Jens<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3fb6d812724261c1ab041db0d41baebc?s=50"></div><header><strong>Sampling collections</strong> from <string>Dave Yost</string> &lt;Dave at Yost.com&gt;<p>April 10, 2016 at 04:00:00pm</p></header><div class="content"><p>Every package that wraps C functions should be accompanied by a higher-level package that wraps the raw interface in best Swift fashion, IMO.<br></p><p>A C package without higher-level Swift wrappers is an invitation to chaos as a zillion people publish competing higher-level wrappers.<br></p><p>&gt; On 2016-04-10, at 3:12 PM, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 10, 2016, at 1:00 PM, Milos Rankovic &lt;milos at milos-and-slavica.net&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The ObjC–Swift bridge is relevant here only in the sense that I would also like sampling methods added to `NSArray`, `NSSet` or `NSDictionary`…<br>&gt; <br>&gt; Any library or program can add methods to any class using extensions. You can easily implement your own `sample` property. There may be a Swift library somewhere that provides one; all you’d have to do is import it.<br>&gt; <br>&gt; If you want to implement it yourself, you can call the C functions `random` or `arc4random` directly from Swift. (You may need to add an #include to your bridging header in Xcode.)<br>&gt; <br>&gt;&gt; What I would personally like to see, however (and what I was wondering the community feels about), is that one of these frameworks extends Standard Library data types and protocols with this functionality<br>&gt; <br>&gt; So far Apple hasn’t added Swift-specific functionality to system frameworks; the frameworks are in Objective-C or C, and the Swift compiler and runtime bridge to that. What you’re suggesting would go the other direction, with a framework offering custom API wrappers. Maybe that will happen in the near future.<br>&gt; <br>&gt; —Jens<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Sampling collections</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>April 10, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Apr 10, 2016, at 4:36 PM, Dave Yost &lt;Dave at Yost.com&gt; wrote:<br>&gt; <br>&gt; Every package that wraps C functions should be accompanied by a higher-level package that wraps the raw interface in best Swift fashion, IMO.<br>&gt; A C package without higher-level Swift wrappers is an invitation to chaos as a zillion people publish competing higher-level wrappers.<br></p><p>Sounds good, although that wasn’t really what I was talking about.<br></p><p>Is this a problem? Are there a lot of C-wrapping Swift libraries that don’t provide idiomatic &amp; safe Swift APIs? I haven’t run across any.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160410/dbddd4ea/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>Sampling collections</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April 11, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On 10 Apr 2016, at 23:12, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; You can easily implement your own `sample` property. <br></p><p>The very first email of this thread has a link to my example implementation. Here it is again if you mist it: http://stackoverflow.com/a/30285125/1409907 &lt;http://stackoverflow.com/a/30285125/1409907&gt;… however, my whole point is that I’d prefer if this important feature came with `Foundation`.<br></p><p>&gt; So far Apple hasn’t added Swift-specific functionality to system frameworks…<br></p><p>As I already stressed, I certainly do not imagine this to be “Swift-specific”, nor do I see any reason it would need to be. Also, it looks like you’ve missed my previous email in this thread where I give examples of current Foundation extensions of Standard Library types, and where I also make the bare bones of my wish-list rather more explicit.<br></p><p>Please note, though, that my original mail was simply trying to find out if there are people who also wished they had this functionality available upon importing Foundation; if they too would enjoy using it in playgrounds, when teaching, or while testing their code… Imagine opening a blank playground and typing something silly like the following, while fully expecting there to be a `sample` method on arrays, just as there is `componentsSeparatedByString` on strings:<br></p><p>import Foundation<br></p><p>extension String {<br>	var define: String? {<br>		return DCSCopyTextDefinition(nil, self, CFRangeMake(0, utf16.count)).map{<br>			$0.takeRetainedValue() as String<br>		}<br>	}<br>	var trail: String {<br>		var trail = [self]<br>		while let word = trail.last?.define?.componentsSeparatedByString(&quot; &quot;).sample {<br>			trail.append(word)<br>		}<br>		return trail.joinWithSeparator(&quot; &quot;) + &quot;!&quot;<br>	}<br>}<br></p><p>for i in 1...100 {<br>	print(&quot;Random&quot;.trail)<br>}<br></p><p>milos<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160411/33dbaa75/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Sampling collections</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>April 10, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Apr 10, 2016, at 6:01 PM, Milos Rankovic &lt;milos at milos-and-slavica.net&gt; wrote:<br>&gt; <br>&gt; As I already stressed, I certainly do not imagine this to be “Swift-specific”, nor do I see any reason it would need to be.<br></p><p>It sounds like you’re asking for a `sample` property to be added to NSArray, NSDictionary, NSSet, etc. You could certainly request that Apple do that, by filing a request at http://bugreport.apple.com, but don’t expect a reply; Apple’s framework teams are notoriously opaque.<br></p><p>Putting on my framework-designer hat, I’d argue that “random” is a broad concept with several possible implementations. Which RNG does `sample` use? Pick a cryptographic one and it might be too slow for some use cases; pick a fast one and it&#39;d be insufficiently random, making it dangerous to use for anything related to security. The right answer might be to have a RNG protocol, with several implementations backed by different generators, that exposes a method like `randomElement(Collection)`.<br></p><p>&gt; Also, it looks like you’ve missed my previous email in this thread where I give examples of current Foundation extensions of Standard Library types, and where I also make the bare bones of my wish-list rather more explicit.<br></p><p>The way those are implemented is a weird hack, so they’re not actually good examples of what you’re asking for. <br></p><p>It’s not that Apple&#39;s Foundation framework contains any extensions to Swift; Foundation is lower-level and I don’t believe it has any knowledge at all of Swift. So this is not the same effect as when you import a Swift library to get extensions. Rather, importing Foundation is a hardwired signal to the Swift compiler to activate the implicit bridging between Swift’s String class and Foundation’s NSString (and likewise for Array/NSArray, etc.)<br></p><p>In Swift 3 this will supposedly change: these APIs will be added directly to the Swift classes, removing the need for bridging.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160410/1baf8b1e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>Sampling collections</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April 11, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On 11 Apr 2016, at 02:17, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; I’d argue that “random” is a broad concept with several possible implementations. Which RNG does `sample` use? Pick a cryptographic one and it might be too slow for some use cases; pick a fast one and it&#39;d be insufficiently random, making it dangerous to use for anything related to security.<br></p><p>And yet we have `arc4random` family of functions which most people use in the kind of scenarios I refer to. The security argument is important, but I feel we sometimes reach for it too quickly. Just how will NOT implementing sampling on collections prevent someone from basing their security strategy on arc4 algorithm. Consider how indicative of their work would that be; how many more glaring security holes are they likely to leave! And are we saying that the obscure path to this algorithm somewhere inside `Darwin` is a virtue? Protecting the uninitiated from a dangerous technology?<br></p><p>I’m sorry we are spending so much time discussing why this may be difficult for *someone* (because it likely won’t be us) to implement. The fact is that random bits will have to come from the frameworks beyond Standard Library, but if there is will, I cannot imagine it would be too difficult to bring them to bear on the core datatypes and protocols. My question was always if there is such will; if people would like the feature to be there competently implemented and vetted by the community…<br></p><p>milos<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160411/c5ec6083/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Sampling collections</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>April 10, 2016 at 06:00:00pm</p></header><div class="content"><p>Well, write up a proposal and submit it &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt; to swift-evolution and let people discuss it.<br></p><p>&gt; I’m sorry we are spending so much time discussing why this may be difficult for *someone* (because it likely won’t be us) to implement.<br></p><p>Welcome to the world of bike-shedding.  It’s not difficult to implement this, it’s difficult to design, because people have different needs and expectations. For a feature to go into a core library, there needs to be a strong enough need and there also needs to be agreement about how it should behave.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160410/bcae1f7c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>Sampling collections</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April 11, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On 11 Apr 2016, at 02:57, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; Welcome to the world of bike-shedding.<br></p><p>Love that :)<br></p><p>milos<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160411/bfcce152/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Sampling collections</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 10, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt;     import Foundation<br>&gt;     <br>&gt;     (1..&lt;4).sample<br>&gt;     [1,2,3].sample<br>&gt;     &quot;abc&quot;.characters.sample<br>&gt;     [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3].sample<br>&gt; <br>&gt; Like so many users of Swift, I have extensions of IntegerType, ClosedInterval and CollectionType that avail me of the above methods and their family, but I’d much rather if such extensions came with Darwin or at least Foundation.<br></p><p>I don&#39;t think a `sample` property or method is the right approach here. It would be using some sort of global source of random numbers, which means that:<br></p><p>* It&#39;s not testable or repeatable<br>* It needs to be synchronized with other threads<br>* It can&#39;t be configured to use a different random number generator<br></p><p>Personally, I would eventually like to see something like this in the standard library:<br></p><p>	protocol RandomizerProtocol {<br>		mutating func randomBytes(_ n: Int) -&gt; [UInt8]<br>		// or possibly something involving a generic-length tuple, for speed<br>	}<br>	extension RandomizerProtocol {<br>		// for coin flips<br>		mutating func randomChoice() -&gt; Bool { ... }<br>		// for choosing a random element<br>		mutating func randomChoice&lt;CollectionType: RandomAccessCollection&gt;(from collection: CollectionType) -&gt; CollectionType.Element { ... }<br>		// for choosing a random value from an uncountable range (e.g. Range&lt;Double&gt;)<br>		mutating func randomChoice&lt;Element: Strideable&gt;(from range: Range&lt;Element&gt;) -&gt; Element { ... }<br>	}<br>	struct Randomizer: RandomizerProtocol {<br>		init(state: [UInt8]) { ... }<br>		init() { self.init(state: somethingToMakeAGoodRandomState()) }<br></p><p>		mutating func randomBytes(_ n: Int) -&gt; [UInt8] {<br>			// akin to arc4random()<br>		}<br>	}<br></p><p>This would allow you to confine a random number generator to a particular thread, swap one implementation for another, or inject one with a fixed starting state as a dependency to make tests predictable. A design like this one works around the problems I described nicely.<br></p><p>However, I don&#39;t think this is a high enough priority to address right now. This is borderline out-of-scope as &quot;major new library functionality&quot;, and there&#39;s so much stuff to do that is truly core to the language, this simply seems like a distraction.<br>		<br>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Sampling collections</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>April 10, 2016 at 06:00:00pm</p></header><div class="content"><p>I encourage anyone thinking about PRNG APIs to check out what C++ STL has<br>to offer: http://en.cppreference.com/w/cpp/numeric/random<br></p><p>And this analysis/extension of it:<br>http://www.pcg-random.org/posts/ease-of-use-without-loss-of-power.html<br></p><p>Jacob<br></p><p>On Sun, Apr 10, 2016 at 6:40 PM, Brent Royal-Gordon via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; &gt;     import Foundation<br>&gt; &gt;<br>&gt; &gt;     (1..&lt;4).sample<br>&gt; &gt;     [1,2,3].sample<br>&gt; &gt;     &quot;abc&quot;.characters.sample<br>&gt; &gt;     [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3].sample<br>&gt; &gt;<br>&gt; &gt; Like so many users of Swift, I have extensions of IntegerType,<br>&gt; ClosedInterval and CollectionType that avail me of the above methods and<br>&gt; their family, but I’d much rather if such extensions came with Darwin or at<br>&gt; least Foundation.<br>&gt;<br>&gt; I don&#39;t think a `sample` property or method is the right approach here. It<br>&gt; would be using some sort of global source of random numbers, which means<br>&gt; that:<br>&gt;<br>&gt; * It&#39;s not testable or repeatable<br>&gt; * It needs to be synchronized with other threads<br>&gt; * It can&#39;t be configured to use a different random number generator<br>&gt;<br>&gt; Personally, I would eventually like to see something like this in the<br>&gt; standard library:<br>&gt;<br>&gt;         protocol RandomizerProtocol {<br>&gt;                 mutating func randomBytes(_ n: Int) -&gt; [UInt8]<br>&gt;                 // or possibly something involving a generic-length tuple,<br>&gt; for speed<br>&gt;         }<br>&gt;         extension RandomizerProtocol {<br>&gt;                 // for coin flips<br>&gt;                 mutating func randomChoice() -&gt; Bool { ... }<br>&gt;                 // for choosing a random element<br>&gt;                 mutating func randomChoice&lt;CollectionType:<br>&gt; RandomAccessCollection&gt;(from collection: CollectionType) -&gt;<br>&gt; CollectionType.Element { ... }<br>&gt;                 // for choosing a random value from an uncountable range<br>&gt; (e.g. Range&lt;Double&gt;)<br>&gt;                 mutating func randomChoice&lt;Element: Strideable&gt;(from<br>&gt; range: Range&lt;Element&gt;) -&gt; Element { ... }<br>&gt;         }<br>&gt;         struct Randomizer: RandomizerProtocol {<br>&gt;                 init(state: [UInt8]) { ... }<br>&gt;                 init() { self.init(state:<br>&gt; somethingToMakeAGoodRandomState()) }<br>&gt;<br>&gt;                 mutating func randomBytes(_ n: Int) -&gt; [UInt8] {<br>&gt;                         // akin to arc4random()<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; This would allow you to confine a random number generator to a particular<br>&gt; thread, swap one implementation for another, or inject one with a fixed<br>&gt; starting state as a dependency to make tests predictable. A design like<br>&gt; this one works around the problems I described nicely.<br>&gt;<br>&gt; However, I don&#39;t think this is a high enough priority to address right<br>&gt; now. This is borderline out-of-scope as &quot;major new library functionality&quot;,<br>&gt; and there&#39;s so much stuff to do that is truly core to the language, this<br>&gt; simply seems like a distraction.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160410/8e58d629/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>Sampling collections</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April 11, 2016 at 03:00:00am</p></header><div class="content"><p>Thanks, Jacob, for the links. Apple did take steps in this direction by spoiling us with a choice of random sources in the GameplayKit. I’m sure that after that initial effort, the GameplayKit team will continue to bring more power to the randomisation part of the framework. <br></p><p>Only, that is not what I had in mind. Once you care about the distinction between congruential and Mersenne sources, you are likely not to mind having to deal with a more involved framework. My point is that this is VERY often far too involved! That the “middle ground” Apple is striking with ARC4 algorithm and a publicly accessible system source is indicative that there is a more “popular” need for such functionality where random merely has to look random… Much joy is to be found below that low bar. For example, I believe that a small family of basic sampling properties and methods would quickly become favourite among the learners of Swift and those that are teaching them.<br></p><p>milos<br></p><p>&gt; On 11 Apr 2016, at 02:42, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; I encourage anyone thinking about PRNG APIs to check out what C++ STL has to offer: http://en.cppreference.com/w/cpp/numeric/random &lt;http://en.cppreference.com/w/cpp/numeric/random&gt;<br>&gt; <br>&gt; And this analysis/extension of it: http://www.pcg-random.org/posts/ease-of-use-without-loss-of-power.html &lt;http://www.pcg-random.org/posts/ease-of-use-without-loss-of-power.html&gt;<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Sun, Apr 10, 2016 at 6:40 PM, Brent Royal-Gordon via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; &gt;     import Foundation<br>&gt; &gt;<br>&gt; &gt;     (1..&lt;4).sample<br>&gt; &gt;     [1,2,3].sample<br>&gt; &gt;     &quot;abc&quot;.characters.sample<br>&gt; &gt;     [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3].sample<br>&gt; &gt;<br>&gt; &gt; Like so many users of Swift, I have extensions of IntegerType, ClosedInterval and CollectionType that avail me of the above methods and their family, but I’d much rather if such extensions came with Darwin or at least Foundation.<br>&gt; <br>&gt; I don&#39;t think a `sample` property or method is the right approach here. It would be using some sort of global source of random numbers, which means that:<br>&gt; <br>&gt; * It&#39;s not testable or repeatable<br>&gt; * It needs to be synchronized with other threads<br>&gt; * It can&#39;t be configured to use a different random number generator<br>&gt; <br>&gt; Personally, I would eventually like to see something like this in the standard library:<br>&gt; <br>&gt;         protocol RandomizerProtocol {<br>&gt;                 mutating func randomBytes(_ n: Int) -&gt; [UInt8]<br>&gt;                 // or possibly something involving a generic-length tuple, for speed<br>&gt;         }<br>&gt;         extension RandomizerProtocol {<br>&gt;                 // for coin flips<br>&gt;                 mutating func randomChoice() -&gt; Bool { ... }<br>&gt;                 // for choosing a random element<br>&gt;                 mutating func randomChoice&lt;CollectionType: RandomAccessCollection&gt;(from collection: CollectionType) -&gt; CollectionType.Element { ... }<br>&gt;                 // for choosing a random value from an uncountable range (e.g. Range&lt;Double&gt;)<br>&gt;                 mutating func randomChoice&lt;Element: Strideable&gt;(from range: Range&lt;Element&gt;) -&gt; Element { ... }<br>&gt;         }<br>&gt;         struct Randomizer: RandomizerProtocol {<br>&gt;                 init(state: [UInt8]) { ... }<br>&gt;                 init() { self.init(state: somethingToMakeAGoodRandomState()) }<br>&gt; <br>&gt;                 mutating func randomBytes(_ n: Int) -&gt; [UInt8] {<br>&gt;                         // akin to arc4random()<br>&gt;                 }<br>&gt;         }<br>&gt; <br>&gt; This would allow you to confine a random number generator to a particular thread, swap one implementation for another, or inject one with a fixed starting state as a dependency to make tests predictable. A design like this one works around the problems I described nicely.<br>&gt; <br>&gt; However, I don&#39;t think this is a high enough priority to address right now. This is borderline out-of-scope as &quot;major new library functionality&quot;, and there&#39;s so much stuff to do that is truly core to the language, this simply seems like a distraction.<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160411/440d9ece/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
