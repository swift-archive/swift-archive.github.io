<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  8, 2016 at 12:00:00pm</p></header><div class="content"><p>(starting a new thread by DaveA&#39;s request)<br></p><p>There&#39;s a definition of equality that makes sense as a default for nearly every type in our system:<br></p><p>- Basic types like IntNN, FloatNN, String, etc. have domain-defined equality,<br>- Structs and tuples can be considered equal if their corresponding fields are equal,<br>- Enums can be considered equal if they carry the same, equal payload,<br>- Class references can be considered equal if they refer to the same instance,<br>- Metatypes can be considered equal if they represent the same type, and<br>- Existentials can be considered equal if they carry equal values of the same dynamic type.<br></p><p>and similarly, reasonable hash code implementations could be synthesized by applying a standard hash combine operation over the components, and a default ordering  could be assigned to values of every type. I think it&#39;s worth considering whether Equatable, Hashable, and/or Comparable, instead of being explicit protocols, should become universal behavior like &#39;print&#39;, with customization points to override the default behavior. If Equatable and Hashable behavior were universal, that would solve many of the common problems people currently have trying to work with heterogeneous containers. In object-oriented frameworks, including Cocoa, Java, and .NET, it is common for the root (NS)Object class to provide default equality and hashing operations. There are of course some tradeoffs:<br></p><p>- Universal behavior would require us to either generate code for &#39;==&#39;, &#39;hashValue&#39;, and/or &#39;&lt;&#39; for every type, or provide sufficient reflection info for a common runtime implementation to do it. The reflection-based approach may be reasonable for print(), since dumping reflection info only reduces the quality of the default logging behavior, but &#39;==&#39; and &#39;hashValue&#39; are more essential to proper behavior, so relying on reflection might be too slow, and would be brittle when we introduce the ability to drop reflection info.<br>- Type safety with &#39;==&#39; is important to prevent accidental &#39;1 == &quot;1&quot;&#39; type comparsions, and a fully generic &#39;func ==&lt;T&gt;(x: T, y: T) -&gt; Bool&#39; could potentially allow those sorts of mixed-type comparisons by accident. Language rules that constrained when generic parameters can be resolved to supertypes might help here.<br>- Function types in Swift do not provide a ready equality operation. We could provide a default implementation that always returns &#39;false&#39;, perhaps.<br>- A Comparable ordering can be dreamt up for many types, but it&#39;s not always a stable ordering, or a desired one. Many people have complained that &#39;nil &lt; .Some(1)&#39; works for optionals, for instance, ordering &#39;nil&#39; below Some values. We could use pointer identity to order class instances and types, but this wouldn&#39;t be a stable ordering across process runs. That might be good enough for ordered collections like search trees, but is weaker than what many people expect &#39;&lt;&#39; to do.<br></p><p>It&#39;s my feeling that Equatable and Hashable would make a lot of sense as universal operations; I&#39;m not so sure about Comparable.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/11a8e906b9e22dfebe544e4e218a4be0?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Brian Pratt</string> &lt;brian at pratt.io&gt;<p>March  8, 2016 at 04:00:00pm</p></header><div class="content"><p>Definitely a +1 on the basics. When you get inheritance involved, does that<br>complicates things a little bit?<br></p><p>Let&#39;s say I have a subclass instance that has corresponding fields with a<br>superclass instance. Is it equal to said super-class instance using just<br>member-wise comparisons? Would that be problematic? In Scala you&#39;d often<br>use a reference to an &quot;equality contract&quot; object type in order to get<br>&quot;transitive&quot; equality between subclasses and superclasses, which definitely<br>feels like a step backwards from the current protocol-driven approach.<br></p><p><br></p><p>On Tue, Mar 8, 2016 at 2:54 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; (starting a new thread by DaveA&#39;s request)<br>&gt;<br>&gt; There&#39;s a definition of equality that makes sense as a default for nearly<br>&gt; every type in our system:<br>&gt;<br>&gt; - Basic types like IntNN, FloatNN, String, etc. have domain-defined<br>&gt; equality,<br>&gt; - Structs and tuples can be considered equal if their corresponding fields<br>&gt; are equal,<br>&gt; - Enums can be considered equal if they carry the same, equal payload,<br>&gt; - Class references can be considered equal if they refer to the same<br>&gt; instance,<br>&gt; - Metatypes can be considered equal if they represent the same type, and<br>&gt; - Existentials can be considered equal if they carry equal values of the<br>&gt; same dynamic type.<br>&gt;<br>&gt; and similarly, reasonable hash code implementations could be synthesized<br>&gt; by applying a standard hash combine operation over the components, and a<br>&gt; default ordering  could be assigned to values of every type. I think it&#39;s<br>&gt; worth considering whether Equatable, Hashable, and/or Comparable, instead<br>&gt; of being explicit protocols, should become universal behavior like &#39;print&#39;,<br>&gt; with customization points to override the default behavior. If Equatable<br>&gt; and Hashable behavior were universal, that would solve many of the common<br>&gt; problems people currently have trying to work with heterogeneous<br>&gt; containers. In object-oriented frameworks, including Cocoa, Java, and .NET,<br>&gt; it is common for the root (NS)Object class to provide default equality and<br>&gt; hashing operations. There are of course some tradeoffs:<br>&gt;<br>&gt; - Universal behavior would require us to either generate code for &#39;==&#39;,<br>&gt; &#39;hashValue&#39;, and/or &#39;&lt;&#39; for every type, or provide sufficient reflection<br>&gt; info for a common runtime implementation to do it. The reflection-based<br>&gt; approach may be reasonable for print(), since dumping reflection info only<br>&gt; reduces the quality of the default logging behavior, but &#39;==&#39; and<br>&gt; &#39;hashValue&#39; are more essential to proper behavior, so relying on reflection<br>&gt; might be too slow, and would be brittle when we introduce the ability to<br>&gt; drop reflection info.<br>&gt; - Type safety with &#39;==&#39; is important to prevent accidental &#39;1 == &quot;1&quot;&#39; type<br>&gt; comparsions, and a fully generic &#39;func ==&lt;T&gt;(x: T, y: T) -&gt; Bool&#39; could<br>&gt; potentially allow those sorts of mixed-type comparisons by accident.<br>&gt; Language rules that constrained when generic parameters can be resolved to<br>&gt; supertypes might help here.<br>&gt; - Function types in Swift do not provide a ready equality operation. We<br>&gt; could provide a default implementation that always returns &#39;false&#39;, perhaps.<br>&gt; - A Comparable ordering can be dreamt up for many types, but it&#39;s not<br>&gt; always a stable ordering, or a desired one. Many people have complained<br>&gt; that &#39;nil &lt; .Some(1)&#39; works for optionals, for instance, ordering &#39;nil&#39;<br>&gt; below Some values. We could use pointer identity to order class instances<br>&gt; and types, but this wouldn&#39;t be a stable ordering across process runs. That<br>&gt; might be good enough for ordered collections like search trees, but is<br>&gt; weaker than what many people expect &#39;&lt;&#39; to do.<br>&gt;<br>&gt; It&#39;s my feeling that Equatable and Hashable would make a lot of sense as<br>&gt; universal operations; I&#39;m not so sure about Comparable.<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/b1806639/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>March  8, 2016 at 02:00:00pm</p></header><div class="content"><p>I would prefer Equatable and Hashable to remain opt-in, and for us to add<br>better support for automatic deriving of implementation.<br></p><p>For something like printing the representation of an object to a string,<br>there exists a &quot;not wrong&quot; mapping of every possible value to a string.<br>That is, if my FooStruct doesn&#39;t provide a custom description, having the<br>runtime convert it to something like &quot;(FooStruct instance)&quot; is still a<br>valid mapping. It might not be useful, but it&#39;s not wrong.<br></p><p>I don&#39;t think the same applies for equatability. The universal default<br>behavior for equating two objects is either correct or incorrect, and it&#39;s<br>not possible to know beforehand which is which. One of the wonderful things<br>about the current Swift system is that (modulo some exceptional cases) only<br>things explicitly meant to be equatable with each other are comparable. We<br>avoid the object-oriented pitfall in which &#39;equality&#39; means two different<br>things - equality of value if you implemented an override properly; a<br>default &#39;equality of instance&#39; otherwise (which might be right or wrong).<br>Of course, the same pitfall wouldn&#39;t necessarily apply in our case, but the<br>problem of having a &#39;default&#39; == impl that allows a developer to falsely<br>assume their type is being properly compared (or not think about it at all)<br>would still be present.<br></p><p>Best,<br>Austin<br></p><p><br></p><p>On Tue, Mar 8, 2016 at 2:02 PM, Brian Pratt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Definitely a +1 on the basics. When you get inheritance involved, does<br>&gt; that complicates things a little bit?<br>&gt;<br>&gt; Let&#39;s say I have a subclass instance that has corresponding fields with a<br>&gt; superclass instance. Is it equal to said super-class instance using just<br>&gt; member-wise comparisons? Would that be problematic? In Scala you&#39;d often<br>&gt; use a reference to an &quot;equality contract&quot; object type in order to get<br>&gt; &quot;transitive&quot; equality between subclasses and superclasses, which definitely<br>&gt; feels like a step backwards from the current protocol-driven approach.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, Mar 8, 2016 at 2:54 PM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; (starting a new thread by DaveA&#39;s request)<br>&gt;&gt;<br>&gt;&gt; There&#39;s a definition of equality that makes sense as a default for nearly<br>&gt;&gt; every type in our system:<br>&gt;&gt;<br>&gt;&gt; - Basic types like IntNN, FloatNN, String, etc. have domain-defined<br>&gt;&gt; equality,<br>&gt;&gt; - Structs and tuples can be considered equal if their corresponding<br>&gt;&gt; fields are equal,<br>&gt;&gt; - Enums can be considered equal if they carry the same, equal payload,<br>&gt;&gt; - Class references can be considered equal if they refer to the same<br>&gt;&gt; instance,<br>&gt;&gt; - Metatypes can be considered equal if they represent the same type, and<br>&gt;&gt; - Existentials can be considered equal if they carry equal values of the<br>&gt;&gt; same dynamic type.<br>&gt;&gt;<br>&gt;&gt; and similarly, reasonable hash code implementations could be synthesized<br>&gt;&gt; by applying a standard hash combine operation over the components, and a<br>&gt;&gt; default ordering  could be assigned to values of every type. I think it&#39;s<br>&gt;&gt; worth considering whether Equatable, Hashable, and/or Comparable, instead<br>&gt;&gt; of being explicit protocols, should become universal behavior like &#39;print&#39;,<br>&gt;&gt; with customization points to override the default behavior. If Equatable<br>&gt;&gt; and Hashable behavior were universal, that would solve many of the common<br>&gt;&gt; problems people currently have trying to work with heterogeneous<br>&gt;&gt; containers. In object-oriented frameworks, including Cocoa, Java, and .NET,<br>&gt;&gt; it is common for the root (NS)Object class to provide default equality and<br>&gt;&gt; hashing operations. There are of course some tradeoffs:<br>&gt;&gt;<br>&gt;&gt; - Universal behavior would require us to either generate code for &#39;==&#39;,<br>&gt;&gt; &#39;hashValue&#39;, and/or &#39;&lt;&#39; for every type, or provide sufficient reflection<br>&gt;&gt; info for a common runtime implementation to do it. The reflection-based<br>&gt;&gt; approach may be reasonable for print(), since dumping reflection info only<br>&gt;&gt; reduces the quality of the default logging behavior, but &#39;==&#39; and<br>&gt;&gt; &#39;hashValue&#39; are more essential to proper behavior, so relying on reflection<br>&gt;&gt; might be too slow, and would be brittle when we introduce the ability to<br>&gt;&gt; drop reflection info.<br>&gt;&gt; - Type safety with &#39;==&#39; is important to prevent accidental &#39;1 == &quot;1&quot;&#39;<br>&gt;&gt; type comparsions, and a fully generic &#39;func ==&lt;T&gt;(x: T, y: T) -&gt; Bool&#39;<br>&gt;&gt; could potentially allow those sorts of mixed-type comparisons by accident.<br>&gt;&gt; Language rules that constrained when generic parameters can be resolved to<br>&gt;&gt; supertypes might help here.<br>&gt;&gt; - Function types in Swift do not provide a ready equality operation. We<br>&gt;&gt; could provide a default implementation that always returns &#39;false&#39;, perhaps.<br>&gt;&gt; - A Comparable ordering can be dreamt up for many types, but it&#39;s not<br>&gt;&gt; always a stable ordering, or a desired one. Many people have complained<br>&gt;&gt; that &#39;nil &lt; .Some(1)&#39; works for optionals, for instance, ordering &#39;nil&#39;<br>&gt;&gt; below Some values. We could use pointer identity to order class instances<br>&gt;&gt; and types, but this wouldn&#39;t be a stable ordering across process runs. That<br>&gt;&gt; might be good enough for ordered collections like search trees, but is<br>&gt;&gt; weaker than what many people expect &#39;&lt;&#39; to do.<br>&gt;&gt;<br>&gt;&gt; It&#39;s my feeling that Equatable and Hashable would make a lot of sense as<br>&gt;&gt; universal operations; I&#39;m not so sure about Comparable.<br>&gt;&gt;<br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/83a7bc70/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>March  8, 2016 at 05:00:00pm</p></header><div class="content"><p>I completely agree with Austin here. Automatic derivation (perhaps<br>through the same mechanisms Joe is talking about) would be a nice<br>enhancement, but I find it refreshing and advantageous for simple value<br>types to have very little automatic behavior.<br></p><p>Cheers!  Zachary Waldowski  zach at waldowski.me<br></p><p>On Tue, Mar 8, 2016, at 05:15 PM, Austin Zheng via swift-evolution wrote:<br>&gt; I would prefer Equatable and Hashable to remain opt-in, and for us to<br>&gt; add better support for automatic deriving of implementation.<br>&gt;<br>&gt; For something like printing the representation of an object to a<br>&gt; string, there exists a &quot;not wrong&quot; mapping of every possible value to<br>&gt; a string. That is, if my FooStruct doesn&#39;t provide a custom<br>&gt; description, having the runtime convert it to something like<br>&gt; &quot;(FooStruct instance)&quot; is still a valid mapping. It might not be<br>&gt; useful, but it&#39;s not wrong.<br>&gt;<br>&gt; I don&#39;t think the same applies for equatability. The universal default<br>&gt; behavior for equating two objects is either correct or incorrect, and<br>&gt; it&#39;s not possible to know beforehand which is which. One of the<br>&gt; wonderful things about the current Swift system is that (modulo some<br>&gt; exceptional cases) only things explicitly meant to be equatable with<br>&gt; each other are comparable. We avoid the object-oriented pitfall in<br>&gt; which &#39;equality&#39; means two different things - equality of value if you<br>&gt; implemented an override properly; a default &#39;equality of instance&#39;<br>&gt; otherwise (which might be right or wrong). Of course, the same pitfall<br>&gt; wouldn&#39;t necessarily apply in our case, but the problem of having a<br>&gt; &#39;default&#39; == impl that allows a developer to falsely assume their type<br>&gt; is being properly compared (or not think about it at all) would still<br>&gt; be present.<br>&gt;<br>&gt; Best, Austin<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, Mar 8, 2016 at 2:02 PM, Brian Pratt via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt; Definitely a +1 on the basics. When you get inheritance involved,<br>&gt;&gt; does that complicates things a little bit?<br>&gt;&gt;<br>&gt;&gt; Let&#39;s say I have a subclass instance that has corresponding fields<br>&gt;&gt; with a superclass instance. Is it equal to said super-class instance<br>&gt;&gt; using just member-wise comparisons? Would that be problematic? In<br>&gt;&gt; Scala you&#39;d often use a reference to an &quot;equality contract&quot; object<br>&gt;&gt; type in order to get &quot;transitive&quot; equality between subclasses and<br>&gt;&gt; superclasses, which definitely feels like a step backwards from the<br>&gt;&gt; current protocol-driven approach.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Mar 8, 2016 at 2:54 PM, Joe Groff via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; (starting a new thread by DaveA&#39;s request)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>There&#39;s a definition of equality that makes sense as a default for<br>nearly every type in our system:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>- Basic types like IntNN, FloatNN, String, etc. have domain-<br>  defined equality,<br>&gt;&gt;&gt;<br>- Structs and tuples can be considered equal if their corresponding<br>  fields are equal,<br>&gt;&gt;&gt;<br>- Enums can be considered equal if they carry the same, equal payload,<br>&gt;&gt;&gt;<br>- Class references can be considered equal if they refer to the<br>  same instance,<br>&gt;&gt;&gt;<br>- Metatypes can be considered equal if they represent the same type, and<br>&gt;&gt;&gt;<br>- Existentials can be considered equal if they carry equal values of the<br>  same dynamic type.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>and similarly, reasonable hash code implementations could be synthesized<br>by applying a standard hash combine operation over the components, and a<br>default ordering  could be assigned to values of every type. I think<br>it&#39;s worth considering whether Equatable, Hashable, and/or Comparable,<br>instead of being explicit protocols, should become universal behavior<br>like &#39;print&#39;, with customization points to override the default<br>behavior. If Equatable and Hashable behavior were universal, that would<br>solve many of the common problems people currently have trying to work<br>with heterogeneous containers. In object-oriented frameworks, including<br>Cocoa, Java, and .NET, it is common for the root (NS)Object class to<br>provide default equality and hashing operations. There are of course<br>some tradeoffs:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>- Universal behavior would require us to either generate code for &#39;==&#39;,<br>  &#39;hashValue&#39;, and/or &#39;&lt;&#39; for every type, or provide sufficient<br>  reflection info for a common runtime implementation to do it. The reflection-<br>  based approach may be reasonable for print(), since dumping reflection<br>  info only reduces the quality of the default logging behavior, but<br>  &#39;==&#39; and &#39;hashValue&#39; are more essential to proper behavior, so relying<br>  on reflection might be too slow, and would be brittle when we<br>  introduce the ability to drop reflection info.<br>&gt;&gt;&gt;<br>- Type safety with &#39;==&#39; is important to prevent accidental &#39;1 == &quot;1&quot;&#39;<br>  type comparsions, and a fully generic &#39;func ==&lt;T&gt;(x: T, y: T) -&gt; Bool&#39;<br>  could potentially allow those sorts of mixed-type comparisons by<br>  accident. Language rules that constrained when generic parameters can<br>  be resolved to supertypes might help here.<br>&gt;&gt;&gt;<br>- Function types in Swift do not provide a ready equality operation.<br>  We could provide a default implementation that always returns<br>  &#39;false&#39;, perhaps.<br>&gt;&gt;&gt;<br>- A Comparable ordering can be dreamt up for many types, but it&#39;s not<br>  always a stable ordering, or a desired one. Many people have<br>  complained that &#39;nil &lt; .Some(1)&#39; works for optionals, for instance,<br>  ordering &#39;nil&#39; below Some values. We could use pointer identity to<br>  order class instances and types, but this wouldn&#39;t be a stable<br>  ordering across process runs. That might be good enough for ordered<br>  collections like search trees, but is weaker than what many people<br>  expect &#39;&lt;&#39; to do.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>It&#39;s my feeling that Equatable and Hashable would make a lot of sense as<br>universal operations; I&#39;m not so sure about Comparable.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>-Joe<br>&gt;&gt;&gt;<br>_______________________________________________<br>&gt;&gt;&gt;<br>swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt;<br>swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/b8a8041f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March  8, 2016 at 03:00:00pm</p></header><div class="content"><p>Agreed. There are plenty of systems where == on classes means === by default, and then people forget to override == when they&#39;re making a class type that doesn&#39;t need identity.<br></p><p>(Then again, should such a type be wrapped in a value type in Swift, to communicate that it doesn&#39;t use identity? But then that type will derive ==.)<br></p><p>Making them derivable seems totally reasonable. Today just declaring Equatable or Hashable is enough to do that in the few places where we do derive conformances; we could either do that or invent a new &quot;deriving&quot; syntax.<br></p><p>Jordan<br></p><p><br>&gt; On Mar 8, 2016, at 14:15, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would prefer Equatable and Hashable to remain opt-in, and for us to add better support for automatic deriving of implementation.<br>&gt; <br>&gt; For something like printing the representation of an object to a string, there exists a &quot;not wrong&quot; mapping of every possible value to a string. That is, if my FooStruct doesn&#39;t provide a custom description, having the runtime convert it to something like &quot;(FooStruct instance)&quot; is still a valid mapping. It might not be useful, but it&#39;s not wrong.<br>&gt; <br>&gt; I don&#39;t think the same applies for equatability. The universal default behavior for equating two objects is either correct or incorrect, and it&#39;s not possible to know beforehand which is which. One of the wonderful things about the current Swift system is that (modulo some exceptional cases) only things explicitly meant to be equatable with each other are comparable. We avoid the object-oriented pitfall in which &#39;equality&#39; means two different things - equality of value if you implemented an override properly; a default &#39;equality of instance&#39; otherwise (which might be right or wrong). Of course, the same pitfall wouldn&#39;t necessarily apply in our case, but the problem of having a &#39;default&#39; == impl that allows a developer to falsely assume their type is being properly compared (or not think about it at all) would still be present.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Tue, Mar 8, 2016 at 2:02 PM, Brian Pratt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Definitely a +1 on the basics. When you get inheritance involved, does that complicates things a little bit?<br>&gt; <br>&gt; Let&#39;s say I have a subclass instance that has corresponding fields with a superclass instance. Is it equal to said super-class instance using just member-wise comparisons? Would that be problematic? In Scala you&#39;d often use a reference to an &quot;equality contract&quot; object type in order to get &quot;transitive&quot; equality between subclasses and superclasses, which definitely feels like a step backwards from the current protocol-driven approach.<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Tue, Mar 8, 2016 at 2:54 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; (starting a new thread by DaveA&#39;s request)<br>&gt; <br>&gt; There&#39;s a definition of equality that makes sense as a default for nearly every type in our system:<br>&gt; <br>&gt; - Basic types like IntNN, FloatNN, String, etc. have domain-defined equality,<br>&gt; - Structs and tuples can be considered equal if their corresponding fields are equal,<br>&gt; - Enums can be considered equal if they carry the same, equal payload,<br>&gt; - Class references can be considered equal if they refer to the same instance,<br>&gt; - Metatypes can be considered equal if they represent the same type, and<br>&gt; - Existentials can be considered equal if they carry equal values of the same dynamic type.<br>&gt; <br>&gt; and similarly, reasonable hash code implementations could be synthesized by applying a standard hash combine operation over the components, and a default ordering  could be assigned to values of every type. I think it&#39;s worth considering whether Equatable, Hashable, and/or Comparable, instead of being explicit protocols, should become universal behavior like &#39;print&#39;, with customization points to override the default behavior. If Equatable and Hashable behavior were universal, that would solve many of the common problems people currently have trying to work with heterogeneous containers. In object-oriented frameworks, including Cocoa, Java, and .NET, it is common for the root (NS)Object class to provide default equality and hashing operations. There are of course some tradeoffs:<br>&gt; <br>&gt; - Universal behavior would require us to either generate code for &#39;==&#39;, &#39;hashValue&#39;, and/or &#39;&lt;&#39; for every type, or provide sufficient reflection info for a common runtime implementation to do it. The reflection-based approach may be reasonable for print(), since dumping reflection info only reduces the quality of the default logging behavior, but &#39;==&#39; and &#39;hashValue&#39; are more essential to proper behavior, so relying on reflection might be too slow, and would be brittle when we introduce the ability to drop reflection info.<br>&gt; - Type safety with &#39;==&#39; is important to prevent accidental &#39;1 == &quot;1&quot;&#39; type comparsions, and a fully generic &#39;func ==&lt;T&gt;(x: T, y: T) -&gt; Bool&#39; could potentially allow those sorts of mixed-type comparisons by accident. Language rules that constrained when generic parameters can be resolved to supertypes might help here.<br>&gt; - Function types in Swift do not provide a ready equality operation. We could provide a default implementation that always returns &#39;false&#39;, perhaps.<br>&gt; - A Comparable ordering can be dreamt up for many types, but it&#39;s not always a stable ordering, or a desired one. Many people have complained that &#39;nil &lt; .Some(1)&#39; works for optionals, for instance, ordering &#39;nil&#39; below Some values. We could use pointer identity to order class instances and types, but this wouldn&#39;t be a stable ordering across process runs. That might be good enough for ordered collections like search trees, but is weaker than what many people expect &#39;&lt;&#39; to do.<br>&gt; <br>&gt; It&#39;s my feeling that Equatable and Hashable would make a lot of sense as universal operations; I&#39;m not so sure about Comparable.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/0e2d6396/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  9, 2016 at 01:00:00pm</p></header><div class="content"><p>on Tue Mar 08 2016, Jordan Rose &lt;jordan_rose-AT-apple.com&gt; wrote:<br></p><p>&gt; Agreed. There are plenty of systems where == on classes means === by<br>&gt; default, and then people forget to override == when they&#39;re making a<br>&gt; class type that doesn&#39;t need identity.<br>&gt;<br>&gt; (Then again, should such a type be wrapped in a value type in Swift,<br>&gt; to communicate that it doesn&#39;t use identity? <br></p><p>Yes.<br></p><p>&gt; But then that type will derive ==.)<br></p><p>Yes, but that&#39;s actually fine; its == will be a valid equivalence<br>relation.  If you want something else, define it.<br></p><p>&gt; Making them derivable seems totally reasonable. Today just declaring<br>&gt; Equatable or Hashable is enough to do that in the few places where we<br>&gt; do derive conformances; we could either do that or invent a new<br>&gt; &quot;deriving&quot; syntax.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;&gt; On Mar 8, 2016, at 14:15, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I would prefer Equatable and Hashable to remain opt-in, and for us<br>&gt;&gt; to add better support for automatic deriving of implementation.<br>&gt;&gt; <br>&gt;&gt; For something like printing the representation of an object to a<br>&gt;&gt; string, there exists a &quot;not wrong&quot; mapping of every possible value<br>&gt;&gt; to a string. That is, if my FooStruct doesn&#39;t provide a custom<br>&gt;&gt; description, having the runtime convert it to something like<br>&gt;&gt; &quot;(FooStruct instance)&quot; is still a valid mapping. It might not be<br>&gt;&gt; useful, but it&#39;s not wrong.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think the same applies for equatability. The universal<br>&gt;&gt; default behavior for equating two objects is either correct or<br>&gt;&gt; incorrect, and it&#39;s not possible to know beforehand which is<br>&gt;&gt; which. One of the wonderful things about the current Swift system is<br>&gt;&gt; that (modulo some exceptional cases) only things explicitly meant to<br>&gt;&gt; be equatable with each other are comparable. We avoid the<br>&gt;&gt; object-oriented pitfall in which &#39;equality&#39; means two different<br>&gt;&gt; things - equality of value if you implemented an override properly;<br>&gt;&gt; a default &#39;equality of instance&#39; otherwise (which might be right or<br>&gt;&gt; wrong). Of course, the same pitfall wouldn&#39;t necessarily apply in<br>&gt;&gt; our case, but the problem of having a &#39;default&#39; == impl that allows<br>&gt;&gt; a developer to falsely assume their type is being properly compared<br>&gt;&gt; (or not think about it at all) would still be present.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, Mar 8, 2016 at 2:02 PM, Brian Pratt via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; Definitely a +1 on the basics. When you get inheritance involved, does that complicates things a little bit?<br>&gt;&gt; <br>&gt;&gt; Let&#39;s say I have a subclass instance that has corresponding fields<br>&gt;&gt; with a superclass instance. Is it equal to said super-class instance<br>&gt;&gt; using just member-wise comparisons? Would that be problematic? In<br>&gt;&gt; Scala you&#39;d often use a reference to an &quot;equality contract&quot; object<br>&gt;&gt; type in order to get &quot;transitive&quot; equality between subclasses and<br>&gt;&gt; superclasses, which definitely feels like a step backwards from the<br>&gt;&gt; current protocol-driven approach.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, Mar 8, 2016 at 2:54 PM, Joe Groff via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; (starting a new thread by DaveA&#39;s request)<br>&gt;&gt; <br>&gt;&gt; There&#39;s a definition of equality that makes sense as a default for nearly every type in our system:<br>&gt;&gt; <br>&gt;&gt; - Basic types like IntNN, FloatNN, String, etc. have domain-defined equality,<br>&gt;&gt; - Structs and tuples can be considered equal if their corresponding fields are equal,<br>&gt;&gt; - Enums can be considered equal if they carry the same, equal payload,<br>&gt;&gt; - Class references can be considered equal if they refer to the same instance,<br>&gt;&gt; - Metatypes can be considered equal if they represent the same type, and<br>&gt;&gt; - Existentials can be considered equal if they carry equal values of the same dynamic type.<br>&gt;&gt; <br>&gt;&gt; and similarly, reasonable hash code implementations could be<br>&gt;&gt; synthesized by applying a standard hash combine operation over the<br>&gt;&gt; components, and a default ordering could be assigned to values of<br>&gt;&gt; every type. I think it&#39;s worth considering whether Equatable,<br>&gt;&gt; Hashable, and/or Comparable, instead of being explicit protocols,<br>&gt;&gt; should become universal behavior like &#39;print&#39;, with customization<br>&gt;&gt; points to override the default behavior. If Equatable and Hashable<br>&gt;&gt; behavior were universal, that would solve many of the common<br>&gt;&gt; problems people currently have trying to work with heterogeneous<br>&gt;&gt; containers. In object-oriented frameworks, including Cocoa, Java,<br>&gt;&gt; and .NET, it is common for the root (NS)Object class to provide<br>&gt;&gt; default equality and hashing operations. There are of course some<br>&gt;&gt; tradeoffs:<br>&gt;&gt; <br>&gt;&gt; - Universal behavior would require us to either generate code for<br>&gt;&gt; &#39;==&#39;, &#39;hashValue&#39;, and/or &#39;&lt;&#39; for every type, or provide sufficient<br>&gt;&gt; reflection info for a common runtime implementation to do it. The<br>&gt;&gt; reflection-based approach may be reasonable for print(), since<br>&gt;&gt; dumping reflection info only reduces the quality of the default<br>&gt;&gt; logging behavior, but &#39;==&#39; and &#39;hashValue&#39; are more essential to<br>&gt;&gt; proper behavior, so relying on reflection might be too slow, and<br>&gt;&gt; would be brittle when we introduce the ability to drop reflection<br>&gt;&gt; info.<br>&gt;&gt; - Type safety with &#39;==&#39; is important to prevent accidental &#39;1 ==<br>&gt;&gt; &quot;1&quot;&#39; type comparsions, and a fully generic &#39;func ==&lt;T&gt;(x: T, y: T)<br>&gt;&gt; -&gt; Bool&#39; could potentially allow those sorts of mixed-type<br>&gt;&gt; comparisons by accident. Language rules that constrained when<br>&gt;&gt; generic parameters can be resolved to supertypes might help here.<br>&gt;&gt; - Function types in Swift do not provide a ready equality<br>&gt;&gt; operation. We could provide a default implementation that always<br>&gt;&gt; returns &#39;false&#39;, perhaps.<br>&gt;&gt; - A Comparable ordering can be dreamt up for many types, but it&#39;s<br>&gt;&gt; not always a stable ordering, or a desired one. Many people have<br>&gt;&gt; complained that &#39;nil &lt; .Some(1)&#39; works for optionals, for instance,<br>&gt;&gt; ordering &#39;nil&#39; below Some values. We could use pointer identity to<br>&gt;&gt; order class instances and types, but this wouldn&#39;t be a stable<br>&gt;&gt; ordering across process runs. That might be good enough for ordered<br>&gt;&gt; collections like search trees, but is weaker than what many people<br>&gt;&gt; expect &#39;&lt;&#39; to do.<br>&gt;&gt; <br>&gt;&gt; It&#39;s my feeling that Equatable and Hashable would make a lot of<br>&gt;&gt; sense as universal operations; I&#39;m not so sure about Comparable.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>-Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March  9, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 08 Mar 2016, at 23:15, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would prefer Equatable and Hashable to remain opt-in, and for us to add better support for automatic deriving of implementation.<br></p><p>&gt; On 08 Mar 2016, at 23:57, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I completely agree with Austin here. Automatic derivation (perhaps through the same mechanisms Joe is talking about) would be a nice enhancement, but I find it refreshing and advantageous for simple value types to have very little automatic behavior.<br></p><p>Pedantically I agree with both of you, but from a very pragmatic point of you, I think it&#39;s very important to point out what Joe said about how this could reduce one of the most frustrating aspects of Swift, when people work with heterogeneous arrays and try to conform to Equatable:<br></p><p>&gt; that would solve many of the common problems people currently have trying to work with heterogeneous containers.<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/042cc7fe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>March  9, 2016 at 12:00:00am</p></header><div class="content"><p>As Brent pointed out, adding this sort of support opens a whole can of worms. Large parts of the standard library would silently become unsound.<br></p><p>As well, in my experience people who have had trouble using (e.g.) Equatable with heterogeneous collections are often trying to do type-unsound things. Maybe Swift should support a separate notion of heterogenous equality for comparisons between Equatable types (and one of the POP WWDC talks actually sketched out an outline of how this might be done), but that&#39;s different from making Equatable universal. In addition, I think Swift 3&#39;s proposed support for conditional protocol conformance will make creating principled heterogeneous collections easier, which should ease some of the burden.<br></p><p>Best,<br>Austin<br></p><p>&gt; On Mar 9, 2016, at 12:17 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On 08 Mar 2016, at 23:15, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I would prefer Equatable and Hashable to remain opt-in, and for us to add better support for automatic deriving of implementation.<br>&gt; <br>&gt; On 08 Mar 2016, at 23:57, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I completely agree with Austin here. Automatic derivation (perhaps through the same mechanisms Joe is talking about) would be a nice enhancement, but I find it refreshing and advantageous for simple value types to have very little automatic behavior.<br>&gt; <br>&gt; Pedantically I agree with both of you, but from a very pragmatic point of you, I think it&#39;s very important to point out what Joe said about how this could reduce one of the most frustrating aspects of Swift, when people work with heterogeneous arrays and try to conform to Equatable:<br>&gt; <br>&gt;&gt; that would solve many of the common problems people currently have trying to work with heterogeneous containers.<br>&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/e89413c8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  9, 2016 at 11:00:00am</p></header><div class="content"><p>While I appreciate the idea behind the proposal, I think I’m a -1 to it. Java has required equality and hashable as part of its base Object class, but I frequently encountered classes that had very poor implementations for these, or never bothered to provide one; arguably they didn’t need to, which is fine, but it kind of went against the whole idea.<br></p><p>Swift has some pretty nifty features that also make this redundant, for example, I’ve been working on some ordered collection types; my natural inclination was to require that values be Comparable, however this actually limits the usefulness of the collection (or requires values to be wrapped somehow). Instead I decided to accept values of any type, and also take a closure (same as used to sort an array).<br></p><p>However, with generic constraints I can still provide a default closure for Comparable types like so:<br></p><p>// Sort Comparable elements in ascending order if no closure is provided.<br>extension OrderedCollection where Self.Generator.Element:Comparable {<br>	init&lt;S:SequenceType where S.Generator.Element == Generator.Element&gt;(elements:S) {<br>		self.init(isOrderedBefore: { $0 &lt; $1 }, elements: elements)<br>	}<br>}<br></p><p>(the same feature also lets me implement ArrayLiteralConvertible for Comparable arrays, though I have to provide a default initialiser producing a fatal error for the rest)<br></p><p><br>It’s a bit of a weird thing to get your head around at first, but you can solve a lot of problems in a similar way, without having to place overly strict requirements on the types that you can accept, removing the need for all types to conform to anything.<br></p><p>&gt; On 9 Mar 2016, at 08:30, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As Brent pointed out, adding this sort of support opens a whole can of worms. Large parts of the standard library would silently become unsound.<br>&gt; <br>&gt; As well, in my experience people who have had trouble using (e.g.) Equatable with heterogeneous collections are often trying to do type-unsound things. Maybe Swift should support a separate notion of heterogenous equality for comparisons between Equatable types (and one of the POP WWDC talks actually sketched out an outline of how this might be done), but that&#39;s different from making Equatable universal. In addition, I think Swift 3&#39;s proposed support for conditional protocol conformance will make creating principled heterogeneous collections easier, which should ease some of the burden.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt;&gt; On Mar 9, 2016, at 12:17 AM, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On 08 Mar 2016, at 23:15, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I would prefer Equatable and Hashable to remain opt-in, and for us to add better support for automatic deriving of implementation.<br>&gt;&gt; <br>&gt;&gt; On 08 Mar 2016, at 23:57, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I completely agree with Austin here. Automatic derivation (perhaps through the same mechanisms Joe is talking about) would be a nice enhancement, but I find it refreshing and advantageous for simple value types to have very little automatic behavior.<br>&gt;&gt; <br>&gt;&gt; Pedantically I agree with both of you, but from a very pragmatic point of you, I think it&#39;s very important to point out what Joe said about how this could reduce one of the most frustrating aspects of Swift, when people work with heterogeneous arrays and try to conform to Equatable:<br>&gt;&gt; <br>&gt;&gt;&gt; that would solve many of the common problems people currently have trying to work with heterogeneous containers.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/041d4fab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5c9df42e3c293e3cdb5f3e1b34d44ef9?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Step C</string> &lt;schristopher at bignerdranch.com&gt;<p>March  9, 2016 at 08:00:00am</p></header><div class="content"><p>I find it valuable to think explicitly about what equality means for my types, though not so valuable to write a bunch of boilerplate to support it. Derivable or automatic conformances might also carry us further towards users being able to provide their own automagic conformances. <br></p><p>&gt; - Class references can be considered equal if they refer to the same instance,<br></p><p>With opt-in conformance we could potentially have field comparison for classes too. I guess that would still need to be a customization point regardless as neither approach is always the right answer. <br></p><p>&gt; On Mar 9, 2016, at 6:29 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; While I appreciate the idea behind the proposal, I think I’m a -1 to it. Java has required equality and hashable as part of its base Object class, but I frequently encountered classes that had very poor implementations for these, or never bothered to provide one; arguably they didn’t need to, which is fine, but it kind of went against the whole idea.<br>&gt; <br>&gt; Swift has some pretty nifty features that also make this redundant, for example, I’ve been working on some ordered collection types; my natural inclination was to require that values be Comparable, however this actually limits the usefulness of the collection (or requires values to be wrapped somehow). Instead I decided to accept values of any type, and also take a closure (same as used to sort an array).<br>&gt; <br>&gt; However, with generic constraints I can still provide a default closure for Comparable types like so:<br>&gt; <br>&gt; // Sort Comparable elements in ascending order if no closure is provided.<br>&gt; extension OrderedCollection where Self.Generator.Element:Comparable {<br>&gt; 	init&lt;S:SequenceType where S.Generator.Element == Generator.Element&gt;(elements:S) {<br>&gt; 		self.init(isOrderedBefore: { $0 &lt; $1 }, elements: elements)<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; (the same feature also lets me implement ArrayLiteralConvertible for Comparable arrays, though I have to provide a default initialiser producing a fatal error for the rest)<br>&gt; <br>&gt; <br>&gt; It’s a bit of a weird thing to get your head around at first, but you can solve a lot of problems in a similar way, without having to place overly strict requirements on the types that you can accept, removing the need for all types to conform to anything.<br>&gt; <br>&gt;&gt; On 9 Mar 2016, at 08:30, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As Brent pointed out, adding this sort of support opens a whole can of worms. Large parts of the standard library would silently become unsound.<br>&gt;&gt; <br>&gt;&gt; As well, in my experience people who have had trouble using (e.g.) Equatable with heterogeneous collections are often trying to do type-unsound things. Maybe Swift should support a separate notion of heterogenous equality for comparisons between Equatable types (and one of the POP WWDC talks actually sketched out an outline of how this might be done), but that&#39;s different from making Equatable universal. In addition, I think Swift 3&#39;s proposed support for conditional protocol conformance will make creating principled heterogeneous collections easier, which should ease some of the burden.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 9, 2016, at 12:17 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 08 Mar 2016, at 23:15, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would prefer Equatable and Hashable to remain opt-in, and for us to add better support for automatic deriving of implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 08 Mar 2016, at 23:57, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I completely agree with Austin here. Automatic derivation (perhaps through the same mechanisms Joe is talking about) would be a nice enhancement, but I find it refreshing and advantageous for simple value types to have very little automatic behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Pedantically I agree with both of you, but from a very pragmatic point of you, I think it&#39;s very important to point out what Joe said about how this could reduce one of the most frustrating aspects of Swift, when people work with heterogeneous arrays and try to conform to Equatable:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; that would solve many of the common problems people currently have trying to work with heterogeneous containers.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/1ef84ac1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>March  9, 2016 at 11:00:00am</p></header><div class="content"><p>I am +1 on being able to opt in for a derived `hashValue` and an emphatic<br>+1 to the idea of being able to make functions conform to `Equatable` and<br>`Hashable` at all. I agree with the sentiment that it should still be opt<br>in, however.<br></p><p>TJ<br></p><p>On Wed, Mar 9, 2016 at 8:51 AM, Step C via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I find it valuable to think explicitly about what equality means for my<br>&gt; types, though not so valuable to write a bunch of boilerplate to support<br>&gt; it. Derivable or automatic conformances might also carry us further towards<br>&gt; users being able to provide their own automagic conformances.<br>&gt;<br>&gt; - Class references can be considered equal if they refer to the same<br>&gt; instance,<br>&gt;<br>&gt; With opt-in conformance we could potentially have field comparison for<br>&gt; classes too. I guess that would still need to be a customization point<br>&gt; regardless as neither approach is always the right answer.<br>&gt;<br>&gt; On Mar 9, 2016, at 6:29 AM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; While I appreciate the idea behind the proposal, I think I’m a -1 to it.<br>&gt; Java has required equality and hashable as part of its base Object class,<br>&gt; but I frequently encountered classes that had very poor implementations for<br>&gt; these, or never bothered to provide one; arguably they didn’t need to,<br>&gt; which is fine, but it kind of went against the whole idea.<br>&gt;<br>&gt; Swift has some pretty nifty features that also make this redundant, for<br>&gt; example, I’ve been working on some ordered collection types; my natural<br>&gt; inclination was to require that values be Comparable, however this actually<br>&gt; limits the usefulness of the collection (or requires values to be wrapped<br>&gt; somehow). Instead I decided to accept values of any type, and also take a<br>&gt; closure (same as used to sort an array).<br>&gt;<br>&gt; However, with generic constraints I can still provide a default closure<br>&gt; for Comparable types like so:<br>&gt;<br>&gt; // Sort Comparable elements in ascending order if no closure is provided.<br>&gt; extension OrderedCollection where Self.Generator.Element:Comparable {<br>&gt; init&lt;S:SequenceType where S.Generator.Element ==<br>&gt; Generator.Element&gt;(elements:S) {<br>&gt; self.init(isOrderedBefore: { $0 &lt; $1 }, elements: elements)<br>&gt; }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; (the same feature also lets me implement ArrayLiteralConvertible for<br>&gt; Comparable arrays, though I have to provide a default initialiser producing<br>&gt; a fatal error for the rest)<br>&gt;<br>&gt;<br>&gt; It’s a bit of a weird thing to get your head around at first, but you can<br>&gt; solve a lot of problems in a similar way, without having to place overly<br>&gt; strict requirements on the types that you can accept, removing the need for<br>&gt; all types to conform to anything.<br>&gt;<br>&gt; On 9 Mar 2016, at 08:30, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; As Brent pointed out, adding this sort of support opens a whole can of<br>&gt; worms. Large parts of the standard library would silently become unsound.<br>&gt;<br>&gt; As well, in my experience people who have had trouble using (e.g.)<br>&gt; Equatable with heterogeneous collections are often trying to do<br>&gt; type-unsound things. Maybe Swift should support a separate notion of<br>&gt; heterogenous equality for comparisons between Equatable types (and one of<br>&gt; the POP WWDC talks actually sketched out an outline of how this might be<br>&gt; done), but that&#39;s different from making Equatable universal. In addition, I<br>&gt; think Swift 3&#39;s proposed support for conditional protocol conformance will<br>&gt; make creating principled heterogeneous collections easier, which should<br>&gt; ease some of the burden.<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt; On Mar 9, 2016, at 12:17 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 08 Mar 2016, at 23:15, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I would prefer Equatable and Hashable to remain opt-in, and for us to add<br>&gt; better support for automatic deriving of implementation.<br>&gt;<br>&gt;<br>&gt; On 08 Mar 2016, at 23:57, Zach Waldowski via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I completely agree with Austin here. Automatic derivation (perhaps through<br>&gt; the same mechanisms Joe is talking about) would be a nice enhancement, but<br>&gt; I find it refreshing and advantageous for simple value types to have very<br>&gt; little automatic behavior.<br>&gt;<br>&gt;<br>&gt; Pedantically I agree with both of you, but from a very pragmatic point of<br>&gt; you, I think it&#39;s very important to point out what Joe said about how this<br>&gt; could reduce one of the most frustrating aspects of Swift, when people work<br>&gt; with heterogeneous arrays and try to conform to Equatable:<br>&gt;<br>&gt; that would solve many of the common problems people currently have trying<br>&gt; to work with heterogeneous containers.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/95c2d82d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0ab9e40f73106b42eaa9724c02b6ad8?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Simon Pilkington</string> &lt;simonmpilkington at icloud.com&gt;<p>March  9, 2016 at 08:00:00am</p></header><div class="content"><p>Generally a -1 here. We have to be very careful.<br></p><p>Take Java as a worst case example; very object is hashable and it makes hashability almost meaningless as a constraint. Did the object actually implement a hash function appropriate to itself or is it relying on the default implementation? Any mechanism using hashability is at best fragile. This can get particularly difficult when the hashing usage of the class is behind an api and the class implementer has to understand that - despite not being required by the compiler - they need to provide an acceptable override of the hashing mechanism.<br></p><p>Java’s default hash function will only succeed against the exact same instance and this was probably chosen because it is very conservative and has no performance implications. But it is almost always not what a object that actually requires to be hashable will want.<br></p><p>So it comes down to the default implementation and I would argue that it might be impossible to provide a default implementation good enough particularly when you consider performance. The alternative to Java’s conservative same-instance hashability is some kind of memberwise implementation which could silently become a very expensive calculation (maybe unnecessarily so and even then might not accurately represent the hashablity/equality of the instance).<br></p><p>I think there could be some potential to provide a way to annotate a type to indicate what members should make up the hash/equality (and if they are all immutable, the hash could be pre-computed on instantiation) to avoid having to write boilerplate but it shouldn’t be an innate feature every type.<br></p><p>-Simon<br></p><p><br>&gt; On 9 Mar 2016, at 5:51 AM, Step C via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I find it valuable to think explicitly about what equality means for my types, though not so valuable to write a bunch of boilerplate to support it. Derivable or automatic conformances might also carry us further towards users being able to provide their own automagic conformances. <br>&gt; <br>&gt;&gt; - Class references can be considered equal if they refer to the same instance,<br>&gt; <br>&gt; With opt-in conformance we could potentially have field comparison for classes too. I guess that would still need to be a customization point regardless as neither approach is always the right answer. <br>&gt; <br>&gt; On Mar 9, 2016, at 6:29 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; While I appreciate the idea behind the proposal, I think I’m a -1 to it. Java has required equality and hashable as part of its base Object class, but I frequently encountered classes that had very poor implementations for these, or never bothered to provide one; arguably they didn’t need to, which is fine, but it kind of went against the whole idea.<br>&gt;&gt; <br>&gt;&gt; Swift has some pretty nifty features that also make this redundant, for example, I’ve been working on some ordered collection types; my natural inclination was to require that values be Comparable, however this actually limits the usefulness of the collection (or requires values to be wrapped somehow). Instead I decided to accept values of any type, and also take a closure (same as used to sort an array).<br>&gt;&gt; <br>&gt;&gt; However, with generic constraints I can still provide a default closure for Comparable types like so:<br>&gt;&gt; <br>&gt;&gt; // Sort Comparable elements in ascending order if no closure is provided.<br>&gt;&gt; extension OrderedCollection where Self.Generator.Element:Comparable {<br>&gt;&gt; 	init&lt;S:SequenceType where S.Generator.Element == Generator.Element&gt;(elements:S) {<br>&gt;&gt; 		self.init(isOrderedBefore: { $0 &lt; $1 }, elements: elements)<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; (the same feature also lets me implement ArrayLiteralConvertible for Comparable arrays, though I have to provide a default initialiser producing a fatal error for the rest)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It’s a bit of a weird thing to get your head around at first, but you can solve a lot of problems in a similar way, without having to place overly strict requirements on the types that you can accept, removing the need for all types to conform to anything.<br>&gt;&gt; <br>&gt;&gt;&gt; On 9 Mar 2016, at 08:30, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As Brent pointed out, adding this sort of support opens a whole can of worms. Large parts of the standard library would silently become unsound.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As well, in my experience people who have had trouble using (e.g.) Equatable with heterogeneous collections are often trying to do type-unsound things. Maybe Swift should support a separate notion of heterogenous equality for comparisons between Equatable types (and one of the POP WWDC talks actually sketched out an outline of how this might be done), but that&#39;s different from making Equatable universal. In addition, I think Swift 3&#39;s proposed support for conditional protocol conformance will make creating principled heterogeneous collections easier, which should ease some of the burden.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 9, 2016, at 12:17 AM, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 08 Mar 2016, at 23:15, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would prefer Equatable and Hashable to remain opt-in, and for us to add better support for automatic deriving of implementation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 08 Mar 2016, at 23:57, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I completely agree with Austin here. Automatic derivation (perhaps through the same mechanisms Joe is talking about) would be a nice enhancement, but I find it refreshing and advantageous for simple value types to have very little automatic behavior.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Pedantically I agree with both of you, but from a very pragmatic point of you, I think it&#39;s very important to point out what Joe said about how this could reduce one of the most frustrating aspects of Swift, when people work with heterogeneous arrays and try to conform to Equatable:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; that would solve many of the common problems people currently have trying to work with heterogeneous containers.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/bf04cbb6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 11, 2016 at 06:00:00am</p></header><div class="content"><p>I agree with Austin.<br>-1 to universal equality<br></p><p>-Thorsten <br></p><p>&gt; Am 08.03.2016 um 23:15 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I would prefer Equatable and Hashable to remain opt-in, and for us to add better support for automatic deriving of implementation.<br>&gt; <br>&gt; For something like printing the representation of an object to a string, there exists a &quot;not wrong&quot; mapping of every possible value to a string. That is, if my FooStruct doesn&#39;t provide a custom description, having the runtime convert it to something like &quot;(FooStruct instance)&quot; is still a valid mapping. It might not be useful, but it&#39;s not wrong.<br>&gt; <br>&gt; I don&#39;t think the same applies for equatability. The universal default behavior for equating two objects is either correct or incorrect, and it&#39;s not possible to know beforehand which is which. One of the wonderful things about the current Swift system is that (modulo some exceptional cases) only things explicitly meant to be equatable with each other are comparable. We avoid the object-oriented pitfall in which &#39;equality&#39; means two different things - equality of value if you implemented an override properly; a default &#39;equality of instance&#39; otherwise (which might be right or wrong). Of course, the same pitfall wouldn&#39;t necessarily apply in our case, but the problem of having a &#39;default&#39; == impl that allows a developer to falsely assume their type is being properly compared (or not think about it at all) would still be present.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Tue, Mar 8, 2016 at 2:02 PM, Brian Pratt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Definitely a +1 on the basics. When you get inheritance involved, does that complicates things a little bit?<br>&gt;&gt; <br>&gt;&gt; Let&#39;s say I have a subclass instance that has corresponding fields with a superclass instance. Is it equal to said super-class instance using just member-wise comparisons? Would that be problematic? In Scala you&#39;d often use a reference to an &quot;equality contract&quot; object type in order to get &quot;transitive&quot; equality between subclasses and superclasses, which definitely feels like a step backwards from the current protocol-driven approach.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, Mar 8, 2016 at 2:54 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; (starting a new thread by DaveA&#39;s request)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There&#39;s a definition of equality that makes sense as a default for nearly every type in our system:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Basic types like IntNN, FloatNN, String, etc. have domain-defined equality,<br>&gt;&gt;&gt; - Structs and tuples can be considered equal if their corresponding fields are equal,<br>&gt;&gt;&gt; - Enums can be considered equal if they carry the same, equal payload,<br>&gt;&gt;&gt; - Class references can be considered equal if they refer to the same instance,<br>&gt;&gt;&gt; - Metatypes can be considered equal if they represent the same type, and<br>&gt;&gt;&gt; - Existentials can be considered equal if they carry equal values of the same dynamic type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and similarly, reasonable hash code implementations could be synthesized by applying a standard hash combine operation over the components, and a default ordering  could be assigned to values of every type. I think it&#39;s worth considering whether Equatable, Hashable, and/or Comparable, instead of being explicit protocols, should become universal behavior like &#39;print&#39;, with customization points to override the default behavior. If Equatable and Hashable behavior were universal, that would solve many of the common problems people currently have trying to work with heterogeneous containers. In object-oriented frameworks, including Cocoa, Java, and .NET, it is common for the root (NS)Object class to provide default equality and hashing operations. There are of course some tradeoffs:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Universal behavior would require us to either generate code for &#39;==&#39;, &#39;hashValue&#39;, and/or &#39;&lt;&#39; for every type, or provide sufficient reflection info for a common runtime implementation to do it. The reflection-based approach may be reasonable for print(), since dumping reflection info only reduces the quality of the default logging behavior, but &#39;==&#39; and &#39;hashValue&#39; are more essential to proper behavior, so relying on reflection might be too slow, and would be brittle when we introduce the ability to drop reflection info.<br>&gt;&gt;&gt; - Type safety with &#39;==&#39; is important to prevent accidental &#39;1 == &quot;1&quot;&#39; type comparsions, and a fully generic &#39;func ==&lt;T&gt;(x: T, y: T) -&gt; Bool&#39; could potentially allow those sorts of mixed-type comparisons by accident. Language rules that constrained when generic parameters can be resolved to supertypes might help here.<br>&gt;&gt;&gt; - Function types in Swift do not provide a ready equality operation. We could provide a default implementation that always returns &#39;false&#39;, perhaps.<br>&gt;&gt;&gt; - A Comparable ordering can be dreamt up for many types, but it&#39;s not always a stable ordering, or a desired one. Many people have complained that &#39;nil &lt; .Some(1)&#39; works for optionals, for instance, ordering &#39;nil&#39; below Some values. We could use pointer identity to order class instances and types, but this wouldn&#39;t be a stable ordering across process runs. That might be good enough for ordered collections like search trees, but is weaker than what many people expect &#39;&lt;&#39; to do.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s my feeling that Equatable and Hashable would make a lot of sense as universal operations; I&#39;m not so sure about Comparable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160311/1293d9d4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  9, 2016 at 11:00:00am</p></header><div class="content"><p>on Tue Mar 08 2016, Brian Pratt &lt;brian-AT-pratt.io&gt; wrote:<br></p><p>&gt; Definitely a +1 on the basics. When you get inheritance involved, does that<br>&gt; complicates things a little bit?<br>&gt;<br>&gt; Let&#39;s say I have a subclass instance that has corresponding fields with a<br>&gt; superclass instance. Is it equal to said super-class instance using just<br>&gt; member-wise comparisons? Would that be problematic? <br></p><p>No and yes, most of the time.<br></p><p>The default for classes would be to compare identity; problem solved :-).<br></p><p>&gt; In Scala you&#39;d often use a reference to an &quot;equality contract&quot; object<br>&gt; type in order to get &quot;transitive&quot; equality between subclasses and<br>&gt; superclasses, which definitely feels like a step backwards from the<br>&gt; current protocol-driven approach.<br>&gt;<br>&gt; On Tue, Mar 8, 2016 at 2:54 PM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; (starting a new thread by DaveA&#39;s request)<br>&gt;&gt;<br>&gt;&gt; There&#39;s a definition of equality that makes sense as a default for nearly<br>&gt;&gt; every type in our system:<br>&gt;&gt;<br>&gt;&gt; - Basic types like IntNN, FloatNN, String, etc. have domain-defined<br>&gt;&gt; equality,<br>&gt;&gt; - Structs and tuples can be considered equal if their corresponding fields<br>&gt;&gt; are equal,<br>&gt;&gt; - Enums can be considered equal if they carry the same, equal payload,<br>&gt;&gt; - Class references can be considered equal if they refer to the same<br>&gt;&gt; instance,<br>&gt;&gt; - Metatypes can be considered equal if they represent the same type, and<br>&gt;&gt; - Existentials can be considered equal if they carry equal values of the<br>&gt;&gt; same dynamic type.<br>&gt;&gt;<br>&gt;&gt; and similarly, reasonable hash code implementations could be synthesized<br>&gt;&gt; by applying a standard hash combine operation over the components, and a<br>&gt;&gt; default ordering  could be assigned to values of every type. I think it&#39;s<br>&gt;&gt; worth considering whether Equatable, Hashable, and/or Comparable, instead<br>&gt;&gt; of being explicit protocols, should become universal behavior like &#39;print&#39;,<br>&gt;&gt; with customization points to override the default behavior. If Equatable<br>&gt;&gt; and Hashable behavior were universal, that would solve many of the common<br>&gt;&gt; problems people currently have trying to work with heterogeneous<br>&gt;&gt; containers. In object-oriented frameworks, including Cocoa, Java, and .NET,<br>&gt;&gt; it is common for the root (NS)Object class to provide default equality and<br>&gt;&gt; hashing operations. There are of course some tradeoffs:<br>&gt;&gt;<br>&gt;&gt; - Universal behavior would require us to either generate code for &#39;==&#39;,<br>&gt;&gt; &#39;hashValue&#39;, and/or &#39;&lt;&#39; for every type, or provide sufficient reflection<br>&gt;&gt; info for a common runtime implementation to do it. The reflection-based<br>&gt;&gt; approach may be reasonable for print(), since dumping reflection info only<br>&gt;&gt; reduces the quality of the default logging behavior, but &#39;==&#39; and<br>&gt;&gt; &#39;hashValue&#39; are more essential to proper behavior, so relying on reflection<br>&gt;&gt; might be too slow, and would be brittle when we introduce the ability to<br>&gt;&gt; drop reflection info.<br>&gt;&gt; - Type safety with &#39;==&#39; is important to prevent accidental &#39;1 == &quot;1&quot;&#39; type<br>&gt;&gt; comparsions, and a fully generic &#39;func ==&lt;T&gt;(x: T, y: T) -&gt; Bool&#39; could<br>&gt;&gt; potentially allow those sorts of mixed-type comparisons by accident.<br>&gt;&gt; Language rules that constrained when generic parameters can be resolved to<br>&gt;&gt; supertypes might help here.<br>&gt;&gt; - Function types in Swift do not provide a ready equality operation. We<br>&gt;&gt; could provide a default implementation that always returns &#39;false&#39;, perhaps.<br>&gt;&gt; - A Comparable ordering can be dreamt up for many types, but it&#39;s not<br>&gt;&gt; always a stable ordering, or a desired one. Many people have complained<br>&gt;&gt; that &#39;nil &lt; .Some(1)&#39; works for optionals, for instance, ordering &#39;nil&#39;<br>&gt;&gt; below Some values. We could use pointer identity to order class instances<br>&gt;&gt; and types, but this wouldn&#39;t be a stable ordering across process runs. That<br>&gt;&gt; might be good enough for ordered collections like search trees, but is<br>&gt;&gt; weaker than what many people expect &#39;&lt;&#39; to do.<br>&gt;&gt;<br>&gt;&gt; It&#39;s my feeling that Equatable and Hashable would make a lot of sense as<br>&gt;&gt; universal operations; I&#39;m not so sure about Comparable.<br>&gt;&gt;<br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p><p>-- <br>-Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  8, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; - Function types in Swift do not provide a ready equality operation. We could provide a default implementation that always returns &#39;false&#39;, perhaps.<br></p><p>I think this sort of puts the lie to the idea.<br></p><p>We can always provide *a* definition of equality, but I suspect it will often be an *incorrect* definition. That&#39;s why you had to suggest functions should always be false: you cannot (without more effort than you want to spend) provide a correct definition of equality for it.<br></p><p>I mean, imagine what happens if you make functions Equatable and Hashable but with definitions that don&#39;t actually work. Currently, `Set&lt;Void -&gt; Void&gt;` gives you an error:<br></p><p>	error: type &#39;Void -&gt; Void&#39; does not conform to protocol &#39;Hashable&#39;<br></p><p>But with this feature in place, Swift would happily produce a Set of functions which collides endlessly, doesn&#39;t do any uniquing, never says it contains any value you pass into it, and can only remove elements by index. A type that is &quot;never equal&quot; completely breaks Set in practice, and there&#39;s no way for the type system to catch the problem.<br></p><p>If we automatically synthesize a == operator for every type, many of those operators will be incorrect. For instance, anything that includes a cache will be incorrect. Anything that includes a pointer to a buffer and ought to evaluate the buffer&#39;s contents will be incorrect. Anything that includes a closure will be incorrect. Individually, each of these cases is minor, but they multiply and interact with each other until, together, they undermine confidence in ==.<br></p><p>If you explicitly mark things as Equatable, then it is clear that the equality operator on them really does have a sensible definition. But if you can pass anything into ==, you will never know what will actually *work*. If everything&#39;s Equatable, then nothing is.<br></p><p>* * *<br></p><p>Auto-deriving is a different story, though, especially if it&#39;s opt-in (you have to say `deriving Equatable`). There, you presumably have looked at the default semantics and determined they&#39;re appropriate for your type.<br></p><p>But I think it&#39;s clear that derived conformances should eventually be a user-accessible feature. We already derive RawRepresentable and ErrorType on enums. (We also derive initializers on some types, but that&#39;s arguably a separate feature.) I think it&#39;s clear that Swift ∞ ought to allow you to derive protocol conformances; it&#39;s just a matter of scheduling.<br></p><p>So I think that what we ought to do is this:<br></p><p>• Make a best guess at what Swift ∞ would want you to do to invoke the user-specified derivation logic for an arbitrary protocol—implicit derivation or something marked by a keyword.<br>• Think about whether derived conformances of Equatable, Hashable, and/or Comparable are urgent enough that we should implement them before the general feature.<br>• If so, design these features along the lines of what we would expect the eventual user-specified derivation feature to use.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>March  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 8, 2016, at 5:12 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; - Function types in Swift do not provide a ready equality operation. We could provide a default implementation that always returns &#39;false&#39;, perhaps.<br>&gt; <br>&gt; I think this sort of puts the lie to the idea.<br>&gt; <br>&gt; We can always provide *a* definition of equality, but I suspect it will often be an *incorrect* definition. That&#39;s why you had to suggest functions should always be false: you cannot (without more effort than you want to spend) provide a correct definition of equality for it.<br>&gt; <br></p><p>+1 to this. Having come from years of writing C# code, having every type implement Equatable and Hashable just led to a lot of useless magic because there are different definitions of equality and the default implementation was often not what you wanted, or your implementation was accidentally broken but you didn’t realize it.<br></p><p>&gt; <br>&gt; * * *<br>&gt; <br>&gt; Auto-deriving is a different story, though, especially if it&#39;s opt-in (you have to say `deriving Equatable`). There, you presumably have looked at the default semantics and determined they&#39;re appropriate for your type.<br>&gt; <br>&gt; But I think it&#39;s clear that derived conformances should eventually be a user-accessible feature. We already derive RawRepresentable and ErrorType on enums. (We also derive initializers on some types, but that&#39;s arguably a separate feature.) I think it&#39;s clear that Swift ∞ ought to allow you to derive protocol conformances; it&#39;s just a matter of scheduling.<br>&gt; <br>&gt; So I think that what we ought to do is this:<br>&gt; <br>&gt; • Make a best guess at what Swift ∞ would want you to do to invoke the user-specified derivation logic for an arbitrary protocol—implicit derivation or something marked by a keyword.<br>&gt; • Think about whether derived conformances of Equatable, Hashable, and/or Comparable are urgent enough that we should implement them before the general feature.<br>&gt; • If so, design these features along the lines of what we would expect the eventual user-specified derivation feature to use.<br></p><p>We can also allow opt-in by adopting a protocol, eg `struct SimpleStruct: DefaultEquatable`. DefaultEquatable would tell the compiler to auto-generate an equatable implementation. Similar for DefaultHashable.<br></p><p>In the C# world you’d actually do something like this with an attribute. I know user-defined attributes aren’t on the table right now but some more built-in ones would be sufficient: @defaultEquatable, @defaultHashable, etc. <br>They could even take a list of properties to ignore if such a feature were useful: `@defaultEquatable(ignored: [currentDate, randomInt])`.<br></p><p><br>Russ<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>March  9, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; We can also allow opt-in by adopting a protocol, eg `struct SimpleStruct: DefaultEquatable`. DefaultEquatable would tell the compiler to auto-generate an equatable implementation. Similar for DefaultHashable.<br>&gt; <br>&gt; In the C# world you’d actually do something like this with an attribute. I know user-defined attributes aren’t on the table right now but some more built-in ones would be sufficient: @defaultEquatable, @defaultHashable, etc. <br>&gt; They could even take a list of properties to ignore if such a feature were useful: `@defaultEquatable(ignored: [currentDate, randomInt])`.<br></p><p>Might be interesting if you could pass in parameters when you declare conformance, like:<br></p><p>struct MyType : Equatable(default) {}<br></p><p>If “default” was missing, you’d have to supply the relevant ==/equals function or whatever as usual, but if it was there you’d get automatically generated stuff based on documented rules.<br></p><p>Maybe it could even be extensible so you can define protocol extensions that are “named” and only apply if you declare conformance with the relevant name:<br></p><p>protocol Bar {<br>  func barFunction()<br>}<br></p><p>extension Bar(foo) {<br>  func fooFunction() { }<br>}<br></p><p>struct Type1 : Bar(foo) {<br>  func barFunction() {}<br>}<br></p><p>struct Type2 : Bar {<br>  func barFunction() {}<br>}<br></p><p>A Type1 instance would also have a fooFunction(), but a Type2 instance would not.<br></p><p>Using this you could have multiple default implementations defined for the same protocol depending on circumstances.<br></p><p>extension Bar(scenerio1) {<br>  func barFunction() { print(“1”) }<br>}<br></p><p>extension Bar(scenerio2) {<br>  func barFunction() { print(“2&quot;) }<br>}<br></p><p>struct Thing1 : Bar(scenerio1) {}<br>struct Thing2 : Bar(scenerio2) {}<br></p><p>let a: Bar = Thing1()<br>let b: Bar = Thing2()<br></p><p>a.barFunction() -&gt; “1”<br>b.barFunction() -&gt; “2”<br></p><p>:)<br></p><p>l8r<br>Sean<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 10, 2016 at 09:00:00am</p></header><div class="content"><p>Presumably a DefaultValueHashable protocol with default implementation of<br>Hashable and Equatable for value types and similarly DefaultObjectHashable<br>for objects could be provided in the standard library (using some deep<br>integration into the compiler or a to be added reflection ability). Then it<br>would be easy to opt in.<br></p><p>On Thursday, 10 March 2016, Sean Heber via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; We can also allow opt-in by adopting a protocol, eg `struct<br>&gt; SimpleStruct: DefaultEquatable`. DefaultEquatable would tell the compiler<br>&gt; to auto-generate an equatable implementation. Similar for DefaultHashable.<br>&gt; &gt;<br>&gt; &gt; In the C# world you’d actually do something like this with an attribute.<br>&gt; I know user-defined attributes aren’t on the table right now but some more<br>&gt; built-in ones would be sufficient: @defaultEquatable, @defaultHashable, etc.<br>&gt; &gt; They could even take a list of properties to ignore if such a feature<br>&gt; were useful: `@defaultEquatable(ignored: [currentDate, randomInt])`.<br>&gt;<br>&gt; Might be interesting if you could pass in parameters when you declare<br>&gt; conformance, like:<br>&gt;<br>&gt; struct MyType : Equatable(default) {}<br>&gt;<br>&gt; If “default” was missing, you’d have to supply the relevant ==/equals<br>&gt; function or whatever as usual, but if it was there you’d get automatically<br>&gt; generated stuff based on documented rules.<br>&gt;<br>&gt; Maybe it could even be extensible so you can define protocol extensions<br>&gt; that are “named” and only apply if you declare conformance with the<br>&gt; relevant name:<br>&gt;<br>&gt; protocol Bar {<br>&gt;   func barFunction()<br>&gt; }<br>&gt;<br>&gt; extension Bar(foo) {<br>&gt;   func fooFunction() { }<br>&gt; }<br>&gt;<br>&gt; struct Type1 : Bar(foo) {<br>&gt;   func barFunction() {}<br>&gt; }<br>&gt;<br>&gt; struct Type2 : Bar {<br>&gt;   func barFunction() {}<br>&gt; }<br>&gt;<br>&gt; A Type1 instance would also have a fooFunction(), but a Type2 instance<br>&gt; would not.<br>&gt;<br>&gt; Using this you could have multiple default implementations defined for the<br>&gt; same protocol depending on circumstances.<br>&gt;<br>&gt; extension Bar(scenerio1) {<br>&gt;   func barFunction() { print(“1”) }<br>&gt; }<br>&gt;<br>&gt; extension Bar(scenerio2) {<br>&gt;   func barFunction() { print(“2&quot;) }<br>&gt; }<br>&gt;<br>&gt; struct Thing1 : Bar(scenerio1) {}<br>&gt; struct Thing2 : Bar(scenerio2) {}<br>&gt;<br>&gt; let a: Bar = Thing1()<br>&gt; let b: Bar = Thing2()<br>&gt;<br>&gt; a.barFunction() -&gt; “1”<br>&gt; b.barFunction() -&gt; “2”<br>&gt;<br>&gt; :)<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/e892dc24/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  9, 2016 at 01:00:00pm</p></header><div class="content"><p>on Tue Mar 08 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br></p><p>&gt;&gt; - Function types in Swift do not provide a ready equality<br>&gt; operation. We could provide a default implementation that always<br>&gt; returns &#39;false&#39;, perhaps.<br>&gt;<br>&gt; I think this sort of puts the lie to the idea.<br>&gt;<br>&gt; We can always provide *a* definition of equality, but I suspect it<br>&gt; will often be an *incorrect* definition. <br></p><p>I disagree; IMO it would seldom be incorrect.<br>But I wouldn&#39;t necessarily want to make everything equatable.  I&#39;d want<br>to give many things an equatable conformance that&#39;s available simply by<br>declaring it. In fact, I&#39;d like to be able to say:<br></p><p>          struct Something : Regular {<br>              // Stored properties that are all Regular<br>          }<br></p><p>and get Equatable, Comparable, and Hashable for free.<br></p><p>&gt; That&#39;s why you had to suggest functions should always be false: you<br>&gt; cannot (without more effort than you want to spend) provide a correct<br>&gt; definition of equality for it.<br>&gt;<br>&gt; I mean, imagine what happens if you make functions Equatable and<br>&gt; Hashable but with definitions that don&#39;t actually work. Currently,<br>&gt; `Set&lt;Void -&gt; Void&gt;` gives you an error:<br>&gt;<br>&gt; 	error: type &#39;Void -&gt; Void&#39; does not conform to protocol &#39;Hashable&#39;<br>&gt;<br>&gt; But with this feature in place, Swift would happily produce a Set of<br>&gt; functions which collides endlessly, doesn&#39;t do any uniquing, never<br>&gt; says it contains any value you pass into it, and can only remove<br>&gt; elements by index. <br>&gt;<br>&gt; A type that is &quot;never equal&quot; completely breaks Set in practice, and<br>&gt; there&#39;s no way for the type system to catch the problem.<br>&gt;<br>&gt; If we automatically synthesize a == operator for every type, many of<br>&gt; those operators will be incorrect. For instance, anything that<br>&gt; includes a cache will be incorrect. <br>&gt; Anything that includes a pointer to a buffer and ought to evaluate the<br>&gt; buffer&#39;s contents will be incorrect. <br>&gt; Anything that includes a closure will be incorrect. Individually, each<br>&gt; of these cases is minor, but they multiply and interact with each<br>&gt; other until, together, they undermine confidence in ==.<br></p><p>These things wouldn&#39;t be Regular by themselves.  To make them<br>composable, you can create a single Regular value type that wraps each<br>one.<br></p><p>&gt; If you explicitly mark things as Equatable, then it is clear that the<br>&gt; equality operator on them really does have a sensible definition. But<br>&gt; if you can pass anything into ==, you will never know what will<br>&gt; actually *work*. If everything&#39;s Equatable, then nothing is.<br>&gt;<br>&gt; * * *<br>&gt;<br>&gt; Auto-deriving is a different story, though, especially if it&#39;s opt-in<br>&gt; (you have to say `deriving Equatable`). There, you presumably have<br>&gt; looked at the default semantics and determined they&#39;re appropriate for<br>&gt; your type.<br></p><p>I don&#39;t know if that level of explicitness is needed.  Explicit<br>declaration of conformance might be enough.<br></p><p>&gt; But I think it&#39;s clear that derived conformances should eventually be<br>&gt; a user-accessible feature. We already derive RawRepresentable and<br>&gt; ErrorType on enums. (We also derive initializers on some types, but<br>&gt; that&#39;s arguably a separate feature.) I think it&#39;s clear that Swift ∞<br>&gt; ought to allow you to derive protocol conformances; it&#39;s just a matter<br>&gt; of scheduling.<br>&gt;<br>&gt; So I think that what we ought to do is this:<br>&gt;<br>&gt; • Make a best guess at what Swift ∞ would want you to do to invoke the<br>&gt; user-specified derivation logic for an arbitrary protocol—implicit<br>&gt; derivation or something marked by a keyword.<br>&gt; • Think about whether derived conformances of Equatable, Hashable,<br>&gt; and/or Comparable are urgent enough that we should implement them<br>&gt; before the general feature.<br>&gt; • If so, design these features along the lines of what we would expect<br>&gt; the eventual user-specified derivation feature to use.<br></p><p>Of course.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>March  9, 2016 at 01:00:00pm</p></header><div class="content"><p>I think we might (at least partially) be in violent agreement :). Most (if<br>not everyone) on this thread has agreed that painless opt-in<br>auto-conformance is a good thing (&quot;struct Foo : Regular { .. }&quot;), albeit<br>with differing definitions of &#39;painless&#39;. But I maintain that having a<br>&quot;func ==(lhs: Any, rhs: Any) -&gt; Bool&quot; stdlib fallback implementation of ==<br>is a lot of potential pain for very little benefit.<br></p><p>Austin<br></p><p>On Wed, Mar 9, 2016 at 1:17 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Tue Mar 08 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; - Function types in Swift do not provide a ready equality<br>&gt; &gt; operation. We could provide a default implementation that always<br>&gt; &gt; returns &#39;false&#39;, perhaps.<br>&gt; &gt;<br>&gt; &gt; I think this sort of puts the lie to the idea.<br>&gt; &gt;<br>&gt; &gt; We can always provide *a* definition of equality, but I suspect it<br>&gt; &gt; will often be an *incorrect* definition.<br>&gt;<br>&gt; I disagree; IMO it would seldom be incorrect.<br>&gt; But I wouldn&#39;t necessarily want to make everything equatable.  I&#39;d want<br>&gt; to give many things an equatable conformance that&#39;s available simply by<br>&gt; declaring it. In fact, I&#39;d like to be able to say:<br>&gt;<br>&gt;           struct Something : Regular {<br>&gt;               // Stored properties that are all Regular<br>&gt;           }<br>&gt;<br>&gt; and get Equatable, Comparable, and Hashable for free.<br></p><p><br>&gt; &gt; That&#39;s why you had to suggest functions should always be false: you<br>&gt; &gt; cannot (without more effort than you want to spend) provide a correct<br>&gt; &gt; definition of equality for it.<br>&gt; &gt;<br>&gt; &gt; I mean, imagine what happens if you make functions Equatable and<br>&gt; &gt; Hashable but with definitions that don&#39;t actually work. Currently,<br>&gt; &gt; `Set&lt;Void -&gt; Void&gt;` gives you an error:<br>&gt; &gt;<br>&gt; &gt;       error: type &#39;Void -&gt; Void&#39; does not conform to protocol &#39;Hashable&#39;<br>&gt; &gt;<br>&gt; &gt; But with this feature in place, Swift would happily produce a Set of<br>&gt; &gt; functions which collides endlessly, doesn&#39;t do any uniquing, never<br>&gt; &gt; says it contains any value you pass into it, and can only remove<br>&gt; &gt; elements by index.<br>&gt; &gt;<br>&gt; &gt; A type that is &quot;never equal&quot; completely breaks Set in practice, and<br>&gt; &gt; there&#39;s no way for the type system to catch the problem.<br>&gt; &gt;<br>&gt; &gt; If we automatically synthesize a == operator for every type, many of<br>&gt; &gt; those operators will be incorrect. For instance, anything that<br>&gt; &gt; includes a cache will be incorrect.<br>&gt; &gt; Anything that includes a pointer to a buffer and ought to evaluate the<br>&gt; &gt; buffer&#39;s contents will be incorrect.<br>&gt; &gt; Anything that includes a closure will be incorrect. Individually, each<br>&gt; &gt; of these cases is minor, but they multiply and interact with each<br>&gt; &gt; other until, together, they undermine confidence in ==.<br>&gt;<br>&gt; These things wouldn&#39;t be Regular by themselves.  To make them<br>&gt; composable, you can create a single Regular value type that wraps each<br>&gt; one.<br>&gt;<br>&gt; &gt; If you explicitly mark things as Equatable, then it is clear that the<br>&gt; &gt; equality operator on them really does have a sensible definition. But<br>&gt; &gt; if you can pass anything into ==, you will never know what will<br>&gt; &gt; actually *work*. If everything&#39;s Equatable, then nothing is.<br>&gt; &gt;<br>&gt; &gt; * * *<br>&gt; &gt;<br>&gt; &gt; Auto-deriving is a different story, though, especially if it&#39;s opt-in<br>&gt; &gt; (you have to say `deriving Equatable`). There, you presumably have<br>&gt; &gt; looked at the default semantics and determined they&#39;re appropriate for<br>&gt; &gt; your type.<br>&gt;<br>&gt; I don&#39;t know if that level of explicitness is needed.  Explicit<br>&gt; declaration of conformance might be enough.<br>&gt;<br>&gt; &gt; But I think it&#39;s clear that derived conformances should eventually be<br>&gt; &gt; a user-accessible feature. We already derive RawRepresentable and<br>&gt; &gt; ErrorType on enums. (We also derive initializers on some types, but<br>&gt; &gt; that&#39;s arguably a separate feature.) I think it&#39;s clear that Swift ∞<br>&gt; &gt; ought to allow you to derive protocol conformances; it&#39;s just a matter<br>&gt; &gt; of scheduling.<br>&gt; &gt;<br>&gt; &gt; So I think that what we ought to do is this:<br>&gt; &gt;<br>&gt; &gt; • Make a best guess at what Swift ∞ would want you to do to invoke the<br>&gt; &gt; user-specified derivation logic for an arbitrary protocol—implicit<br>&gt; &gt; derivation or something marked by a keyword.<br>&gt; &gt; • Think about whether derived conformances of Equatable, Hashable,<br>&gt; &gt; and/or Comparable are urgent enough that we should implement them<br>&gt; &gt; before the general feature.<br>&gt; &gt; • If so, design these features along the lines of what we would expect<br>&gt; &gt; the eventual user-specified derivation feature to use.<br>&gt;<br>&gt; Of course.<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/0c96fc9c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 11, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; Am 09.03.2016 um 22:34 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I think we might (at least partially) be in violent agreement :). Most (if not everyone) on this thread has agreed that painless opt-in auto-conformance is a good thing (&quot;struct Foo : Regular { .. }&quot;), albeit with differing definitions of &#39;painless&#39;. But I maintain that having a &quot;func ==(lhs: Any, rhs: Any) -&gt; Bool&quot; stdlib fallback implementation of == is a lot of potential pain for very little benefit.<br></p><p>I agree completely. Not having everything comparable with everything is a good thing IMO!<br></p><p>-Thorsten <br></p><p>&gt; <br>&gt; Austin<br>&gt; <br>&gt;&gt; On Wed, Mar 9, 2016 at 1:17 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; on Tue Mar 08 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; - Function types in Swift do not provide a ready equality<br>&gt;&gt; &gt; operation. We could provide a default implementation that always<br>&gt;&gt; &gt; returns &#39;false&#39;, perhaps.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think this sort of puts the lie to the idea.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; We can always provide *a* definition of equality, but I suspect it<br>&gt;&gt; &gt; will often be an *incorrect* definition.<br>&gt;&gt; <br>&gt;&gt; I disagree; IMO it would seldom be incorrect.<br>&gt;&gt; But I wouldn&#39;t necessarily want to make everything equatable.  I&#39;d want<br>&gt;&gt; to give many things an equatable conformance that&#39;s available simply by<br>&gt;&gt; declaring it. In fact, I&#39;d like to be able to say:<br>&gt;&gt; <br>&gt;&gt;           struct Something : Regular {<br>&gt;&gt;               // Stored properties that are all Regular<br>&gt;&gt;           }<br>&gt;&gt; <br>&gt;&gt; and get Equatable, Comparable, and Hashable for free.<br>&gt;&gt; <br>&gt;&gt; &gt; That&#39;s why you had to suggest functions should always be false: you<br>&gt;&gt; &gt; cannot (without more effort than you want to spend) provide a correct<br>&gt;&gt; &gt; definition of equality for it.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I mean, imagine what happens if you make functions Equatable and<br>&gt;&gt; &gt; Hashable but with definitions that don&#39;t actually work. Currently,<br>&gt;&gt; &gt; `Set&lt;Void -&gt; Void&gt;` gives you an error:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       error: type &#39;Void -&gt; Void&#39; does not conform to protocol &#39;Hashable&#39;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; But with this feature in place, Swift would happily produce a Set of<br>&gt;&gt; &gt; functions which collides endlessly, doesn&#39;t do any uniquing, never<br>&gt;&gt; &gt; says it contains any value you pass into it, and can only remove<br>&gt;&gt; &gt; elements by index.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; A type that is &quot;never equal&quot; completely breaks Set in practice, and<br>&gt;&gt; &gt; there&#39;s no way for the type system to catch the problem.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; If we automatically synthesize a == operator for every type, many of<br>&gt;&gt; &gt; those operators will be incorrect. For instance, anything that<br>&gt;&gt; &gt; includes a cache will be incorrect.<br>&gt;&gt; &gt; Anything that includes a pointer to a buffer and ought to evaluate the<br>&gt;&gt; &gt; buffer&#39;s contents will be incorrect.<br>&gt;&gt; &gt; Anything that includes a closure will be incorrect. Individually, each<br>&gt;&gt; &gt; of these cases is minor, but they multiply and interact with each<br>&gt;&gt; &gt; other until, together, they undermine confidence in ==.<br>&gt;&gt; <br>&gt;&gt; These things wouldn&#39;t be Regular by themselves.  To make them<br>&gt;&gt; composable, you can create a single Regular value type that wraps each<br>&gt;&gt; one.<br>&gt;&gt; <br>&gt;&gt; &gt; If you explicitly mark things as Equatable, then it is clear that the<br>&gt;&gt; &gt; equality operator on them really does have a sensible definition. But<br>&gt;&gt; &gt; if you can pass anything into ==, you will never know what will<br>&gt;&gt; &gt; actually *work*. If everything&#39;s Equatable, then nothing is.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; * * *<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Auto-deriving is a different story, though, especially if it&#39;s opt-in<br>&gt;&gt; &gt; (you have to say `deriving Equatable`). There, you presumably have<br>&gt;&gt; &gt; looked at the default semantics and determined they&#39;re appropriate for<br>&gt;&gt; &gt; your type.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know if that level of explicitness is needed.  Explicit<br>&gt;&gt; declaration of conformance might be enough.<br>&gt;&gt; <br>&gt;&gt; &gt; But I think it&#39;s clear that derived conformances should eventually be<br>&gt;&gt; &gt; a user-accessible feature. We already derive RawRepresentable and<br>&gt;&gt; &gt; ErrorType on enums. (We also derive initializers on some types, but<br>&gt;&gt; &gt; that&#39;s arguably a separate feature.) I think it&#39;s clear that Swift ∞<br>&gt;&gt; &gt; ought to allow you to derive protocol conformances; it&#39;s just a matter<br>&gt;&gt; &gt; of scheduling.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; So I think that what we ought to do is this:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; • Make a best guess at what Swift ∞ would want you to do to invoke the<br>&gt;&gt; &gt; user-specified derivation logic for an arbitrary protocol—implicit<br>&gt;&gt; &gt; derivation or something marked by a keyword.<br>&gt;&gt; &gt; • Think about whether derived conformances of Equatable, Hashable,<br>&gt;&gt; &gt; and/or Comparable are urgent enough that we should implement them<br>&gt;&gt; &gt; before the general feature.<br>&gt;&gt; &gt; • If so, design these features along the lines of what we would expect<br>&gt;&gt; &gt; the eventual user-specified derivation feature to use.<br>&gt;&gt; <br>&gt;&gt; Of course.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160311/fb7f16ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>March 10, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Mar 10, 2016, at 9:58 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Am 09.03.2016 um 22:34 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; I think we might (at least partially) be in violent agreement :). Most (if not everyone) on this thread has agreed that painless opt-in auto-conformance is a good thing (&quot;struct Foo : Regular { .. }&quot;), albeit with differing definitions of &#39;painless&#39;. But I maintain that having a &quot;func ==(lhs: Any, rhs: Any) -&gt; Bool&quot; stdlib fallback implementation of == is a lot of potential pain for very little benefit.<br>&gt; <br>&gt; I agree completely. Not having everything comparable with everything is a good thing IMO!<br>&gt; <br></p><p>I can’t tell if I misunderstood Joe&#39;s original proposal, but I don’t think the suggestion was to have everything comparable to everything, but to have any type comparable with itself by default.  I’m against everything being comparable with everything else, but for having a default equality for every type with itself.<br></p><p>To re-state:<br></p><p>-1 to: func ==(lhs: Any, rhs: Any) -&gt; Bool<br>+1 to: func ==&lt;T&gt; (lhs: T, rhs: T) -&gt; Bool<br></p><p>- Will<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/d5992c30/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>March 10, 2016 at 10:00:00pm</p></header><div class="content"><p>I took Joe&#39;s points about making it easier to work with heterogeneous collections to refer to heterogeneous comparison.<br></p><p>I&#39;m still -1 to &quot;func ==&lt;T&gt;(lhs: T, rhs: T) -&gt; Bool&quot;, but for the reasons Brent brought up earlier. If adding a default conformance can be made &quot;as easy as&quot; declaring conformance to &quot;Equatable&quot; without an explicit impl (or declaring conformance to &quot;Regular&quot; or &quot;#derives(Equatable)&quot; or ...), I see that as the preferable option:<br></p><p>- The amount of inconvenience it gives the programmer is negligible - one conformance declaration for each custom type that deserves to be equatable, and no function or operator code.<br>- Declaring it explicitly is a flag that the programmer has intentionally decided that this type should be equatable under whatever common-sense default rules the compiler uses for the type&#39;s &#39;kind&#39;. This is especially important for APIs being vended out, whose implementations might be opaque to the user.<br>- Declaring a universal homogenous equality operator that works for types for which equality makes no sense (or there&#39;s no clear definition) is actively hostile to users of the language (to go back to Brent&#39;s point, &quot;why is my Set&lt;() -&gt; Int&gt; broken when I try using it?&quot;)<br></p><p>Austin<br></p><p>&gt; On Mar 10, 2016, at 10:21 PM, William Dillon &lt;william at housedillon.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 10, 2016, at 9:58 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Am 09.03.2016 um 22:34 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; I think we might (at least partially) be in violent agreement :). Most (if not everyone) on this thread has agreed that painless opt-in auto-conformance is a good thing (&quot;struct Foo : Regular { .. }&quot;), albeit with differing definitions of &#39;painless&#39;. But I maintain that having a &quot;func ==(lhs: Any, rhs: Any) -&gt; Bool&quot; stdlib fallback implementation of == is a lot of potential pain for very little benefit.<br>&gt;&gt; <br>&gt;&gt; I agree completely. Not having everything comparable with everything is a good thing IMO!<br>&gt;&gt; <br>&gt; <br>&gt; I can’t tell if I misunderstood Joe&#39;s original proposal, but I don’t think the suggestion was to have everything comparable to everything, but to have any type comparable with itself by default.  I’m against everything being comparable with everything else, but for having a default equality for every type with itself.<br>&gt; <br>&gt; To re-state:<br>&gt; <br>&gt; -1 to: func ==(lhs: Any, rhs: Any) -&gt; Bool<br>&gt; +1 to: func ==&lt;T&gt; (lhs: T, rhs: T) -&gt; Bool<br>&gt; <br>&gt; - Will<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/06f95b3e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  9, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt;&gt; Auto-deriving is a different story, though, especially if it&#39;s opt-in<br>&gt;&gt; (you have to say `deriving Equatable`). There, you presumably have<br>&gt;&gt; looked at the default semantics and determined they&#39;re appropriate for<br>&gt;&gt; your type.<br>&gt; <br>&gt; I don&#39;t know if that level of explicitness is needed.  Explicit<br>&gt; declaration of conformance might be enough.<br></p><p>I don&#39;t know if it&#39;s necessary either. What I&#39;m saying is that if it *is* that explicit, it&#39;s a slam dunk; if it&#39;s *not* that explicit, it&#39;s a little more uncertain, but probably still a good idea.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  9, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Mar 9, 2016, at 5:57 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Auto-deriving is a different story, though, especially if it&#39;s opt-in<br>&gt;&gt;&gt; (you have to say `deriving Equatable`). There, you presumably have<br>&gt;&gt;&gt; looked at the default semantics and determined they&#39;re appropriate for<br>&gt;&gt;&gt; your type.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know if that level of explicitness is needed.  Explicit<br>&gt;&gt; declaration of conformance might be enough.<br>&gt; <br>&gt; I don&#39;t know if it&#39;s necessary either. What I&#39;m saying is that if it *is* that explicit, it&#39;s a slam dunk; if it&#39;s *not* that explicit, it&#39;s a little more uncertain, but probably still a good idea.<br></p><p>IMO, since you can already get &quot;implicitly derived&quot; default implementations from a protocol extension simply by declaring conformance to a protocol, it would be consistent to only require a conformance declaration to access compiler-derived implementations. One could imagine Swift Pro 6s Plus having enough fancy generics features to provide the default implementations of Equatable, Hashable, etc. as protocol extensions.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>March  9, 2016 at 08:00:00am</p></header><div class="content"><p>I’m +1 to this idea for Hashable and Equatable. <br></p><p>I really hate writing hashValue implementations, and equality is something that I wouldn’t miss.  The way Joe proposes these would be implemented is already very close to what I do anyway.  I don’t see how it would have a negative effect on existing code.  Existing code that uses ‘==‘ or ‘hashValue&#39; necessarily implements these functions, and they would override the default implementation.<br></p><p>It seems to me that the biggest risk would be if you try to compare two instances (using ==, for example) and you haven’t overridden the default implementation.  If you have a weird type, and get unexpected behavior, it may be hard to remember that ‘==‘ might be to blame.  With the current status quo, Swift would just say “no” and you’d be on your way to writing a new implementation.  With this proposal, it might take a bit more time to understand what’s happening.  However, I doubt that the comparison of (really?) weird types are very frequent.  Furthermore, if you do have something that is that weird, as you’re typing “==“ you’re probably thinking “This is a really weird type, I should probably make sure that the default ‘==‘ makes sense.”<br></p><p>In my opinion, making it opt-in would introduce relatively weird or inelegant syntax to mark your type as opting into the behavior.  I’d rather allow for overridden behavior.<br></p><p>Finally, I don’t think Comparable is a good idea for this. <br></p><p>- Will<br></p><p>&gt; On Mar 8, 2016, at 12:54 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; (starting a new thread by DaveA&#39;s request)<br>&gt; <br>&gt; There&#39;s a definition of equality that makes sense as a default for nearly every type in our system:<br>&gt; <br>&gt; - Basic types like IntNN, FloatNN, String, etc. have domain-defined equality,<br>&gt; - Structs and tuples can be considered equal if their corresponding fields are equal,<br>&gt; - Enums can be considered equal if they carry the same, equal payload,<br>&gt; - Class references can be considered equal if they refer to the same instance,<br>&gt; - Metatypes can be considered equal if they represent the same type, and<br>&gt; - Existentials can be considered equal if they carry equal values of the same dynamic type.<br>&gt; <br>&gt; and similarly, reasonable hash code implementations could be synthesized by applying a standard hash combine operation over the components, and a default ordering  could be assigned to values of every type. I think it&#39;s worth considering whether Equatable, Hashable, and/or Comparable, instead of being explicit protocols, should become universal behavior like &#39;print&#39;, with customization points to override the default behavior. If Equatable and Hashable behavior were universal, that would solve many of the common problems people currently have trying to work with heterogeneous containers. In object-oriented frameworks, including Cocoa, Java, and .NET, it is common for the root (NS)Object class to provide default equality and hashing operations. There are of course some tradeoffs:<br>&gt; <br>&gt; - Universal behavior would require us to either generate code for &#39;==&#39;, &#39;hashValue&#39;, and/or &#39;&lt;&#39; for every type, or provide sufficient reflection info for a common runtime implementation to do it. The reflection-based approach may be reasonable for print(), since dumping reflection info only reduces the quality of the default logging behavior, but &#39;==&#39; and &#39;hashValue&#39; are more essential to proper behavior, so relying on reflection might be too slow, and would be brittle when we introduce the ability to drop reflection info.<br>&gt; - Type safety with &#39;==&#39; is important to prevent accidental &#39;1 == &quot;1&quot;&#39; type comparsions, and a fully generic &#39;func ==&lt;T&gt;(x: T, y: T) -&gt; Bool&#39; could potentially allow those sorts of mixed-type comparisons by accident. Language rules that constrained when generic parameters can be resolved to supertypes might help here.<br>&gt; - Function types in Swift do not provide a ready equality operation. We could provide a default implementation that always returns &#39;false&#39;, perhaps.<br>&gt; - A Comparable ordering can be dreamt up for many types, but it&#39;s not always a stable ordering, or a desired one. Many people have complained that &#39;nil &lt; .Some(1)&#39; works for optionals, for instance, ordering &#39;nil&#39; below Some values. We could use pointer identity to order class instances and types, but this wouldn&#39;t be a stable ordering across process runs. That might be good enough for ordered collections like search trees, but is weaker than what many people expect &#39;&lt;&#39; to do.<br>&gt; <br>&gt; It&#39;s my feeling that Equatable and Hashable would make a lot of sense as universal operations; I&#39;m not so sure about Comparable.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  9, 2016 at 11:00:00am</p></header><div class="content"><p>on Tue Mar 08 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br></p><p>&gt; (starting a new thread by DaveA&#39;s request)<br>&gt;<br>&gt; There&#39;s a definition of equality that makes sense as a default for nearly every type in our system:<br>&gt;<br>&gt; - Basic types like IntNN, FloatNN, String, etc. have domain-defined<br>&gt; equality,<br></p><p>But floats, as ever, are weird because their domain equality isn&#39;t an<br>equivalence relation.  Just one of the many little issues to be worked<br>out ;-).<br></p><p>&gt; - Structs and tuples can be considered equal if their corresponding fields are equal,<br>&gt; - Enums can be considered equal if they carry the same, equal payload,<br>&gt; - Class references can be considered equal if they refer to the same instance,<br>&gt; - Metatypes can be considered equal if they represent the same type, and<br>&gt; - Existentials can be considered equal if they carry equal values of the same dynamic type.<br>&gt;<br>&gt; and similarly, reasonable hash code implementations could be<br>&gt; synthesized by applying a standard hash combine operation over the<br>&gt; components, and a default ordering could be assigned to values of<br>&gt; every type. I think it&#39;s worth considering whether Equatable,<br>&gt; Hashable, and/or Comparable, instead of being explicit protocols,<br>&gt; should become universal behavior like &#39;print&#39;, with customization<br>&gt; points to override the default behavior. <br></p><p>Yes, please, let&#39;s consider that.  If the default behavior is going to<br>be a reasonable correct behavior 95% of the time (which IMO it is), this<br>will increase interoperability and decrease boilerplate.<br></p><p>I think because of the tight relationship between ==, copying, and<br>assignment, this discussion probably drags in the issues of:<br></p><p>* how to constrain generic parameters to having value semantics<br>* how to universally clone/assign mutable instances<br>* one more I thought of that slipped my mind; it&#39;ll come back to me.<br></p><p>&gt; If Equatable and Hashable behavior were universal, that would solve<br>&gt; many of the common problems people currently have trying to work with<br>&gt; heterogeneous containers. In object-oriented frameworks, including<br>&gt; Cocoa, Java, and .NET, it is common for the root (NS)Object class to<br>&gt; provide default equality and hashing operations. There are of course<br>&gt; some tradeoffs:<br>&gt;<br>&gt; - Universal behavior would require us to either generate code for<br>&gt; &#39;==&#39;, &#39;hashValue&#39;, and/or &#39;&lt;&#39; for every type, or provide sufficient<br>&gt; reflection info for a common runtime implementation to do it. The<br>&gt; reflection-based approach may be reasonable for print(), since dumping<br>&gt; reflection info only reduces the quality of the default logging<br>&gt; behavior, but &#39;==&#39; and &#39;hashValue&#39; are more essential to proper<br>&gt; behavior, so relying on reflection might be too slow, and would be<br>&gt; brittle when we introduce the ability to drop reflection info.<br>&gt; - Type safety with &#39;==&#39; is important to prevent accidental &#39;1 == &quot;1&quot;&#39;<br>&gt; type comparsions, and a fully generic &#39;func ==&lt;T&gt;(x: T, y: T) -&gt; Bool&#39;<br>&gt; could potentially allow those sorts of mixed-type comparisons by<br>&gt; accident. Language rules that constrained when generic parameters can<br>&gt; be resolved to supertypes might help here.<br>&gt; - Function types in Swift do not provide a ready equality<br>&gt; operation. We could provide a default implementation that always<br>&gt; returns &#39;false&#39;, perhaps.<br></p><p>Like Float equality, that&#39;s not an equivalence relation, only this<br>one is more serious, because for most Floats you can pretend it&#39;s an<br>equivalence relation unless you run into NaN.  I&#39;m unsure what to do<br>about these two, but they bear careful consideration.<br></p><p>&gt; - A Comparable ordering can be dreamt up for many types, but it&#39;s not<br>&gt; always a stable ordering, <br></p><p>What do you mean by stable ordering?<br></p><p>&gt; or a desired one. <br></p><p>That&#39;s true.  But what&#39;s important is that it&#39;s consistent with == and<br>allows lookup in a sorted container.  The core ordering operation should<br>not be spelled &quot;&lt;&quot; though; we should use &quot;&lt;=&gt;&quot; for that so that types<br>can keep their domain-specific &quot;&lt;&quot; if necessary.  Too bad the same trick<br>doesn&#39;t work for &quot;==&quot; :-).<br></p><p>&gt; Many people have complained that &#39;nil &lt; .Some(1)&#39; works for optionals,<br>&gt; for instance, ordering &#39;nil&#39; below Some values. We could use pointer<br>&gt; identity to order class instances and types, but this wouldn&#39;t be a<br>&gt; stable ordering across process runs. <br></p><p>Oh, that&#39;s what you mean by &quot;stable.&quot;  So what?<br></p><p>&gt; That might be good enough for ordered collections like search trees,<br>&gt; but is weaker than what many people expect &#39;&lt;&#39; to do.<br></p><p>MMmph.  I don&#39;t think it&#39;s unreasonable to say that if your expectations<br>don&#39;t match the defaults, you can define your own.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  9, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 9, 2016, at 11:41 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; or a desired one. <br>&gt; <br>&gt; That&#39;s true.  But what&#39;s important is that it&#39;s consistent with == and<br>&gt; allows lookup in a sorted container.  The core ordering operation should<br>&gt; not be spelled &quot;&lt;&quot; though; we should use &quot;&lt;=&gt;&quot; for that so that types<br>&gt; can keep their domain-specific &quot;&lt;&quot; if necessary.  Too bad the same trick<br>&gt; doesn&#39;t work for &quot;==&quot; :-).<br>&gt; <br>&gt;&gt; Many people have complained that &#39;nil &lt; .Some(1)&#39; works for optionals,<br>&gt;&gt; for instance, ordering &#39;nil&#39; below Some values. We could use pointer<br>&gt;&gt; identity to order class instances and types, but this wouldn&#39;t be a<br>&gt;&gt; stable ordering across process runs. <br>&gt; <br>&gt; Oh, that&#39;s what you mean by &quot;stable.&quot;  So what?<br></p><p>What if we separated &quot;ordering for a collection&quot; from the &lt; == &gt; family altogether? Even Floats can be given a true equivalence relationship and assigned a stable total ordering for the purposes of container identity. I think it&#39;s reasonable for types to be able to provide an abstract ordering without making &#39;&lt;&#39; and friends casually work. Programmers may have had &quot;don&#39;t rely on hash order&quot; drilled into their heads over the decades, and &quot;don&#39;t rely on container order&quot; might be a reasonable abstraction step from that, but &quot;don&#39;t rely on &lt; behavior&quot; strikes me as unintuitive and going against the intuition users build up from common concrete manifestations of &#39;&lt;&#39;, such as numeric types.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/9589eafe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>March  9, 2016 at 01:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Mar 9, 2016, at 12:51 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Mar 9, 2016, at 11:41 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or a desired one. <br>&gt;&gt; <br>&gt;&gt; That&#39;s true.  But what&#39;s important is that it&#39;s consistent with == and<br>&gt;&gt; allows lookup in a sorted container.  The core ordering operation should<br>&gt;&gt; not be spelled &quot;&lt;&quot; though; we should use &quot;&lt;=&gt;&quot; for that so that types<br>&gt;&gt; can keep their domain-specific &quot;&lt;&quot; if necessary.  Too bad the same trick<br>&gt;&gt; doesn&#39;t work for &quot;==&quot; :-).<br>&gt;&gt; <br>&gt;&gt;&gt; Many people have complained that &#39;nil &lt; .Some(1)&#39; works for optionals,<br>&gt;&gt;&gt; for instance, ordering &#39;nil&#39; below Some values. We could use pointer<br>&gt;&gt;&gt; identity to order class instances and types, but this wouldn&#39;t be a<br>&gt;&gt;&gt; stable ordering across process runs. <br>&gt;&gt; <br>&gt;&gt; Oh, that&#39;s what you mean by &quot;stable.&quot;  So what?<br>&gt; <br>&gt; What if we separated &quot;ordering for a collection&quot; from the &lt; == &gt; family altogether? Even Floats can be given a true equivalence relationship and assigned a stable total ordering for the purposes of container identity. I think it&#39;s reasonable for types to be able to provide an abstract ordering without making &#39;&lt;&#39; and friends casually work. Programmers may have had &quot;don&#39;t rely on hash order&quot; drilled into their heads over the decades, and &quot;don&#39;t rely on container order&quot; might be a reasonable abstraction step from that, but &quot;don&#39;t rely on &lt; behavior&quot; strikes me as unintuitive and going against the intuition users build up from common concrete manifestations of &#39;&lt;&#39;, such as numeric types.<br></p><p>+1 to this.  There are many advantages to this approach and I am surprised that no languages (that I know of) have done this.<br></p><p><br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/d17b0441/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  9, 2016 at 02:00:00pm</p></header><div class="content"><p>on Wed Mar 09 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Mar 9, 2016, at 11:41 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; or a desired one. <br>&gt;&gt; <br>&gt;&gt; That&#39;s true.  But what&#39;s important is that it&#39;s consistent with == and<br>&gt;<br>&gt;&gt; allows lookup in a sorted container.  The core ordering operation should<br>&gt;&gt; not be spelled &quot;&lt;&quot; though; we should use &quot;&lt;=&gt;&quot; for that so that types<br>&gt;&gt; can keep their domain-specific &quot;&lt;&quot; if necessary.  Too bad the same trick<br>&gt;&gt; doesn&#39;t work for &quot;==&quot; :-).<br>&gt;&gt; <br>&gt;&gt;&gt; Many people have complained that &#39;nil &lt; .Some(1)&#39; works for optionals,<br>&gt;&gt;&gt; for instance, ordering &#39;nil&#39; below Some values. We could use pointer<br>&gt;&gt;&gt; identity to order class instances and types, but this wouldn&#39;t be a<br>&gt;&gt;&gt; stable ordering across process runs. <br>&gt;&gt; <br>&gt;&gt; Oh, that&#39;s what you mean by &quot;stable.&quot;  So what?<br>&gt;<br>&gt; What if we separated &quot;ordering for a collection&quot; from the &lt; == &gt;<br>&gt; family altogether? <br></p><p>Yes, that&#39;s what I was suggesting we do with &lt;=&gt;.  Heh, that works for<br>== too, I hadn&#39;t realized!<br></p><p>&gt; Even Floats can be given a true equivalence relationship and assigned<br>&gt; a stable total ordering for the purposes of container identity. I<br>&gt; think it&#39;s reasonable for types to be able to provide an abstract<br>&gt; ordering without making &#39;&lt;&#39; and friends casually work. Programmers may<br>&gt; have had &quot;don&#39;t rely on hash order&quot; drilled into their heads over the<br>&gt; decades, and &quot;don&#39;t rely on container order&quot; might be a reasonable<br>&gt; abstraction step from that, but &quot;don&#39;t rely on &lt; behavior&quot; strikes me<br>&gt; as unintuitive and going against the intuition users build up from<br>&gt; common concrete manifestations of &#39;&lt;&#39;, such as numeric types.<br></p><p>http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4367.html<br>or<br>https://www.youtube.com/watch?v=fi0CQ7laiXE<br></p><p>might be interesting background.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
