<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089:	Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 25, 2016 at 09:00:00am</p></header><div class="content"><p>Am 25. Mai 2016 um 10:01 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p><br>I am not going to comment on the proposal (conflict of interest etc). I do want to speak up in support of Brent&#39;s points, though.<br></p><p><br>On May 25, 2016, at 12:34 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br> * What is your evaluation of the proposal?<br></p><p><br>I am in favor. This is a necessary step towards many future features: class-plus-protocol types, the replacement/reimplementation of AnyObject with Any&lt;class&gt;, existentials with associated types, etc.<br></p><p><br>One reason to prefer `Any` over `any` which is not listed in the proposal is confusion with the unparameterized `Any` type. Having an uppercase `Any` and a lowercase `any&lt;…&gt;` is going to lead to a lot of confusion; people aren&#39;t going to remember whether they need the capitalized form or the lowercase one for any particular use. I don&#39;t think we can have `any&lt;...&gt;` unless we&#39;re also willing to have an unparameterized `any`, and I think `any` is 100% wrong, because it is absolutely a type but is lowercase.<br></p><p><br>Since we are trying to cram as many breaking changes as possible into Swift 3, I also think we should consider now, or soon, whether or not we want to draw a strong syntactic line between protocols-as-existentials and protocols-as-constraints by requiring the use of `Any&lt;…&gt;` on all existentials and forbidding its use in constraints. That would mean, for instance, that code like this:<br></p><p><br>     let printable: CustomStringConvertible = foo<br></p><p><br>Would now be written:<br></p><p><br> let printable: Any&lt;CustomStringConvertible&gt; = foo<br></p><p>I&#39;m sure this will be controversial, but I like the idea of marking all existential types using Any-syntax. It makes the distinction between concrete and existential types in code completely clear to the reader. Given that there are some subtle differences in how concrete and existential types can be used (for example, used as the types of values passed to generic functions), I think this is definitely worth considering.<br></p><p><br>AFAIK an existential type is a type T with type parameters that are still abstract (see for example https://en.wikipedia.org/wiki/Type_system#Existential_types), i.e. have not been assigned concrete values.<br></p><p><br>In Swift these are protocols with Self type requirements (which are always varying) or with associated types that haven&#39;t been assigned, yet.<br></p><p>These currently cannot be used in type declarations but will be usable with Any&lt;...&gt;<br></p><p><br></p><p>Other protocols which do not have Self type requirements or associated types are *not* existential types.<br></p><p>`CustomStringConvertible` in particular which is used in the example is *not* an existential type and therefore should still be usable as:<br></p><p><br></p><p>let printable: CustomStringConvertible = foo<br></p><p><br>i.e. it would *not* be required to write Any&lt;CustomStringConvertible&gt; because CustomStringConvertible is not an existential type.<br></p><p><br></p><p>While I would love making existential types available at last in Swift with this proposal I will not support requiring all protocols to be written as existentials. This makes no sense.<br></p><p><br></p><p>-Thorsten<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/d737e091/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 25, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; AFAIK an existential type is a type T with type parameters that are still abstract (see for example https://en.wikipedia.org/wiki/Type_system#Existential_types), i.e. have not been assigned concrete values.<br></p><p>My understanding is that, in Swift, the instance used to store something whose concrete type is unknown (i.e. is still abstract), but which is known to conform to some protocol, is called an &quot;existential&quot;. Protocols with associated values cannot be packed into normal existentials because, even though we know that the concrete type conforms to some protocol, the associated types represent additional unknowns, and Swift cannot be sure how to translate uses of those unknown types into callable members. Hence, protocols with associated types are sometimes called &quot;non-existential&quot;.<br></p><p>If I am misusing the terminology in this area, please understand that that&#39;s what I mean when I use that word.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May 25, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 25, 2016, at 05:27, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; AFAIK an existential type is a type T with type parameters that are still abstract (see for example https://en.wikipedia.org/wiki/Type_system#Existential_types), i.e. have not been assigned concrete values.<br>&gt; <br>&gt; My understanding is that, in Swift, the instance used to store something whose concrete type is unknown (i.e. is still abstract), but which is known to conform to some protocol, is called an &quot;existential&quot;. Protocols with associated values cannot be packed into normal existentials because, even though we know that the concrete type conforms to some protocol, the associated types represent additional unknowns, and Swift cannot be sure how to translate uses of those unknown types into callable members. Hence, protocols with associated types are sometimes called &quot;non-existential&quot;.<br>&gt; <br>&gt; If I am misusing the terminology in this area, please understand that that&#39;s what I mean when I use that word.<br></p><p>We’re not consistent about it, but an “existential value” is a value with protocol or protocol composition type. My mnemonic for this is that all we know is that certain operations exist (unlike a generic value, where we also have access to the type). John could explain it more formally. We sometimes use “existentials” as a (noun) shorthand for “existential value”.<br></p><p>In the compiler source, all protocols and protocol compositions are referred to as “existential types”, whether they have associated types or not. Again, a protocol asserts the existence (and semantics) of various operations, but nothing else about the conforming type. (Except perhaps that it’s a class.) All protocols are thus “existential types” whether or not the language supports values having that type.<br></p><p>It is incorrect to say that protocols with associated types (or requirements involving Self) are “non-existential”.<br></p><p>Jordan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 25, 2016, at 12:10 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On May 25, 2016, at 05:27, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; AFAIK an existential type is a type T with type parameters that are still abstract (see for example https://en.wikipedia.org/wiki/Type_system#Existential_types), i.e. have not been assigned concrete values.<br>&gt;&gt; <br>&gt;&gt; My understanding is that, in Swift, the instance used to store something whose concrete type is unknown (i.e. is still abstract), but which is known to conform to some protocol, is called an &quot;existential&quot;. Protocols with associated values cannot be packed into normal existentials because, even though we know that the concrete type conforms to some protocol, the associated types represent additional unknowns, and Swift cannot be sure how to translate uses of those unknown types into callable members. Hence, protocols with associated types are sometimes called &quot;non-existential&quot;.<br>&gt;&gt; <br>&gt;&gt; If I am misusing the terminology in this area, please understand that that&#39;s what I mean when I use that word.<br>&gt; <br>&gt; We’re not consistent about it, but an “existential value” is a value with protocol or protocol composition type. My mnemonic for this is that all we know is that certain operations exist (unlike a generic value, where we also have access to the type). John could explain it more formally. We sometimes use “existentials” as a (noun) shorthand for “existential value”.<br>&gt; <br>&gt; In the compiler source, all protocols and protocol compositions are referred to as “existential types”, whether they have associated types or not. Again, a protocol asserts the existence (and semantics) of various operations, but nothing else about the conforming type. (Except perhaps that it’s a class.) All protocols are thus “existential types” whether or not the language supports values having that type.<br>&gt; <br>&gt; It is incorrect to say that protocols with associated types (or requirements involving Self) are “non-existential”.<br></p><p>I haven&#39;t heard people using this term myself, but I imagine they probably mean &quot;can&#39;t form an existential value with the protocol&quot;.  There certainly appears to be a lot of confusion in the community with many not realizing that this is a temporary limitation of the implementation, not a necessary fact.  <br></p><p>&gt; <br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May 25, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 25, 2016, at 10:43, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On May 25, 2016, at 12:10 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 25, 2016, at 05:27, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; AFAIK an existential type is a type T with type parameters that are still abstract (see for example https://en.wikipedia.org/wiki/Type_system#Existential_types), i.e. have not been assigned concrete values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My understanding is that, in Swift, the instance used to store something whose concrete type is unknown (i.e. is still abstract), but which is known to conform to some protocol, is called an &quot;existential&quot;. Protocols with associated values cannot be packed into normal existentials because, even though we know that the concrete type conforms to some protocol, the associated types represent additional unknowns, and Swift cannot be sure how to translate uses of those unknown types into callable members. Hence, protocols with associated types are sometimes called &quot;non-existential&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If I am misusing the terminology in this area, please understand that that&#39;s what I mean when I use that word.<br>&gt;&gt; <br>&gt;&gt; We’re not consistent about it, but an “existential value” is a value with protocol or protocol composition type. My mnemonic for this is that all we know is that certain operations exist (unlike a generic value, where we also have access to the type). John could explain it more formally. We sometimes use “existentials” as a (noun) shorthand for “existential value”.<br>&gt;&gt; <br>&gt;&gt; In the compiler source, all protocols and protocol compositions are referred to as “existential types”, whether they have associated types or not. Again, a protocol asserts the existence (and semantics) of various operations, but nothing else about the conforming type. (Except perhaps that it’s a class.) All protocols are thus “existential types” whether or not the language supports values having that type.<br>&gt;&gt; <br>&gt;&gt; It is incorrect to say that protocols with associated types (or requirements involving Self) are “non-existential”.<br>&gt; <br>&gt; I haven&#39;t heard people using this term myself, but I imagine they probably mean &quot;can&#39;t form an existential value with the protocol&quot;.  There certainly appears to be a lot of confusion in the community with many not realizing that this is a temporary limitation of the implementation, not a necessary fact.  <br></p><p>This sort of confusion is why we try to keep the word “existential” out of diagnostics. (We could have also had success going the other way, and consistently referring to protocols as existential even in non-existential-value cases, but originally we decided it was better to stick with Objective-C’s terms even if it was a bit limiting and awkward.)<br></p><p>Jordan<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
