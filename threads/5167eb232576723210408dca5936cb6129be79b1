<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Idea][Swift 3] Change &#39;DispatchQueue.after&#39; to take a relative time + clock (with default). Maybe replace clocks with an enum?</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 13, 2016 at 06:00:00pm</p></header><div class="content"><p>#1 - <br></p><p>Currently, DispatchQueue.after() takes an absolute time as the ‚Äúafter‚Äù parameter. This makes it hard to understand how to use it; you need to go digging through generated interfaces to find out what a ‚ÄòDispatchTime‚Äô is and how you construct it (by getting the .now() and adding a DispatchTimeInterval using one of the easily-missable operator overloads, if you were wondering).<br></p><p>Here is what DispatchQueue.after looks like now:<br></p><p>public func after(when: DispatchTime, qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute work: @convention(block) () -&gt; Void)<br></p><p>So to use it, you have to type:<br></p><p>DispatchQueue.main.after(when: DispatchTime.now() + .milliseconds(250))   { /* do stuff */ }<br></p><p>I don‚Äôt believe this is a great fit with the Swift API Guidelines. I believe the name ‚Äúafter‚Äù already implies that the time is relative, the argument label should be dropped, and that nuances about the clock (basically, whether or not it pauses during system sleep) are edge-cases which can be handled for the majority of users with a sensible default value (or better yet, modelling via an enum or boolean switch ‚Äî see #2). Additionally, There are overloads with ‚ÄúwallTime‚Äù parameter labels which seem only to duplicate type information (the monotonic and walltime clocks are actually split at the type level) and could be more concise and readable. The principle is that, ultimately, you should just be able to write the above code like this:<br></p><p>DispatchQueue.main.after(.milliseconds(250)) { /* do stuff */ }<br></p><p>Or<br></p><p>DispatchQueue.main.at(DispatchTime.now() + .seconds(3)) { /* do stuff */ }<br></p><p>It‚Äôs not something you use all the time (like .sync/.async), but I find that whenever I do need it I‚Äôm frustrated by how needlessly complex it is to decipher and use. I would find these methods much more obvious, I could figure out how to use them much more quickly, and I think I‚Äôd remember how to use them more quickly.<br></p><p>‚Äî<br></p><p>#2 - <br></p><p>Actually, while writing this down it‚Äôs becoming clearer and clearer that the idea to split DispatchTime (the monotonic clock) and DispatchWallTime (the wall clock) at the type level is probably a bad idea.<br></p><p>Novice users are not going to understand what‚Äôs going on here - I expect most of them to default to the more generic-sounding ‚ÄúDispatchTime‚Äù without any idea of the implications of this. Perhaps we should look at replacing these clock variations with a more descriptive enum or boolean, rather than a separate type. For example:<br></p><p>struct DispatchTime {                       // replaces DispatchTime and DispatchWallTime<br>    let rawValue : dispatch_time_t<br>    let clock : Clock<br></p><p>    enum Clock { case monotonicClock; case wallClock }<br>}<br></p><p>This would not obsolete the discussion at the start about ‚Äúafter‚Äù. The name ‚Äúafter‚Äù still implies that I want something done at some duration relative to an absolute point in time (usually now).<br></p><p>Thoughts? <br>There have been some really in-depth naming discussions on here recently, so I‚Äôm interested to hear what you make of it.<br></p><p>Karl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/974612b3d1f698cfb3141abdee303df9?s=50"></div><header><strong>[Idea][Swift 3] Change &#39;DispatchQueue.after&#39; to take a relative time + clock (with default). Maybe replace clocks with an enum?</strong> from <string>Anthony Chivetta</string> &lt;achivetta at apple.com&gt;<p>July 13, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 13, 2016, at 9:18 , Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; nuances about the clock (basically, whether or not it pauses during system sleep) are edge-cases which can be handled for the majority of users with a sensible default value<br></p><p>I‚Äôm going to stay out of the naming part of the conversation for the moment and just address this point‚Ä¶<br></p><p>I disagree strenuously: it‚Äôs a super important distinction that is frequently the cause of subtle but bad bugs!<br></p><p>Lets start with the fact that you (presumably not the novice user you describe below) actually got the difference between the two clocks wrong.  Here‚Äôs the current behavior (on Darwin, not sure what Linux currently implements):<br></p><p>  - DispatchTime is a clock that only advances forward and tracks the amount of time the computer is awake.<br></p><p>  - DispatchWillTime is a clock that tracks as a UTC clock would, generally moving ahead during sleep, but is *not* monotonic.  It can move forward, backward, upside down, whatever it wants.  And frequently it will.<br></p><p>And this stuff is hard: if you are writing a tea timer app and you pick either of these, you have a bug.  DispatchTime, the bug is that if the user locks their device and it falls asleep the alarm won‚Äôt fire upon wake.  DispatchWallTime, if the device realizes its clock is ahead or behind the ‚Äúreal‚Äù time the elapsed duration won‚Äôt be what you expect.  (Should we have a third that works for the tea timer? Absolutely‚Ä¶)<br></p><p>So, what‚Äôs the sensible default you had in mind that won‚Äôt fail for a large portion of use cases?  Safety is an important design point in an API surface and making these distinctions clear to developers is absolutely critical to achieving that goal.<br></p><p>(Of course, Foundation.Timer gets all of the above horribly wrong, IMHO.  We should fix that too‚Ä¶)<br></p><p>&gt;  (the monotonic and walltime clocks are actually split at the type level)<br></p><p>DispatchTime is not a monotonic clock.  At least, not in the POSIX sense.  So let‚Äôs not call it that.  (Linux‚Äôs failure to implement POSIX correctly notwithstanding.)<br></p><p>&gt; Novice users are not going to understand what‚Äôs going on here - I expect most of them to default to the more generic-sounding ‚ÄúDispatchTime‚Äù without any idea of the implications of this.<br></p><p>If that‚Äôs the case, that‚Äôs a good argument for forcing users to make the choice in an even more obvious and explicit way.  Not making it easier to use one or the other when they‚Äôll likely get it wrong.<br></p><p>ÔΩû Anthony<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/08c09acb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Idea][Swift 3] Change &#39;DispatchQueue.after&#39; to take a relative time + clock (with default). Maybe replace clocks with an enum?</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 13, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 13 Jul 2016, at 18:47, Anthony Chivetta via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 13, 2016, at 9:18 , Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; nuances about the clock (basically, whether or not it pauses during system sleep) are edge-cases which can be handled for the majority of users with a sensible default value<br>&gt; <br>&gt; I‚Äôm going to stay out of the naming part of the conversation for the moment and just address this point‚Ä¶<br>&gt; <br>&gt; I disagree strenuously: it‚Äôs a super important distinction that is frequently the cause of subtle but bad bugs!<br>&gt; <br>&gt; Lets start with the fact that you (presumably not the novice user you describe below) actually got the difference between the two clocks wrong.  Here‚Äôs the current behavior (on Darwin, not sure what Linux currently implements):<br>&gt; <br>&gt;   - DispatchTime is a clock that only advances forward and tracks the amount of time the computer is awake.<br>&gt; <br>&gt;   - DispatchWillTime is a clock that tracks as a UTC clock would, generally moving ahead during sleep, but is *not* monotonic.  It can move forward, backward, upside down, whatever it wants.  And frequently it will.<br>&gt; <br></p><p>Yeah I know, I don‚Äôt think I got the clocks wrong. I forgot that the UTC clock can move around, but yeah, of course it can; fair enough.<br></p><p>&gt; And this stuff is hard: if you are writing a tea timer app and you pick either of these, you have a bug.  DispatchTime, the bug is that if the user locks their device and it falls asleep the alarm won‚Äôt fire upon wake.  DispatchWallTime, if the device realizes its clock is ahead or behind the ‚Äúreal‚Äù time the elapsed duration won‚Äôt be what you expect.  (Should we have a third that works for the tea timer? Absolutely‚Ä¶)<br>&gt; <br></p><p>Do you think that is adequately expressed in the API? <br></p><p>I don‚Äôt, and I believe the current system of type-based overloads is not a good way to ensure people don‚Äôt accidentally use the wrong one. Maybe we should rename the methods which take each type to make it more of a conscious decision (I‚Äôm happy with that, because in that case we definitely have reasonable default values üòé)<br></p><p>&gt; So, what‚Äôs the sensible default you had in mind that won‚Äôt fail for a large portion of use cases?  Safety is an important design point in an API surface and making these distinctions clear to developers is absolutely critical to achieving that goal.<br></p><p>The default clock depends on the context of what you‚Äôre doing. If I‚Äôm using DispatchQueue.after, I would say the monotonic clock is a reasonable default. Typically you‚Äôre going to be scheduling short fire-once things like performing an animation after a second or two (at the most). In that case, system sleep isn‚Äôt an issue - even on iOS where the user can lock the screen at any moment; your long-running alarm that crosses sleep events will still fire, it just won‚Äôt fire *immediately* upon wake. iOS in general makes a point not to offer guarantees about what will happen to your app if it ever goes in to the background, and offers alternative backgrounding and local notification APIs instead.<br></p><p>And again, if you considered it and really need that timer to fire immediately if the system dozed off for a little bit in-between, that‚Äôs available as an explicit consideration.<br></p><p>I could see how there‚Äôs an argument for a third type of timer; it‚Äôs obviously a complex topic, and we should provide a reasonable default if possible; even if that‚Äôs a platform-specific alias.<br></p><p>&gt; <br>&gt; (Of course, Foundation.Timer gets all of the above horribly wrong, IMHO.  We should fix that too‚Ä¶)<br>&gt; <br>&gt;&gt;  (the monotonic and walltime clocks are actually split at the type level)<br>&gt; <br>&gt; DispatchTime is not a monotonic clock.  At least, not in the POSIX sense.  So let‚Äôs not call it that.  (Linux‚Äôs failure to implement POSIX correctly notwithstanding.)<br>&gt; <br>&gt;&gt; Novice users are not going to understand what‚Äôs going on here - I expect most of them to default to the more generic-sounding ‚ÄúDispatchTime‚Äù without any idea of the implications of this.<br>&gt; <br>&gt; If that‚Äôs the case, that‚Äôs a good argument for forcing users to make the choice in an even more obvious and explicit way.  Not making it easier to use one or the other when they‚Äôll likely get it wrong.<br>&gt; <br></p><p>Yes, that was the motivation behind saying we should merge them - while writing it, it feels like you‚Äôre on a bit of a tightrope - one slip and this code could mean something very different.<br></p><p>Karl<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/744828ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27423842cafa2fc08bf56ff675a852e5?s=50"></div><header><strong>[Idea][Swift 3] Change &#39;DispatchQueue.after&#39; to take a relative time + clock (with default). Maybe replace clocks with an enum?</strong> from <string>Daniel A. Steffen</string> &lt;das at apple.com&gt;<p>July 13, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 13, 2016, at 10:08, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 13 Jul 2016, at 18:47, Anthony Chivetta via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 13, 2016, at 9:18 , Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; nuances about the clock (basically, whether or not it pauses during system sleep) are edge-cases which can be handled for the majority of users with a sensible default value<br>&gt;&gt; <br>&gt;&gt; I‚Äôm going to stay out of the naming part of the conversation for the moment and just address this point‚Ä¶<br>&gt;&gt; <br>&gt;&gt; I disagree strenuously: it‚Äôs a super important distinction that is frequently the cause of subtle but bad bugs!<br>&gt;&gt; <br>&gt;&gt; Lets start with the fact that you (presumably not the novice user you describe below) actually got the difference between the two clocks wrong.  Here‚Äôs the current behavior (on Darwin, not sure what Linux currently implements):<br>&gt;&gt; <br>&gt;&gt;   - DispatchTime is a clock that only advances forward and tracks the amount of time the computer is awake.<br>&gt;&gt; <br>&gt;&gt;   - DispatchWillTime is a clock that tracks as a UTC clock would, generally moving ahead during sleep, but is *not* monotonic.  It can move forward, backward, upside down, whatever it wants.  And frequently it will.<br>&gt;&gt; <br>&gt; <br>&gt; Yeah I know, I don‚Äôt think I got the clocks wrong. I forgot that the UTC clock can move around, but yeah, of course it can; fair enough.<br>&gt; <br>&gt;&gt; And this stuff is hard: if you are writing a tea timer app and you pick either of these, you have a bug.  DispatchTime, the bug is that if the user locks their device and it falls asleep the alarm won‚Äôt fire upon wake.  DispatchWallTime, if the device realizes its clock is ahead or behind the ‚Äúreal‚Äù time the elapsed duration won‚Äôt be what you expect.  (Should we have a third that works for the tea timer? Absolutely‚Ä¶)<br>&gt;&gt; <br>&gt; <br>&gt; Do you think that is adequately expressed in the API? <br>&gt; <br>&gt; I don‚Äôt, and I believe the current system of type-based overloads is not a good way to ensure people don‚Äôt accidentally use the wrong one. Maybe we should rename the methods which take each type to make it more of a conscious decision (I‚Äôm happy with that, because in that case we definitely have reasonable default values üòé)<br></p><p>I‚Äôm confused, that is what we have in the current version (the argument label is part of the overall method name): asyncAfter(deadline:) vs asyncAfter(wallDeadline:), which is consistent with all the other labels of deadline arguments in the API (this isn‚Äôt the only method dealing with time)<br></p><p>we did discuss naming these asyncAt() instead of asyncAfter(), which would make it more clear that they take a deadline, but the name felt uncomfortably close to async(), and may also lead to the mistaken impression that the execution with occur exactly _at_ the deadline (as opposed to just the async() to a queue that may be full of other items already and take a while to drain, or be suspended and never execute at all)<br></p><p>&gt; <br>&gt;&gt; So, what‚Äôs the sensible default you had in mind that won‚Äôt fail for a large portion of use cases?  Safety is an important design point in an API surface and making these distinctions clear to developers is absolutely critical to achieving that goal.<br>&gt; <br>&gt; The default clock depends on the context of what you‚Äôre doing. If I‚Äôm using DispatchQueue.after, I would say the monotonic clock is a reasonable default. Typically you‚Äôre going to be scheduling short fire-once things like performing an animation after a second or two (at the most). In that case, system sleep isn‚Äôt an issue - even on iOS where the user can lock the screen at any moment; your long-running alarm that crosses sleep events will still fire, it just won‚Äôt fire *immediately* upon wake.<br></p><p>Nothing in the API says it must be used only for &quot;short fire-once things&quot;<br></p><p>The problem with the monotonic clock isn‚Äôt about firing at wake, but about pushing the fire time out by the amount of time asleep.<br>If you are using this to implement e.g. a calendaring meeting reminder alarms, you are not going to be happy if your reminder is late by the amount of time that your device happened to put its cpu to sleep for many short intervals for power management reasons...<br></p><p>&gt; iOS in general makes a point not to offer guarantees about what will happen to your app if it ever goes in to the background, and offers alternative backgrounding and local notification APIs instead.<br></p><p>this API isn‚Äôt just designed for iOS Apps but for system programming in general, on any platform.<br></p><p>&gt; <br>&gt; And again, if you considered it and really need that timer to fire immediately if the system dozed off for a little bit in-between, that‚Äôs available as an explicit consideration.<br>&gt; <br>&gt; I could see how there‚Äôs an argument for a third type of timer; it‚Äôs obviously a complex topic, and we should provide a reasonable default if possible; even if that‚Äôs a platform-specific alias.<br></p><p>yes this was intentionally designed to accommodate additional clocks<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; (Of course, Foundation.Timer gets all of the above horribly wrong, IMHO.  We should fix that too‚Ä¶)<br>&gt;&gt; <br>&gt;&gt;&gt;  (the monotonic and walltime clocks are actually split at the type level)<br>&gt;&gt; <br>&gt;&gt; DispatchTime is not a monotonic clock.  At least, not in the POSIX sense.  So let‚Äôs not call it that.  (Linux‚Äôs failure to implement POSIX correctly notwithstanding.)<br>&gt;&gt; <br>&gt;&gt;&gt; Novice users are not going to understand what‚Äôs going on here - I expect most of them to default to the more generic-sounding ‚ÄúDispatchTime‚Äù without any idea of the implications of this.<br>&gt;&gt; <br>&gt;&gt; If that‚Äôs the case, that‚Äôs a good argument for forcing users to make the choice in an even more obvious and explicit way.  Not making it easier to use one or the other when they‚Äôll likely get it wrong.<br>&gt;&gt; <br>&gt; <br>&gt; Yes, that was the motivation behind saying we should merge them - while writing it, it feels like you‚Äôre on a bit of a tightrope - one slip and this code could mean something very different.<br>&gt; <br>&gt; Karl<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/3dd5b02d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Idea][Swift 3] Change &#39;DispatchQueue.after&#39; to take a relative time + clock (with default). Maybe replace clocks with an enum?</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 13, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 13 Jul 2016, at 19:59, Daniel A. Steffen &lt;das at apple.com&gt; wrote:<br>&gt; <br>&gt; I‚Äôm confused, that is what we have in the current version (the argument label is part of the overall method name): asyncAfter(deadline:) vs asyncAfter(wallDeadline:), which is consistent with all the other labels of deadline arguments in the API (this isn‚Äôt the only method dealing with time)<br>&gt; <br></p><p>I think this argument labels are superfluous and actually make the meaning less coherent. ‚Äúafter(when:‚Ä¶)‚Äù is not grammatically fluent, which the Swift API guidelines encourage, and which the standard library has made big steps towards recently (see especially https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md). By dropping the labels and renaming the function base-names, we make them more ‚Äúswifty‚Äù, more concise, clear and readable, and can improve safety by making sure people know which clock they‚Äôre using and what semantic meaning that has. <br></p><p><br>&gt; we did discuss naming these asyncAt() instead of asyncAfter(), which would make it more clear that they take a deadline, but the name felt uncomfortably close to async(), and may also lead to the mistaken impression that the execution with occur exactly _at_ the deadline (as opposed to just the async() to a queue that may be full of other items already and take a while to drain, or be suspended and never execute at all)<br>&gt; <br></p><p>I‚Äôm not sure it‚Äôs really necessary to include the word ‚Äúasync‚Äù in there ‚Äî it‚Äôs pretty clear from the fact that they take a time that they‚Äôre not going to block.<br></p><p>The problem with ‚Äúdeadline‚Äù is that it‚Äôs just not a deadline. It‚Äôs an aspirational fire time, and Dispatch should execute the block as soon as possible after that time. I can‚Äôt really think of a concise word for it, but ‚Äúdeadline‚Äù does not express what you‚Äôre talking about. Deadline implies that the block can execute any time _before_ the specified time.<br></p><p>So that‚Äôs where I get ‚Äúat‚Äù from; if your app is asleep, it isn‚Äôt possible to execute exactly at the specified time for reasons outside of your control. If it executes as soon as possible after waking, I would still consider it to be firing ‚Äúat‚Äù the correct time (in a loose sort of way). If we were talking about the dispatch queue as a person, and I asked him/her to do something at a particular time, but they were delayed due to circumstances outside of anybody&#39;s control (like a natural disaster or a traffic accident), I‚Äôd still consider that they did it ‚Äúat‚Äù the correct time, again in a loose sense - to the best that they can control it, in other words.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; So, what‚Äôs the sensible default you had in mind that won‚Äôt fail for a large portion of use cases?  Safety is an important design point in an API surface and making these distinctions clear to developers is absolutely critical to achieving that goal.<br>&gt;&gt; <br>&gt;&gt; The default clock depends on the context of what you‚Äôre doing. If I‚Äôm using DispatchQueue.after, I would say the monotonic clock is a reasonable default. Typically you‚Äôre going to be scheduling short fire-once things like performing an animation after a second or two (at the most). In that case, system sleep isn‚Äôt an issue - even on iOS where the user can lock the screen at any moment; your long-running alarm that crosses sleep events will still fire, it just won‚Äôt fire *immediately* upon wake. <br>&gt; <br>&gt; Nothing in the API says it must be used only for &quot;short fire-once things&quot;<br>&gt; <br>&gt; The problem with the monotonic clock isn‚Äôt about firing at wake, but about pushing the fire time out by the amount of time asleep.<br>&gt; If you are using this to implement e.g. a calendaring meeting reminder alarms, you are not going to be happy if your reminder is late by the amount of time that your device happened to put its cpu to sleep for many short intervals for power management reasons‚Ä¶<br></p><p>No, nothing in the API does say that, but in this context I believe it‚Äôs the most commonly wanted thing and would be a reasonable default.<br></p><p>If you are implementing calendar reminders using dispatch_after in an application which can be suspended at any moment, you‚Äôre using the wrong API pure and simple. On Linux, you might be able to guarantee your app won‚Äôt be suspended so this strategy could work for you, but the API you use must be appropriate to the platform. If you can‚Äôt make that guarantee (e.g. On iOS), you should look for an alternative, such as the local notifications API, which is designed for exactly this.<br></p><p>&gt; <br>&gt;&gt; iOS in general makes a point not to offer guarantees about what will happen to your app if it ever goes in to the background, and offers alternative backgrounding and local notification APIs instead.<br>&gt; <br>&gt; this API isn‚Äôt just designed for iOS Apps but for system programming in general, on any platform.<br>&gt; <br></p><p>No, but as above, the API you use must be appropriate for the platform. We shouldn‚Äôt worry about people on iOS using dispatch_after for calendar notifications. Those people will run in to all kinds of headaches anyway, asking them to be explicit about which clock they use is pretty fair IMO. I would say it might even help them...<br></p><p>&gt;&gt; <br>&gt;&gt; And again, if you considered it and really need that timer to fire immediately if the system dozed off for a little bit in-between, that‚Äôs available as an explicit consideration.<br>&gt;&gt; <br>&gt;&gt; I could see how there‚Äôs an argument for a third type of timer; it‚Äôs obviously a complex topic, and we should provide a reasonable default if possible; even if that‚Äôs a platform-specific alias.<br>&gt; <br>&gt; yes this was intentionally designed to accommodate additional clocks<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Of course, Foundation.Timer gets all of the above horribly wrong, IMHO.  We should fix that too‚Ä¶)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  (the monotonic and walltime clocks are actually split at the type level)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; DispatchTime is not a monotonic clock.  At least, not in the POSIX sense.  So let‚Äôs not call it that.  (Linux‚Äôs failure to implement POSIX correctly notwithstanding.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Novice users are not going to understand what‚Äôs going on here - I expect most of them to default to the more generic-sounding ‚ÄúDispatchTime‚Äù without any idea of the implications of this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If that‚Äôs the case, that‚Äôs a good argument for forcing users to make the choice in an even more obvious and explicit way.  Not making it easier to use one or the other when they‚Äôll likely get it wrong.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Yes, that was the motivation behind saying we should merge them - while writing it, it feels like you‚Äôre on a bit of a tightrope - one slip and this code could mean something very different.<br>&gt;&gt; <br>&gt;&gt; Karl<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/6249ea45/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0db24e79de1d6e82cf6327b091903b1b?s=50"></div><header><strong>[Idea][Swift 3] Change &#39;DispatchQueue.after&#39; to take a relative time + clock (with default). Maybe replace clocks with an enum?</strong> from <string>Pierre Habouzit</string> &lt;phabouzit at apple.com&gt;<p>July 13, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jul 13, 2016, at 11:42 AM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 13 Jul 2016, at 19:59, Daniel A. Steffen &lt;das at apple.com &lt;mailto:das at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I‚Äôm confused, that is what we have in the current version (the argument label is part of the overall method name): asyncAfter(deadline:) vs asyncAfter(wallDeadline:), which is consistent with all the other labels of deadline arguments in the API (this isn‚Äôt the only method dealing with time)<br>&gt;&gt; <br>&gt; <br>&gt; I think this argument labels are superfluous and actually make the meaning less coherent. ‚Äúafter(when:‚Ä¶)‚Äù is not grammatically fluent, which the Swift API guidelines encourage, and which the standard library has made big steps towards recently (see especially https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md&gt;). By dropping the labels and renaming the function base-names, we make them more ‚Äúswifty‚Äù, more concise, clear and readable, and can improve safety by making sure people know which clock they‚Äôre using and what semantic meaning that has. <br></p><p>after(when:) is the current state of the overlay but we told you we‚Äôre proposing something new, so your argument is not in complete good faith here is it? ;)<br></p><p>&gt;&gt; we did discuss naming these asyncAt() instead of asyncAfter(), which would make it more clear that they take a deadline, but the name felt uncomfortably close to async(), and may also lead to the mistaken impression that the execution with occur exactly _at_ the deadline (as opposed to just the async() to a queue that may be full of other items already and take a while to drain, or be suspended and never execute at all)<br>&gt;&gt; <br>&gt; <br>&gt; I‚Äôm not sure it‚Äôs really necessary to include the word ‚Äúasync‚Äù in there ‚Äî it‚Äôs pretty clear from the fact that they take a time that they‚Äôre not going to block.<br>&gt; <br>&gt; The problem with ‚Äúdeadline‚Äù is that it‚Äôs just not a deadline. It‚Äôs an aspirational fire time, and Dispatch should execute the block as soon as possible after that time. I can‚Äôt really think of a concise word for it, but ‚Äúdeadline‚Äù does not express what you‚Äôre talking about. Deadline implies that the block can execute any time _before_ the specified time.<br>&gt; <br>&gt; So that‚Äôs where I get ‚Äúat‚Äù from; if your app is asleep, it isn‚Äôt possible to execute exactly at the specified time for reasons outside of your control. If it executes as soon as possible after waking, I would still consider it to be firing ‚Äúat‚Äù the correct time (in a loose sort of way). If we were talking about the dispatch queue as a person, and I asked him/her to do something at a particular time, but they were delayed due to circumstances outside of anybody&#39;s control (like a natural disaster or a traffic accident), I‚Äôd still consider that they did it ‚Äúat‚Äù the correct time, again in a loose sense - to the best that they can control it, in other words.<br></p><p>I strongly disagree that the two forms should be named differently, it‚Äôs even more confusing that if you use after() you get one clock and at() the other. Also when we will add a 3rd clock to dispatch, it just stops working completely (look at clock_gettime() that was finally added to macOS, it has 3 interesting clocks: MONOTONIC, UPTIME, and WALLTIME that posix calls REALTIME for some weird reason).<br></p><p>the functions should exactly differ with the argument tag to show that they basically perform the same task with a slight difference that is the clock you‚Äôre using. It‚Äôs concise, unambiguous, and regular with the other functions in the Dispatch module that handle time. Which in my opinion goes exactly in the direction of SE-0118.<br></p><p>&gt;&gt;&gt;&gt; So, what‚Äôs the sensible default you had in mind that won‚Äôt fail for a large portion of use cases?  Safety is an important design point in an API surface and making these distinctions clear to developers is absolutely critical to achieving that goal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The default clock depends on the context of what you‚Äôre doing. If I‚Äôm using DispatchQueue.after, I would say the monotonic clock is a reasonable default. Typically you‚Äôre going to be scheduling short fire-once things like performing an animation after a second or two (at the most). In that case, system sleep isn‚Äôt an issue - even on iOS where the user can lock the screen at any moment; your long-running alarm that crosses sleep events will still fire, it just won‚Äôt fire *immediately* upon wake. <br>&gt;&gt; <br>&gt;&gt; Nothing in the API says it must be used only for &quot;short fire-once things&quot;<br>&gt;&gt; <br>&gt;&gt; The problem with the monotonic clock isn‚Äôt about firing at wake, but about pushing the fire time out by the amount of time asleep.<br>&gt;&gt; If you are using this to implement e.g. a calendaring meeting reminder alarms, you are not going to be happy if your reminder is late by the amount of time that your device happened to put its cpu to sleep for many short intervals for power management reasons‚Ä¶<br>&gt; <br>&gt; No, nothing in the API does say that, but in this context I believe it‚Äôs the most commonly wanted thing and would be a reasonable default.<br>&gt; <br>&gt; If you are implementing calendar reminders using dispatch_after in an application which can be suspended at any moment, you‚Äôre using the wrong API pure and simple. On Linux, you might be able to guarantee your app won‚Äôt be suspended so this strategy could work for you, but the API you use must be appropriate to the platform. If you can‚Äôt make that guarantee (e.g. On iOS), you should look for an alternative, such as the local notifications API, which is designed for exactly this.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; iOS in general makes a point not to offer guarantees about what will happen to your app if it ever goes in to the background, and offers alternative backgrounding and local notification APIs instead.<br>&gt;&gt; <br>&gt;&gt; this API isn‚Äôt just designed for iOS Apps but for system programming in general, on any platform.<br>&gt;&gt; <br>&gt; <br>&gt; No, but as above, the API you use must be appropriate for the platform. We shouldn‚Äôt worry about people on iOS using dispatch_after for calendar notifications. Those people will run in to all kinds of headaches anyway, asking them to be explicit about which clock they use is pretty fair IMO. I would say it might even help them‚Ä¶<br></p><p><br>This was an example was to give you a sense of why what you‚Äôre asking feels wrong to us. But if you want a better one: dispatch_after() is completely suitable to have a notification in app when a given wall time passes if you‚Äôre in the app. It avoids the overhead and headaches of complex notification mechanisms, which are sometimes not even desired (if you‚Äôre not in the app, having the system wake up for that timer is a power issue). There are several apps doing that.<br></p><p>We hence don‚Äôt think that what you‚Äôre asking for is serving developers.<br></p><p>also note that the C API works that way for a long time:<br></p><p>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, ‚Ä¶), ‚Ä¶)<br>dispatch_after(dispatch_walltime(DISPATCH_TIME_NOW, ‚Ä¶), ‚Ä¶)<br></p><p>to me it‚Äôs visually similar to:<br></p><p>q.asyncAfter(deadline: .now() + ‚Ä¶) ‚Ä¶<br>q.asyncAfter(wallDeadline: .now() + ‚Ä¶) ‚Ä¶<br></p><p>And while making things more swifty (and DispatchWorkItem shows that we‚Äôre dedicated to that when there‚Äôs a benefit), making it too dissimilar to the C interface for no good reason is something to IMO consider when picking names here.<br></p><p><br>-Pierre<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/87f312d5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Idea][Swift 3] Change &#39;DispatchQueue.after&#39; to take a relative time + clock (with default). Maybe replace clocks with an enum?</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 13, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 13 Jul 2016, at 21:04, Pierre Habouzit &lt;phabouzit at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 13, 2016, at 11:42 AM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 13 Jul 2016, at 19:59, Daniel A. Steffen &lt;das at apple.com &lt;mailto:das at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I‚Äôm confused, that is what we have in the current version (the argument label is part of the overall method name): asyncAfter(deadline:) vs asyncAfter(wallDeadline:), which is consistent with all the other labels of deadline arguments in the API (this isn‚Äôt the only method dealing with time)<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I think this argument labels are superfluous and actually make the meaning less coherent. ‚Äúafter(when:‚Ä¶)‚Äù is not grammatically fluent, which the Swift API guidelines encourage, and which the standard library has made big steps towards recently (see especially https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md&gt;). By dropping the labels and renaming the function base-names, we make them more ‚Äúswifty‚Äù, more concise, clear and readable, and can improve safety by making sure people know which clock they‚Äôre using and what semantic meaning that has. <br>&gt; <br>&gt; after(when:) is the current state of the overlay but we told you we‚Äôre proposing something new, so your argument is not in complete good faith here is it? ;)<br></p><p>Yeah, I know - you‚Äôre proposing to rename it, I‚Äôm proposing that it should have a different type (which would be enabled by a different renaming to the one you‚Äôre proposing). So I think it‚Äôs a fair debate. I gave my opinion on ‚Äúdeadline&quot; - the time you specify isn‚Äôt actually a deadline, is it? It isn‚Äôt the latest possible the time the block is allowed to execute; it‚Äôs the earliest possible time.<br></p><p>Maybe there is a language gap in there, maybe people use ‚Äúdeadline‚Äù more loosely to mean a general point in time in California, but the dictionary agrees that deadline means &quot;the latest time or date by which something should be completed‚Äù, which is not what I think you mean (maybe I‚Äôm wrong, but that‚Äôs my understanding of what you‚Äôve been saying so far).<br></p><p>&gt; <br>&gt;&gt;&gt; we did discuss naming these asyncAt() instead of asyncAfter(), which would make it more clear that they take a deadline, but the name felt uncomfortably close to async(), and may also lead to the mistaken impression that the execution with occur exactly _at_ the deadline (as opposed to just the async() to a queue that may be full of other items already and take a while to drain, or be suspended and never execute at all)<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I‚Äôm not sure it‚Äôs really necessary to include the word ‚Äúasync‚Äù in there ‚Äî it‚Äôs pretty clear from the fact that they take a time that they‚Äôre not going to block.<br>&gt;&gt; <br>&gt;&gt; The problem with ‚Äúdeadline‚Äù is that it‚Äôs just not a deadline. It‚Äôs an aspirational fire time, and Dispatch should execute the block as soon as possible after that time. I can‚Äôt really think of a concise word for it, but ‚Äúdeadline‚Äù does not express what you‚Äôre talking about. Deadline implies that the block can execute any time _before_ the specified time.<br>&gt;&gt; <br>&gt;&gt; So that‚Äôs where I get ‚Äúat‚Äù from; if your app is asleep, it isn‚Äôt possible to execute exactly at the specified time for reasons outside of your control. If it executes as soon as possible after waking, I would still consider it to be firing ‚Äúat‚Äù the correct time (in a loose sort of way). If we were talking about the dispatch queue as a person, and I asked him/her to do something at a particular time, but they were delayed due to circumstances outside of anybody&#39;s control (like a natural disaster or a traffic accident), I‚Äôd still consider that they did it ‚Äúat‚Äù the correct time, again in a loose sense - to the best that they can control it, in other words.<br>&gt; <br>&gt; I strongly disagree that the two forms should be named differently, it‚Äôs even more confusing that if you use after() you get one clock and at() the other. Also when we will add a 3rd clock to dispatch, it just stops working completely (look at clock_gettime() that was finally added to macOS, it has 3 interesting clocks: MONOTONIC, UPTIME, and WALLTIME that posix calls REALTIME for some weird reason).<br>&gt; <br>&gt; the functions should exactly differ with the argument tag to show that they basically perform the same task with a slight difference that is the clock you‚Äôre using. It‚Äôs concise, unambiguous, and regular with the other functions in the Dispatch module that handle time. Which in my opinion goes exactly in the direction of SE-0118.<br>&gt; <br></p><p>Didn‚Äôt we agree earlier that the clock type is not a minor distinction? And that there are rather large differences about when the block might fire depending on which clock you use. This was Anthony Chievetta (maybe I misunderstood him, too):<br></p><p>&gt; I disagree strenuously: it‚Äôs a super important distinction that is frequently the cause of subtle but bad bugs!<br>&gt; <br>&gt; Lets start with the fact that you (presumably not the novice user you describe below) actually got the difference between the two clocks wrong.  Here‚Äôs the current behavior (on Darwin, not sure what Linux currently implements):<br>&gt; <br>&gt;   - DispatchTime is a clock that only advances forward and tracks the amount of time the computer is awake.<br>&gt; <br>&gt;   - DispatchWillTime is a clock that tracks as a UTC clock would, generally moving ahead during sleep, but is *not* monotonic.  It can move forward, backward, upside down, whatever it wants.  And frequently it will.<br>&gt; <br>&gt; And this stuff is hard: if you are writing a tea timer app and you pick either of these, you have a bug.  DispatchTime, the bug is that if the user locks their device and it falls asleep the alarm won‚Äôt fire upon wake.  DispatchWallTime, if the device realizes its clock is ahead or behind the ‚Äúreal‚Äù time the elapsed duration won‚Äôt be what you expect.  (Should we have a third that works for the tea timer? Absolutely‚Ä¶)<br></p><p><br></p><p>If there is some new clock introduced later, with different scheduling guarantees, it can get its own unique name to reflect what it does, right?<br></p><p><br>&gt;&gt;&gt;&gt;&gt; <br>&gt; <br>&gt; <br>&gt; This was an example was to give you a sense of why what you‚Äôre asking feels wrong to us. But if you want a better one: dispatch_after() is completely suitable to have a notification in app when a given wall time passes if you‚Äôre in the app. It avoids the overhead and headaches of complex notification mechanisms, which are sometimes not even desired (if you‚Äôre not in the app, having the system wake up for that timer is a power issue). There are several apps doing that.<br>&gt; <br>&gt; We hence don‚Äôt think that what you‚Äôre asking for is serving developers.<br>&gt; <br>&gt; also note that the C API works that way for a long time:<br>&gt; <br>&gt; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, ‚Ä¶), ‚Ä¶)<br>&gt; dispatch_after(dispatch_walltime(DISPATCH_TIME_NOW, ‚Ä¶), ‚Ä¶)<br>&gt; <br>&gt; to me it‚Äôs visually similar to:<br>&gt; <br>&gt; q.asyncAfter(deadline: .now() + ‚Ä¶) ‚Ä¶<br>&gt; q.asyncAfter(wallDeadline: .now() + ‚Ä¶) ‚Ä¶<br>&gt; <br>&gt; And while making things more swifty (and DispatchWorkItem shows that we‚Äôre dedicated to that when there‚Äôs a benefit), making it too dissimilar to the C interface for no good reason is something to IMO consider when picking names here.<br></p><p>The C API was also horrible in that regard. I bet there‚Äôs not a handful of people on this mailing list who could tell you exactly how to invoke dispatch_after. Everybody just uses the Xcode macro because it‚Äôs a mountain of jargon that almost nobody needs to care about.<br></p><p>That‚Äôs the whole point of all of this - I‚Äôm not proposing removing functionality, just making it more obvious and intuitive. If these clocks have such enormous differences, they should have unique names to reflect that ‚Äî and since we now know the clock, we can supply defaults and take intervals rather than absolute times, making the names fluent and clear.<br></p><p>That‚Äôs why I think my proposed change is so much for the better - it leads to massive simplifications all-around, and things will just make so much more sense afterwards, without reducing functionality. Nuances that were hidden will be exposed, and you won‚Äôt need to dig through interfaces looking for operator overloads any more - autocomplete will be able to tell you exactly what to enter.<br></p><p>That‚Äôs why I‚Äôm not disparaged by how many of you Apple guys disagree - after all, you guys designed the original C API that this very-closely follows (which is a great API, don‚Äôt get me wrong, but this function hasn‚Äôt adapted to Swift yet IMO). It could be clearer and more approachable for end-users.<br></p><p><br>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/1e4ca73a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Idea][Swift 3] Change &#39;DispatchQueue.after&#39; to take a relative time + clock (with default). Maybe replace clocks with an enum?</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>July 13, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 13 Jul 2016, at 20:04, Pierre Habouzit via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I strongly disagree that the two forms should be named differently, it‚Äôs even more confusing that if you use after() you get one clock and at() the other. Also when we will add a 3rd clock to dispatch, it just stops working completely (look at clock_gettime() that was finally added to macOS, it has 3 interesting clocks: MONOTONIC, UPTIME, and WALLTIME that posix calls REALTIME for some weird reason).<br>&gt; <br>&gt; the functions should exactly differ with the argument tag to show that they basically perform the same task with a slight difference that is the clock you‚Äôre using. It‚Äôs concise, unambiguous, and regular with the other functions in the Dispatch module that handle time. Which in my opinion goes exactly in the direction of SE-0118.<br></p><p>Methods taking DispatchTime or DispatchWallTime parameters have duplicate implementations. Shouldn&#39;t they be generic?<br></p><p>	public func wait&lt;T: DispatchTime&gt;(timeout: T? = nil) -&gt; DispatchTimeoutResult<br></p><p>As I mentioned in the review, DISPATCH_TIME_FOREVER can be represented as an Optional parameter, so `distantFuture` isn&#39;t needed.<br></p><p>	group.wait(timeout: DispatchWallTime() + .seconds(10))<br></p><p>	group.wait()<br></p><p>DispatchTime would be a protocol, and the existing structure would be renamed.<br></p><p>	public protocol DispatchTime: Comparable, RawRepresentable {<br></p><p>	    var rawValue: dispatch_time_t { get }<br></p><p>	    init(rawValue: dispatch_time_t)<br></p><p>	    init()<br>	}<br></p><p>-- Ben<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0db24e79de1d6e82cf6327b091903b1b?s=50"></div><header><strong>[Idea][Swift 3] Change &#39;DispatchQueue.after&#39; to take a relative time + clock (with default). Maybe replace clocks with an enum?</strong> from <string>Pierre Habouzit</string> &lt;phabouzit at apple.com&gt;<p>July 13, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 13, 2016, at 9:18 AM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; #1 - <br>&gt; <br>&gt; Currently, DispatchQueue.after() takes an absolute time as the ‚Äúafter‚Äù parameter. This makes it hard to understand how to use it; you need to go digging through generated interfaces to find out what a ‚ÄòDispatchTime‚Äô is and how you construct it (by getting the .now() and adding a DispatchTimeInterval using one of the easily-missable operator overloads, if you were wondering).<br>&gt; <br>&gt; Here is what DispatchQueue.after looks like now:<br>&gt; <br>&gt; public func after(when: DispatchTime, qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute work: @convention(block) () -&gt; Void)<br>&gt; <br>&gt; So to use it, you have to type:<br>&gt; <br>&gt; DispatchQueue.main.after(when: DispatchTime.now() + .milliseconds(250))   { /* do stuff */ }<br>&gt; <br>&gt; I don‚Äôt believe this is a great fit with the Swift API Guidelines. I believe the name ‚Äúafter‚Äù already implies that the time is relative, the argument label should be dropped, and that nuances about the clock (basically, whether or not it pauses during system sleep) are edge-cases which can be handled for the majority of users with a sensible default value (or better yet, modelling via an enum or boolean switch ‚Äî see #2). Additionally, There are overloads with ‚ÄúwallTime‚Äù parameter labels which seem only to duplicate type information (the monotonic and walltime clocks are actually split at the type level) and could be more concise and readable. The principle is that, ultimately, you should just be able to write the above code like this:<br>&gt; <br>&gt; DispatchQueue.main.after(.milliseconds(250)) { /* do stuff */ }<br>&gt; <br>&gt; Or<br>&gt; <br>&gt; DispatchQueue.main.at(DispatchTime.now() + .seconds(3)) { /* do stuff */ }<br>&gt; <br>&gt; It‚Äôs not something you use all the time (like .sync/.async), but I find that whenever I do need it I‚Äôm frustrated by how needlessly complex it is to decipher and use. I would find these methods much more obvious, I could figure out how to use them much more quickly, and I think I‚Äôd remember how to use them more quickly.<br></p><p>As mentioned by Matt in the pull request you created, we‚Äôre working on a proposal that would look like this:<br></p><p>func asyncAfter(deadline:qos:flags:work:)<br>func asyncAfter(wallDeadline:qos:flags:work:)<br>As we discussed on the pull request, <br></p><p>DispatchQueue.main.after(.milliseconds(250)) { /* do stuff */ }<br></p><p>Is ambiguous as you don‚Äôt know which clock was meant, and despite your claim, there‚Äôs in general no good default for the clock. If you are writing a calendar app, you want wallClock, but if you‚Äôre doing anything network related, you will want the monotonic one. Depending on which software you‚Äôre writing, you will have a bias for one or the other.<br></p><p>Also it may be a native speaker thing (which I‚Äôm not) but this reads ‚Äúplease async this closure on `q` after this deadline has expired‚Äù to me, which sounds like proper english:<br></p><p>q.asyncAfter(deadline: .now() + 1.0) { /* do stuff */ }<br></p><p><br>I thought that you would say ‚Äúplease meet me in 10 minutes‚Äù or ‚Äúplease meet me after 2PM‚Äù. The `asyncBy` that you suggested to the pull request reads *before* that deadline to me which is not good either.<br>`asyncAt` would probably work too however, but asyncAfter is easier for people coming from C who are used to dispatch_after().<br></p><p><br>&gt; #2 - <br>&gt; <br>&gt; Actually, while writing this down it‚Äôs becoming clearer and clearer that the idea to split DispatchTime (the monotonic clock) and DispatchWallTime (the wall clock) at the type level is probably a bad idea.<br>&gt; <br>&gt; Novice users are not going to understand what‚Äôs going on here - I expect most of them to default to the more generic-sounding ‚ÄúDispatchTime‚Äù without any idea of the implications of this. Perhaps we should look at replacing these clock variations with a more descriptive enum or boolean, rather than a separate type. For example:<br>&gt; <br>&gt; struct DispatchTime {                       // replaces DispatchTime and DispatchWallTime<br>&gt;    let rawValue : dispatch_time_t<br>&gt;    let clock : Clock<br>&gt; <br>&gt;    enum Clock { case monotonicClock; case wallClock }<br>&gt; }<br>&gt; <br>&gt; This would not obsolete the discussion at the start about ‚Äúafter‚Äù. The name ‚Äúafter‚Äù still implies that I want something done at some duration relative to an absolute point in time (usually now).<br></p><p>This is what dispatch_time_t does in C and my team at Apple widely considers this having been a design mistake: it means that the time is not generally Comparable, that you can‚Äôt perform any kind of arithmetic with it, etc.<br></p><p>In C it‚Äôs more convenient to have a single type, but in Swift where type is inferred, given that most of the uses will construct the time as the argument to the function itself, we feel that the current proposal allows for the most concise use.<br></p><p><br></p><p>-Pierre<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/31c83154/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Idea][Swift 3] Change &#39;DispatchQueue.after&#39; to take a relative time + clock (with default). Maybe replace clocks with an enum?</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 13, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 13 Jul 2016, at 18:56, Pierre Habouzit &lt;phabouzit at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 13, 2016, at 9:18 AM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; #1 - <br>&gt;&gt; <br>&gt;&gt; Currently, DispatchQueue.after() takes an absolute time as the ‚Äúafter‚Äù parameter. This makes it hard to understand how to use it; you need to go digging through generated interfaces to find out what a ‚ÄòDispatchTime‚Äô is and how you construct it (by getting the .now() and adding a DispatchTimeInterval using one of the easily-missable operator overloads, if you were wondering).<br>&gt;&gt; <br>&gt;&gt; Here is what DispatchQueue.after looks like now:<br>&gt;&gt; <br>&gt;&gt; public func after(when: DispatchTime, qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute work: @convention(block) () -&gt; Void)<br>&gt;&gt; <br>&gt;&gt; So to use it, you have to type:<br>&gt;&gt; <br>&gt;&gt; DispatchQueue.main.after(when: DispatchTime.now() + .milliseconds(250))   { /* do stuff */ }<br>&gt;&gt; <br>&gt;&gt; I don‚Äôt believe this is a great fit with the Swift API Guidelines. I believe the name ‚Äúafter‚Äù already implies that the time is relative, the argument label should be dropped, and that nuances about the clock (basically, whether or not it pauses during system sleep) are edge-cases which can be handled for the majority of users with a sensible default value (or better yet, modelling via an enum or boolean switch ‚Äî see #2). Additionally, There are overloads with ‚ÄúwallTime‚Äù parameter labels which seem only to duplicate type information (the monotonic and walltime clocks are actually split at the type level) and could be more concise and readable. The principle is that, ultimately, you should just be able to write the above code like this:<br>&gt;&gt; <br>&gt;&gt; DispatchQueue.main.after(.milliseconds(250)) { /* do stuff */ }<br>&gt;&gt; <br>&gt;&gt; Or<br>&gt;&gt; <br>&gt;&gt; DispatchQueue.main.at &lt;http://dispatchqueue.main.at/&gt;(DispatchTime.now() + .seconds(3)) { /* do stuff */ }<br>&gt;&gt; <br>&gt;&gt; It‚Äôs not something you use all the time (like .sync/.async), but I find that whenever I do need it I‚Äôm frustrated by how needlessly complex it is to decipher and use. I would find these methods much more obvious, I could figure out how to use them much more quickly, and I think I‚Äôd remember how to use them more quickly.<br>&gt; <br>&gt; As mentioned by Matt in the pull request you created, we‚Äôre working on a proposal that would look like this:<br>&gt; <br>&gt; func asyncAfter(deadline:qos:flags:work:)<br>&gt; func asyncAfter(wallDeadline:qos:flags:work:)<br>&gt; As we discussed on the pull request, <br>&gt; <br>&gt; DispatchQueue.main.after(.milliseconds(250)) { /* do stuff */ }<br>&gt; <br>&gt; Is ambiguous as you don‚Äôt know which clock was meant, and despite your claim, there‚Äôs in general no good default for the clock. If you are writing a calendar app, you want wallClock, but if you‚Äôre doing anything network related, you will want the monotonic one. Depending on which software you‚Äôre writing, you will have a bias for one or the other.<br></p><p>Yeah I think we should split after(DispatchTime) and after(DispatchWallTime) to reflect their different ways of working.<br></p><p>after(DispatchTime) stays as it is, because it reflects an elapsed number of ticks<br>after(DispatchWallTime) should be renamed. I suggested it should be at(DispatchWallTime), and should only take an absolute value.<br></p><p>‚Äúafter(deadline:)‚Äù isn‚Äôt better, I‚Äôm afraid. The definition is: &quot;the latest time or date by which something should be completed.‚Äù We don‚Äôt really talk about ‚Äúafter‚Äù deadlines - deadlines are points in time you need to do something *before*. If something happens after a deadline, we say it ‚Äúmissed‚Äù the deadline. Like I said in the PR, that kind of timing guarantee is most clearly expressed by saying ‚Äúby(deadline:)‚Äù.<br></p><p>&gt; <br>&gt; Also it may be a native speaker thing (which I‚Äôm not) but this reads ‚Äúplease async this closure on `q` after this deadline has expired‚Äù to me, which sounds like proper english:<br>&gt; <br>&gt; q.asyncAfter(deadline: .now() + 1.0) { /* do stuff */ }<br>&gt; <br>&gt; <br>&gt; I thought that you would say ‚Äúplease meet me in 10 minutes‚Äù or ‚Äúplease meet me after 2PM‚Äù. The `asyncBy` that you suggested to the pull request reads *before* that deadline to me which is not good either.<br>&gt; `asyncAt` would probably work too however, but asyncAfter is easier for people coming from C who are used to dispatch_after().<br>&gt; <br>&gt; <br>&gt;&gt; #2 - <br>&gt;&gt; <br>&gt;&gt; Actually, while writing this down it‚Äôs becoming clearer and clearer that the idea to split DispatchTime (the monotonic clock) and DispatchWallTime (the wall clock) at the type level is probably a bad idea.<br>&gt;&gt; <br>&gt;&gt; Novice users are not going to understand what‚Äôs going on here - I expect most of them to default to the more generic-sounding ‚ÄúDispatchTime‚Äù without any idea of the implications of this. Perhaps we should look at replacing these clock variations with a more descriptive enum or boolean, rather than a separate type. For example:<br>&gt;&gt; <br>&gt;&gt; struct DispatchTime {                       // replaces DispatchTime and DispatchWallTime<br>&gt;&gt;    let rawValue : dispatch_time_t<br>&gt;&gt;    let clock : Clock<br>&gt;&gt; <br>&gt;&gt;    enum Clock { case monotonicClock; case wallClock }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This would not obsolete the discussion at the start about ‚Äúafter‚Äù. The name ‚Äúafter‚Äù still implies that I want something done at some duration relative to an absolute point in time (usually now).<br>&gt; <br>&gt; This is what dispatch_time_t does in C and my team at Apple widely considers this having been a design mistake: it means that the time is not generally Comparable, that you can‚Äôt perform any kind of arithmetic with it, etc.<br>&gt; <br>&gt; In C it‚Äôs more convenient to have a single type, but in Swift where type is inferred, given that most of the uses will construct the time as the argument to the function itself, we feel that the current proposal allows for the most concise use.<br>&gt; <br></p><p>OK, the motivation to unify them was because it‚Äôs quite easy to get them confused when one is named ‚Äúafter(when: DispatchTime, ‚Ä¶‚Äù and the other is named ‚Äúafter(walltime when: DispatchWallTime, ‚Ä¶‚Äù<br></p><p>Giving them more distinct function names would also work.<br></p><p>Karl<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/cc707b74/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
