<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Idea][Swift 3] Change &#39;DispatchQueue.after&#39; to take a relative time + clock (with default). Maybe replace clocks with an enum?</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 13, 2016 at 06:00:00pm</p></header><div class="content"><p>#1 - <br></p><p>Currently, DispatchQueue.after() takes an absolute time as the “after” parameter. This makes it hard to understand how to use it; you need to go digging through generated interfaces to find out what a ‘DispatchTime’ is and how you construct it (by getting the .now() and adding a DispatchTimeInterval using one of the easily-missable operator overloads, if you were wondering).<br></p><p>Here is what DispatchQueue.after looks like now:<br></p><p>public func after(when: DispatchTime, qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute work: @convention(block) () -&gt; Void)<br></p><p>So to use it, you have to type:<br></p><p>DispatchQueue.main.after(when: DispatchTime.now() + .milliseconds(250))   { /* do stuff */ }<br></p><p>I don’t believe this is a great fit with the Swift API Guidelines. I believe the name “after” already implies that the time is relative, the argument label should be dropped, and that nuances about the clock (basically, whether or not it pauses during system sleep) are edge-cases which can be handled for the majority of users with a sensible default value (or better yet, modelling via an enum or boolean switch — see #2). Additionally, There are overloads with “wallTime” parameter labels which seem only to duplicate type information (the monotonic and walltime clocks are actually split at the type level) and could be more concise and readable. The principle is that, ultimately, you should just be able to write the above code like this:<br></p><p>DispatchQueue.main.after(.milliseconds(250)) { /* do stuff */ }<br></p><p>Or<br></p><p>DispatchQueue.main.at(DispatchTime.now() + .seconds(3)) { /* do stuff */ }<br></p><p>It’s not something you use all the time (like .sync/.async), but I find that whenever I do need it I’m frustrated by how needlessly complex it is to decipher and use. I would find these methods much more obvious, I could figure out how to use them much more quickly, and I think I’d remember how to use them more quickly.<br></p><p>—<br></p><p>#2 - <br></p><p>Actually, while writing this down it’s becoming clearer and clearer that the idea to split DispatchTime (the monotonic clock) and DispatchWallTime (the wall clock) at the type level is probably a bad idea.<br></p><p>Novice users are not going to understand what’s going on here - I expect most of them to default to the more generic-sounding “DispatchTime” without any idea of the implications of this. Perhaps we should look at replacing these clock variations with a more descriptive enum or boolean, rather than a separate type. For example:<br></p><p>struct DispatchTime {                       // replaces DispatchTime and DispatchWallTime<br>    let rawValue : dispatch_time_t<br>    let clock : Clock<br></p><p>    enum Clock { case monotonicClock; case wallClock }<br>}<br></p><p>This would not obsolete the discussion at the start about “after”. The name “after” still implies that I want something done at some duration relative to an absolute point in time (usually now).<br></p><p>Thoughts? <br>There have been some really in-depth naming discussions on here recently, so I’m interested to hear what you make of it.<br></p><p>Karl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/974612b3d1f698cfb3141abdee303df9?s=50"></div><header><strong>[Idea][Swift 3] Change &#39;DispatchQueue.after&#39; to take a relative time + clock (with default). Maybe replace clocks with an enum?</strong> from <string>Anthony Chivetta</string> &lt;achivetta at apple.com&gt;<p>July 13, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 13, 2016, at 9:18 , Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; nuances about the clock (basically, whether or not it pauses during system sleep) are edge-cases which can be handled for the majority of users with a sensible default value<br></p><p>I’m going to stay out of the naming part of the conversation for the moment and just address this point…<br></p><p>I disagree strenuously: it’s a super important distinction that is frequently the cause of subtle but bad bugs!<br></p><p>Lets start with the fact that you (presumably not the novice user you describe below) actually got the difference between the two clocks wrong.  Here’s the current behavior (on Darwin, not sure what Linux currently implements):<br></p><p>  - DispatchTime is a clock that only advances forward and tracks the amount of time the computer is awake.<br></p><p>  - DispatchWillTime is a clock that tracks as a UTC clock would, generally moving ahead during sleep, but is *not* monotonic.  It can move forward, backward, upside down, whatever it wants.  And frequently it will.<br></p><p>And this stuff is hard: if you are writing a tea timer app and you pick either of these, you have a bug.  DispatchTime, the bug is that if the user locks their device and it falls asleep the alarm won’t fire upon wake.  DispatchWallTime, if the device realizes its clock is ahead or behind the “real” time the elapsed duration won’t be what you expect.  (Should we have a third that works for the tea timer? Absolutely…)<br></p><p>So, what’s the sensible default you had in mind that won’t fail for a large portion of use cases?  Safety is an important design point in an API surface and making these distinctions clear to developers is absolutely critical to achieving that goal.<br></p><p>(Of course, Foundation.Timer gets all of the above horribly wrong, IMHO.  We should fix that too…)<br></p><p>&gt;  (the monotonic and walltime clocks are actually split at the type level)<br></p><p>DispatchTime is not a monotonic clock.  At least, not in the POSIX sense.  So let’s not call it that.  (Linux’s failure to implement POSIX correctly notwithstanding.)<br></p><p>&gt; Novice users are not going to understand what’s going on here - I expect most of them to default to the more generic-sounding “DispatchTime” without any idea of the implications of this.<br></p><p>If that’s the case, that’s a good argument for forcing users to make the choice in an even more obvious and explicit way.  Not making it easier to use one or the other when they’ll likely get it wrong.<br></p><p>～ Anthony<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/08c09acb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Idea][Swift 3] Change &#39;DispatchQueue.after&#39; to take a relative time + clock (with default). Maybe replace clocks with an enum?</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 13, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 13 Jul 2016, at 18:47, Anthony Chivetta via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 13, 2016, at 9:18 , Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; nuances about the clock (basically, whether or not it pauses during system sleep) are edge-cases which can be handled for the majority of users with a sensible default value<br>&gt; <br>&gt; I’m going to stay out of the naming part of the conversation for the moment and just address this point…<br>&gt; <br>&gt; I disagree strenuously: it’s a super important distinction that is frequently the cause of subtle but bad bugs!<br>&gt; <br>&gt; Lets start with the fact that you (presumably not the novice user you describe below) actually got the difference between the two clocks wrong.  Here’s the current behavior (on Darwin, not sure what Linux currently implements):<br>&gt; <br>&gt;   - DispatchTime is a clock that only advances forward and tracks the amount of time the computer is awake.<br>&gt; <br>&gt;   - DispatchWillTime is a clock that tracks as a UTC clock would, generally moving ahead during sleep, but is *not* monotonic.  It can move forward, backward, upside down, whatever it wants.  And frequently it will.<br>&gt; <br></p><p>Yeah I know, I don’t think I got the clocks wrong. I forgot that the UTC clock can move around, but yeah, of course it can; fair enough.<br></p><p>&gt; And this stuff is hard: if you are writing a tea timer app and you pick either of these, you have a bug.  DispatchTime, the bug is that if the user locks their device and it falls asleep the alarm won’t fire upon wake.  DispatchWallTime, if the device realizes its clock is ahead or behind the “real” time the elapsed duration won’t be what you expect.  (Should we have a third that works for the tea timer? Absolutely…)<br>&gt; <br></p><p>Do you think that is adequately expressed in the API? <br></p><p>I don’t, and I believe the current system of type-based overloads is not a good way to ensure people don’t accidentally use the wrong one. Maybe we should rename the methods which take each type to make it more of a conscious decision (I’m happy with that, because in that case we definitely have reasonable default values 😎)<br></p><p>&gt; So, what’s the sensible default you had in mind that won’t fail for a large portion of use cases?  Safety is an important design point in an API surface and making these distinctions clear to developers is absolutely critical to achieving that goal.<br></p><p>The default clock depends on the context of what you’re doing. If I’m using DispatchQueue.after, I would say the monotonic clock is a reasonable default. Typically you’re going to be scheduling short fire-once things like performing an animation after a second or two (at the most). In that case, system sleep isn’t an issue - even on iOS where the user can lock the screen at any moment; your long-running alarm that crosses sleep events will still fire, it just won’t fire *immediately* upon wake. iOS in general makes a point not to offer guarantees about what will happen to your app if it ever goes in to the background, and offers alternative backgrounding and local notification APIs instead.<br></p><p>And again, if you considered it and really need that timer to fire immediately if the system dozed off for a little bit in-between, that’s available as an explicit consideration.<br></p><p>I could see how there’s an argument for a third type of timer; it’s obviously a complex topic, and we should provide a reasonable default if possible; even if that’s a platform-specific alias.<br></p><p>&gt; <br>&gt; (Of course, Foundation.Timer gets all of the above horribly wrong, IMHO.  We should fix that too…)<br>&gt; <br>&gt;&gt;  (the monotonic and walltime clocks are actually split at the type level)<br>&gt; <br>&gt; DispatchTime is not a monotonic clock.  At least, not in the POSIX sense.  So let’s not call it that.  (Linux’s failure to implement POSIX correctly notwithstanding.)<br>&gt; <br>&gt;&gt; Novice users are not going to understand what’s going on here - I expect most of them to default to the more generic-sounding “DispatchTime” without any idea of the implications of this.<br>&gt; <br>&gt; If that’s the case, that’s a good argument for forcing users to make the choice in an even more obvious and explicit way.  Not making it easier to use one or the other when they’ll likely get it wrong.<br>&gt; <br></p><p>Yes, that was the motivation behind saying we should merge them - while writing it, it feels like you’re on a bit of a tightrope - one slip and this code could mean something very different.<br></p><p>Karl<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/744828ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27423842cafa2fc08bf56ff675a852e5?s=50"></div><header><strong>[Idea][Swift 3] Change &#39;DispatchQueue.after&#39; to take a relative time + clock (with default). Maybe replace clocks with an enum?</strong> from <string>Daniel A. Steffen</string> &lt;das at apple.com&gt;<p>July 13, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 13, 2016, at 10:08, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 13 Jul 2016, at 18:47, Anthony Chivetta via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 13, 2016, at 9:18 , Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; nuances about the clock (basically, whether or not it pauses during system sleep) are edge-cases which can be handled for the majority of users with a sensible default value<br>&gt;&gt; <br>&gt;&gt; I’m going to stay out of the naming part of the conversation for the moment and just address this point…<br>&gt;&gt; <br>&gt;&gt; I disagree strenuously: it’s a super important distinction that is frequently the cause of subtle but bad bugs!<br>&gt;&gt; <br>&gt;&gt; Lets start with the fact that you (presumably not the novice user you describe below) actually got the difference between the two clocks wrong.  Here’s the current behavior (on Darwin, not sure what Linux currently implements):<br>&gt;&gt; <br>&gt;&gt;   - DispatchTime is a clock that only advances forward and tracks the amount of time the computer is awake.<br>&gt;&gt; <br>&gt;&gt;   - DispatchWillTime is a clock that tracks as a UTC clock would, generally moving ahead during sleep, but is *not* monotonic.  It can move forward, backward, upside down, whatever it wants.  And frequently it will.<br>&gt;&gt; <br>&gt; <br>&gt; Yeah I know, I don’t think I got the clocks wrong. I forgot that the UTC clock can move around, but yeah, of course it can; fair enough.<br>&gt; <br>&gt;&gt; And this stuff is hard: if you are writing a tea timer app and you pick either of these, you have a bug.  DispatchTime, the bug is that if the user locks their device and it falls asleep the alarm won’t fire upon wake.  DispatchWallTime, if the device realizes its clock is ahead or behind the “real” time the elapsed duration won’t be what you expect.  (Should we have a third that works for the tea timer? Absolutely…)<br>&gt;&gt; <br>&gt; <br>&gt; Do you think that is adequately expressed in the API? <br>&gt; <br>&gt; I don’t, and I believe the current system of type-based overloads is not a good way to ensure people don’t accidentally use the wrong one. Maybe we should rename the methods which take each type to make it more of a conscious decision (I’m happy with that, because in that case we definitely have reasonable default values 😎)<br></p><p>I’m confused, that is what we have in the current version (the argument label is part of the overall method name): asyncAfter(deadline:) vs asyncAfter(wallDeadline:), which is consistent with all the other labels of deadline arguments in the API (this isn’t the only method dealing with time)<br></p><p>we did discuss naming these asyncAt() instead of asyncAfter(), which would make it more clear that they take a deadline, but the name felt uncomfortably close to async(), and may also lead to the mistaken impression that the execution with occur exactly _at_ the deadline (as opposed to just the async() to a queue that may be full of other items already and take a while to drain, or be suspended and never execute at all)<br></p><p>&gt; <br>&gt;&gt; So, what’s the sensible default you had in mind that won’t fail for a large portion of use cases?  Safety is an important design point in an API surface and making these distinctions clear to developers is absolutely critical to achieving that goal.<br>&gt; <br>&gt; The default clock depends on the context of what you’re doing. If I’m using DispatchQueue.after, I would say the monotonic clock is a reasonable default. Typically you’re going to be scheduling short fire-once things like performing an animation after a second or two (at the most). In that case, system sleep isn’t an issue - even on iOS where the user can lock the screen at any moment; your long-running alarm that crosses sleep events will still fire, it just won’t fire *immediately* upon wake.<br></p><p>Nothing in the API says it must be used only for &quot;short fire-once things&quot;<br></p><p>The problem with the monotonic clock isn’t about firing at wake, but about pushing the fire time out by the amount of time asleep.<br>If you are using this to implement e.g. a calendaring meeting reminder alarms, you are not going to be happy if your reminder is late by the amount of time that your device happened to put its cpu to sleep for many short intervals for power management reasons...<br></p><p>&gt; iOS in general makes a point not to offer guarantees about what will happen to your app if it ever goes in to the background, and offers alternative backgrounding and local notification APIs instead.<br></p><p>this API isn’t just designed for iOS Apps but for system programming in general, on any platform.<br></p><p>&gt; <br>&gt; And again, if you considered it and really need that timer to fire immediately if the system dozed off for a little bit in-between, that’s available as an explicit consideration.<br>&gt; <br>&gt; I could see how there’s an argument for a third type of timer; it’s obviously a complex topic, and we should provide a reasonable default if possible; even if that’s a platform-specific alias.<br></p><p>yes this was intentionally designed to accommodate additional clocks<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; (Of course, Foundation.Timer gets all of the above horribly wrong, IMHO.  We should fix that too…)<br>&gt;&gt; <br>&gt;&gt;&gt;  (the monotonic and walltime clocks are actually split at the type level)<br>&gt;&gt; <br>&gt;&gt; DispatchTime is not a monotonic clock.  At least, not in the POSIX sense.  So let’s not call it that.  (Linux’s failure to implement POSIX correctly notwithstanding.)<br>&gt;&gt; <br>&gt;&gt;&gt; Novice users are not going to understand what’s going on here - I expect most of them to default to the more generic-sounding “DispatchTime” without any idea of the implications of this.<br>&gt;&gt; <br>&gt;&gt; If that’s the case, that’s a good argument for forcing users to make the choice in an even more obvious and explicit way.  Not making it easier to use one or the other when they’ll likely get it wrong.<br>&gt;&gt; <br>&gt; <br>&gt; Yes, that was the motivation behind saying we should merge them - while writing it, it feels like you’re on a bit of a tightrope - one slip and this code could mean something very different.<br>&gt; <br>&gt; Karl<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/3dd5b02d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Idea][Swift 3] Change &#39;DispatchQueue.after&#39; to take a relative time + clock (with default). Maybe replace clocks with an enum?</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 13, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 13 Jul 2016, at 19:59, Daniel A. Steffen &lt;das at apple.com&gt; wrote:<br>&gt; <br>&gt; I’m confused, that is what we have in the current version (the argument label is part of the overall method name): asyncAfter(deadline:) vs asyncAfter(wallDeadline:), which is consistent with all the other labels of deadline arguments in the API (this isn’t the only method dealing with time)<br>&gt; <br></p><p>I think this argument labels are superfluous and actually make the meaning less coherent. “after(when:…)” is not grammatically fluent, which the Swift API guidelines encourage, and which the standard library has made big steps towards recently (see especially https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md). By dropping the labels and renaming the function base-names, we make them more “swifty”, more concise, clear and readable, and can improve safety by making sure people know which clock they’re using and what semantic meaning that has. <br></p><p><br>&gt; we did discuss naming these asyncAt() instead of asyncAfter(), which would make it more clear that they take a deadline, but the name felt uncomfortably close to async(), and may also lead to the mistaken impression that the execution with occur exactly _at_ the deadline (as opposed to just the async() to a queue that may be full of other items already and take a while to drain, or be suspended and never execute at all)<br>&gt; <br></p><p>I’m not sure it’s really necessary to include the word “async” in there — it’s pretty clear from the fact that they take a time that they’re not going to block.<br></p><p>The problem with “deadline” is that it’s just not a deadline. It’s an aspirational fire time, and Dispatch should execute the block as soon as possible after that time. I can’t really think of a concise word for it, but “deadline” does not express what you’re talking about. Deadline implies that the block can execute any time _before_ the specified time.<br></p><p>So that’s where I get “at” from; if your app is asleep, it isn’t possible to execute exactly at the specified time for reasons outside of your control. If it executes as soon as possible after waking, I would still consider it to be firing “at” the correct time (in a loose sort of way). If we were talking about the dispatch queue as a person, and I asked him/her to do something at a particular time, but they were delayed due to circumstances outside of anybody&#39;s control (like a natural disaster or a traffic accident), I’d still consider that they did it “at” the correct time, again in a loose sense - to the best that they can control it, in other words.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; So, what’s the sensible default you had in mind that won’t fail for a large portion of use cases?  Safety is an important design point in an API surface and making these distinctions clear to developers is absolutely critical to achieving that goal.<br>&gt;&gt; <br>&gt;&gt; The default clock depends on the context of what you’re doing. If I’m using DispatchQueue.after, I would say the monotonic clock is a reasonable default. Typically you’re going to be scheduling short fire-once things like performing an animation after a second or two (at the most). In that case, system sleep isn’t an issue - even on iOS where the user can lock the screen at any moment; your long-running alarm that crosses sleep events will still fire, it just won’t fire *immediately* upon wake. <br>&gt; <br>&gt; Nothing in the API says it must be used only for &quot;short fire-once things&quot;<br>&gt; <br>&gt; The problem with the monotonic clock isn’t about firing at wake, but about pushing the fire time out by the amount of time asleep.<br>&gt; If you are using this to implement e.g. a calendaring meeting reminder alarms, you are not going to be happy if your reminder is late by the amount of time that your device happened to put its cpu to sleep for many short intervals for power management reasons…<br></p><p>No, nothing in the API does say that, but in this context I believe it’s the most commonly wanted thing and would be a reasonable default.<br></p><p>If you are implementing calendar reminders using dispatch_after in an application which can be suspended at any moment, you’re using the wrong API pure and simple. On Linux, you might be able to guarantee your app won’t be suspended so this strategy could work for you, but the API you use must be appropriate to the platform. If you can’t make that guarantee (e.g. On iOS), you should look for an alternative, such as the local notifications API, which is designed for exactly this.<br></p><p>&gt; <br>&gt;&gt; iOS in general makes a point not to offer guarantees about what will happen to your app if it ever goes in to the background, and offers alternative backgrounding and local notification APIs instead.<br>&gt; <br>&gt; this API isn’t just designed for iOS Apps but for system programming in general, on any platform.<br>&gt; <br></p><p>No, but as above, the API you use must be appropriate for the platform. We shouldn’t worry about people on iOS using dispatch_after for calendar notifications. Those people will run in to all kinds of headaches anyway, asking them to be explicit about which clock they use is pretty fair IMO. I would say it might even help them...<br></p><p>&gt;&gt; <br>&gt;&gt; And again, if you considered it and really need that timer to fire immediately if the system dozed off for a little bit in-between, that’s available as an explicit consideration.<br>&gt;&gt; <br>&gt;&gt; I could see how there’s an argument for a third type of timer; it’s obviously a complex topic, and we should provide a reasonable default if possible; even if that’s a platform-specific alias.<br>&gt; <br>&gt; yes this was intentionally designed to accommodate additional clocks<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Of course, Foundation.Timer gets all of the above horribly wrong, IMHO.  We should fix that too…)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  (the monotonic and walltime clocks are actually split at the type level)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; DispatchTime is not a monotonic clock.  At least, not in the POSIX sense.  So let’s not call it that.  (Linux’s failure to implement POSIX correctly notwithstanding.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Novice users are not going to understand what’s going on here - I expect most of them to default to the more generic-sounding “DispatchTime” without any idea of the implications of this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If that’s the case, that’s a good argument for forcing users to make the choice in an even more obvious and explicit way.  Not making it easier to use one or the other when they’ll likely get it wrong.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Yes, that was the motivation behind saying we should merge them - while writing it, it feels like you’re on a bit of a tightrope - one slip and this code could mean something very different.<br>&gt;&gt; <br>&gt;&gt; Karl<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/6249ea45/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0db24e79de1d6e82cf6327b091903b1b?s=50"></div><header><strong>[Idea][Swift 3] Change &#39;DispatchQueue.after&#39; to take a relative time + clock (with default). Maybe replace clocks with an enum?</strong> from <string>Pierre Habouzit</string> &lt;phabouzit at apple.com&gt;<p>July 13, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jul 13, 2016, at 11:42 AM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 13 Jul 2016, at 19:59, Daniel A. Steffen &lt;das at apple.com &lt;mailto:das at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m confused, that is what we have in the current version (the argument label is part of the overall method name): asyncAfter(deadline:) vs asyncAfter(wallDeadline:), which is consistent with all the other labels of deadline arguments in the API (this isn’t the only method dealing with time)<br>&gt;&gt; <br>&gt; <br>&gt; I think this argument labels are superfluous and actually make the meaning less coherent. “after(when:…)” is not grammatically fluent, which the Swift API guidelines encourage, and which the standard library has made big steps towards recently (see especially https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md&gt;). By dropping the labels and renaming the function base-names, we make them more “swifty”, more concise, clear and readable, and can improve safety by making sure people know which clock they’re using and what semantic meaning that has. <br></p><p>after(when:) is the current state of the overlay but we told you we’re proposing something new, so your argument is not in complete good faith here is it? ;)<br></p><p>&gt;&gt; we did discuss naming these asyncAt() instead of asyncAfter(), which would make it more clear that they take a deadline, but the name felt uncomfortably close to async(), and may also lead to the mistaken impression that the execution with occur exactly _at_ the deadline (as opposed to just the async() to a queue that may be full of other items already and take a while to drain, or be suspended and never execute at all)<br>&gt;&gt; <br>&gt; <br>&gt; I’m not sure it’s really necessary to include the word “async” in there — it’s pretty clear from the fact that they take a time that they’re not going to block.<br>&gt; <br>&gt; The problem with “deadline” is that it’s just not a deadline. It’s an aspirational fire time, and Dispatch should execute the block as soon as possible after that time. I can’t really think of a concise word for it, but “deadline” does not express what you’re talking about. Deadline implies that the block can execute any time _before_ the specified time.<br>&gt; <br>&gt; So that’s where I get “at” from; if your app is asleep, it isn’t possible to execute exactly at the specified time for reasons outside of your control. If it executes as soon as possible after waking, I would still consider it to be firing “at” the correct time (in a loose sort of way). If we were talking about the dispatch queue as a person, and I asked him/her to do something at a particular time, but they were delayed due to circumstances outside of anybody&#39;s control (like a natural disaster or a traffic accident), I’d still consider that they did it “at” the correct time, again in a loose sense - to the best that they can control it, in other words.<br></p><p>I strongly disagree that the two forms should be named differently, it’s even more confusing that if you use after() you get one clock and at() the other. Also when we will add a 3rd clock to dispatch, it just stops working completely (look at clock_gettime() that was finally added to macOS, it has 3 interesting clocks: MONOTONIC, UPTIME, and WALLTIME that posix calls REALTIME for some weird reason).<br></p><p>the functions should exactly differ with the argument tag to show that they basically perform the same task with a slight difference that is the clock you’re using. It’s concise, unambiguous, and regular with the other functions in the Dispatch module that handle time. Which in my opinion goes exactly in the direction of SE-0118.<br></p><p>&gt;&gt;&gt;&gt; So, what’s the sensible default you had in mind that won’t fail for a large portion of use cases?  Safety is an important design point in an API surface and making these distinctions clear to developers is absolutely critical to achieving that goal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The default clock depends on the context of what you’re doing. If I’m using DispatchQueue.after, I would say the monotonic clock is a reasonable default. Typically you’re going to be scheduling short fire-once things like performing an animation after a second or two (at the most). In that case, system sleep isn’t an issue - even on iOS where the user can lock the screen at any moment; your long-running alarm that crosses sleep events will still fire, it just won’t fire *immediately* upon wake. <br>&gt;&gt; <br>&gt;&gt; Nothing in the API says it must be used only for &quot;short fire-once things&quot;<br>&gt;&gt; <br>&gt;&gt; The problem with the monotonic clock isn’t about firing at wake, but about pushing the fire time out by the amount of time asleep.<br>&gt;&gt; If you are using this to implement e.g. a calendaring meeting reminder alarms, you are not going to be happy if your reminder is late by the amount of time that your device happened to put its cpu to sleep for many short intervals for power management reasons…<br>&gt; <br>&gt; No, nothing in the API does say that, but in this context I believe it’s the most commonly wanted thing and would be a reasonable default.<br>&gt; <br>&gt; If you are implementing calendar reminders using dispatch_after in an application which can be suspended at any moment, you’re using the wrong API pure and simple. On Linux, you might be able to guarantee your app won’t be suspended so this strategy could work for you, but the API you use must be appropriate to the platform. If you can’t make that guarantee (e.g. On iOS), you should look for an alternative, such as the local notifications API, which is designed for exactly this.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; iOS in general makes a point not to offer guarantees about what will happen to your app if it ever goes in to the background, and offers alternative backgrounding and local notification APIs instead.<br>&gt;&gt; <br>&gt;&gt; this API isn’t just designed for iOS Apps but for system programming in general, on any platform.<br>&gt;&gt; <br>&gt; <br>&gt; No, but as above, the API you use must be appropriate for the platform. We shouldn’t worry about people on iOS using dispatch_after for calendar notifications. Those people will run in to all kinds of headaches anyway, asking them to be explicit about which clock they use is pretty fair IMO. I would say it might even help them…<br></p><p><br>This was an example was to give you a sense of why what you’re asking feels wrong to us. But if you want a better one: dispatch_after() is completely suitable to have a notification in app when a given wall time passes if you’re in the app. It avoids the overhead and headaches of complex notification mechanisms, which are sometimes not even desired (if you’re not in the app, having the system wake up for that timer is a power issue). There are several apps doing that.<br></p><p>We hence don’t think that what you’re asking for is serving developers.<br></p><p>also note that the C API works that way for a long time:<br></p><p>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, …), …)<br>dispatch_after(dispatch_walltime(DISPATCH_TIME_NOW, …), …)<br></p><p>to me it’s visually similar to:<br></p><p>q.asyncAfter(deadline: .now() + …) …<br>q.asyncAfter(wallDeadline: .now() + …) …<br></p><p>And while making things more swifty (and DispatchWorkItem shows that we’re dedicated to that when there’s a benefit), making it too dissimilar to the C interface for no good reason is something to IMO consider when picking names here.<br></p><p><br>-Pierre<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/87f312d5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Idea][Swift 3] Change &#39;DispatchQueue.after&#39; to take a relative time + clock (with default). Maybe replace clocks with an enum?</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 13, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 13 Jul 2016, at 21:04, Pierre Habouzit &lt;phabouzit at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 13, 2016, at 11:42 AM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 13 Jul 2016, at 19:59, Daniel A. Steffen &lt;das at apple.com &lt;mailto:das at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m confused, that is what we have in the current version (the argument label is part of the overall method name): asyncAfter(deadline:) vs asyncAfter(wallDeadline:), which is consistent with all the other labels of deadline arguments in the API (this isn’t the only method dealing with time)<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I think this argument labels are superfluous and actually make the meaning less coherent. “after(when:…)” is not grammatically fluent, which the Swift API guidelines encourage, and which the standard library has made big steps towards recently (see especially https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md&gt;). By dropping the labels and renaming the function base-names, we make them more “swifty”, more concise, clear and readable, and can improve safety by making sure people know which clock they’re using and what semantic meaning that has. <br>&gt; <br>&gt; after(when:) is the current state of the overlay but we told you we’re proposing something new, so your argument is not in complete good faith here is it? ;)<br></p><p>Yeah, I know - you’re proposing to rename it, I’m proposing that it should have a different type (which would be enabled by a different renaming to the one you’re proposing). So I think it’s a fair debate. I gave my opinion on “deadline&quot; - the time you specify isn’t actually a deadline, is it? It isn’t the latest possible the time the block is allowed to execute; it’s the earliest possible time.<br></p><p>Maybe there is a language gap in there, maybe people use “deadline” more loosely to mean a general point in time in California, but the dictionary agrees that deadline means &quot;the latest time or date by which something should be completed”, which is not what I think you mean (maybe I’m wrong, but that’s my understanding of what you’ve been saying so far).<br></p><p>&gt; <br>&gt;&gt;&gt; we did discuss naming these asyncAt() instead of asyncAfter(), which would make it more clear that they take a deadline, but the name felt uncomfortably close to async(), and may also lead to the mistaken impression that the execution with occur exactly _at_ the deadline (as opposed to just the async() to a queue that may be full of other items already and take a while to drain, or be suspended and never execute at all)<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I’m not sure it’s really necessary to include the word “async” in there — it’s pretty clear from the fact that they take a time that they’re not going to block.<br>&gt;&gt; <br>&gt;&gt; The problem with “deadline” is that it’s just not a deadline. It’s an aspirational fire time, and Dispatch should execute the block as soon as possible after that time. I can’t really think of a concise word for it, but “deadline” does not express what you’re talking about. Deadline implies that the block can execute any time _before_ the specified time.<br>&gt;&gt; <br>&gt;&gt; So that’s where I get “at” from; if your app is asleep, it isn’t possible to execute exactly at the specified time for reasons outside of your control. If it executes as soon as possible after waking, I would still consider it to be firing “at” the correct time (in a loose sort of way). If we were talking about the dispatch queue as a person, and I asked him/her to do something at a particular time, but they were delayed due to circumstances outside of anybody&#39;s control (like a natural disaster or a traffic accident), I’d still consider that they did it “at” the correct time, again in a loose sense - to the best that they can control it, in other words.<br>&gt; <br>&gt; I strongly disagree that the two forms should be named differently, it’s even more confusing that if you use after() you get one clock and at() the other. Also when we will add a 3rd clock to dispatch, it just stops working completely (look at clock_gettime() that was finally added to macOS, it has 3 interesting clocks: MONOTONIC, UPTIME, and WALLTIME that posix calls REALTIME for some weird reason).<br>&gt; <br>&gt; the functions should exactly differ with the argument tag to show that they basically perform the same task with a slight difference that is the clock you’re using. It’s concise, unambiguous, and regular with the other functions in the Dispatch module that handle time. Which in my opinion goes exactly in the direction of SE-0118.<br>&gt; <br></p><p>Didn’t we agree earlier that the clock type is not a minor distinction? And that there are rather large differences about when the block might fire depending on which clock you use. This was Anthony Chievetta (maybe I misunderstood him, too):<br></p><p>&gt; I disagree strenuously: it’s a super important distinction that is frequently the cause of subtle but bad bugs!<br>&gt; <br>&gt; Lets start with the fact that you (presumably not the novice user you describe below) actually got the difference between the two clocks wrong.  Here’s the current behavior (on Darwin, not sure what Linux currently implements):<br>&gt; <br>&gt;   - DispatchTime is a clock that only advances forward and tracks the amount of time the computer is awake.<br>&gt; <br>&gt;   - DispatchWillTime is a clock that tracks as a UTC clock would, generally moving ahead during sleep, but is *not* monotonic.  It can move forward, backward, upside down, whatever it wants.  And frequently it will.<br>&gt; <br>&gt; And this stuff is hard: if you are writing a tea timer app and you pick either of these, you have a bug.  DispatchTime, the bug is that if the user locks their device and it falls asleep the alarm won’t fire upon wake.  DispatchWallTime, if the device realizes its clock is ahead or behind the “real” time the elapsed duration won’t be what you expect.  (Should we have a third that works for the tea timer? Absolutely…)<br></p><p><br></p><p>If there is some new clock introduced later, with different scheduling guarantees, it can get its own unique name to reflect what it does, right?<br></p><p><br>&gt;&gt;&gt;&gt;&gt; <br>&gt; <br>&gt; <br>&gt; This was an example was to give you a sense of why what you’re asking feels wrong to us. But if you want a better one: dispatch_after() is completely suitable to have a notification in app when a given wall time passes if you’re in the app. It avoids the overhead and headaches of complex notification mechanisms, which are sometimes not even desired (if you’re not in the app, having the system wake up for that timer is a power issue). There are several apps doing that.<br>&gt; <br>&gt; We hence don’t think that what you’re asking for is serving developers.<br>&gt; <br>&gt; also note that the C API works that way for a long time:<br>&gt; <br>&gt; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, …), …)<br>&gt; dispatch_after(dispatch_walltime(DISPATCH_TIME_NOW, …), …)<br>&gt; <br>&gt; to me it’s visually similar to:<br>&gt; <br>&gt; q.asyncAfter(deadline: .now() + …) …<br>&gt; q.asyncAfter(wallDeadline: .now() + …) …<br>&gt; <br>&gt; And while making things more swifty (and DispatchWorkItem shows that we’re dedicated to that when there’s a benefit), making it too dissimilar to the C interface for no good reason is something to IMO consider when picking names here.<br></p><p>The C API was also horrible in that regard. I bet there’s not a handful of people on this mailing list who could tell you exactly how to invoke dispatch_after. Everybody just uses the Xcode macro because it’s a mountain of jargon that almost nobody needs to care about.<br></p><p>That’s the whole point of all of this - I’m not proposing removing functionality, just making it more obvious and intuitive. If these clocks have such enormous differences, they should have unique names to reflect that — and since we now know the clock, we can supply defaults and take intervals rather than absolute times, making the names fluent and clear.<br></p><p>That’s why I think my proposed change is so much for the better - it leads to massive simplifications all-around, and things will just make so much more sense afterwards, without reducing functionality. Nuances that were hidden will be exposed, and you won’t need to dig through interfaces looking for operator overloads any more - autocomplete will be able to tell you exactly what to enter.<br></p><p>That’s why I’m not disparaged by how many of you Apple guys disagree - after all, you guys designed the original C API that this very-closely follows (which is a great API, don’t get me wrong, but this function hasn’t adapted to Swift yet IMO). It could be clearer and more approachable for end-users.<br></p><p><br>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/1e4ca73a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Idea][Swift 3] Change &#39;DispatchQueue.after&#39; to take a relative time + clock (with default). Maybe replace clocks with an enum?</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>July 13, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 13 Jul 2016, at 20:04, Pierre Habouzit via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I strongly disagree that the two forms should be named differently, it’s even more confusing that if you use after() you get one clock and at() the other. Also when we will add a 3rd clock to dispatch, it just stops working completely (look at clock_gettime() that was finally added to macOS, it has 3 interesting clocks: MONOTONIC, UPTIME, and WALLTIME that posix calls REALTIME for some weird reason).<br>&gt; <br>&gt; the functions should exactly differ with the argument tag to show that they basically perform the same task with a slight difference that is the clock you’re using. It’s concise, unambiguous, and regular with the other functions in the Dispatch module that handle time. Which in my opinion goes exactly in the direction of SE-0118.<br></p><p>Methods taking DispatchTime or DispatchWallTime parameters have duplicate implementations. Shouldn&#39;t they be generic?<br></p><p>	public func wait&lt;T: DispatchTime&gt;(timeout: T? = nil) -&gt; DispatchTimeoutResult<br></p><p>As I mentioned in the review, DISPATCH_TIME_FOREVER can be represented as an Optional parameter, so `distantFuture` isn&#39;t needed.<br></p><p>	group.wait(timeout: DispatchWallTime() + .seconds(10))<br></p><p>	group.wait()<br></p><p>DispatchTime would be a protocol, and the existing structure would be renamed.<br></p><p>	public protocol DispatchTime: Comparable, RawRepresentable {<br></p><p>	    var rawValue: dispatch_time_t { get }<br></p><p>	    init(rawValue: dispatch_time_t)<br></p><p>	    init()<br>	}<br></p><p>-- Ben<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0db24e79de1d6e82cf6327b091903b1b?s=50"></div><header><strong>[Idea][Swift 3] Change &#39;DispatchQueue.after&#39; to take a relative time + clock (with default). Maybe replace clocks with an enum?</strong> from <string>Pierre Habouzit</string> &lt;phabouzit at apple.com&gt;<p>July 13, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 13, 2016, at 9:18 AM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; #1 - <br>&gt; <br>&gt; Currently, DispatchQueue.after() takes an absolute time as the “after” parameter. This makes it hard to understand how to use it; you need to go digging through generated interfaces to find out what a ‘DispatchTime’ is and how you construct it (by getting the .now() and adding a DispatchTimeInterval using one of the easily-missable operator overloads, if you were wondering).<br>&gt; <br>&gt; Here is what DispatchQueue.after looks like now:<br>&gt; <br>&gt; public func after(when: DispatchTime, qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute work: @convention(block) () -&gt; Void)<br>&gt; <br>&gt; So to use it, you have to type:<br>&gt; <br>&gt; DispatchQueue.main.after(when: DispatchTime.now() + .milliseconds(250))   { /* do stuff */ }<br>&gt; <br>&gt; I don’t believe this is a great fit with the Swift API Guidelines. I believe the name “after” already implies that the time is relative, the argument label should be dropped, and that nuances about the clock (basically, whether or not it pauses during system sleep) are edge-cases which can be handled for the majority of users with a sensible default value (or better yet, modelling via an enum or boolean switch — see #2). Additionally, There are overloads with “wallTime” parameter labels which seem only to duplicate type information (the monotonic and walltime clocks are actually split at the type level) and could be more concise and readable. The principle is that, ultimately, you should just be able to write the above code like this:<br>&gt; <br>&gt; DispatchQueue.main.after(.milliseconds(250)) { /* do stuff */ }<br>&gt; <br>&gt; Or<br>&gt; <br>&gt; DispatchQueue.main.at(DispatchTime.now() + .seconds(3)) { /* do stuff */ }<br>&gt; <br>&gt; It’s not something you use all the time (like .sync/.async), but I find that whenever I do need it I’m frustrated by how needlessly complex it is to decipher and use. I would find these methods much more obvious, I could figure out how to use them much more quickly, and I think I’d remember how to use them more quickly.<br></p><p>As mentioned by Matt in the pull request you created, we’re working on a proposal that would look like this:<br></p><p>func asyncAfter(deadline:qos:flags:work:)<br>func asyncAfter(wallDeadline:qos:flags:work:)<br>As we discussed on the pull request, <br></p><p>DispatchQueue.main.after(.milliseconds(250)) { /* do stuff */ }<br></p><p>Is ambiguous as you don’t know which clock was meant, and despite your claim, there’s in general no good default for the clock. If you are writing a calendar app, you want wallClock, but if you’re doing anything network related, you will want the monotonic one. Depending on which software you’re writing, you will have a bias for one or the other.<br></p><p>Also it may be a native speaker thing (which I’m not) but this reads “please async this closure on `q` after this deadline has expired” to me, which sounds like proper english:<br></p><p>q.asyncAfter(deadline: .now() + 1.0) { /* do stuff */ }<br></p><p><br>I thought that you would say “please meet me in 10 minutes” or “please meet me after 2PM”. The `asyncBy` that you suggested to the pull request reads *before* that deadline to me which is not good either.<br>`asyncAt` would probably work too however, but asyncAfter is easier for people coming from C who are used to dispatch_after().<br></p><p><br>&gt; #2 - <br>&gt; <br>&gt; Actually, while writing this down it’s becoming clearer and clearer that the idea to split DispatchTime (the monotonic clock) and DispatchWallTime (the wall clock) at the type level is probably a bad idea.<br>&gt; <br>&gt; Novice users are not going to understand what’s going on here - I expect most of them to default to the more generic-sounding “DispatchTime” without any idea of the implications of this. Perhaps we should look at replacing these clock variations with a more descriptive enum or boolean, rather than a separate type. For example:<br>&gt; <br>&gt; struct DispatchTime {                       // replaces DispatchTime and DispatchWallTime<br>&gt;    let rawValue : dispatch_time_t<br>&gt;    let clock : Clock<br>&gt; <br>&gt;    enum Clock { case monotonicClock; case wallClock }<br>&gt; }<br>&gt; <br>&gt; This would not obsolete the discussion at the start about “after”. The name “after” still implies that I want something done at some duration relative to an absolute point in time (usually now).<br></p><p>This is what dispatch_time_t does in C and my team at Apple widely considers this having been a design mistake: it means that the time is not generally Comparable, that you can’t perform any kind of arithmetic with it, etc.<br></p><p>In C it’s more convenient to have a single type, but in Swift where type is inferred, given that most of the uses will construct the time as the argument to the function itself, we feel that the current proposal allows for the most concise use.<br></p><p><br></p><p>-Pierre<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/31c83154/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Idea][Swift 3] Change &#39;DispatchQueue.after&#39; to take a relative time + clock (with default). Maybe replace clocks with an enum?</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 13, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 13 Jul 2016, at 18:56, Pierre Habouzit &lt;phabouzit at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 13, 2016, at 9:18 AM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; #1 - <br>&gt;&gt; <br>&gt;&gt; Currently, DispatchQueue.after() takes an absolute time as the “after” parameter. This makes it hard to understand how to use it; you need to go digging through generated interfaces to find out what a ‘DispatchTime’ is and how you construct it (by getting the .now() and adding a DispatchTimeInterval using one of the easily-missable operator overloads, if you were wondering).<br>&gt;&gt; <br>&gt;&gt; Here is what DispatchQueue.after looks like now:<br>&gt;&gt; <br>&gt;&gt; public func after(when: DispatchTime, qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute work: @convention(block) () -&gt; Void)<br>&gt;&gt; <br>&gt;&gt; So to use it, you have to type:<br>&gt;&gt; <br>&gt;&gt; DispatchQueue.main.after(when: DispatchTime.now() + .milliseconds(250))   { /* do stuff */ }<br>&gt;&gt; <br>&gt;&gt; I don’t believe this is a great fit with the Swift API Guidelines. I believe the name “after” already implies that the time is relative, the argument label should be dropped, and that nuances about the clock (basically, whether or not it pauses during system sleep) are edge-cases which can be handled for the majority of users with a sensible default value (or better yet, modelling via an enum or boolean switch — see #2). Additionally, There are overloads with “wallTime” parameter labels which seem only to duplicate type information (the monotonic and walltime clocks are actually split at the type level) and could be more concise and readable. The principle is that, ultimately, you should just be able to write the above code like this:<br>&gt;&gt; <br>&gt;&gt; DispatchQueue.main.after(.milliseconds(250)) { /* do stuff */ }<br>&gt;&gt; <br>&gt;&gt; Or<br>&gt;&gt; <br>&gt;&gt; DispatchQueue.main.at &lt;http://dispatchqueue.main.at/&gt;(DispatchTime.now() + .seconds(3)) { /* do stuff */ }<br>&gt;&gt; <br>&gt;&gt; It’s not something you use all the time (like .sync/.async), but I find that whenever I do need it I’m frustrated by how needlessly complex it is to decipher and use. I would find these methods much more obvious, I could figure out how to use them much more quickly, and I think I’d remember how to use them more quickly.<br>&gt; <br>&gt; As mentioned by Matt in the pull request you created, we’re working on a proposal that would look like this:<br>&gt; <br>&gt; func asyncAfter(deadline:qos:flags:work:)<br>&gt; func asyncAfter(wallDeadline:qos:flags:work:)<br>&gt; As we discussed on the pull request, <br>&gt; <br>&gt; DispatchQueue.main.after(.milliseconds(250)) { /* do stuff */ }<br>&gt; <br>&gt; Is ambiguous as you don’t know which clock was meant, and despite your claim, there’s in general no good default for the clock. If you are writing a calendar app, you want wallClock, but if you’re doing anything network related, you will want the monotonic one. Depending on which software you’re writing, you will have a bias for one or the other.<br></p><p>Yeah I think we should split after(DispatchTime) and after(DispatchWallTime) to reflect their different ways of working.<br></p><p>after(DispatchTime) stays as it is, because it reflects an elapsed number of ticks<br>after(DispatchWallTime) should be renamed. I suggested it should be at(DispatchWallTime), and should only take an absolute value.<br></p><p>“after(deadline:)” isn’t better, I’m afraid. The definition is: &quot;the latest time or date by which something should be completed.” We don’t really talk about “after” deadlines - deadlines are points in time you need to do something *before*. If something happens after a deadline, we say it “missed” the deadline. Like I said in the PR, that kind of timing guarantee is most clearly expressed by saying “by(deadline:)”.<br></p><p>&gt; <br>&gt; Also it may be a native speaker thing (which I’m not) but this reads “please async this closure on `q` after this deadline has expired” to me, which sounds like proper english:<br>&gt; <br>&gt; q.asyncAfter(deadline: .now() + 1.0) { /* do stuff */ }<br>&gt; <br>&gt; <br>&gt; I thought that you would say “please meet me in 10 minutes” or “please meet me after 2PM”. The `asyncBy` that you suggested to the pull request reads *before* that deadline to me which is not good either.<br>&gt; `asyncAt` would probably work too however, but asyncAfter is easier for people coming from C who are used to dispatch_after().<br>&gt; <br>&gt; <br>&gt;&gt; #2 - <br>&gt;&gt; <br>&gt;&gt; Actually, while writing this down it’s becoming clearer and clearer that the idea to split DispatchTime (the monotonic clock) and DispatchWallTime (the wall clock) at the type level is probably a bad idea.<br>&gt;&gt; <br>&gt;&gt; Novice users are not going to understand what’s going on here - I expect most of them to default to the more generic-sounding “DispatchTime” without any idea of the implications of this. Perhaps we should look at replacing these clock variations with a more descriptive enum or boolean, rather than a separate type. For example:<br>&gt;&gt; <br>&gt;&gt; struct DispatchTime {                       // replaces DispatchTime and DispatchWallTime<br>&gt;&gt;    let rawValue : dispatch_time_t<br>&gt;&gt;    let clock : Clock<br>&gt;&gt; <br>&gt;&gt;    enum Clock { case monotonicClock; case wallClock }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This would not obsolete the discussion at the start about “after”. The name “after” still implies that I want something done at some duration relative to an absolute point in time (usually now).<br>&gt; <br>&gt; This is what dispatch_time_t does in C and my team at Apple widely considers this having been a design mistake: it means that the time is not generally Comparable, that you can’t perform any kind of arithmetic with it, etc.<br>&gt; <br>&gt; In C it’s more convenient to have a single type, but in Swift where type is inferred, given that most of the uses will construct the time as the argument to the function itself, we feel that the current proposal allows for the most concise use.<br>&gt; <br></p><p>OK, the motivation to unify them was because it’s quite easy to get them confused when one is named “after(when: DispatchTime, …” and the other is named “after(walltime when: DispatchWallTime, …”<br></p><p>Giving them more distinct function names would also work.<br></p><p>Karl<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/cc707b74/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
