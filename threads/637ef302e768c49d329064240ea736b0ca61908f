<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>multi-line string literals.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>April 25, 2016 at 08:00:00pm</p></header><div class="content"><p>This could be a simple solution: <br></p><p>Starting each line with a special token.<br></p><p>In the example here it is the \\  double-backslash .  <br>when the \\ appears in the first two columns of a source line, <br>this tells the compiler that it is a data line and that more might follow.<br>the last line starting with \\ completes the data entry.<br></p><p>Here is an example of a string declaration with some XML<br>(no escape sequences needed for “) <br>Of course it could be anything other kind of textual data as well.<br></p><p>let  str =  <br>\\&lt;!DOCTYPE html&gt;<br>\\&lt;html&gt;<br>\\&lt;body&gt;<br>\\<br>\\&lt;h1&gt;W3Schools Internal Note&lt;/h1&gt;\n<br>\\&lt;div&gt;<br>\\&lt;b&gt;To:&lt;/b&gt; &lt;span id=&quot;to&quot;&gt;&lt;/span&gt;&lt;br&gt;\n<br>\\&lt;b&gt;From:&lt;/b&gt; &lt;span id=&quot;from&quot;&gt;&lt;/span&gt;&lt;br&gt;\n<br>\\&lt;b&gt;Message:&lt;/b&gt; &lt;span id=&quot;message&quot;&gt;&lt;/span&gt;<br>\\&lt;/div&gt;<br>\\\n<br>\\&lt;script&gt;<br>\\var txt, parser, xmlDoc;<br>\\txt = &quot;&lt;note&gt;&quot; +<br>\\&quot;&lt;to&gt;Tove&lt;/to&gt;&quot; +<br>\\etc. this is the last data line.<br></p><p><br>Conditions: <br></p><p>- Every line starting with \\ in first and second column of the line <br>  is  treated as a data line.<br>- All characters behind the \\ are regarded as data, thus note that:<br>     - the “ is not regarded as a string delimiter<br>     - the // chars and whatever follows it are interpreted as data on such a line, not as comment.<br>     -  \\  within the data itself are treated as data e.g. this line is valid:<br>\\There \\ are three backslashes (as data) in this line \\\\ today.<br>\\<br>the above data line is empty but is allowed. <br></p><p>- Leading and embedded spaces are respected.<br>- Tabs, Linefeeds etc. can be inserted the usual way using \t \n etc. <br>- trailing spaces and line terminators cr lf are ignored, filtered out.<br></p><p>let dutchNumbers =            <br>\\ een twee drie vier vijf<br></p><p>\\ zes zeven acht negen tien   <br>\\these two data lines are orphans,<br></p><p>Blank lines or other Swift statement lines in-between<br>breaks a set of \\ data lines <br></p><p><br>All \\ lines together are treated as one single string literal<br>and may occur everywhere where “normal” string literals are allowed.<br></p><p>    // E.g. this if statement would be correct:<br>    // Yes, this would be legal but doesn’t look so great: Indentation not possible here<br>       if cars == <br>\\Ford<br>\\ Delorean<br>\\ Chevrolet<br>      {<br>          doSomething()<br>      }<br></p><p>An array with 2 string elements: <br></p><p>var ar =<br>[ <br>\\sdkdslkdslkdsldkshfkjdljfsdljkfdshjklfd dioioioioio \n\nsljkf sdflkf dsl;dfsk sdlfk dfsfkds <br>\\ sdkdfkdfldkfd fdfldk   fdlkfd jkfds  hjklfd dsljkf sdflkf dsl;dfsk sdlfk dfsfkds <br>,<br>\\There are many ships in the ha<br>\\rbour that are soon sailing away.<br>]<br></p><p><br>I also thought about using “”  as token, but this would be interpreted as an empty string.<br>or “”” but this is an empty string followed by an unclosed string literal.<br></p><p>Should be relatively easy to implement? What y’all think?<br></p><p><br>Kind Regards<br>TedvG<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/637e908f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>multi-line string literals.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>April 26, 2016 at 01:00:00am</p></header><div class="content"><p>possible improvement, one could allow<br>leading spaces before the &quot;data line token&quot;<br>thus enabling indentation, like so<br>{<br>       let str =<br>          \\dataaaaaaaaaahgdfhhfdxfg cvcsffggcfg<br>          \\c jggjvhfh fhffhfgxfxgdgfhgj  jvhhfhfhcgxgc<br>        .<br>        .<br>}<br></p><p>TedvG<br></p><p>&gt; On 25 Apr 2016, at 20:47, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt; <br>&gt; This could be a simple solution: <br>&gt; <br>&gt; Starting each line with a special token.<br>&gt; <br>&gt; In the example here it is the \\  double-backslash .  <br>&gt; when the \\ appears in the first two columns of a source line, <br>&gt; this tells the compiler that it is a data line and that more might follow.<br>&gt; the last line starting with \\ completes the data entry.<br>&gt; <br>&gt; Here is an example of a string declaration with some XML<br>&gt; (no escape sequences needed for “) <br>&gt; Of course it could be anything other kind of textual data as well.<br>&gt; <br>&gt; let  str =  <br>&gt; \\&lt;!DOCTYPE html&gt;<br>&gt; \\&lt;html&gt;<br>&gt; \\&lt;body&gt;<br>&gt; \\<br>&gt; \\&lt;h1&gt;W3Schools Internal Note&lt;/h1&gt;\n<br>&gt; \\&lt;div&gt;<br>&gt; \\&lt;b&gt;To:&lt;/b&gt; &lt;span id=&quot;to&quot;&gt;&lt;/span&gt;&lt;br&gt;\n<br>&gt; \\&lt;b&gt;From:&lt;/b&gt; &lt;span id=&quot;from&quot;&gt;&lt;/span&gt;&lt;br&gt;\n<br>&gt; \\&lt;b&gt;Message:&lt;/b&gt; &lt;span id=&quot;message&quot;&gt;&lt;/span&gt;<br>&gt; \\&lt;/div&gt;<br>&gt; \\\n<br>&gt; \\&lt;script&gt;<br>&gt; \\var txt, parser, xmlDoc;<br>&gt; \\txt = &quot;&lt;note&gt;&quot; +<br>&gt; \\&quot;&lt;to&gt;Tove&lt;/to&gt;&quot; +<br>&gt; \\etc. this is the last data line.<br>&gt; <br>&gt; <br>&gt; Conditions: <br>&gt; <br>&gt; - Every line starting with \\ in first and second column of the line <br>&gt;   is  treated as a data line.<br>&gt; - All characters behind the \\ are regarded as data, thus note that:<br>&gt;      - the “ is not regarded as a string delimiter<br>&gt;      - the // chars and whatever follows it are interpreted as data on such a line, not as comment.<br>&gt;      -  \\  within the data itself are treated as data e.g. this line is valid:<br>&gt; \\There \\ are three backslashes (as data) in this line \\\\ today.<br>&gt; \\<br>&gt; the above data line is empty but is allowed. <br>&gt; <br>&gt; - Leading and embedded spaces are respected.<br>&gt; - Tabs, Linefeeds etc. can be inserted the usual way using \t \n etc. <br>&gt; - trailing spaces and line terminators cr lf are ignored, filtered out.<br>&gt; <br>&gt; let dutchNumbers =            <br>&gt; \\ een twee drie vier vijf<br>&gt; <br>&gt; \\ zes zeven acht negen tien   <br>&gt; \\these two data lines are orphans,<br>&gt; <br>&gt; Blank lines or other Swift statement lines in-between<br>&gt; breaks a set of \\ data lines <br>&gt; <br>&gt; <br>&gt; All \\ lines together are treated as one single string literal<br>&gt; and may occur everywhere where “normal” string literals are allowed.<br>&gt; <br>&gt;     // E.g. this if statement would be correct:<br>&gt;     // Yes, this would be legal but doesn’t look so great: Indentation not possible here<br>&gt;        if cars == <br>&gt; \\Ford<br>&gt; \\ Delorean<br>&gt; \\ Chevrolet<br>&gt;       {<br>&gt;           doSomething()<br>&gt;       }<br>&gt; <br>&gt; An array with 2 string elements: <br>&gt; <br>&gt; var ar =<br>&gt; [ <br>&gt; \\sdkdslkdslkdsldkshfkjdljfsdljkfdshjklfd dioioioioio \n\nsljkf sdflkf dsl;dfsk sdlfk dfsfkds <br>&gt; \\ sdkdfkdfldkfd fdfldk   fdlkfd jkfds  hjklfd dsljkf sdflkf dsl;dfsk sdlfk dfsfkds <br>&gt; ,<br>&gt; \\There are many ships in the ha<br>&gt; \\rbour that are soon sailing away.<br>&gt; ]<br>&gt; <br>&gt; <br>&gt; I also thought about using “”  as token, but this would be interpreted as an empty string.<br>&gt; or “”” but this is an empty string followed by an unclosed string literal.<br>&gt; <br>&gt; Should be relatively easy to implement? What y’all think?<br>&gt; <br>&gt; <br>&gt; Kind Regards<br>&gt; TedvG<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/3073c952/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>April 26, 2016 at 07:00:00am</p></header><div class="content"><p>&quot;&quot;&quot;Just in my opinion:<br>having to start each line with a particular token kinda defeats the purpose of multiline string literals.<br>&quot;can&#39;t we just continue&quot;<br>&quot;the literal on the next line anyways,&quot;<br>&quot;like in C?&quot;<br>&quot;or maybe the &quot;+<br>&quot;at the end of the line can be&quot;+<br>&quot;optimized away?&quot;<br>&quot;&quot;&quot;<br></p><p>What is wrong with just using &quot;&quot;&quot; as a delimiter? Except that maybe there are other languages which use this already. You can copy&amp;paste whole XML snippets into such a thing. It&#39;s also good for usage instructions in a command line tool, and I think everyone will understand what it means. Is it a design goal to do something completely new? Or are you just unhappy with all existing multi-line string literal syntaxes?<br></p><p>-Michael (who would be happy with Perl Heredoc-Syntax as well)<br></p><p>&gt; Am 26.04.2016 um 01:00 schrieb ted van gaalen via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; possible improvement, one could allow<br>&gt; leading spaces before the &quot;data line token&quot;<br>&gt; thus enabling indentation, like so<br>&gt; {<br>&gt;        let str =<br>&gt;           \\dataaaaaaaaaahgdfhhfdxfg cvcsffggcfg<br>&gt;           \\c jggjvhfh fhffhfgxfxgdgfhgj  jvhhfhfhcgxgc<br>&gt;         .<br>&gt;         .<br>&gt; }<br>&gt; <br>&gt; TedvG<br>&gt; <br>&gt; On 25 Apr 2016, at 20:47, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; This could be a simple solution: <br>&gt;&gt; <br>&gt;&gt; Starting each line with a special token.<br>&gt;&gt; <br>&gt;&gt; In the example here it is the \\  double-backslash .  <br>&gt;&gt; when the \\ appears in the first two columns of a source line, <br>&gt;&gt; this tells the compiler that it is a data line and that more might follow.<br>&gt;&gt; the last line starting with \\ completes the data entry.<br>&gt;&gt; <br>&gt;&gt; Here is an example of a string declaration with some XML<br>&gt;&gt; (no escape sequences needed for “) <br>&gt;&gt; Of course it could be anything other kind of textual data as well.<br>&gt;&gt; <br>&gt;&gt; let  str =  <br>&gt;&gt; \\&lt;!DOCTYPE html&gt;<br>&gt;&gt; \\&lt;html&gt;<br>&gt;&gt; \\&lt;body&gt;<br>&gt;&gt; \\<br>&gt;&gt; \\&lt;h1&gt;W3Schools Internal Note&lt;/h1&gt;\n<br>&gt;&gt; \\&lt;div&gt;<br>&gt;&gt; \\&lt;b&gt;To:&lt;/b&gt; &lt;span id=&quot;to&quot;&gt;&lt;/span&gt;&lt;br&gt;\n<br>&gt;&gt; \\&lt;b&gt;From:&lt;/b&gt; &lt;span id=&quot;from&quot;&gt;&lt;/span&gt;&lt;br&gt;\n<br>&gt;&gt; \\&lt;b&gt;Message:&lt;/b&gt; &lt;span id=&quot;message&quot;&gt;&lt;/span&gt;<br>&gt;&gt; \\&lt;/div&gt;<br>&gt;&gt; \\\n<br>&gt;&gt; \\&lt;script&gt;<br>&gt;&gt; \\var txt, parser, xmlDoc;<br>&gt;&gt; \\txt = &quot;&lt;note&gt;&quot; +<br>&gt;&gt; \\&quot;&lt;to&gt;Tove&lt;/to&gt;&quot; +<br>&gt;&gt; \\etc. this is the last data line.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Conditions: <br>&gt;&gt; <br>&gt;&gt; - Every line starting with \\ in first and second column of the line <br>&gt;&gt;   is  treated as a data line.<br>&gt;&gt; - All characters behind the \\ are regarded as data, thus note that:<br>&gt;&gt;      - the “ is not regarded as a string delimiter<br>&gt;&gt;      - the // chars and whatever follows it are interpreted as data on such a line, not as comment.<br>&gt;&gt;      -  \\  within the data itself are treated as data e.g. this line is valid:<br>&gt;&gt; \\There \\ are three backslashes (as data) in this line \\\\ today.<br>&gt;&gt; \\<br>&gt;&gt; the above data line is empty but is allowed. <br>&gt;&gt; <br>&gt;&gt; - Leading and embedded spaces are respected.<br>&gt;&gt; - Tabs, Linefeeds etc. can be inserted the usual way using \t \n etc. <br>&gt;&gt; - trailing spaces and line terminators cr lf are ignored, filtered out.<br>&gt;&gt; <br>&gt;&gt; let dutchNumbers =            <br>&gt;&gt; \\ een twee drie vier vijf<br>&gt;&gt; <br>&gt;&gt; \\ zes zeven acht negen tien   <br>&gt;&gt; \\these two data lines are orphans,<br>&gt;&gt; <br>&gt;&gt; Blank lines or other Swift statement lines in-between<br>&gt;&gt; breaks a set of \\ data lines <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; All \\ lines together are treated as one single string literal<br>&gt;&gt; and may occur everywhere where “normal” string literals are allowed.<br>&gt;&gt; <br>&gt;&gt;     // E.g. this if statement would be correct:<br>&gt;&gt;     // Yes, this would be legal but doesn’t look so great: Indentation not possible here<br>&gt;&gt;        if cars == <br>&gt;&gt; \\Ford<br>&gt;&gt; \\ Delorean<br>&gt;&gt; \\ Chevrolet<br>&gt;&gt;       {<br>&gt;&gt;           doSomething()<br>&gt;&gt;       }<br>&gt;&gt; <br>&gt;&gt; An array with 2 string elements: <br>&gt;&gt; <br>&gt;&gt; var ar =<br>&gt;&gt; [ <br>&gt;&gt; \\sdkdslkdslkdsldkshfkjdljfsdljkfdshjklfd dioioioioio \n\nsljkf sdflkf dsl;dfsk sdlfk dfsfkds <br>&gt;&gt; \\ sdkdfkdfldkfd fdfldk   fdlkfd jkfds  hjklfd dsljkf sdflkf dsl;dfsk sdlfk dfsfkds <br>&gt;&gt; ,<br>&gt;&gt; \\There are many ships in the ha<br>&gt;&gt; \\rbour that are soon sailing away.<br>&gt;&gt; ]<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I also thought about using “”  as token, but this would be interpreted as an empty string.<br>&gt;&gt; or “”” but this is an empty string followed by an unclosed string literal.<br>&gt;&gt; <br>&gt;&gt; Should be relatively easy to implement? What y’all think?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Kind Regards<br>&gt;&gt; TedvG<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>multi-line string literals.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>April 26, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi Michael<br></p><p>What happens if a delimiter in this case: “”” <br>occurs embedded in the data?   like  so (two times here):<br></p><p>“””<br>dfksposdkj dslkd s hfdslk   dskdslk  lskd sk aaasd<br>lfsdlks dslksd sdlk sdlksd  “””  fskfsdalkfsd  “”” fdjf dkjfds  <br>“”&quot;<br></p><p>Having a particular token at the start of a line (or after  leading space(s) ) to define a data line <br>allows us to use *all* available characters behind it.  <br></p><p>Actually after further thinking, I assume that 1 token is not enough, perhaps there should be two tokens e.g.<br> <br>   \\ ……………...   to process  escaped chars, like \… and \(item),  <br>                 the same way as with normal Swift string literals<br>             <br>   \@………….   to take all characters as is without conversion?    <br></p><p><br>Examples:<br>1.<br>let someText = <br>\\There are \t \t  \(nrofboxes) boxes avai<br>\\lable.<br>converts to:<br>&quot;There are             12 boxes available.&quot;<br></p><p>2.<br></p><p>let someText = <br>\@There are \t \t  \(nrofboxes) boxes avai<br>\@able.<br>String taken as is, nothing is converted:<br>&quot;There are \t \t  \(nrofboxes) boxes available.&quot;<br></p><p>Of course one could choose other tokens than \\ and \@<br>they just looked convenient to me...<br></p><p>TedvG<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p>&gt; On 26.04.2016, at 07:53, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt; <br>&gt; &quot;&quot;&quot;Just in my opinion:<br>&gt; having to start each line with a particular token kinda defeats the purpose of multiline string literals.<br>Why? <br>&gt; &quot;can&#39;t we just continue&quot;<br>&gt; &quot;the literal on the next line anyways,&quot;<br>&gt; &quot;like in C?&quot;<br>&gt; &quot;or maybe the &quot;+<br>&gt; &quot;at the end of the line can be&quot;+<br>&gt; &quot;optimized away?&quot;<br>&gt; &quot;&quot;&quot;<br>&gt; <br>&gt; What is wrong with just using &quot;&quot;&quot; as a delimiter? Except that maybe there are other languages which use this already. You can copy&amp;paste whole XML snippets into such a thing. It&#39;s also good for usage instructions in a command line tool, and I think everyone will understand what it means. Is it a design goal to do something completely new? Or are you just unhappy with all existing multi-line string literal syntaxes?<br>&gt; <br>&gt; -Michael (who would be happy with Perl Heredoc-Syntax as well)<br>&gt; <br>&gt;&gt; Am 26.04.2016 um 01:00 schrieb ted van gaalen via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; possible improvement, one could allow<br>&gt;&gt; leading spaces before the &quot;data line token&quot;<br>&gt;&gt; thus enabling indentation, like so<br>&gt;&gt; {<br>&gt;&gt;       let str =<br>&gt;&gt;          \\dataaaaaaaaaahgdfhhfdxfg cvcsffggcfg<br>&gt;&gt;          \\c jggjvhfh fhffhfgxfxgdgfhgj  jvhhfhfhcgxgc<br>&gt;&gt;        .<br>&gt;&gt;        .<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; TedvG<br>&gt;&gt; <br>&gt;&gt; On 25 Apr 2016, at 20:47, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; This could be a simple solution: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Starting each line with a special token.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the example here it is the \\  double-backslash .  <br>&gt;&gt;&gt; when the \\ appears in the first two columns of a source line, <br>&gt;&gt;&gt; this tells the compiler that it is a data line and that more might follow.<br>&gt;&gt;&gt; the last line starting with \\ completes the data entry.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is an example of a string declaration with some XML<br>&gt;&gt;&gt; (no escape sequences needed for “) <br>&gt;&gt;&gt; Of course it could be anything other kind of textual data as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let  str =  <br>&gt;&gt;&gt; \\&lt;!DOCTYPE html&gt;<br>&gt;&gt;&gt; \\&lt;html&gt;<br>&gt;&gt;&gt; \\&lt;body&gt;<br>&gt;&gt;&gt; \\<br>&gt;&gt;&gt; \\&lt;h1&gt;W3Schools Internal Note&lt;/h1&gt;\n<br>&gt;&gt;&gt; \\&lt;div&gt;<br>&gt;&gt;&gt; \\&lt;b&gt;To:&lt;/b&gt; &lt;span id=&quot;to&quot;&gt;&lt;/span&gt;&lt;br&gt;\n<br>&gt;&gt;&gt; \\&lt;b&gt;From:&lt;/b&gt; &lt;span id=&quot;from&quot;&gt;&lt;/span&gt;&lt;br&gt;\n<br>&gt;&gt;&gt; \\&lt;b&gt;Message:&lt;/b&gt; &lt;span id=&quot;message&quot;&gt;&lt;/span&gt;<br>&gt;&gt;&gt; \\&lt;/div&gt;<br>&gt;&gt;&gt; \\\n<br>&gt;&gt;&gt; \\&lt;script&gt;<br>&gt;&gt;&gt; \\var txt, parser, xmlDoc;<br>&gt;&gt;&gt; \\txt = &quot;&lt;note&gt;&quot; +<br>&gt;&gt;&gt; \\&quot;&lt;to&gt;Tove&lt;/to&gt;&quot; +<br>&gt;&gt;&gt; \\etc. this is the last data line.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conditions: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Every line starting with \\ in first and second column of the line <br>&gt;&gt;&gt;  is  treated as a data line.<br>&gt;&gt;&gt; - All characters behind the \\ are regarded as data, thus note that:<br>&gt;&gt;&gt;     - the “ is not regarded as a string delimiter<br>&gt;&gt;&gt;     - the // chars and whatever follows it are interpreted as data on such a line, not as comment.<br>&gt;&gt;&gt;     -  \\  within the data itself are treated as data e.g. this line is valid:<br>&gt;&gt;&gt; \\There \\ are three backslashes (as data) in this line \\\\ today.<br>&gt;&gt;&gt; \\<br>&gt;&gt;&gt; the above data line is empty but is allowed. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Leading and embedded spaces are respected.<br>&gt;&gt;&gt; - Tabs, Linefeeds etc. can be inserted the usual way using \t \n etc. <br>&gt;&gt;&gt; - trailing spaces and line terminators cr lf are ignored, filtered out.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let dutchNumbers =            <br>&gt;&gt;&gt; \\ een twee drie vier vijf<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; \\ zes zeven acht negen tien   <br>&gt;&gt;&gt; \\these two data lines are orphans,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Blank lines or other Swift statement lines in-between<br>&gt;&gt;&gt; breaks a set of \\ data lines <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; All \\ lines together are treated as one single string literal<br>&gt;&gt;&gt; and may occur everywhere where “normal” string literals are allowed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // E.g. this if statement would be correct:<br>&gt;&gt;&gt;    // Yes, this would be legal but doesn’t look so great: Indentation not possible here<br>&gt;&gt;&gt;       if cars == <br>&gt;&gt;&gt; \\Ford<br>&gt;&gt;&gt; \\ Delorean<br>&gt;&gt;&gt; \\ Chevrolet<br>&gt;&gt;&gt;      {<br>&gt;&gt;&gt;          doSomething()<br>&gt;&gt;&gt;      }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An array with 2 string elements: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var ar =<br>&gt;&gt;&gt; [ <br>&gt;&gt;&gt; \\sdkdslkdslkdsldkshfkjdljfsdljkfdshjklfd dioioioioio \n\nsljkf sdflkf dsl;dfsk sdlfk dfsfkds <br>&gt;&gt;&gt; \\ sdkdfkdfldkfd fdfldk   fdlkfd jkfds  hjklfd dsljkf sdflkf dsl;dfsk sdlfk dfsfkds <br>&gt;&gt;&gt; ,<br>&gt;&gt;&gt; \\There are many ships in the ha<br>&gt;&gt;&gt; \\rbour that are soon sailing away.<br>&gt;&gt;&gt; ]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I also thought about using “”  as token, but this would be interpreted as an empty string.<br>&gt;&gt;&gt; or “”” but this is an empty string followed by an unclosed string literal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Should be relatively easy to implement? What y’all think?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Kind Regards<br>&gt;&gt;&gt; TedvG<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>April 26, 2016 at 10:00:00pm</p></header><div class="content"><p>Comments inline.<br></p><p>&gt; Am 26.04.2016 um 15:32 schrieb Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt;:<br>&gt; <br>&gt; Hi Michael<br>&gt; <br>&gt; What happens if a delimiter in this case: “”” <br>&gt; occurs embedded in the data?   like  so (two times here):<br></p><p>that&#39;s a problem you always have. And I think pasting a few lines of text is a (much) more common use case than wanting to have a string literal that contains &quot;&quot;&quot; in it. I have never needed a string literal that contained &quot;&quot;&quot;, and as long as you don&#39;t create a parser for a language that wants to parse such literals, the use cases are very rare IMO. Furthermore, if the string interpolation and escape sequences are enabled, I can answer this directly: you write &quot;&quot;&quot;some text<br>some text. Here you have 3 double quotes: &quot;&quot;\&quot; and here again \&quot;&quot;&quot;<br>&quot;&quot;&quot;; you can just put a backslash before one of the offending double quotes.<br></p><p>I think starting each line with \\ is really ugly, and I wouldn&#39;t consider this a true &quot;multi-line string literal&quot;. Because instead of writing<br></p><p>\\bla bla<br>\\bla bla<br></p><p>I&#39;d rather write<br></p><p>&quot;bla bla\n&quot;<br>&quot;bla bla&quot;<br></p><p>&gt; <br>&gt; “””<br>&gt; dfksposdkj dslkd s hfdslk   dskdslk  lskd sk aaasd<br>&gt; lfsdlks dslksd sdlk sdlksd  “””  fskfsdalkfsd  “”” fdjf dkjfds  <br>&gt; “”&quot;<br>&gt; <br>&gt; Having a particular token at the start of a line (or after  leading space(s) ) to define a data line <br>&gt; allows us to use *all* available characters behind it.  <br>&gt; <br>&gt; Actually after further thinking, I assume that 1 token is not enough, perhaps there should be two tokens e.g.<br>&gt; <br>&gt;   \\ ……………...   to process  escaped chars, like \… and \(item),  <br>&gt;                 the same way as with normal Swift string literals<br>&gt; <br>&gt;   \@………….   to take all characters as is without conversion?    <br>&gt; <br>&gt; <br>&gt; Examples:<br>&gt; 1.<br>&gt; let someText = <br>&gt; \\There are \t \t  \(nrofboxes) boxes avai<br>&gt; \\lable.<br>&gt; converts to:<br>&gt; &quot;There are             12 boxes available.&quot;<br></p><p>really? so I have to write \n if I want to have a newline?<br></p><p>&gt; <br>&gt; 2.<br>&gt; <br>&gt; let someText = <br>&gt; \@There are \t \t  \(nrofboxes) boxes avai<br>&gt; \@able.<br>&gt; String taken as is, nothing is converted:<br>&gt; &quot;There are \t \t  \(nrofboxes) boxes available.&quot;<br>&gt; <br>&gt; Of course one could choose other tokens than \\ and \@<br>&gt; they just looked convenient to me...<br>&gt; <br>&gt; TedvG<br>&gt; <br>&gt; <br>&gt;&gt; On 26.04.2016, at 07:53, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &quot;&quot;&quot;Just in my opinion:<br>&gt;&gt; having to start each line with a particular token kinda defeats the purpose of multiline string literals.<br>&gt; Why? <br></p><p>because IMHO the purpose of multiline string literals *is* that you can copy&amp;paste multiple lines of text directly into the editor? If I call \\literals a &#39;multi-line literal&#39;, I can call &quot;normal strings&quot; multiline too, can&#39;t I?<br></p><p>What makes<br>    \\this<br>    \\string<br>a &#39;multiline string literal&#39;<br>    &quot;and this &quot;<br>    &quot;string&quot;<br>not? (What is the definition of a &quot;multiline string literal&quot;?)<br></p><p>-Michael<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>multi-line string literals.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>April 27, 2016 at 01:00:00am</p></header><div class="content"><p>Hi Michael<br>also inline<br></p><p>&gt; On 26 Apr 2016, at 22:05, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt; <br>&gt; Comments inline.<br>&gt; <br>&gt;&gt; Am 26.04.2016 um 15:32 schrieb Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt;:<br>&gt;&gt; <br>&gt;&gt; Hi Michael<br>&gt;&gt; <br>&gt;&gt; What happens if a delimiter in this case: “”” <br>&gt;&gt; occurs embedded in the data?   like  so (two times here):<br>&gt; <br>&gt; that&#39;s a problem you always have.<br>It is not a problem with the &quot;data line&quot; method that I suggest...<br>&gt; And I think pasting a few lines of text is a (much) more common use case than wanting to have a string literal that contains &quot;&quot;&quot; in it.<br>..all you have to do is paste your few lines of text an put \@ in front of each line...<br>** (see further in text)<br></p><p>If copying larger texts, it might be better to use a resource (file) instead of<br>hard coding all that data into a multi-line string. <br></p><p> <br></p><p>&gt; I have never needed a string literal that contained &quot;&quot;&quot;, and as long as you don&#39;t create a parser for a language that wants to parse such literals, the use cases are very rare IMO. <br>Swift is a general purpose language used for making many different applications..<br></p><p><br>&gt; Furthermore, if the string interpolation and escape sequences are enabled, I can answer this directly: you write &quot;&quot;&quot;some text<br>&gt; some text. Here you have 3 double quotes: &quot;&quot;\&quot; and here again \&quot;&quot;&quot;<br>&gt; &quot;&quot;&quot;; you can just put a backslash before one of the offending double quotes.<br>&gt; <br>then you would have to change all the &quot; in say an Xml group of lines.<br>&gt; I think starting each line with \\ is really ugly,<br>Ok, but that&#39;s just a matter of personal taste...<br>I&#39;ll gladly give up some esthetics for better functionality.<br>&gt; and I wouldn&#39;t consider this a true &quot;multi-line string literal&quot;. Because instead of writing<br>&gt; <br>&gt; \\bla bla<br>&gt; \\bla bla<br>&gt; <br>&gt; I&#39;d rather write<br>&gt; <br>this:<br>&gt; &quot;bla bla\n&quot;<br>&gt; &quot;bla bla&quot;<br>already exists with +  ... +<br>but then you have to add \n as well and use escape \&quot; all the time.<br>e.g. when coding Html lines with parameters.<br>&gt;&gt; <br>&gt;&gt; “””<br>&gt;&gt; dfksposdkj dslkd s hfdslk   dskdslk  lskd sk aaasd<br>&gt;&gt; lfsdlks dslksd sdlk sdlksd  “””  fskfsdalkfsd  “”” fdjf dkjfds  <br>&gt;&gt; “”&quot;<br>&gt;&gt; <br>&gt;&gt; Having a particular token at the start of a line (or after  leading space(s) ) to define a data line <br>&gt;&gt; allows us to use *all* available characters behind it.  <br>&gt;&gt; <br>&gt;&gt; Actually after further thinking, I assume that 1 token is not enough, perhaps there should be two tokens e.g.<br>&gt;&gt; <br>&gt;&gt;  \\ ……………...   to process  escaped chars, like \… and \(item),  <br>&gt;&gt;                the same way as with normal Swift string literals<br>&gt;&gt; <br>&gt;&gt;  \@………….   to take all characters as is without conversion?    <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Examples:<br>&gt;&gt; 1.<br>&gt;&gt; let someText = <br>&gt;&gt; \\There are \t \t  \(nrofboxes) boxes avai<br>&gt;&gt; \\lable.<br>&gt;&gt; converts to:<br>&gt;&gt; &quot;There are             12 boxes available.&quot;<br>&gt; <br>&gt; really? so I have to write \n if I want to have a newline?<br>&gt; <br>**<br>Yes, because here, \\ is used instead of other suggested token \@ <br>but respecting source-file-linefeeds could perhaps be an option<br>when using \@ ?<br></p><p>&gt;&gt; <br>&gt;&gt; 2.<br>&gt;&gt; <br>&gt;&gt; let someText = <br>&gt;&gt; \@There are \t \t  \(nrofboxes) boxes avai<br>&gt;&gt; \@able.<br>&gt;&gt; String taken as is, nothing is converted:<br>&gt;&gt; &quot;There are \t \t  \(nrofboxes) boxes available.&quot;<br>&gt;&gt; <br>&gt;&gt; Of course one could choose other tokens than \\ and \@<br>&gt;&gt; they just looked convenient to me...<br>&gt;&gt; <br>&gt;&gt; TedvG<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 26.04.2016, at 07:53, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;&quot;&quot;Just in my opinion:<br>&gt;&gt;&gt; having to start each line with a particular token kinda defeats the purpose of multiline string literals.<br>&gt;&gt; Why? <br>&gt; <br>&gt; because IMHO the purpose of multiline string literals *is* that you can copy&amp;paste multiple lines of text directly into the editor? If I call \\literals a &#39;multi-line literal&#39;, I can call &quot;normal strings&quot; multiline too, can&#39;t I?<br>&gt; <br>&gt; What makes<br>&gt;    \\this<br>&gt;    \\string<br>&gt; a &#39;multiline string literal&#39;<br>&gt;    &quot;and this &quot;<br>&gt;    &quot;string&quot;<br>&gt; not? (What is the definition of a &quot;multiline string literal&quot;?)<br>&gt; <br>&gt; -Michael<br>&gt; <br>Regards, TedvG<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/88b34675/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 26, 2016 at 04:00:00pm</p></header><div class="content"><p>Please allow me to add my 2 cents. How I think about multi-line feature: it <br>should allow to paste any text as-is, which will have no any special <br>letters/symbols in it. Such text should be copied to variable *exactly* as <br>typed inside source file.<br></p><p>I want to be able to have in source file exactly this text, without any <br>wrapping of &quot;disallowed&quot; symbols :<br></p><p>&lt;?xml version=&quot;1.0&quot;?&gt;<br>&lt;catalog&gt;<br>	&lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;<br>		&lt;author&gt;myAuthor&lt;/author&gt;<br>		&lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;<br>	&lt;/book&gt;<br>&lt;/catalog&gt;<br></p><p>(please note this &quot;\tuttorial&quot; and &quot;\(edition&quot; )<br></p><p>So, I suggest to start such multi line with &quot;\ and have &quot; as <br>end-of-multiline marker:<br></p><p>var xml = &quot;\<br>&lt;?xml version=&quot;1.0&quot;?&gt;<br>&lt;catalog&gt;<br>	&lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;<br>		&lt;author&gt;myAuthor&lt;/author&gt;<br>		&lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;<br>	&lt;/book&gt;<br>&lt;/catalog&gt;<br>&quot;<br></p><p>Pros:<br>* text as-is, you can have &quot; \ \\ \t \( etc symbols<br>* var xml = &quot;  - clearly seems like start of string, all the lines looks <br>like inside one string<br>* &quot;\  - says that here is some special case, as we usually need some symbol <br>after \ to have special character like \t or \n<br>* ends with &quot;  - clearly see that here is an end of string (probably &quot;; <br>should be required here.)<br></p><p>Cons:<br>* if we need tabs inside our &#39;xml&#39; variable - we need to keep them in <br>source file<br>* spaces at the end of each line could be trimmed by editor<br>* line with only &quot; symbol is not allowed inside mutli-line string - it will <br>terminate the string.<br></p><p>But the cons could be solved (if you need this) by custom markers you can <br>use to replace later in &#39;xml&#39; variable like:<br>var multiline = &quot;\<br>#tab&lt;folder&gt;<br>#tab#tab&lt;file&gt;...&lt;/file&gt;<br>#tab#tab&lt;file&gt;...&lt;/file&gt;<br>#tab&lt;/folder&gt;<br>&quot;<br>multiline.replace(&quot;#tab&quot;, to:&quot;\t&quot;)<br></p><p>On 26.04.2016 8:53, Michael Peternell via swift-evolution wrote:<br>&gt; &quot;&quot;&quot;Just in my opinion: having to start each line with a particular token<br>&gt; kinda defeats the purpose of multiline string literals. &quot;can&#39;t we just<br>&gt; continue&quot; &quot;the literal on the next line anyways,&quot; &quot;like in C?&quot; &quot;or maybe<br>&gt; the &quot;+ &quot;at the end of the line can be&quot;+ &quot;optimized away?&quot; &quot;&quot;&quot;<br>&gt;<br>&gt; What is wrong with just using &quot;&quot;&quot; as a delimiter? Except that maybe<br>&gt; there are other languages which use this already. You can copy&amp;paste<br>&gt; whole XML snippets into such a thing. It&#39;s also good for usage<br>&gt; instructions in a command line tool, and I think everyone will<br>&gt; understand what it means. Is it a design goal to do something completely<br>&gt; new? Or are you just unhappy with all existing multi-line string literal<br>&gt; syntaxes?<br> &gt;<br>&gt; -Michael (who would be happy with Perl Heredoc-Syntax as well)<br>&gt;<br>&gt;&gt; Am 26.04.2016 um 01:00 schrieb ted van gaalen via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; possible improvement, one could allow leading spaces before the &quot;data<br>&gt;&gt; line token&quot; thus enabling indentation, like so { let str =<br>&gt;&gt; \\dataaaaaaaaaahgdfhhfdxfg cvcsffggcfg \\c jggjvhfh fhffhfgxfxgdgfhgj<br>&gt;&gt; jvhhfhfhcgxgc . . }<br>&gt;&gt;<br>&gt;&gt; TedvG<br>&gt;&gt;<br>&gt;&gt; On 25 Apr 2016, at 20:47, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; This could be a simple solution:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Starting each line with a special token.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In the example here it is the \\  double-backslash . when the \\<br>&gt;&gt;&gt; appears in the first two columns of a source line, this tells the<br>&gt;&gt;&gt; compiler that it is a data line and that more might follow. the last<br>&gt;&gt;&gt; line starting with \\ completes the data entry.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Here is an example of a string declaration with some XML (no escape<br>&gt;&gt;&gt; sequences needed for “) Of course it could be anything other kind of<br>&gt;&gt;&gt; textual data as well.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let  str = \\&lt;!DOCTYPE html&gt; \\&lt;html&gt; \\&lt;body&gt; \\ \\&lt;h1&gt;W3Schools<br>&gt;&gt;&gt; Internal Note&lt;/h1&gt;\n \\&lt;div&gt; \\&lt;b&gt;To:&lt;/b&gt; &lt;span<br>&gt;&gt;&gt; id=&quot;to&quot;&gt;&lt;/span&gt;&lt;br&gt;\n \\&lt;b&gt;From:&lt;/b&gt; &lt;span id=&quot;from&quot;&gt;&lt;/span&gt;&lt;br&gt;\n<br>&gt;&gt;&gt; \\&lt;b&gt;Message:&lt;/b&gt; &lt;span id=&quot;message&quot;&gt;&lt;/span&gt; \\&lt;/div&gt; \\\n<br>&gt;&gt;&gt; \\&lt;script&gt; \\var txt, parser, xmlDoc; \\txt = &quot;&lt;note&gt;&quot; +<br>&gt;&gt;&gt; \\&quot;&lt;to&gt;Tove&lt;/to&gt;&quot; + \\etc. this is the last data line.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Conditions:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Every line starting with \\ in first and second column of the line<br>&gt;&gt;&gt;  is  treated as a data line. - All characters behind the \\ are<br>&gt;&gt;&gt; regarded as data, thus note that: - the “ is not regarded as a<br>&gt;&gt;&gt; string delimiter - the // chars and whatever follows it are<br>&gt;&gt;&gt; interpreted as data on such a line, not as comment. -  \\  within<br>&gt;&gt;&gt; the data itself are treated as data e.g. this line is valid: \\There<br>&gt;&gt;&gt; \\ are three backslashes (as data) in this line \\\\ today. \\ the<br>&gt;&gt;&gt; above data line is empty but is allowed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Leading and embedded spaces are respected. - Tabs, Linefeeds etc.<br>&gt;&gt;&gt; can be inserted the usual way using \t \n etc. - trailing spaces and<br>&gt;&gt;&gt; line terminators cr lf are ignored, filtered out.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let dutchNumbers = \\ een twee drie vier vijf<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; \\ zes zeven acht negen tien \\these two data lines are orphans,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Blank lines or other Swift statement lines in-between breaks a set<br>&gt;&gt;&gt; of \\ data lines<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; All \\ lines together are treated as one single string literal and<br>&gt;&gt;&gt; may occur everywhere where “normal” string literals are allowed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // E.g. this if statement would be correct: // Yes, this would be<br>&gt;&gt;&gt; legal but doesn’t look so great: Indentation not possible here if<br>&gt;&gt;&gt; cars == \\Ford \\ Delorean \\ Chevrolet { doSomething() }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; An array with 2 string elements:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var ar = [ \\sdkdslkdslkdsldkshfkjdljfsdljkfdshjklfd dioioioioio<br>&gt;&gt;&gt; \n\nsljkf sdflkf dsl;dfsk sdlfk dfsfkds \\ sdkdfkdfldkfd fdfldk<br>&gt;&gt;&gt; fdlkfd jkfds  hjklfd dsljkf sdflkf dsl;dfsk sdlfk dfsfkds , \\There<br>&gt;&gt;&gt; are many ships in the ha \\rbour that are soon sailing away. ]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I also thought about using “”  as token, but this would be<br>&gt;&gt;&gt; interpreted as an empty string. or “”” but this is an empty string<br>&gt;&gt;&gt; followed by an unclosed string literal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Should be relatively easy to implement? What y’all think?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Kind Regards TedvG<br>&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________ swift-evolution mailing<br>&gt; list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
