<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Idea] Repurpose Void</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>April 24, 2016 at 03:00:00am</p></header><div class="content"><p>SE-0066 disallows Void to be used on left side of function types.<br></p><p>Some people, including me, argue that Void should be removed altogether,<br>because:<br>1) () is more consistent with curried functions: (Int) -&gt; () -&gt; Double<br>2) () follows functional programming traditions<br></p><p>Now, why don&#39;t we repurpose Void to follow functional programming<br>traditions as well?<br>Its definition will look like:<br>enum Void { }<br></p><p>Basically, Void is a type which cannot have values.<br>With it, we can eliminate at least two Swift special cases:<br></p><p>1. Noreturn functions<br></p><p>func exit(code: Int = 0) -&gt; Void<br></p><p>&gt;From this signature, it&#39;s obvious that `exit` cannot return normally<br></p><p>2. Rethrows<br></p><p>func call&lt;T, U&gt;(block: () throws T -&gt; U) throws T -&gt; U<br></p><p>Non-throwing functions are functions throwing Void.<br>So if T=Void, we get the non-throwing version of `call`.<br></p><p>- Anton<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160424/173c9d54/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Idea] Repurpose Void</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 24, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Some people, including me, argue that Void should be removed altogether, because:<br>&gt; 1) () is more consistent with curried functions: (Int) -&gt; () -&gt; Double<br>&gt; 2) () follows functional programming traditions<br>&gt; <br>&gt; Now, why don&#39;t we repurpose Void to follow functional programming traditions as well?<br>&gt; Its definition will look like:<br>&gt; enum Void { }<br>&gt; <br>&gt; Basically, Void is a type which cannot have values.<br></p><p>I don&#39;t think Void is a good name for this, because it means something wildly different from the C-style `void`. It would be a confusing name choice for no real reason.<br></p><p>&gt; With it, we can eliminate at least two Swift special cases:<br>&gt; <br>&gt; 1. Noreturn functions<br>&gt; <br>&gt; func exit(code: Int = 0) -&gt; Void<br>&gt; <br>&gt; From this signature, it&#39;s obvious that `exit` cannot return normally<br>&gt; <br>&gt; 2. Rethrows<br>&gt; <br>&gt; func call&lt;T, U&gt;(block: () throws T -&gt; U) throws T -&gt; U<br>&gt; <br>&gt; Non-throwing functions are functions throwing Void.<br>&gt; So if T=Void, we get the non-throwing version of `call`.<br></p><p>As for these, I think we would actually be better off having a bottom type for these use cases. A bottom type is a subtype of all types—sort of the opposite of `Any` (which is at the top of the type graph). Since it&#39;s impossible for any value to belong to all types simultaneously, it&#39;s impossible to construct a value of the bottom type, so it has the same role of meaning &quot;this never returns/happens&quot;. But it has an important advantage over an empty enum type: you can treat it as any type you&#39;d like.<br></p><p>For instance, suppose we spell the bottom type `_`. Then we can write, for instance, this function, which indicates we haven&#39;t finished writing something:<br></p><p>	func unimplemented(_ description: String, file: String = #file, line: String = #line) -&gt; _ {<br>		fatalError(&quot;\(description) unimplemented&quot;, file: file, line: line)<br>	}<br></p><p>And use it like so:<br></p><p>	func calculateThing() -&gt; Thing {<br>		if let cachedThing = cachedThing {<br>			return cachedThing<br>		}<br>		<br>		cachedThing = Thing(foo: calculateFoo(), bar: unimplemented(&quot;Calculation of bar&quot;))<br>		return cachedThing!<br>	}<br></p><p>Because `unimplemented()` returns the bottom type, we can use it anywhere in any expression expecting any type, and it will compile just fine, implicitly converting to any type the context demands. Of course, since there are no values of the bottom type, `unimplemented()` cannot actually return a value, and so the call to `Thing.init(foo:bar:)` can never actually occur. But from the type checker&#39;s perspective, it all works out fine.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>[Idea] Repurpose Void</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>April 25, 2016 at 11:00:00am</p></header><div class="content"><p>Just wanted to quickly throw out that Kotlin&#39;s Unit class, their<br>&quot;equivalent&quot; of void, semantically follows the definition of &quot;type with<br>only one value&quot; laid out in the enum Void example above.<br></p><p>Dennis<br></p><p>On Sun, Apr 24, 2016, 9:43 PM Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Some people, including me, argue that Void should be removed altogether,<br>&gt; because:<br>&gt; &gt; 1) () is more consistent with curried functions: (Int) -&gt; () -&gt; Double<br>&gt; &gt; 2) () follows functional programming traditions<br>&gt; &gt;<br>&gt; &gt; Now, why don&#39;t we repurpose Void to follow functional programming<br>&gt; traditions as well?<br>&gt; &gt; Its definition will look like:<br>&gt; &gt; enum Void { }<br>&gt; &gt;<br>&gt; &gt; Basically, Void is a type which cannot have values.<br>&gt;<br>&gt; I don&#39;t think Void is a good name for this, because it means something<br>&gt; wildly different from the C-style `void`. It would be a confusing name<br>&gt; choice for no real reason.<br>&gt;<br>&gt; &gt; With it, we can eliminate at least two Swift special cases:<br>&gt; &gt;<br>&gt; &gt; 1. Noreturn functions<br>&gt; &gt;<br>&gt; &gt; func exit(code: Int = 0) -&gt; Void<br>&gt; &gt;<br>&gt; &gt; From this signature, it&#39;s obvious that `exit` cannot return normally<br>&gt; &gt;<br>&gt; &gt; 2. Rethrows<br>&gt; &gt;<br>&gt; &gt; func call&lt;T, U&gt;(block: () throws T -&gt; U) throws T -&gt; U<br>&gt; &gt;<br>&gt; &gt; Non-throwing functions are functions throwing Void.<br>&gt; &gt; So if T=Void, we get the non-throwing version of `call`.<br>&gt;<br>&gt; As for these, I think we would actually be better off having a bottom type<br>&gt; for these use cases. A bottom type is a subtype of all types—sort of the<br>&gt; opposite of `Any` (which is at the top of the type graph). Since it&#39;s<br>&gt; impossible for any value to belong to all types simultaneously, it&#39;s<br>&gt; impossible to construct a value of the bottom type, so it has the same role<br>&gt; of meaning &quot;this never returns/happens&quot;. But it has an important advantage<br>&gt; over an empty enum type: you can treat it as any type you&#39;d like.<br>&gt;<br>&gt; For instance, suppose we spell the bottom type `_`. Then we can write, for<br>&gt; instance, this function, which indicates we haven&#39;t finished writing<br>&gt; something:<br>&gt;<br>&gt;         func unimplemented(_ description: String, file: String = #file,<br>&gt; line: String = #line) -&gt; _ {<br>&gt;                 fatalError(&quot;\(description) unimplemented&quot;, file: file,<br>&gt; line: line)<br>&gt;         }<br>&gt;<br>&gt; And use it like so:<br>&gt;<br>&gt;         func calculateThing() -&gt; Thing {<br>&gt;                 if let cachedThing = cachedThing {<br>&gt;                         return cachedThing<br>&gt;                 }<br>&gt;<br>&gt;                 cachedThing = Thing(foo: calculateFoo(), bar:<br>&gt; unimplemented(&quot;Calculation of bar&quot;))<br>&gt;                 return cachedThing!<br>&gt;         }<br>&gt;<br>&gt; Because `unimplemented()` returns the bottom type, we can use it anywhere<br>&gt; in any expression expecting any type, and it will compile just fine,<br>&gt; implicitly converting to any type the context demands. Of course, since<br>&gt; there are no values of the bottom type, `unimplemented()` cannot actually<br>&gt; return a value, and so the call to `Thing.init(foo:bar:)` can never<br>&gt; actually occur. But from the type checker&#39;s perspective, it all works out<br>&gt; fine.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/d6ebbf7c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Idea] Repurpose Void</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 25, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Just wanted to quickly throw out that Kotlin&#39;s Unit class, their &quot;equivalent&quot; of void, semantically follows the definition of &quot;type with only one value&quot; laid out in the enum Void example above. <br></p><p>`enum Void {}` is not a type with only one value; it&#39;s a type with no values.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
