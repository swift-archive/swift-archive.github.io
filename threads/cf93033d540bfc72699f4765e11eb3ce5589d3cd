<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Disallowing weak struct properties</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 29, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi, everyone. What do you think about dropping support for &#39;weak&#39; in struct properties? This would fix a semantic issue—&#39;let&#39; structs containing weak properties won&#39;t change out from under you—and (AFAICT) would make all values trivially movable, which is a great quality to have.<br></p><p>This wouldn&#39;t change local variables, top-level variables, or class properties, just structs. It would make having an array of weak references a little harder, but honestly we should have proper weak-supporting collections anyway; as I understand it the behavior you usually want is auto-compacting rather than leaving a hole. (Evidence: Cocoa has NSHashTable for weak sets and NSMapTable for dictionaries with weak keys and/or values; there&#39;s no variant of NSArray that supports weak references other than by making a custom CFArray and being very very careful how you access it.)<br></p><p>Anyway, thoughts? It&#39;s not really my department but it cleans up the same areas that are being affected by struct resilience.<br>Jordan<br></p><p>P.S. I know this would have to go through swift-evolution for real. I just want to know if it&#39;s a silly idea to begin with.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160129/cf93d3cd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Disallowing weak struct properties</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 29, 2016 at 06:00:00pm</p></header><div class="content"><p>+1, and +1 to first-class weak-supporting sets and hash tables.<br></p><p>Austin<br></p><p>On Fri, Jan 29, 2016 at 5:56 PM, Jordan Rose via swift-dev &lt;<br>swift-dev at swift.org&gt; wrote:<br></p><p>&gt; Hi, everyone. What do you think about dropping support for &#39;weak&#39; in<br>&gt; struct properties? This would fix a semantic issue—&#39;let&#39; structs containing<br>&gt; weak properties won&#39;t change out from under you—and (AFAICT) would make all<br>&gt; values trivially movable, which is a great quality to have.<br>&gt;<br>&gt; This wouldn&#39;t change local variables, top-level variables, or class<br>&gt; properties, just structs. It *would* make having an array of weak<br>&gt; references a little harder, but honestly we should have proper<br>&gt; weak-supporting collections anyway; as I understand it the behavior you<br>&gt; usually want is auto-compacting rather than leaving a hole. (Evidence:<br>&gt; Cocoa has NSHashTable for weak sets and NSMapTable for dictionaries with<br>&gt; weak keys and/or values; there&#39;s no variant of NSArray that supports weak<br>&gt; references other than by making a custom CFArray and being very very<br>&gt; careful how you access it.)<br>&gt;<br>&gt; Anyway, thoughts? It&#39;s not really my department but it cleans up the same<br>&gt; areas that are being affected by struct resilience.<br>&gt; Jordan<br>&gt;<br>&gt; P.S. I know this would have to go through swift-evolution for real. I just<br>&gt; want to know if it&#39;s a silly idea to begin with.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160129/04085f63/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Disallowing weak struct properties</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 5:56 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi, everyone. What do you think about dropping support for &#39;weak&#39; in struct properties? This would fix a semantic issue—&#39;let&#39; structs containing weak properties won&#39;t change out from under you<br></p><p>Is there a formalizable notion of “change” here that doesn’t include changes in mutable referents and that isn’t just restating bit-equivalence?<br></p><p>&gt; —and (AFAICT) would make all values trivially movable, which is a great quality to have.<br></p><p>If you sweep “unowned&quot; up with “weak”, yes, this is true of the current language.  It’s not an obvious restriction that we want to adopt forever, though.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Disallowing weak struct properties</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 18:22 , John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 29, 2016, at 5:56 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi, everyone. What do you think about dropping support for &#39;weak&#39; in struct properties? This would fix a semantic issue—&#39;let&#39; structs containing weak properties won&#39;t change out from under you<br>&gt; <br>&gt; Is there a formalizable notion of “change” here that doesn’t include changes in mutable referents and that isn’t just restating bit-equivalence?<br></p><p>If you treat the &quot;value&quot; of a reference as its referent&#39;s identity rather than contents, then the &quot;value&quot; of a struct is fully captured by the &quot;values&quot; of its members (which happens to be bitwise equality). The struct value has no identity.<br></p><p>The particular benefit we&#39;d get here is that existential boxes could be passed in registers, but Slava pointed out that we could just force values containing weak references to be stored out of line even if they&#39;d otherwise fit in the box.<br></p><p><br>&gt; <br>&gt;&gt; —and (AFAICT) would make all values trivially movable, which is a great quality to have.<br>&gt; <br>&gt; If you sweep “unowned&quot; up with “weak”, yes, this is true of the current language.  It’s not an obvious restriction that we want to adopt forever, though.<br></p><p>I thought unowned was ref-counted (and therefore forwardable) as well, or are we dropping that implementation because we couldn&#39;t get it to work with objc?<br></p><p>Jordan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Disallowing weak struct properties</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 6:31 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; On Jan 29, 2016, at 18:22 , John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 29, 2016, at 5:56 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi, everyone. What do you think about dropping support for &#39;weak&#39; in struct properties? This would fix a semantic issue—&#39;let&#39; structs containing weak properties won&#39;t change out from under you<br>&gt;&gt; <br>&gt;&gt; Is there a formalizable notion of “change” here that doesn’t include changes in mutable referents and that isn’t just restating bit-equivalence?<br>&gt; <br>&gt; If you treat the &quot;value&quot; of a reference as its referent&#39;s identity rather than contents, then the &quot;value&quot; of a struct is fully captured by the &quot;values&quot; of its members (which happens to be bitwise equality). The struct value has no identity.<br></p><p>This is true of weak references as well: the value is the same independent of where it is stored.  However, the value *is* dependent on global state.<br></p><p>&gt; The particular benefit we&#39;d get here is that existential boxes could be passed in registers, but Slava pointed out that we could just force values containing weak references to be stored out of line even if they&#39;d otherwise fit in the box.<br></p><p>Yes.<br></p><p>&gt;&gt;&gt; —and (AFAICT) would make all values trivially movable, which is a great quality to have.<br>&gt;&gt; <br>&gt;&gt; If you sweep “unowned&quot; up with “weak”, yes, this is true of the current language.  It’s not an obvious restriction that we want to adopt forever, though.<br>&gt; <br>&gt; I thought unowned was ref-counted (and therefore forwardable) as well, or are we dropping that implementation because we couldn&#39;t get it to work with objc?<br></p><p>Unowned references to pure-Swift classes are ref-counted.  Unowned references to unrestricted classes have to be (well, “have to be”) address-only for ObjC interop reasons; I fixed that sometime in December.<br></p><p>John.<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Disallowing weak struct properties</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January 29, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 7:56 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi, everyone. What do you think about dropping support for &#39;weak&#39; in struct properties? This would fix a semantic issue—&#39;let&#39; structs containing weak properties won&#39;t change out from under you—and (AFAICT) would make all values trivially movable, which is a great quality to have.<br>&gt; <br>&gt; … It would make having an array of weak references a little harder, but honestly we should have proper weak-supporting collections anyway; as I understand it the behavior you usually want is auto-compacting rather than leaving a hole. …<br></p><p>Well, this would certainly pour some cold water on Siesta. It might be able to get by with what you describe, but it’s hard to say without a more specific proposal on the weak-supporting collections. (Without such collections, this would be something of a disaster for the library.)<br></p><p>On the one hand, almost all the weak properties in the whole project occur in structs.<br></p><p>On the other hand, those structs are all meant to support weak collections of various kinds.<br></p><p>On the other other hand, the behavior is more complex than what you outlined above:<br></p><p>there’s StrongOrWeakRef struct used by a cache that needs to be able to switch specific references from strong to weak (at which point auto-compaction of the weak ones would be desirable), and<br>a WeakRef that hangs on to referent’s ObjectIdentifier’s hash and identity, so that it can be a stable dictionary key.<br></p><p>The second I imagine a dictionary with first-class support for weak keys would probably cover. The first seems pretty purpose-specific, however, and it’s less clear that general-purpose weak collections would cover it.<br></p><p>The StrongOrWeakRef usage suggests, I think, that weak collections may not quite be one size fits all, and having the ability to wrap a weak ref in a struct without incurring an additional allocation may be worth the trouble. At the very least, they’d need some serious thought.<br></p><p>You can see the relevant bits of the code in question here:<br></p><p>https://github.com/bustoutsolutions/siesta/blob/e29a5967e7c7e223377107ff2bdc53180f0d2951/Source/Support/ARC%2BSiesta.swift<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160129/b6b05a8d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Disallowing weak struct properties</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 29, 2016 at 07:00:00pm</p></header><div class="content"><p>I&#39;m against it, unless structs can have &quot;WeakCollectionType&quot; properties (which seems like it&#39;d necessarily involve some of that compiler magic we&#39;re trying to avoid).<br></p><p>If reference/value semantics weren&#39;t tied to struct/class, I&#39;d care a lot less.<br></p><p>I also wouldn&#39;t object to removing them from structs, but then adding a &quot;strass&quot; object classification for when you need weak inside a value-semantics object.<br></p><p>-Dave Sweeris<br></p><p>Sent from my iPhone<br></p><p>&gt; On Jan 29, 2016, at 17:56, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi, everyone. What do you think about dropping support for &#39;weak&#39; in struct properties? This would fix a semantic issue—&#39;let&#39; structs containing weak properties won&#39;t change out from under you—and (AFAICT) would make all values trivially movable, which is a great quality to have.<br>&gt; <br>&gt; This wouldn&#39;t change local variables, top-level variables, or class properties, just structs. It would make having an array of weak references a little harder, but honestly we should have proper weak-supporting collections anyway; as I understand it the behavior you usually want is auto-compacting rather than leaving a hole. (Evidence: Cocoa has NSHashTable for weak sets and NSMapTable for dictionaries with weak keys and/or values; there&#39;s no variant of NSArray that supports weak references other than by making a custom CFArray and being very very careful how you access it.)<br>&gt; <br>&gt; Anyway, thoughts? It&#39;s not really my department but it cleans up the same areas that are being affected by struct resilience.<br>&gt; Jordan<br>&gt; <br>&gt; P.S. I know this would have to go through swift-evolution for real. I just want to know if it&#39;s a silly idea to begin with.<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160129/0070af66/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Disallowing weak struct properties</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 29, 2016 at 07:00:00pm</p></header><div class="content"><p>The workaround would be boxing the weak reference in a final class, which isn&#39;t particularly efficient (or small!) but would be equivalent.<br></p><p>private final class WeakBox&lt;T: AnyObject&gt; {<br>  weak var ref: T?<br>  init(ref: T?) { self.ref = ref }<br>}<br></p><p>class Foo { … }<br></p><p>struct FooUser {<br>  private var box: WeakBox&lt;Foo&gt;<br>  init(ref: Foo?) { self.box = WeakBox(ref) }<br>  var ref: Foo? {<br>    get { return box.ref }<br>    set {<br>      // Don&#39;t mutate the existing box, which may be shared with other FooUser instances<br>      box = WeakBox(newValue)<br>    }<br>  }<br>}<br></p><p>We could also just make this the implementation of weak-in-structs (possibly with coalescing of multiple weak variables, possibly not), which would get us the optimization properties even if it doesn&#39;t fix what I see as a semantic hole. To me, though, weak properties in structs are semantically wrong because they&#39;re never actually constant. (Unowned ones, on the other hand, are just checked non-owning references, which means they don&#39;t mutate if your program is correct.)<br></p><p>Jordan<br></p><p>&gt; On Jan 29, 2016, at 19:24 , David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m against it, unless structs can have &quot;WeakCollectionType&quot; properties (which seems like it&#39;d necessarily involve some of that compiler magic we&#39;re trying to avoid).<br>&gt; <br>&gt; If reference/value semantics weren&#39;t tied to struct/class, I&#39;d care a lot less.<br>&gt; <br>&gt; I also wouldn&#39;t object to removing them from structs, but then adding a &quot;strass&quot; object classification for when you need weak inside a value-semantics object.<br>&gt; <br>&gt; -Dave Sweeris<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Jan 29, 2016, at 17:56, Jordan Rose via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Hi, everyone. What do you think about dropping support for &#39;weak&#39; in struct properties? This would fix a semantic issue—&#39;let&#39; structs containing weak properties won&#39;t change out from under you—and (AFAICT) would make all values trivially movable, which is a great quality to have.<br>&gt;&gt; <br>&gt;&gt; This wouldn&#39;t change local variables, top-level variables, or class properties, just structs. It would make having an array of weak references a little harder, but honestly we should have proper weak-supporting collections anyway; as I understand it the behavior you usually want is auto-compacting rather than leaving a hole. (Evidence: Cocoa has NSHashTable for weak sets and NSMapTable for dictionaries with weak keys and/or values; there&#39;s no variant of NSArray that supports weak references other than by making a custom CFArray and being very very careful how you access it.)<br>&gt;&gt; <br>&gt;&gt; Anyway, thoughts? It&#39;s not really my department but it cleans up the same areas that are being affected by struct resilience.<br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; P.S. I know this would have to go through swift-evolution for real. I just want to know if it&#39;s a silly idea to begin with.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160129/149cc810/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Disallowing weak struct properties</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January 29, 2016 at 10:00:00pm</p></header><div class="content"><p>Your WeakBox-backed property is more or less how I imagine the semantics of a weak var in a struct — but in the Siesta example elsewhere on this thread, the allocation overhead if it were actually implemented this way would be pretty painful.<br></p><p>P<br></p><p>&gt; On Jan 29, 2016, at 9:33 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; The workaround would be boxing the weak reference in a final class, which isn&#39;t particularly efficient (or small!) but would be equivalent.<br>&gt; <br>&gt; private final class WeakBox&lt;T: AnyObject&gt; {<br>&gt;   weak var ref: T?<br>&gt;   init(ref: T?) { self.ref = ref }<br>&gt; }<br>&gt; <br>&gt; class Foo { … }<br>&gt; <br>&gt; struct FooUser {<br>&gt;   private var box: WeakBox&lt;Foo&gt;<br>&gt;   init(ref: Foo?) { self.box = WeakBox(ref) }<br>&gt;   var ref: Foo? {<br>&gt;     get { return box.ref }<br>&gt;     set {<br>&gt;       // Don&#39;t mutate the existing box, which may be shared with other FooUser instances<br>&gt;       box = WeakBox(newValue)<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; We could also just make this the implementation of weak-in-structs (possibly with coalescing of multiple weak variables, possibly not), which would get us the optimization properties even if it doesn&#39;t fix what I see as a semantic hole. To me, though, weak properties in structs are semantically wrong because they&#39;re never actually constant. (Unowned ones, on the other hand, are just checked non-owning references, which means they don&#39;t mutate if your program is correct.)<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Jan 29, 2016, at 19:24 , David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m against it, unless structs can have &quot;WeakCollectionType&quot; properties (which seems like it&#39;d necessarily involve some of that compiler magic we&#39;re trying to avoid).<br>&gt;&gt; <br>&gt;&gt; If reference/value semantics weren&#39;t tied to struct/class, I&#39;d care a lot less.<br>&gt;&gt; <br>&gt;&gt; I also wouldn&#39;t object to removing them from structs, but then adding a &quot;strass&quot; object classification for when you need weak inside a value-semantics object.<br>&gt;&gt; <br>&gt;&gt; -Dave Sweeris<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On Jan 29, 2016, at 17:56, Jordan Rose via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Hi, everyone. What do you think about dropping support for &#39;weak&#39; in struct properties? This would fix a semantic issue—&#39;let&#39; structs containing weak properties won&#39;t change out from under you—and (AFAICT) would make all values trivially movable, which is a great quality to have.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This wouldn&#39;t change local variables, top-level variables, or class properties, just structs. It would make having an array of weak references a little harder, but honestly we should have proper weak-supporting collections anyway; as I understand it the behavior you usually want is auto-compacting rather than leaving a hole. (Evidence: Cocoa has NSHashTable for weak sets and NSMapTable for dictionaries with weak keys and/or values; there&#39;s no variant of NSArray that supports weak references other than by making a custom CFArray and being very very careful how you access it.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyway, thoughts? It&#39;s not really my department but it cleans up the same areas that are being affected by struct resilience.<br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; P.S. I know this would have to go through swift-evolution for real. I just want to know if it&#39;s a silly idea to begin with.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160129/903f1a15/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Disallowing weak struct properties</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 30, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 5:56 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi, everyone. What do you think about dropping support for &#39;weak&#39; in struct properties? This would fix a semantic issue—&#39;let&#39; structs containing weak properties won&#39;t change out from under you—and (AFAICT) would make all values trivially movable, which is a great quality to have.<br>&gt; <br>&gt; This wouldn&#39;t change local variables, top-level variables, or class properties, just structs. It would make having an array of weak references a little harder, but honestly we should have proper weak-supporting collections anyway; as I understand it the behavior you usually want is auto-compacting rather than leaving a hole. (Evidence: Cocoa has NSHashTable for weak sets and NSMapTable for dictionaries with weak keys and/or values; there&#39;s no variant of NSArray that supports weak references other than by making a custom CFArray and being very very careful how you access it.)<br>&gt; <br>&gt; Anyway, thoughts? It&#39;s not really my department but it cleans up the same areas that are being affected by struct resilience.<br></p><p>I brought this up internally last year, and we decided to keep the current behavior. Weak references are atomically managed by the compiler and runtime, so code should always see all copies of a weak reference in immutable values go to nil simultaneously. You effectively get the semantics of a weak var stored in a box, but without the box. In resilient cases, I don&#39;t think we want to make assumptions that opaque types are trivially movable irrespective of weak references, since that would severely limit our future ability to interop with C++ value types in the future, so I don&#39;t see any benefit to introducing this constraint.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160130/8414fcd4/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
