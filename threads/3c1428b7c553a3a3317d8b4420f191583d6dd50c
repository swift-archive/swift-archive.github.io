<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>April 15, 2016 at 07:00:00pm</p></header><div class="content"><p>Hi Stephen<br></p><p><br>&gt; Hi Erica, thanks for the feedback.<br>&gt; <br>&gt;&gt; On Apr 14, 2016, at 6:29 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; * I do use % for floating point but not as much as I first thought before I started searching through my code after reading your e-mail. But when I do use it, it&#39;s nice to have a really familiar symbol rather than a big word.<br>&gt; <br>Agreeing completely with Erica here.<br></p><p>&gt; <br>&gt;&gt; What were the ways that it was used incorrectly? Do you have some examples?<br>&gt; <br>&gt; As it happens, I have a rationale sitting around from an earlier (internal) discussion:<br>&gt; <br>&gt; While C and C++ do not provide the “%” operator for floating-point types, many newer languages do (Java, C#, and Python, to name just a few).  Superficially this seems reasonable, but there are severe gotchas when % is applied to floating-point data, and the results are often extremely surprising to unwary users.<br>What is your definition of unwary users? Programmers that usually don’t work with floating point data? <br>No gotchas or total flabbergasting astonishment with day to day floating point usage.<br></p><p>&gt;  C and C++ omitted this operator for good reason.  Even if you think you want this operator, it is probably doing the wrong thing in subtle ways that will cause trouble for you in the future.<br>I don’t share this opinion at all.<br>&gt; <br>&gt; The % operator on integer types satisfies the division algorithm axiom: If b is non-zero and q = a/b, r = a%b, then a = q*b + r.  This property does not hold for floating-point types, because a/b does not produce an integral value.<br>The axiom is correct of course, but only in a perfect world with perfect numbers. Not in real life.   **<br>Floats never represent integral values, if so then they were Integers.<br></p><p>&gt;  If it did produce an integral value, it would need to be a bignum type of some sort (the integral part of DBL_MAX / DBL_MIN, for example, has over 2000 bits or 600 decimal digits).<br>Impossible. E.g. one would need a planet covered completely <br>with memory (even holographic quantum) units and even then <br>you would not have enough storage to store (one) PI with all its decimals.<br>By the way most of PIs decimals are unknown as you know.<br>It could even be that memory units on all the planets in (this) <br>the universe are even not enough to satisfy the storage need <br>for just one PI.<br> * Please read the Hitchhikers Guide To The Galaxy for more info on this interesting subject :o)<br>Of course, the last decimals of PI are …42. Dolphins know that, but they left long ago in the future *      <br>&gt; <br>&gt; Even if a bignum type were returned, or if we ignore the loss of the division algorithm axiom, % would still be deeply flawed.  <br>   % is not flawed. It’s just the real life precision limitations of the floating point type. Live with it.<br></p><p><br>&gt; Whereas people are generally used to modest rounding errors in floating-point arithmetic, because % is not continuous small errors are frequently enormously magnified with catastrophic results:<br>&gt; <br>&gt; 	(swift) 10.0 % 0.1<br>&gt;    // r0 : Double = 0.0999999999999995 // What?!<br>As I have tried to explain in more detail before:<br>This is perfectly normal, acceptable  and expected, because,<br>whether you like it or not, that is the exactly? the nature of <br>floating point numbers stored in a computer<br>(well, at least in this age)  they’re not precise,<br>but in context precise enough voor most purposes in scientific <br>and engineering applications.<br>If you want to work with exact values e.g. for representing money,<br>then use an appropriate numerical type <br>or roll your own, make a struct for it.<br></p><p>Swift is poor in this because it only offers Integer and Floating point numerical types,<br>not Fixed Decimal (Like e.g. in PL/1 and C#) <br>also its Ranges and iterations are with Integers only and<br>going in one direction only.<br> <br>&gt; <br>&gt; [Explanation: 0.1 cannot be exactly represented in binary floating point; the actual value of “0.1” is 0.1000000000000000055511151231257827021181583404541015625.  Other than that rounding, the entire computation is exact.]<br>no, it&#39;s not. or at least you can’t count on that. especially when intermediate expressions (with floats) are involved.<br></p><p>** (to all, not meant cynically here, and with all due respect:<br>If you don’t value floats and understand their purpose and place,<br>please go programming for a half year or so in an industrial/engineering workshop.<br>You’ll notice that these precision issues you are writing about are mostly irrelevant.<br>E.g. You could theoretically calculate the length of a steel bar for a bridge (the hardware one :o)<br>exactly to 0.000000000001 or so,  but the bar in question would only coincidentally have<br>this exact value. For instance thermal expansion will be much larger. <br>http://www.engineeringtoolbox.com/thermal-expansion-metals-d_859.html &lt;http://www.engineeringtoolbox.com/thermal-expansion-metals-d_859.html&gt;<br>It’s all a matter of magnitude in the context/domain of what one is calculating.<br>  <br>&gt; <br>&gt; Proposed Approach:<br>&gt; Remove the “%” operator for floating-point types.  The operation is still be available via the C standard library fmod( ) function (which should be mapped to a Swiftier name, but that’s a separate proposal).<br>I completely disagree here.   It is very useful in many calculations!<br>E.g. If I want to space (geometric) objects in 3D space in SceneKit<br>I don’t care and would really not notice if a block &gt; 0.000000000000000001 or so dislocated<br>(it would also not be possible, because this small value is <br>very much less of the resolution in use, although, in theory<br>(no one has checked this :o) 3D space is infinite)  <br>Btw. SceneKit is so fast, because it uses floating point values.<br></p><p>Very sure I am missing things / come for a different time / world, etc.<br>but to me, a floating point value is nothing more than a storage location<br>holding a number of bytes, in an IEEE standard format<br>with all its related arithmetic perfectly well implemented in Swift, <br>no need to touch it or define additional functions. infinity etc.<br>So, better imho to leave it as it is. it’s OK.<br></p><p>=============<br>Off topic, but perhaps readable just the same: <br></p><p>Just a thought/ fear:<br>Watching trends here. I am also (hopefully unnecessary) <br>a bit afraid that in the long run Swift might become more <br>complex and thus as tedious to work with as Objective C? <br>Loosing it’s simplicity? <br></p><p>Note that the language should serve (nearly) every one,<br></p><p>I am now talking like an old guy, well I am 65 earth years :o) -&gt;  <br>Most of you are very talented, that’s great! and I am learning<br>things from U 2. But it appears to me that the trend is to introduce <br>a lot of “very exotic” features, (albeit with great things too that make<br>a programmer’s life easier)  but for some, are they really necessary? Useful?<br>How fragile is the line between “academic” and “academic distortion” ?  <br>How far does it go? <br>E.g for Strings, it is all logically very correct, Unicode and all,<br>but I had to write my own extensions for this:<br>     s2 = s1[1..5]  // was an unimplemented feature. Silly.<br>One could have saved the trouble, by pushing the Unicode values<br>(with variable length of course) down as atomic values, <br>instead of the opposite and laying a character view over it...<br>using overly complicated things like<br>startIndex, strides and so on ?<br>Just one example.<br></p><p>Maybe it’s just a cultural difference,<br>but like you all the same.<br></p><p>Kind regards<br>Ted<br></p><p><br></p><p><br>   <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/3c14d50c/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
