<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Proposal] Threadsafe lazy vars</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>April  6, 2016 at 11:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>lazy vars are not threadsafe in Swift 2. I saw code that uses lazy initialization in an unsafe way that introduces race conditions so often that I would be rich by now if get a penny each time. Many people use patterns like { if(_var == nil) { _var = [self _calculateVar]; } return _var; } or they just dispatch_once, but forget that they are in an instance method, and that it will all break if there is ever more than one instance of that class.<br></p><p>I propose to make lazy vars atomic. Optionally, the old lazy var behavior could be renamed to something like lazy_nonatomic.<br></p><p>I want to list some pros and cons for making lazy vars threadsafe:<br></p><p>Pros:<br>- This proposal will not change the behavior of programs which are free from data races. I could argue that the change is therefore backwards-compatible.<br>- I would say that programs which require lazy vars to be nonatomic in order to function correctly, are really bad style; threadsafe lazy vars behave much more deterministic. Many programs which use lazy vars incorrectly could suddenly become safe if this proposal is implemented.<br>- The overhead would be minimal. For example, suppose we have a lazy var of type `NSImage`. We could represent that variable as a simple pointer which is initialized to NULL. The access could look something like this (this is just an example, there may be even more efficient solutions): {<br>    // we need to make sure that reads on _var are not cached:<br>    memory_read_barrier(&amp;_var);<br>    // ^^and I&#39;m not 100% sure that we really need that memory barrier.<br>    // (at least it&#39;s not needed for static vars, as proven by the implementation of dispatch_once())<br></p><p>    if(_var == nil) {<br>        @synchronized(&amp;_var) {<br>            // ^^we synchronize on &amp;_var, and not on _var<br>            // this is semantically invalid in objc, but the objc-runtime supports it.<br>            // The point I want to make is that we don&#39;t need extra storage for the<br>            // synchronization, in many cases.<br>            if(_var != nil) {<br>                return _var;<br>            }<br>            ... some code that initializes _var<br>        }<br>        //@synchronized() already employs memory barriers, so no additional barriers are needed<br>        //maybe we should use a non-recursive lock though..<br>    }<br>    return _var;<br>}<br>- Currently, if you need threadsafety, you cannot use lazy. You can of course wrap a lock around a nonatomic lazy var, but that would be much more inefficient than a native implementation.<br>- I guess, no one will really complain if lazy var&#39;s are suddenly threadsafe. I also cannot see how it would break any code (except for contrived examples.)<br>- In some cases, the nonatomic behavior can be used as an optimization, if it is semantically equivalent. For example, a lazy var that lives in automatic storage (i.e. not an ivar or static var, but just a local var) and that is *not* captured in a closure expression can be safely initialized in a non-threadsafe way, because the variable can not be accessed from more than one thread concurrently anyways.<br></p><p>Cons:<br>- This would be the first concurrency primitive built into the language (at least as far as I know)<br>- It may suggest to users of the language that other primitives (like var&#39;s) would be threadsafe too, which is obviously not the case.<br>- There is at least *some* runtime overhead involved. It&#39;s not zero-cost. On the other hand, lazy initialization should only be used when the cost of initialization is much higher than the cost of creating and maintaining a thunk. And in that case, I think the performance characteristics are pretty well.<br>- It may be out of scope for Swift 3 :-(<br></p><p>Proposed solution:<br></p><p>    public lazy var foo: Type = fn()<br></p><p>is semantically equivalent to<br></p><p>    private var _lazy_storage_foo: Type?<br>    private var _lazy_lock_foo: Lock<br>    public var foo: Type {<br>        get {<br>            var result: Type?<br>            _lazy_lock_foo.withLock {<br>                if(_lazy_storage_foo == nil) {<br>                    _lazy_storage_foo = fn()<br>                }<br>            }<br>            return _lazy_storage_foo!<br>        }<br>    }<br></p><p>except that the builtin solution is much more efficient, and that the two private extra vars are not exposed when you use the lazy keyword.<br></p><p>All in all, I think that threadsafe lazy vars would be a nice feature for the language. I welcome feedback and am interested in a discussion.<br></p><p>Regards,<br>Michael<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Proposal] Threadsafe lazy vars</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>April  6, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 2:07 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; lazy vars are not threadsafe in Swift 2. I saw code that uses lazy initialization in an unsafe way that introduces race conditions so often that I would be rich by now if get a penny each time. Many people use patterns like { if(_var == nil) { _var = [self _calculateVar]; } return _var; } or they just dispatch_once, but forget that they are in an instance method, and that it will all break if there is ever more than one instance of that class.<br>&gt; <br>&gt; I propose to make lazy vars atomic. Optionally, the old lazy var behavior could be renamed to something like lazy_nonatomic.<br>&gt; <br>&gt; I want to list some pros and cons for making lazy vars threadsafe:<br>&gt; <br>&gt; Pros:<br>&gt; - This proposal will not change the behavior of programs which are free from data races. I could argue that the change is therefore backwards-compatible.<br>&gt; - I would say that programs which require lazy vars to be nonatomic in order to function correctly, are really bad style; threadsafe lazy vars behave much more deterministic. Many programs which use lazy vars incorrectly could suddenly become safe if this proposal is implemented.<br>&gt; - The overhead would be minimal. For example, suppose we have a lazy var of type `NSImage`. We could represent that variable as a simple pointer which is initialized to NULL. The access could look something like this (this is just an example, there may be even more efficient solutions): {<br>&gt;    // we need to make sure that reads on _var are not cached:<br>&gt;    memory_read_barrier(&amp;_var);<br>&gt;    // ^^and I&#39;m not 100% sure that we really need that memory barrier.<br>&gt;    // (at least it&#39;s not needed for static vars, as proven by the implementation of dispatch_once())<br>&gt; <br>&gt;    if(_var == nil) {<br>&gt;        @synchronized(&amp;_var) {<br>&gt;            // ^^we synchronize on &amp;_var, and not on _var<br>&gt;            // this is semantically invalid in objc, but the objc-runtime supports it.<br>&gt;            // The point I want to make is that we don&#39;t need extra storage for the<br>&gt;            // synchronization, in many cases.<br>&gt;            if(_var != nil) {<br>&gt;                return _var;<br>&gt;            }<br>&gt;            ... some code that initializes _var<br>&gt;        }<br>&gt;        //@synchronized() already employs memory barriers, so no additional barriers are needed<br>&gt;        //maybe we should use a non-recursive lock though..<br>&gt;    }<br>&gt;    return _var;<br>&gt; }<br>&gt; - Currently, if you need threadsafety, you cannot use lazy. You can of course wrap a lock around a nonatomic lazy var, but that would be much more inefficient than a native implementation.<br>&gt; - I guess, no one will really complain if lazy var&#39;s are suddenly threadsafe. I also cannot see how it would break any code (except for contrived examples.)<br>&gt; - In some cases, the nonatomic behavior can be used as an optimization, if it is semantically equivalent. For example, a lazy var that lives in automatic storage (i.e. not an ivar or static var, but just a local var) and that is *not* captured in a closure expression can be safely initialized in a non-threadsafe way, because the variable can not be accessed from more than one thread concurrently anyways.<br>&gt; <br>&gt; Cons:<br>&gt; - This would be the first concurrency primitive built into the language (at least as far as I know)<br>&gt; - It may suggest to users of the language that other primitives (like var&#39;s) would be threadsafe too, which is obviously not the case.<br>&gt; - There is at least *some* runtime overhead involved. It&#39;s not zero-cost. On the other hand, lazy initialization should only be used when the cost of initialization is much higher than the cost of creating and maintaining a thunk. And in that case, I think the performance characteristics are pretty well.<br>&gt; - It may be out of scope for Swift 3 :-(<br>&gt; <br>&gt; Proposed solution:<br>&gt; <br>&gt;    public lazy var foo: Type = fn()<br>&gt; <br>&gt; is semantically equivalent to<br>&gt; <br>&gt;    private var _lazy_storage_foo: Type?<br>&gt;    private var _lazy_lock_foo: Lock<br>&gt;    public var foo: Type {<br>&gt;        get {<br>&gt;            var result: Type?<br>&gt;            _lazy_lock_foo.withLock {<br>&gt;                if(_lazy_storage_foo == nil) {<br>&gt;                    _lazy_storage_foo = fn()<br>&gt;                }<br>&gt;            }<br>&gt;            return _lazy_storage_foo!<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; except that the builtin solution is much more efficient, and that the two private extra vars are not exposed when you use the lazy keyword.<br>&gt; <br>&gt; All in all, I think that threadsafe lazy vars would be a nice feature for the language. I welcome feedback and am interested in a discussion.<br></p><p><br>These are good points. I think we need both nonatomic and atomic lazy variables. The syntax and scaffolding will likely fall out of Property Behaviors:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md&gt;<br></p><p>All thatâ€™s left would be optimizing the implementation, which would be premature to discuss.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/9f80ec54/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
