<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Additional generics specialization</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 18, 2016 at 09:00:00am</p></header><div class="content"><p>This is something additional, but I’m curios about how the community feels about it.<br></p><p>I recently come across the issue where conforming to Hashable wasn’t enough to thecke if two instances of the same generic type were equal.<br></p><p>I had additionally provide myself the != function.<br></p><p>public func !=&lt;T, U&gt;(lhs: SomeTypeName&lt;T&gt;, rhs: SomeTypeName&lt;U&gt;) -&gt; Bool {<br>    return lhs.hashValue != rhs.hashValue<br>}<br>I wondered if Swift can ever get generic specialization like this:<br></p><p>public func !=&lt;T : Hashable, U, V&gt;(lhs: T&lt;U&gt;, rhs: T&lt;V&gt;) -&gt; Bool {<br>    return !(lhs.hashValue == rhs.hashValue)<br>}<br>This function in stdlib would fill the gap. Or we need an extra protocol GenericHashable which includes !=.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/2777b1e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Discussion] Additional generics specialization</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July 18, 2016 at 09:00:00am</p></header><div class="content"><p>In general, Swift will need a way to point to a generic type without a particular specialization. Currently, you can&#39;t do this:<br></p><p>class APICall&lt;T&gt; { }<br></p><p>class CombinedCall: APICall&lt;Bool&gt; {<br>	var calls: [APICall] // Error - no specialization<br>}<br></p><p>I&#39;ve been currently working around this by:<br></p><p>class APICallBase {} // No generics<br>class APICall&lt;T&gt;: APICallBase {}<br>class CombinedCall: APICall&lt;Bool&gt; {<br>	var calls: [APICallBase]<br>}<br></p><p>But it&#39;s definitely a pain to work with.<br></p><p>As asked by the core team several times now, we should defer any discussion on additional features until August.<br></p><p><br>&gt; On Jul 18, 2016, at 9:04 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is something additional, but I’m curios about how the community feels about it.<br>&gt; <br>&gt; I recently come across the issue where conforming to Hashable wasn’t enough to thecke if two instances of the same generic type were equal.<br>&gt; <br>&gt; I had additionally provide myself the != function.<br>&gt; <br>&gt; public func !=&lt;T, U&gt;(lhs: SomeTypeName&lt;T&gt;, rhs: SomeTypeName&lt;U&gt;) -&gt; Bool {<br>&gt;     return lhs.hashValue != rhs.hashValue<br>&gt; }<br>&gt; I wondered if Swift can ever get generic specialization like this:<br>&gt; <br>&gt; public func !=&lt;T : Hashable, U, V&gt;(lhs: T&lt;U&gt;, rhs: T&lt;V&gt;) -&gt; Bool {<br>&gt;     return !(lhs.hashValue == rhs.hashValue)<br>&gt; }<br>&gt; This function in stdlib would fill the gap. Or we need an extra protocol GenericHashable which includes !=.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/52831f68/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Additional generics specialization</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 18, 2016 at 11:00:00am</p></header><div class="content"><p>I wasn’t asking to get something like this now. I was curios and I don’t feel like curios question like this should be asked in the user mail-list. Maybe we need an extra mail-list for discussion and this will only remain for proposals and review, which will sort out such additional topics and don’t bother the review process.<br></p><p>After I posted the question I realized myself that the given example will only work for generics with a single inner type.<br></p><p>That’s why you’re totally right about the ability without specialization. :)<br></p><p>The next problem you’re design, that it does not work with structs and enums.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 18. Juli 2016 um 09:17:44, Charlie Monroe (charlie at charliemonroe.net) schrieb:<br></p><p>In general, Swift will need a way to point to a generic type without a particular specialization. Currently, you can&#39;t do this:<br></p><p>class APICall&lt;T&gt; { }<br></p><p>class CombinedCall: APICall&lt;Bool&gt; {<br>var calls: [APICall] // Error - no specialization<br>}<br></p><p>I&#39;ve been currently working around this by:<br></p><p>class APICallBase {} // No generics<br>class APICall&lt;T&gt;: APICallBase {}<br>class CombinedCall: APICall&lt;Bool&gt; {<br>var calls: [APICallBase]<br>}<br></p><p>But it&#39;s definitely a pain to work with.<br></p><p>As asked by the core team several times now, we should defer any discussion on additional features until August.<br></p><p><br>On Jul 18, 2016, at 9:04 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>This is something additional, but I’m curios about how the community feels about it.<br></p><p>I recently come across the issue where conforming to Hashable wasn’t enough to thecke if two instances of the same generic type were equal.<br></p><p>I had additionally provide myself the != function.<br></p><p>public func !=&lt;T, U&gt;(lhs: SomeTypeName&lt;T&gt;, rhs: SomeTypeName&lt;U&gt;) -&gt; Bool {<br>    return lhs.hashValue != rhs.hashValue<br>}<br>I wondered if Swift can ever get generic specialization like this:<br></p><p>public func !=&lt;T : Hashable, U, V&gt;(lhs: T&lt;U&gt;, rhs: T&lt;V&gt;) -&gt; Bool {<br>    return !(lhs.hashValue == rhs.hashValue)<br>}<br>This function in stdlib would fill the gap. Or we need an extra protocol GenericHashable which includes !=.<br></p><p><br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/aa03df6d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Discussion] Additional generics specialization</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July 18, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 18 Jul 2016, at 08:04, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is something additional, but I’m curios about how the community feels about it.<br>&gt; <br>&gt; I recently come across the issue where conforming to Hashable wasn’t enough to thecke if two instances of the same generic type were equal.<br>&gt; <br>&gt; I had additionally provide myself the != function.<br>&gt; <br>&gt; public func !=&lt;T, U&gt;(lhs: SomeTypeName&lt;T&gt;, rhs: SomeTypeName&lt;U&gt;) -&gt; Bool {<br>&gt;     return lhs.hashValue != rhs.hashValue<br>&gt; }<br>&gt; I wondered if Swift can ever get generic specialization like this:<br>&gt; <br>&gt; public func !=&lt;T : Hashable, U, V&gt;(lhs: T&lt;U&gt;, rhs: T&lt;V&gt;) -&gt; Bool {<br>&gt;     return !(lhs.hashValue == rhs.hashValue)<br>&gt; }<br>&gt; This function in stdlib would fill the gap. Or we need an extra protocol GenericHashable which includes !=.<br>&gt; <br>What exactly is the problem you&#39;re trying to solve here? Hash values being equal is not a guarantee of equality, so what you&#39;re doing with this operator is masking what&#39;s going on which I&#39;m not sure is a good idea. If you need to compare hash-values, then compare them, they&#39;re already as generic as you can possibly get (since they&#39;re always of type Int), otherwise you can&#39;t really rely on hash-values from generic types in this way, and shouldn&#39;t be hiding them behind the equality operator.<br></p><p>To think of it another way, if two hash-values are equal, then the two values *might* be equal, but you still have to test them further to be sure. You can only rely on the hash-value in this way if you have control of the implementation details, which you can only guarantee when the values you are comparing are the same type, or from a family of types that you control (as you say, a protocol could do this, by requiring that hash-values are unique within some well-defined domain).<br></p><p>I feel like this is seeking a solution that is a workaround to a protocol that has no associatedtype, as the problem you&#39;re describing is essentially already solved by generic constraints. For example, if you were working with Iterators you can define things like:<br></p><p>	func someFunc&lt;I1:IteratorProtocol, I2:IteratorProtocol where I1.Element:Hashable, I2.Element:Hashable&gt;(lhs:I1, rhs:I2) -&gt; Bool {<br>		return lhs.next()?.hashValue == rhs.next()?.hashValue<br>	}<br></p><p>Probably a useless example, but it shows how generic constraints achieve this already, but they require a protocol that is intended to expose an internal detail (the Element associatedtype), this is not what Hashable is for, Hashable is for reducing any conforming type down to an Int, with no guarantee of that value being unique.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/f82bf106/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Discussion] Additional generics specialization</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 18, 2016 at 09:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 18, 2016, at 9:04 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is something additional, but I’m curios about how the community feels about it.<br>&gt; <br>&gt; I recently come across the issue where conforming to Hashable wasn’t enough to thecke if two instances of the same generic type were equal.<br>&gt; <br>&gt; I had additionally provide myself the != function.<br>&gt; <br>&gt; public func !=&lt;T, U&gt;(lhs: SomeTypeName&lt;T&gt;, rhs: SomeTypeName&lt;U&gt;) -&gt; Bool {<br>&gt;     return lhs.hashValue != rhs.hashValue<br>&gt; }<br>&gt; I wondered if Swift can ever get generic specialization like this:<br>&gt; <br>&gt; public func !=&lt;T : Hashable, U, V&gt;(lhs: T&lt;U&gt;, rhs: T&lt;V&gt;) -&gt; Bool {<br>&gt;     return !(lhs.hashValue == rhs.hashValue)<br>&gt; }<br>I am not sure about the ordering... Interestingly enough, this is real code written last week as part of a framework:<br></p><p>Export function newSataStore&lt;T extends DataStore&lt;U&gt;, U&gt; (ctor: { new (config:DataStoreConfig):T, config:DataStoreConfig):T {<br>   return new ctor(config)<br>}<br></p><p>And this is legal code just to try:<br></p><p> interface Hashable {<br>  getHash(): number<br>}<br>interface T extends Hashable { }<br>class SomeTypeName&lt;Type extends Hashable&gt; {<br>  public getHash():number {<br>    return ...;<br>  }<br>  public type():this {<br>    return Type;<br>  }<br>}<br>function compare&lt;T1 extends T, T2 extends T&gt;(lhs:SomeTypeName&lt;T1&gt;, rhs:SomeTypeName&lt;T2&gt;):boolean {<br>  return lhs.getHash() != rhs.getHash();<br>}<br> <br>but this is more interesting:<br></p><p>type List&lt;T&gt; = T &amp; { next: List&lt;T&gt; }   // listObj.next.next.next.???<br></p><p><br></p><p><br>&gt; This function in stdlib would fill the gap. Or we need an extra protocol GenericHashable which includes !=.<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/5ff46a84/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Discussion] Additional generics specialization</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 18, 2016 at 09:00:00pm</p></header><div class="content"><p>It was TypeScript<br></p><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 18, 2016, at 9:48 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt;&gt; On Jul 18, 2016, at 9:04 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is something additional, but I’m curios about how the community feels about it.<br>&gt;&gt; <br>&gt;&gt; I recently come across the issue where conforming to Hashable wasn’t enough to thecke if two instances of the same generic type were equal.<br>&gt;&gt; <br>&gt;&gt; I had additionally provide myself the != function.<br>&gt;&gt; <br>&gt;&gt; public func !=&lt;T, U&gt;(lhs: SomeTypeName&lt;T&gt;, rhs: SomeTypeName&lt;U&gt;) -&gt; Bool {<br>&gt;&gt;     return lhs.hashValue != rhs.hashValue<br>&gt;&gt; }<br>&gt;&gt; I wondered if Swift can ever get generic specialization like this:<br>&gt;&gt; <br>&gt;&gt; public func !=&lt;T : Hashable, U, V&gt;(lhs: T&lt;U&gt;, rhs: T&lt;V&gt;) -&gt; Bool {<br>&gt;&gt;     return !(lhs.hashValue == rhs.hashValue)<br>&gt;&gt; }<br>&gt; I am not sure about the ordering... Interestingly enough, this is real code written last week as part of a framework:<br>&gt; <br>&gt; Export function newSataStore&lt;T extends DataStore&lt;U&gt;, U&gt; (ctor: { new (config:DataStoreConfig):T, config:DataStoreConfig):T {<br>&gt;    return new ctor(config)<br>&gt; }<br>&gt; <br>&gt; And this is legal code just to try:<br>&gt; <br>&gt;  interface Hashable {<br>&gt;   getHash(): number<br>&gt; }<br>&gt; interface T extends Hashable { }<br>&gt; class SomeTypeName&lt;Type extends Hashable&gt; {<br>&gt;   public getHash():number {<br>&gt;     return ...;<br>&gt;   }<br>&gt;   public type():this {<br>&gt;     return Type;<br>&gt;   }<br>&gt; }<br>&gt; function compare&lt;T1 extends T, T2 extends T&gt;(lhs:SomeTypeName&lt;T1&gt;, rhs:SomeTypeName&lt;T2&gt;):boolean {<br>&gt;   return lhs.getHash() != rhs.getHash();<br>&gt; }<br>&gt;  <br>&gt; but this is more interesting:<br>&gt; <br>&gt; type List&lt;T&gt; = T &amp; { next: List&lt;T&gt; }   // listObj.next.next.next.???<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; This function in stdlib would fill the gap. Or we need an extra protocol GenericHashable which includes !=.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/35a8bdf2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
