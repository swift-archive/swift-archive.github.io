<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/62749cfcefbf700862299872a12b2d57?s=50"></div><header><strong>[Pitch] Guarding on enum values</strong> from <string>Andrew Duncan</string> &lt;andrewzboard at gmail.com&gt;<p>December 22, 2015 at 08:00:00pm</p></header><div class="content"><p>Motivation<br></p><p>The guard statement rescues us from the pyramid of doom, and lets our code hug the left margin more... if the failure case is false or nil. I&#39;d like to guard against specific values in an enum, and get the same flattening of code flow. This generalizes Swift’s convenient handling of Optionals. (I have a hazy perception that this was mooted for 1.x, but can’t remember where I read it.)<br></p><p>The goal is to make error-handling by result-returning smoother. (I need say no more about side-effect NSError** parameters.) Consider everyone’s favorite enum example: <br></p><p>    enum Result { <br>    case .Fail(String)      // Error message<br>    case .Succeed(MyType)   // Something we use.<br>    }<br>    <br>The Pitch (to avoid TL;DR)<br></p><p>I&#39;d like to use something like this:<br></p><p>    guard case let .Succeed(m) = returnsResult() else {<br>         return it<br>    }<br>    // Can safely use m, otherwise Result is passed back the call stack.<br></p><p>Remarks<br></p><p>When I&#39;m getting back a returned Result I want to bail immediately and propagate (return) the .Fail value, but to use the Succeed value. On the left margin, not in a welter of braces. The naive way, which at least has the value of directness, is:<br></p><p>    let r = returnsResult()<br>    let m:MyType<br>    switch r {<br>    case .OK(let dummy): m = dummy<br>    default: return r<br>    }<br>    // Can use m safely here.<br>    <br>This is bulky and leaves the value r cluttering the rest of the method. Not to mention the terrible hanging right-brace.<br></p><p>We can do better:<br></p><p>    let r = returnsResult()<br>    guard case let .Succeed(m) = r else { <br>        return r <br>    }<br>    // m may safely graze. <br>    // r is mentioned *three* times, and is still hanging around.<br></p><p>Finally we see the gold of El Dorado:<br></p><p>    guard case let .Succeed(m) = returnsResult() else {<br>         return it<br>    }<br>    // m is in scope, no other cruft.<br></p><p>No repeated identifiers, no leftover debris.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Guarding on enum values</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 23, 2015 at 01:00:00am</p></header><div class="content"><p>&gt;    guard case let .Succeed(m) = returnsResult() else {<br>&gt;         return it<br>&gt;    }<br>&gt;    // Can safely use m, otherwise Result is passed back the call stack.<br></p><p>I didn&#39;t understand what you wanted to begin with, so to summarize: you want to be able to bind the return value of `returnsResult()` to a constant on the `else` branch if the pattern doesn&#39;t match.<br></p><p>I definitely see the use case here, but I can&#39;t say I like the implicit use of `it`. If we did something like this, I would prefer it be done by decorating the `else`:<br></p><p>	guard case let .Succeed(m) = returnsResult() else let r {<br>		return r<br>	}<br></p><p>However, I&#39;m honestly not sure that&#39;s much less burdensome than this:<br></p><p>	let r = returnsResult()<br>	guard case let .Succeed(m) = r else {<br>		return r<br>	}<br></p><p>It *is* a line less, and a constant less, but it also means adding a new and slightly funky syntax to the language. I&#39;m just not sure it&#39;s worth it.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Pitch] Guarding on enum values</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 23, 2015 at 09:00:00am</p></header><div class="content"><p>I feel exactly like Brent.<br></p><p>Félix<br></p><p>&gt; Le 23 déc. 2015 à 04:15:24, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt;   guard case let .Succeed(m) = returnsResult() else {<br>&gt;&gt;        return it<br>&gt;&gt;   }<br>&gt;&gt;   // Can safely use m, otherwise Result is passed back the call stack.<br>&gt; <br>&gt; I didn&#39;t understand what you wanted to begin with, so to summarize: you want to be able to bind the return value of `returnsResult()` to a constant on the `else` branch if the pattern doesn&#39;t match.<br>&gt; <br>&gt; I definitely see the use case here, but I can&#39;t say I like the implicit use of `it`. If we did something like this, I would prefer it be done by decorating the `else`:<br>&gt; <br>&gt; 	guard case let .Succeed(m) = returnsResult() else let r {<br>&gt; 		return r<br>&gt; 	}<br>&gt; <br>&gt; However, I&#39;m honestly not sure that&#39;s much less burdensome than this:<br>&gt; <br>&gt; 	let r = returnsResult()<br>&gt; 	guard case let .Succeed(m) = r else {<br>&gt; 		return r<br>&gt; 	}<br>&gt; <br>&gt; It *is* a line less, and a constant less, but it also means adding a new and slightly funky syntax to the language. I&#39;m just not sure it&#39;s worth it.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/62749cfcefbf700862299872a12b2d57?s=50"></div><header><strong>[Pitch] Guarding on enum values</strong> from <string>Andrew Duncan</string> &lt;andrewzboard at gmail.com&gt;<p>December 23, 2015 at 10:00:00am</p></header><div class="content"><p>In fact, I feel the same way too. I have definite views about indefinite pronouns. When I am teaching, I studiously avoid “it”, “this”, and “that”: at any given instant half the students have wandering minds, and if they miss the referent, they get lost. My old HyperTalk habits must be resurfacing with “it”. :)<br></p><p>I still think the use case is valuable as a (natural IMHO) generalization of guard, and feel the annoyance of having the bound variable show up three times and outlast the guard, when I don’t want to use or even see it. Brent’s suggestion removes the second objection and alleviates the first; I’ll see that, but ask if we can raise it. The pitch is:<br></p><p>    guard case let .Succeed(m) = returnsResult() else let r {<br>        return r<br>    }<br></p><p>Improvement! The question is: can we reduce this by one or two ‘r’s?<br></p><p>&gt; On 23 Dec, 2015, at 6:59, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; I feel exactly like Brent.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 23 déc. 2015 à 04:15:24, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt;  guard case let .Succeed(m) = returnsResult() else {<br>&gt;&gt;&gt;       return it<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt;  // Can safely use m, otherwise Result is passed back the call stack.<br>&gt;&gt; <br>&gt;&gt; I didn&#39;t understand what you wanted to begin with, so to summarize: you want to be able to bind the return value of `returnsResult()` to a constant on the `else` branch if the pattern doesn&#39;t match.<br>&gt;&gt; <br>&gt;&gt; I definitely see the use case here, but I can&#39;t say I like the implicit use of `it`. If we did something like this, I would prefer it be done by decorating the `else`:<br>&gt;&gt; <br>&gt;&gt; 	guard case let .Succeed(m) = returnsResult() else let r {<br>&gt;&gt; 		return r<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; However, I&#39;m honestly not sure that&#39;s much less burdensome than this:<br>&gt;&gt; <br>&gt;&gt; 	let r = returnsResult()<br>&gt;&gt; 	guard case let .Succeed(m) = r else {<br>&gt;&gt; 		return r<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; It *is* a line less, and a constant less, but it also means adding a new and slightly funky syntax to the language. I&#39;m just not sure it&#39;s worth it.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Guarding on enum values</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 23, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 10:16 AM, Andrew Duncan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In fact, I feel the same way too. I have definite views about indefinite pronouns. When I am teaching, I studiously avoid “it”, “this”, and “that”: at any given instant half the students have wandering minds, and if they miss the referent, they get lost. My old HyperTalk habits must be resurfacing with “it”. :)<br>&gt; <br>&gt; I still think the use case is valuable as a (natural IMHO) generalization of guard, and feel the annoyance of having the bound variable show up three times and outlast the guard, when I don’t want to use or even see it. Brent’s suggestion removes the second objection and alleviates the first; I’ll see that, but ask if we can raise it. The pitch is:<br>&gt; <br>&gt;    guard case let .Succeed(m) = returnsResult() else let r {<br>&gt;        return r<br>&gt;    }<br>&gt; <br>&gt; Improvement! The question is: can we reduce this by one or two ‘r’s?<br></p><p>A slight generalization would be to allow for an arbitrary pattern in the `else` clause:<br></p><p>guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>       return r<br>}<br></p><p>with the requirement that the &quot;guard&quot; and &quot;else&quot; patterns form an exhaustive match when taken together. That feels nicer than special-case knowledge of two-case enums, though I admit it punishes what&#39;s likely to be a common case.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Guarding on enum values</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 23, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 3:35 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 23, 2015, at 10:16 AM, Andrew Duncan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In fact, I feel the same way too. I have definite views about indefinite pronouns. When I am teaching, I studiously avoid “it”, “this”, and “that”: at any given instant half the students have wandering minds, and if they miss the referent, they get lost. My old HyperTalk habits must be resurfacing with “it”. :)<br>&gt;&gt; <br>&gt;&gt; I still think the use case is valuable as a (natural IMHO) generalization of guard, and feel the annoyance of having the bound variable show up three times and outlast the guard, when I don’t want to use or even see it. Brent’s suggestion removes the second objection and alleviates the first; I’ll see that, but ask if we can raise it. The pitch is:<br>&gt;&gt; <br>&gt;&gt;   guard case let .Succeed(m) = returnsResult() else let r {<br>&gt;&gt;       return r<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; Improvement! The question is: can we reduce this by one or two ‘r’s?<br>&gt; <br>&gt; A slight generalization would be to allow for an arbitrary pattern in the `else` clause:<br>&gt; <br>&gt; guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>&gt;       return r<br>&gt; }<br>&gt; <br>&gt; with the requirement that the &quot;guard&quot; and &quot;else&quot; patterns form an exhaustive match when taken together. That feels nicer than special-case knowledge of two-case enums, though I admit it punishes what&#39;s likely to be a common case.<br></p><p>I thought a bit about that. Would it make sense to support multiple else blocks?<br></p><p>	guard case let .Succeed(m) = returnsResult()<br>	else if case .Failure(&quot;Temporary Failure&quot;) {<br>		return retry()<br>	}<br>	else case let .Failure(r) {<br>		return r<br>	}<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/62749cfcefbf700862299872a12b2d57?s=50"></div><header><strong>[Pitch] Guarding on enum values</strong> from <string>Andrew Duncan</string> &lt;andrewzboard at gmail.com&gt;<p>December 23, 2015 at 03:00:00pm</p></header><div class="content"><p>More progress! This sounds good, but it looks like what you intend is for r to be the error message in the Result enum type.<br></p><p>enum Result {<br>case .Fail(String)    // Error message<br>case .Succeed(MyType) // Something to work with<br>}<br></p><p>guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>      return r // Looks like r is bound to the error String. <br>               // But maybe you meant r = the entire returnsResult() result.<br>}<br></p><p>The sort of message-passing error-handling I have in mind is where each method in the call chain returns a full Result enum and each stage checks it for Succeed/Fail, and immediately bails on Fail, returning (propagating) the Result. To be sure, this is sort of what exceptions do under the hood anyway.<br></p><p>My use-case is a recursive descent parser that I want to bail when a syntax error is found. This could happen way deep in the stack of calls. If I consistently return a .Fail(ErrorCode) or .Succeed(ASTNode) from each method, I just pass on the Result in case of .Fail, or use it in case of .Succeed.<br> <br></p><p>&gt; On 23 Dec, 2015, at 15:35, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 10:16 AM, Andrew Duncan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt; <br>&gt; A slight generalization would be to allow for an arbitrary pattern in the `else` clause:<br>&gt; <br>&gt; guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>&gt;       return r<br>&gt; }<br>&gt; <br>&gt; with the requirement that the &quot;guard&quot; and &quot;else&quot; patterns form an exhaustive match when taken together. That feels nicer than special-case knowledge of two-case enums, though I admit it punishes what&#39;s likely to be a common case.<br>&gt; <br>&gt; -Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Guarding on enum values</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 23, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 3:56 PM, Andrew Duncan &lt;andrewzboard at gmail.com&gt; wrote:<br>&gt; <br>&gt; More progress! This sounds good, but it looks like what you intend is for r to be the error message in the Result enum type.<br>&gt; <br>&gt; enum Result {<br>&gt; case .Fail(String)    // Error message<br>&gt; case .Succeed(MyType) // Something to work with<br>&gt; }<br>&gt; <br>&gt; guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>&gt;      return r // Looks like r is bound to the error String. <br>&gt;               // But maybe you meant r = the entire returnsResult() result.<br>&gt; }<br></p><p>I see. If it&#39;s an arbitrary pattern, you can match &#39;case let r&#39; to bind the entire value instead of picking out the payload of the other case. That would still be exhaustive.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; The sort of message-passing error-handling I have in mind is where each method in the call chain returns a full Result enum and each stage checks it for Succeed/Fail, and immediately bails on Fail, returning (propagating) the Result. To be sure, this is sort of what exceptions do under the hood anyway.<br>&gt; <br>&gt; My use-case is a recursive descent parser that I want to bail when a syntax error is found. This could happen way deep in the stack of calls. If I consistently return a .Fail(ErrorCode) or .Succeed(ASTNode) from each method, I just pass on the Result in case of .Fail, or use it in case of .Succeed.<br>&gt; <br>&gt; <br>&gt;&gt; On 23 Dec, 2015, at 15:35, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 23, 2015, at 10:16 AM, Andrew Duncan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; A slight generalization would be to allow for an arbitrary pattern in the `else` clause:<br>&gt;&gt; <br>&gt;&gt; guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>&gt;&gt;      return r<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; with the requirement that the &quot;guard&quot; and &quot;else&quot; patterns form an exhaustive match when taken together. That feels nicer than special-case knowledge of two-case enums, though I admit it punishes what&#39;s likely to be a common case.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/62749cfcefbf700862299872a12b2d57?s=50"></div><header><strong>[Pitch] Guarding on enum values</strong> from <string>Andrew Duncan</string> &lt;andrewzboard at gmail.com&gt;<p>December 23, 2015 at 04:00:00pm</p></header><div class="content"><p>Yes, which would revert to Brent’s suggestion. But you have generalized it in a very compatible way.<br></p><p>As I read somewhere, improving programming languages comes from removing limitations rather than adding features. I intend for this Pitch to be the former, although it does kind of look like the latter.<br></p><p>&gt; On 23 Dec, 2015, at 15:58, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 3:56 PM, Andrew Duncan &lt;andrewzboard at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; More progress! This sounds good, but it looks like what you intend is for r to be the error message in the Result enum type.<br>&gt;&gt; <br>&gt;&gt; enum Result {<br>&gt;&gt; case .Fail(String)    // Error message<br>&gt;&gt; case .Succeed(MyType) // Something to work with<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>&gt;&gt;     return r // Looks like r is bound to the error String. <br>&gt;&gt;              // But maybe you meant r = the entire returnsResult() result.<br>&gt;&gt; }<br>&gt; <br>&gt; I see. If it&#39;s an arbitrary pattern, you can match &#39;case let r&#39; to bind the entire value instead of picking out the payload of the other case. That would still be exhaustive.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt; The sort of message-passing error-handling I have in mind is where each method in the call chain returns a full Result enum and each stage checks it for Succeed/Fail, and immediately bails on Fail, returning (propagating) the Result. To be sure, this is sort of what exceptions do under the hood anyway.<br>&gt;&gt; <br>&gt;&gt; My use-case is a recursive descent parser that I want to bail when a syntax error is found. This could happen way deep in the stack of calls. If I consistently return a .Fail(ErrorCode) or .Succeed(ASTNode) from each method, I just pass on the Result in case of .Fail, or use it in case of .Succeed.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 23 Dec, 2015, at 15:35, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 23, 2015, at 10:16 AM, Andrew Duncan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A slight generalization would be to allow for an arbitrary pattern in the `else` clause:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>&gt;&gt;&gt;     return r<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; with the requirement that the &quot;guard&quot; and &quot;else&quot; patterns form an exhaustive match when taken together. That feels nicer than special-case knowledge of two-case enums, though I admit it punishes what&#39;s likely to be a common case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pitch] Guarding on enum values</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 24, 2015 at 12:00:00pm</p></header><div class="content"><p>What do you think of<br></p><p>guard let r = returnsResult(), case let .Succeed(m) = r else {<br>        return r <br>}<br></p><p>Which binds r only within the scope of the guard as desired.<br></p><p>Written in multiple lines<br></p><p>guard <br>        let r = returnsResult(), <br>        case let .Succeed(m) = r <br>else {<br>        return r <br>}<br></p><p>-Thorsten <br></p><p>&gt; Am 24.12.2015 um 01:02 schrieb Andrew Duncan via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Yes, which would revert to Brent’s suggestion. But you have generalized it in a very compatible way.<br>&gt; <br>&gt; As I read somewhere, improving programming languages comes from removing limitations rather than adding features. I intend for this Pitch to be the former, although it does kind of look like the latter.<br>&gt; <br>&gt;&gt; On 23 Dec, 2015, at 15:58, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 23, 2015, at 3:56 PM, Andrew Duncan &lt;andrewzboard at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More progress! This sounds good, but it looks like what you intend is for r to be the error message in the Result enum type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Result {<br>&gt;&gt;&gt; case .Fail(String)    // Error message<br>&gt;&gt;&gt; case .Succeed(MyType) // Something to work with<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>&gt;&gt;&gt;    return r // Looks like r is bound to the error String. <br>&gt;&gt;&gt;             // But maybe you meant r = the entire returnsResult() result.<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I see. If it&#39;s an arbitrary pattern, you can match &#39;case let r&#39; to bind the entire value instead of picking out the payload of the other case. That would still be exhaustive.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The sort of message-passing error-handling I have in mind is where each method in the call chain returns a full Result enum and each stage checks it for Succeed/Fail, and immediately bails on Fail, returning (propagating) the Result. To be sure, this is sort of what exceptions do under the hood anyway.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My use-case is a recursive descent parser that I want to bail when a syntax error is found. This could happen way deep in the stack of calls. If I consistently return a .Fail(ErrorCode) or .Succeed(ASTNode) from each method, I just pass on the Result in case of .Fail, or use it in case of .Succeed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 23 Dec, 2015, at 15:35, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 10:16 AM, Andrew Duncan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A slight generalization would be to allow for an arbitrary pattern in the `else` clause:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>&gt;&gt;&gt;&gt;    return r<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; with the requirement that the &quot;guard&quot; and &quot;else&quot; patterns form an exhaustive match when taken together. That feels nicer than special-case knowledge of two-case enums, though I admit it punishes what&#39;s likely to be a common case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Pitch] Guarding on enum values</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 24, 2015 at 09:00:00am</p></header><div class="content"><p>I like that it&#39;s consistent with the if syntax (even though I don&#39;t really like the if syntax) and that there&#39;s no dangling parts after the else.<br></p><p>Félix<br></p><p>&gt; Le 24 déc. 2015 à 06:29:17, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; What do you think of<br>&gt; <br>&gt; guard let r = returnsResult(), case let .Succeed(m) = r else {<br>&gt;        return r <br>&gt; }<br>&gt; <br>&gt; Which binds r only within the scope of the guard as desired.<br>&gt; <br>&gt; Written in multiple lines<br>&gt; <br>&gt; guard <br>&gt;        let r = returnsResult(), <br>&gt;        case let .Succeed(m) = r <br>&gt; else {<br>&gt;        return r <br>&gt; }<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt;&gt; Am 24.12.2015 um 01:02 schrieb Andrew Duncan via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Yes, which would revert to Brent’s suggestion. But you have generalized it in a very compatible way.<br>&gt;&gt; <br>&gt;&gt; As I read somewhere, improving programming languages comes from removing limitations rather than adding features. I intend for this Pitch to be the former, although it does kind of look like the latter.<br>&gt;&gt; <br>&gt;&gt;&gt; On 23 Dec, 2015, at 15:58, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 23, 2015, at 3:56 PM, Andrew Duncan &lt;andrewzboard at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; More progress! This sounds good, but it looks like what you intend is for r to be the error message in the Result enum type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum Result {<br>&gt;&gt;&gt;&gt; case .Fail(String)    // Error message<br>&gt;&gt;&gt;&gt; case .Succeed(MyType) // Something to work with<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>&gt;&gt;&gt;&gt;   return r // Looks like r is bound to the error String. <br>&gt;&gt;&gt;&gt;            // But maybe you meant r = the entire returnsResult() result.<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I see. If it&#39;s an arbitrary pattern, you can match &#39;case let r&#39; to bind the entire value instead of picking out the payload of the other case. That would still be exhaustive.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The sort of message-passing error-handling I have in mind is where each method in the call chain returns a full Result enum and each stage checks it for Succeed/Fail, and immediately bails on Fail, returning (propagating) the Result. To be sure, this is sort of what exceptions do under the hood anyway.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My use-case is a recursive descent parser that I want to bail when a syntax error is found. This could happen way deep in the stack of calls. If I consistently return a .Fail(ErrorCode) or .Succeed(ASTNode) from each method, I just pass on the Result in case of .Fail, or use it in case of .Succeed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 23 Dec, 2015, at 15:35, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 10:16 AM, Andrew Duncan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A slight generalization would be to allow for an arbitrary pattern in the `else` clause:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>&gt;&gt;&gt;&gt;&gt;   return r<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; with the requirement that the &quot;guard&quot; and &quot;else&quot; patterns form an exhaustive match when taken together. That feels nicer than special-case knowledge of two-case enums, though I admit it punishes what&#39;s likely to be a common case.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Pitch] Guarding on enum values</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 24, 2015 at 12:00:00pm</p></header><div class="content"><p>Wait, no, there&#39;s a problem with that. You can&#39;t use `r` in the guard scope because `returnsResult()` might not have succeeded.<br></p><p>Félix<br></p><p>&gt; Le 24 déc. 2015 à 09:37:36, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I like that it&#39;s consistent with the if syntax (even though I don&#39;t really like the if syntax) and that there&#39;s no dangling parts after the else.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 24 déc. 2015 à 06:29:17, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; What do you think of<br>&gt;&gt; <br>&gt;&gt; guard let r = returnsResult(), case let .Succeed(m) = r else {<br>&gt;&gt;       return r <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Which binds r only within the scope of the guard as desired.<br>&gt;&gt; <br>&gt;&gt; Written in multiple lines<br>&gt;&gt; <br>&gt;&gt; guard <br>&gt;&gt;       let r = returnsResult(), <br>&gt;&gt;       case let .Succeed(m) = r <br>&gt;&gt; else {<br>&gt;&gt;       return r <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt;&gt; Am 24.12.2015 um 01:02 schrieb Andrew Duncan via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, which would revert to Brent’s suggestion. But you have generalized it in a very compatible way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As I read somewhere, improving programming languages comes from removing limitations rather than adding features. I intend for this Pitch to be the former, although it does kind of look like the latter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 23 Dec, 2015, at 15:58, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 3:56 PM, Andrew Duncan &lt;andrewzboard at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; More progress! This sounds good, but it looks like what you intend is for r to be the error message in the Result enum type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; enum Result {<br>&gt;&gt;&gt;&gt;&gt; case .Fail(String)    // Error message<br>&gt;&gt;&gt;&gt;&gt; case .Succeed(MyType) // Something to work with<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>&gt;&gt;&gt;&gt;&gt;  return r // Looks like r is bound to the error String. <br>&gt;&gt;&gt;&gt;&gt;           // But maybe you meant r = the entire returnsResult() result.<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I see. If it&#39;s an arbitrary pattern, you can match &#39;case let r&#39; to bind the entire value instead of picking out the payload of the other case. That would still be exhaustive.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The sort of message-passing error-handling I have in mind is where each method in the call chain returns a full Result enum and each stage checks it for Succeed/Fail, and immediately bails on Fail, returning (propagating) the Result. To be sure, this is sort of what exceptions do under the hood anyway.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My use-case is a recursive descent parser that I want to bail when a syntax error is found. This could happen way deep in the stack of calls. If I consistently return a .Fail(ErrorCode) or .Succeed(ASTNode) from each method, I just pass on the Result in case of .Fail, or use it in case of .Succeed.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 23 Dec, 2015, at 15:35, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 10:16 AM, Andrew Duncan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A slight generalization would be to allow for an arbitrary pattern in the `else` clause:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>&gt;&gt;&gt;&gt;&gt;&gt;  return r<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; with the requirement that the &quot;guard&quot; and &quot;else&quot; patterns form an exhaustive match when taken together. That feels nicer than special-case knowledge of two-case enums, though I admit it punishes what&#39;s likely to be a common case.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pitch] Guarding on enum values</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 27, 2015 at 05:00:00pm</p></header><div class="content"><p>The problem is that currently the if-let and guard-let syntax is reserved for unwrapping optionals and therefore cannot be used (at least not unambiguously) for simple let-bindings as well, which is required here.<br></p><p>My example therefore needs the following change (sorry, I did not make this explicit):<br></p><p>1. allow let-bindings in if- and guard-statements and<br>2. require explicit optional unwrapping by pattern matching in if- and guard-statements<br></p><p>In addition I’d like to add the following (but that’s really a separate proposal):<br>3. drop the „case“ keyword for pattern matching<br></p><p>The example would then look like follows (written in multiple lines for adding comments):<br></p><p>guard <br>     let r = returnsResult(), 	// simple let-binding<br>     let .Succeed(m) = r  		// pattern matching<br>else {<br>     return r <br>}<br></p><p>Unwrapping optionals would then look like follows (i.e. no special syntax for unwrapping optionals):<br></p><p>if let .Some(x) = x {<br>	…<br>}<br></p><p>A shorter alternative might be: if let x ?= x { … }<br></p><p>IIRC this or something similar was part of an earlier Swift release and was streamlined to the current syntax because optionals are quite common and already have special syntax sugar. The problem is that the current syntax while being convenient for its succinctness is ambiguous with simple let-bindings which is inconsistent and - more importantly - makes extending if-statements and guard-statements by simple let-bindings impossible.<br></p><p>-Thorsten<br></p><p><br>&gt; Am 24.12.2015 um 18:13 schrieb Félix Cloutier &lt;felixcca at yahoo.ca&gt;:<br>&gt; <br>&gt; Wait, no, there&#39;s a problem with that. You can&#39;t use `r` in the guard scope because `returnsResult()` might not have succeeded.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 24 déc. 2015 à 09:37:36, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I like that it&#39;s consistent with the if syntax (even though I don&#39;t really like the if syntax) and that there&#39;s no dangling parts after the else.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 24 déc. 2015 à 06:29:17, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you think of<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard let r = returnsResult(), case let .Succeed(m) = r else {<br>&gt;&gt;&gt;      return r <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Which binds r only within the scope of the guard as desired.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Written in multiple lines<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard <br>&gt;&gt;&gt;      let r = returnsResult(), <br>&gt;&gt;&gt;      case let .Succeed(m) = r <br>&gt;&gt;&gt; else {<br>&gt;&gt;&gt;      return r <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 24.12.2015 um 01:02 schrieb Andrew Duncan via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, which would revert to Brent’s suggestion. But you have generalized it in a very compatible way.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As I read somewhere, improving programming languages comes from removing limitations rather than adding features. I intend for this Pitch to be the former, although it does kind of look like the latter.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 23 Dec, 2015, at 15:58, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 3:56 PM, Andrew Duncan &lt;andrewzboard at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; More progress! This sounds good, but it looks like what you intend is for r to be the error message in the Result enum type.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; enum Result {<br>&gt;&gt;&gt;&gt;&gt;&gt; case .Fail(String)    // Error message<br>&gt;&gt;&gt;&gt;&gt;&gt; case .Succeed(MyType) // Something to work with<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>&gt;&gt;&gt;&gt;&gt;&gt; return r // Looks like r is bound to the error String. <br>&gt;&gt;&gt;&gt;&gt;&gt;          // But maybe you meant r = the entire returnsResult() result.<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I see. If it&#39;s an arbitrary pattern, you can match &#39;case let r&#39; to bind the entire value instead of picking out the payload of the other case. That would still be exhaustive.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The sort of message-passing error-handling I have in mind is where each method in the call chain returns a full Result enum and each stage checks it for Succeed/Fail, and immediately bails on Fail, returning (propagating) the Result. To be sure, this is sort of what exceptions do under the hood anyway.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; My use-case is a recursive descent parser that I want to bail when a syntax error is found. This could happen way deep in the stack of calls. If I consistently return a .Fail(ErrorCode) or .Succeed(ASTNode) from each method, I just pass on the Result in case of .Fail, or use it in case of .Succeed.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 23 Dec, 2015, at 15:35, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 10:16 AM, Andrew Duncan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; A slight generalization would be to allow for an arbitrary pattern in the `else` clause:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return r<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; with the requirement that the &quot;guard&quot; and &quot;else&quot; patterns form an exhaustive match when taken together. That feels nicer than special-case knowledge of two-case enums, though I admit it punishes what&#39;s likely to be a common case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Pitch] Guarding on enum values</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 27, 2015 at 05:00:00pm</p></header><div class="content"><p>You actually can do simple let-bindings in if-let and guard-let via the `case let` syntax:<br></p><p>guard case let r = returnsResult(), case let .Succeed(m) = r else { ... }<br></p><p>Although the problem with this is `r` still isn&#39;t visible inside of the else block, because it&#39;s part of the guard statement and none of the bound identifiers are visible inside of the else. But this really ends up being the equivalent of<br></p><p>let r = returnsResult()<br>guard case let .Succeed(m) = r else { return r }<br></p><p>anyway so I don&#39;t really see the point in pursuing this.<br></p><p>As for changing if-let and guard-let by default to do this style of matching, I believe the Swift team did consider doing that, but the overwhelming prevalence of Optionals in Swift is why they didn&#39;t go ahead with it. I bet if you examine your own code you&#39;ll find that normal if-let and guard-lets outweigh if-case and guard-case by a very large amount.<br></p><p>-Kevin<br></p><p>On Sun, Dec 27, 2015, at 08:25 AM, Thorsten Seitz via swift-evolution wrote:<br>&gt; The problem is that currently the if-let and guard-let syntax is reserved for unwrapping optionals and therefore cannot be used (at least not unambiguously) for simple let-bindings as well, which is required here.<br>&gt; <br>&gt; My example therefore needs the following change (sorry, I did not make this explicit):<br>&gt; <br>&gt; 1. allow let-bindings in if- and guard-statements and<br>&gt; 2. require explicit optional unwrapping by pattern matching in if- and guard-statements<br>&gt; <br>&gt; In addition I’d like to add the following (but that’s really a separate proposal):<br>&gt; 3. drop the „case“ keyword for pattern matching<br>&gt; <br>&gt; The example would then look like follows (written in multiple lines for adding comments):<br>&gt; <br>&gt; guard <br>&gt;      let r = returnsResult(), 	// simple let-binding<br>&gt;      let .Succeed(m) = r  		// pattern matching<br>&gt; else {<br>&gt;      return r <br>&gt; }<br>&gt; <br>&gt; Unwrapping optionals would then look like follows (i.e. no special syntax for unwrapping optionals):<br>&gt; <br>&gt; if let .Some(x) = x {<br>&gt; 	…<br>&gt; }<br>&gt; <br>&gt; A shorter alternative might be: if let x ?= x { … }<br>&gt; <br>&gt; IIRC this or something similar was part of an earlier Swift release and was streamlined to the current syntax because optionals are quite common and already have special syntax sugar. The problem is that the current syntax while being convenient for its succinctness is ambiguous with simple let-bindings which is inconsistent and - more importantly - makes extending if-statements and guard-statements by simple let-bindings impossible.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; &gt; Am 24.12.2015 um 18:13 schrieb Félix Cloutier &lt;felixcca at yahoo.ca&gt;:<br>&gt; &gt; <br>&gt; &gt; Wait, no, there&#39;s a problem with that. You can&#39;t use `r` in the guard scope because `returnsResult()` might not have succeeded.<br>&gt; &gt; <br>&gt; &gt; Félix<br>&gt; &gt; <br>&gt; &gt;&gt; Le 24 déc. 2015 à 09:37:36, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I like that it&#39;s consistent with the if syntax (even though I don&#39;t really like the if syntax) and that there&#39;s no dangling parts after the else.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Félix<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;&gt; Le 24 déc. 2015 à 06:29:17, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; What do you think of<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; guard let r = returnsResult(), case let .Succeed(m) = r else {<br>&gt; &gt;&gt;&gt;      return r <br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Which binds r only within the scope of the guard as desired.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Written in multiple lines<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; guard <br>&gt; &gt;&gt;&gt;      let r = returnsResult(), <br>&gt; &gt;&gt;&gt;      case let .Succeed(m) = r <br>&gt; &gt;&gt;&gt; else {<br>&gt; &gt;&gt;&gt;      return r <br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; -Thorsten <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; Am 24.12.2015 um 01:02 schrieb Andrew Duncan via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; Yes, which would revert to Brent’s suggestion. But you have generalized it in a very compatible way.<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; As I read somewhere, improving programming languages comes from removing limitations rather than adding features. I intend for this Pitch to be the former, although it does kind of look like the latter.<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; On 23 Dec, 2015, at 15:58, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 3:56 PM, Andrew Duncan &lt;andrewzboard at gmail.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; More progress! This sounds good, but it looks like what you intend is for r to be the error message in the Result enum type.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum Result {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case .Fail(String)    // Error message<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case .Succeed(MyType) // Something to work with<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; return r // Looks like r is bound to the error String. <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;          // But maybe you meant r = the entire returnsResult() result.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; I see. If it&#39;s an arbitrary pattern, you can match &#39;case let r&#39; to bind the entire value instead of picking out the payload of the other case. That would still be exhaustive.<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; -Joe<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; The sort of message-passing error-handling I have in mind is where each method in the call chain returns a full Result enum and each stage checks it for Succeed/Fail, and immediately bails on Fail, returning (propagating) the Result. To be sure, this is sort of what exceptions do under the hood anyway.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; My use-case is a recursive descent parser that I want to bail when a syntax error is found. This could happen way deep in the stack of calls. If I consistently return a .Fail(ErrorCode) or .Succeed(ASTNode) from each method, I just pass on the Result in case of .Fail, or use it in case of .Succeed.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On 23 Dec, 2015, at 15:35, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 10:16 AM, Andrew Duncan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; A slight generalization would be to allow for an arbitrary pattern in the `else` clause:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; return r<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; with the requirement that the &quot;guard&quot; and &quot;else&quot; patterns form an exhaustive match when taken together. That feels nicer than special-case knowledge of two-case enums, though I admit it punishes what&#39;s likely to be a common case.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pitch] Guarding on enum values</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 28, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; Am 28.12.2015 um 02:31 schrieb Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; You actually can do simple let-bindings in if-let and guard-let via the `case let` syntax:<br>&gt; <br>&gt; guard case let r = returnsResult(), case let .Succeed(m) = r else { ... }<br>&gt; <br>&gt; Although the problem with this is `r` still isn&#39;t visible inside of the else block, because it&#39;s part of the guard statement and none of the bound identifiers are visible inside of the else.<br></p><p>Which is correct because &quot;case let&quot; can fail as it is not a simple let-binding but pattn matching. That&#39;s why a real simple let-binding might be attractive to have. Names bound by these (or rather by let-bindings that happen before a failable binding like pattern matching or optionla unwrapping) should be available in the else block.<br></p><p>&gt; But this really ends up being the equivalent of<br>&gt; <br>&gt; let r = returnsResult()<br>&gt; guard case let .Succeed(m) = r else { return r }<br>&gt; <br>&gt; anyway so I don&#39;t really see the point in pursuing this.<br></p><p>The point was about keeping the scope of &quot;r&quot; restricted to the guard clause.<br>This might not be worth the effort, of course.<br></p><p>&gt; As for changing if-let and guard-let by default to do this style of matching, I believe the Swift team did consider doing that, but the overwhelming prevalence of Optionals in Swift is why they didn&#39;t go ahead with it. I bet if you examine your own code you&#39;ll find that normal if-let and guard-lets outweigh if-case and guard-case by a very large amount.<br></p><p>I agree without having to examine my code but I&#39;m still unsure whether it wouldn&#39;t be better to unify let bindings with pattern matching while disambiguating simple bindings from pattern matching and optional unwrapping as special case of pattern matching:<br></p><p>let pattern = expression <br></p><p>If &quot;pattern&quot; is a simple variable the pattern matching cannot fail, so we have a simple let-binding. Using this in an if- or guard-statement would make the bound name available in the statement block(s) unless a failable pattern matching came before it.<br></p><p>For syntactically light optional unwrapping &quot;expression&quot; can be &quot;x?&quot;, i.e. &quot;if let x = x? {...}&quot;.<br>This syntax sugar would be in line with optional chaining, like &quot;x?.property = 42&quot; where we can understand &quot;x?&quot; to mean the unwrapped optional if present and otherwise skipping the statement.<br></p><p>-Thorsten <br></p><p>&gt; <br>&gt; -Kevin<br>&gt; <br>&gt;&gt; On Sun, Dec 27, 2015, at 08:25 AM, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt; The problem is that currently the if-let and guard-let syntax is reserved for unwrapping optionals and therefore cannot be used (at least not unambiguously) for simple let-bindings as well, which is required here.<br>&gt;&gt; <br>&gt;&gt; My example therefore needs the following change (sorry, I did not make this explicit):<br>&gt;&gt; <br>&gt;&gt; 1. allow let-bindings in if- and guard-statements and<br>&gt;&gt; 2. require explicit optional unwrapping by pattern matching in if- and guard-statements<br>&gt;&gt; <br>&gt;&gt; In addition I’d like to add the following (but that’s really a separate proposal):<br>&gt;&gt; 3. drop the „case“ keyword for pattern matching<br>&gt;&gt; <br>&gt;&gt; The example would then look like follows (written in multiple lines for adding comments):<br>&gt;&gt; <br>&gt;&gt; guard <br>&gt;&gt;     let r = returnsResult(),    // simple let-binding<br>&gt;&gt;     let .Succeed(m) = r          // pattern matching<br>&gt;&gt; else {<br>&gt;&gt;     return r <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Unwrapping optionals would then look like follows (i.e. no special syntax for unwrapping optionals):<br>&gt;&gt; <br>&gt;&gt; if let .Some(x) = x {<br>&gt;&gt;    …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; A shorter alternative might be: if let x ?= x { … }<br>&gt;&gt; <br>&gt;&gt; IIRC this or something similar was part of an earlier Swift release and was streamlined to the current syntax because optionals are quite common and already have special syntax sugar. The problem is that the current syntax while being convenient for its succinctness is ambiguous with simple let-bindings which is inconsistent and - more importantly - makes extending if-statements and guard-statements by simple let-bindings impossible.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 24.12.2015 um 18:13 schrieb Félix Cloutier &lt;felixcca at yahoo.ca&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Wait, no, there&#39;s a problem with that. You can&#39;t use `r` in the guard scope because `returnsResult()` might not have succeeded.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 24 déc. 2015 à 09:37:36, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like that it&#39;s consistent with the if syntax (even though I don&#39;t really like the if syntax) and that there&#39;s no dangling parts after the else.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 24 déc. 2015 à 06:29:17, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What do you think of<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; guard let r = returnsResult(), case let .Succeed(m) = r else {<br>&gt;&gt;&gt;&gt;&gt;     return r <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Which binds r only within the scope of the guard as desired.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Written in multiple lines<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; guard <br>&gt;&gt;&gt;&gt;&gt;     let r = returnsResult(), <br>&gt;&gt;&gt;&gt;&gt;     case let .Succeed(m) = r <br>&gt;&gt;&gt;&gt;&gt; else {<br>&gt;&gt;&gt;&gt;&gt;     return r <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 24.12.2015 um 01:02 schrieb Andrew Duncan via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, which would revert to Brent’s suggestion. But you have generalized it in a very compatible way.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As I read somewhere, improving programming languages comes from removing limitations rather than adding features. I intend for this Pitch to be the former, although it does kind of look like the latter.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 23 Dec, 2015, at 15:58, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 3:56 PM, Andrew Duncan &lt;andrewzboard at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; More progress! This sounds good, but it looks like what you intend is for r to be the error message in the Result enum type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum Result {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Fail(String)    // Error message<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Succeed(MyType) // Something to work with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; return r // Looks like r is bound to the error String. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // But maybe you meant r = the entire returnsResult() result.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I see. If it&#39;s an arbitrary pattern, you can match &#39;case let r&#39; to bind the entire value instead of picking out the payload of the other case. That would still be exhaustive.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The sort of message-passing error-handling I have in mind is where each method in the call chain returns a full Result enum and each stage checks it for Succeed/Fail, and immediately bails on Fail, returning (propagating) the Result. To be sure, this is sort of what exceptions do under the hood anyway.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My use-case is a recursive descent parser that I want to bail when a syntax error is found. This could happen way deep in the stack of calls. If I consistently return a .Fail(ErrorCode) or .Succeed(ASTNode) from each method, I just pass on the Result in case of .Fail, or use it in case of .Succeed.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 23 Dec, 2015, at 15:35, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 10:16 AM, Andrew Duncan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A slight generalization would be to allow for an arbitrary pattern in the `else` clause:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; return r<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with the requirement that the &quot;guard&quot; and &quot;else&quot; patterns form an exhaustive match when taken together. That feels nicer than special-case knowledge of two-case enums, though I admit it punishes what&#39;s likely to be a common case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Pitch] Guarding on enum values</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 27, 2015 at 05:00:00pm</p></header><div class="content"><p>On Wed, Dec 23, 2015, at 03:35 PM, Joe Groff via swift-evolution wrote:<br>&gt; A slight generalization would be to allow for an arbitrary pattern in the `else` clause:<br>&gt; <br>&gt; guard case let .Succeed(m) = returnsResult() else case let .Failure(r) {<br>&gt;        return r<br>&gt; }<br>&gt; <br>&gt; with the requirement that the &quot;guard&quot; and &quot;else&quot; patterns form an exhaustive match when taken together. That feels nicer than special-case knowledge of two-case enums, though I admit it punishes what&#39;s likely to be a common case.<br></p><p>Cute, but it seems a little confusing. Personally, I&#39;d rather just stick with a normal switch in cases like that:<br></p><p>let m: MyType<br>switch returnsResult() {<br>case let .Succeed(m_): m = m_<br>case let .Failure(r): return r<br>}<br></p><p>-Kevin<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5c9df42e3c293e3cdb5f3e1b34d44ef9?s=50"></div><header><strong>[Pitch] Guarding on enum values</strong> from <string>Step C</string> &lt;schristopher at bignerdranch.com&gt;<p>December 23, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 11:58 PM, Andrew Duncan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; The guard statement rescues us from the pyramid of doom, and lets our code hug the left margin more... if the failure case is false or nil. I&#39;d like to guard against specific values in an enum, and get the same flattening of code flow. This generalizes Swift’s convenient handling of Optionals. (I have a hazy perception that this was mooted for 1.x, but can’t remember where I read it.)<br>&gt; <br>&gt; The goal is to make error-handling by result-returning smoother. (I need say no more about side-effect NSError** parameters.) Consider everyone’s favorite enum example: <br>&gt; <br>&gt;    enum Result { <br>&gt;    case .Fail(String)      // Error message<br>&gt;    case .Succeed(MyType)   // Something we use.<br>&gt;    }<br>&gt; <br>&gt; The Pitch (to avoid TL;DR)<br>&gt; <br>&gt; I&#39;d like to use something like this:<br>&gt; <br>&gt;    guard case let .Succeed(m) = returnsResult() else {<br>&gt;         return it<br>&gt;    }<br>&gt;    // Can safely use m, otherwise Result is passed back the call stack.<br></p><p>What about an enumeration with three cases? <br></p><p>For example:<br></p><p>enum Result {<br>case Success<br>case Failure<br>case Cancelled<br>}<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Guarding on enum values</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 23, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; What about an enumeration with three cases? <br>&gt; <br>&gt; For example:<br>&gt; <br>&gt; enum Result {<br>&gt; case Success<br>&gt; case Failure<br>&gt; case Cancelled<br>&gt; }<br></p><p>What about it? The case permitted by the `guard` continues through the surrounding scope; the other cases are handled by the `else` block.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
