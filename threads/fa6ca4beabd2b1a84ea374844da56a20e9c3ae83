<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44a036cc421ee97534c54653a233db93?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Jānis Kiršteins</string> &lt;janis.kirsteins at gmail.com&gt;<p>May 25, 2016 at 02:00:00pm</p></header><div class="content"><p>Hello everyone,<br></p><p>Currently Swift only supports computed properties for each enum case.<br>If you want to somehow get static values with each case you would<br>probably do it like this:<br></p><p>enum Planet {<br>    case mercury<br>    case venus<br>    case earth<br>    case mars<br>    case jupiter<br>    case saturn<br>    case uranus<br>    case neptune<br></p><p>    var mass: Float {<br>        switch self {<br>        case .mercury: return 3.303e+23<br>        case .venus: return 4.869e+24<br>        case .earth: return 5.976e+24<br>        case .mars: return 6.421e+23<br>        case .jupiter: return 1.9e+27<br>        case .saturn: return 5.688e+26<br>        case .uranus: return 8.686e+25<br>        case .neptune: return 1.024e+26<br>        }<br>    }<br></p><p>    var radius: Float {<br>        switch self {<br>        case .mercury: return 2.4397e6<br>        case .venus: return 6.0518e6<br>        case .earth: return 6.37814e6<br>        case .mars: return 3.3972e6<br>        case .jupiter: return 7.1492e7<br>        case .saturn: return 6.0268e7<br>        case .uranus: return 2.5559e7<br>        case .neptune: return 2.4746e7<br>        }<br>    }<br>}<br></p><p>However I see two problems with this approach:<br></p><p>1. These value definitions are spread out and difficult to read and<br>maintain (especially if you have many computed properties for each<br>enum case);<br>2. These values are not static. They are computed each time property<br>is accessed. This can be a problem when value is expensive to create.<br></p><p>The proposed solution is to have single static initializer for each<br>enum case that initializes stored properties. For example,<br></p><p>enum Planet {<br>    var mass: Float<br>    var radius: Float<br></p><p>    static init(mass: Float, radius: Float) {<br>        self.mass = mass<br>        self.radius = radius<br>    }<br></p><p>    case mercury where (mass: 3.303e+23, radius: 2.4397e6)<br>    case venus where (mass: 4.869e+24, radius: 6.0518e6)<br>    case earth where (mass: 5.976e+24, radius: 6.37814e6)<br>    case mars where (mass: 6.421e+23, radius: 3.3972e6)<br>    case jupiter where (mass: 1.9e+27, radius: 7.1492e7)<br>    case saturn where (mass: 5.688e+26, radius: 6.0268e7)<br>    case uranus where (mass: 8.686e+25, radius: 2.5559e7)<br>    case neptune where (mass: 1.024e+26, radius: 2.4746e7)<br>}<br></p><p>This approach do not affect enums that have raw or associated values,<br>or custom enum initializers:<br></p><p>case A = &quot;A&quot; where (id: 0)<br></p><p>or<br></p><p>case B(Int, Int, Int) where (id: 0)<br></p><p>Benefits:<br>1. Less verbosity<br>2. Improved readability<br>3. Related values are closer to each other<br>4. Static values are not recomputed<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Enums with static stored properties foreach case</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 25, 2016 at 09:00:00am</p></header><div class="content"><p>Hi,<br></p><p>Couldn&#39;t this be solved by using tuples? If not because the syntax is not allowed I think this would be more coherent to do it using current syntax.<br></p><p>enum Planet : (mass: Float, radius: Float) {<br>    case mercury = (mass: 3.303e+23, radius: 2.4397e6)<br>    case venus = (mass: 4.869e+24, radius: 6.0518e6)<br>    case earth = (mass: 5.976e+24, radius: 6.37814e6)<br>    case mars = (mass: 6.421e+23, radius: 3.3972e6)<br>    case jupiter = (mass: 1.9e+27, radius: 7.1492e7)<br>    case saturn = (mass: 5.688e+26, radius: 6.0268e7)<br>    case uranus = (mass: 8.686e+25, radius: 2.5559e7)<br>    case neptune = (mass: 1.024e+26, radius: 2.4746e7)<br>}<br></p><p><br>-----Original Message-----<br>From: &quot;Jānis Kiršteins via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Sent: ‎25/‎05/‎2016 08:58 AM<br>To: &quot;swift-evolution at swift.org&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: [swift-evolution] [Proposal] Enums with static stored properties foreach case<br></p><p>Hello everyone,<br></p><p>Currently Swift only supports computed properties for each enum case.<br>If you want to somehow get static values with each case you would<br>probably do it like this:<br></p><p>enum Planet {<br>    case mercury<br>    case venus<br>    case earth<br>    case mars<br>    case jupiter<br>    case saturn<br>    case uranus<br>    case neptune<br></p><p>    var mass: Float {<br>        switch self {<br>        case .mercury: return 3.303e+23<br>        case .venus: return 4.869e+24<br>        case .earth: return 5.976e+24<br>        case .mars: return 6.421e+23<br>        case .jupiter: return 1.9e+27<br>        case .saturn: return 5.688e+26<br>        case .uranus: return 8.686e+25<br>        case .neptune: return 1.024e+26<br>        }<br>    }<br></p><p>    var radius: Float {<br>        switch self {<br>        case .mercury: return 2.4397e6<br>        case .venus: return 6.0518e6<br>        case .earth: return 6.37814e6<br>        case .mars: return 3.3972e6<br>        case .jupiter: return 7.1492e7<br>        case .saturn: return 6.0268e7<br>        case .uranus: return 2.5559e7<br>        case .neptune: return 2.4746e7<br>        }<br>    }<br>}<br></p><p>However I see two problems with this approach:<br></p><p>1. These value definitions are spread out and difficult to read and<br>maintain (especially if you have many computed properties for each<br>enum case);<br>2. These values are not static. They are computed each time property<br>is accessed. This can be a problem when value is expensive to create.<br></p><p>The proposed solution is to have single static initializer for each<br>enum case that initializes stored properties. For example,<br></p><p>enum Planet {<br>    var mass: Float<br>    var radius: Float<br></p><p>    static init(mass: Float, radius: Float) {<br>        self.mass = mass<br>        self.radius = radius<br>    }<br></p><p>    case mercury where (mass: 3.303e+23, radius: 2.4397e6)<br>    case venus where (mass: 4.869e+24, radius: 6.0518e6)<br>    case earth where (mass: 5.976e+24, radius: 6.37814e6)<br>    case mars where (mass: 6.421e+23, radius: 3.3972e6)<br>    case jupiter where (mass: 1.9e+27, radius: 7.1492e7)<br>    case saturn where (mass: 5.688e+26, radius: 6.0268e7)<br>    case uranus where (mass: 8.686e+25, radius: 2.5559e7)<br>    case neptune where (mass: 1.024e+26, radius: 2.4746e7)<br>}<br></p><p>This approach do not affect enums that have raw or associated values,<br>or custom enum initializers:<br></p><p>case A = &quot;A&quot; where (id: 0)<br></p><p>or<br></p><p>case B(Int, Int, Int) where (id: 0)<br></p><p>Benefits:<br>1. Less verbosity<br>2. Improved readability<br>3. Related values are closer to each other<br>4. Static values are not recomputed<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/0be7437a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44a036cc421ee97534c54653a233db93?s=50"></div><header><strong>[Proposal] Enums with static stored properties foreach case</strong> from <string>Jānis Kiršteins</string> &lt;janis.kirsteins at gmail.com&gt;<p>May 25, 2016 at 10:00:00pm</p></header><div class="content"><p>That would replace current enum raw value functionality and I see two<br>problems with that.<br></p><p>1. A lot of breaking changes<br>2. Raw values currently are unique values among all cases. That makes<br>a possibility that enums can be easily serialized/deserialized to<br>formats like JSON, property lists, etc. In &quot;case mercury = (mass:<br>3.303e+23, radius: 2.4397e6)&quot; neither mass nor radius is unique value<br>(it is possible that two different planets could have the same mass as<br>radius).<br></p><p><br></p><p>On Wed, May 25, 2016 at 3:37 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; Hi,<br>&gt;<br>&gt; Couldn&#39;t this be solved by using tuples? If not because the syntax is not<br>&gt; allowed I think this would be more coherent to do it using current syntax.<br>&gt;<br>&gt; enum Planet : (mass: Float, radius: Float) {<br>&gt;     case mercury = (mass: 3.303e+23, radius: 2.4397e6)<br>&gt;     case venus = (mass: 4.869e+24, radius: 6.0518e6)<br>&gt;     case earth = (mass: 5.976e+24, radius: 6.37814e6)<br>&gt;     case mars = (mass: 6.421e+23, radius: 3.3972e6)<br>&gt;     case jupiter = (mass: 1.9e+27, radius: 7.1492e7)<br>&gt;     case saturn = (mass: 5.688e+26, radius: 6.0268e7)<br>&gt;     case uranus = (mass: 8.686e+25, radius: 2.5559e7)<br>&gt;     case neptune = (mass: 1.024e+26, radius: 2.4746e7)<br>&gt; }<br>&gt; ________________________________<br>&gt; From: Jānis Kiršteins via swift-evolution<br>&gt; Sent: ‎25/‎05/‎2016 08:58 AM<br>&gt; To: swift-evolution at swift.org<br>&gt; Subject: [swift-evolution] [Proposal] Enums with static stored properties<br>&gt; foreach case<br>&gt;<br>&gt; Hello everyone,<br>&gt;<br>&gt; Currently Swift only supports computed properties for each enum case.<br>&gt; If you want to somehow get static values with each case you would<br>&gt; probably do it like this:<br>&gt;<br>&gt; enum Planet {<br>&gt;     case mercury<br>&gt;     case venus<br>&gt;     case earth<br>&gt;     case mars<br>&gt;     case jupiter<br>&gt;     case saturn<br>&gt;     case uranus<br>&gt;     case neptune<br>&gt;<br>&gt;     var mass: Float {<br>&gt;         switch self {<br>&gt;         case .mercury: return 3.303e+23<br>&gt;         case .venus: return 4.869e+24<br>&gt;         case .earth: return 5.976e+24<br>&gt;         case .mars: return 6.421e+23<br>&gt;         case .jupiter: return 1.9e+27<br>&gt;         case .saturn: return 5.688e+26<br>&gt;         case .uranus: return 8.686e+25<br>&gt;         case .neptune: return 1.024e+26<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     var radius: Float {<br>&gt;         switch self {<br>&gt;         case .mercury: return 2.4397e6<br>&gt;         case .venus: return 6.0518e6<br>&gt;         case .earth: return 6.37814e6<br>&gt;         case .mars: return 3.3972e6<br>&gt;         case .jupiter: return 7.1492e7<br>&gt;         case .saturn: return 6.0268e7<br>&gt;         case .uranus: return 2.5559e7<br>&gt;         case .neptune: return 2.4746e7<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; However I see two problems with this approach:<br>&gt;<br>&gt; 1. These value definitions are spread out and difficult to read and<br>&gt; maintain (especially if you have many computed properties for each<br>&gt; enum case);<br>&gt; 2. These values are not static. They are computed each time property<br>&gt; is accessed. This can be a problem when value is expensive to create.<br>&gt;<br>&gt; The proposed solution is to have single static initializer for each<br>&gt; enum case that initializes stored properties. For example,<br>&gt;<br>&gt; enum Planet {<br>&gt;     var mass: Float<br>&gt;     var radius: Float<br>&gt;<br>&gt;     static init(mass: Float, radius: Float) {<br>&gt;         self.mass = mass<br>&gt;         self.radius = radius<br>&gt;     }<br>&gt;<br>&gt;     case mercury where (mass: 3.303e+23, radius: 2.4397e6)<br>&gt;     case venus where (mass: 4.869e+24, radius: 6.0518e6)<br>&gt;     case earth where (mass: 5.976e+24, radius: 6.37814e6)<br>&gt;     case mars where (mass: 6.421e+23, radius: 3.3972e6)<br>&gt;     case jupiter where (mass: 1.9e+27, radius: 7.1492e7)<br>&gt;     case saturn where (mass: 5.688e+26, radius: 6.0268e7)<br>&gt;     case uranus where (mass: 8.686e+25, radius: 2.5559e7)<br>&gt;     case neptune where (mass: 1.024e+26, radius: 2.4746e7)<br>&gt; }<br>&gt;<br>&gt; This approach do not affect enums that have raw or associated values,<br>&gt; or custom enum initializers:<br>&gt;<br>&gt; case A = &quot;A&quot; where (id: 0)<br>&gt;<br>&gt; or<br>&gt;<br>&gt; case B(Int, Int, Int) where (id: 0)<br>&gt;<br>&gt; Benefits:<br>&gt; 1. Less verbosity<br>&gt; 2. Improved readability<br>&gt; 3. Related values are closer to each other<br>&gt; 4. Static values are not recomputed<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Enums with static stored propertiesforeach case</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 25, 2016 at 05:00:00pm</p></header><div class="content"><p>But that&#39;s an issue related to how serialising JSON works. Should the API serialise the name of the value and not the associated values, it should work fine. Should we have anything like annotations in Swift to describe how we wanted that output we&#39;d have no problems.<br></p><p>About breaking things I wouldn&#39;t worry as Swift 3 is going to break a lot by itself anyway.<br></p><p><br></p><p>-----Original Message-----<br>From: &quot;Jānis Kiršteins&quot; &lt;janis.kirsteins at gmail.com&gt;<br>Sent: ‎25/‎05/‎2016 04:50 PM<br>To: &quot;Leonardo Pessoa&quot; &lt;me at lmpessoa.com&gt;<br>Cc: &quot;swift-evolution at swift.org&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Proposal] Enums with static stored propertiesforeach case<br></p><p>That would replace current enum raw value functionality and I see two<br>problems with that.<br></p><p>1. A lot of breaking changes<br>2. Raw values currently are unique values among all cases. That makes<br>a possibility that enums can be easily serialized/deserialized to<br>formats like JSON, property lists, etc. In &quot;case mercury = (mass:<br>3.303e+23, radius: 2.4397e6)&quot; neither mass nor radius is unique value<br>(it is possible that two different planets could have the same mass as<br>radius).<br></p><p><br></p><p>On Wed, May 25, 2016 at 3:37 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; Hi,<br>&gt;<br>&gt; Couldn&#39;t this be solved by using tuples? If not because the syntax is not<br>&gt; allowed I think this would be more coherent to do it using current syntax.<br>&gt;<br>&gt; enum Planet : (mass: Float, radius: Float) {<br>&gt;     case mercury = (mass: 3.303e+23, radius: 2.4397e6)<br>&gt;     case venus = (mass: 4.869e+24, radius: 6.0518e6)<br>&gt;     case earth = (mass: 5.976e+24, radius: 6.37814e6)<br>&gt;     case mars = (mass: 6.421e+23, radius: 3.3972e6)<br>&gt;     case jupiter = (mass: 1.9e+27, radius: 7.1492e7)<br>&gt;     case saturn = (mass: 5.688e+26, radius: 6.0268e7)<br>&gt;     case uranus = (mass: 8.686e+25, radius: 2.5559e7)<br>&gt;     case neptune = (mass: 1.024e+26, radius: 2.4746e7)<br>&gt; }<br>&gt; ________________________________<br>&gt; From: Jānis Kiršteins via swift-evolution<br>&gt; Sent: ‎25/‎05/‎2016 08:58 AM<br>&gt; To: swift-evolution at swift.org<br>&gt; Subject: [swift-evolution] [Proposal] Enums with static stored properties<br>&gt; foreach case<br>&gt;<br>&gt; Hello everyone,<br>&gt;<br>&gt; Currently Swift only supports computed properties for each enum case.<br>&gt; If you want to somehow get static values with each case you would<br>&gt; probably do it like this:<br>&gt;<br>&gt; enum Planet {<br>&gt;     case mercury<br>&gt;     case venus<br>&gt;     case earth<br>&gt;     case mars<br>&gt;     case jupiter<br>&gt;     case saturn<br>&gt;     case uranus<br>&gt;     case neptune<br>&gt;<br>&gt;     var mass: Float {<br>&gt;         switch self {<br>&gt;         case .mercury: return 3.303e+23<br>&gt;         case .venus: return 4.869e+24<br>&gt;         case .earth: return 5.976e+24<br>&gt;         case .mars: return 6.421e+23<br>&gt;         case .jupiter: return 1.9e+27<br>&gt;         case .saturn: return 5.688e+26<br>&gt;         case .uranus: return 8.686e+25<br>&gt;         case .neptune: return 1.024e+26<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     var radius: Float {<br>&gt;         switch self {<br>&gt;         case .mercury: return 2.4397e6<br>&gt;         case .venus: return 6.0518e6<br>&gt;         case .earth: return 6.37814e6<br>&gt;         case .mars: return 3.3972e6<br>&gt;         case .jupiter: return 7.1492e7<br>&gt;         case .saturn: return 6.0268e7<br>&gt;         case .uranus: return 2.5559e7<br>&gt;         case .neptune: return 2.4746e7<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; However I see two problems with this approach:<br>&gt;<br>&gt; 1. These value definitions are spread out and difficult to read and<br>&gt; maintain (especially if you have many computed properties for each<br>&gt; enum case);<br>&gt; 2. These values are not static. They are computed each time property<br>&gt; is accessed. This can be a problem when value is expensive to create.<br>&gt;<br>&gt; The proposed solution is to have single static initializer for each<br>&gt; enum case that initializes stored properties. For example,<br>&gt;<br>&gt; enum Planet {<br>&gt;     var mass: Float<br>&gt;     var radius: Float<br>&gt;<br>&gt;     static init(mass: Float, radius: Float) {<br>&gt;         self.mass = mass<br>&gt;         self.radius = radius<br>&gt;     }<br>&gt;<br>&gt;     case mercury where (mass: 3.303e+23, radius: 2.4397e6)<br>&gt;     case venus where (mass: 4.869e+24, radius: 6.0518e6)<br>&gt;     case earth where (mass: 5.976e+24, radius: 6.37814e6)<br>&gt;     case mars where (mass: 6.421e+23, radius: 3.3972e6)<br>&gt;     case jupiter where (mass: 1.9e+27, radius: 7.1492e7)<br>&gt;     case saturn where (mass: 5.688e+26, radius: 6.0268e7)<br>&gt;     case uranus where (mass: 8.686e+25, radius: 2.5559e7)<br>&gt;     case neptune where (mass: 1.024e+26, radius: 2.4746e7)<br>&gt; }<br>&gt;<br>&gt; This approach do not affect enums that have raw or associated values,<br>&gt; or custom enum initializers:<br>&gt;<br>&gt; case A = &quot;A&quot; where (id: 0)<br>&gt;<br>&gt; or<br>&gt;<br>&gt; case B(Int, Int, Int) where (id: 0)<br>&gt;<br>&gt; Benefits:<br>&gt; 1. Less verbosity<br>&gt; 2. Improved readability<br>&gt; 3. Related values are closer to each other<br>&gt; 4. Static values are not recomputed<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/1de0e3a0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Proposal] Enums with static stored properties foreach case</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 26, 2016 at 11:00:00am</p></header><div class="content"><p>Yes, I don’t think it would work with a raw value behaviour. You want it to compile down to the same underlying code as the first example, without having to write lots of switch statements.<br></p><p>Another syntax I could imagine is:<br></p><p>enum Planet {<br>  var mass: Float { get }<br>  var radius: Float { get }<br></p><p>  case mercury [<br>    mass: 3.303e+23,<br>    radius: 2.4397e6<br>  ]<br>  case venus [<br>    mass: 4.869e+24,<br>    radius: 6.0518e6<br>  ]<br>  case earth [<br>    mass: 5.976e+24,<br>    radius: 6.37814e6<br>  ]<br>  ...<br>}<br></p><p><br>You couldn’t have an initializer, as enums only have storage when they have associated values, which these do not. ‘where’ is used for pattern matching, not declaring as far as I know, so that’s why I suggest this other way.<br></p><p>Patrick<br></p><p>&gt; On 26 May 2016, at 5:50 AM, Jānis Kiršteins via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That would replace current enum raw value functionality and I see two<br>&gt; problems with that.<br>&gt; <br>&gt; 1. A lot of breaking changes<br>&gt; 2. Raw values currently are unique values among all cases. That makes<br>&gt; a possibility that enums can be easily serialized/deserialized to<br>&gt; formats like JSON, property lists, etc. In &quot;case mercury = (mass:<br>&gt; 3.303e+23, radius: 2.4397e6)&quot; neither mass nor radius is unique value<br>&gt; (it is possible that two different planets could have the same mass as<br>&gt; radius).<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Wed, May 25, 2016 at 3:37 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; Couldn&#39;t this be solved by using tuples? If not because the syntax is not<br>&gt;&gt; allowed I think this would be more coherent to do it using current syntax.<br>&gt;&gt; <br>&gt;&gt; enum Planet : (mass: Float, radius: Float) {<br>&gt;&gt;    case mercury = (mass: 3.303e+23, radius: 2.4397e6)<br>&gt;&gt;    case venus = (mass: 4.869e+24, radius: 6.0518e6)<br>&gt;&gt;    case earth = (mass: 5.976e+24, radius: 6.37814e6)<br>&gt;&gt;    case mars = (mass: 6.421e+23, radius: 3.3972e6)<br>&gt;&gt;    case jupiter = (mass: 1.9e+27, radius: 7.1492e7)<br>&gt;&gt;    case saturn = (mass: 5.688e+26, radius: 6.0268e7)<br>&gt;&gt;    case uranus = (mass: 8.686e+25, radius: 2.5559e7)<br>&gt;&gt;    case neptune = (mass: 1.024e+26, radius: 2.4746e7)<br>&gt;&gt; }<br>&gt;&gt; ________________________________<br>&gt;&gt; From: Jānis Kiršteins via swift-evolution<br>&gt;&gt; Sent: ‎25/‎05/‎2016 08:58 AM<br>&gt;&gt; To: swift-evolution at swift.org<br>&gt;&gt; Subject: [swift-evolution] [Proposal] Enums with static stored properties<br>&gt;&gt; foreach case<br>&gt;&gt; <br>&gt;&gt; Hello everyone,<br>&gt;&gt; <br>&gt;&gt; Currently Swift only supports computed properties for each enum case.<br>&gt;&gt; If you want to somehow get static values with each case you would<br>&gt;&gt; probably do it like this:<br>&gt;&gt; <br>&gt;&gt; enum Planet {<br>&gt;&gt;    case mercury<br>&gt;&gt;    case venus<br>&gt;&gt;    case earth<br>&gt;&gt;    case mars<br>&gt;&gt;    case jupiter<br>&gt;&gt;    case saturn<br>&gt;&gt;    case uranus<br>&gt;&gt;    case neptune<br>&gt;&gt; <br>&gt;&gt;    var mass: Float {<br>&gt;&gt;        switch self {<br>&gt;&gt;        case .mercury: return 3.303e+23<br>&gt;&gt;        case .venus: return 4.869e+24<br>&gt;&gt;        case .earth: return 5.976e+24<br>&gt;&gt;        case .mars: return 6.421e+23<br>&gt;&gt;        case .jupiter: return 1.9e+27<br>&gt;&gt;        case .saturn: return 5.688e+26<br>&gt;&gt;        case .uranus: return 8.686e+25<br>&gt;&gt;        case .neptune: return 1.024e+26<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    var radius: Float {<br>&gt;&gt;        switch self {<br>&gt;&gt;        case .mercury: return 2.4397e6<br>&gt;&gt;        case .venus: return 6.0518e6<br>&gt;&gt;        case .earth: return 6.37814e6<br>&gt;&gt;        case .mars: return 3.3972e6<br>&gt;&gt;        case .jupiter: return 7.1492e7<br>&gt;&gt;        case .saturn: return 6.0268e7<br>&gt;&gt;        case .uranus: return 2.5559e7<br>&gt;&gt;        case .neptune: return 2.4746e7<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; However I see two problems with this approach:<br>&gt;&gt; <br>&gt;&gt; 1. These value definitions are spread out and difficult to read and<br>&gt;&gt; maintain (especially if you have many computed properties for each<br>&gt;&gt; enum case);<br>&gt;&gt; 2. These values are not static. They are computed each time property<br>&gt;&gt; is accessed. This can be a problem when value is expensive to create.<br>&gt;&gt; <br>&gt;&gt; The proposed solution is to have single static initializer for each<br>&gt;&gt; enum case that initializes stored properties. For example,<br>&gt;&gt; <br>&gt;&gt; enum Planet {<br>&gt;&gt;    var mass: Float<br>&gt;&gt;    var radius: Float<br>&gt;&gt; <br>&gt;&gt;    static init(mass: Float, radius: Float) {<br>&gt;&gt;        self.mass = mass<br>&gt;&gt;        self.radius = radius<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    case mercury where (mass: 3.303e+23, radius: 2.4397e6)<br>&gt;&gt;    case venus where (mass: 4.869e+24, radius: 6.0518e6)<br>&gt;&gt;    case earth where (mass: 5.976e+24, radius: 6.37814e6)<br>&gt;&gt;    case mars where (mass: 6.421e+23, radius: 3.3972e6)<br>&gt;&gt;    case jupiter where (mass: 1.9e+27, radius: 7.1492e7)<br>&gt;&gt;    case saturn where (mass: 5.688e+26, radius: 6.0268e7)<br>&gt;&gt;    case uranus where (mass: 8.686e+25, radius: 2.5559e7)<br>&gt;&gt;    case neptune where (mass: 1.024e+26, radius: 2.4746e7)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This approach do not affect enums that have raw or associated values,<br>&gt;&gt; or custom enum initializers:<br>&gt;&gt; <br>&gt;&gt; case A = &quot;A&quot; where (id: 0)<br>&gt;&gt; <br>&gt;&gt; or<br>&gt;&gt; <br>&gt;&gt; case B(Int, Int, Int) where (id: 0)<br>&gt;&gt; <br>&gt;&gt; Benefits:<br>&gt;&gt; 1. Less verbosity<br>&gt;&gt; 2. Improved readability<br>&gt;&gt; 3. Related values are closer to each other<br>&gt;&gt; 4. Static values are not recomputed<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Enums with static stored propertiesforeach case</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 25, 2016 at 11:00:00pm</p></header><div class="content"><p>I&#39;d still go with tuple syntax as it feels more like a natural extension to current enum syntax and does not introduce new elements to the syntax of enums (other than add tuples as a possible enum value type) thus being simpler and faster to implement and learn than a new syntax built specifically for this kind of construction.<br></p><p>As I mentioned before, the issue with JSON and other engines trying to record the raw value instead of the enum seems to me as a wrong implementation choice of the engine. Previous to Swift enums I&#39;ve always seen enum cases the same as constants and any additional values they&#39;d hold are associated with that constant and not persisted. This may also be a thing from the company I work for today that choses to store the names of the enum cases (as strings) in databases and any values associated with them are recovered from the enum case constant. Of course the language I work with supports finding the enum value by its name, which it seems Swift doesn&#39;t.<br></p><p><br></p><p>-----Original Message-----<br>From: &quot;Patrick Smith&quot; &lt;pgwsmith at gmail.com&gt;<br>Sent: ‎25/‎05/‎2016 10:20 PM<br>To: &quot;Jānis Kiršteins&quot; &lt;janis.kirsteins at gmail.com&gt;<br>Cc: &quot;Leonardo Pessoa&quot; &lt;me at lmpessoa.com&gt;; &quot;swift-evolution at swift.org&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Proposal] Enums with static stored propertiesforeach case<br></p><p>Yes, I don’t think it would work with a raw value behaviour. You want it to compile down to the same underlying code as the first example, without having to write lots of switch statements.<br></p><p>Another syntax I could imagine is:<br></p><p>enum Planet {<br>  var mass: Float { get }<br>  var radius: Float { get }<br></p><p>  case mercury [<br>    mass: 3.303e+23,<br>    radius: 2.4397e6<br>  ]<br>  case venus [<br>    mass: 4.869e+24,<br>    radius: 6.0518e6<br>  ]<br>  case earth [<br>    mass: 5.976e+24,<br>    radius: 6.37814e6<br>  ]<br>  ...<br>}<br></p><p><br>You couldn’t have an initializer, as enums only have storage when they have associated values, which these do not. ‘where’ is used for pattern matching, not declaring as far as I know, so that’s why I suggest this other way.<br></p><p>Patrick<br></p><p>&gt; On 26 May 2016, at 5:50 AM, Jānis Kiršteins via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That would replace current enum raw value functionality and I see two<br>&gt; problems with that.<br>&gt; <br>&gt; 1. A lot of breaking changes<br>&gt; 2. Raw values currently are unique values among all cases. That makes<br>&gt; a possibility that enums can be easily serialized/deserialized to<br>&gt; formats like JSON, property lists, etc. In &quot;case mercury = (mass:<br>&gt; 3.303e+23, radius: 2.4397e6)&quot; neither mass nor radius is unique value<br>&gt; (it is possible that two different planets could have the same mass as<br>&gt; radius).<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Wed, May 25, 2016 at 3:37 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; Couldn&#39;t this be solved by using tuples? If not because the syntax is not<br>&gt;&gt; allowed I think this would be more coherent to do it using current syntax.<br>&gt;&gt; <br>&gt;&gt; enum Planet : (mass: Float, radius: Float) {<br>&gt;&gt;    case mercury = (mass: 3.303e+23, radius: 2.4397e6)<br>&gt;&gt;    case venus = (mass: 4.869e+24, radius: 6.0518e6)<br>&gt;&gt;    case earth = (mass: 5.976e+24, radius: 6.37814e6)<br>&gt;&gt;    case mars = (mass: 6.421e+23, radius: 3.3972e6)<br>&gt;&gt;    case jupiter = (mass: 1.9e+27, radius: 7.1492e7)<br>&gt;&gt;    case saturn = (mass: 5.688e+26, radius: 6.0268e7)<br>&gt;&gt;    case uranus = (mass: 8.686e+25, radius: 2.5559e7)<br>&gt;&gt;    case neptune = (mass: 1.024e+26, radius: 2.4746e7)<br>&gt;&gt; }<br>&gt;&gt; ________________________________<br>&gt;&gt; From: Jānis Kiršteins via swift-evolution<br>&gt;&gt; Sent: ‎25/‎05/‎2016 08:58 AM<br>&gt;&gt; To: swift-evolution at swift.org<br>&gt;&gt; Subject: [swift-evolution] [Proposal] Enums with static stored properties<br>&gt;&gt; foreach case<br>&gt;&gt; <br>&gt;&gt; Hello everyone,<br>&gt;&gt; <br>&gt;&gt; Currently Swift only supports computed properties for each enum case.<br>&gt;&gt; If you want to somehow get static values with each case you would<br>&gt;&gt; probably do it like this:<br>&gt;&gt; <br>&gt;&gt; enum Planet {<br>&gt;&gt;    case mercury<br>&gt;&gt;    case venus<br>&gt;&gt;    case earth<br>&gt;&gt;    case mars<br>&gt;&gt;    case jupiter<br>&gt;&gt;    case saturn<br>&gt;&gt;    case uranus<br>&gt;&gt;    case neptune<br>&gt;&gt; <br>&gt;&gt;    var mass: Float {<br>&gt;&gt;        switch self {<br>&gt;&gt;        case .mercury: return 3.303e+23<br>&gt;&gt;        case .venus: return 4.869e+24<br>&gt;&gt;        case .earth: return 5.976e+24<br>&gt;&gt;        case .mars: return 6.421e+23<br>&gt;&gt;        case .jupiter: return 1.9e+27<br>&gt;&gt;        case .saturn: return 5.688e+26<br>&gt;&gt;        case .uranus: return 8.686e+25<br>&gt;&gt;        case .neptune: return 1.024e+26<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    var radius: Float {<br>&gt;&gt;        switch self {<br>&gt;&gt;        case .mercury: return 2.4397e6<br>&gt;&gt;        case .venus: return 6.0518e6<br>&gt;&gt;        case .earth: return 6.37814e6<br>&gt;&gt;        case .mars: return 3.3972e6<br>&gt;&gt;        case .jupiter: return 7.1492e7<br>&gt;&gt;        case .saturn: return 6.0268e7<br>&gt;&gt;        case .uranus: return 2.5559e7<br>&gt;&gt;        case .neptune: return 2.4746e7<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; However I see two problems with this approach:<br>&gt;&gt; <br>&gt;&gt; 1. These value definitions are spread out and difficult to read and<br>&gt;&gt; maintain (especially if you have many computed properties for each<br>&gt;&gt; enum case);<br>&gt;&gt; 2. These values are not static. They are computed each time property<br>&gt;&gt; is accessed. This can be a problem when value is expensive to create.<br>&gt;&gt; <br>&gt;&gt; The proposed solution is to have single static initializer for each<br>&gt;&gt; enum case that initializes stored properties. For example,<br>&gt;&gt; <br>&gt;&gt; enum Planet {<br>&gt;&gt;    var mass: Float<br>&gt;&gt;    var radius: Float<br>&gt;&gt; <br>&gt;&gt;    static init(mass: Float, radius: Float) {<br>&gt;&gt;        self.mass = mass<br>&gt;&gt;        self.radius = radius<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    case mercury where (mass: 3.303e+23, radius: 2.4397e6)<br>&gt;&gt;    case venus where (mass: 4.869e+24, radius: 6.0518e6)<br>&gt;&gt;    case earth where (mass: 5.976e+24, radius: 6.37814e6)<br>&gt;&gt;    case mars where (mass: 6.421e+23, radius: 3.3972e6)<br>&gt;&gt;    case jupiter where (mass: 1.9e+27, radius: 7.1492e7)<br>&gt;&gt;    case saturn where (mass: 5.688e+26, radius: 6.0268e7)<br>&gt;&gt;    case uranus where (mass: 8.686e+25, radius: 2.5559e7)<br>&gt;&gt;    case neptune where (mass: 1.024e+26, radius: 2.4746e7)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This approach do not affect enums that have raw or associated values,<br>&gt;&gt; or custom enum initializers:<br>&gt;&gt; <br>&gt;&gt; case A = &quot;A&quot; where (id: 0)<br>&gt;&gt; <br>&gt;&gt; or<br>&gt;&gt; <br>&gt;&gt; case B(Int, Int, Int) where (id: 0)<br>&gt;&gt; <br>&gt;&gt; Benefits:<br>&gt;&gt; 1. Less verbosity<br>&gt;&gt; 2. Improved readability<br>&gt;&gt; 3. Related values are closer to each other<br>&gt;&gt; 4. Static values are not recomputed<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/90ca2e6f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Proposal] Enums with static stored propertiesforeach case</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 26, 2016 at 12:00:00pm</p></header><div class="content"><p>Yes, that would be a great behaviour, but that’s exactly how enums with raw values do not work. The enum cases transform to and from an external representable form, that’s why it is ‘RawRepresentable’. So in your example of tuples, that representable form would be the tuple values themselves.<br></p><p>I agree about having enum cases as strings is handy. For your described case it is best to use a String as the raw value type, and the derived values as calculated properties. It would be handy, as we are discussing, to declare those calculated properties in an easier manner, and I would’t mind if it used a tuple syntax. But it should’t be used as the underlying value, as this is the source of ‘truth’ for the enum.<br></p><p><br>&gt; On 26 May 2016, at 12:09 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; <br>&gt; I&#39;d still go with tuple syntax as it feels more like a natural extension to current enum syntax and does not introduce new elements to the syntax of enums (other than add tuples as a possible enum value type) thus being simpler and faster to implement and learn than a new syntax built specifically for this kind of construction.<br>&gt; <br>&gt; As I mentioned before, the issue with JSON and other engines trying to record the raw value instead of the enum seems to me as a wrong implementation choice of the engine. Previous to Swift enums I&#39;ve always seen enum cases the same as constants and any additional values they&#39;d hold are associated with that constant and not persisted. This may also be a thing from the company I work for today that choses to store the names of the enum cases (as strings) in databases and any values associated with them are recovered from the enum case constant. Of course the language I work with supports finding the enum value by its name, which it seems Swift doesn&#39;t.<br>&gt; <br>&gt; From: Patrick Smith &lt;mailto:pgwsmith at gmail.com&gt;<br>&gt; Sent: ‎25/‎05/‎2016 10:20 PM<br>&gt; To: Jānis Kiršteins &lt;mailto:janis.kirsteins at gmail.com&gt;<br>&gt; Cc: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Proposal] Enums with static stored propertiesforeach case<br>&gt; <br>&gt; Yes, I don’t think it would work with a raw value behaviour. You want it to compile down to the same underlying code as the first example, without having to write lots of switch statements.<br>&gt; <br>&gt; Another syntax I could imagine is:<br>&gt; <br>&gt; enum Planet {<br>&gt;   var mass: Float { get }<br>&gt;   var radius: Float { get }<br>&gt; <br>&gt;   case mercury [<br>&gt;     mass: 3.303e+23,<br>&gt;     radius: 2.4397e6<br>&gt;   ]<br>&gt;   case venus [<br>&gt;     mass: 4.869e+24,<br>&gt;     radius: 6.0518e6<br>&gt;   ]<br>&gt;   case earth [<br>&gt;     mass: 5.976e+24,<br>&gt;     radius: 6.37814e6<br>&gt;   ]<br>&gt;   ...<br>&gt; }<br>&gt; <br>&gt; <br>&gt; You couldn’t have an initializer, as enums only have storage when they have associated values, which these do not. ‘where’ is used for pattern matching, not declaring as far as I know, so that’s why I suggest this other way.<br>&gt; <br>&gt; Patrick<br>&gt; <br>&gt; &gt; On 26 May 2016, at 5:50 AM, Jānis Kiršteins via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; That would replace current enum raw value functionality and I see two<br>&gt; &gt; problems with that.<br>&gt; &gt; <br>&gt; &gt; 1. A lot of breaking changes<br>&gt; &gt; 2. Raw values currently are unique values among all cases. That makes<br>&gt; &gt; a possibility that enums can be easily serialized/deserialized to<br>&gt; &gt; formats like JSON, property lists, etc. In &quot;case mercury = (mass:<br>&gt; &gt; 3.303e+23, radius: 2.4397e6)&quot; neither mass nor radius is unique value<br>&gt; &gt; (it is possible that two different planets could have the same mass as<br>&gt; &gt; radius).<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; On Wed, May 25, 2016 at 3:37 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; &gt;&gt; Hi,<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Couldn&#39;t this be solved by using tuples? If not because the syntax is not<br>&gt; &gt;&gt; allowed I think this would be more coherent to do it using current syntax.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; enum Planet : (mass: Float, radius: Float) {<br>&gt; &gt;&gt;    case mercury = (mass: 3.303e+23, radius: 2.4397e6)<br>&gt; &gt;&gt;    case venus = (mass: 4.869e+24, radius: 6.0518e6)<br>&gt; &gt;&gt;    case earth = (mass: 5.976e+24, radius: 6.37814e6)<br>&gt; &gt;&gt;    case mars = (mass: 6.421e+23, radius: 3.3972e6)<br>&gt; &gt;&gt;    case jupiter = (mass: 1.9e+27, radius: 7.1492e7)<br>&gt; &gt;&gt;    case saturn = (mass: 5.688e+26, radius: 6.0268e7)<br>&gt; &gt;&gt;    case uranus = (mass: 8.686e+25, radius: 2.5559e7)<br>&gt; &gt;&gt;    case neptune = (mass: 1.024e+26, radius: 2.4746e7)<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; ________________________________<br>&gt; &gt;&gt; From: Jānis Kiršteins via swift-evolution<br>&gt; &gt;&gt; Sent: ‎25/‎05/‎2016 08:58 AM<br>&gt; &gt;&gt; To: swift-evolution at swift.org<br>&gt; &gt;&gt; Subject: [swift-evolution] [Proposal] Enums with static stored properties<br>&gt; &gt;&gt; foreach case<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Hello everyone,<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Currently Swift only supports computed properties for each enum case.<br>&gt; &gt;&gt; If you want to somehow get static values with each case you would<br>&gt; &gt;&gt; probably do it like this:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; enum Planet {<br>&gt; &gt;&gt;    case mercury<br>&gt; &gt;&gt;    case venus<br>&gt; &gt;&gt;    case earth<br>&gt; &gt;&gt;    case mars<br>&gt; &gt;&gt;    case jupiter<br>&gt; &gt;&gt;    case saturn<br>&gt; &gt;&gt;    case uranus<br>&gt; &gt;&gt;    case neptune<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;    var mass: Float {<br>&gt; &gt;&gt;        switch self {<br>&gt; &gt;&gt;        case .mercury: return 3.303e+23<br>&gt; &gt;&gt;        case .venus: return 4.869e+24<br>&gt; &gt;&gt;        case .earth: return 5.976e+24<br>&gt; &gt;&gt;        case .mars: return 6.421e+23<br>&gt; &gt;&gt;        case .jupiter: return 1.9e+27<br>&gt; &gt;&gt;        case .saturn: return 5.688e+26<br>&gt; &gt;&gt;        case .uranus: return 8.686e+25<br>&gt; &gt;&gt;        case .neptune: return 1.024e+26<br>&gt; &gt;&gt;        }<br>&gt; &gt;&gt;    }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;    var radius: Float {<br>&gt; &gt;&gt;        switch self {<br>&gt; &gt;&gt;        case .mercury: return 2.4397e6<br>&gt; &gt;&gt;        case .venus: return 6.0518e6<br>&gt; &gt;&gt;        case .earth: return 6.37814e6<br>&gt; &gt;&gt;        case .mars: return 3.3972e6<br>&gt; &gt;&gt;        case .jupiter: return 7.1492e7<br>&gt; &gt;&gt;        case .saturn: return 6.0268e7<br>&gt; &gt;&gt;        case .uranus: return 2.5559e7<br>&gt; &gt;&gt;        case .neptune: return 2.4746e7<br>&gt; &gt;&gt;        }<br>&gt; &gt;&gt;    }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; However I see two problems with this approach:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; 1. These value definitions are spread out and difficult to read and<br>&gt; &gt;&gt; maintain (especially if you have many computed properties for each<br>&gt; &gt;&gt; enum case);<br>&gt; &gt;&gt; 2. These values are not static. They are computed each time property<br>&gt; &gt;&gt; is accessed. This can be a problem when value is expensive to create.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; The proposed solution is to have single static initializer for each<br>&gt; &gt;&gt; enum case that initializes stored properties. For example,<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; enum Planet {<br>&gt; &gt;&gt;    var mass: Float<br>&gt; &gt;&gt;    var radius: Float<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;    static init(mass: Float, radius: Float) {<br>&gt; &gt;&gt;        self.mass = mass<br>&gt; &gt;&gt;        self.radius = radius<br>&gt; &gt;&gt;    }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;    case mercury where (mass: 3.303e+23, radius: 2.4397e6)<br>&gt; &gt;&gt;    case venus where (mass: 4.869e+24, radius: 6.0518e6)<br>&gt; &gt;&gt;    case earth where (mass: 5.976e+24, radius: 6.37814e6)<br>&gt; &gt;&gt;    case mars where (mass: 6.421e+23, radius: 3.3972e6)<br>&gt; &gt;&gt;    case jupiter where (mass: 1.9e+27, radius: 7.1492e7)<br>&gt; &gt;&gt;    case saturn where (mass: 5.688e+26, radius: 6.0268e7)<br>&gt; &gt;&gt;    case uranus where (mass: 8.686e+25, radius: 2.5559e7)<br>&gt; &gt;&gt;    case neptune where (mass: 1.024e+26, radius: 2.4746e7)<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; This approach do not affect enums that have raw or associated values,<br>&gt; &gt;&gt; or custom enum initializers:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; case A = &quot;A&quot; where (id: 0)<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; or<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; case B(Int, Int, Int) where (id: 0)<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Benefits:<br>&gt; &gt;&gt; 1. Less verbosity<br>&gt; &gt;&gt; 2. Improved readability<br>&gt; &gt;&gt; 3. Related values are closer to each other<br>&gt; &gt;&gt; 4. Static values are not recomputed<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/fa9f72d8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Enums with static stored properties foreach case</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May 25, 2016 at 10:00:00pm</p></header><div class="content"><p>On May 25, 2016, at 7:37 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; Couldn&#39;t this be solved by using tuples? If not because the syntax is not allowed I think this would be more coherent to do it using current syntax.<br>&gt; <br>&gt; enum Planet : (mass: Float, radius: Float) {<br>&gt;     case mercury = (mass: 3.303e+23, radius: 2.4397e6)<br>&gt;     case venus = (mass: 4.869e+24, radius: 6.0518e6)<br>&gt;     case earth = (mass: 5.976e+24, radius: 6.37814e6)<br>&gt;     case mars = (mass: 6.421e+23, radius: 3.3972e6)<br>&gt;     case jupiter = (mass: 1.9e+27, radius: 7.1492e7)<br>&gt;     case saturn = (mass: 5.688e+26, radius: 6.0268e7)<br>&gt;     case uranus = (mass: 8.686e+25, radius: 2.5559e7)<br>&gt;     case neptune = (mass: 1.024e+26, radius: 2.4746e7)<br>&gt; }<br></p><p><br>This would be my preferred solution… AFAIK, the only reason we can’t do it now is that Swift currently requires RawValue be an integer, floating-point value, or string. I don’t know why the language has this restriction, so I can’t comment on how hard it would be to change.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/19ac64d4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Proposal] Enums with static stored properties foreach case</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>May 25, 2016 at 08:00:00pm</p></header><div class="content"><p>On Wed, May 25, 2016 at 8:15 PM, David Sweeris via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On May 25, 2016, at 7:37 AM, Leonardo Pessoa via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Hi,<br>&gt;<br>&gt; Couldn&#39;t this be solved by using tuples? If not because the syntax is not<br>&gt; allowed I think this would be more coherent to do it using current syntax.<br>&gt;<br>&gt; enum Planet : (mass: Float, radius: Float) {<br>&gt;     case mercury = (mass: 3.303e+23, radius: 2.4397e6)<br>&gt;     case venus = (mass: 4.869e+24, radius: 6.0518e6)<br>&gt;     case earth = (mass: 5.976e+24, radius: 6.37814e6)<br>&gt;     case mars = (mass: 6.421e+23, radius: 3.3972e6)<br>&gt;     case jupiter = (mass: 1.9e+27, radius: 7.1492e7)<br>&gt;     case saturn = (mass: 5.688e+26, radius: 6.0268e7)<br>&gt;     case uranus = (mass: 8.686e+25, radius: 2.5559e7)<br>&gt;     case neptune = (mass: 1.024e+26, radius: 2.4746e7)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This would be my preferred solution… AFAIK, the only reason we can’t do it<br>&gt; now is that Swift currently requires RawValue be an integer, floating-point<br>&gt; value, or string. I don’t know why the language has this restriction, so I<br>&gt; can’t comment on how hard it would be to change.<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br></p><p>Except you&#39;d have to write Planet.mercury.rawValue.mass, rather than<br>Planet.mercury.mass.<br></p><p>This could be one or two proposals: allow enums with tuple RawValues, and<br>allow `TupleName.caseName.propertyName` to access a tuple element without<br>going through .rawValue.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/fc14558a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Enums with static stored properties foreach case</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May 25, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On May 25, 2016, at 10:27 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, May 25, 2016 at 8:15 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; On May 25, 2016, at 7:37 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; Couldn&#39;t this be solved by using tuples? If not because the syntax is not allowed I think this would be more coherent to do it using current syntax.<br>&gt;&gt; <br>&gt;&gt; enum Planet : (mass: Float, radius: Float) {<br>&gt;&gt;     case mercury = (mass: 3.303e+23, radius: 2.4397e6)<br>&gt;&gt;     case venus = (mass: 4.869e+24, radius: 6.0518e6)<br>&gt;&gt;     case earth = (mass: 5.976e+24, radius: 6.37814e6)<br>&gt;&gt;     case mars = (mass: 6.421e+23, radius: 3.3972e6)<br>&gt;&gt;     case jupiter = (mass: 1.9e+27, radius: 7.1492e7)<br>&gt;&gt;     case saturn = (mass: 5.688e+26, radius: 6.0268e7)<br>&gt;&gt;     case uranus = (mass: 8.686e+25, radius: 2.5559e7)<br>&gt;&gt;     case neptune = (mass: 1.024e+26, radius: 2.4746e7)<br>&gt;&gt; }<br>&gt; <br>&gt; <br>&gt; This would be my preferred solution… AFAIK, the only reason we can’t do it now is that Swift currently requires RawValue be an integer, floating-point value, or string. I don’t know why the language has this restriction, so I can’t comment on how hard it would be to change.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt; Except you&#39;d have to write Planet.mercury.rawValue.mass, rather than Planet.mercury.mass.<br>&gt; <br>&gt; This could be one or two proposals: allow enums with tuple RawValues, and allow `TupleName.caseName.propertyName` to access a tuple element without going through .rawValue.<br></p><p>Good point… Has there been a thread on allowing raw-valued enums to be treated as constants of type `RawValue` yet? Either way, removing the restriction on what types can be a RawValue is still my preferred solution.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/3f4895bb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Proposal] Enums with static stored properties foreach case</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 26, 2016 at 01:00:00pm</p></header><div class="content"><p>Raw values are for coverting to and from an external representation only. That’s why it must be a primitive value, as they can be checked for equality in `init?(rawValue:)`.<br></p><p>The planets here have fuzzy floating point values, and so must never be checked for equality. The only source of truth are their names.<br></p><p>If you want a list of planets, the best way is to do this:<br></p><p>struct Planet {<br>  var mass: Float<br>  var radius: Float<br>  <br>  static let mercury = Planet(mass: 3.303e+23, radius: 2.4397e6)<br>  static let venus = Planet(mass: 4.869e+24, radius: 6.0518e6)<br>  static let earth = Planet(mass: 5.976e+24, radius: 6.37814e6)<br>  static let mars = Planet(mass: 6.421e+23, radius: 3.3972e6)<br>  static let jupiter = Planet(mass: 1.9e+27, radius: 7.1492e7)<br>  static let saturn = Planet(mass: 5.688e+26, radius: 6.0268e7)<br>  static let uranus = Planet(mass: 8.686e+25, radius: 2.5559e7)<br>  static let neptune = Planet(mass: 1.024e+26, radius: 2.4746e7)<br>}<br></p><p><br>What this proposal is asking for is an easier way to have derived values from enum cases. Asking for more flexible RawValues means mass and radius are not derived, they are the source of truth. It goes against the whole point of RawRepresentable. You are not saying ‘Mercury is identified by the case .mercury’, you are saying ‘Mercury is identified by a mass of 3.303e+23’. It’s backwards.<br></p><p><br>&gt; On 26 May 2016, at 1:47 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 25, 2016, at 10:27 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, May 25, 2016 at 8:15 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On May 25, 2016, at 7:37 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Couldn&#39;t this be solved by using tuples? If not because the syntax is not allowed I think this would be more coherent to do it using current syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Planet : (mass: Float, radius: Float) {<br>&gt;&gt;&gt;     case mercury = (mass: 3.303e+23, radius: 2.4397e6)<br>&gt;&gt;&gt;     case venus = (mass: 4.869e+24, radius: 6.0518e6)<br>&gt;&gt;&gt;     case earth = (mass: 5.976e+24, radius: 6.37814e6)<br>&gt;&gt;&gt;     case mars = (mass: 6.421e+23, radius: 3.3972e6)<br>&gt;&gt;&gt;     case jupiter = (mass: 1.9e+27, radius: 7.1492e7)<br>&gt;&gt;&gt;     case saturn = (mass: 5.688e+26, radius: 6.0268e7)<br>&gt;&gt;&gt;     case uranus = (mass: 8.686e+25, radius: 2.5559e7)<br>&gt;&gt;&gt;     case neptune = (mass: 1.024e+26, radius: 2.4746e7)<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This would be my preferred solution… AFAIK, the only reason we can’t do it now is that Swift currently requires RawValue be an integer, floating-point value, or string. I don’t know why the language has this restriction, so I can’t comment on how hard it would be to change.<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt; Except you&#39;d have to write Planet.mercury.rawValue.mass, rather than Planet.mercury.mass.<br>&gt;&gt; <br>&gt;&gt; This could be one or two proposals: allow enums with tuple RawValues, and allow `TupleName.caseName.propertyName` to access a tuple element without going through .rawValue.<br>&gt; <br>&gt; Good point… Has there been a thread on allowing raw-valued enums to be treated as constants of type `RawValue` yet? Either way, removing the restriction on what types can be a RawValue is still my preferred solution.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/6049c22c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal] Enums with static stored properties foreach case</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 26, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; What this proposal is asking for is an easier way to have derived values from enum cases. Asking for more flexible RawValues means mass and radius are not derived, they are the source of truth. It goes against the whole point of RawRepresentable. You are not saying ‘Mercury is identified by the case .mercury’, you are saying ‘Mercury is identified by a mass of 3.303e+23’. It’s backwards.<br></p><p>I see what Janis meant in the first email. It&#39;s not that the planet would be identified by the mass or radius. It could very much be <br></p><p>case Mercury = 1 where (mass: 3, radius: 2),<br></p><p>- Mercury&#39;s rawValue would be 1.<br></p><p>The issue here is that sometimes you want additional information with the enum. There are many cases where you extend the enum with a variable:<br></p><p>enum Error {<br>	case NoError<br>	case FileNotFound<br>	...<br></p><p>	var isFatal: Bool {<br>		/// swtich over all values of self goes here.<br>	}<br></p><p>	var isNetworkError: Bool {<br>		/// swtich over all values of self goes here.<br>	}<br></p><p>	var isIOError: Bool {<br>		/// swtich over all values of self goes here.<br>	}<br>}<br></p><p>What the propsal suggests is to simplify this to the following:<br></p><p>enum Error {<br>	var isFatal: Bool<br></p><p>	case NoError where (isFatal: false, isNetworkError: false, isIOError: false)<br>	case FileNotFound  where (isFatal: true, isNetworkError: false, isIOError: true)<br>	...<br></p><p>}<br></p><p>So that you assign the additional information to the enum value itself.<br></p><p>Charlie<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On 26 May 2016, at 1:47 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 25, 2016, at 10:27 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, May 25, 2016 at 8:15 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; On May 25, 2016, at 7:37 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Couldn&#39;t this be solved by using tuples? If not because the syntax is not allowed I think this would be more coherent to do it using current syntax.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum Planet : (mass: Float, radius: Float) {<br>&gt;&gt;&gt;&gt;     case mercury = (mass: 3.303e+23, radius: 2.4397e6)<br>&gt;&gt;&gt;&gt;     case venus = (mass: 4.869e+24, radius: 6.0518e6)<br>&gt;&gt;&gt;&gt;     case earth = (mass: 5.976e+24, radius: 6.37814e6)<br>&gt;&gt;&gt;&gt;     case mars = (mass: 6.421e+23, radius: 3.3972e6)<br>&gt;&gt;&gt;&gt;     case jupiter = (mass: 1.9e+27, radius: 7.1492e7)<br>&gt;&gt;&gt;&gt;     case saturn = (mass: 5.688e+26, radius: 6.0268e7)<br>&gt;&gt;&gt;&gt;     case uranus = (mass: 8.686e+25, radius: 2.5559e7)<br>&gt;&gt;&gt;&gt;     case neptune = (mass: 1.024e+26, radius: 2.4746e7)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would be my preferred solution… AFAIK, the only reason we can’t do it now is that Swift currently requires RawValue be an integer, floating-point value, or string. I don’t know why the language has this restriction, so I can’t comment on how hard it would be to change.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Except you&#39;d have to write Planet.mercury.rawValue.mass, rather than Planet.mercury.mass.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This could be one or two proposals: allow enums with tuple RawValues, and allow `TupleName.caseName.propertyName` to access a tuple element without going through .rawValue.<br>&gt;&gt; <br>&gt;&gt; Good point… Has there been a thread on allowing raw-valued enums to be treated as constants of type `RawValue` yet? Either way, removing the restriction on what types can be a RawValue is still my preferred solution.<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/68b86c90/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44a036cc421ee97534c54653a233db93?s=50"></div><header><strong>[Proposal] Enums with static stored properties foreach case</strong> from <string>Jānis Kiršteins</string> &lt;janis.kirsteins at gmail.com&gt;<p>May 26, 2016 at 08:00:00am</p></header><div class="content"><p>The argument against giving away raw value is that it grants<br>uniqueness of cases when serialized. One can reliably do:<br></p><p>// serialize<br>let rawValue = Planet.mercury.rawValue<br></p><p>// and de-serialize<br>guard let planet = Planet(rawValue: rawValue) else {<br>// ...<br>}<br></p><p>Currently raw values cannot only be equatables that are also literals<br>so their uniqueness can be checked at compile time. An alternative<br>could be that you can serialize/deserialize by case name. For example:<br></p><p>// serialize<br>let caseName = Planet.mercury.caseName // &quot;mercury&quot;<br></p><p>// de-serialize<br>guard let planet = Planet(caseName: &quot;mercury&quot;) else {<br>// ...<br>}<br></p><p>On Thu, May 26, 2016 at 8:26 AM, Charlie Monroe via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; What this proposal is asking for is an easier way to have derived values<br>&gt; from enum cases. Asking for more flexible RawValues means mass and radius<br>&gt; are not derived, they are the source of truth. It goes against the whole<br>&gt; point of RawRepresentable. You are not saying ‘Mercury is identified by the<br>&gt; case .mercury’, you are saying ‘Mercury is identified by a mass of<br>&gt; 3.303e+23’. It’s backwards.<br>&gt;<br>&gt;<br>&gt; I see what Janis meant in the first email. It&#39;s not that the planet would be<br>&gt; identified by the mass or radius. It could very much be<br>&gt;<br>&gt; case Mercury = 1 where (mass: 3, radius: 2),<br>&gt;<br>&gt; - Mercury&#39;s rawValue would be 1.<br>&gt;<br>&gt; The issue here is that sometimes you want additional information with the<br>&gt; enum. There are many cases where you extend the enum with a variable:<br>&gt;<br>&gt; enum Error {<br>&gt; case NoError<br>&gt; case FileNotFound<br>&gt; ...<br>&gt;<br>&gt; var isFatal: Bool {<br>&gt; /// swtich over all values of self goes here.<br>&gt; }<br>&gt;<br>&gt; var isNetworkError: Bool {<br>&gt; /// swtich over all values of self goes here.<br>&gt; }<br>&gt;<br>&gt; var isIOError: Bool {<br>&gt; /// swtich over all values of self goes here.<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; What the propsal suggests is to simplify this to the following:<br>&gt;<br>&gt; enum Error {<br>&gt; var isFatal: Bool<br>&gt;<br>&gt; case NoError where (isFatal: false, isNetworkError: false, isIOError: false)<br>&gt; case FileNotFound  where (isFatal: true, isNetworkError: false, isIOError:<br>&gt; true)<br>&gt; ...<br>&gt;<br>&gt; }<br>&gt;<br>&gt; So that you assign the additional information to the enum value itself.<br>&gt;<br>&gt; Charlie<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 26 May 2016, at 1:47 PM, David Sweeris via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On May 25, 2016, at 10:27 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; On Wed, May 25, 2016 at 8:15 PM, David Sweeris via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On May 25, 2016, at 7:37 AM, Leonardo Pessoa via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Hi,<br>&gt;&gt;<br>&gt;&gt; Couldn&#39;t this be solved by using tuples? If not because the syntax is not<br>&gt;&gt; allowed I think this would be more coherent to do it using current syntax.<br>&gt;&gt;<br>&gt;&gt; enum Planet : (mass: Float, radius: Float) {<br>&gt;&gt;     case mercury = (mass: 3.303e+23, radius: 2.4397e6)<br>&gt;&gt;     case venus = (mass: 4.869e+24, radius: 6.0518e6)<br>&gt;&gt;     case earth = (mass: 5.976e+24, radius: 6.37814e6)<br>&gt;&gt;     case mars = (mass: 6.421e+23, radius: 3.3972e6)<br>&gt;&gt;     case jupiter = (mass: 1.9e+27, radius: 7.1492e7)<br>&gt;&gt;     case saturn = (mass: 5.688e+26, radius: 6.0268e7)<br>&gt;&gt;     case uranus = (mass: 8.686e+25, radius: 2.5559e7)<br>&gt;&gt;     case neptune = (mass: 1.024e+26, radius: 2.4746e7)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This would be my preferred solution… AFAIK, the only reason we can’t do it<br>&gt;&gt; now is that Swift currently requires RawValue be an integer, floating-point<br>&gt;&gt; value, or string. I don’t know why the language has this restriction, so I<br>&gt;&gt; can’t comment on how hard it would be to change.<br>&gt;&gt;<br>&gt;&gt; - Dave Sweeris<br>&gt;<br>&gt;<br>&gt; Except you&#39;d have to write Planet.mercury.rawValue.mass, rather than<br>&gt; Planet.mercury.mass.<br>&gt;<br>&gt; This could be one or two proposals: allow enums with tuple RawValues, and<br>&gt; allow `TupleName.caseName.propertyName` to access a tuple element without<br>&gt; going through .rawValue.<br>&gt;<br>&gt;<br>&gt; Good point… Has there been a thread on allowing raw-valued enums to be<br>&gt; treated as constants of type `RawValue` yet? Either way, removing the<br>&gt; restriction on what types can be a RawValue is still my preferred solution.<br>&gt;<br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Enums with static stored propertiesforeach case</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 26, 2016 at 08:00:00am</p></header><div class="content"><p>That caseName I&#39;d the solution I miss and would like to see. Indeed when I see an enum the name is the reference to whatever value it should be holding. Think of this:<br></p><p>// all relative to Earth&#39;s mass, I&#39;m not digging the real values now <br>enum Mass : Float {<br>   case Earth = 1.0<br>   case Moon = 0.2<br>   ...<br>}<br></p><p>Since the values of each case are what&#39;s serialised, should I change the values here to absolute values I&#39;m unable to deserialise the stored values because the values no longer exist.<br></p><p>IMO enums are a language resource used to mask values by a name just like a group of related constants. Being able to find an enum value by its raw value is a good way to convert the value into an enum but you should not rely on it to ever hold the same value forever so yes enum names are supposed to be the truth but that&#39;s just not how it works in Swift (still, I do love being able to parameterise enum cases, so I&#39;m not suggesting to remove them).<br></p><p>As for having to use rawValue, we could work out a solution that would allow direct use of the properties in the tuple and I already have an idea: to make this:<br></p><p>enum Mass : Float {<br>   case Earth = 1.0<br>   case Moon = 0.2<br>}<br></p><p>be a shortcut in the language that is internally transformed and handled like this by the compiler:<br></p><p>enum Mass : (rawValue: Float) {<br>   case Earth = (rawValue : 1.0)<br>   case Moon = (rawValue: 0.2)<br>}<br></p><p>This doesn&#39;t break the current syntax of typed enums and still would allow us to access Planet.mercury.mass (in the previous examples) directly without using rawValue in the middle.<br></p><p>What do you think?<br></p><p><br></p><p>-----Original Message-----<br>From: &quot;Jānis Kiršteins via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Sent: ‎26/‎05/‎2016 02:59 AM<br>To: &quot;Charlie Monroe&quot; &lt;charlie at charliemonroe.net&gt;<br>Cc: &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Proposal] Enums with static stored propertiesforeach case<br></p><p>The argument against giving away raw value is that it grants<br>uniqueness of cases when serialized. One can reliably do:<br></p><p>// serialize<br>let rawValue = Planet.mercury.rawValue<br></p><p>// and de-serialize<br>guard let planet = Planet(rawValue: rawValue) else {<br>// ...<br>}<br></p><p>Currently raw values cannot only be equatables that are also literals<br>so their uniqueness can be checked at compile time. An alternative<br>could be that you can serialize/deserialize by case name. For example:<br></p><p>// serialize<br>let caseName = Planet.mercury.caseName // &quot;mercury&quot;<br></p><p>// de-serialize<br>guard let planet = Planet(caseName: &quot;mercury&quot;) else {<br>// ...<br>}<br></p><p>On Thu, May 26, 2016 at 8:26 AM, Charlie Monroe via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; What this proposal is asking for is an easier way to have derived values<br>&gt; from enum cases. Asking for more flexible RawValues means mass and radius<br>&gt; are not derived, they are the source of truth. It goes against the whole<br>&gt; point of RawRepresentable. You are not saying ‘Mercury is identified by the<br>&gt; case .mercury’, you are saying ‘Mercury is identified by a mass of<br>&gt; 3.303e+23’. It’s backwards.<br>&gt;<br>&gt;<br>&gt; I see what Janis meant in the first email. It&#39;s not that the planet would be<br>&gt; identified by the mass or radius. It could very much be<br>&gt;<br>&gt; case Mercury = 1 where (mass: 3, radius: 2),<br>&gt;<br>&gt; - Mercury&#39;s rawValue would be 1.<br>&gt;<br>&gt; The issue here is that sometimes you want additional information with the<br>&gt; enum. There are many cases where you extend the enum with a variable:<br>&gt;<br>&gt; enum Error {<br>&gt; case NoError<br>&gt; case FileNotFound<br>&gt; ...<br>&gt;<br>&gt; var isFatal: Bool {<br>&gt; /// swtich over all values of self goes here.<br>&gt; }<br>&gt;<br>&gt; var isNetworkError: Bool {<br>&gt; /// swtich over all values of self goes here.<br>&gt; }<br>&gt;<br>&gt; var isIOError: Bool {<br>&gt; /// swtich over all values of self goes here.<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; What the propsal suggests is to simplify this to the following:<br>&gt;<br>&gt; enum Error {<br>&gt; var isFatal: Bool<br>&gt;<br>&gt; case NoError where (isFatal: false, isNetworkError: false, isIOError: false)<br>&gt; case FileNotFound  where (isFatal: true, isNetworkError: false, isIOError:<br>&gt; true)<br>&gt; ...<br>&gt;<br>&gt; }<br>&gt;<br>&gt; So that you assign the additional information to the enum value itself.<br>&gt;<br>&gt; Charlie<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 26 May 2016, at 1:47 PM, David Sweeris via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On May 25, 2016, at 10:27 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; On Wed, May 25, 2016 at 8:15 PM, David Sweeris via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On May 25, 2016, at 7:37 AM, Leonardo Pessoa via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Hi,<br>&gt;&gt;<br>&gt;&gt; Couldn&#39;t this be solved by using tuples? If not because the syntax is not<br>&gt;&gt; allowed I think this would be more coherent to do it using current syntax.<br>&gt;&gt;<br>&gt;&gt; enum Planet : (mass: Float, radius: Float) {<br>&gt;&gt;     case mercury = (mass: 3.303e+23, radius: 2.4397e6)<br>&gt;&gt;     case venus = (mass: 4.869e+24, radius: 6.0518e6)<br>&gt;&gt;     case earth = (mass: 5.976e+24, radius: 6.37814e6)<br>&gt;&gt;     case mars = (mass: 6.421e+23, radius: 3.3972e6)<br>&gt;&gt;     case jupiter = (mass: 1.9e+27, radius: 7.1492e7)<br>&gt;&gt;     case saturn = (mass: 5.688e+26, radius: 6.0268e7)<br>&gt;&gt;     case uranus = (mass: 8.686e+25, radius: 2.5559e7)<br>&gt;&gt;     case neptune = (mass: 1.024e+26, radius: 2.4746e7)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This would be my preferred solution… AFAIK, the only reason we can’t do it<br>&gt;&gt; now is that Swift currently requires RawValue be an integer, floating-point<br>&gt;&gt; value, or string. I don’t know why the language has this restriction, so I<br>&gt;&gt; can’t comment on how hard it would be to change.<br>&gt;&gt;<br>&gt;&gt; - Dave Sweeris<br>&gt;<br>&gt;<br>&gt; Except you&#39;d have to write Planet.mercury.rawValue.mass, rather than<br>&gt; Planet.mercury.mass.<br>&gt;<br>&gt; This could be one or two proposals: allow enums with tuple RawValues, and<br>&gt; allow `TupleName.caseName.propertyName` to access a tuple element without<br>&gt; going through .rawValue.<br>&gt;<br>&gt;<br>&gt; Good point… Has there been a thread on allowing raw-valued enums to be<br>&gt; treated as constants of type `RawValue` yet? Either way, removing the<br>&gt; restriction on what types can be a RawValue is still my preferred solution.<br>&gt;<br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/b62e18be/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] Enums with static stored properties foreach case</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 26, 2016 at 05:00:00pm</p></header><div class="content"><p>I support the proposal, but couldn&#39;t the initial target be achieved today <br>with such (more verbose,yes) solution? :<br></p><p>enum Planet {<br>     struct PlanetInfo {<br>         var mass: Double<br>         var description: String<br>     }<br></p><p>     case earth<br>     case moon<br></p><p>     var info : PlanetInfo {<br>         switch self {<br>             case earth: return PlanetInfo(mass: 1.0, description: &quot;Earth <br>is our home&quot;)<br>             case moon: return PlanetInfo(mass: 0.2, description: &quot;Just a <br>moon&quot;)<br>         }<br>     }<br>}<br></p><p><br>let e = Planet.earth<br>print(e, e.info.description)<br></p><p>let m = Planet.moon<br>print(m, m.info.description)<br></p><p><br></p><p>On 26.05.2016 8:26, Charlie Monroe via swift-evolution wrote:<br>&gt;&gt; What this proposal is asking for is an easier way to have derived values<br>&gt;&gt; from enum cases. Asking for more flexible RawValues means mass and radius<br>&gt;&gt; are not derived, they are the source of truth. It goes against the whole<br>&gt;&gt; point of RawRepresentable. You are not saying ‘Mercury is identified by<br>&gt;&gt; the case .mercury’, you are saying ‘Mercury is identified by a mass of<br>&gt;&gt; 3.303e+23’. It’s backwards.<br>&gt;<br>&gt; I see what Janis meant in the first email. It&#39;s not that the planet would<br>&gt; be identified by the mass or radius. It could very much be<br>&gt;<br>&gt; case Mercury = 1 where (mass: 3, radius: 2),<br>&gt;<br>&gt; - Mercury&#39;s rawValue would be 1.<br>&gt;<br>&gt; The issue here is that sometimes you want additional information with the<br>&gt; enum. There are many cases where you extend the enum with a variable:<br>&gt;<br>&gt; enum Error {<br>&gt; case NoError<br>&gt; case FileNotFound<br>&gt; ...<br>&gt;<br>&gt; var isFatal: Bool {<br>&gt; /// swtich over all values of self goes here.<br>&gt; }<br>&gt;<br>&gt; var isNetworkError: Bool {<br>&gt; /// swtich over all values of self goes here.<br>&gt; }<br>&gt;<br>&gt; var isIOError: Bool {<br>&gt; /// swtich over all values of self goes here.<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; What the propsal suggests is to simplify this to the following:<br>&gt;<br>&gt; enum Error {<br>&gt; var isFatal: Bool<br>&gt;<br>&gt; case NoError where (isFatal: false, isNetworkError: false, isIOError: false)<br>&gt; case FileNotFound  where (isFatal: true, isNetworkError: false, isIOError:<br>&gt; true)<br>&gt; ...<br>&gt;<br>&gt; }<br>&gt;<br>&gt; So that you assign the additional information to the enum value itself.<br>&gt;<br>&gt; Charlie<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On 26 May 2016, at 1:47 PM, David Sweeris via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On May 25, 2016, at 10:27 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com<br>&gt;&gt;&gt;&gt; &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, May 25, 2016 at 8:15 PM, David Sweeris via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     On May 25, 2016, at 7:37 AM, Leonardo Pessoa via swift-evolution<br>&gt;&gt;&gt;&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     Hi,<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     Couldn&#39;t this be solved by using tuples? If not because the syntax<br>&gt;&gt;&gt;&gt;&gt;     is not allowed I think this would be more coherent to do it using<br>&gt;&gt;&gt;&gt;&gt;     current syntax.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     enum Planet : (mass: Float, radius: Float) {<br>&gt;&gt;&gt;&gt;&gt;         case mercury = (mass: 3.303e+23, radius: 2.4397e6)<br>&gt;&gt;&gt;&gt;&gt;         case venus = (mass: 4.869e+24, radius: 6.0518e6)<br>&gt;&gt;&gt;&gt;&gt;         case earth = (mass: 5.976e+24, radius: 6.37814e6)<br>&gt;&gt;&gt;&gt;&gt;         case mars = (mass: 6.421e+23, radius: 3.3972e6)<br>&gt;&gt;&gt;&gt;&gt;         case jupiter = (mass: 1.9e+27, radius: 7.1492e7)<br>&gt;&gt;&gt;&gt;&gt;         case saturn = (mass: 5.688e+26, radius: 6.0268e7)<br>&gt;&gt;&gt;&gt;&gt;         case uranus = (mass: 8.686e+25, radius: 2.5559e7)<br>&gt;&gt;&gt;&gt;&gt;         case neptune = (mass: 1.024e+26, radius: 2.4746e7)<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     This would be my preferred solution… AFAIK, the only reason we<br>&gt;&gt;&gt;&gt;     can’t do it now is that Swift currently requires RawValue be an<br>&gt;&gt;&gt;&gt;     integer, floating-point value, or string. I don’t know why the<br>&gt;&gt;&gt;&gt;     language has this restriction, so I can’t comment on how hard it<br>&gt;&gt;&gt;&gt;     would be to change.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     - Dave Sweeris<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Except you&#39;d have to write Planet.mercury.rawValue.mass, rather than<br>&gt;&gt;&gt;&gt; Planet.mercury.mass.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This could be one or two proposals: allow enums with tuple RawValues,<br>&gt;&gt;&gt;&gt; and allow `TupleName.caseName.propertyName` to access a tuple element<br>&gt;&gt;&gt;&gt; without going through .rawValue.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Good point… Has there been a thread on allowing raw-valued enums to be<br>&gt;&gt;&gt; treated as constants of type `RawValue` yet? Either way, removing the<br>&gt;&gt;&gt; restriction on what types can be a RawValue is still my preferred solution.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44a036cc421ee97534c54653a233db93?s=50"></div><header><strong>[Proposal] Enums with static stored properties foreach case</strong> from <string>Jānis Kiršteins</string> &lt;janis.kirsteins at gmail.com&gt;<p>May 26, 2016 at 06:00:00pm</p></header><div class="content"><p>The problem is that PlanetInfo values are recreated each time while<br>they are static. Imagine if PlanetInfo where some type that expensive<br>to create performance wise.<br></p><p>You could solve it by:<br></p><p>enum Planet {<br>    struct PlanetInfo {<br>        var mass: Double<br>        var description: String<br>    }<br></p><p>    case earth<br>    case moon<br></p><p>    private static earthInfo = PlanetInfo(mass: 1.0, description:<br>&quot;Earth is our home&quot;)<br>    private static moonInfo = PlanetInfo(mass: 0.2, description: &quot;Just a moon&quot;)<br></p><p>    var info : PlanetInfo {<br>        switch self {<br>            case earth: return PlanetInfo.earthInfo<br>            case moon: return PlanetInfo.moonInfo<br>        }<br>    }<br>}<br></p><p>But that again more verbose. The proposed solution is explicit that<br>those properties are static for each case.<br></p><p><br>On Thu, May 26, 2016 at 5:58 PM, Vladimir.S via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I support the proposal, but couldn&#39;t the initial target be achieved today<br>&gt; with such (more verbose,yes) solution? :<br>&gt;<br>&gt; enum Planet {<br>&gt;     struct PlanetInfo {<br>&gt;         var mass: Double<br>&gt;         var description: String<br>&gt;     }<br>&gt;<br>&gt;     case earth<br>&gt;     case moon<br>&gt;<br>&gt;     var info : PlanetInfo {<br>&gt;         switch self {<br>&gt;             case earth: return PlanetInfo(mass: 1.0, description: &quot;Earth is<br>&gt; our home&quot;)<br>&gt;             case moon: return PlanetInfo(mass: 0.2, description: &quot;Just a<br>&gt; moon&quot;)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; let e = Planet.earth<br>&gt; print(e, e.info.description)<br>&gt;<br>&gt; let m = Planet.moon<br>&gt; print(m, m.info.description)<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 26.05.2016 8:26, Charlie Monroe via swift-evolution wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What this proposal is asking for is an easier way to have derived values<br>&gt;&gt;&gt; from enum cases. Asking for more flexible RawValues means mass and radius<br>&gt;&gt;&gt; are not derived, they are the source of truth. It goes against the whole<br>&gt;&gt;&gt; point of RawRepresentable. You are not saying ‘Mercury is identified by<br>&gt;&gt;&gt; the case .mercury’, you are saying ‘Mercury is identified by a mass of<br>&gt;&gt;&gt; 3.303e+23’. It’s backwards.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I see what Janis meant in the first email. It&#39;s not that the planet would<br>&gt;&gt; be identified by the mass or radius. It could very much be<br>&gt;&gt;<br>&gt;&gt; case Mercury = 1 where (mass: 3, radius: 2),<br>&gt;&gt;<br>&gt;&gt; - Mercury&#39;s rawValue would be 1.<br>&gt;&gt;<br>&gt;&gt; The issue here is that sometimes you want additional information with the<br>&gt;&gt; enum. There are many cases where you extend the enum with a variable:<br>&gt;&gt;<br>&gt;&gt; enum Error {<br>&gt;&gt; case NoError<br>&gt;&gt; case FileNotFound<br>&gt;&gt; ...<br>&gt;&gt;<br>&gt;&gt; var isFatal: Bool {<br>&gt;&gt; /// swtich over all values of self goes here.<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; var isNetworkError: Bool {<br>&gt;&gt; /// swtich over all values of self goes here.<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; var isIOError: Bool {<br>&gt;&gt; /// swtich over all values of self goes here.<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; What the propsal suggests is to simplify this to the following:<br>&gt;&gt;<br>&gt;&gt; enum Error {<br>&gt;&gt; var isFatal: Bool<br>&gt;&gt;<br>&gt;&gt; case NoError where (isFatal: false, isNetworkError: false, isIOError:<br>&gt;&gt; false)<br>&gt;&gt; case FileNotFound  where (isFatal: true, isNetworkError: false, isIOError:<br>&gt;&gt; true)<br>&gt;&gt; ...<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; So that you assign the additional information to the enum value itself.<br>&gt;&gt;<br>&gt;&gt; Charlie<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 26 May 2016, at 1:47 PM, David Sweeris via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 10:27 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, May 25, 2016 at 8:15 PM, David Sweeris via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     On May 25, 2016, at 7:37 AM, Leonardo Pessoa via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     Hi,<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     Couldn&#39;t this be solved by using tuples? If not because the syntax<br>&gt;&gt;&gt;&gt;&gt;&gt;     is not allowed I think this would be more coherent to do it using<br>&gt;&gt;&gt;&gt;&gt;&gt;     current syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     enum Planet : (mass: Float, radius: Float) {<br>&gt;&gt;&gt;&gt;&gt;&gt;         case mercury = (mass: 3.303e+23, radius: 2.4397e6)<br>&gt;&gt;&gt;&gt;&gt;&gt;         case venus = (mass: 4.869e+24, radius: 6.0518e6)<br>&gt;&gt;&gt;&gt;&gt;&gt;         case earth = (mass: 5.976e+24, radius: 6.37814e6)<br>&gt;&gt;&gt;&gt;&gt;&gt;         case mars = (mass: 6.421e+23, radius: 3.3972e6)<br>&gt;&gt;&gt;&gt;&gt;&gt;         case jupiter = (mass: 1.9e+27, radius: 7.1492e7)<br>&gt;&gt;&gt;&gt;&gt;&gt;         case saturn = (mass: 5.688e+26, radius: 6.0268e7)<br>&gt;&gt;&gt;&gt;&gt;&gt;         case uranus = (mass: 8.686e+25, radius: 2.5559e7)<br>&gt;&gt;&gt;&gt;&gt;&gt;         case neptune = (mass: 1.024e+26, radius: 2.4746e7)<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     This would be my preferred solution… AFAIK, the only reason we<br>&gt;&gt;&gt;&gt;&gt;     can’t do it now is that Swift currently requires RawValue be an<br>&gt;&gt;&gt;&gt;&gt;     integer, floating-point value, or string. I don’t know why the<br>&gt;&gt;&gt;&gt;&gt;     language has this restriction, so I can’t comment on how hard it<br>&gt;&gt;&gt;&gt;&gt;     would be to change.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     - Dave Sweeris<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Except you&#39;d have to write Planet.mercury.rawValue.mass, rather than<br>&gt;&gt;&gt;&gt;&gt; Planet.mercury.mass.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; This could be one or two proposals: allow enums with tuple RawValues,<br>&gt;&gt;&gt;&gt;&gt; and allow `TupleName.caseName.propertyName` to access a tuple element<br>&gt;&gt;&gt;&gt;&gt; without going through .rawValue.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Good point… Has there been a thread on allowing raw-valued enums to be<br>&gt;&gt;&gt;&gt; treated as constants of type `RawValue` yet? Either way, removing the<br>&gt;&gt;&gt;&gt; restriction on what types can be a RawValue is still my preferred<br>&gt;&gt;&gt;&gt; solution.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] Enums with static stored properties foreach case</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 26, 2016 at 06:00:00pm</p></header><div class="content"><p>Or(if we are sure we&#39;ll don&#39;t forget to udpate `infoDict` in case of new <br>added case in future):<br></p><p>enum Planet {<br>     case earth<br>     case moon<br></p><p>     struct PlanetInfo {<br>         var mass: Double<br>         var description: String<br>     }<br></p><p>     private static let infoDict = [<br>         Planet.earth :<br>             PlanetInfo(mass: 1.0, description:&quot;Earth is our home&quot;),<br>         .moon:<br>             PlanetInfo(mass: 0.2, description:&quot;Just a moon&quot;),<br>         ]<br></p><p>     var info : PlanetInfo { return Planet.infoDict[self]! }<br>}<br></p><p>But I agree with you, IMO we need static stored properties for each case.<br></p><p>On 26.05.2016 18:15, Jānis Kiršteins wrote:<br>&gt; The problem is that PlanetInfo values are recreated each time while<br>&gt; they are static. Imagine if PlanetInfo where some type that expensive<br>&gt; to create performance wise.<br>&gt;<br>&gt; You could solve it by:<br>&gt;<br>&gt; enum Planet {<br>&gt;     struct PlanetInfo {<br>&gt;         var mass: Double<br>&gt;         var description: String<br>&gt;     }<br>&gt;<br>&gt;     case earth<br>&gt;     case moon<br>&gt;<br>&gt;     private static earthInfo = PlanetInfo(mass: 1.0, description:<br>&gt; &quot;Earth is our home&quot;)<br>&gt;     private static moonInfo = PlanetInfo(mass: 0.2, description: &quot;Just a moon&quot;)<br>&gt;<br>&gt;     var info : PlanetInfo {<br>&gt;         switch self {<br>&gt;             case earth: return PlanetInfo.earthInfo<br>&gt;             case moon: return PlanetInfo.moonInfo<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; But that again more verbose. The proposed solution is explicit that<br>&gt; those properties are static for each case.<br>&gt;<br>&gt;<br>&gt; On Thu, May 26, 2016 at 5:58 PM, Vladimir.S via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I support the proposal, but couldn&#39;t the initial target be achieved today<br>&gt;&gt; with such (more verbose,yes) solution? :<br>&gt;&gt;<br>&gt;&gt; enum Planet {<br>&gt;&gt;     struct PlanetInfo {<br>&gt;&gt;         var mass: Double<br>&gt;&gt;         var description: String<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     case earth<br>&gt;&gt;     case moon<br>&gt;&gt;<br>&gt;&gt;     var info : PlanetInfo {<br>&gt;&gt;         switch self {<br>&gt;&gt;             case earth: return PlanetInfo(mass: 1.0, description: &quot;Earth is<br>&gt;&gt; our home&quot;)<br>&gt;&gt;             case moon: return PlanetInfo(mass: 0.2, description: &quot;Just a<br>&gt;&gt; moon&quot;)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; let e = Planet.earth<br>&gt;&gt; print(e, e.info.description)<br>&gt;&gt;<br>&gt;&gt; let m = Planet.moon<br>&gt;&gt; print(m, m.info.description)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 26.05.2016 8:26, Charlie Monroe via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; What this proposal is asking for is an easier way to have derived values<br>&gt;&gt;&gt;&gt; from enum cases. Asking for more flexible RawValues means mass and radius<br>&gt;&gt;&gt;&gt; are not derived, they are the source of truth. It goes against the whole<br>&gt;&gt;&gt;&gt; point of RawRepresentable. You are not saying ‘Mercury is identified by<br>&gt;&gt;&gt;&gt; the case .mercury’, you are saying ‘Mercury is identified by a mass of<br>&gt;&gt;&gt;&gt; 3.303e+23’. It’s backwards.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I see what Janis meant in the first email. It&#39;s not that the planet would<br>&gt;&gt;&gt; be identified by the mass or radius. It could very much be<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; case Mercury = 1 where (mass: 3, radius: 2),<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Mercury&#39;s rawValue would be 1.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The issue here is that sometimes you want additional information with the<br>&gt;&gt;&gt; enum. There are many cases where you extend the enum with a variable:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; enum Error {<br>&gt;&gt;&gt; case NoError<br>&gt;&gt;&gt; case FileNotFound<br>&gt;&gt;&gt; ...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var isFatal: Bool {<br>&gt;&gt;&gt; /// swtich over all values of self goes here.<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var isNetworkError: Bool {<br>&gt;&gt;&gt; /// swtich over all values of self goes here.<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var isIOError: Bool {<br>&gt;&gt;&gt; /// swtich over all values of self goes here.<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What the propsal suggests is to simplify this to the following:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; enum Error {<br>&gt;&gt;&gt; var isFatal: Bool<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; case NoError where (isFatal: false, isNetworkError: false, isIOError:<br>&gt;&gt;&gt; false)<br>&gt;&gt;&gt; case FileNotFound  where (isFatal: true, isNetworkError: false, isIOError:<br>&gt;&gt;&gt; true)<br>&gt;&gt;&gt; ...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So that you assign the additional information to the enum value itself.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On 26 May 2016, at 1:47 PM, David Sweeris via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 10:27 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, May 25, 2016 at 8:15 PM, David Sweeris via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     On May 25, 2016, at 7:37 AM, Leonardo Pessoa via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     Hi,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     Couldn&#39;t this be solved by using tuples? If not because the syntax<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     is not allowed I think this would be more coherent to do it using<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     current syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     enum Planet : (mass: Float, radius: Float) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         case mercury = (mass: 3.303e+23, radius: 2.4397e6)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         case venus = (mass: 4.869e+24, radius: 6.0518e6)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         case earth = (mass: 5.976e+24, radius: 6.37814e6)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         case mars = (mass: 6.421e+23, radius: 3.3972e6)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         case jupiter = (mass: 1.9e+27, radius: 7.1492e7)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         case saturn = (mass: 5.688e+26, radius: 6.0268e7)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         case uranus = (mass: 8.686e+25, radius: 2.5559e7)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         case neptune = (mass: 1.024e+26, radius: 2.4746e7)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     This would be my preferred solution… AFAIK, the only reason we<br>&gt;&gt;&gt;&gt;&gt;&gt;     can’t do it now is that Swift currently requires RawValue be an<br>&gt;&gt;&gt;&gt;&gt;&gt;     integer, floating-point value, or string. I don’t know why the<br>&gt;&gt;&gt;&gt;&gt;&gt;     language has this restriction, so I can’t comment on how hard it<br>&gt;&gt;&gt;&gt;&gt;&gt;     would be to change.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     - Dave Sweeris<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Except you&#39;d have to write Planet.mercury.rawValue.mass, rather than<br>&gt;&gt;&gt;&gt;&gt;&gt; Planet.mercury.mass.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; This could be one or two proposals: allow enums with tuple RawValues,<br>&gt;&gt;&gt;&gt;&gt;&gt; and allow `TupleName.caseName.propertyName` to access a tuple element<br>&gt;&gt;&gt;&gt;&gt;&gt; without going through .rawValue.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Good point… Has there been a thread on allowing raw-valued enums to be<br>&gt;&gt;&gt;&gt;&gt; treated as constants of type `RawValue` yet? Either way, removing the<br>&gt;&gt;&gt;&gt;&gt; restriction on what types can be a RawValue is still my preferred<br>&gt;&gt;&gt;&gt;&gt; solution.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>[Proposal] Enums with static stored properties foreach case</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>May 26, 2016 at 05:00:00pm</p></header><div class="content"><p>Perhaps there&#39;s an argument to be made for a sort of &#39;enumDictionary&#39; type<br>- a dictionary whose keys are all the cases of an enum, and is thus<br>guaranteed to produce a value.<br></p><p>I think the question I have is how you&#39;d access the values, syntactically.<br>To use the Planet example, if &#39;.earth&#39; is a value of the Planet enum, is<br>&#39;.earth.mass&#39; an acceptable way to access its mass? Or perhaps<br>&#39;Planet[.earth].mass&#39;?<br></p><p>On Thu, May 26, 2016 at 4:43 PM, Vladimir.S via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Or(if we are sure we&#39;ll don&#39;t forget to udpate `infoDict` in case of new<br>&gt; added case in future):<br>&gt;<br>&gt; enum Planet {<br>&gt;     case earth<br>&gt;     case moon<br>&gt;<br>&gt;     struct PlanetInfo {<br>&gt;         var mass: Double<br>&gt;         var description: String<br>&gt;     }<br>&gt;<br>&gt;     private static let infoDict = [<br>&gt;         Planet.earth :<br>&gt;             PlanetInfo(mass: 1.0, description:&quot;Earth is our home&quot;),<br>&gt;         .moon:<br>&gt;             PlanetInfo(mass: 0.2, description:&quot;Just a moon&quot;),<br>&gt;         ]<br>&gt;<br>&gt;     var info : PlanetInfo { return Planet.infoDict[self]! }<br>&gt; }<br>&gt;<br>&gt; But I agree with you, IMO we need static stored properties for each case.<br>&gt;<br>&gt;<br>&gt; On 26.05.2016 18:15, Jānis Kiršteins wrote:<br>&gt;<br>&gt;&gt; The problem is that PlanetInfo values are recreated each time while<br>&gt;&gt; they are static. Imagine if PlanetInfo where some type that expensive<br>&gt;&gt; to create performance wise.<br>&gt;&gt;<br>&gt;&gt; You could solve it by:<br>&gt;&gt;<br>&gt;&gt; enum Planet {<br>&gt;&gt;     struct PlanetInfo {<br>&gt;&gt;         var mass: Double<br>&gt;&gt;         var description: String<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     case earth<br>&gt;&gt;     case moon<br>&gt;&gt;<br>&gt;&gt;     private static earthInfo = PlanetInfo(mass: 1.0, description:<br>&gt;&gt; &quot;Earth is our home&quot;)<br>&gt;&gt;     private static moonInfo = PlanetInfo(mass: 0.2, description: &quot;Just a<br>&gt;&gt; moon&quot;)<br>&gt;&gt;<br>&gt;&gt;     var info : PlanetInfo {<br>&gt;&gt;         switch self {<br>&gt;&gt;             case earth: return PlanetInfo.earthInfo<br>&gt;&gt;             case moon: return PlanetInfo.moonInfo<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; But that again more verbose. The proposed solution is explicit that<br>&gt;&gt; those properties are static for each case.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Thu, May 26, 2016 at 5:58 PM, Vladimir.S via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I support the proposal, but couldn&#39;t the initial target be achieved today<br>&gt;&gt;&gt; with such (more verbose,yes) solution? :<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; enum Planet {<br>&gt;&gt;&gt;     struct PlanetInfo {<br>&gt;&gt;&gt;         var mass: Double<br>&gt;&gt;&gt;         var description: String<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     case earth<br>&gt;&gt;&gt;     case moon<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     var info : PlanetInfo {<br>&gt;&gt;&gt;         switch self {<br>&gt;&gt;&gt;             case earth: return PlanetInfo(mass: 1.0, description: &quot;Earth<br>&gt;&gt;&gt; is<br>&gt;&gt;&gt; our home&quot;)<br>&gt;&gt;&gt;             case moon: return PlanetInfo(mass: 0.2, description: &quot;Just a<br>&gt;&gt;&gt; moon&quot;)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let e = Planet.earth<br>&gt;&gt;&gt; print(e, e.info.description)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let m = Planet.moon<br>&gt;&gt;&gt; print(m, m.info.description)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 26.05.2016 8:26, Charlie Monroe via swift-evolution wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; What this proposal is asking for is an easier way to have derived<br>&gt;&gt;&gt;&gt;&gt; values<br>&gt;&gt;&gt;&gt;&gt; from enum cases. Asking for more flexible RawValues means mass and<br>&gt;&gt;&gt;&gt;&gt; radius<br>&gt;&gt;&gt;&gt;&gt; are not derived, they are the source of truth. It goes against the<br>&gt;&gt;&gt;&gt;&gt; whole<br>&gt;&gt;&gt;&gt;&gt; point of RawRepresentable. You are not saying ‘Mercury is identified by<br>&gt;&gt;&gt;&gt;&gt; the case .mercury’, you are saying ‘Mercury is identified by a mass of<br>&gt;&gt;&gt;&gt;&gt; 3.303e+23’. It’s backwards.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I see what Janis meant in the first email. It&#39;s not that the planet<br>&gt;&gt;&gt;&gt; would<br>&gt;&gt;&gt;&gt; be identified by the mass or radius. It could very much be<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; case Mercury = 1 where (mass: 3, radius: 2),<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - Mercury&#39;s rawValue would be 1.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The issue here is that sometimes you want additional information with<br>&gt;&gt;&gt;&gt; the<br>&gt;&gt;&gt;&gt; enum. There are many cases where you extend the enum with a variable:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; enum Error {<br>&gt;&gt;&gt;&gt; case NoError<br>&gt;&gt;&gt;&gt; case FileNotFound<br>&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; var isFatal: Bool {<br>&gt;&gt;&gt;&gt; /// swtich over all values of self goes here.<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; var isNetworkError: Bool {<br>&gt;&gt;&gt;&gt; /// swtich over all values of self goes here.<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; var isIOError: Bool {<br>&gt;&gt;&gt;&gt; /// swtich over all values of self goes here.<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; What the propsal suggests is to simplify this to the following:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; enum Error {<br>&gt;&gt;&gt;&gt; var isFatal: Bool<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; case NoError where (isFatal: false, isNetworkError: false, isIOError:<br>&gt;&gt;&gt;&gt; false)<br>&gt;&gt;&gt;&gt; case FileNotFound  where (isFatal: true, isNetworkError: false,<br>&gt;&gt;&gt;&gt; isIOError:<br>&gt;&gt;&gt;&gt; true)<br>&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So that you assign the additional information to the enum value itself.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On 26 May 2016, at 1:47 PM, David Sweeris via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 10:27 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, May 25, 2016 at 8:15 PM, David Sweeris via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     On May 25, 2016, at 7:37 AM, Leonardo Pessoa via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     Hi,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     Couldn&#39;t this be solved by using tuples? If not because the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; syntax<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     is not allowed I think this would be more coherent to do it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; using<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     current syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     enum Planet : (mass: Float, radius: Float) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         case mercury = (mass: 3.303e+23, radius: 2.4397e6)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         case venus = (mass: 4.869e+24, radius: 6.0518e6)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         case earth = (mass: 5.976e+24, radius: 6.37814e6)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         case mars = (mass: 6.421e+23, radius: 3.3972e6)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         case jupiter = (mass: 1.9e+27, radius: 7.1492e7)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         case saturn = (mass: 5.688e+26, radius: 6.0268e7)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         case uranus = (mass: 8.686e+25, radius: 2.5559e7)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         case neptune = (mass: 1.024e+26, radius: 2.4746e7)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     This would be my preferred solution… AFAIK, the only reason we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     can’t do it now is that Swift currently requires RawValue be an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     integer, floating-point value, or string. I don’t know why the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     language has this restriction, so I can’t comment on how hard it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     would be to change.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     - Dave Sweeris<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Except you&#39;d have to write Planet.mercury.rawValue.mass, rather than<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Planet.mercury.mass.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This could be one or two proposals: allow enums with tuple RawValues,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and allow `TupleName.caseName.propertyName` to access a tuple element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; without going through .rawValue.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Good point… Has there been a thread on allowing raw-valued enums to be<br>&gt;&gt;&gt;&gt;&gt;&gt; treated as constants of type `RawValue` yet? Either way, removing the<br>&gt;&gt;&gt;&gt;&gt;&gt; restriction on what types can be a RawValue is still my preferred<br>&gt;&gt;&gt;&gt;&gt;&gt; solution.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/3189d450/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] Enums with static stored properties foreach case</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 26, 2016 at 08:00:00pm</p></header><div class="content"><p>On 26.05.2016 19:50, Ross O&#39;Brien wrote:<br>&gt; Perhaps there&#39;s an argument to be made for a sort of &#39;enumDictionary&#39; type<br>&gt; - a dictionary whose keys are all the cases of an enum, and is thus<br>&gt; guaranteed to produce a value.<br></p><p>In Delphi(Pascal) you can define an array with indexes of enum type i.e.:<br>type<br>   TMyEnum = (One, Two)<br>var<br>   MyVal : array[TMyEnum] of String<br>const<br>   MyConsts : array [TMyEnum] of String = (&#39;just one&#39;, &#39;two here&#39;)<br>   // compiler will check that values for each enum were specified here<br></p><p>,so you can do<br>var e: TMyEnum<br>e := One;<br>MyVal[e] := &#39;hello&#39;;<br>s2 := MyConsts[e];<br></p><p>This is really useful and used a lot. And this is safe in meaning compiler <br>will notify you if you changed the enum - you&#39;ll have to change such <br>constant array.<br></p><p>I wish we&#39;ll have something like this in Swift.<br></p><p>&gt;<br>&gt; I think the question I have is how you&#39;d access the values, syntactically.<br>&gt; To use the Planet example, if &#39;.earth&#39; is a value of the Planet enum, is<br>&gt; &#39;.earth.mass&#39; an acceptable way to access its mass? Or perhaps<br>&gt; &#39;Planet[.earth].mass&#39;?<br></p><p>Just like .rawValue currently, i.e.<br>let e = Planet.earth<br>print(e.mass, e.description)<br></p><p>&gt;<br>&gt; On Thu, May 26, 2016 at 4:43 PM, Vladimir.S via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;     Or(if we are sure we&#39;ll don&#39;t forget to udpate `infoDict` in case of<br>&gt;     new added case in future):<br>&gt;<br>&gt;     enum Planet {<br>&gt;         case earth<br>&gt;         case moon<br>&gt;<br>&gt;         struct PlanetInfo {<br>&gt;             var mass: Double<br>&gt;             var description: String<br>&gt;         }<br>&gt;<br>&gt;         private static let infoDict = [<br>&gt;             Planet.earth :<br>&gt;                 PlanetInfo(mass: 1.0, description:&quot;Earth is our home&quot;),<br>&gt;             .moon:<br>&gt;                 PlanetInfo(mass: 0.2, description:&quot;Just a moon&quot;),<br>&gt;             ]<br>&gt;<br>&gt;         var info : PlanetInfo { return Planet.infoDict[self]! }<br>&gt;     }<br>&gt;<br>&gt;     But I agree with you, IMO we need static stored properties for each case.<br>&gt;<br>&gt;<br>&gt;     On 26.05.2016 18 &lt;tel:26.05.2016%2018&gt;:15, Jānis Kiršteins wrote:<br>&gt;<br>&gt;         The problem is that PlanetInfo values are recreated each time while<br>&gt;         they are static. Imagine if PlanetInfo where some type that expensive<br>&gt;         to create performance wise.<br>&gt;<br>&gt;         You could solve it by:<br>&gt;<br>&gt;         enum Planet {<br>&gt;             struct PlanetInfo {<br>&gt;                 var mass: Double<br>&gt;                 var description: String<br>&gt;             }<br>&gt;<br>&gt;             case earth<br>&gt;             case moon<br>&gt;<br>&gt;             private static earthInfo = PlanetInfo(mass: 1.0, description:<br>&gt;         &quot;Earth is our home&quot;)<br>&gt;             private static moonInfo = PlanetInfo(mass: 0.2, description:<br>&gt;         &quot;Just a moon&quot;)<br>&gt;<br>&gt;             var info : PlanetInfo {<br>&gt;                 switch self {<br>&gt;                     case earth: return PlanetInfo.earthInfo<br>&gt;                     case moon: return PlanetInfo.moonInfo<br>&gt;                 }<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt;         But that again more verbose. The proposed solution is explicit that<br>&gt;         those properties are static for each case.<br>&gt;<br>&gt;<br>&gt;         On Thu, May 26, 2016 at 5:58 PM, Vladimir.S via swift-evolution<br>&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;             I support the proposal, but couldn&#39;t the initial target be<br>&gt;             achieved today<br>&gt;             with such (more verbose,yes) solution? :<br>&gt;<br>&gt;             enum Planet {<br>&gt;                 struct PlanetInfo {<br>&gt;                     var mass: Double<br>&gt;                     var description: String<br>&gt;                 }<br>&gt;<br>&gt;                 case earth<br>&gt;                 case moon<br>&gt;<br>&gt;                 var info : PlanetInfo {<br>&gt;                     switch self {<br>&gt;                         case earth: return PlanetInfo(mass: 1.0,<br>&gt;             description: &quot;Earth is<br>&gt;             our home&quot;)<br>&gt;                         case moon: return PlanetInfo(mass: 0.2,<br>&gt;             description: &quot;Just a<br>&gt;             moon&quot;)<br>&gt;                     }<br>&gt;                 }<br>&gt;             }<br>&gt;<br>&gt;<br>&gt;             let e = Planet.earth<br>&gt;             print(e, e.info.description)<br>&gt;<br>&gt;             let m = Planet.moon<br>&gt;             print(m, m.info.description)<br>&gt;<br>&gt;<br>&gt;<br>&gt;             On 26.05.2016 8:26, Charlie Monroe via swift-evolution wrote:<br>&gt;<br>&gt;<br>&gt;                     What this proposal is asking for is an easier way to<br>&gt;                     have derived values<br>&gt;                     from enum cases. Asking for more flexible RawValues<br>&gt;                     means mass and radius<br>&gt;                     are not derived, they are the source of truth. It goes<br>&gt;                     against the whole<br>&gt;                     point of RawRepresentable. You are not saying ‘Mercury<br>&gt;                     is identified by<br>&gt;                     the case .mercury’, you are saying ‘Mercury is<br>&gt;                     identified by a mass of<br>&gt;                     3.303e+23’. It’s backwards.<br>&gt;<br>&gt;<br>&gt;<br>&gt;                 I see what Janis meant in the first email. It&#39;s not that<br>&gt;                 the planet would<br>&gt;                 be identified by the mass or radius. It could very much be<br>&gt;<br>&gt;                 case Mercury = 1 where (mass: 3, radius: 2),<br>&gt;<br>&gt;                 - Mercury&#39;s rawValue would be 1.<br>&gt;<br>&gt;                 The issue here is that sometimes you want additional<br>&gt;                 information with the<br>&gt;                 enum. There are many cases where you extend the enum with a<br>&gt;                 variable:<br>&gt;<br>&gt;                 enum Error {<br>&gt;                 case NoError<br>&gt;                 case FileNotFound<br>&gt;                 ...<br>&gt;<br>&gt;                 var isFatal: Bool {<br>&gt;                 /// swtich over all values of self goes here.<br>&gt;                 }<br>&gt;<br>&gt;                 var isNetworkError: Bool {<br>&gt;                 /// swtich over all values of self goes here.<br>&gt;                 }<br>&gt;<br>&gt;                 var isIOError: Bool {<br>&gt;                 /// swtich over all values of self goes here.<br>&gt;                 }<br>&gt;                 }<br>&gt;<br>&gt;                 What the propsal suggests is to simplify this to the following:<br>&gt;<br>&gt;                 enum Error {<br>&gt;                 var isFatal: Bool<br>&gt;<br>&gt;                 case NoError where (isFatal: false, isNetworkError: false,<br>&gt;                 isIOError:<br>&gt;                 false)<br>&gt;                 case FileNotFound  where (isFatal: true, isNetworkError:<br>&gt;                 false, isIOError:<br>&gt;                 true)<br>&gt;                 ...<br>&gt;<br>&gt;                 }<br>&gt;<br>&gt;                 So that you assign the additional information to the enum<br>&gt;                 value itself.<br>&gt;<br>&gt;                 Charlie<br>&gt;<br>&gt;<br>&gt;<br>&gt;                         On 26 May 2016, at 1:47 PM, David Sweeris via<br>&gt;                         swift-evolution<br>&gt;                         &lt;swift-evolution at swift.org<br>&gt;                         &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;                         &lt;mailto:swift-evolution at swift.org<br>&gt;                         &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt;                             On May 25, 2016, at 10:27 PM, Jacob<br>&gt;                             Bandes-Storch &lt;jtbandes at gmail.com<br>&gt;                             &lt;mailto:jtbandes at gmail.com&gt;<br>&gt;                             &lt;mailto:jtbandes at gmail.com<br>&gt;                             &lt;mailto:jtbandes at gmail.com&gt;&gt;&gt; wrote:<br>&gt;<br>&gt;                             On Wed, May 25, 2016 at 8:15 PM, David Sweeris<br>&gt;                             via swift-evolution<br>&gt;                             &lt;swift-evolution at swift.org<br>&gt;                             &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;                             &lt;mailto:swift-evolution at swift.org<br>&gt;                             &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;<br>&gt;                                 On May 25, 2016, at 7:37 AM, Leonardo<br>&gt;                             Pessoa via swift-evolution<br>&gt;                                 &lt;swift-evolution at swift.org<br>&gt;                             &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;                             &lt;mailto:swift-evolution at swift.org<br>&gt;                             &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;                             wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt;                                     Hi,<br>&gt;<br>&gt;                                     Couldn&#39;t this be solved by using<br>&gt;                                 tuples? If not because the syntax<br>&gt;                                     is not allowed I think this would be<br>&gt;                                 more coherent to do it using<br>&gt;                                     current syntax.<br>&gt;<br>&gt;                                     enum Planet : (mass: Float, radius:<br>&gt;                                 Float) {<br>&gt;                                         case mercury = (mass: 3.303e+23,<br>&gt;                                 radius: 2.4397e6)<br>&gt;                                         case venus = (mass: 4.869e+24,<br>&gt;                                 radius: 6.0518e6)<br>&gt;                                         case earth = (mass: 5.976e+24,<br>&gt;                                 radius: 6.37814e6)<br>&gt;                                         case mars = (mass: 6.421e+23,<br>&gt;                                 radius: 3.3972e6)<br>&gt;                                         case jupiter = (mass: 1.9e+27,<br>&gt;                                 radius: 7.1492e7)<br>&gt;                                         case saturn = (mass: 5.688e+26,<br>&gt;                                 radius: 6.0268e7)<br>&gt;                                         case uranus = (mass: 8.686e+25,<br>&gt;                                 radius: 2.5559e7)<br>&gt;                                         case neptune = (mass: 1.024e+26,<br>&gt;                                 radius: 2.4746e7)<br>&gt;                                     }<br>&gt;<br>&gt;<br>&gt;<br>&gt;                                 This would be my preferred solution… AFAIK,<br>&gt;                             the only reason we<br>&gt;                                 can’t do it now is that Swift currently<br>&gt;                             requires RawValue be an<br>&gt;                                 integer, floating-point value, or string. I<br>&gt;                             don’t know why the<br>&gt;                                 language has this restriction, so I can’t<br>&gt;                             comment on how hard it<br>&gt;                                 would be to change.<br>&gt;<br>&gt;                                 - Dave Sweeris<br>&gt;<br>&gt;<br>&gt;                             Except you&#39;d have to write<br>&gt;                             Planet.mercury.rawValue.mass, rather than<br>&gt;                             Planet.mercury.mass.<br>&gt;<br>&gt;                             This could be one or two proposals: allow enums<br>&gt;                             with tuple RawValues,<br>&gt;                             and allow `TupleName.caseName.propertyName` to<br>&gt;                             access a tuple element<br>&gt;                             without going through .rawValue.<br>&gt;<br>&gt;<br>&gt;<br>&gt;                         Good point… Has there been a thread on allowing<br>&gt;                         raw-valued enums to be<br>&gt;                         treated as constants of type `RawValue` yet? Either<br>&gt;                         way, removing the<br>&gt;                         restriction on what types can be a RawValue is<br>&gt;                         still my preferred<br>&gt;                         solution.<br>&gt;<br>&gt;                         - Dave Sweeris<br>&gt;                         _______________________________________________<br>&gt;                         swift-evolution mailing list<br>&gt;                         swift-evolution at swift.org<br>&gt;                         &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;                         &lt;mailto:swift-evolution at swift.org<br>&gt;                         &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;                         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;                     _______________________________________________<br>&gt;                     swift-evolution mailing list<br>&gt;                     swift-evolution at swift.org<br>&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;                     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;                 _______________________________________________<br>&gt;                 swift-evolution mailing list<br>&gt;                 swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;             _______________________________________________<br>&gt;             swift-evolution mailing list<br>&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Enums with static stored propertiesforeach case</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 26, 2016 at 02:00:00pm</p></header><div class="content"><p>Java enums automatically have a static values() method that return an array with all values in an enum.<br></p><p><br>-----Original Message-----<br>From: &quot;Vladimir.S via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Sent: ‎26/‎05/‎2016 02:36 PM<br>To: &quot;Ross O&#39;Brien&quot; &lt;narrativium+swift at gmail.com&gt;<br>Cc: &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Proposal] Enums with static stored propertiesforeach case<br></p><p>On 26.05.2016 19:50, Ross O&#39;Brien wrote:<br>&gt; Perhaps there&#39;s an argument to be made for a sort of &#39;enumDictionary&#39; type<br>&gt; - a dictionary whose keys are all the cases of an enum, and is thus<br>&gt; guaranteed to produce a value.<br></p><p>In Delphi(Pascal) you can define an array with indexes of enum type i.e.:<br>type<br>   TMyEnum = (One, Two)<br>var<br>   MyVal : array[TMyEnum] of String<br>const<br>   MyConsts : array [TMyEnum] of String = (&#39;just one&#39;, &#39;two here&#39;)<br>   // compiler will check that values for each enum were specified here<br></p><p>,so you can do<br>var e: TMyEnum<br>e := One;<br>MyVal[e] := &#39;hello&#39;;<br>s2 := MyConsts[e];<br></p><p>This is really useful and used a lot. And this is safe in meaning compiler <br>will notify you if you changed the enum - you&#39;ll have to change such <br>constant array.<br></p><p>I wish we&#39;ll have something like this in Swift.<br></p><p>&gt;<br>&gt; I think the question I have is how you&#39;d access the values, syntactically.<br>&gt; To use the Planet example, if &#39;.earth&#39; is a value of the Planet enum, is<br>&gt; &#39;.earth.mass&#39; an acceptable way to access its mass? Or perhaps<br>&gt; &#39;Planet[.earth].mass&#39;?<br></p><p>Just like .rawValue currently, i.e.<br>let e = Planet.earth<br>print(e.mass, e.description)<br></p><p>&gt;<br>&gt; On Thu, May 26, 2016 at 4:43 PM, Vladimir.S via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;     Or(if we are sure we&#39;ll don&#39;t forget to udpate `infoDict` in case of<br>&gt;     new added case in future):<br>&gt;<br>&gt;     enum Planet {<br>&gt;         case earth<br>&gt;         case moon<br>&gt;<br>&gt;         struct PlanetInfo {<br>&gt;             var mass: Double<br>&gt;             var description: String<br>&gt;         }<br>&gt;<br>&gt;         private static let infoDict = [<br>&gt;             Planet.earth :<br>&gt;                 PlanetInfo(mass: 1.0, description:&quot;Earth is our home&quot;),<br>&gt;             .moon:<br>&gt;                 PlanetInfo(mass: 0.2, description:&quot;Just a moon&quot;),<br>&gt;             ]<br>&gt;<br>&gt;         var info : PlanetInfo { return Planet.infoDict[self]! }<br>&gt;     }<br>&gt;<br>&gt;     But I agree with you, IMO we need static stored properties for each case.<br>&gt;<br>&gt;<br>&gt;     On 26.05.2016 18 &lt;tel:26.05.2016%2018&gt;:15, Jānis Kiršteins wrote:<br>&gt;<br>&gt;         The problem is that PlanetInfo values are recreated each time while<br>&gt;         they are static. Imagine if PlanetInfo where some type that expensive<br>&gt;         to create performance wise.<br>&gt;<br>&gt;         You could solve it by:<br>&gt;<br>&gt;         enum Planet {<br>&gt;             struct PlanetInfo {<br>&gt;                 var mass: Double<br>&gt;                 var description: String<br>&gt;             }<br>&gt;<br>&gt;             case earth<br>&gt;             case moon<br>&gt;<br>&gt;             private static earthInfo = PlanetInfo(mass: 1.0, description:<br>&gt;         &quot;Earth is our home&quot;)<br>&gt;             private static moonInfo = PlanetInfo(mass: 0.2, description:<br>&gt;         &quot;Just a moon&quot;)<br>&gt;<br>&gt;             var info : PlanetInfo {<br>&gt;                 switch self {<br>&gt;                     case earth: return PlanetInfo.earthInfo<br>&gt;                     case moon: return PlanetInfo.moonInfo<br>&gt;                 }<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt;         But that again more verbose. The proposed solution is explicit that<br>&gt;         those properties are static for each case.<br>&gt;<br>&gt;<br>&gt;         On Thu, May 26, 2016 at 5:58 PM, Vladimir.S via swift-evolution<br>&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;             I support the proposal, but couldn&#39;t the initial target be<br>&gt;             achieved today<br>&gt;             with such (more verbose,yes) solution? :<br>&gt;<br>&gt;             enum Planet {<br>&gt;                 struct PlanetInfo {<br>&gt;                     var mass: Double<br>&gt;                     var description: String<br>&gt;                 }<br>&gt;<br>&gt;                 case earth<br>&gt;                 case moon<br>&gt;<br>&gt;                 var info : PlanetInfo {<br>&gt;                     switch self {<br>&gt;                         case earth: return PlanetInfo(mass: 1.0,<br>&gt;             description: &quot;Earth is<br>&gt;             our home&quot;)<br>&gt;                         case moon: return PlanetInfo(mass: 0.2,<br>&gt;             description: &quot;Just a<br>&gt;             moon&quot;)<br>&gt;                     }<br>&gt;                 }<br>&gt;             }<br>&gt;<br>&gt;<br>&gt;             let e = Planet.earth<br>&gt;             print(e, e.info.description)<br>&gt;<br>&gt;             let m = Planet.moon<br>&gt;             print(m, m.info.description)<br>&gt;<br>&gt;<br>&gt;<br>&gt;             On 26.05.2016 8:26, Charlie Monroe via swift-evolution wrote:<br>&gt;<br>&gt;<br>&gt;                     What this proposal is asking for is an easier way to<br>&gt;                     have derived values<br>&gt;                     from enum cases. Asking for more flexible RawValues<br>&gt;                     means mass and radius<br>&gt;                     are not derived, they are the source of truth. It goes<br>&gt;                     against the whole<br>&gt;                     point of RawRepresentable. You are not saying ‘Mercury<br>&gt;                     is identified by<br>&gt;                     the case .mercury’, you are saying ‘Mercury is<br>&gt;                     identified by a mass of<br>&gt;                     3.303e+23’. It’s backwards.<br>&gt;<br>&gt;<br>&gt;<br>&gt;                 I see what Janis meant in the first email. It&#39;s not that<br>&gt;                 the planet would<br>&gt;                 be identified by the mass or radius. It could very much be<br>&gt;<br>&gt;                 case Mercury = 1 where (mass: 3, radius: 2),<br>&gt;<br>&gt;                 - Mercury&#39;s rawValue would be 1.<br>&gt;<br>&gt;                 The issue here is that sometimes you want additional<br>&gt;                 information with the<br>&gt;                 enum. There are many cases where you extend the enum with a<br>&gt;                 variable:<br>&gt;<br>&gt;                 enum Error {<br>&gt;                 case NoError<br>&gt;                 case FileNotFound<br>&gt;                 ...<br>&gt;<br>&gt;                 var isFatal: Bool {<br>&gt;                 /// swtich over all values of self goes here.<br>&gt;                 }<br>&gt;<br>&gt;                 var isNetworkError: Bool {<br>&gt;                 /// swtich over all values of self goes here.<br>&gt;                 }<br>&gt;<br>&gt;                 var isIOError: Bool {<br>&gt;                 /// swtich over all values of self goes here.<br>&gt;                 }<br>&gt;                 }<br>&gt;<br>&gt;                 What the propsal suggests is to simplify this to the following:<br>&gt;<br>&gt;                 enum Error {<br>&gt;                 var isFatal: Bool<br>&gt;<br>&gt;                 case NoError where (isFatal: false, isNetworkError: false,<br>&gt;                 isIOError:<br>&gt;                 false)<br>&gt;                 case FileNotFound  where (isFatal: true, isNetworkError:<br>&gt;                 false, isIOError:<br>&gt;                 true)<br>&gt;                 ...<br>&gt;<br>&gt;                 }<br>&gt;<br>&gt;                 So that you assign the additional information to the enum<br>&gt;                 value itself.<br>&gt;<br>&gt;                 Charlie<br>&gt;<br>&gt;<br>&gt;<br>&gt;                         On 26 May 2016, at 1:47 PM, David Sweeris via<br>&gt;                         swift-evolution<br>&gt;                         &lt;swift-evolution at swift.org<br>&gt;                         &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;                         &lt;mailto:swift-evolution at swift.org<br>&gt;                         &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt;                             On May 25, 2016, at 10:27 PM, Jacob<br>&gt;                             Bandes-Storch &lt;jtbandes at gmail.com<br>&gt;                             &lt;mailto:jtbandes at gmail.com&gt;<br>&gt;                             &lt;mailto:jtbandes at gmail.com<br>&gt;                             &lt;mailto:jtbandes at gmail.com&gt;&gt;&gt; wrote:<br>&gt;<br>&gt;                             On Wed, May 25, 2016 at 8:15 PM, David Sweeris<br>&gt;                             via swift-evolution<br>&gt;                             &lt;swift-evolution at swift.org<br>&gt;                             &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;                             &lt;mailto:swift-evolution at swift.org<br>&gt;                             &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;<br>&gt;                                 On May 25, 2016, at 7:37 AM, Leonardo<br>&gt;                             Pessoa via swift-evolution<br>&gt;                                 &lt;swift-evolution at swift.org<br>&gt;                             &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;                             &lt;mailto:swift-evolution at swift.org<br>&gt;                             &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;                             wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt;                                     Hi,<br>&gt;<br>&gt;                                     Couldn&#39;t this be solved by using<br>&gt;                                 tuples? If not because the syntax<br>&gt;                                     is not allowed I think this would be<br>&gt;                                 more coherent to do it using<br>&gt;                                     current syntax.<br>&gt;<br>&gt;                                     enum Planet : (mass: Float, radius:<br>&gt;                                 Float) {<br>&gt;                                         case mercury = (mass: 3.303e+23,<br>&gt;                                 radius: 2.4397e6)<br>&gt;                                         case venus = (mass: 4.869e+24,<br>&gt;                                 radius: 6.0518e6)<br>&gt;                                         case earth = (mass: 5.976e+24,<br>&gt;                                 radius: 6.37814e6)<br>&gt;                                         case mars = (mass: 6.421e+23,<br>&gt;                                 radius: 3.3972e6)<br>&gt;                                         case jupiter = (mass: 1.9e+27,<br>&gt;                                 radius: 7.1492e7)<br>&gt;                                         case saturn = (mass: 5.688e+26,<br>&gt;                                 radius: 6.0268e7)<br>&gt;                                         case uranus = (mass: 8.686e+25,<br>&gt;                                 radius: 2.5559e7)<br>&gt;                                         case neptune = (mass: 1.024e+26,<br>&gt;                                 radius: 2.4746e7)<br>&gt;                                     }<br>&gt;<br>&gt;<br>&gt;<br>&gt;                                 This would be my preferred solution… AFAIK,<br>&gt;                             the only reason we<br>&gt;                                 can’t do it now is that Swift currently<br>&gt;                             requires RawValue be an<br>&gt;                                 integer, floating-point value, or string. I<br>&gt;                             don’t know why the<br>&gt;                                 language has this restriction, so I can’t<br>&gt;                             comment on how hard it<br>&gt;                                 would be to change.<br>&gt;<br>&gt;                                 - Dave Sweeris<br>&gt;<br>&gt;<br>&gt;                             Except you&#39;d have to write<br>&gt;                             Planet.mercury.rawValue.mass, rather than<br>&gt;                             Planet.mercury.mass.<br>&gt;<br>&gt;                             This could be one or two proposals: allow enums<br>&gt;                             with tuple RawValues,<br>&gt;                             and allow `TupleName.caseName.propertyName` to<br>&gt;                             access a tuple element<br>&gt;                             without going through .rawValue.<br>&gt;<br>&gt;<br>&gt;<br>&gt;                         Good point… Has there been a thread on allowing<br>&gt;                         raw-valued enums to be<br>&gt;                         treated as constants of type `RawValue` yet? Either<br>&gt;                         way, removing the<br>&gt;                         restriction on what types can be a RawValue is<br>&gt;                         still my preferred<br>&gt;                         solution.<br>&gt;<br>&gt;                         - Dave Sweeris<br>&gt;                         _______________________________________________<br>&gt;                         swift-evolution mailing list<br>&gt;                         swift-evolution at swift.org<br>&gt;                         &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;                         &lt;mailto:swift-evolution at swift.org<br>&gt;                         &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;                         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;                     _______________________________________________<br>&gt;                     swift-evolution mailing list<br>&gt;                     swift-evolution at swift.org<br>&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;                     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;                 _______________________________________________<br>&gt;                 swift-evolution mailing list<br>&gt;                 swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;             _______________________________________________<br>&gt;             swift-evolution mailing list<br>&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/3d345867/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] Enums with static stored propertiesforeach case</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 26, 2016 at 09:00:00pm</p></header><div class="content"><p>Yes, this was mentioned in a similar thread in this email list earlier. <br>There is even some proposal for such .values() for Swift enums.<br></p><p>But this values() in Java is not the same thing as discussed dictionary <br>with *keys* of enum type or Delphi&#39;s arrays with *index* of enum type.<br></p><p>Could you write Java&#39;s example for array/dictionary of String which <br>*index*(or key) will be of enum type? *And* compiler will check that value <br>for each enum case is set in case of array of constants like:<br>MyConsts : array [TMyEnum] of String = (&#39;just one&#39;, &#39;two here&#39;)<br>// compiler will always check that value assigned for each case<br></p><p><br>On 26.05.2016 20:58, Leonardo Pessoa wrote:<br>&gt; Java enums automatically have a static values() method that return an array<br>&gt; with all values in an enum.<br>&gt; ---------------------------------------------------------------------------<br>&gt; From: Vladimir.S via swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; Sent: ‎26/‎05/‎2016 02:36 PM<br>&gt; To: Ross O&#39;Brien &lt;mailto:narrativium+swift at gmail.com&gt;<br>&gt; Cc: swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Proposal] Enums with static stored<br>&gt; propertiesforeach case<br>&gt;<br>&gt; On 26.05.2016 19:50, Ross O&#39;Brien wrote:<br>&gt;&gt; Perhaps there&#39;s an argument to be made for a sort of &#39;enumDictionary&#39; type<br>&gt;&gt; - a dictionary whose keys are all the cases of an enum, and is thus<br>&gt;&gt; guaranteed to produce a value.<br>&gt;<br>&gt; In Delphi(Pascal) you can define an array with indexes of enum type i.e.:<br>&gt; type<br>&gt;    TMyEnum = (One, Two)<br>&gt; var<br>&gt;    MyVal : array[TMyEnum] of String<br>&gt; const<br>&gt;    MyConsts : array [TMyEnum] of String = (&#39;just one&#39;, &#39;two here&#39;)<br>&gt;    // compiler will check that values for each enum were specified here<br>&gt;<br>&gt; ,so you can do<br>&gt; var e: TMyEnum<br>&gt; e := One;<br>&gt; MyVal[e] := &#39;hello&#39;;<br>&gt; s2 := MyConsts[e];<br>&gt;<br>&gt; This is really useful and used a lot. And this is safe in meaning compiler<br>&gt; will notify you if you changed the enum - you&#39;ll have to change such<br>&gt; constant array.<br>&gt;<br>&gt; I wish we&#39;ll have something like this in Swift.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; I think the question I have is how you&#39;d access the values, syntactically.<br>&gt;&gt; To use the Planet example, if &#39;.earth&#39; is a value of the Planet enum, is<br>&gt;&gt; &#39;.earth.mass&#39; an acceptable way to access its mass? Or perhaps<br>&gt;&gt; &#39;Planet[.earth].mass&#39;?<br>&gt;<br>&gt; Just like .rawValue currently, i.e.<br>&gt; let e = Planet.earth<br>&gt; print(e.mass, e.description)<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Thu, May 26, 2016 at 4:43 PM, Vladimir.S via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     Or(if we are sure we&#39;ll don&#39;t forget to udpate `infoDict` in case of<br>&gt;&gt;     new added case in future):<br>&gt;&gt;<br>&gt;&gt;     enum Planet {<br>&gt;&gt;         case earth<br>&gt;&gt;         case moon<br>&gt;&gt;<br>&gt;&gt;         struct PlanetInfo {<br>&gt;&gt;             var mass: Double<br>&gt;&gt;             var description: String<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         private static let infoDict = [<br>&gt;&gt;             Planet.earth :<br>&gt;&gt;                 PlanetInfo(mass: 1.0, description:&quot;Earth is our home&quot;),<br>&gt;&gt;             .moon:<br>&gt;&gt;                 PlanetInfo(mass: 0.2, description:&quot;Just a moon&quot;),<br>&gt;&gt;             ]<br>&gt;&gt;<br>&gt;&gt;         var info : PlanetInfo { return Planet.infoDict[self]! }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     But I agree with you, IMO we need static stored properties for each case.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     On 26.05.2016 18 &lt;tel:26.05.2016%2018&gt;:15, Jānis Kiršteins wrote:<br>&gt;&gt;<br>&gt;&gt;         The problem is that PlanetInfo values are recreated each time while<br>&gt;&gt;         they are static. Imagine if PlanetInfo where some type that expensive<br>&gt;&gt;         to create performance wise.<br>&gt;&gt;<br>&gt;&gt;         You could solve it by:<br>&gt;&gt;<br>&gt;&gt;         enum Planet {<br>&gt;&gt;             struct PlanetInfo {<br>&gt;&gt;                 var mass: Double<br>&gt;&gt;                 var description: String<br>&gt;&gt;             }<br>&gt;&gt;<br>&gt;&gt;             case earth<br>&gt;&gt;             case moon<br>&gt;&gt;<br>&gt;&gt;             private static earthInfo = PlanetInfo(mass: 1.0, description:<br>&gt;&gt;         &quot;Earth is our home&quot;)<br>&gt;&gt;             private static moonInfo = PlanetInfo(mass: 0.2, description:<br>&gt;&gt;         &quot;Just a moon&quot;)<br>&gt;&gt;<br>&gt;&gt;             var info : PlanetInfo {<br>&gt;&gt;                 switch self {<br>&gt;&gt;                     case earth: return PlanetInfo.earthInfo<br>&gt;&gt;                     case moon: return PlanetInfo.moonInfo<br>&gt;&gt;                 }<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         But that again more verbose. The proposed solution is explicit that<br>&gt;&gt;         those properties are static for each case.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         On Thu, May 26, 2016 at 5:58 PM, Vladimir.S via swift-evolution<br>&gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;             I support the proposal, but couldn&#39;t the initial target be<br>&gt;&gt;             achieved today<br>&gt;&gt;             with such (more verbose,yes) solution? :<br>&gt;&gt;<br>&gt;&gt;             enum Planet {<br>&gt;&gt;                 struct PlanetInfo {<br>&gt;&gt;                     var mass: Double<br>&gt;&gt;                     var description: String<br>&gt;&gt;                 }<br>&gt;&gt;<br>&gt;&gt;                 case earth<br>&gt;&gt;                 case moon<br>&gt;&gt;<br>&gt;&gt;                 var info : PlanetInfo {<br>&gt;&gt;                     switch self {<br>&gt;&gt;                         case earth: return PlanetInfo(mass: 1.0,<br>&gt;&gt;             description: &quot;Earth is<br>&gt;&gt;             our home&quot;)<br>&gt;&gt;                         case moon: return PlanetInfo(mass: 0.2,<br>&gt;&gt;             description: &quot;Just a<br>&gt;&gt;             moon&quot;)<br>&gt;&gt;                     }<br>&gt;&gt;                 }<br>&gt;&gt;             }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;             let e = Planet.earth<br>&gt;&gt;             print(e, e.info.description)<br>&gt;&gt;<br>&gt;&gt;             let m = Planet.moon<br>&gt;&gt;             print(m, m.info.description)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;             On 26.05.2016 8:26, Charlie Monroe via swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                     What this proposal is asking for is an easier way to<br>&gt;&gt;                     have derived values<br>&gt;&gt;                     from enum cases. Asking for more flexible RawValues<br>&gt;&gt;                     means mass and radius<br>&gt;&gt;                     are not derived, they are the source of truth. It goes<br>&gt;&gt;                     against the whole<br>&gt;&gt;                     point of RawRepresentable. You are not saying ‘Mercury<br>&gt;&gt;                     is identified by<br>&gt;&gt;                     the case .mercury’, you are saying ‘Mercury is<br>&gt;&gt;                     identified by a mass of<br>&gt;&gt;                     3.303e+23’. It’s backwards.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                 I see what Janis meant in the first email. It&#39;s not that<br>&gt;&gt;                 the planet would<br>&gt;&gt;                 be identified by the mass or radius. It could very much be<br>&gt;&gt;<br>&gt;&gt;                 case Mercury = 1 where (mass: 3, radius: 2),<br>&gt;&gt;<br>&gt;&gt;                 - Mercury&#39;s rawValue would be 1.<br>&gt;&gt;<br>&gt;&gt;                 The issue here is that sometimes you want additional<br>&gt;&gt;                 information with the<br>&gt;&gt;                 enum. There are many cases where you extend the enum with a<br>&gt;&gt;                 variable:<br>&gt;&gt;<br>&gt;&gt;                 enum Error {<br>&gt;&gt;                 case NoError<br>&gt;&gt;                 case FileNotFound<br>&gt;&gt;                 ...<br>&gt;&gt;<br>&gt;&gt;                 var isFatal: Bool {<br>&gt;&gt;                 /// swtich over all values of self goes here.<br>&gt;&gt;                 }<br>&gt;&gt;<br>&gt;&gt;                 var isNetworkError: Bool {<br>&gt;&gt;                 /// swtich over all values of self goes here.<br>&gt;&gt;                 }<br>&gt;&gt;<br>&gt;&gt;                 var isIOError: Bool {<br>&gt;&gt;                 /// swtich over all values of self goes here.<br>&gt;&gt;                 }<br>&gt;&gt;                 }<br>&gt;&gt;<br>&gt;&gt;                 What the propsal suggests is to simplify this to the<br>&gt; following:<br>&gt;&gt;<br>&gt;&gt;                 enum Error {<br>&gt;&gt;                 var isFatal: Bool<br>&gt;&gt;<br>&gt;&gt;                 case NoError where (isFatal: false, isNetworkError: false,<br>&gt;&gt;                 isIOError:<br>&gt;&gt;                 false)<br>&gt;&gt;                 case FileNotFound  where (isFatal: true, isNetworkError:<br>&gt;&gt;                 false, isIOError:<br>&gt;&gt;                 true)<br>&gt;&gt;                 ...<br>&gt;&gt;<br>&gt;&gt;                 }<br>&gt;&gt;<br>&gt;&gt;                 So that you assign the additional information to the enum<br>&gt;&gt;                 value itself.<br>&gt;&gt;<br>&gt;&gt;                 Charlie<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                         On 26 May 2016, at 1:47 PM, David Sweeris via<br>&gt;&gt;                         swift-evolution<br>&gt;&gt;                         &lt;swift-evolution at swift.org<br>&gt;&gt;                         &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;                         &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;                         &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                             On May 25, 2016, at 10:27 PM, Jacob<br>&gt;&gt;                             Bandes-Storch &lt;jtbandes at gmail.com<br>&gt;&gt;                             &lt;mailto:jtbandes at gmail.com&gt;<br>&gt;&gt;                             &lt;mailto:jtbandes at gmail.com<br>&gt;&gt;                             &lt;mailto:jtbandes at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;                             On Wed, May 25, 2016 at 8:15 PM, David Sweeris<br>&gt;&gt;                             via swift-evolution<br>&gt;&gt;                             &lt;swift-evolution at swift.org<br>&gt;&gt;                             &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;                             &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;                             &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;                                 On May 25, 2016, at 7:37 AM, Leonardo<br>&gt;&gt;                             Pessoa via swift-evolution<br>&gt;&gt;                                 &lt;swift-evolution at swift.org<br>&gt;&gt;                             &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;                             &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;                             &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;                             wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                                     Hi,<br>&gt;&gt;<br>&gt;&gt;                                     Couldn&#39;t this be solved by using<br>&gt;&gt;                                 tuples? If not because the syntax<br>&gt;&gt;                                     is not allowed I think this would be<br>&gt;&gt;                                 more coherent to do it using<br>&gt;&gt;                                     current syntax.<br>&gt;&gt;<br>&gt;&gt;                                     enum Planet : (mass: Float, radius:<br>&gt;&gt;                                 Float) {<br>&gt;&gt;                                         case mercury = (mass: 3.303e+23,<br>&gt;&gt;                                 radius: 2.4397e6)<br>&gt;&gt;                                         case venus = (mass: 4.869e+24,<br>&gt;&gt;                                 radius: 6.0518e6)<br>&gt;&gt;                                         case earth = (mass: 5.976e+24,<br>&gt;&gt;                                 radius: 6.37814e6)<br>&gt;&gt;                                         case mars = (mass: 6.421e+23,<br>&gt;&gt;                                 radius: 3.3972e6)<br>&gt;&gt;                                         case jupiter = (mass: 1.9e+27,<br>&gt;&gt;                                 radius: 7.1492e7)<br>&gt;&gt;                                         case saturn = (mass: 5.688e+26,<br>&gt;&gt;                                 radius: 6.0268e7)<br>&gt;&gt;                                         case uranus = (mass: 8.686e+25,<br>&gt;&gt;                                 radius: 2.5559e7)<br>&gt;&gt;                                         case neptune = (mass: 1.024e+26,<br>&gt;&gt;                                 radius: 2.4746e7)<br>&gt;&gt;                                     }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                                 This would be my preferred solution… AFAIK,<br>&gt;&gt;                             the only reason we<br>&gt;&gt;                                 can’t do it now is that Swift currently<br>&gt;&gt;                             requires RawValue be an<br>&gt;&gt;                                 integer, floating-point value, or string. I<br>&gt;&gt;                             don’t know why the<br>&gt;&gt;                                 language has this restriction, so I can’t<br>&gt;&gt;                             comment on how hard it<br>&gt;&gt;                                 would be to change.<br>&gt;&gt;<br>&gt;&gt;                                 - Dave Sweeris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                             Except you&#39;d have to write<br>&gt;&gt;                             Planet.mercury.rawValue.mass, rather than<br>&gt;&gt;                             Planet.mercury.mass.<br>&gt;&gt;<br>&gt;&gt;                             This could be one or two proposals: allow enums<br>&gt;&gt;                             with tuple RawValues,<br>&gt;&gt;                             and allow `TupleName.caseName.propertyName` to<br>&gt;&gt;                             access a tuple element<br>&gt;&gt;                             without going through .rawValue.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                         Good point… Has there been a thread on allowing<br>&gt;&gt;                         raw-valued enums to be<br>&gt;&gt;                         treated as constants of type `RawValue` yet? Either<br>&gt;&gt;                         way, removing the<br>&gt;&gt;                         restriction on what types can be a RawValue is<br>&gt;&gt;                         still my preferred<br>&gt;&gt;                         solution.<br>&gt;&gt;<br>&gt;&gt;                         - Dave Sweeris<br>&gt;&gt;                         _______________________________________________<br>&gt;&gt;                         swift-evolution mailing list<br>&gt;&gt;                         swift-evolution at swift.org<br>&gt;&gt;                         &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;                         &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;                         &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                     _______________________________________________<br>&gt;&gt;                     swift-evolution mailing list<br>&gt;&gt;                     swift-evolution at swift.org<br>&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;                     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                 _______________________________________________<br>&gt;&gt;                 swift-evolution mailing list<br>&gt;&gt;                 swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;             _______________________________________________<br>&gt;&gt;             swift-evolution mailing list<br>&gt;&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     _______________________________________________<br>&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal] Enums with static stored propertiesforeach case</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 26, 2016 at 08:00:00pm</p></header><div class="content"><p>Now thinking about this, what would solve this partially is being discussed in another topic here - sealed clasees.<br></p><p>Each planet would have its own class and the superclass Planet would be abstract sealed. You would then be able to do an effective switch on the instance of the planet, which would act like an enum.<br></p><p>&gt; On May 26, 2016, at 8:06 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yes, this was mentioned in a similar thread in this email list earlier. There is even some proposal for such .values() for Swift enums.<br>&gt; <br>&gt; But this values() in Java is not the same thing as discussed dictionary with *keys* of enum type or Delphi&#39;s arrays with *index* of enum type.<br>&gt; <br>&gt; Could you write Java&#39;s example for array/dictionary of String which *index*(or key) will be of enum type? *And* compiler will check that value for each enum case is set in case of array of constants like:<br>&gt; MyConsts : array [TMyEnum] of String = (&#39;just one&#39;, &#39;two here&#39;)<br>&gt; // compiler will always check that value assigned for each case<br>&gt; <br>&gt; <br>&gt; On 26.05.2016 20:58, Leonardo Pessoa wrote:<br>&gt;&gt; Java enums automatically have a static values() method that return an array<br>&gt;&gt; with all values in an enum.<br>&gt;&gt; ---------------------------------------------------------------------------<br>&gt;&gt; From: Vladimir.S via swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; Sent: ‎26/‎05/‎2016 02:36 PM<br>&gt;&gt; To: Ross O&#39;Brien &lt;mailto:narrativium+swift at gmail.com&gt;<br>&gt;&gt; Cc: swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; Subject: Re: [swift-evolution] [Proposal] Enums with static stored<br>&gt;&gt; propertiesforeach case<br>&gt;&gt; <br>&gt;&gt; On 26.05.2016 19:50, Ross O&#39;Brien wrote:<br>&gt;&gt;&gt; Perhaps there&#39;s an argument to be made for a sort of &#39;enumDictionary&#39; type<br>&gt;&gt;&gt; - a dictionary whose keys are all the cases of an enum, and is thus<br>&gt;&gt;&gt; guaranteed to produce a value.<br>&gt;&gt; <br>&gt;&gt; In Delphi(Pascal) you can define an array with indexes of enum type i.e.:<br>&gt;&gt; type<br>&gt;&gt;   TMyEnum = (One, Two)<br>&gt;&gt; var<br>&gt;&gt;   MyVal : array[TMyEnum] of String<br>&gt;&gt; const<br>&gt;&gt;   MyConsts : array [TMyEnum] of String = (&#39;just one&#39;, &#39;two here&#39;)<br>&gt;&gt;   // compiler will check that values for each enum were specified here<br>&gt;&gt; <br>&gt;&gt; ,so you can do<br>&gt;&gt; var e: TMyEnum<br>&gt;&gt; e := One;<br>&gt;&gt; MyVal[e] := &#39;hello&#39;;<br>&gt;&gt; s2 := MyConsts[e];<br>&gt;&gt; <br>&gt;&gt; This is really useful and used a lot. And this is safe in meaning compiler<br>&gt;&gt; will notify you if you changed the enum - you&#39;ll have to change such<br>&gt;&gt; constant array.<br>&gt;&gt; <br>&gt;&gt; I wish we&#39;ll have something like this in Swift.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the question I have is how you&#39;d access the values, syntactically.<br>&gt;&gt;&gt; To use the Planet example, if &#39;.earth&#39; is a value of the Planet enum, is<br>&gt;&gt;&gt; &#39;.earth.mass&#39; an acceptable way to access its mass? Or perhaps<br>&gt;&gt;&gt; &#39;Planet[.earth].mass&#39;?<br>&gt;&gt; <br>&gt;&gt; Just like .rawValue currently, i.e.<br>&gt;&gt; let e = Planet.earth<br>&gt;&gt; print(e.mass, e.description)<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, May 26, 2016 at 4:43 PM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Or(if we are sure we&#39;ll don&#39;t forget to udpate `infoDict` in case of<br>&gt;&gt;&gt;    new added case in future):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    enum Planet {<br>&gt;&gt;&gt;        case earth<br>&gt;&gt;&gt;        case moon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        struct PlanetInfo {<br>&gt;&gt;&gt;            var mass: Double<br>&gt;&gt;&gt;            var description: String<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        private static let infoDict = [<br>&gt;&gt;&gt;            Planet.earth :<br>&gt;&gt;&gt;                PlanetInfo(mass: 1.0, description:&quot;Earth is our home&quot;),<br>&gt;&gt;&gt;            .moon:<br>&gt;&gt;&gt;                PlanetInfo(mass: 0.2, description:&quot;Just a moon&quot;),<br>&gt;&gt;&gt;            ]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        var info : PlanetInfo { return Planet.infoDict[self]! }<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    But I agree with you, IMO we need static stored properties for each case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    On 26.05.2016 18 &lt;tel:26.05.2016%2018&gt;:15, Jānis Kiršteins wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        The problem is that PlanetInfo values are recreated each time while<br>&gt;&gt;&gt;        they are static. Imagine if PlanetInfo where some type that expensive<br>&gt;&gt;&gt;        to create performance wise.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        You could solve it by:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        enum Planet {<br>&gt;&gt;&gt;            struct PlanetInfo {<br>&gt;&gt;&gt;                var mass: Double<br>&gt;&gt;&gt;                var description: String<br>&gt;&gt;&gt;            }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            case earth<br>&gt;&gt;&gt;            case moon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            private static earthInfo = PlanetInfo(mass: 1.0, description:<br>&gt;&gt;&gt;        &quot;Earth is our home&quot;)<br>&gt;&gt;&gt;            private static moonInfo = PlanetInfo(mass: 0.2, description:<br>&gt;&gt;&gt;        &quot;Just a moon&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            var info : PlanetInfo {<br>&gt;&gt;&gt;                switch self {<br>&gt;&gt;&gt;                    case earth: return PlanetInfo.earthInfo<br>&gt;&gt;&gt;                    case moon: return PlanetInfo.moonInfo<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt;            }<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        But that again more verbose. The proposed solution is explicit that<br>&gt;&gt;&gt;        those properties are static for each case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        On Thu, May 26, 2016 at 5:58 PM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;        &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            I support the proposal, but couldn&#39;t the initial target be<br>&gt;&gt;&gt;            achieved today<br>&gt;&gt;&gt;            with such (more verbose,yes) solution? :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            enum Planet {<br>&gt;&gt;&gt;                struct PlanetInfo {<br>&gt;&gt;&gt;                    var mass: Double<br>&gt;&gt;&gt;                    var description: String<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                case earth<br>&gt;&gt;&gt;                case moon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                var info : PlanetInfo {<br>&gt;&gt;&gt;                    switch self {<br>&gt;&gt;&gt;                        case earth: return PlanetInfo(mass: 1.0,<br>&gt;&gt;&gt;            description: &quot;Earth is<br>&gt;&gt;&gt;            our home&quot;)<br>&gt;&gt;&gt;                        case moon: return PlanetInfo(mass: 0.2,<br>&gt;&gt;&gt;            description: &quot;Just a<br>&gt;&gt;&gt;            moon&quot;)<br>&gt;&gt;&gt;                    }<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt;            }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            let e = Planet.earth<br>&gt;&gt;&gt;            print(e, e.info.description)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            let m = Planet.moon<br>&gt;&gt;&gt;            print(m, m.info.description)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            On 26.05.2016 8:26, Charlie Monroe via swift-evolution wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                    What this proposal is asking for is an easier way to<br>&gt;&gt;&gt;                    have derived values<br>&gt;&gt;&gt;                    from enum cases. Asking for more flexible RawValues<br>&gt;&gt;&gt;                    means mass and radius<br>&gt;&gt;&gt;                    are not derived, they are the source of truth. It goes<br>&gt;&gt;&gt;                    against the whole<br>&gt;&gt;&gt;                    point of RawRepresentable. You are not saying ‘Mercury<br>&gt;&gt;&gt;                    is identified by<br>&gt;&gt;&gt;                    the case .mercury’, you are saying ‘Mercury is<br>&gt;&gt;&gt;                    identified by a mass of<br>&gt;&gt;&gt;                    3.303e+23’. It’s backwards.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                I see what Janis meant in the first email. It&#39;s not that<br>&gt;&gt;&gt;                the planet would<br>&gt;&gt;&gt;                be identified by the mass or radius. It could very much be<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                case Mercury = 1 where (mass: 3, radius: 2),<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                - Mercury&#39;s rawValue would be 1.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                The issue here is that sometimes you want additional<br>&gt;&gt;&gt;                information with the<br>&gt;&gt;&gt;                enum. There are many cases where you extend the enum with a<br>&gt;&gt;&gt;                variable:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                enum Error {<br>&gt;&gt;&gt;                case NoError<br>&gt;&gt;&gt;                case FileNotFound<br>&gt;&gt;&gt;                ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                var isFatal: Bool {<br>&gt;&gt;&gt;                /// swtich over all values of self goes here.<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                var isNetworkError: Bool {<br>&gt;&gt;&gt;                /// swtich over all values of self goes here.<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                var isIOError: Bool {<br>&gt;&gt;&gt;                /// swtich over all values of self goes here.<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                What the propsal suggests is to simplify this to the<br>&gt;&gt; following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                enum Error {<br>&gt;&gt;&gt;                var isFatal: Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                case NoError where (isFatal: false, isNetworkError: false,<br>&gt;&gt;&gt;                isIOError:<br>&gt;&gt;&gt;                false)<br>&gt;&gt;&gt;                case FileNotFound  where (isFatal: true, isNetworkError:<br>&gt;&gt;&gt;                false, isIOError:<br>&gt;&gt;&gt;                true)<br>&gt;&gt;&gt;                ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                So that you assign the additional information to the enum<br>&gt;&gt;&gt;                value itself.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                Charlie<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                        On 26 May 2016, at 1:47 PM, David Sweeris via<br>&gt;&gt;&gt;                        swift-evolution<br>&gt;&gt;&gt;                        &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;                        &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                        &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;                        &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                            On May 25, 2016, at 10:27 PM, Jacob<br>&gt;&gt;&gt;                            Bandes-Storch &lt;jtbandes at gmail.com<br>&gt;&gt;&gt;                            &lt;mailto:jtbandes at gmail.com&gt;<br>&gt;&gt;&gt;                            &lt;mailto:jtbandes at gmail.com<br>&gt;&gt;&gt;                            &lt;mailto:jtbandes at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                            On Wed, May 25, 2016 at 8:15 PM, David Sweeris<br>&gt;&gt;&gt;                            via swift-evolution<br>&gt;&gt;&gt;                            &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;                            &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                            &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;                            &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                                On May 25, 2016, at 7:37 AM, Leonardo<br>&gt;&gt;&gt;                            Pessoa via swift-evolution<br>&gt;&gt;&gt;                                &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;                            &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                            &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;                            &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;                            wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                                    Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                                    Couldn&#39;t this be solved by using<br>&gt;&gt;&gt;                                tuples? If not because the syntax<br>&gt;&gt;&gt;                                    is not allowed I think this would be<br>&gt;&gt;&gt;                                more coherent to do it using<br>&gt;&gt;&gt;                                    current syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                                    enum Planet : (mass: Float, radius:<br>&gt;&gt;&gt;                                Float) {<br>&gt;&gt;&gt;                                        case mercury = (mass: 3.303e+23,<br>&gt;&gt;&gt;                                radius: 2.4397e6)<br>&gt;&gt;&gt;                                        case venus = (mass: 4.869e+24,<br>&gt;&gt;&gt;                                radius: 6.0518e6)<br>&gt;&gt;&gt;                                        case earth = (mass: 5.976e+24,<br>&gt;&gt;&gt;                                radius: 6.37814e6)<br>&gt;&gt;&gt;                                        case mars = (mass: 6.421e+23,<br>&gt;&gt;&gt;                                radius: 3.3972e6)<br>&gt;&gt;&gt;                                        case jupiter = (mass: 1.9e+27,<br>&gt;&gt;&gt;                                radius: 7.1492e7)<br>&gt;&gt;&gt;                                        case saturn = (mass: 5.688e+26,<br>&gt;&gt;&gt;                                radius: 6.0268e7)<br>&gt;&gt;&gt;                                        case uranus = (mass: 8.686e+25,<br>&gt;&gt;&gt;                                radius: 2.5559e7)<br>&gt;&gt;&gt;                                        case neptune = (mass: 1.024e+26,<br>&gt;&gt;&gt;                                radius: 2.4746e7)<br>&gt;&gt;&gt;                                    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                                This would be my preferred solution… AFAIK,<br>&gt;&gt;&gt;                            the only reason we<br>&gt;&gt;&gt;                                can’t do it now is that Swift currently<br>&gt;&gt;&gt;                            requires RawValue be an<br>&gt;&gt;&gt;                                integer, floating-point value, or string. I<br>&gt;&gt;&gt;                            don’t know why the<br>&gt;&gt;&gt;                                language has this restriction, so I can’t<br>&gt;&gt;&gt;                            comment on how hard it<br>&gt;&gt;&gt;                                would be to change.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                                - Dave Sweeris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                            Except you&#39;d have to write<br>&gt;&gt;&gt;                            Planet.mercury.rawValue.mass, rather than<br>&gt;&gt;&gt;                            Planet.mercury.mass.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                            This could be one or two proposals: allow enums<br>&gt;&gt;&gt;                            with tuple RawValues,<br>&gt;&gt;&gt;                            and allow `TupleName.caseName.propertyName` to<br>&gt;&gt;&gt;                            access a tuple element<br>&gt;&gt;&gt;                            without going through .rawValue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                        Good point… Has there been a thread on allowing<br>&gt;&gt;&gt;                        raw-valued enums to be<br>&gt;&gt;&gt;                        treated as constants of type `RawValue` yet? Either<br>&gt;&gt;&gt;                        way, removing the<br>&gt;&gt;&gt;                        restriction on what types can be a RawValue is<br>&gt;&gt;&gt;                        still my preferred<br>&gt;&gt;&gt;                        solution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                        - Dave Sweeris<br>&gt;&gt;&gt;                        _______________________________________________<br>&gt;&gt;&gt;                        swift-evolution mailing list<br>&gt;&gt;&gt;                        swift-evolution at swift.org<br>&gt;&gt;&gt;                        &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                        &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;                        &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                    _______________________________________________<br>&gt;&gt;&gt;                    swift-evolution mailing list<br>&gt;&gt;&gt;                    swift-evolution at swift.org<br>&gt;&gt;&gt;                    &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                    &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;                    &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;                    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                _______________________________________________<br>&gt;&gt;&gt;                swift-evolution mailing list<br>&gt;&gt;&gt;                swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            _______________________________________________<br>&gt;&gt;&gt;            swift-evolution mailing list<br>&gt;&gt;&gt;            swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;            https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    _______________________________________________<br>&gt;&gt;&gt;    swift-evolution mailing list<br>&gt;&gt;&gt;    swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Enums with static storedpropertiesforeach case</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 26, 2016 at 04:00:00pm</p></header><div class="content"><p>I think these are different concepts. Classes and structs are abstractions for something (think of them as empty forms while instances are filled forms) while enums identify a closed set of values (filled forms) known ahead of use. Sealed classes are intended to limit extensions to a class not to the instances that can be created.<br></p><p><br></p><p>-----Original Message-----<br>From: &quot;Charlie Monroe&quot; &lt;charlie at charliemonroe.net&gt;<br>Sent: ‎26/‎05/‎2016 03:13 PM<br>To: &quot;Vladimir.S&quot; &lt;svabox at gmail.com&gt;<br>Cc: &quot;Leonardo Pessoa&quot; &lt;me at lmpessoa.com&gt;; &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Proposal] Enums with static storedpropertiesforeach case<br></p><p>Now thinking about this, what would solve this partially is being discussed in another topic here - sealed clasees.<br></p><p>Each planet would have its own class and the superclass Planet would be abstract sealed. You would then be able to do an effective switch on the instance of the planet, which would act like an enum.<br></p><p>&gt; On May 26, 2016, at 8:06 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yes, this was mentioned in a similar thread in this email list earlier. There is even some proposal for such .values() for Swift enums.<br>&gt; <br>&gt; But this values() in Java is not the same thing as discussed dictionary with *keys* of enum type or Delphi&#39;s arrays with *index* of enum type.<br>&gt; <br>&gt; Could you write Java&#39;s example for array/dictionary of String which *index*(or key) will be of enum type? *And* compiler will check that value for each enum case is set in case of array of constants like:<br>&gt; MyConsts : array [TMyEnum] of String = (&#39;just one&#39;, &#39;two here&#39;)<br>&gt; // compiler will always check that value assigned for each case<br>&gt; <br>&gt; <br>&gt; On 26.05.2016 20:58, Leonardo Pessoa wrote:<br>&gt;&gt; Java enums automatically have a static values() method that return an array<br>&gt;&gt; with all values in an enum.<br>&gt;&gt; ---------------------------------------------------------------------------<br>&gt;&gt; From: Vladimir.S via swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; Sent: ‎26/‎05/‎2016 02:36 PM<br>&gt;&gt; To: Ross O&#39;Brien &lt;mailto:narrativium+swift at gmail.com&gt;<br>&gt;&gt; Cc: swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; Subject: Re: [swift-evolution] [Proposal] Enums with static stored<br>&gt;&gt; propertiesforeach case<br>&gt;&gt; <br>&gt;&gt; On 26.05.2016 19:50, Ross O&#39;Brien wrote:<br>&gt;&gt;&gt; Perhaps there&#39;s an argument to be made for a sort of &#39;enumDictionary&#39; type<br>&gt;&gt;&gt; - a dictionary whose keys are all the cases of an enum, and is thus<br>&gt;&gt;&gt; guaranteed to produce a value.<br>&gt;&gt; <br>&gt;&gt; In Delphi(Pascal) you can define an array with indexes of enum type i.e.:<br>&gt;&gt; type<br>&gt;&gt;   TMyEnum = (One, Two)<br>&gt;&gt; var<br>&gt;&gt;   MyVal : array[TMyEnum] of String<br>&gt;&gt; const<br>&gt;&gt;   MyConsts : array [TMyEnum] of String = (&#39;just one&#39;, &#39;two here&#39;)<br>&gt;&gt;   // compiler will check that values for each enum were specified here<br>&gt;&gt; <br>&gt;&gt; ,so you can do<br>&gt;&gt; var e: TMyEnum<br>&gt;&gt; e := One;<br>&gt;&gt; MyVal[e] := &#39;hello&#39;;<br>&gt;&gt; s2 := MyConsts[e];<br>&gt;&gt; <br>&gt;&gt; This is really useful and used a lot. And this is safe in meaning compiler<br>&gt;&gt; will notify you if you changed the enum - you&#39;ll have to change such<br>&gt;&gt; constant array.<br>&gt;&gt; <br>&gt;&gt; I wish we&#39;ll have something like this in Swift.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the question I have is how you&#39;d access the values, syntactically.<br>&gt;&gt;&gt; To use the Planet example, if &#39;.earth&#39; is a value of the Planet enum, is<br>&gt;&gt;&gt; &#39;.earth.mass&#39; an acceptable way to access its mass? Or perhaps<br>&gt;&gt;&gt; &#39;Planet[.earth].mass&#39;?<br>&gt;&gt; <br>&gt;&gt; Just like .rawValue currently, i.e.<br>&gt;&gt; let e = Planet.earth<br>&gt;&gt; print(e.mass, e.description)<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, May 26, 2016 at 4:43 PM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Or(if we are sure we&#39;ll don&#39;t forget to udpate `infoDict` in case of<br>&gt;&gt;&gt;    new added case in future):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    enum Planet {<br>&gt;&gt;&gt;        case earth<br>&gt;&gt;&gt;        case moon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        struct PlanetInfo {<br>&gt;&gt;&gt;            var mass: Double<br>&gt;&gt;&gt;            var description: String<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        private static let infoDict = [<br>&gt;&gt;&gt;            Planet.earth :<br>&gt;&gt;&gt;                PlanetInfo(mass: 1.0, description:&quot;Earth is our home&quot;),<br>&gt;&gt;&gt;            .moon:<br>&gt;&gt;&gt;                PlanetInfo(mass: 0.2, description:&quot;Just a moon&quot;),<br>&gt;&gt;&gt;            ]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        var info : PlanetInfo { return Planet.infoDict[self]! }<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    But I agree with you, IMO we need static stored properties for each case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    On 26.05.2016 18 &lt;tel:26.05.2016%2018&gt;:15, Jānis Kiršteins wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        The problem is that PlanetInfo values are recreated each time while<br>&gt;&gt;&gt;        they are static. Imagine if PlanetInfo where some type that expensive<br>&gt;&gt;&gt;        to create performance wise.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        You could solve it by:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        enum Planet {<br>&gt;&gt;&gt;            struct PlanetInfo {<br>&gt;&gt;&gt;                var mass: Double<br>&gt;&gt;&gt;                var description: String<br>&gt;&gt;&gt;            }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            case earth<br>&gt;&gt;&gt;            case moon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            private static earthInfo = PlanetInfo(mass: 1.0, description:<br>&gt;&gt;&gt;        &quot;Earth is our home&quot;)<br>&gt;&gt;&gt;            private static moonInfo = PlanetInfo(mass: 0.2, description:<br>&gt;&gt;&gt;        &quot;Just a moon&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            var info : PlanetInfo {<br>&gt;&gt;&gt;                switch self {<br>&gt;&gt;&gt;                    case earth: return PlanetInfo.earthInfo<br>&gt;&gt;&gt;                    case moon: return PlanetInfo.moonInfo<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt;            }<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        But that again more verbose. The proposed solution is explicit that<br>&gt;&gt;&gt;        those properties are static for each case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        On Thu, May 26, 2016 at 5:58 PM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;        &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            I support the proposal, but couldn&#39;t the initial target be<br>&gt;&gt;&gt;            achieved today<br>&gt;&gt;&gt;            with such (more verbose,yes) solution? :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            enum Planet {<br>&gt;&gt;&gt;                struct PlanetInfo {<br>&gt;&gt;&gt;                    var mass: Double<br>&gt;&gt;&gt;                    var description: String<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                case earth<br>&gt;&gt;&gt;                case moon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                var info : PlanetInfo {<br>&gt;&gt;&gt;                    switch self {<br>&gt;&gt;&gt;                        case earth: return PlanetInfo(mass: 1.0,<br>&gt;&gt;&gt;            description: &quot;Earth is<br>&gt;&gt;&gt;            our home&quot;)<br>&gt;&gt;&gt;                        case moon: return PlanetInfo(mass: 0.2,<br>&gt;&gt;&gt;            description: &quot;Just a<br>&gt;&gt;&gt;            moon&quot;)<br>&gt;&gt;&gt;                    }<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt;            }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            let e = Planet.earth<br>&gt;&gt;&gt;            print(e, e.info.description)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            let m = Planet.moon<br>&gt;&gt;&gt;            print(m, m.info.description)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            On 26.05.2016 8:26, Charlie Monroe via swift-evolution wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                    What this proposal is asking for is an easier way to<br>&gt;&gt;&gt;                    have derived values<br>&gt;&gt;&gt;                    from enum cases. Asking for more flexible RawValues<br>&gt;&gt;&gt;                    means mass and radius<br>&gt;&gt;&gt;                    are not derived, they are the source of truth. It goes<br>&gt;&gt;&gt;                    against the whole<br>&gt;&gt;&gt;                    point of RawRepresentable. You are not saying ‘Mercury<br>&gt;&gt;&gt;                    is identified by<br>&gt;&gt;&gt;                    the case .mercury’, you are saying ‘Mercury is<br>&gt;&gt;&gt;                    identified by a mass of<br>&gt;&gt;&gt;                    3.303e+23’. It’s backwards.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                I see what Janis meant in the first email. It&#39;s not that<br>&gt;&gt;&gt;                the planet would<br>&gt;&gt;&gt;                be identified by the mass or radius. It could very much be<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                case Mercury = 1 where (mass: 3, radius: 2),<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                - Mercury&#39;s rawValue would be 1.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                The issue here is that sometimes you want additional<br>&gt;&gt;&gt;                information with the<br>&gt;&gt;&gt;                enum. There are many cases where you extend the enum with a<br>&gt;&gt;&gt;                variable:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                enum Error {<br>&gt;&gt;&gt;                case NoError<br>&gt;&gt;&gt;                case FileNotFound<br>&gt;&gt;&gt;                ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                var isFatal: Bool {<br>&gt;&gt;&gt;                /// swtich over all values of self goes here.<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                var isNetworkError: Bool {<br>&gt;&gt;&gt;                /// swtich over all values of self goes here.<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                var isIOError: Bool {<br>&gt;&gt;&gt;                /// swtich over all values of self goes here.<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                What the propsal suggests is to simplify this to the<br>&gt;&gt; following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                enum Error {<br>&gt;&gt;&gt;                var isFatal: Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                case NoError where (isFatal: false, isNetworkError: false,<br>&gt;&gt;&gt;                isIOError:<br>&gt;&gt;&gt;                false)<br>&gt;&gt;&gt;                case FileNotFound  where (isFatal: true, isNetworkError:<br>&gt;&gt;&gt;                false, isIOError:<br>&gt;&gt;&gt;                true)<br>&gt;&gt;&gt;                ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                So that you assign the additional information to the enum<br>&gt;&gt;&gt;                value itself.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                Charlie<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                        On 26 May 2016, at 1:47 PM, David Sweeris via<br>&gt;&gt;&gt;                        swift-evolution<br>&gt;&gt;&gt;                        &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;                        &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                        &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;                        &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                            On May 25, 2016, at 10:27 PM, Jacob<br>&gt;&gt;&gt;                            Bandes-Storch &lt;jtbandes at gmail.com<br>&gt;&gt;&gt;                            &lt;mailto:jtbandes at gmail.com&gt;<br>&gt;&gt;&gt;                            &lt;mailto:jtbandes at gmail.com<br>&gt;&gt;&gt;                            &lt;mailto:jtbandes at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                            On Wed, May 25, 2016 at 8:15 PM, David Sweeris<br>&gt;&gt;&gt;                            via swift-evolution<br>&gt;&gt;&gt;                            &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;                            &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                            &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;                            &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                                On May 25, 2016, at 7:37 AM, Leonardo<br>&gt;&gt;&gt;                            Pessoa via swift-evolution<br>&gt;&gt;&gt;                                &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;                            &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                            &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;                            &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;                            wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                                    Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                                    Couldn&#39;t this be solved by using<br>&gt;&gt;&gt;                                tuples? If not because the syntax<br>&gt;&gt;&gt;                                    is not allowed I think this would be<br>&gt;&gt;&gt;                                more coherent to do it using<br>&gt;&gt;&gt;                                    current syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                                    enum Planet : (mass: Float, radius:<br>&gt;&gt;&gt;                                Float) {<br>&gt;&gt;&gt;                                        case mercury = (mass: 3.303e+23,<br>&gt;&gt;&gt;                                radius: 2.4397e6)<br>&gt;&gt;&gt;                                        case venus = (mass: 4.869e+24,<br>&gt;&gt;&gt;                                radius: 6.0518e6)<br>&gt;&gt;&gt;                                        case earth = (mass: 5.976e+24,<br>&gt;&gt;&gt;                                radius: 6.37814e6)<br>&gt;&gt;&gt;                                        case mars = (mass: 6.421e+23,<br>&gt;&gt;&gt;                                radius: 3.3972e6)<br>&gt;&gt;&gt;                                        case jupiter = (mass: 1.9e+27,<br>&gt;&gt;&gt;                                radius: 7.1492e7)<br>&gt;&gt;&gt;                                        case saturn = (mass: 5.688e+26,<br>&gt;&gt;&gt;                                radius: 6.0268e7)<br>&gt;&gt;&gt;                                        case uranus = (mass: 8.686e+25,<br>&gt;&gt;&gt;                                radius: 2.5559e7)<br>&gt;&gt;&gt;                                        case neptune = (mass: 1.024e+26,<br>&gt;&gt;&gt;                                radius: 2.4746e7)<br>&gt;&gt;&gt;                                    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                                This would be my preferred solution… AFAIK,<br>&gt;&gt;&gt;                            the only reason we<br>&gt;&gt;&gt;                                can’t do it now is that Swift currently<br>&gt;&gt;&gt;                            requires RawValue be an<br>&gt;&gt;&gt;                                integer, floating-point value, or string. I<br>&gt;&gt;&gt;                            don’t know why the<br>&gt;&gt;&gt;                                language has this restriction, so I can’t<br>&gt;&gt;&gt;                            comment on how hard it<br>&gt;&gt;&gt;                                would be to change.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                                - Dave Sweeris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                            Except you&#39;d have to write<br>&gt;&gt;&gt;                            Planet.mercury.rawValue.mass, rather than<br>&gt;&gt;&gt;                            Planet.mercury.mass.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                            This could be one or two proposals: allow enums<br>&gt;&gt;&gt;                            with tuple RawValues,<br>&gt;&gt;&gt;                            and allow `TupleName.caseName.propertyName` to<br>&gt;&gt;&gt;                            access a tuple element<br>&gt;&gt;&gt;                            without going through .rawValue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                        Good point… Has there been a thread on allowing<br>&gt;&gt;&gt;                        raw-valued enums to be<br>&gt;&gt;&gt;                        treated as constants of type `RawValue` yet? Either<br>&gt;&gt;&gt;                        way, removing the<br>&gt;&gt;&gt;                        restriction on what types can be a RawValue is<br>&gt;&gt;&gt;                        still my preferred<br>&gt;&gt;&gt;                        solution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                        - Dave Sweeris<br>&gt;&gt;&gt;                        _______________________________________________<br>&gt;&gt;&gt;                        swift-evolution mailing list<br>&gt;&gt;&gt;                        swift-evolution at swift.org<br>&gt;&gt;&gt;                        &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                        &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;                        &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                    _______________________________________________<br>&gt;&gt;&gt;                    swift-evolution mailing list<br>&gt;&gt;&gt;                    swift-evolution at swift.org<br>&gt;&gt;&gt;                    &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                    &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;                    &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;                    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                _______________________________________________<br>&gt;&gt;&gt;                swift-evolution mailing list<br>&gt;&gt;&gt;                swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            _______________________________________________<br>&gt;&gt;&gt;            swift-evolution mailing list<br>&gt;&gt;&gt;            swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;            https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    _______________________________________________<br>&gt;&gt;&gt;    swift-evolution mailing list<br>&gt;&gt;&gt;    swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/ed6c7caf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal] Enums with static storedpropertiesforeach case</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 26, 2016 at 09:00:00pm</p></header><div class="content"><p>Not really. When you take Scala&#39;s case classes, they are exactly for this purpose:<br></p><p>http://docs.scala-lang.org/tutorials/tour/case-classes.html<br></p><p>abstract class Term<br>case class Var(name: String) extends Term<br>case class Fun(arg: String, body: Term) extends Term<br>case class App(f: Term, v: Term) extends Term<br></p><p>Which in Swift could be an enum.<br></p><p>You can look at sealed classes in two ways:<br></p><p>1) Something that prevents others from subclassing your classes.<br>2) Something that ensures that only a known number of subclasses exists at compile-time - which is pretty much the definition of an enum.<br></p><p><br></p><p>&gt; On May 26, 2016, at 9:48 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; <br>&gt; I think these are different concepts. Classes and structs are abstractions for something (think of them as empty forms while instances are filled forms) while enums identify a closed set of values (filled forms) known ahead of use. Sealed classes are intended to limit extensions to a class not to the instances that can be created.<br>&gt; <br>&gt; From: Charlie Monroe &lt;mailto:charlie at charliemonroe.net&gt;<br>&gt; Sent: ‎26/‎05/‎2016 03:13 PM<br>&gt; To: Vladimir.S &lt;mailto:svabox at gmail.com&gt;<br>&gt; Cc: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;; swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Proposal] Enums with static storedpropertiesforeach case<br>&gt; <br>&gt; Now thinking about this, what would solve this partially is being discussed in another topic here - sealed clasees.<br>&gt; <br>&gt; Each planet would have its own class and the superclass Planet would be abstract sealed. You would then be able to do an effective switch on the instance of the planet, which would act like an enum.<br>&gt; <br>&gt; &gt; On May 26, 2016, at 8:06 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; Yes, this was mentioned in a similar thread in this email list earlier. There is even some proposal for such .values() for Swift enums.<br>&gt; &gt; <br>&gt; &gt; But this values() in Java is not the same thing as discussed dictionary with *keys* of enum type or Delphi&#39;s arrays with *index* of enum type.<br>&gt; &gt; <br>&gt; &gt; Could you write Java&#39;s example for array/dictionary of String which *index*(or key) will be of enum type? *And* compiler will check that value for each enum case is set in case of array of constants like:<br>&gt; &gt; MyConsts : array [TMyEnum] of String = (&#39;just one&#39;, &#39;two here&#39;)<br>&gt; &gt; // compiler will always check that value assigned for each case<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; On 26.05.2016 20:58, Leonardo Pessoa wrote:<br>&gt; &gt;&gt; Java enums automatically have a static values() method that return an array<br>&gt; &gt;&gt; with all values in an enum.<br>&gt; &gt;&gt; ---------------------------------------------------------------------------<br>&gt; &gt;&gt; From: Vladimir.S via swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; Sent: ‎26/‎05/‎2016 02:36 PM<br>&gt; &gt;&gt; To: Ross O&#39;Brien &lt;mailto:narrativium+swift at gmail.com&gt;<br>&gt; &gt;&gt; Cc: swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; Subject: Re: [swift-evolution] [Proposal] Enums with static stored<br>&gt; &gt;&gt; propertiesforeach case<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; On 26.05.2016 19:50, Ross O&#39;Brien wrote:<br>&gt; &gt;&gt;&gt; Perhaps there&#39;s an argument to be made for a sort of &#39;enumDictionary&#39; type<br>&gt; &gt;&gt;&gt; - a dictionary whose keys are all the cases of an enum, and is thus<br>&gt; &gt;&gt;&gt; guaranteed to produce a value.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; In Delphi(Pascal) you can define an array with indexes of enum type i.e.:<br>&gt; &gt;&gt; type<br>&gt; &gt;&gt;   TMyEnum = (One, Two)<br>&gt; &gt;&gt; var<br>&gt; &gt;&gt;   MyVal : array[TMyEnum] of String<br>&gt; &gt;&gt; const<br>&gt; &gt;&gt;   MyConsts : array [TMyEnum] of String = (&#39;just one&#39;, &#39;two here&#39;)<br>&gt; &gt;&gt;   // compiler will check that values for each enum were specified here<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; ,so you can do<br>&gt; &gt;&gt; var e: TMyEnum<br>&gt; &gt;&gt; e := One;<br>&gt; &gt;&gt; MyVal[e] := &#39;hello&#39;;<br>&gt; &gt;&gt; s2 := MyConsts[e];<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; This is really useful and used a lot. And this is safe in meaning compiler<br>&gt; &gt;&gt; will notify you if you changed the enum - you&#39;ll have to change such<br>&gt; &gt;&gt; constant array.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I wish we&#39;ll have something like this in Swift.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; I think the question I have is how you&#39;d access the values, syntactically.<br>&gt; &gt;&gt;&gt; To use the Planet example, if &#39;.earth&#39; is a value of the Planet enum, is<br>&gt; &gt;&gt;&gt; &#39;.earth.mass&#39; an acceptable way to access its mass? Or perhaps<br>&gt; &gt;&gt;&gt; &#39;Planet[.earth].mass&#39;?<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Just like .rawValue currently, i.e.<br>&gt; &gt;&gt; let e = Planet.earth<br>&gt; &gt;&gt; print(e.mass, e.description)<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; On Thu, May 26, 2016 at 4:43 PM, Vladimir.S via swift-evolution<br>&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;    Or(if we are sure we&#39;ll don&#39;t forget to udpate `infoDict` in case of<br>&gt; &gt;&gt;&gt;    new added case in future):<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;    enum Planet {<br>&gt; &gt;&gt;&gt;        case earth<br>&gt; &gt;&gt;&gt;        case moon<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;        struct PlanetInfo {<br>&gt; &gt;&gt;&gt;            var mass: Double<br>&gt; &gt;&gt;&gt;            var description: String<br>&gt; &gt;&gt;&gt;        }<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;        private static let infoDict = [<br>&gt; &gt;&gt;&gt;            Planet.earth :<br>&gt; &gt;&gt;&gt;                PlanetInfo(mass: 1.0, description:&quot;Earth is our home&quot;),<br>&gt; &gt;&gt;&gt;            .moon:<br>&gt; &gt;&gt;&gt;                PlanetInfo(mass: 0.2, description:&quot;Just a moon&quot;),<br>&gt; &gt;&gt;&gt;            ]<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;        var info : PlanetInfo { return Planet.infoDict[self]! }<br>&gt; &gt;&gt;&gt;    }<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;    But I agree with you, IMO we need static stored properties for each case.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;    On 26.05.2016 18 &lt;tel:26.05.2016%2018&gt;:15, Jānis Kiršteins wrote:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;        The problem is that PlanetInfo values are recreated each time while<br>&gt; &gt;&gt;&gt;        they are static. Imagine if PlanetInfo where some type that expensive<br>&gt; &gt;&gt;&gt;        to create performance wise.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;        You could solve it by:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;        enum Planet {<br>&gt; &gt;&gt;&gt;            struct PlanetInfo {<br>&gt; &gt;&gt;&gt;                var mass: Double<br>&gt; &gt;&gt;&gt;                var description: String<br>&gt; &gt;&gt;&gt;            }<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;            case earth<br>&gt; &gt;&gt;&gt;            case moon<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;            private static earthInfo = PlanetInfo(mass: 1.0, description:<br>&gt; &gt;&gt;&gt;        &quot;Earth is our home&quot;)<br>&gt; &gt;&gt;&gt;            private static moonInfo = PlanetInfo(mass: 0.2, description:<br>&gt; &gt;&gt;&gt;        &quot;Just a moon&quot;)<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;            var info : PlanetInfo {<br>&gt; &gt;&gt;&gt;                switch self {<br>&gt; &gt;&gt;&gt;                    case earth: return PlanetInfo.earthInfo<br>&gt; &gt;&gt;&gt;                    case moon: return PlanetInfo.moonInfo<br>&gt; &gt;&gt;&gt;                }<br>&gt; &gt;&gt;&gt;            }<br>&gt; &gt;&gt;&gt;        }<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;        But that again more verbose. The proposed solution is explicit that<br>&gt; &gt;&gt;&gt;        those properties are static for each case.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;        On Thu, May 26, 2016 at 5:58 PM, Vladimir.S via swift-evolution<br>&gt; &gt;&gt;&gt;        &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;            I support the proposal, but couldn&#39;t the initial target be<br>&gt; &gt;&gt;&gt;            achieved today<br>&gt; &gt;&gt;&gt;            with such (more verbose,yes) solution? :<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;            enum Planet {<br>&gt; &gt;&gt;&gt;                struct PlanetInfo {<br>&gt; &gt;&gt;&gt;                    var mass: Double<br>&gt; &gt;&gt;&gt;                    var description: String<br>&gt; &gt;&gt;&gt;                }<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                case earth<br>&gt; &gt;&gt;&gt;                case moon<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                var info : PlanetInfo {<br>&gt; &gt;&gt;&gt;                    switch self {<br>&gt; &gt;&gt;&gt;                        case earth: return PlanetInfo(mass: 1.0,<br>&gt; &gt;&gt;&gt;            description: &quot;Earth is<br>&gt; &gt;&gt;&gt;            our home&quot;)<br>&gt; &gt;&gt;&gt;                        case moon: return PlanetInfo(mass: 0.2,<br>&gt; &gt;&gt;&gt;            description: &quot;Just a<br>&gt; &gt;&gt;&gt;            moon&quot;)<br>&gt; &gt;&gt;&gt;                    }<br>&gt; &gt;&gt;&gt;                }<br>&gt; &gt;&gt;&gt;            }<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;            let e = Planet.earth<br>&gt; &gt;&gt;&gt;            print(e, e.info.description)<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;            let m = Planet.moon<br>&gt; &gt;&gt;&gt;            print(m, m.info.description)<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;            On 26.05.2016 8:26, Charlie Monroe via swift-evolution wrote:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                    What this proposal is asking for is an easier way to<br>&gt; &gt;&gt;&gt;                    have derived values<br>&gt; &gt;&gt;&gt;                    from enum cases. Asking for more flexible RawValues<br>&gt; &gt;&gt;&gt;                    means mass and radius<br>&gt; &gt;&gt;&gt;                    are not derived, they are the source of truth. It goes<br>&gt; &gt;&gt;&gt;                    against the whole<br>&gt; &gt;&gt;&gt;                    point of RawRepresentable. You are not saying ‘Mercury<br>&gt; &gt;&gt;&gt;                    is identified by<br>&gt; &gt;&gt;&gt;                    the case .mercury’, you are saying ‘Mercury is<br>&gt; &gt;&gt;&gt;                    identified by a mass of<br>&gt; &gt;&gt;&gt;                    3.303e+23’. It’s backwards.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                I see what Janis meant in the first email. It&#39;s not that<br>&gt; &gt;&gt;&gt;                the planet would<br>&gt; &gt;&gt;&gt;                be identified by the mass or radius. It could very much be<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                case Mercury = 1 where (mass: 3, radius: 2),<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                - Mercury&#39;s rawValue would be 1.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                The issue here is that sometimes you want additional<br>&gt; &gt;&gt;&gt;                information with the<br>&gt; &gt;&gt;&gt;                enum. There are many cases where you extend the enum with a<br>&gt; &gt;&gt;&gt;                variable:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                enum Error {<br>&gt; &gt;&gt;&gt;                case NoError<br>&gt; &gt;&gt;&gt;                case FileNotFound<br>&gt; &gt;&gt;&gt;                ...<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                var isFatal: Bool {<br>&gt; &gt;&gt;&gt;                /// swtich over all values of self goes here.<br>&gt; &gt;&gt;&gt;                }<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                var isNetworkError: Bool {<br>&gt; &gt;&gt;&gt;                /// swtich over all values of self goes here.<br>&gt; &gt;&gt;&gt;                }<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                var isIOError: Bool {<br>&gt; &gt;&gt;&gt;                /// swtich over all values of self goes here.<br>&gt; &gt;&gt;&gt;                }<br>&gt; &gt;&gt;&gt;                }<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                What the propsal suggests is to simplify this to the<br>&gt; &gt;&gt; following:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                enum Error {<br>&gt; &gt;&gt;&gt;                var isFatal: Bool<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                case NoError where (isFatal: false, isNetworkError: false,<br>&gt; &gt;&gt;&gt;                isIOError:<br>&gt; &gt;&gt;&gt;                false)<br>&gt; &gt;&gt;&gt;                case FileNotFound  where (isFatal: true, isNetworkError:<br>&gt; &gt;&gt;&gt;                false, isIOError:<br>&gt; &gt;&gt;&gt;                true)<br>&gt; &gt;&gt;&gt;                ...<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                }<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                So that you assign the additional information to the enum<br>&gt; &gt;&gt;&gt;                value itself.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                Charlie<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                        On 26 May 2016, at 1:47 PM, David Sweeris via<br>&gt; &gt;&gt;&gt;                        swift-evolution<br>&gt; &gt;&gt;&gt;                        &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;                        &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;                        &lt;mailto:swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;                        &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                            On May 25, 2016, at 10:27 PM, Jacob<br>&gt; &gt;&gt;&gt;                            Bandes-Storch &lt;jtbandes at gmail.com<br>&gt; &gt;&gt;&gt;                            &lt;mailto:jtbandes at gmail.com&gt;<br>&gt; &gt;&gt;&gt;                            &lt;mailto:jtbandes at gmail.com<br>&gt; &gt;&gt;&gt;                            &lt;mailto:jtbandes at gmail.com&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                            On Wed, May 25, 2016 at 8:15 PM, David Sweeris<br>&gt; &gt;&gt;&gt;                            via swift-evolution<br>&gt; &gt;&gt;&gt;                            &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;                            &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;                            &lt;mailto:swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;                            &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                                On May 25, 2016, at 7:37 AM, Leonardo<br>&gt; &gt;&gt;&gt;                            Pessoa via swift-evolution<br>&gt; &gt;&gt;&gt;                                &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;                            &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;                            &lt;mailto:swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;                            &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;                            wrote:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                                    Hi,<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                                    Couldn&#39;t this be solved by using<br>&gt; &gt;&gt;&gt;                                tuples? If not because the syntax<br>&gt; &gt;&gt;&gt;                                    is not allowed I think this would be<br>&gt; &gt;&gt;&gt;                                more coherent to do it using<br>&gt; &gt;&gt;&gt;                                    current syntax.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                                    enum Planet : (mass: Float, radius:<br>&gt; &gt;&gt;&gt;                                Float) {<br>&gt; &gt;&gt;&gt;                                        case mercury = (mass: 3.303e+23,<br>&gt; &gt;&gt;&gt;                                radius: 2.4397e6)<br>&gt; &gt;&gt;&gt;                                        case venus = (mass: 4.869e+24,<br>&gt; &gt;&gt;&gt;                                radius: 6.0518e6)<br>&gt; &gt;&gt;&gt;                                        case earth = (mass: 5.976e+24,<br>&gt; &gt;&gt;&gt;                                radius: 6.37814e6)<br>&gt; &gt;&gt;&gt;                                        case mars = (mass: 6.421e+23,<br>&gt; &gt;&gt;&gt;                                radius: 3.3972e6)<br>&gt; &gt;&gt;&gt;                                        case jupiter = (mass: 1.9e+27,<br>&gt; &gt;&gt;&gt;                                radius: 7.1492e7)<br>&gt; &gt;&gt;&gt;                                        case saturn = (mass: 5.688e+26,<br>&gt; &gt;&gt;&gt;                                radius: 6.0268e7)<br>&gt; &gt;&gt;&gt;                                        case uranus = (mass: 8.686e+25,<br>&gt; &gt;&gt;&gt;                                radius: 2.5559e7)<br>&gt; &gt;&gt;&gt;                                        case neptune = (mass: 1.024e+26,<br>&gt; &gt;&gt;&gt;                                radius: 2.4746e7)<br>&gt; &gt;&gt;&gt;                                    }<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                                This would be my preferred solution… AFAIK,<br>&gt; &gt;&gt;&gt;                            the only reason we<br>&gt; &gt;&gt;&gt;                                can’t do it now is that Swift currently<br>&gt; &gt;&gt;&gt;                            requires RawValue be an<br>&gt; &gt;&gt;&gt;                                integer, floating-point value, or string. I<br>&gt; &gt;&gt;&gt;                            don’t know why the<br>&gt; &gt;&gt;&gt;                                language has this restriction, so I can’t<br>&gt; &gt;&gt;&gt;                            comment on how hard it<br>&gt; &gt;&gt;&gt;                                would be to change.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                                - Dave Sweeris<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                            Except you&#39;d have to write<br>&gt; &gt;&gt;&gt;                            Planet.mercury.rawValue.mass, rather than<br>&gt; &gt;&gt;&gt;                            Planet.mercury.mass.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                            This could be one or two proposals: allow enums<br>&gt; &gt;&gt;&gt;                            with tuple RawValues,<br>&gt; &gt;&gt;&gt;                            and allow `TupleName.caseName.propertyName` to<br>&gt; &gt;&gt;&gt;                            access a tuple element<br>&gt; &gt;&gt;&gt;                            without going through .rawValue.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                        Good point… Has there been a thread on allowing<br>&gt; &gt;&gt;&gt;                        raw-valued enums to be<br>&gt; &gt;&gt;&gt;                        treated as constants of type `RawValue` yet? Either<br>&gt; &gt;&gt;&gt;                        way, removing the<br>&gt; &gt;&gt;&gt;                        restriction on what types can be a RawValue is<br>&gt; &gt;&gt;&gt;                        still my preferred<br>&gt; &gt;&gt;&gt;                        solution.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                        - Dave Sweeris<br>&gt; &gt;&gt;&gt;                        _______________________________________________<br>&gt; &gt;&gt;&gt;                        swift-evolution mailing list<br>&gt; &gt;&gt;&gt;                        swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;                        &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;                        &lt;mailto:swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;                        &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                    _______________________________________________<br>&gt; &gt;&gt;&gt;                    swift-evolution mailing list<br>&gt; &gt;&gt;&gt;                    swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;                    &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;                    &lt;mailto:swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;                    &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt;                    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;                _______________________________________________<br>&gt; &gt;&gt;&gt;                swift-evolution mailing list<br>&gt; &gt;&gt;&gt;                swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;                https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;            _______________________________________________<br>&gt; &gt;&gt;&gt;            swift-evolution mailing list<br>&gt; &gt;&gt;&gt;            swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;            https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;    _______________________________________________<br>&gt; &gt;&gt;&gt;    swift-evolution mailing list<br>&gt; &gt;&gt;&gt;    swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/51df0244/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Enums with staticstoredpropertiesforeach case</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 26, 2016 at 05:00:00pm</p></header><div class="content"><p>Ok, I&#39;m not familiar with Scala but if the language does not have support for the type of enums we&#39;re discussing it may be their chosen mechanism to handle enums with associated values (feel free to correct me if I&#39;m wrong always) but my main point for enums is still: do we really need to introduce another concept to handle the presented examples or can we reuse an existing concept? Enums are (or can be seen as) our case classes but there seems to exist a need for enums to hold more than just one value as of today.<br></p><p>Just to mention ahead, I&#39;m not in favour of enum values having methods or computed properties<br></p><p><br></p><p>-----Original Message-----<br>From: &quot;Charlie Monroe&quot; &lt;charlie at charliemonroe.net&gt;<br>Sent: ‎26/‎05/‎2016 04:57 PM<br>To: &quot;Leonardo Pessoa&quot; &lt;me at lmpessoa.com&gt;<br>Cc: &quot;Vladimir.S&quot; &lt;svabox at gmail.com&gt;; &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Proposal] Enums with staticstoredpropertiesforeach case<br></p><p>Not really. When you take Scala&#39;s case classes, they are exactly for this purpose:<br></p><p><br>http://docs.scala-lang.org/tutorials/tour/case-classes.html<br></p><p><br>abstract class Term<br></p><p>case class Var(name: String) extends Term<br></p><p>case class Fun(arg: String, body: Term) extends Term<br></p><p>case class App(f: Term, v: Term) extends Term<br></p><p><br></p><p>Which in Swift could be an enum.<br></p><p><br>You can look at sealed classes in two ways:<br></p><p><br>1) Something that prevents others from subclassing your classes.<br>2) Something that ensures that only a known number of subclasses exists at compile-time - which is pretty much the definition of an enum.<br></p><p><br></p><p><br></p><p><br>On May 26, 2016, at 9:48 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br></p><p><br>I think these are different concepts. Classes and structs are abstractions for something (think of them as empty forms while instances are filled forms) while enums identify a closed set of values (filled forms) known ahead of use. Sealed classes are intended to limit extensions to a class not to the instances that can be created.<br></p><p><br></p><p><br>From: Charlie Monroe<br>Sent: ‎26/‎05/‎2016 03:13 PM<br>To: Vladimir.S<br>Cc: Leonardo Pessoa; swift-evolution<br>Subject: Re: [swift-evolution] [Proposal] Enums with static storedpropertiesforeach case<br></p><p><br>Now thinking about this, what would solve this partially is being discussed in another topic here - sealed clasees.<br></p><p>Each planet would have its own class and the superclass Planet would be abstract sealed. You would then be able to do an effective switch on the instance of the planet, which would act like an enum.<br></p><p>&gt; On May 26, 2016, at 8:06 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yes, this was mentioned in a similar thread in this email list earlier. There is even some proposal for such .values() for Swift enums.<br>&gt; <br>&gt; But this values() in Java is not the same thing as discussed dictionary with *keys* of enum type or Delphi&#39;s arrays with *index* of enum type.<br>&gt; <br>&gt; Could you write Java&#39;s example for array/dictionary of String which *index*(or key) will be of enum type? *And* compiler will check that value for each enum case is set in case of array of constants like:<br>&gt; MyConsts : array [TMyEnum] of String = (&#39;just one&#39;, &#39;two here&#39;)<br>&gt; // compiler will always check that value assigned for each case<br>&gt; <br>&gt; <br>&gt; On 26.05.2016 20:58, Leonardo Pessoa wrote:<br>&gt;&gt; Java enums automatically have a static values() method that return an array<br>&gt;&gt; with all values in an enum.<br>&gt;&gt; ---------------------------------------------------------------------------<br>&gt;&gt; From: Vladimir.S via swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; Sent: ‎26/‎05/‎2016 02:36 PM<br>&gt;&gt; To: Ross O&#39;Brien &lt;mailto:narrativium+swift at gmail.com&gt;<br>&gt;&gt; Cc: swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; Subject: Re: [swift-evolution] [Proposal] Enums with static stored<br>&gt;&gt; propertiesforeach case<br>&gt;&gt; <br>&gt;&gt; On 26.05.2016 19:50, Ross O&#39;Brien wrote:<br>&gt;&gt;&gt; Perhaps there&#39;s an argument to be made for a sort of &#39;enumDictionary&#39; type<br>&gt;&gt;&gt; - a dictionary whose keys are all the cases of an enum, and is thus<br>&gt;&gt;&gt; guaranteed to produce a value.<br>&gt;&gt; <br>&gt;&gt; In Delphi(Pascal) you can define an array with indexes of enum type i.e.:<br>&gt;&gt; type<br>&gt;&gt;   TMyEnum = (One, Two)<br>&gt;&gt; var<br>&gt;&gt;   MyVal : array[TMyEnum] of String<br>&gt;&gt; const<br>&gt;&gt;   MyConsts : array [TMyEnum] of String = (&#39;just one&#39;, &#39;two here&#39;)<br>&gt;&gt;   // compiler will check that values for each enum were specified here<br>&gt;&gt; <br>&gt;&gt; ,so you can do<br>&gt;&gt; var e: TMyEnum<br>&gt;&gt; e := One;<br>&gt;&gt; MyVal[e] := &#39;hello&#39;;<br>&gt;&gt; s2 := MyConsts[e];<br>&gt;&gt; <br>&gt;&gt; This is really useful and used a lot. And this is safe in meaning compiler<br>&gt;&gt; will notify you if you changed the enum - you&#39;ll have to change such<br>&gt;&gt; constant array.<br>&gt;&gt; <br>&gt;&gt; I wish we&#39;ll have something like this in Swift.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the question I have is how you&#39;d access the values, syntactically.<br>&gt;&gt;&gt; To use the Planet example, if &#39;.earth&#39; is a value of the Planet enum, is<br>&gt;&gt;&gt; &#39;.earth.mass&#39; an acceptable way to access its mass? Or perhaps<br>&gt;&gt;&gt; &#39;Planet[.earth].mass&#39;?<br>&gt;&gt; <br>&gt;&gt; Just like .rawValue currently, i.e.<br>&gt;&gt; let e = Planet.earth<br>&gt;&gt; print(e.mass, e.description)<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, May 26, 2016 at 4:43 PM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Or(if we are sure we&#39;ll don&#39;t forget to udpate `infoDict` in case of<br>&gt;&gt;&gt;    new added case in future):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    enum Planet {<br>&gt;&gt;&gt;        case earth<br>&gt;&gt;&gt;        case moon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        struct PlanetInfo {<br>&gt;&gt;&gt;            var mass: Double<br>&gt;&gt;&gt;            var description: String<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        private static let infoDict = [<br>&gt;&gt;&gt;            Planet.earth :<br>&gt;&gt;&gt;                PlanetInfo(mass: 1.0, description:&quot;Earth is our home&quot;),<br>&gt;&gt;&gt;            .moon:<br>&gt;&gt;&gt;                PlanetInfo(mass: 0.2, description:&quot;Just a moon&quot;),<br>&gt;&gt;&gt;            ]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        var info : PlanetInfo { return Planet.infoDict[self]! }<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    But I agree with you, IMO we need static stored properties for each case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    On 26.05.2016 18 &lt;tel:26.05.2016%2018&gt;:15, Jānis Kiršteins wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        The problem is that PlanetInfo values are recreated each time while<br>&gt;&gt;&gt;        they are static. Imagine if PlanetInfo where some type that expensive<br>&gt;&gt;&gt;        to create performance wise.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        You could solve it by:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        enum Planet {<br>&gt;&gt;&gt;            struct PlanetInfo {<br>&gt;&gt;&gt;                var mass: Double<br>&gt;&gt;&gt;                var description: String<br>&gt;&gt;&gt;            }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            case earth<br>&gt;&gt;&gt;            case moon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            private static earthInfo = PlanetInfo(mass: 1.0, description:<br>&gt;&gt;&gt;        &quot;Earth is our home&quot;)<br>&gt;&gt;&gt;            private static moonInfo = PlanetInfo(mass: 0.2, description:<br>&gt;&gt;&gt;        &quot;Just a moon&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            var info : PlanetInfo {<br>&gt;&gt;&gt;                switch self {<br>&gt;&gt;&gt;                    case earth: return PlanetInfo.earthInfo<br>&gt;&gt;&gt;                    case moon: return PlanetInfo.moonInfo<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt;            }<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        But that again more verbose. The proposed solution is explicit that<br>&gt;&gt;&gt;        those properties are static for each case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        On Thu, May 26, 2016 at 5:58 PM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;        &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            I support the proposal, but couldn&#39;t the initial target be<br>&gt;&gt;&gt;            achieved today<br>&gt;&gt;&gt;            with such (more verbose,yes) solution? :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            enum Planet {<br>&gt;&gt;&gt;                struct PlanetInfo {<br>&gt;&gt;&gt;                    var mass: Double<br>&gt;&gt;&gt;                    var description: String<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                case earth<br>&gt;&gt;&gt;                case moon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                var info : PlanetInfo {<br>&gt;&gt;&gt;                    switch self {<br>&gt;&gt;&gt;                        case earth: return PlanetInfo(mass: 1.0,<br>&gt;&gt;&gt;            description: &quot;Earth is<br>&gt;&gt;&gt;            our home&quot;)<br>&gt;&gt;&gt;                        case moon: return PlanetInfo(mass: 0.2,<br>&gt;&gt;&gt;            description: &quot;Just a<br>&gt;&gt;&gt;            moon&quot;)<br>&gt;&gt;&gt;                    }<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt;            }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            let e = Planet.earth<br>&gt;&gt;&gt;            print(e, e.info.description)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            let m = Planet.moon<br>&gt;&gt;&gt;            print(m, m.info.description)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            On 26.05.2016 8:26, Charlie Monroe via swift-evolution wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;                    What this proposal is asking for is an easier way to<br>&gt;&gt;&gt;                    have derived values<br>&gt;&gt;&gt;                    from enum cases. Asking for more flexible RawValues<br>&gt;&gt;&gt;                    means mass and radius<br>&gt;&gt;&gt;                    are not derived, they are the source of truth. It goes<br>&gt;&gt;&gt;                    against the whole<br>&gt;&gt;&gt;                    point of RawRepresentable. You are not saying ‘Mercury<br>&gt;&gt;&gt;                    is identified by&lt;br<br></p><p>[The entire original message is not included.]<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/74594427/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Enums with static storedpropertiesforeach case</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 26, 2016 at 05:00:00pm</p></header><div class="content"><p>I get it and think this was really very interesting in Delphi and I wouldn&#39;t mind having something like this in Swift. But despite being able to extend associated information through the use of another array we&#39;d still have more verbosity and scattering than with tuples to implement the examples discussed. And we can already have enum dictionaries just not checking automatically if all enum values have been covered. Moreover there is no loss in having both solutions.<br></p><p>I mentioned the values() method also because I miss a way to iterate through all the values on an enum and since it seems we&#39;re discussing the entire way to work with enums here it was worth bringing it up.<br></p><p><br></p><p>-----Original Message-----<br>From: &quot;Vladimir.S&quot; &lt;svabox at gmail.com&gt;<br>Sent: ‎26/‎05/‎2016 03:06 PM<br>To: &quot;Leonardo Pessoa&quot; &lt;me at lmpessoa.com&gt;<br>Cc: &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Proposal] Enums with static storedpropertiesforeach case<br></p><p>Yes, this was mentioned in a similar thread in this email list earlier. <br>There is even some proposal for such .values() for Swift enums.<br></p><p>But this values() in Java is not the same thing as discussed dictionary <br>with *keys* of enum type or Delphi&#39;s arrays with *index* of enum type.<br></p><p>Could you write Java&#39;s example for array/dictionary of String which <br>*index*(or key) will be of enum type? *And* compiler will check that value <br>for each enum case is set in case of array of constants like:<br>MyConsts : array [TMyEnum] of String = (&#39;just one&#39;, &#39;two here&#39;)<br>// compiler will always check that value assigned for each case<br></p><p><br>On 26.05.2016 20:58, Leonardo Pessoa wrote:<br>&gt; Java enums automatically have a static values() method that return an array<br>&gt; with all values in an enum.<br>&gt; ---------------------------------------------------------------------------<br>&gt; From: Vladimir.S via swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; Sent: ‎26/‎05/‎2016 02:36 PM<br>&gt; To: Ross O&#39;Brien &lt;mailto:narrativium+swift at gmail.com&gt;<br>&gt; Cc: swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Proposal] Enums with static stored<br>&gt; propertiesforeach case<br>&gt;<br>&gt; On 26.05.2016 19:50, Ross O&#39;Brien wrote:<br>&gt;&gt; Perhaps there&#39;s an argument to be made for a sort of &#39;enumDictionary&#39; type<br>&gt;&gt; - a dictionary whose keys are all the cases of an enum, and is thus<br>&gt;&gt; guaranteed to produce a value.<br>&gt;<br>&gt; In Delphi(Pascal) you can define an array with indexes of enum type i.e.:<br>&gt; type<br>&gt;    TMyEnum = (One, Two)<br>&gt; var<br>&gt;    MyVal : array[TMyEnum] of String<br>&gt; const<br>&gt;    MyConsts : array [TMyEnum] of String = (&#39;just one&#39;, &#39;two here&#39;)<br>&gt;    // compiler will check that values for each enum were specified here<br>&gt;<br>&gt; ,so you can do<br>&gt; var e: TMyEnum<br>&gt; e := One;<br>&gt; MyVal[e] := &#39;hello&#39;;<br>&gt; s2 := MyConsts[e];<br>&gt;<br>&gt; This is really useful and used a lot. And this is safe in meaning compiler<br>&gt; will notify you if you changed the enum - you&#39;ll have to change such<br>&gt; constant array.<br>&gt;<br>&gt; I wish we&#39;ll have something like this in Swift.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; I think the question I have is how you&#39;d access the values, syntactically.<br>&gt;&gt; To use the Planet example, if &#39;.earth&#39; is a value of the Planet enum, is<br>&gt;&gt; &#39;.earth.mass&#39; an acceptable way to access its mass? Or perhaps<br>&gt;&gt; &#39;Planet[.earth].mass&#39;?<br>&gt;<br>&gt; Just like .rawValue currently, i.e.<br>&gt; let e = Planet.earth<br>&gt; print(e.mass, e.description)<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Thu, May 26, 2016 at 4:43 PM, Vladimir.S via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     Or(if we are sure we&#39;ll don&#39;t forget to udpate `infoDict` in case of<br>&gt;&gt;     new added case in future):<br>&gt;&gt;<br>&gt;&gt;     enum Planet {<br>&gt;&gt;         case earth<br>&gt;&gt;         case moon<br>&gt;&gt;<br>&gt;&gt;         struct PlanetInfo {<br>&gt;&gt;             var mass: Double<br>&gt;&gt;             var description: String<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         private static let infoDict = [<br>&gt;&gt;             Planet.earth :<br>&gt;&gt;                 PlanetInfo(mass: 1.0, description:&quot;Earth is our home&quot;),<br>&gt;&gt;             .moon:<br>&gt;&gt;                 PlanetInfo(mass: 0.2, description:&quot;Just a moon&quot;),<br>&gt;&gt;             ]<br>&gt;&gt;<br>&gt;&gt;         var info : PlanetInfo { return Planet.infoDict[self]! }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     But I agree with you, IMO we need static stored properties for each case.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     On 26.05.2016 18 &lt;tel:26.05.2016%2018&gt;:15, Jānis Kiršteins wrote:<br>&gt;&gt;<br>&gt;&gt;         The problem is that PlanetInfo values are recreated each time while<br>&gt;&gt;         they are static. Imagine if PlanetInfo where some type that expensive<br>&gt;&gt;         to create performance wise.<br>&gt;&gt;<br>&gt;&gt;         You could solve it by:<br>&gt;&gt;<br>&gt;&gt;         enum Planet {<br>&gt;&gt;             struct PlanetInfo {<br>&gt;&gt;                 var mass: Double<br>&gt;&gt;                 var description: String<br>&gt;&gt;             }<br>&gt;&gt;<br>&gt;&gt;             case earth<br>&gt;&gt;             case moon<br>&gt;&gt;<br>&gt;&gt;             private static earthInfo = PlanetInfo(mass: 1.0, description:<br>&gt;&gt;         &quot;Earth is our home&quot;)<br>&gt;&gt;             private static moonInfo = PlanetInfo(mass: 0.2, description:<br>&gt;&gt;         &quot;Just a moon&quot;)<br>&gt;&gt;<br>&gt;&gt;             var info : PlanetInfo {<br>&gt;&gt;                 switch self {<br>&gt;&gt;                     case earth: return PlanetInfo.earthInfo<br>&gt;&gt;                     case moon: return PlanetInfo.moonInfo<br>&gt;&gt;                 }<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         But that again more verbose. The proposed solution is explicit that<br>&gt;&gt;         those properties are static for each case.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         On Thu, May 26, 2016 at 5:58 PM, Vladimir.S via swift-evolution<br>&gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;             I support the proposal, but couldn&#39;t the initial target be<br>&gt;&gt;             achieved today<br>&gt;&gt;             with such (more verbose,yes) solution? :<br>&gt;&gt;<br>&gt;&gt;             enum Planet {<br>&gt;&gt;                 struct PlanetInfo {<br>&gt;&gt;                     var mass: Double<br>&gt;&gt;                     var description: String<br>&gt;&gt;                 }<br>&gt;&gt;<br>&gt;&gt;                 case earth<br>&gt;&gt;                 case moon<br>&gt;&gt;<br>&gt;&gt;                 var info : PlanetInfo {<br>&gt;&gt;                     switch self {<br>&gt;&gt;                         case earth: return PlanetInfo(mass: 1.0,<br>&gt;&gt;             description: &quot;Earth is<br>&gt;&gt;             our home&quot;)<br>&gt;&gt;                         case moon: return PlanetInfo(mass: 0.2,<br>&gt;&gt;             description: &quot;Just a<br>&gt;&gt;             moon&quot;)<br>&gt;&gt;                     }<br>&gt;&gt;                 }<br>&gt;&gt;             }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;             let e = Planet.earth<br>&gt;&gt;             print(e, e.info.description)<br>&gt;&gt;<br>&gt;&gt;             let m = Planet.moon<br>&gt;&gt;             print(m, m.info.description)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;             On 26.05.2016 8:26, Charlie Monroe via swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                     What this proposal is asking for is an easier way to<br>&gt;&gt;                     have derived values<br>&gt;&gt;                     from enum cases. Asking for more flexible RawValues<br>&gt;&gt;                     means mass and radius<br>&gt;&gt;                     are not derived, they are the source of truth. It goes<br>&gt;&gt;                     against the whole<br>&gt;&gt;                     point of RawRepresentable. You are not saying ‘Mercury<br>&gt;&gt;                     is identified by<br>&gt;&gt;                     the case .mercury’, you are saying ‘Mercury is<br>&gt;&gt;                     identified by a mass of<br>&gt;&gt;                     3.303e+23’. It’s backwards.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                 I see what Janis meant in the first email. It&#39;s not that<br>&gt;&gt;                 the planet would<br>&gt;&gt;                 be identified by the mass or radius. It could very much be<br>&gt;&gt;<br>&gt;&gt;                 case Mercury = 1 where (mass: 3, radius: 2),<br>&gt;&gt;<br>&gt;&gt;                 - Mercury&#39;s rawValue would be 1.<br>&gt;&gt;<br>&gt;&gt;                 The issue here is that sometimes you want additional<br>&gt;&gt;                 information with the<br>&gt;&gt;                 enum. There are many cases where you extend the enum with a<br>&gt;&gt;                 variable:<br>&gt;&gt;<br>&gt;&gt;                 enum Error {<br>&gt;&gt;                 case NoError<br>&gt;&gt;                 case FileNotFound<br>&gt;&gt;                 ...<br>&gt;&gt;<br>&gt;&gt;                 var isFatal: Bool {<br>&gt;&gt;                 /// swtich over all values of self goes here.<br>&gt;&gt;                 }<br>&gt;&gt;<br>&gt;&gt;                 var isNetworkError: Bool {<br>&gt;&gt;                 /// swtich over all values of self goes here.<br>&gt;&gt;                 }<br>&gt;&gt;<br>&gt;&gt;                 var isIOError: Bool {<br>&gt;&gt;                 /// swtich over all values of self goes here.<br>&gt;&gt;                 }<br>&gt;&gt;                 }<br>&gt;&gt;<br>&gt;&gt;                 What the propsal suggests is to simplify this to the<br>&gt; following:<br>&gt;&gt;<br>&gt;&gt;                 enum Error {<br>&gt;&gt;                 var isFatal: Bool<br>&gt;&gt;<br>&gt;&gt;                 case NoError where (isFatal: false, isNetworkError: false,<br>&gt;&gt;                 isIOError:<br>&gt;&gt;                 false)<br>&gt;&gt;                 case FileNotFound  where (isFatal: true, isNetworkError:<br>&gt;&gt;                 false, isIOError:<br>&gt;&gt;                 true)<br>&gt;&gt;                 ...<br>&gt;&gt;<br>&gt;&gt;                 }<br>&gt;&gt;<br>&gt;&gt;                 So that you assign the additional information to the enum<br>&gt;&gt;                 value itself.<br>&gt;&gt;<br>&gt;&gt;                 Charlie<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                         On 26 May 2016, at 1:47 PM, David Sweeris via<br>&gt;&gt;                         swift-evolution<br>&gt;&gt;                         &lt;swift-evolution at swift.org<br>&gt;&gt;                         &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;                         &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;                         &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                             On May 25, 2016, at 10:27 PM, Jacob<br>&gt;&gt;                             Bandes-Storch &lt;jtbandes at gmail.com<br>&gt;&gt;                             &lt;mailto:jtbandes at gmail.com&gt;<br>&gt;&gt;                             &lt;mailto:jtbandes at gmail.com<br>&gt;&gt;                             &lt;mailto:jtbandes at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;                             On Wed, May 25, 2016 at 8:15 PM, David Sweeris<br>&gt;&gt;                             via swift-evolution<br>&gt;&gt;                             &lt;swift-evolution at swift.org<br>&gt;&gt;                             &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;                             &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;                             &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;                                 On May 25, 2016, at 7:37 AM, Leonardo<br>&gt;&gt;                             Pessoa via swift-evolution<br>&gt;&gt;                                 &lt;swift-evolution at swift.org<br>&gt;&gt;                             &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;                             &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;                             &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;                             wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                                     Hi,<br>&gt;&gt;<br>&gt;&gt;                                     Couldn&#39;t this be solved by using<br>&gt;&gt;                                 tuples? If not because the syntax<br>&gt;&gt;                                     is not allowed I think this would be<br>&gt;&gt;                                 more coherent to do it using<br>&gt;&gt;                                     current syntax.<br>&gt;&gt;<br>&gt;&gt;                                     enum Planet : (mass: Float, radius:<br>&gt;&gt;                                 Float) {<br>&gt;&gt;                                         case mercury = (mass: 3.303e+23,<br>&gt;&gt;                                 radius: 2.4397e6)<br>&gt;&gt;                                         case venus = (mass: 4.869e+24,<br>&gt;&gt;                                 radius: 6.0518e6)<br>&gt;&gt;                                         case earth = (mass: 5.976e+24,<br>&gt;&gt;                                 radius: 6.37814e6)<br>&gt;&gt;                                         case mars = (mass: 6.421e+23,<br>&gt;&gt;                                 radius: 3.3972e6)<br>&gt;&gt;                                         case jupiter = (mass: 1.9e+27,<br>&gt;&gt;                                 radius: 7.1492e7)<br>&gt;&gt;                                         case saturn = (mass: 5.688e+26,<br>&gt;&gt;                                 radius: 6.0268e7)<br>&gt;&gt;                                         case uranus = (mass: 8.686e+25,<br>&gt;&gt;                                 radius: 2.5559e7)<br>&gt;&gt;                                         case neptune = (mass: 1.024e+26,<br>&gt;&gt;                                 radius: 2.4746e7)<br>&gt;&gt;                                     }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                                 This would be my preferred solution… AFAIK,<br>&gt;&gt;                             the only reason we<br>&gt;&gt;                                 can’t do it now is that Swift currently<br>&gt;&gt;                             requires RawValue be an<br>&gt;&gt;                                 integer, floating-point value, or string. I<br>&gt;&gt;                             don’t know why the<br>&gt;&gt;                                 language has this restriction, so I can’t<br>&gt;&gt;                             comment on how hard it<br>&gt;&gt;                                 would be to change.<br>&gt;&gt;<br>&gt;&gt;                                 - Dave Sweeris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                             Except you&#39;d have to write<br>&gt;&gt;                             Planet.mercury.rawValue.mass, rather than<br>&gt;&gt;                             Planet.mercury.mass.<br>&gt;&gt;<br>&gt;&gt;                             This could be one or two proposals: allow enums<br>&gt;&gt;                             with tuple RawValues,<br>&gt;&gt;                             and allow `TupleName.caseName.propertyName` to<br>&gt;&gt;                             access a tuple element<br>&gt;&gt;                             without going through .rawValue.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                         Good point… Has there been a thread on allowing<br>&gt;&gt;                         raw-valued enums to be<br>&gt;&gt;                         treated as constants of type `RawValue` yet? Either<br>&gt;&gt;                         way, removing the<br>&gt;&gt;                         restriction on what types can be a RawValue is<br>&gt;&gt;                         still my preferred<br>&gt;&gt;                         solution.<br>&gt;&gt;<br>&gt;&gt;                         - Dave Sweeris<br>&gt;&gt;                         _______________________________________________<br>&gt;&gt;                         swift-evolution mailing list<br>&gt;&gt;                         swift-evolution at swift.org<br>&gt;&gt;                         &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;                         &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;                         &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                     _______________________________________________<br>&gt;&gt;                     swift-evolution mailing list<br>&gt;&gt;                     swift-evolution at swift.org<br>&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;                     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                 _______________________________________________<br>&gt;&gt;                 swift-evolution mailing list<br>&gt;&gt;                 swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;             _______________________________________________<br>&gt;&gt;             swift-evolution mailing list<br>&gt;&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     _______________________________________________<br>&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/2e3ba783/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal] Enums with static storedpropertiesforeach case</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 26, 2016 at 10:00:00pm</p></header><div class="content"><p>I personally don&#39;t like the Java values() solution. Nor the solution based on dictionary where you need to use ! to unwrap the optionals.<br></p><p>There are IMHO only two ways to solve this:<br></p><p>1) allow enums with RawValue being object (AnyClass) and make allow case values to be computed. In the Planet case:<br></p><p>enum Planets: Planet {<br>	case Earth = Planet(mass: 1, radius: 2)<br>	...<br>}<br></p><p>The switch would be performed using ===, i.e. it would be allowed to have two cases with the same mass and radius.<br></p><p>This unfortunately faces a lot of issues, including if you have an ObjC class that may returns in all cases a singleton and all cases would have the same value. This could be handled by an assertion at launch.<br></p><p><br>2) allow auto-generation of computed variables on enums (partially as I&#39;ve proposed):<br></p><p>enum Planets {<br>	@auto var mass: Double /// @auto indicates it&#39;s auto-generated<br>	@auto var radius: Double<br></p><p>	/// The enum value is .Earth and has mass and radius properties.<br>	/// All cases would need to declare these and only literals would<br>	/// be allowed - i.e. numbers + strings.<br>	case Earth where (mass: 1.0, radius: 2.0)<br>	...<br></p><p>}<br></p><p>which would do nothing else than create the following code:<br></p><p>enum Planets {<br>	var mass: Double {<br>		switch self {<br>		case .Earth: return 1.0<br>		...<br>		}<br>	}<br></p><p>	var radius: Double {<br>		switch self {<br>		case .Earth: return 2.0<br>		...<br>		}<br>	}<br></p><p>	case Earth<br>}<br></p><p><br></p><p>&gt; On May 26, 2016, at 10:03 PM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I get it and think this was really very interesting in Delphi and I wouldn&#39;t mind having something like this in Swift. But despite being able to extend associated information through the use of another array we&#39;d still have more verbosity and scattering than with tuples to implement the examples discussed. And we can already have enum dictionaries just not checking automatically if all enum values have been covered. Moreover there is no loss in having both solutions.<br>&gt; <br>&gt; I mentioned the values() method also because I miss a way to iterate through all the values on an enum and since it seems we&#39;re discussing the entire way to work with enums here it was worth bringing it up.<br>&gt; <br>&gt; From: Vladimir.S &lt;mailto:svabox at gmail.com&gt;<br>&gt; Sent: ‎26/‎05/‎2016 03:06 PM<br>&gt; To: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;<br>&gt; Cc: swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Proposal] Enums with static storedpropertiesforeach case<br>&gt; <br>&gt; Yes, this was mentioned in a similar thread in this email list earlier. <br>&gt; There is even some proposal for such .values() for Swift enums.<br>&gt; <br>&gt; But this values() in Java is not the same thing as discussed dictionary <br>&gt; with *keys* of enum type or Delphi&#39;s arrays with *index* of enum type.<br>&gt; <br>&gt; Could you write Java&#39;s example for array/dictionary of String which <br>&gt; *index*(or key) will be of enum type? *And* compiler will check that value <br>&gt; for each enum case is set in case of array of constants like:<br>&gt; MyConsts : array [TMyEnum] of String = (&#39;just one&#39;, &#39;two here&#39;)<br>&gt; // compiler will always check that value assigned for each case<br>&gt; <br>&gt; <br>&gt; On 26.05.2016 20:58, Leonardo Pessoa wrote:<br>&gt; &gt; Java enums automatically have a static values() method that return an array<br>&gt; &gt; with all values in an enum.<br>&gt; &gt; ---------------------------------------------------------------------------<br>&gt; &gt; From: Vladimir.S via swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; Sent: ‎26/‎05/‎2016 02:36 PM<br>&gt; &gt; To: Ross O&#39;Brien &lt;mailto:narrativium+swift at gmail.com&gt;<br>&gt; &gt; Cc: swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; Subject: Re: [swift-evolution] [Proposal] Enums with static stored<br>&gt; &gt; propertiesforeach case<br>&gt; &gt;<br>&gt; &gt; On 26.05.2016 19:50, Ross O&#39;Brien wrote:<br>&gt; &gt;&gt; Perhaps there&#39;s an argument to be made for a sort of &#39;enumDictionary&#39; type<br>&gt; &gt;&gt; - a dictionary whose keys are all the cases of an enum, and is thus<br>&gt; &gt;&gt; guaranteed to produce a value.<br>&gt; &gt;<br>&gt; &gt; In Delphi(Pascal) you can define an array with indexes of enum type i.e.:<br>&gt; &gt; type<br>&gt; &gt;    TMyEnum = (One, Two)<br>&gt; &gt; var<br>&gt; &gt;    MyVal : array[TMyEnum] of String<br>&gt; &gt; const<br>&gt; &gt;    MyConsts : array [TMyEnum] of String = (&#39;just one&#39;, &#39;two here&#39;)<br>&gt; &gt;    // compiler will check that values for each enum were specified here<br>&gt; &gt;<br>&gt; &gt; ,so you can do<br>&gt; &gt; var e: TMyEnum<br>&gt; &gt; e := One;<br>&gt; &gt; MyVal[e] := &#39;hello&#39;;<br>&gt; &gt; s2 := MyConsts[e];<br>&gt; &gt;<br>&gt; &gt; This is really useful and used a lot. And this is safe in meaning compiler<br>&gt; &gt; will notify you if you changed the enum - you&#39;ll have to change such<br>&gt; &gt; constant array.<br>&gt; &gt;<br>&gt; &gt; I wish we&#39;ll have something like this in Swift.<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I think the question I have is how you&#39;d access the values, syntactically.<br>&gt; &gt;&gt; To use the Planet example, if &#39;.earth&#39; is a value of the Planet enum, is<br>&gt; &gt;&gt; &#39;.earth.mass&#39; an acceptable way to access its mass? Or perhaps<br>&gt; &gt;&gt; &#39;Planet[.earth].mass&#39;?<br>&gt; &gt;<br>&gt; &gt; Just like .rawValue currently, i.e.<br>&gt; &gt; let e = Planet.earth<br>&gt; &gt; print(e.mass, e.description)<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Thu, May 26, 2016 at 4:43 PM, Vladimir.S via swift-evolution<br>&gt; &gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;     Or(if we are sure we&#39;ll don&#39;t forget to udpate `infoDict` in case of<br>&gt; &gt;&gt;     new added case in future):<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;     enum Planet {<br>&gt; &gt;&gt;         case earth<br>&gt; &gt;&gt;         case moon<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;         struct PlanetInfo {<br>&gt; &gt;&gt;             var mass: Double<br>&gt; &gt;&gt;             var description: String<br>&gt; &gt;&gt;         }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;         private static let infoDict = [<br>&gt; &gt;&gt;             Planet.earth :<br>&gt; &gt;&gt;                 PlanetInfo(mass: 1.0, description:&quot;Earth is our home&quot;),<br>&gt; &gt;&gt;             .moon:<br>&gt; &gt;&gt;                 PlanetInfo(mass: 0.2, description:&quot;Just a moon&quot;),<br>&gt; &gt;&gt;             ]<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;         var info : PlanetInfo { return Planet.infoDict[self]! }<br>&gt; &gt;&gt;     }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;     But I agree with you, IMO we need static stored properties for each case.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;     On 26.05.2016 18 &lt;tel:26.05.2016%2018&gt;:15, Jānis Kiršteins wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;         The problem is that PlanetInfo values are recreated each time while<br>&gt; &gt;&gt;         they are static. Imagine if PlanetInfo where some type that expensive<br>&gt; &gt;&gt;         to create performance wise.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;         You could solve it by:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;         enum Planet {<br>&gt; &gt;&gt;             struct PlanetInfo {<br>&gt; &gt;&gt;                 var mass: Double<br>&gt; &gt;&gt;                 var description: String<br>&gt; &gt;&gt;             }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;             case earth<br>&gt; &gt;&gt;             case moon<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;             private static earthInfo = PlanetInfo(mass: 1.0, description:<br>&gt; &gt;&gt;         &quot;Earth is our home&quot;)<br>&gt; &gt;&gt;             private static moonInfo = PlanetInfo(mass: 0.2, description:<br>&gt; &gt;&gt;         &quot;Just a moon&quot;)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;             var info : PlanetInfo {<br>&gt; &gt;&gt;                 switch self {<br>&gt; &gt;&gt;                     case earth: return PlanetInfo.earthInfo<br>&gt; &gt;&gt;                     case moon: return PlanetInfo.moonInfo<br>&gt; &gt;&gt;                 }<br>&gt; &gt;&gt;             }<br>&gt; &gt;&gt;         }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;         But that again more verbose. The proposed solution is explicit that<br>&gt; &gt;&gt;         those properties are static for each case.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;         On Thu, May 26, 2016 at 5:58 PM, Vladimir.S via swift-evolution<br>&gt; &gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;             I support the proposal, but couldn&#39;t the initial target be<br>&gt; &gt;&gt;             achieved today<br>&gt; &gt;&gt;             with such (more verbose,yes) solution? :<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;             enum Planet {<br>&gt; &gt;&gt;                 struct PlanetInfo {<br>&gt; &gt;&gt;                     var mass: Double<br>&gt; &gt;&gt;                     var description: String<br>&gt; &gt;&gt;                 }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                 case earth<br>&gt; &gt;&gt;                 case moon<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                 var info : PlanetInfo {<br>&gt; &gt;&gt;                     switch self {<br>&gt; &gt;&gt;                         case earth: return PlanetInfo(mass: 1.0,<br>&gt; &gt;&gt;             description: &quot;Earth is<br>&gt; &gt;&gt;             our home&quot;)<br>&gt; &gt;&gt;                         case moon: return PlanetInfo(mass: 0.2,<br>&gt; &gt;&gt;             description: &quot;Just a<br>&gt; &gt;&gt;             moon&quot;)<br>&gt; &gt;&gt;                     }<br>&gt; &gt;&gt;                 }<br>&gt; &gt;&gt;             }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;             let e = Planet.earth<br>&gt; &gt;&gt;             print(e, e.info.description)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;             let m = Planet.moon<br>&gt; &gt;&gt;             print(m, m.info.description)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;             On 26.05.2016 8:26, Charlie Monroe via swift-evolution wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                     What this proposal is asking for is an easier way to<br>&gt; &gt;&gt;                     have derived values<br>&gt; &gt;&gt;                     from enum cases. Asking for more flexible RawValues<br>&gt; &gt;&gt;                     means mass and radius<br>&gt; &gt;&gt;                     are not derived, they are the source of truth. It goes<br>&gt; &gt;&gt;                     against the whole<br>&gt; &gt;&gt;                     point of RawRepresentable. You are not saying ‘Mercury<br>&gt; &gt;&gt;                     is identified by<br>&gt; &gt;&gt;                     the case .mercury’, you are saying ‘Mercury is<br>&gt; &gt;&gt;                     identified by a mass of<br>&gt; &gt;&gt;                     3.303e+23’. It’s backwards.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                 I see what Janis meant in the first email. It&#39;s not that<br>&gt; &gt;&gt;                 the planet would<br>&gt; &gt;&gt;                 be identified by the mass or radius. It could very much be<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                 case Mercury = 1 where (mass: 3, radius: 2),<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                 - Mercury&#39;s rawValue would be 1.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                 The issue here is that sometimes you want additional<br>&gt; &gt;&gt;                 information with the<br>&gt; &gt;&gt;                 enum. There are many cases where you extend the enum with a<br>&gt; &gt;&gt;                 variable:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                 enum Error {<br>&gt; &gt;&gt;                 case NoError<br>&gt; &gt;&gt;                 case FileNotFound<br>&gt; &gt;&gt;                 ...<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                 var isFatal: Bool {<br>&gt; &gt;&gt;                 /// swtich over all values of self goes here.<br>&gt; &gt;&gt;                 }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                 var isNetworkError: Bool {<br>&gt; &gt;&gt;                 /// swtich over all values of self goes here.<br>&gt; &gt;&gt;                 }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                 var isIOError: Bool {<br>&gt; &gt;&gt;                 /// swtich over all values of self goes here.<br>&gt; &gt;&gt;                 }<br>&gt; &gt;&gt;                 }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                 What the propsal suggests is to simplify this to the<br>&gt; &gt; following:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                 enum Error {<br>&gt; &gt;&gt;                 var isFatal: Bool<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                 case NoError where (isFatal: false, isNetworkError: false,<br>&gt; &gt;&gt;                 isIOError:<br>&gt; &gt;&gt;                 false)<br>&gt; &gt;&gt;                 case FileNotFound  where (isFatal: true, isNetworkError:<br>&gt; &gt;&gt;                 false, isIOError:<br>&gt; &gt;&gt;                 true)<br>&gt; &gt;&gt;                 ...<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                 }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                 So that you assign the additional information to the enum<br>&gt; &gt;&gt;                 value itself.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                 Charlie<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                         On 26 May 2016, at 1:47 PM, David Sweeris via<br>&gt; &gt;&gt;                         swift-evolution<br>&gt; &gt;&gt;                         &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;                         &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;                         &lt;mailto:swift-evolution at swift.org<br>&gt; &gt;&gt;                         &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                             On May 25, 2016, at 10:27 PM, Jacob<br>&gt; &gt;&gt;                             Bandes-Storch &lt;jtbandes at gmail.com<br>&gt; &gt;&gt;                             &lt;mailto:jtbandes at gmail.com&gt;<br>&gt; &gt;&gt;                             &lt;mailto:jtbandes at gmail.com<br>&gt; &gt;&gt;                             &lt;mailto:jtbandes at gmail.com&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                             On Wed, May 25, 2016 at 8:15 PM, David Sweeris<br>&gt; &gt;&gt;                             via swift-evolution<br>&gt; &gt;&gt;                             &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;                             &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;                             &lt;mailto:swift-evolution at swift.org<br>&gt; &gt;&gt;                             &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                                 On May 25, 2016, at 7:37 AM, Leonardo<br>&gt; &gt;&gt;                             Pessoa via swift-evolution<br>&gt; &gt;&gt;                                 &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;                             &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;                             &lt;mailto:swift-evolution at swift.org<br>&gt; &gt;&gt;                             &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; &gt;&gt;                             wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                                     Hi,<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                                     Couldn&#39;t this be solved by using<br>&gt; &gt;&gt;                                 tuples? If not because the syntax<br>&gt; &gt;&gt;                                     is not allowed I think this would be<br>&gt; &gt;&gt;                                 more coherent to do it using<br>&gt; &gt;&gt;                                     current syntax.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                                     enum Planet : (mass: Float, radius:<br>&gt; &gt;&gt;                                 Float) {<br>&gt; &gt;&gt;                                         case mercury = (mass: 3.303e+23,<br>&gt; &gt;&gt;                                 radius: 2.4397e6)<br>&gt; &gt;&gt;                                         case venus = (mass: 4.869e+24,<br>&gt; &gt;&gt;                                 radius: 6.0518e6)<br>&gt; &gt;&gt;                                         case earth = (mass: 5.976e+24,<br>&gt; &gt;&gt;                                 radius: 6.37814e6)<br>&gt; &gt;&gt;                                         case mars = (mass: 6.421e+23,<br>&gt; &gt;&gt;                                 radius: 3.3972e6)<br>&gt; &gt;&gt;                                         case jupiter = (mass: 1.9e+27,<br>&gt; &gt;&gt;                                 radius: 7.1492e7)<br>&gt; &gt;&gt;                                         case saturn = (mass: 5.688e+26,<br>&gt; &gt;&gt;                                 radius: 6.0268e7)<br>&gt; &gt;&gt;                                         case uranus = (mass: 8.686e+25,<br>&gt; &gt;&gt;                                 radius: 2.5559e7)<br>&gt; &gt;&gt;                                         case neptune = (mass: 1.024e+26,<br>&gt; &gt;&gt;                                 radius: 2.4746e7)<br>&gt; &gt;&gt;                                     }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                                 This would be my preferred solution… AFAIK,<br>&gt; &gt;&gt;                             the only reason we<br>&gt; &gt;&gt;                                 can’t do it now is that Swift currently<br>&gt; &gt;&gt;                             requires RawValue be an<br>&gt; &gt;&gt;                                 integer, floating-point value, or string. I<br>&gt; &gt;&gt;                             don’t know why the<br>&gt; &gt;&gt;                                 language has this restriction, so I can’t<br>&gt; &gt;&gt;                             comment on how hard it<br>&gt; &gt;&gt;                                 would be to change.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                                 - Dave Sweeris<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                             Except you&#39;d have to write<br>&gt; &gt;&gt;                             Planet.mercury.rawValue.mass, rather than<br>&gt; &gt;&gt;                             Planet.mercury.mass.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                             This could be one or two proposals: allow enums<br>&gt; &gt;&gt;                             with tuple RawValues,<br>&gt; &gt;&gt;                             and allow `TupleName.caseName.propertyName` to<br>&gt; &gt;&gt;                             access a tuple element<br>&gt; &gt;&gt;                             without going through .rawValue.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                         Good point… Has there been a thread on allowing<br>&gt; &gt;&gt;                         raw-valued enums to be<br>&gt; &gt;&gt;                         treated as constants of type `RawValue` yet? Either<br>&gt; &gt;&gt;                         way, removing the<br>&gt; &gt;&gt;                         restriction on what types can be a RawValue is<br>&gt; &gt;&gt;                         still my preferred<br>&gt; &gt;&gt;                         solution.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                         - Dave Sweeris<br>&gt; &gt;&gt;                         _______________________________________________<br>&gt; &gt;&gt;                         swift-evolution mailing list<br>&gt; &gt;&gt;                         swift-evolution at swift.org<br>&gt; &gt;&gt;                         &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;                         &lt;mailto:swift-evolution at swift.org<br>&gt; &gt;&gt;                         &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                     _______________________________________________<br>&gt; &gt;&gt;                     swift-evolution mailing list<br>&gt; &gt;&gt;                     swift-evolution at swift.org<br>&gt; &gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt; &gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;                     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;                 _______________________________________________<br>&gt; &gt;&gt;                 swift-evolution mailing list<br>&gt; &gt;&gt;                 swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;             _______________________________________________<br>&gt; &gt;&gt;             swift-evolution mailing list<br>&gt; &gt;&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;     _______________________________________________<br>&gt; &gt;&gt;     swift-evolution mailing list<br>&gt; &gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/0568b456/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] Enums with static storedpropertiesforeach case</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 27, 2016 at 12:00:00am</p></header><div class="content"><p>IMO (now I agree with Leonardo) all we need is allowing a tuple as raw type <br>for enum and in this case compiler should allow as to skip &#39;.rawValue.&#39; and <br>to use tuple values on enum instance directly like:<br></p><p>enum Planets: (mass: Double, description: String) {<br>   case earth = (mass: 1.0, description: &quot;Earth&quot;)<br>   case moon = (mass: 0.2, description: &quot;Moon&quot;)<br>}<br></p><p>print(Planets.earth.mass)<br></p><p>But for this, enum should allows raw type representation not just by <br>Int/Double/String as now(correct me if forgot something), but at least by <br>tuple.<br>Currently we can actually have enum Planet : PlanetInfo, but raw value <br>could be represented only with string like<br></p><p>enum Planet : PlanetInfo {<br>     case earth = &quot;earth&quot; // represents PlanetInfo(1.0, &quot;Earth&quot;)<br>     case moon = &quot;moon&quot; // represents PlanetInfo(0.2, &quot;Moon&quot;)<br>}<br>and then use:<br>print(Planets.earth.rawValue.mass)<br></p><p>But you need a lot(relative) of code to make simple PlanetInfo struct <br>RawRepresentable+StringLiteralConvertible+Equatable<br></p><p>Do we actually have some proposal for enum improvement? I mean at least <br>&#39;.allValues&#39; feature and this &#39;tuple raw value&#39; feature?<br>Probably additionally I&#39;d like to see some &#39;.next/.prev&#39; methods for enums <br>without associated values.<br></p><p>On 26.05.2016 23:27, Charlie Monroe wrote:<br>&gt; I personally don&#39;t like the Java values() solution. Nor the solution based<br>&gt; on dictionary where you need to use ! to unwrap the optionals.<br>&gt;<br>&gt; There are IMHO only two ways to solve this:<br>&gt;<br>&gt; 1) allow enums with RawValue being object (AnyClass) and make allow case<br>&gt; values to be computed. In the Planet case:<br>&gt;<br>&gt; enum Planets: Planet {<br>&gt; case Earth = Planet(mass: 1, radius: 2)<br>&gt; ...<br>&gt; }<br>&gt;<br>&gt; The switch would be performed using ===, i.e. it would be allowed to have<br>&gt; two cases with the same mass and radius.<br>&gt;<br>&gt; This unfortunately faces a lot of issues, including if you have an ObjC<br>&gt; class that may returns in all cases a singleton and all cases would have<br>&gt; the same value. This could be handled by an assertion at launch.<br>&gt;<br>&gt;<br>&gt; 2) allow auto-generation of computed variables on enums (partially as I&#39;ve<br>&gt; proposed):<br>&gt;<br>&gt; enum Planets {<br>&gt; @auto var mass: Double /// @auto indicates it&#39;s auto-generated<br>&gt; @auto var radius: Double<br>&gt;<br>&gt; /// The enum value is .Earth and has mass and radius properties.<br>&gt; /// All cases would need to declare these and only literals would<br>&gt; /// be allowed - i.e. numbers + strings.<br>&gt; case Earth where (mass: 1.0, radius: 2.0)<br>&gt; ...<br>&gt;<br>&gt; }<br>&gt;<br>&gt; which would do nothing else than create the following code:<br>&gt;<br>&gt; enum Planets {<br>&gt; var mass: Double {<br>&gt; switch self {<br>&gt; case .Earth: return 1.0<br>&gt; ...<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; var radius: Double {<br>&gt; switch self {<br>&gt; case .Earth: return 2.0<br>&gt; ...<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; case Earth<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; On May 26, 2016, at 10:03 PM, Leonardo Pessoa via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I get it and think this was really very interesting in Delphi and I<br>&gt;&gt; wouldn&#39;t mind having something like this in Swift. But despite being able<br>&gt;&gt; to extend associated information through the use of another array we&#39;d<br>&gt;&gt; still have more verbosity and scattering than with tuples to implement<br>&gt;&gt; the examples discussed. And we can already have enum dictionaries just<br>&gt;&gt; not checking automatically if all enum values have been covered. Moreover<br>&gt;&gt; there is no loss in having both solutions.<br>&gt;&gt;<br>&gt;&gt; I mentioned the values() method also because I miss a way to iterate<br>&gt;&gt; through all the values on an enum and since it seems we&#39;re discussing the<br>&gt;&gt; entire way to work with enums here it was worth bringing it up.<br>&gt;&gt;<br>&gt;&gt; ---------------------------------------------------------------------------<br>&gt;&gt; From: Vladimir.S &lt;mailto:svabox at gmail.com&gt;<br>&gt;&gt; Sent: ‎26/‎05/‎2016 03:06 PM<br>&gt;&gt; To: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;<br>&gt;&gt; Cc: swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; Subject: Re: [swift-evolution] [Proposal] Enums with static<br>&gt;&gt; storedpropertiesforeach case<br>&gt;&gt;<br>&gt;&gt; Yes, this was mentioned in a similar thread in this email list earlier.<br>&gt;&gt; There is even some proposal for such .values() for Swift enums.<br>&gt;&gt;<br>&gt;&gt; But this values() in Java is not the same thing as discussed dictionary<br>&gt;&gt; with *keys* of enum type or Delphi&#39;s arrays with *index* of enum type.<br>&gt;&gt;<br>&gt;&gt; Could you write Java&#39;s example for array/dictionary of String which<br>&gt;&gt; *index*(or key) will be of enum type? *And* compiler will check that value<br>&gt;&gt; for each enum case is set in case of array of constants like:<br>&gt;&gt; MyConsts : array [TMyEnum] of String = (&#39;just one&#39;, &#39;two here&#39;)<br>&gt;&gt; // compiler will always check that value assigned for each case<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 26.05.2016 20:58, Leonardo Pessoa wrote:<br>&gt;&gt; &gt; Java enums automatically have a static values() method that return an array<br>&gt;&gt; &gt; with all values in an enum.<br>&gt;&gt; &gt; ---------------------------------------------------------------------------<br>&gt;&gt; &gt; From: Vladimir.S via swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; Sent: ‎26/‎05/‎2016 02:36 PM<br>&gt;&gt; &gt; To: Ross O&#39;Brien &lt;mailto:narrativium+swift at gmail.com&gt;<br>&gt;&gt; &gt; Cc: swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; Subject: Re: [swift-evolution] [Proposal] Enums with static stored<br>&gt;&gt; &gt; propertiesforeach case<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On 26.05.2016 19:50, Ross O&#39;Brien wrote:<br>&gt;&gt; &gt;&gt; Perhaps there&#39;s an argument to be made for a sort of &#39;enumDictionary&#39; type<br>&gt;&gt; &gt;&gt; - a dictionary whose keys are all the cases of an enum, and is thus<br>&gt;&gt; &gt;&gt; guaranteed to produce a value.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In Delphi(Pascal) you can define an array with indexes of enum type i.e.:<br>&gt;&gt; &gt; type<br>&gt;&gt; &gt;    TMyEnum = (One, Two)<br>&gt;&gt; &gt; var<br>&gt;&gt; &gt;    MyVal : array[TMyEnum] of String<br>&gt;&gt; &gt; const<br>&gt;&gt; &gt;    MyConsts : array [TMyEnum] of String = (&#39;just one&#39;, &#39;two here&#39;)<br>&gt;&gt; &gt;    // compiler will check that values for each enum were specified here<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ,so you can do<br>&gt;&gt; &gt; var e: TMyEnum<br>&gt;&gt; &gt; e := One;<br>&gt;&gt; &gt; MyVal[e] := &#39;hello&#39;;<br>&gt;&gt; &gt; s2 := MyConsts[e];<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This is really useful and used a lot. And this is safe in meaning compiler<br>&gt;&gt; &gt; will notify you if you changed the enum - you&#39;ll have to change such<br>&gt;&gt; &gt; constant array.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I wish we&#39;ll have something like this in Swift.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I think the question I have is how you&#39;d access the values, syntactically.<br>&gt;&gt; &gt;&gt; To use the Planet example, if &#39;.earth&#39; is a value of the Planet enum, is<br>&gt;&gt; &gt;&gt; &#39;.earth.mass&#39; an acceptable way to access its mass? Or perhaps<br>&gt;&gt; &gt;&gt; &#39;Planet[.earth].mass&#39;?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Just like .rawValue currently, i.e.<br>&gt;&gt; &gt; let e = Planet.earth<br>&gt;&gt; &gt; print(e.mass, e.description)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; On Thu, May 26, 2016 at 4:43 PM, Vladimir.S via swift-evolution<br>&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;     Or(if we are sure we&#39;ll don&#39;t forget to udpate `infoDict` in case of<br>&gt;&gt; &gt;&gt;     new added case in future):<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;     enum Planet {<br>&gt;&gt; &gt;&gt;         case earth<br>&gt;&gt; &gt;&gt;         case moon<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;         struct PlanetInfo {<br>&gt;&gt; &gt;&gt;             var mass: Double<br>&gt;&gt; &gt;&gt;             var description: String<br>&gt;&gt; &gt;&gt;         }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;         private static let infoDict = [<br>&gt;&gt; &gt;&gt;             Planet.earth :<br>&gt;&gt; &gt;&gt;                 PlanetInfo(mass: 1.0, description:&quot;Earth is our home&quot;),<br>&gt;&gt; &gt;&gt;             .moon:<br>&gt;&gt; &gt;&gt;                 PlanetInfo(mass: 0.2, description:&quot;Just a moon&quot;),<br>&gt;&gt; &gt;&gt;             ]<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;         var info : PlanetInfo { return Planet.infoDict[self]! }<br>&gt;&gt; &gt;&gt;     }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;     But I agree with you, IMO we need static stored properties for<br>&gt;&gt; each case.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;     On 26.05.2016 18 &lt;tel:26.05.2016%2018&gt;:15, Jānis Kiršteins wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;         The problem is that PlanetInfo values are recreated each time<br>&gt;&gt; while<br>&gt;&gt; &gt;&gt;         they are static. Imagine if PlanetInfo where some type that<br>&gt;&gt; expensive<br>&gt;&gt; &gt;&gt;         to create performance wise.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;         You could solve it by:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;         enum Planet {<br>&gt;&gt; &gt;&gt;             struct PlanetInfo {<br>&gt;&gt; &gt;&gt;                 var mass: Double<br>&gt;&gt; &gt;&gt;                 var description: String<br>&gt;&gt; &gt;&gt;             }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;             case earth<br>&gt;&gt; &gt;&gt;             case moon<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;             private static earthInfo = PlanetInfo(mass: 1.0, description:<br>&gt;&gt; &gt;&gt;         &quot;Earth is our home&quot;)<br>&gt;&gt; &gt;&gt;             private static moonInfo = PlanetInfo(mass: 0.2, description:<br>&gt;&gt; &gt;&gt;         &quot;Just a moon&quot;)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;             var info : PlanetInfo {<br>&gt;&gt; &gt;&gt;                 switch self {<br>&gt;&gt; &gt;&gt;                     case earth: return PlanetInfo.earthInfo<br>&gt;&gt; &gt;&gt;                     case moon: return PlanetInfo.moonInfo<br>&gt;&gt; &gt;&gt;                 }<br>&gt;&gt; &gt;&gt;             }<br>&gt;&gt; &gt;&gt;         }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;         But that again more verbose. The proposed solution is explicit<br>&gt;&gt; that<br>&gt;&gt; &gt;&gt;         those properties are static for each case.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;         On Thu, May 26, 2016 at 5:58 PM, Vladimir.S via swift-evolution<br>&gt;&gt; &gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;             I support the proposal, but couldn&#39;t the initial target be<br>&gt;&gt; &gt;&gt;             achieved today<br>&gt;&gt; &gt;&gt;             with such (more verbose,yes) solution? :<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;             enum Planet {<br>&gt;&gt; &gt;&gt;                 struct PlanetInfo {<br>&gt;&gt; &gt;&gt;                     var mass: Double<br>&gt;&gt; &gt;&gt;                     var description: String<br>&gt;&gt; &gt;&gt;                 }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                 case earth<br>&gt;&gt; &gt;&gt;                 case moon<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                 var info : PlanetInfo {<br>&gt;&gt; &gt;&gt;                     switch self {<br>&gt;&gt; &gt;&gt;                         case earth: return PlanetInfo(mass: 1.0,<br>&gt;&gt; &gt;&gt;             description: &quot;Earth is<br>&gt;&gt; &gt;&gt;             our home&quot;)<br>&gt;&gt; &gt;&gt;                         case moon: return PlanetInfo(mass: 0.2,<br>&gt;&gt; &gt;&gt;             description: &quot;Just a<br>&gt;&gt; &gt;&gt;             moon&quot;)<br>&gt;&gt; &gt;&gt;                     }<br>&gt;&gt; &gt;&gt;                 }<br>&gt;&gt; &gt;&gt;             }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;             let e = Planet.earth<br>&gt;&gt; &gt;&gt;             print(e, e.info.description)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;             let m = Planet.moon<br>&gt;&gt; &gt;&gt;             print(m, m.info.description)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;             On 26.05.2016 8:26, Charlie Monroe via swift-evolution wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                     What this proposal is asking for is an easier way to<br>&gt;&gt; &gt;&gt;                     have derived values<br>&gt;&gt; &gt;&gt;                     from enum cases. Asking for more flexible RawValues<br>&gt;&gt; &gt;&gt;                     means mass and radius<br>&gt;&gt; &gt;&gt;                     are not derived, they are the source of truth. It goes<br>&gt;&gt; &gt;&gt;                     against the whole<br>&gt;&gt; &gt;&gt;                     point of RawRepresentable. You are not saying ‘Mercury<br>&gt;&gt; &gt;&gt;                     is identified by<br>&gt;&gt; &gt;&gt;                     the case .mercury’, you are saying ‘Mercury is<br>&gt;&gt; &gt;&gt;                     identified by a mass of<br>&gt;&gt; &gt;&gt;                     3.303e+23’. It’s backwards.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                 I see what Janis meant in the first email. It&#39;s not that<br>&gt;&gt; &gt;&gt;                 the planet would<br>&gt;&gt; &gt;&gt;                 be identified by the mass or radius. It could very much be<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                 case Mercury = 1 where (mass: 3, radius: 2),<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                 - Mercury&#39;s rawValue would be 1.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                 The issue here is that sometimes you want additional<br>&gt;&gt; &gt;&gt;                 information with the<br>&gt;&gt; &gt;&gt;                 enum. There are many cases where you extend the enum<br>&gt;&gt; with a<br>&gt;&gt; &gt;&gt;                 variable:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                 enum Error {<br>&gt;&gt; &gt;&gt;                 case NoError<br>&gt;&gt; &gt;&gt;                 case FileNotFound<br>&gt;&gt; &gt;&gt;                 ...<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                 var isFatal: Bool {<br>&gt;&gt; &gt;&gt;                 /// swtich over all values of self goes here.<br>&gt;&gt; &gt;&gt;                 }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                 var isNetworkError: Bool {<br>&gt;&gt; &gt;&gt;                 /// swtich over all values of self goes here.<br>&gt;&gt; &gt;&gt;                 }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                 var isIOError: Bool {<br>&gt;&gt; &gt;&gt;                 /// swtich over all values of self goes here.<br>&gt;&gt; &gt;&gt;                 }<br>&gt;&gt; &gt;&gt;                 }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                 What the propsal suggests is to simplify this to the<br>&gt;&gt; &gt; following:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                 enum Error {<br>&gt;&gt; &gt;&gt;                 var isFatal: Bool<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                 case NoError where (isFatal: false, isNetworkError: false,<br>&gt;&gt; &gt;&gt;                 isIOError:<br>&gt;&gt; &gt;&gt;                 false)<br>&gt;&gt; &gt;&gt;                 case FileNotFound  where (isFatal: true, isNetworkError:<br>&gt;&gt; &gt;&gt;                 false, isIOError:<br>&gt;&gt; &gt;&gt;                 true)<br>&gt;&gt; &gt;&gt;                 ...<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                 }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                 So that you assign the additional information to the enum<br>&gt;&gt; &gt;&gt;                 value itself.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                 Charlie<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                         On 26 May 2016, at 1:47 PM, David Sweeris via<br>&gt;&gt; &gt;&gt;                         swift-evolution<br>&gt;&gt; &gt;&gt;                         &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;                         &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;                         &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;                         &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                             On May 25, 2016, at 10:27 PM, Jacob<br>&gt;&gt; &gt;&gt;                             Bandes-Storch &lt;jtbandes at gmail.com<br>&gt;&gt; &lt;mailto:jtbandes at gmail.com&gt;<br>&gt;&gt; &gt;&gt;                             &lt;mailto:jtbandes at gmail.com&gt;<br>&gt;&gt; &gt;&gt;                             &lt;mailto:jtbandes at gmail.com<br>&gt;&gt; &gt;&gt;                             &lt;mailto:jtbandes at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                             On Wed, May 25, 2016 at 8:15 PM, David Sweeris<br>&gt;&gt; &gt;&gt;                             via swift-evolution<br>&gt;&gt; &gt;&gt;                             &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;                             &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;                             &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;                             &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                                 On May 25, 2016, at 7:37 AM, Leonardo<br>&gt;&gt; &gt;&gt;                             Pessoa via swift-evolution<br>&gt;&gt; &gt;&gt;                                 &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;                             &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;                             &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;                             &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;                             wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                                     Hi,<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                                     Couldn&#39;t this be solved by using<br>&gt;&gt; &gt;&gt;                                 tuples? If not because the syntax<br>&gt;&gt; &gt;&gt;                                     is not allowed I think this would be<br>&gt;&gt; &gt;&gt;                                 more coherent to do it using<br>&gt;&gt; &gt;&gt;                                     current syntax.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                                     enum Planet : (mass: Float, radius:<br>&gt;&gt; &gt;&gt;                                 Float) {<br>&gt;&gt; &gt;&gt;                                         case mercury = (mass: 3.303e+23,<br>&gt;&gt; &gt;&gt;                                 radius: 2.4397e6)<br>&gt;&gt; &gt;&gt;                                         case venus = (mass: 4.869e+24,<br>&gt;&gt; &gt;&gt;                                 radius: 6.0518e6)<br>&gt;&gt; &gt;&gt;                                         case earth = (mass: 5.976e+24,<br>&gt;&gt; &gt;&gt;                                 radius: 6.37814e6)<br>&gt;&gt; &gt;&gt;                                         case mars = (mass: 6.421e+23,<br>&gt;&gt; &gt;&gt;                                 radius: 3.3972e6)<br>&gt;&gt; &gt;&gt;                                         case jupiter = (mass: 1.9e+27,<br>&gt;&gt; &gt;&gt;                                 radius: 7.1492e7)<br>&gt;&gt; &gt;&gt;                                         case saturn = (mass: 5.688e+26,<br>&gt;&gt; &gt;&gt;                                 radius: 6.0268e7)<br>&gt;&gt; &gt;&gt;                                         case uranus = (mass: 8.686e+25,<br>&gt;&gt; &gt;&gt;                                 radius: 2.5559e7)<br>&gt;&gt; &gt;&gt;                                         case neptune = (mass: 1.024e+26,<br>&gt;&gt; &gt;&gt;                                 radius: 2.4746e7)<br>&gt;&gt; &gt;&gt;                                     }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                                 This would be my preferred solution…<br>&gt;&gt; AFAIK,<br>&gt;&gt; &gt;&gt;                             the only reason we<br>&gt;&gt; &gt;&gt;                                 can’t do it now is that Swift currently<br>&gt;&gt; &gt;&gt;                             requires RawValue be an<br>&gt;&gt; &gt;&gt;                                 integer, floating-point value, or<br>&gt;&gt; string. I<br>&gt;&gt; &gt;&gt;                             don’t know why the<br>&gt;&gt; &gt;&gt;                                 language has this restriction, so I can’t<br>&gt;&gt; &gt;&gt;                             comment on how hard it<br>&gt;&gt; &gt;&gt;                                 would be to change.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                                 - Dave Sweeris<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                             Except you&#39;d have to write<br>&gt;&gt; &gt;&gt;                             Planet.mercury.rawValue.mass, rather than<br>&gt;&gt; &gt;&gt;                             Planet.mercury.mass.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                             This could be one or two proposals: allow<br>&gt;&gt; enums<br>&gt;&gt; &gt;&gt;                             with tuple RawValues,<br>&gt;&gt; &gt;&gt;                             and allow `TupleName.caseName.propertyName` to<br>&gt;&gt; &gt;&gt;                             access a tuple element<br>&gt;&gt; &gt;&gt;                             without going through .rawValue.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                         Good point… Has there been a thread on allowing<br>&gt;&gt; &gt;&gt;                         raw-valued enums to be<br>&gt;&gt; &gt;&gt;                         treated as constants of type `RawValue` yet?<br>&gt;&gt; Either<br>&gt;&gt; &gt;&gt;                         way, removing the<br>&gt;&gt; &gt;&gt;                         restriction on what types can be a RawValue is<br>&gt;&gt; &gt;&gt;                         still my preferred<br>&gt;&gt; &gt;&gt;                         solution.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                         - Dave Sweeris<br>&gt;&gt; &gt;&gt;                         _______________________________________________<br>&gt;&gt; &gt;&gt;                         swift-evolution mailing list<br>&gt;&gt; &gt;&gt;                         swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;                         &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;                         &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;                         &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                     _______________________________________________<br>&gt;&gt; &gt;&gt;                     swift-evolution mailing list<br>&gt;&gt; &gt;&gt;                     swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;                 _______________________________________________<br>&gt;&gt; &gt;&gt;                 swift-evolution mailing list<br>&gt;&gt; &gt;&gt;                 swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;             _______________________________________________<br>&gt;&gt; &gt;&gt;             swift-evolution mailing list<br>&gt;&gt; &gt;&gt;             swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;     _______________________________________________<br>&gt;&gt; &gt;&gt;     swift-evolution mailing list<br>&gt;&gt; &gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] Enums with static storedpropertiesforeach case</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 27, 2016 at 12:00:00am</p></header><div class="content"><p>On 26.05.2016 23:03, Leonardo Pessoa wrote:<br>&gt; I get it and think this was really very interesting in Delphi and I<br>&gt; wouldn&#39;t mind having something like this in Swift. But despite being able<br>&gt; to extend associated information through the use of another array we&#39;d<br>&gt; still have more verbosity and scattering than with tuples to implement the<br>&gt; examples discussed.<br></p><p>At this moment I think your proposal for tuples as raw value for enum is <br>the best. So we can ask just to support tuples(not other types, at least <br>yet) as raw type and use tuple values directly on enum instance(without <br>`.rawValue.`). The question is if this is doable and if there is a support <br>for this in community and in core team. (even for post Swift 3.0 era)<br>As I understand, for this we need implicit implementation of Equatable for <br>tuple as raw value and probably of RawRepresentable.<br></p><p> &gt;And we can already have enum dictionaries just not<br>&gt; checking automatically if all enum values have been covered. Moreover there<br>&gt; is no loss in having both solutions.<br></p><p>As for dictionary. I don&#39;t think of it as implementation detail for static <br>stored properties for each case. Such dictionary could be helpful in other <br>situations when you need assign some value for each enum case in your code. <br>*The main point* is a feature that compiler checks that value is assigned <br>for *each* case.<br></p><p>For example, in your code you need to assign color for each case in <br>Planets. You can do this in switch:<br></p><p>switch e {<br>   case .earth : color = colorA<br>   case .moon : color = colorB<br>}<br></p><p>but instead you can create a dict:<br>let planetToColor = [Planet.earth : colorA, .moon : colorB]<br>and use as planetToColor[e]!  // yes, have to use `!` here<br></p><p>But, this is *not safe*(but very handy and useful) - as if you *add* new <br>case in enum (let&#39;s say .mars) you will not be notified(in opposite to <br>switch) that your planetToColor must me changed also - it does not contain <br>color for .mars. You will know about this only in runtime.<br></p><p>So, it will be very good for our code, if we have such dictionary which <br>will check at compile time that all cases are presented as keys in it.<br></p><p>&gt;<br>&gt; I mentioned the values() method also because I miss a way to iterate<br>&gt; through all the values on an enum and since it seems we&#39;re discussing the<br>&gt; entire way to work with enums here it was worth bringing it up.<br>&gt;<br></p><p>There was &quot;ValueEnumerable protocol with derived implementation for enums&quot; <br>thread in this mailing list, you can review discussion in it regarding <br>&quot;values()&quot; feature.<br>I also wish someone create a proposal to improve enums in a number of ways.<br></p><p>&gt; ---------------------------------------------------------------------------<br>&gt; From: Vladimir.S &lt;mailto:svabox at gmail.com&gt;<br>&gt; Sent: ‎26/‎05/‎2016 03:06 PM<br>&gt; To: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;<br>&gt; Cc: swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Proposal] Enums with static<br>&gt; storedpropertiesforeach case<br>&gt;<br>&gt; Yes, this was mentioned in a similar thread in this email list earlier.<br>&gt; There is even some proposal for such .values() for Swift enums.<br>&gt;<br>&gt; But this values() in Java is not the same thing as discussed dictionary<br>&gt; with *keys* of enum type or Delphi&#39;s arrays with *index* of enum type.<br>&gt;<br>&gt; Could you write Java&#39;s example for array/dictionary of String which<br>&gt; *index*(or key) will be of enum type? *And* compiler will check that value<br>&gt; for each enum case is set in case of array of constants like:<br>&gt; MyConsts : array [TMyEnum] of String = (&#39;just one&#39;, &#39;two here&#39;)<br>&gt; // compiler will always check that value assigned for each case<br>&gt;<br>&gt;<br>&gt; On 26.05.2016 20:58, Leonardo Pessoa wrote:<br>&gt;&gt; Java enums automatically have a static values() method that return an array<br>&gt;&gt; with all values in an enum.<br>&gt;&gt; ---------------------------------------------------------------------------<br>&gt;&gt; From: Vladimir.S via swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; Sent: ‎26/‎05/‎2016 02:36 PM<br>&gt;&gt; To: Ross O&#39;Brien &lt;mailto:narrativium+swift at gmail.com&gt;<br>&gt;&gt; Cc: swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; Subject: Re: [swift-evolution] [Proposal] Enums with static stored<br>&gt;&gt; propertiesforeach case<br>&gt;&gt;<br>&gt;&gt; On 26.05.2016 19:50, Ross O&#39;Brien wrote:<br>&gt;&gt;&gt; Perhaps there&#39;s an argument to be made for a sort of &#39;enumDictionary&#39; type<br>&gt;&gt;&gt; - a dictionary whose keys are all the cases of an enum, and is thus<br>&gt;&gt;&gt; guaranteed to produce a value.<br>&gt;&gt;<br>&gt;&gt; In Delphi(Pascal) you can define an array with indexes of enum type i.e.:<br>&gt;&gt; type<br>&gt;&gt;    TMyEnum = (One, Two)<br>&gt;&gt; var<br>&gt;&gt;    MyVal : array[TMyEnum] of String<br>&gt;&gt; const<br>&gt;&gt;    MyConsts : array [TMyEnum] of String = (&#39;just one&#39;, &#39;two here&#39;)<br>&gt;&gt;    // compiler will check that values for each enum were specified here<br>&gt;&gt;<br>&gt;&gt; ,so you can do<br>&gt;&gt; var e: TMyEnum<br>&gt;&gt; e := One;<br>&gt;&gt; MyVal[e] := &#39;hello&#39;;<br>&gt;&gt; s2 := MyConsts[e];<br>&gt;&gt;<br>&gt;&gt; This is really useful and used a lot. And this is safe in meaning compiler<br>&gt;&gt; will notify you if you changed the enum - you&#39;ll have to change such<br>&gt;&gt; constant array.<br>&gt;&gt;<br>&gt;&gt; I wish we&#39;ll have something like this in Swift.<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think the question I have is how you&#39;d access the values, syntactically.<br>&gt;&gt;&gt; To use the Planet example, if &#39;.earth&#39; is a value of the Planet enum, is<br>&gt;&gt;&gt; &#39;.earth.mass&#39; an acceptable way to access its mass? Or perhaps<br>&gt;&gt;&gt; &#39;Planet[.earth].mass&#39;?<br>&gt;&gt;<br>&gt;&gt; Just like .rawValue currently, i.e.<br>&gt;&gt; let e = Planet.earth<br>&gt;&gt; print(e.mass, e.description)<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Thu, May 26, 2016 at 4:43 PM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Or(if we are sure we&#39;ll don&#39;t forget to udpate `infoDict` in case of<br>&gt;&gt;&gt;     new added case in future):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     enum Planet {<br>&gt;&gt;&gt;         case earth<br>&gt;&gt;&gt;         case moon<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         struct PlanetInfo {<br>&gt;&gt;&gt;             var mass: Double<br>&gt;&gt;&gt;             var description: String<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         private static let infoDict = [<br>&gt;&gt;&gt;             Planet.earth :<br>&gt;&gt;&gt;                 PlanetInfo(mass: 1.0, description:&quot;Earth is our home&quot;),<br>&gt;&gt;&gt;             .moon:<br>&gt;&gt;&gt;                 PlanetInfo(mass: 0.2, description:&quot;Just a moon&quot;),<br>&gt;&gt;&gt;             ]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         var info : PlanetInfo { return Planet.infoDict[self]! }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     But I agree with you, IMO we need static stored properties for each<br>&gt; case.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     On 26.05.2016 18 &lt;tel:26.05.2016%2018&gt;:15, Jānis Kiršteins wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         The problem is that PlanetInfo values are recreated each time while<br>&gt;&gt;&gt;         they are static. Imagine if PlanetInfo where some type that<br>&gt; expensive<br>&gt;&gt;&gt;         to create performance wise.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         You could solve it by:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         enum Planet {<br>&gt;&gt;&gt;             struct PlanetInfo {<br>&gt;&gt;&gt;                 var mass: Double<br>&gt;&gt;&gt;                 var description: String<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             case earth<br>&gt;&gt;&gt;             case moon<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             private static earthInfo = PlanetInfo(mass: 1.0, description:<br>&gt;&gt;&gt;         &quot;Earth is our home&quot;)<br>&gt;&gt;&gt;             private static moonInfo = PlanetInfo(mass: 0.2, description:<br>&gt;&gt;&gt;         &quot;Just a moon&quot;)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             var info : PlanetInfo {<br>&gt;&gt;&gt;                 switch self {<br>&gt;&gt;&gt;                     case earth: return PlanetInfo.earthInfo<br>&gt;&gt;&gt;                     case moon: return PlanetInfo.moonInfo<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         But that again more verbose. The proposed solution is explicit that<br>&gt;&gt;&gt;         those properties are static for each case.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         On Thu, May 26, 2016 at 5:58 PM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             I support the proposal, but couldn&#39;t the initial target be<br>&gt;&gt;&gt;             achieved today<br>&gt;&gt;&gt;             with such (more verbose,yes) solution? :<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             enum Planet {<br>&gt;&gt;&gt;                 struct PlanetInfo {<br>&gt;&gt;&gt;                     var mass: Double<br>&gt;&gt;&gt;                     var description: String<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 case earth<br>&gt;&gt;&gt;                 case moon<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 var info : PlanetInfo {<br>&gt;&gt;&gt;                     switch self {<br>&gt;&gt;&gt;                         case earth: return PlanetInfo(mass: 1.0,<br>&gt;&gt;&gt;             description: &quot;Earth is<br>&gt;&gt;&gt;             our home&quot;)<br>&gt;&gt;&gt;                         case moon: return PlanetInfo(mass: 0.2,<br>&gt;&gt;&gt;             description: &quot;Just a<br>&gt;&gt;&gt;             moon&quot;)<br>&gt;&gt;&gt;                     }<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             let e = Planet.earth<br>&gt;&gt;&gt;             print(e, e.info.description)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             let m = Planet.moon<br>&gt;&gt;&gt;             print(m, m.info.description)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             On 26.05.2016 8:26, Charlie Monroe via swift-evolution wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                     What this proposal is asking for is an easier way to<br>&gt;&gt;&gt;                     have derived values<br>&gt;&gt;&gt;                     from enum cases. Asking for more flexible RawValues<br>&gt;&gt;&gt;                     means mass and radius<br>&gt;&gt;&gt;                     are not derived, they are the source of truth. It goes<br>&gt;&gt;&gt;                     against the whole<br>&gt;&gt;&gt;                     point of RawRepresentable. You are not saying ‘Mercury<br>&gt;&gt;&gt;                     is identified by<br>&gt;&gt;&gt;                     the case .mercury’, you are saying ‘Mercury is<br>&gt;&gt;&gt;                     identified by a mass of<br>&gt;&gt;&gt;                     3.303e+23’. It’s backwards.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 I see what Janis meant in the first email. It&#39;s not that<br>&gt;&gt;&gt;                 the planet would<br>&gt;&gt;&gt;                 be identified by the mass or radius. It could very much be<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 case Mercury = 1 where (mass: 3, radius: 2),<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 - Mercury&#39;s rawValue would be 1.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 The issue here is that sometimes you want additional<br>&gt;&gt;&gt;                 information with the<br>&gt;&gt;&gt;                 enum. There are many cases where you extend the enum with a<br>&gt;&gt;&gt;                 variable:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 enum Error {<br>&gt;&gt;&gt;                 case NoError<br>&gt;&gt;&gt;                 case FileNotFound<br>&gt;&gt;&gt;                 ...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 var isFatal: Bool {<br>&gt;&gt;&gt;                 /// swtich over all values of self goes here.<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 var isNetworkError: Bool {<br>&gt;&gt;&gt;                 /// swtich over all values of self goes here.<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 var isIOError: Bool {<br>&gt;&gt;&gt;                 /// swtich over all values of self goes here.<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 What the propsal suggests is to simplify this to the<br>&gt;&gt; following:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 enum Error {<br>&gt;&gt;&gt;                 var isFatal: Bool<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 case NoError where (isFatal: false, isNetworkError: false,<br>&gt;&gt;&gt;                 isIOError:<br>&gt;&gt;&gt;                 false)<br>&gt;&gt;&gt;                 case FileNotFound  where (isFatal: true, isNetworkError:<br>&gt;&gt;&gt;                 false, isIOError:<br>&gt;&gt;&gt;                 true)<br>&gt;&gt;&gt;                 ...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 So that you assign the additional information to the enum<br>&gt;&gt;&gt;                 value itself.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 Charlie<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                         On 26 May 2016, at 1:47 PM, David Sweeris via<br>&gt;&gt;&gt;                         swift-evolution<br>&gt;&gt;&gt;                         &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;                         &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                         &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;                         &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                             On May 25, 2016, at 10:27 PM, Jacob<br>&gt;&gt;&gt;                             Bandes-Storch &lt;jtbandes at gmail.com<br>&gt;&gt;&gt;                             &lt;mailto:jtbandes at gmail.com&gt;<br>&gt;&gt;&gt;                             &lt;mailto:jtbandes at gmail.com<br>&gt;&gt;&gt;                             &lt;mailto:jtbandes at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                             On Wed, May 25, 2016 at 8:15 PM, David Sweeris<br>&gt;&gt;&gt;                             via swift-evolution<br>&gt;&gt;&gt;                             &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;                             &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                             &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;                             &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                                 On May 25, 2016, at 7:37 AM, Leonardo<br>&gt;&gt;&gt;                             Pessoa via swift-evolution<br>&gt;&gt;&gt;                                 &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;                             &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                             &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;                             &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;                             wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                                     Hi,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                                     Couldn&#39;t this be solved by using<br>&gt;&gt;&gt;                                 tuples? If not because the syntax<br>&gt;&gt;&gt;                                     is not allowed I think this would be<br>&gt;&gt;&gt;                                 more coherent to do it using<br>&gt;&gt;&gt;                                     current syntax.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                                     enum Planet : (mass: Float, radius:<br>&gt;&gt;&gt;                                 Float) {<br>&gt;&gt;&gt;                                         case mercury = (mass: 3.303e+23,<br>&gt;&gt;&gt;                                 radius: 2.4397e6)<br>&gt;&gt;&gt;                                         case venus = (mass: 4.869e+24,<br>&gt;&gt;&gt;                                 radius: 6.0518e6)<br>&gt;&gt;&gt;                                         case earth = (mass: 5.976e+24,<br>&gt;&gt;&gt;                                 radius: 6.37814e6)<br>&gt;&gt;&gt;                                         case mars = (mass: 6.421e+23,<br>&gt;&gt;&gt;                                 radius: 3.3972e6)<br>&gt;&gt;&gt;                                         case jupiter = (mass: 1.9e+27,<br>&gt;&gt;&gt;                                 radius: 7.1492e7)<br>&gt;&gt;&gt;                                         case saturn = (mass: 5.688e+26,<br>&gt;&gt;&gt;                                 radius: 6.0268e7)<br>&gt;&gt;&gt;                                         case uranus = (mass: 8.686e+25,<br>&gt;&gt;&gt;                                 radius: 2.5559e7)<br>&gt;&gt;&gt;                                         case neptune = (mass: 1.024e+26,<br>&gt;&gt;&gt;                                 radius: 2.4746e7)<br>&gt;&gt;&gt;                                     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                                 This would be my preferred solution… AFAIK,<br>&gt;&gt;&gt;                             the only reason we<br>&gt;&gt;&gt;                                 can’t do it now is that Swift currently<br>&gt;&gt;&gt;                             requires RawValue be an<br>&gt;&gt;&gt;                                 integer, floating-point value, or string. I<br>&gt;&gt;&gt;                             don’t know why the<br>&gt;&gt;&gt;                                 language has this restriction, so I can’t<br>&gt;&gt;&gt;                             comment on how hard it<br>&gt;&gt;&gt;                                 would be to change.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                                 - Dave Sweeris<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                             Except you&#39;d have to write<br>&gt;&gt;&gt;                             Planet.mercury.rawValue.mass, rather than<br>&gt;&gt;&gt;                             Planet.mercury.mass.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                             This could be one or two proposals: allow enums<br>&gt;&gt;&gt;                             with tuple RawValues,<br>&gt;&gt;&gt;                             and allow `TupleName.caseName.propertyName` to<br>&gt;&gt;&gt;                             access a tuple element<br>&gt;&gt;&gt;                             without going through .rawValue.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                         Good point… Has there been a thread on allowing<br>&gt;&gt;&gt;                         raw-valued enums to be<br>&gt;&gt;&gt;                         treated as constants of type `RawValue` yet? Either<br>&gt;&gt;&gt;                         way, removing the<br>&gt;&gt;&gt;                         restriction on what types can be a RawValue is<br>&gt;&gt;&gt;                         still my preferred<br>&gt;&gt;&gt;                         solution.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                         - Dave Sweeris<br>&gt;&gt;&gt;                         _______________________________________________<br>&gt;&gt;&gt;                         swift-evolution mailing list<br>&gt;&gt;&gt;                         swift-evolution at swift.org<br>&gt;&gt;&gt;                         &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                         &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;                         &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                     _______________________________________________<br>&gt;&gt;&gt;                     swift-evolution mailing list<br>&gt;&gt;&gt;                     swift-evolution at swift.org<br>&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;                     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;                     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 _______________________________________________<br>&gt;&gt;&gt;                 swift-evolution mailing list<br>&gt;&gt;&gt;                 swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             _______________________________________________<br>&gt;&gt;&gt;             swift-evolution mailing list<br>&gt;&gt;&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     _______________________________________________<br>&gt;&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 26, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; The proposed solution is to have single static initializer for each<br>&gt; enum case that initializes stored properties. For example,<br></p><p>My opinions so far:<br></p><p>- Abusing rawValue is just that: an abuse.<br></p><p>- Using `where` just doesn&#39;t match the use of `where` elsewhere in the language; everywhere else, it&#39;s some kind of condition.<br></p><p>- Dictionaries are the most straightforward way to handle this with the current language, but their lack of exhaustiveness checking is a problem.<br></p><p>What I would do is borrow the &quot;accessors&quot; concept from the property behaviors proposal and extend it so that it supported both functions and variables. Then I would let you write this:<br></p><p>	enum Planet {<br>	   accessor var mass: Float<br>	   accessor var radius: Float<br>	   <br>	   case mercury {<br>	      mass = 3.303e+23<br>	      radius = 2.4397e6<br>	   }<br>	   case venus {<br>	      mass = 4.869e+24<br>	      radius = 6.0518e6<br>	   }<br>	   case earth {<br>	      mass = 5.976e+24<br>	      radius = 6.37814e6<br>	   }<br>	   case mars {<br>	      mass = 6.421e+23<br>	      radius = 3.3972e6<br>	   }<br>	   case jupiter {<br>	      mass = 1.9e+27<br>	      radius = 7.1492e7<br>	   }<br>	   case saturn {<br>	      mass = 5.688e+26<br>	      radius = 6.0268e7<br>	   }<br>	   case uranus {<br>	      mass = 8.686e+25<br>	      radius = 2.5559e7<br>	   }<br>	   case neptune {<br>	      mass = 1.024e+26<br>	      radius = 2.4746e7<br>	   }<br>	}<br></p><p>You would also be able to declare methods like this; each implementation would just look like `methodName { code }`. And you could provide default implementations too:<br></p><p>	enum Planet {<br>	   accessor var mass: Float<br>	   accessor var radius: Float<br>	   accessor var habitable: Bool = false<br>	   <br>	   case mercury {<br>	      mass = 3.303e+23<br>	      radius = 2.4397e6<br>	   }<br>	   case venus {<br>	      mass = 4.869e+24<br>	      radius = 6.0518e6<br>	   }<br>	   case earth {<br>	      mass = 5.976e+24<br>	      radius = 6.37814e6<br>	      habitable = true<br>	   }<br>	   case mars {<br>	      mass = 6.421e+23<br>	      radius = 3.3972e6<br>	   }<br>	   case jupiter {<br>	      mass = 1.9e+27<br>	      radius = 7.1492e7<br>	   }<br>	   case saturn {<br>	      mass = 5.688e+26<br>	      radius = 6.0268e7<br>	   }<br>	   case uranus {<br>	      mass = 8.686e+25<br>	      radius = 2.5559e7<br>	   }<br>	   case neptune {<br>	      mass = 1.024e+26<br>	      radius = 2.4746e7<br>	   }<br>	}<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 26, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 26, 2016, at 4:47 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; The proposed solution is to have single static initializer for each<br>&gt;&gt; enum case that initializes stored properties. For example,<br>&gt; <br>&gt; My opinions so far:<br>&gt; <br>&gt; - Abusing rawValue is just that: an abuse.<br>&gt; <br>&gt; - Using `where` just doesn&#39;t match the use of `where` elsewhere in the language; everywhere else, it&#39;s some kind of condition.<br>&gt; <br>&gt; - Dictionaries are the most straightforward way to handle this with the current language, but their lack of exhaustiveness checking is a problem.<br>&gt; <br>&gt; What I would do is borrow the &quot;accessors&quot; concept from the property behaviors proposal and extend it so that it supported both functions and variables. Then I would let you write this:<br>&gt; <br>&gt; 	enum Planet {<br>&gt; 	   accessor var mass: Float<br>&gt; 	   accessor var radius: Float<br>&gt; 	   <br>&gt; 	   case mercury {<br>&gt; 	      mass = 3.303e+23<br>&gt; 	      radius = 2.4397e6<br>&gt; 	   }<br>&gt; 	   case venus {<br>&gt; 	      mass = 4.869e+24<br>&gt; 	      radius = 6.0518e6<br>&gt; 	   }<br>&gt; 	   case earth {<br>&gt; 	      mass = 5.976e+24<br>&gt; 	      radius = 6.37814e6<br>&gt; 	   }<br>&gt; 	   case mars {<br>&gt; 	      mass = 6.421e+23<br>&gt; 	      radius = 3.3972e6<br>&gt; 	   }<br>&gt; 	   case jupiter {<br>&gt; 	      mass = 1.9e+27<br>&gt; 	      radius = 7.1492e7<br>&gt; 	   }<br>&gt; 	   case saturn {<br>&gt; 	      mass = 5.688e+26<br>&gt; 	      radius = 6.0268e7<br>&gt; 	   }<br>&gt; 	   case uranus {<br>&gt; 	      mass = 8.686e+25<br>&gt; 	      radius = 2.5559e7<br>&gt; 	   }<br>&gt; 	   case neptune {<br>&gt; 	      mass = 1.024e+26<br>&gt; 	      radius = 2.4746e7<br>&gt; 	   }<br>&gt; 	}<br>&gt; <br>&gt; You would also be able to declare methods like this; each implementation would just look like `methodName { code }`. And you could provide default implementations too:<br>&gt; <br>&gt; 	enum Planet {<br>&gt; 	   accessor var mass: Float<br>&gt; 	   accessor var radius: Float<br>&gt; 	   accessor var habitable: Bool = false<br>&gt; 	   <br>&gt; 	   case mercury {<br>&gt; 	      mass = 3.303e+23<br>&gt; 	      radius = 2.4397e6<br>&gt; 	   }<br>&gt; 	   case venus {<br>&gt; 	      mass = 4.869e+24<br>&gt; 	      radius = 6.0518e6<br>&gt; 	   }<br>&gt; 	   case earth {<br>&gt; 	      mass = 5.976e+24<br>&gt; 	      radius = 6.37814e6<br>&gt; 	      habitable = true<br>&gt; 	   }<br>&gt; 	   case mars {<br>&gt; 	      mass = 6.421e+23<br>&gt; 	      radius = 3.3972e6<br>&gt; 	   }<br>&gt; 	   case jupiter {<br>&gt; 	      mass = 1.9e+27<br>&gt; 	      radius = 7.1492e7<br>&gt; 	   }<br>&gt; 	   case saturn {<br>&gt; 	      mass = 5.688e+26<br>&gt; 	      radius = 6.0268e7<br>&gt; 	   }<br>&gt; 	   case uranus {<br>&gt; 	      mass = 8.686e+25<br>&gt; 	      radius = 2.5559e7<br>&gt; 	   }<br>&gt; 	   case neptune {<br>&gt; 	      mass = 1.024e+26<br>&gt; 	      radius = 2.4746e7<br>&gt; 	   }<br>&gt; 	}<br>&gt; <br></p><p>This is the first really interesting (to me) idea in the thread.  I think I like it but need to give it more thought to decide for sure. <br></p><p>One really interesting thing we could do to build on this would be to introduce the associated value names inside the scope of each case as if they were member variables:<br></p><p>enum Foo {<br>    accessor func bar() -&gt; Int<br>    <br>    case baz(val: Int) {<br>        // val is in scope here<br>        func bar() {<br>            return val<br>        }<br>    }<br>}<br></p><p><br></p><p>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 26, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 26, 2016, at 4:47 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; - Abusing rawValue is just that: an abuse.<br></p><p>In addition, enums with associated types can’t have rawValues.<br></p><p>Why is this relevant, you may ask? Because error enums are a huge use case for something like this. Being able to do the below would be great:<br></p><p>enum MyError: ErrorProtocol {<br>    accessor var localizedFailureReason: String<br>    accessor var url: NSURL<br></p><p>    case FileNotFound(url: NSURL) {<br>        self.localizedFailureReason = “File \&quot;\(url.lastPathComponent ?? “”)\” not found.”<br>        self.url = url<br>    }<br></p><p>    case FileIsCorrupt(url: NSURL) {<br>        self.localizedFailureReason = “File \&quot;\(url.lastPathComponent ?? “”)\” is corrupt.”<br>        self.url = url<br>    }<br>}<br></p><p>This would be much cleaner than the existing method of using a switch to create a userInfo dictionary for creating an NSError to send to -[NSApplication presentError:] and similar methods.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/b7f89658/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 27, 2016 at 02:00:00pm</p></header><div class="content"><p>Correct me if I&#39;m wrong, but this idea with accessors is not the same as <br>static properties for each case. The one of ideas of initial proposal - <br>static(!) values would be created only once and it is important in case it <br>is expensive to create such value(or if should be created only once per case)<br></p><p>The suggested solution based on &#39;accessor&#39; - will create assotiated <br>properties each time the enum instace created, for each instance of enum type.<br></p><p>We can have something like the example with accessors now :<br></p><p>enum MyError: ErrorProtocol {<br>     struct MyErrorInfo {<br>         let localizedFailureReason: String<br>         let url: String<br>     }<br></p><p>     case fileNotFound(url: String)<br>     case fileIsCorrupt(url: String)<br></p><p>     var info : MyErrorInfo {<br>         switch self {<br>             case fileNotFound(let url) : return <br>MyErrorInfo(localizedFailureReason: &quot;File \&quot;\(url.lowercased())\&quot; not <br>found.&quot;, url: url)<br></p><p>             case fileIsCorrupt(let url) : return <br>MyErrorInfo(localizedFailureReason: &quot;File \&quot;\(url.lowercased())\&quot;  is <br>corrupt.&quot;, url: url)<br>         }<br>     }<br>}<br></p><p>var e = MyError.fileNotFound(url: &quot;http://something.some&quot;)<br>var info = e.info<br>print(info.localizedFailureReason, info.url)<br></p><p>But yes, such MyErrorInfo will be created on each `info.` call. This is <br>worse that create MyErrorInfo once per each enum instance initialization, <br>but IMO these solutions are close enough.<br></p><p>In any case, I don&#39;t see why tuple for enum and enum with `accessor` can <br>not co-exists.<br></p><p>On 27.05.2016 2:28, Charles Srstka via swift-evolution wrote:<br>&gt;&gt; On May 26, 2016, at 4:47 PM, Brent Royal-Gordon via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; - Abusing rawValue is just that: an abuse.<br>&gt;<br>&gt; In addition, enums with associated types can’t have rawValues.<br>&gt;<br>&gt; Why is this relevant, you may ask? Because error enums are a huge use case<br>&gt; for something like this. Being able to do the below would be great:<br>&gt;<br>&gt; enum MyError: ErrorProtocol {<br>&gt;     accessor var localizedFailureReason: String<br>&gt;     accessor var url: NSURL<br>&gt;<br>&gt;     case FileNotFound(url: NSURL) {<br>&gt;         self.localizedFailureReason = “File \&quot;\(url.lastPathComponent ??<br>&gt; “”)\” not found.”<br>&gt;         self.url = url<br>&gt;     }<br>&gt;<br>&gt;     case FileIsCorrupt(url: NSURL) {<br>&gt;         self.localizedFailureReason = “File \&quot;\(url.lastPathComponent ??<br>&gt; “”)\” is corrupt.”<br>&gt;         self.url = url<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; This would be much cleaner than the existing method of using a switch to<br>&gt; create a userInfo dictionary for creating an NSError to send to<br>&gt; -[NSApplication presentError:] and similar methods.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Enums with static stored propertiesfor each case</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 27, 2016 at 08:00:00am</p></header><div class="content"><p>I agree. These are different proposals that can coexist but I think they should be evaluated separately by the community.<br></p><p><br></p><p>-----Original Message-----<br>From: &quot;Vladimir.S via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Sent: ‎27/‎05/‎2016 08:05 AM<br>To: &quot;Charles Srstka&quot; &lt;cocoadev at charlessoft.com&gt;<br>Cc: &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Proposal] Enums with static stored propertiesfor each case<br></p><p>Correct me if I&#39;m wrong, but this idea with accessors is not the same as <br>static properties for each case. The one of ideas of initial proposal - <br>static(!) values would be created only once and it is important in case it <br>is expensive to create such value(or if should be created only once per case)<br></p><p>The suggested solution based on &#39;accessor&#39; - will create assotiated <br>properties each time the enum instace created, for each instance of enum type.<br></p><p>We can have something like the example with accessors now :<br></p><p>enum MyError: ErrorProtocol {<br>     struct MyErrorInfo {<br>         let localizedFailureReason: String<br>         let url: String<br>     }<br></p><p>     case fileNotFound(url: String)<br>     case fileIsCorrupt(url: String)<br></p><p>     var info : MyErrorInfo {<br>         switch self {<br>             case fileNotFound(let url) : return <br>MyErrorInfo(localizedFailureReason: &quot;File \&quot;\(url.lowercased())\&quot; not <br>found.&quot;, url: url)<br></p><p>             case fileIsCorrupt(let url) : return <br>MyErrorInfo(localizedFailureReason: &quot;File \&quot;\(url.lowercased())\&quot;  is <br>corrupt.&quot;, url: url)<br>         }<br>     }<br>}<br></p><p>var e = MyError.fileNotFound(url: &quot;http://something.some&quot;)<br>var info = e.info<br>print(info.localizedFailureReason, info.url)<br></p><p>But yes, such MyErrorInfo will be created on each `info.` call. This is <br>worse that create MyErrorInfo once per each enum instance initialization, <br>but IMO these solutions are close enough.<br></p><p>In any case, I don&#39;t see why tuple for enum and enum with `accessor` can <br>not co-exists.<br></p><p>On 27.05.2016 2:28, Charles Srstka via swift-evolution wrote:<br>&gt;&gt; On May 26, 2016, at 4:47 PM, Brent Royal-Gordon via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; - Abusing rawValue is just that: an abuse.<br>&gt;<br>&gt; In addition, enums with associated types can’t have rawValues.<br>&gt;<br>&gt; Why is this relevant, you may ask? Because error enums are a huge use case<br>&gt; for something like this. Being able to do the below would be great:<br>&gt;<br>&gt; enum MyError: ErrorProtocol {<br>&gt;     accessor var localizedFailureReason: String<br>&gt;     accessor var url: NSURL<br>&gt;<br>&gt;     case FileNotFound(url: NSURL) {<br>&gt;         self.localizedFailureReason = “File \&quot;\(url.lastPathComponent ??<br>&gt; “”)\” not found.”<br>&gt;         self.url = url<br>&gt;     }<br>&gt;<br>&gt;     case FileIsCorrupt(url: NSURL) {<br>&gt;         self.localizedFailureReason = “File \&quot;\(url.lastPathComponent ??<br>&gt; “”)\” is corrupt.”<br>&gt;         self.url = url<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; This would be much cleaner than the existing method of using a switch to<br>&gt; create a userInfo dictionary for creating an NSError to send to<br>&gt; -[NSApplication presentError:] and similar methods.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/bedc7ef5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 27, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; The suggested solution based on &#39;accessor&#39; - will create assotiated properties each time the enum instace created, for each instance of enum type.<br></p><p>No; property accessors would be either computed or constant (so that all instances of a given case can share storage). This is much the way they would behave if they were included in behaviors.<br></p><p>You could write a property accessor with a setter, but it would have to be computed, and manipulate `self`&#39;s cases and associated values:<br></p><p>	enum Optional&lt;T&gt; {<br>		accessor var unwrapped: T { get set }<br></p><p>		case none {<br>			unwrapped {<br>				get { fatalError(&quot;No value&quot;) }<br>				set { self = .some(newValue) }<br>			}<br>		}<br>		case some (_ value: T) {<br>			unwrapped {<br>				get { return value }<br>				set { self = .some(newValue) }<br>			}<br>		}<br>	}<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44a036cc421ee97534c54653a233db93?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Jānis Kiršteins</string> &lt;janis.kirsteins at gmail.com&gt;<p>May 28, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; - Abusing rawValue is just that: an abuse.<br></p><p>My original proposal does not replace rawValue and is compatible with it.<br></p><p>&gt; - Using `where` just doesn&#39;t match the use of `where` elsewhere in the language; everywhere else, it&#39;s some kind of condition.<br></p><p>It is also used in generic type constraints. Plus it reads like human<br>language: `case mercury where (mass: 3.303e+23, radius: 2.4397e6)`<br></p><p>&gt; - Dictionaries are the most straightforward way to handle this with the current language, but their lack of exhaustiveness checking is a problem.<br></p><p>Dictionaries can be used as workaround, but they cannot (lack of<br>exhaustiveness) solve the problem.<br></p><p>&gt; What I would do is borrow the &quot;accessors&quot; concept from the property behaviors proposal and extend it so that it supported both functions and variables.<br></p><p>Wouldn&#39;t accessor just be a redundant keyword here? Currently enums do<br>not support stored properties, so I guess there is no extra need to<br>mark properties with any special keyword.<br></p><p>Property accessors might work for enums with associated values, but<br>not so well without them.<br></p><p>On Fri, May 27, 2016 at 3:43 PM, Brent Royal-Gordon via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; The suggested solution based on &#39;accessor&#39; - will create assotiated properties each time the enum instace created, for each instance of enum type.<br>&gt;<br>&gt; No; property accessors would be either computed or constant (so that all instances of a given case can share storage). This is much the way they would behave if they were included in behaviors.<br>&gt;<br>&gt; You could write a property accessor with a setter, but it would have to be computed, and manipulate `self`&#39;s cases and associated values:<br>&gt;<br>&gt;         enum Optional&lt;T&gt; {<br>&gt;                 accessor var unwrapped: T { get set }<br>&gt;<br>&gt;                 case none {<br>&gt;                         unwrapped {<br>&gt;                                 get { fatalError(&quot;No value&quot;) }<br>&gt;                                 set { self = .some(newValue) }<br>&gt;                         }<br>&gt;                 }<br>&gt;                 case some (_ value: T) {<br>&gt;                         unwrapped {<br>&gt;                                 get { return value }<br>&gt;                                 set { self = .some(newValue) }<br>&gt;                         }<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Enums with static stored propertiesfor each case</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 28, 2016 at 02:00:00pm</p></header><div class="content"><p>My suggestion of allowing tuples as raw values instead doesn&#39;t burden the language and also does not eliminate rawValue (treat previously supported raw value types as one value tuples), reads very cleanly and supports a syntax we&#39;re already familiar with. I don&#39;t see how the &#39;where&#39; syntax reads like natural language and I agree it doesn&#39;t match other uses of where in the language.<br></p><p><br></p><p>-----Original Message-----<br>From: &quot;Jānis Kiršteins via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Sent: ‎28/‎05/‎2016 10:54 AM<br>To: &quot;Brent Royal-Gordon&quot; &lt;brent at architechies.com&gt;<br>Cc: &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Proposal] Enums with static stored propertiesfor each case<br></p><p>&gt; - Abusing rawValue is just that: an abuse.<br></p><p>My original proposal does not replace rawValue and is compatible with it.<br></p><p>&gt; - Using `where` just doesn&#39;t match the use of `where` elsewhere in the language; everywhere else, it&#39;s some kind of condition.<br></p><p>It is also used in generic type constraints. Plus it reads like human<br>language: `case mercury where (mass: 3.303e+23, radius: 2.4397e6)`<br></p><p>&gt; - Dictionaries are the most straightforward way to handle this with the current language, but their lack of exhaustiveness checking is a problem.<br></p><p>Dictionaries can be used as workaround, but they cannot (lack of<br>exhaustiveness) solve the problem.<br></p><p>&gt; What I would do is borrow the &quot;accessors&quot; concept from the property behaviors proposal and extend it so that it supported both functions and variables.<br></p><p>Wouldn&#39;t accessor just be a redundant keyword here? Currently enums do<br>not support stored properties, so I guess there is no extra need to<br>mark properties with any special keyword.<br></p><p>Property accessors might work for enums with associated values, but<br>not so well without them.<br></p><p>On Fri, May 27, 2016 at 3:43 PM, Brent Royal-Gordon via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; The suggested solution based on &#39;accessor&#39; - will create assotiated properties each time the enum instace created, for each instance of enum type.<br>&gt;<br>&gt; No; property accessors would be either computed or constant (so that all instances of a given case can share storage). This is much the way they would behave if they were included in behaviors.<br>&gt;<br>&gt; You could write a property accessor with a setter, but it would have to be computed, and manipulate `self`&#39;s cases and associated values:<br>&gt;<br>&gt;         enum Optional&lt;T&gt; {<br>&gt;                 accessor var unwrapped: T { get set }<br>&gt;<br>&gt;                 case none {<br>&gt;                         unwrapped {<br>&gt;                                 get { fatalError(&quot;No value&quot;) }<br>&gt;                                 set { self = .some(newValue) }<br>&gt;                         }<br>&gt;                 }<br>&gt;                 case some (_ value: T) {<br>&gt;                         unwrapped {<br>&gt;                                 get { return value }<br>&gt;                                 set { self = .some(newValue) }<br>&gt;                         }<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/cc572cb6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44a036cc421ee97534c54653a233db93?s=50"></div><header><strong>[Proposal] Enums with static stored propertiesfor each case</strong> from <string>Jānis Kiršteins</string> &lt;janis.kirsteins at gmail.com&gt;<p>May 28, 2016 at 09:00:00pm</p></header><div class="content"><p>As previosly state there is one problem using tuples as rawValues - they currently must be static (literals) and unique. In example with planets the mass or radius is not unique so it cannot be used as raw value with current requirments. <br></p><p><br></p><p>&gt; On 28 May 2016, at 20:22, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; <br>&gt; My suggestion of allowing tuples as raw values instead doesn&#39;t burden the language and also does not eliminate rawValue (treat previously supported raw value types as one value tuples), reads very cleanly and supports a syntax we&#39;re already familiar with. I don&#39;t see how the &#39;where&#39; syntax reads like natural language and I agree it doesn&#39;t match other uses of where in the language.<br>&gt; <br>&gt; From: Jānis Kiršteins via swift-evolution<br>&gt; Sent: ‎28/‎05/‎2016 10:54 AM<br>&gt; To: Brent Royal-Gordon<br>&gt; Cc: swift-evolution<br>&gt; Subject: Re: [swift-evolution] [Proposal] Enums with static stored propertiesfor each case<br>&gt; <br>&gt; &gt; - Abusing rawValue is just that: an abuse.<br>&gt; <br>&gt; My original proposal does not replace rawValue and is compatible with it.<br>&gt; <br>&gt; &gt; - Using `where` just doesn&#39;t match the use of `where` elsewhere in the language; everywhere else, it&#39;s some kind of condition.<br>&gt; <br>&gt; It is also used in generic type constraints. Plus it reads like human<br>&gt; language: `case mercury where (mass: 3.303e+23, radius: 2.4397e6)`<br>&gt; <br>&gt; &gt; - Dictionaries are the most straightforward way to handle this with the current language, but their lack of exhaustiveness checking is a problem.<br>&gt; <br>&gt; Dictionaries can be used as workaround, but they cannot (lack of<br>&gt; exhaustiveness) solve the problem.<br>&gt; <br>&gt; &gt; What I would do is borrow the &quot;accessors&quot; concept from the property behaviors proposal and extend it so that it supported both functions and variables.<br>&gt; <br>&gt; Wouldn&#39;t accessor just be a redundant keyword here? Currently enums do<br>&gt; not support stored properties, so I guess there is no extra need to<br>&gt; mark properties with any special keyword.<br>&gt; <br>&gt; Property accessors might work for enums with associated values, but<br>&gt; not so well without them.<br>&gt; <br>&gt; On Fri, May 27, 2016 at 3:43 PM, Brent Royal-Gordon via<br>&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; The suggested solution based on &#39;accessor&#39; - will create assotiated properties each time the enum instace created, for each instance of enum type.<br>&gt; &gt;<br>&gt; &gt; No; property accessors would be either computed or constant (so that all instances of a given case can share storage). This is much the way they would behave if they were included in behaviors.<br>&gt; &gt;<br>&gt; &gt; You could write a property accessor with a setter, but it would have to be computed, and manipulate `self`&#39;s cases and associated values:<br>&gt; &gt;<br>&gt; &gt;         enum Optional&lt;T&gt; {<br>&gt; &gt;                 accessor var unwrapped: T { get set }<br>&gt; &gt;<br>&gt; &gt;                 case none {<br>&gt; &gt;                         unwrapped {<br>&gt; &gt;                                 get { fatalError(&quot;No value&quot;) }<br>&gt; &gt;                                 set { self = .some(newValue) }<br>&gt; &gt;                         }<br>&gt; &gt;                 }<br>&gt; &gt;                 case some (_ value: T) {<br>&gt; &gt;                         unwrapped {<br>&gt; &gt;                                 get { return value }<br>&gt; &gt;                                 set { self = .some(newValue) }<br>&gt; &gt;                         }<br>&gt; &gt;                 }<br>&gt; &gt;         }<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/b239c4f6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Enums with static storedpropertiesfor each case</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 28, 2016 at 04:00:00pm</p></header><div class="content"><p>So it should either be an exception when using tuples (which I know is not good) or ensure the combination of values in all tuple values are different from one another.<br></p><p><br></p><p>-----Original Message-----<br>From: &quot;Jānis Kiršteins&quot; &lt;janis.kirsteins at gmail.com&gt;<br>Sent: ‎28/‎05/‎2016 03:58 PM<br>To: &quot;Leonardo Pessoa&quot; &lt;me at lmpessoa.com&gt;<br>Cc: &quot;Brent Royal-Gordon&quot; &lt;brent at architechies.com&gt;; &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Proposal] Enums with static storedpropertiesfor each case<br></p><p>As previosly state there is one problem using tuples as rawValues - they currently must be static (literals) and unique. In example with planets the mass or radius is not unique so it cannot be used as raw value with current requirments. <br></p><p><br></p><p><br>On 28 May 2016, at 20:22, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br></p><p><br>My suggestion of allowing tuples as raw values instead doesn&#39;t burden the language and also does not eliminate rawValue (treat previously supported raw value types as one value tuples), reads very cleanly and supports a syntax we&#39;re already familiar with. I don&#39;t see how the &#39;where&#39; syntax reads like natural language and I agree it doesn&#39;t match other uses of where in the language.<br></p><p><br></p><p><br>From: Jānis Kiršteins via swift-evolution<br>Sent: ‎28/‎05/‎2016 10:54 AM<br>To: Brent Royal-Gordon<br>Cc: swift-evolution<br>Subject: Re: [swift-evolution] [Proposal] Enums with static stored propertiesfor each case<br></p><p><br>&gt; - Abusing rawValue is just that: an abuse.<br></p><p>My original proposal does not replace rawValue and is compatible with it.<br></p><p>&gt; - Using `where` just doesn&#39;t match the use of `where` elsewhere in the language; everywhere else, it&#39;s some kind of condition.<br></p><p>It is also used in generic type constraints. Plus it reads like human<br>language: `case mercury where (mass: 3.303e+23, radius: 2.4397e6)`<br></p><p>&gt; - Dictionaries are the most straightforward way to handle this with the current language, but their lack of exhaustiveness checking is a problem.<br></p><p>Dictionaries can be used as workaround, but they cannot (lack of<br>exhaustiveness) solve the problem.<br></p><p>&gt; What I would do is borrow the &quot;accessors&quot; concept from the property behaviors proposal and extend it so that it supported both functions and variables.<br></p><p>Wouldn&#39;t accessor just be a redundant keyword here? Currently enums do<br>not support stored properties, so I guess there is no extra need to<br>mark properties with any special keyword.<br></p><p>Property accessors might work for enums with associated values, but<br>not so well without them.<br></p><p>On Fri, May 27, 2016 at 3:43 PM, Brent Royal-Gordon via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; The suggested solution based on &#39;accessor&#39; - will create assotiated properties each time the enum instace created, for each instance of enum type.<br>&gt;<br>&gt; No; property accessors would be either computed or constant (so that all instances of a given case can share storage). This is much the way they would behave if they were included in behaviors.<br>&gt;<br>&gt; You could write a property accessor with a setter, but it would have to be computed, and manipulate `self`&#39;s cases and associated values:<br>&gt;<br>&gt;         enum Optional&lt;T&gt; {<br>&gt;                 accessor var unwrapped: T { get set }<br>&gt;<br>&gt;                 case none {<br>&gt;                         unwrapped {<br>&gt;                                 get { fatalError(&quot;No value&quot;) }<br>&gt;                                 set { self = .some(newValue) }<br>&gt;                         }<br>&gt;                 }<br>&gt;                 case some (_ value: T) {<br>&gt;                         unwrapped {<br>&gt;                                 get { return value }<br>&gt;                                 set { self = .some(newValue) }<br>&gt;                         }<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/a039f6d0/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 28, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt;&gt; - Abusing rawValue is just that: an abuse.<br>&gt; <br>&gt; My original proposal does not replace rawValue and is compatible with it.<br></p><p>`rawValue` has a different purpose from how you&#39;re using it. It&#39;s supposed to allow you to convert your type to some other *equivalent* type, like an equivalent integer or string. Moreover, it&#39;s supposed to allow you to *reconstruct* the instance from the raw value—remember, `RawRepresentable` has an `init(rawValue:)` requirement.<br></p><p>It is *not* supposed to be an ancillary bag of information on the side. You&#39;re cramming a square peg into a round hole here.<br></p><p>(Also, if you use `rawValue` for an ancillary bag of information, that means you *can&#39;t* use it on the same type for its intended purpose. For instance, you would not be able to assign numbers to your Planet enum&#39;s cases to help you serialize them or bridge them to Objective-C. That&#39;s not good.)<br></p><p>&gt;&gt; - Using `where` just doesn&#39;t match the use of `where` elsewhere in the language; everywhere else, it&#39;s some kind of condition.<br>&gt; <br>&gt; It is also used in generic type constraints. Plus it reads like human<br>&gt; language: `case mercury where (mass: 3.303e+23, radius: 2.4397e6)`<br></p><p>But a generic constraint is also a type of condition: it specifies types which are permitted and divides them from types that are not.<br></p><p>This is *not* a condition. It&#39;s not anything like a condition. It&#39;s simply not consistent with anything else in the language.<br></p><p>&gt;&gt; - Dictionaries are the most straightforward way to handle this with the current language, but their lack of exhaustiveness checking is a problem.<br>&gt; <br>&gt; Dictionaries can be used as workaround, but they cannot (lack of<br>&gt; exhaustiveness) solve the problem.<br></p><p>I agree that they&#39;re a halfway solution.<br></p><p>If `ValuesEnumerable` were to be accepted (and to have a generic requirement for its `allValues` property), you could write a Dictionary-like type which ensured at initialization time that it was exhaustive. That&#39;s not as good as compile time, but it&#39;s not bad—sort of a three-quarters solution.<br></p><p>	struct ExhaustiveDictionary&lt;Key: Hashable, Value where Key: ValuesEnumerable&gt;: Collection, DictionaryLiteralConvertible {<br>		private var dictionary: [Key: Value]<br>		<br>		init(dictionaryLiteral elements: (Key, Value)...) {<br>			dictionary = [:]<br>			for (k, v) in elements {<br>				dictionary[k] = v<br>			}<br>			<br>			if dictionary.count != Key.allValues.count {<br>				let missingKeys = Key.allValues.filter { dictionary[$0] == nil }<br>				preconditionFailure(&quot;ExhaustiveDictionary is missing elements from \(Key.self): \(missingKeys)&quot;)<br>			}<br>		}<br>		<br>		var startIndex: Dictionary.Index {<br>			return dictionary.startIndex<br>		}<br>		var endIndex: Dictionary.Index {<br>			return dictionary.endIndex<br>		}<br>		subscript(index: Dictionary.Index) -&gt; (Key, Value) {<br>			return dictionary[index]<br>		}<br>		func index(after i: Dictionary.Index) -&gt; Dictionary.Index {<br>			return dictionary.index(after: i)<br>		}		<br></p><p>		subscript(key: Key) -&gt; Value {<br>			get { return dictionary[key]! }<br>			set { dictionary[key] = newValue }<br>		}<br>	}<br></p><p>&gt;&gt; What I would do is borrow the &quot;accessors&quot; concept from the property behaviors proposal and extend it so that it supported both functions and variables.<br>&gt; <br>&gt; Wouldn&#39;t accessor just be a redundant keyword here? Currently enums do<br>&gt; not support stored properties, so I guess there is no extra need to<br>&gt; mark properties with any special keyword.<br></p><p>The keyword is mainly to indicate the unusual syntax at the definition site, where you only have to specify the name of the accessor you&#39;re defining, not a `func` or `var` keyword, a return type, or even parameter names. (Like `willSet`, there&#39;s a default parameter name you can use.) Secondarily, though, I think it&#39;s helpful to indicate very explicitly that this is not an ordinary method or property definition, even if the compiler could perhaps sort things out without it. `accessor` is something a user can Google if they&#39;ve never seen it before.<br></p><p>&gt; Property accessors might work for enums with associated values, but<br>&gt; not so well without them.<br></p><p>The two have nothing to do with each other. I showed your planets example, which has no associated values but uses accessors just fine.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44a036cc421ee97534c54653a233db93?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Jānis Kiršteins</string> &lt;janis.kirsteins at gmail.com&gt;<p>May 29, 2016 at 09:00:00am</p></header><div class="content"><p>I agree with the argument about use of &quot;where&quot;, not replacing the raw<br>value and having some kind of initialization block. But I cannot see<br>why &quot;accessors&quot; concept is any better than stored properties to solve<br>the particular problem. The &quot;accessors&quot; concept has much wider scope<br>than enums and is a separate proposal.<br></p><p>On Sat, May 28, 2016 at 11:39 PM, Brent Royal-Gordon<br>&lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; - Abusing rawValue is just that: an abuse.<br>&gt;&gt;<br>&gt;&gt; My original proposal does not replace rawValue and is compatible with it.<br>&gt;<br>&gt; `rawValue` has a different purpose from how you&#39;re using it. It&#39;s supposed to allow you to convert your type to some other *equivalent* type, like an equivalent integer or string. Moreover, it&#39;s supposed to allow you to *reconstruct* the instance from the raw value—remember, `RawRepresentable` has an `init(rawValue:)` requirement.<br>&gt;<br>&gt; It is *not* supposed to be an ancillary bag of information on the side. You&#39;re cramming a square peg into a round hole here.<br>&gt;<br>&gt; (Also, if you use `rawValue` for an ancillary bag of information, that means you *can&#39;t* use it on the same type for its intended purpose. For instance, you would not be able to assign numbers to your Planet enum&#39;s cases to help you serialize them or bridge them to Objective-C. That&#39;s not good.)<br>&gt;<br>&gt;&gt;&gt; - Using `where` just doesn&#39;t match the use of `where` elsewhere in the language; everywhere else, it&#39;s some kind of condition.<br>&gt;&gt;<br>&gt;&gt; It is also used in generic type constraints. Plus it reads like human<br>&gt;&gt; language: `case mercury where (mass: 3.303e+23, radius: 2.4397e6)`<br>&gt;<br>&gt; But a generic constraint is also a type of condition: it specifies types which are permitted and divides them from types that are not.<br>&gt;<br>&gt; This is *not* a condition. It&#39;s not anything like a condition. It&#39;s simply not consistent with anything else in the language.<br>&gt;<br>&gt;&gt;&gt; - Dictionaries are the most straightforward way to handle this with the current language, but their lack of exhaustiveness checking is a problem.<br>&gt;&gt;<br>&gt;&gt; Dictionaries can be used as workaround, but they cannot (lack of<br>&gt;&gt; exhaustiveness) solve the problem.<br>&gt;<br>&gt; I agree that they&#39;re a halfway solution.<br>&gt;<br>&gt; If `ValuesEnumerable` were to be accepted (and to have a generic requirement for its `allValues` property), you could write a Dictionary-like type which ensured at initialization time that it was exhaustive. That&#39;s not as good as compile time, but it&#39;s not bad—sort of a three-quarters solution.<br>&gt;<br>&gt;         struct ExhaustiveDictionary&lt;Key: Hashable, Value where Key: ValuesEnumerable&gt;: Collection, DictionaryLiteralConvertible {<br>&gt;                 private var dictionary: [Key: Value]<br>&gt;<br>&gt;                 init(dictionaryLiteral elements: (Key, Value)...) {<br>&gt;                         dictionary = [:]<br>&gt;                         for (k, v) in elements {<br>&gt;                                 dictionary[k] = v<br>&gt;                         }<br>&gt;<br>&gt;                         if dictionary.count != Key.allValues.count {<br>&gt;                                 let missingKeys = Key.allValues.filter { dictionary[$0] == nil }<br>&gt;                                 preconditionFailure(&quot;ExhaustiveDictionary is missing elements from \(Key.self): \(missingKeys)&quot;)<br>&gt;                         }<br>&gt;                 }<br>&gt;<br>&gt;                 var startIndex: Dictionary.Index {<br>&gt;                         return dictionary.startIndex<br>&gt;                 }<br>&gt;                 var endIndex: Dictionary.Index {<br>&gt;                         return dictionary.endIndex<br>&gt;                 }<br>&gt;                 subscript(index: Dictionary.Index) -&gt; (Key, Value) {<br>&gt;                         return dictionary[index]<br>&gt;                 }<br>&gt;                 func index(after i: Dictionary.Index) -&gt; Dictionary.Index {<br>&gt;                         return dictionary.index(after: i)<br>&gt;                 }<br>&gt;<br>&gt;                 subscript(key: Key) -&gt; Value {<br>&gt;                         get { return dictionary[key]! }<br>&gt;                         set { dictionary[key] = newValue }<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt;&gt;&gt; What I would do is borrow the &quot;accessors&quot; concept from the property behaviors proposal and extend it so that it supported both functions and variables.<br>&gt;&gt;<br>&gt;&gt; Wouldn&#39;t accessor just be a redundant keyword here? Currently enums do<br>&gt;&gt; not support stored properties, so I guess there is no extra need to<br>&gt;&gt; mark properties with any special keyword.<br>&gt;<br>&gt; The keyword is mainly to indicate the unusual syntax at the definition site, where you only have to specify the name of the accessor you&#39;re defining, not a `func` or `var` keyword, a return type, or even parameter names. (Like `willSet`, there&#39;s a default parameter name you can use.) Secondarily, though, I think it&#39;s helpful to indicate very explicitly that this is not an ordinary method or property definition, even if the compiler could perhaps sort things out without it. `accessor` is something a user can Google if they&#39;ve never seen it before.<br>&gt;<br>&gt;&gt; Property accessors might work for enums with associated values, but<br>&gt;&gt; not so well without them.<br>&gt;<br>&gt; The two have nothing to do with each other. I showed your planets example, which has no associated values but uses accessors just fine.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 29, 2016 at 09:00:00am</p></header><div class="content"><p>I think that&#39;s the case with enums. You&#39;re changing their current behaviour of only having stored values to one in which it&#39;s computed (even if only once and then stored). Enums are IMO something that have a static value you know beforehand and can count on. That&#39;s why I&#39;m not fond of the accessor proposal. Otherwise I think we&#39;re transforming enums into a closed set of struct instances and one could do that already by using a private init.<br></p><p><br>&gt; On 29 May 2016, at 3:38 am, Jānis Kiršteins via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree with the argument about use of &quot;where&quot;, not replacing the raw<br>&gt; value and having some kind of initialization block. But I cannot see<br>&gt; why &quot;accessors&quot; concept is any better than stored properties to solve<br>&gt; the particular problem. The &quot;accessors&quot; concept has much wider scope<br>&gt; than enums and is a separate proposal.<br>&gt; <br>&gt; On Sat, May 28, 2016 at 11:39 PM, Brent Royal-Gordon<br>&gt; &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt; - Abusing rawValue is just that: an abuse.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My original proposal does not replace rawValue and is compatible with it.<br>&gt;&gt; <br>&gt;&gt; `rawValue` has a different purpose from how you&#39;re using it. It&#39;s supposed to allow you to convert your type to some other *equivalent* type, like an equivalent integer or string. Moreover, it&#39;s supposed to allow you to *reconstruct* the instance from the raw value—remember, `RawRepresentable` has an `init(rawValue:)` requirement.<br>&gt;&gt; <br>&gt;&gt; It is *not* supposed to be an ancillary bag of information on the side. You&#39;re cramming a square peg into a round hole here.<br>&gt;&gt; <br>&gt;&gt; (Also, if you use `rawValue` for an ancillary bag of information, that means you *can&#39;t* use it on the same type for its intended purpose. For instance, you would not be able to assign numbers to your Planet enum&#39;s cases to help you serialize them or bridge them to Objective-C. That&#39;s not good.)<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; - Using `where` just doesn&#39;t match the use of `where` elsewhere in the language; everywhere else, it&#39;s some kind of condition.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is also used in generic type constraints. Plus it reads like human<br>&gt;&gt;&gt; language: `case mercury where (mass: 3.303e+23, radius: 2.4397e6)`<br>&gt;&gt; <br>&gt;&gt; But a generic constraint is also a type of condition: it specifies types which are permitted and divides them from types that are not.<br>&gt;&gt; <br>&gt;&gt; This is *not* a condition. It&#39;s not anything like a condition. It&#39;s simply not consistent with anything else in the language.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; - Dictionaries are the most straightforward way to handle this with the current language, but their lack of exhaustiveness checking is a problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dictionaries can be used as workaround, but they cannot (lack of<br>&gt;&gt;&gt; exhaustiveness) solve the problem.<br>&gt;&gt; <br>&gt;&gt; I agree that they&#39;re a halfway solution.<br>&gt;&gt; <br>&gt;&gt; If `ValuesEnumerable` were to be accepted (and to have a generic requirement for its `allValues` property), you could write a Dictionary-like type which ensured at initialization time that it was exhaustive. That&#39;s not as good as compile time, but it&#39;s not bad—sort of a three-quarters solution.<br>&gt;&gt; <br>&gt;&gt;        struct ExhaustiveDictionary&lt;Key: Hashable, Value where Key: ValuesEnumerable&gt;: Collection, DictionaryLiteralConvertible {<br>&gt;&gt;                private var dictionary: [Key: Value]<br>&gt;&gt; <br>&gt;&gt;                init(dictionaryLiteral elements: (Key, Value)...) {<br>&gt;&gt;                        dictionary = [:]<br>&gt;&gt;                        for (k, v) in elements {<br>&gt;&gt;                                dictionary[k] = v<br>&gt;&gt;                        }<br>&gt;&gt; <br>&gt;&gt;                        if dictionary.count != Key.allValues.count {<br>&gt;&gt;                                let missingKeys = Key.allValues.filter { dictionary[$0] == nil }<br>&gt;&gt;                                preconditionFailure(&quot;ExhaustiveDictionary is missing elements from \(Key.self): \(missingKeys)&quot;)<br>&gt;&gt;                        }<br>&gt;&gt;                }<br>&gt;&gt; <br>&gt;&gt;                var startIndex: Dictionary.Index {<br>&gt;&gt;                        return dictionary.startIndex<br>&gt;&gt;                }<br>&gt;&gt;                var endIndex: Dictionary.Index {<br>&gt;&gt;                        return dictionary.endIndex<br>&gt;&gt;                }<br>&gt;&gt;                subscript(index: Dictionary.Index) -&gt; (Key, Value) {<br>&gt;&gt;                        return dictionary[index]<br>&gt;&gt;                }<br>&gt;&gt;                func index(after i: Dictionary.Index) -&gt; Dictionary.Index {<br>&gt;&gt;                        return dictionary.index(after: i)<br>&gt;&gt;                }<br>&gt;&gt; <br>&gt;&gt;                subscript(key: Key) -&gt; Value {<br>&gt;&gt;                        get { return dictionary[key]! }<br>&gt;&gt;                        set { dictionary[key] = newValue }<br>&gt;&gt;                }<br>&gt;&gt;        }<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; What I would do is borrow the &quot;accessors&quot; concept from the property behaviors proposal and extend it so that it supported both functions and variables.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Wouldn&#39;t accessor just be a redundant keyword here? Currently enums do<br>&gt;&gt;&gt; not support stored properties, so I guess there is no extra need to<br>&gt;&gt;&gt; mark properties with any special keyword.<br>&gt;&gt; <br>&gt;&gt; The keyword is mainly to indicate the unusual syntax at the definition site, where you only have to specify the name of the accessor you&#39;re defining, not a `func` or `var` keyword, a return type, or even parameter names. (Like `willSet`, there&#39;s a default parameter name you can use.) Secondarily, though, I think it&#39;s helpful to indicate very explicitly that this is not an ordinary method or property definition, even if the compiler could perhaps sort things out without it. `accessor` is something a user can Google if they&#39;ve never seen it before.<br>&gt;&gt; <br>&gt;&gt;&gt; Property accessors might work for enums with associated values, but<br>&gt;&gt;&gt; not so well without them.<br>&gt;&gt; <br>&gt;&gt; The two have nothing to do with each other. I showed your planets example, which has no associated values but uses accessors just fine.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44a036cc421ee97534c54653a233db93?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Jānis Kiršteins</string> &lt;janis.kirsteins at gmail.com&gt;<p>May 31, 2016 at 05:00:00pm</p></header><div class="content"><p>I wrote a proposal draft:<br></p><p># Enum case stored properties<br></p><p>* Proposal: TBD<br>* Author: [Janis Kirsteins](https://github.com/kirsteins)<br>* Status: TBD<br>* Review manager: TBD<br></p><p>## Introduction<br></p><p>This proposal allows each enum case to have stored properties.<br></p><p>## Motivation<br></p><p>Enums cases can have a lot of constant (or variable) static values<br>associated with it. For example, planets can have mass, radius, age,<br>closest star etc. Currently there is no way to set or get those values<br>easily.<br></p><p>Example below shows that is hard to read and manage static associated<br>values with each case. It is hard to add or remove case as it would<br>require to add or remove code in four different places in file. Also<br>static associated value like `UIBezierPath` is recreated each time the<br>property is computed while it&#39;s constant.<br></p><p>```swift<br>enum Suit {<br>    case spades<br>    case hearts<br>    case diamonds<br>    case clubs<br></p><p>    var simpleDescription: String {<br>        switch self {<br>        case .spades:<br>            return &quot;spades&quot;<br>        case .hearts:<br>            return &quot;hearts&quot;<br>        case .diamonds:<br>            return &quot;diamonds&quot;<br>        case .clubs:<br>            return &quot;clubs&quot;<br>        }<br>    }<br></p><p>    var color: UIColor {<br>        switch self {<br>        case .spades:<br>            return .blackColor()<br>        case .hearts:<br>            return .redColor()<br>        case .diamonds:<br>            return .redColor()<br>        case .clubs:<br>            return .blackColor()<br>        }<br>    }<br></p><p>    var symbol: String {<br>        switch self {<br>        case .spades:<br>            return &quot;♠&quot;<br>        case .hearts:<br>            return &quot;♥&quot;<br>        case .diamonds:<br>            return &quot;♦&quot;<br>        case .clubs:<br>            return &quot;♣&quot;<br>        }<br>    }<br></p><p>    var bezierPath: UIBezierPath {<br>        switch self {<br>        case .spades:<br>            let path = UIBezierPath()<br>            // omitted lines ...<br>            return path<br>        case .hearts:<br>            let path = UIBezierPath()<br>            // omitted lines ...<br>            return path<br>        case .diamonds:<br>            let path = UIBezierPath()<br>            // omitted lines ...<br>            return path<br>        case .clubs:<br>            let path = UIBezierPath()<br>            // omitted lines ...<br>            return path<br>        }<br>    }<br>}<br>```<br></p><p>## Proposed solution<br></p><p>Support stored properties for enum cases just as each case were an<br>instance. Case properties are initialized block after each case<br>declaration.<br></p><p>```swift<br>enum Suit {<br>    let simpleDescription: String<br>    let color: UIColor<br>    let symbol: String<br>    let bezierPath: UIBezierPath<br></p><p>    case spades {<br>        simpleDescription = &quot;spades&quot;<br>        color = .blackColor()<br>        symbol = &quot;♠&quot;<br>        let bezierPath = UIBezierPath()<br>        // omitted lines ...<br>        self.bezierPath = bezierPath<br>    }<br></p><p>    case hearts {<br>        simpleDescription = &quot;hearts&quot;<br>        color = .redColor()<br>        symbol = &quot;♥&quot;<br>        let bezierPath = UIBezierPath()<br>        // omitted lines ...<br>        self.bezierPath = bezierPath<br>    }<br></p><p>    case diamonds {<br>        simpleDescription = &quot;diamonds&quot;<br>        color = .redColor()<br>        symbol = &quot;♦&quot;<br>        let bezierPath = UIBezierPath()<br>        // omitted lines ...<br>        self.bezierPath = bezierPath<br>    }<br></p><p>    case clubs {<br>        simpleDescription = &quot;clubs&quot;<br>        color = .blackColor()<br>        symbol = &quot;♣&quot;<br>        let bezierPath = UIBezierPath()<br>        // omitted lines ...<br>        self.bezierPath = bezierPath<br>    }<br>}<br></p><p>let symbol = Suit.spades.symbol // &quot;♠&quot;<br>```<br></p><p>The proposed solution improves:<br>- Readability as cases are closer with their related data;<br>- Improves code maintainability as a case can be removed or added in one place;<br>- Improved performance as there is no need to recreate static values;<br>- ~30% less lines of code in given example.<br></p><p>## Detailed design<br></p><p>#### Stored properties<br></p><p>Enum stored properties are supported the same way they are supported<br>for structs can classes. Unlike enum associated values, stored<br>properties are static to case and are shared for the same case.<br></p><p>Properties are accessed:<br>```swift<br>let simpleDescription = Suit.spades.simpleDescription<br>```<br></p><p>Mutable properties can be set:<br>```swift<br>Suit.spades.simpleDescription = &quot;new simple description&quot;<br>```<br></p><p>#### Initialization<br></p><p>If enum has uninitialized stored property it must be initialized in a<br>block after each case declaration. The block work the same way as<br>struct initialization. At the end of initialization block all<br>properties must be initialized.<br></p><p>```swift<br>enum Suit {<br>    var simpleDescription: String<br></p><p>    case spades {<br>        simpleDescription = &quot;spades&quot;<br>    }<br>}<br>```<br></p><p>Initialization block can be combine with use of `rawValue`:<br></p><p>```swift<br>enum Suit: Int {<br>    var simpleDescription: String<br></p><p>    case spades = 1 {<br>        simpleDescription = &quot;spades&quot;<br>    }<br>}<br>```<br>or associated values of the case:<br></p><p>```swift<br>enum Suit {<br>    var simpleDescription: String<br></p><p>    case spades(Int) {<br>        simpleDescription = &quot;spades&quot;<br>    }<br>}<br>```<br></p><p>## Impact on existing code<br></p><p>Stored properties for enums are not currently not supported, so there<br>is no impact on existing code.<br></p><p>## Alternatives considered<br></p><p>- Use labeled tuple as `rawValue` of the enum case. This approach is<br>not compatible as it conflicts with intention of `rawValue` of Swift<br>enum;<br>- Use per case initializer like [Java<br>Enum](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html).<br>Swift enum uses custom initializer syntax to setup instances, not<br>cases. So this approach is not suitable for Swift.<br></p><p><br>On Sun, May 29, 2016 at 3:42 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; I think that&#39;s the case with enums. You&#39;re changing their current behaviour of only having stored values to one in which it&#39;s computed (even if only once and then stored). Enums are IMO something that have a static value you know beforehand and can count on. That&#39;s why I&#39;m not fond of the accessor proposal. Otherwise I think we&#39;re transforming enums into a closed set of struct instances and one could do that already by using a private init.<br>&gt;<br>&gt;<br>&gt;&gt; On 29 May 2016, at 3:38 am, Jānis Kiršteins via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I agree with the argument about use of &quot;where&quot;, not replacing the raw<br>&gt;&gt; value and having some kind of initialization block. But I cannot see<br>&gt;&gt; why &quot;accessors&quot; concept is any better than stored properties to solve<br>&gt;&gt; the particular problem. The &quot;accessors&quot; concept has much wider scope<br>&gt;&gt; than enums and is a separate proposal.<br>&gt;&gt;<br>&gt;&gt; On Sat, May 28, 2016 at 11:39 PM, Brent Royal-Gordon<br>&gt;&gt; &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; - Abusing rawValue is just that: an abuse.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; My original proposal does not replace rawValue and is compatible with it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; `rawValue` has a different purpose from how you&#39;re using it. It&#39;s supposed to allow you to convert your type to some other *equivalent* type, like an equivalent integer or string. Moreover, it&#39;s supposed to allow you to *reconstruct* the instance from the raw value—remember, `RawRepresentable` has an `init(rawValue:)` requirement.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It is *not* supposed to be an ancillary bag of information on the side. You&#39;re cramming a square peg into a round hole here.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (Also, if you use `rawValue` for an ancillary bag of information, that means you *can&#39;t* use it on the same type for its intended purpose. For instance, you would not be able to assign numbers to your Planet enum&#39;s cases to help you serialize them or bridge them to Objective-C. That&#39;s not good.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; - Using `where` just doesn&#39;t match the use of `where` elsewhere in the language; everywhere else, it&#39;s some kind of condition.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It is also used in generic type constraints. Plus it reads like human<br>&gt;&gt;&gt;&gt; language: `case mercury where (mass: 3.303e+23, radius: 2.4397e6)`<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But a generic constraint is also a type of condition: it specifies types which are permitted and divides them from types that are not.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is *not* a condition. It&#39;s not anything like a condition. It&#39;s simply not consistent with anything else in the language.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; - Dictionaries are the most straightforward way to handle this with the current language, but their lack of exhaustiveness checking is a problem.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Dictionaries can be used as workaround, but they cannot (lack of<br>&gt;&gt;&gt;&gt; exhaustiveness) solve the problem.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree that they&#39;re a halfway solution.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If `ValuesEnumerable` were to be accepted (and to have a generic requirement for its `allValues` property), you could write a Dictionary-like type which ensured at initialization time that it was exhaustive. That&#39;s not as good as compile time, but it&#39;s not bad—sort of a three-quarters solution.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;        struct ExhaustiveDictionary&lt;Key: Hashable, Value where Key: ValuesEnumerable&gt;: Collection, DictionaryLiteralConvertible {<br>&gt;&gt;&gt;                private var dictionary: [Key: Value]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                init(dictionaryLiteral elements: (Key, Value)...) {<br>&gt;&gt;&gt;                        dictionary = [:]<br>&gt;&gt;&gt;                        for (k, v) in elements {<br>&gt;&gt;&gt;                                dictionary[k] = v<br>&gt;&gt;&gt;                        }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                        if dictionary.count != Key.allValues.count {<br>&gt;&gt;&gt;                                let missingKeys = Key.allValues.filter { dictionary[$0] == nil }<br>&gt;&gt;&gt;                                preconditionFailure(&quot;ExhaustiveDictionary is missing elements from \(Key.self): \(missingKeys)&quot;)<br>&gt;&gt;&gt;                        }<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                var startIndex: Dictionary.Index {<br>&gt;&gt;&gt;                        return dictionary.startIndex<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt;                var endIndex: Dictionary.Index {<br>&gt;&gt;&gt;                        return dictionary.endIndex<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt;                subscript(index: Dictionary.Index) -&gt; (Key, Value) {<br>&gt;&gt;&gt;                        return dictionary[index]<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt;                func index(after i: Dictionary.Index) -&gt; Dictionary.Index {<br>&gt;&gt;&gt;                        return dictionary.index(after: i)<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                subscript(key: Key) -&gt; Value {<br>&gt;&gt;&gt;                        get { return dictionary[key]! }<br>&gt;&gt;&gt;                        set { dictionary[key] = newValue }<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; What I would do is borrow the &quot;accessors&quot; concept from the property behaviors proposal and extend it so that it supported both functions and variables.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Wouldn&#39;t accessor just be a redundant keyword here? Currently enums do<br>&gt;&gt;&gt;&gt; not support stored properties, so I guess there is no extra need to<br>&gt;&gt;&gt;&gt; mark properties with any special keyword.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The keyword is mainly to indicate the unusual syntax at the definition site, where you only have to specify the name of the accessor you&#39;re defining, not a `func` or `var` keyword, a return type, or even parameter names. (Like `willSet`, there&#39;s a default parameter name you can use.) Secondarily, though, I think it&#39;s helpful to indicate very explicitly that this is not an ordinary method or property definition, even if the compiler could perhaps sort things out without it. `accessor` is something a user can Google if they&#39;ve never seen it before.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Property accessors might work for enums with associated values, but<br>&gt;&gt;&gt;&gt; not so well without them.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The two have nothing to do with each other. I showed your planets example, which has no associated values but uses accessors just fine.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Enums with static stored propertiesfor each case</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 31, 2016 at 11:00:00am</p></header><div class="content"><p>As I said before, I&#39;m not in favour of this approach. And you completely missed my proposal in the alternatives.<br></p><p><br></p><p>-----Original Message-----<br>From: &quot;Jānis Kiršteins&quot; &lt;janis.kirsteins at gmail.com&gt;<br>Sent: ‎31/‎05/‎2016 11:17 AM<br>To: &quot;Leonardo Pessoa&quot; &lt;me at lmpessoa.com&gt;<br>Cc: &quot;Brent Royal-Gordon&quot; &lt;brent at architechies.com&gt;; &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Proposal] Enums with static stored propertiesfor each case<br></p><p>I wrote a proposal draft:<br></p><p># Enum case stored properties<br></p><p>* Proposal: TBD<br>* Author: [Janis Kirsteins](https://github.com/kirsteins)<br>* Status: TBD<br>* Review manager: TBD<br></p><p>## Introduction<br></p><p>This proposal allows each enum case to have stored properties.<br></p><p>## Motivation<br></p><p>Enums cases can have a lot of constant (or variable) static values<br>associated with it. For example, planets can have mass, radius, age,<br>closest star etc. Currently there is no way to set or get those values<br>easily.<br></p><p>Example below shows that is hard to read and manage static associated<br>values with each case. It is hard to add or remove case as it would<br>require to add or remove code in four different places in file. Also<br>static associated value like `UIBezierPath` is recreated each time the<br>property is computed while it&#39;s constant.<br></p><p>```swift<br>enum Suit {<br>    case spades<br>    case hearts<br>    case diamonds<br>    case clubs<br></p><p>    var simpleDescription: String {<br>        switch self {<br>        case .spades:<br>            return &quot;spades&quot;<br>        case .hearts:<br>            return &quot;hearts&quot;<br>        case .diamonds:<br>            return &quot;diamonds&quot;<br>        case .clubs:<br>            return &quot;clubs&quot;<br>        }<br>    }<br></p><p>    var color: UIColor {<br>        switch self {<br>        case .spades:<br>            return .blackColor()<br>        case .hearts:<br>            return .redColor()<br>        case .diamonds:<br>            return .redColor()<br>        case .clubs:<br>            return .blackColor()<br>        }<br>    }<br></p><p>    var symbol: String {<br>        switch self {<br>        case .spades:<br>            return &quot;♠&quot;<br>        case .hearts:<br>            return &quot;♥&quot;<br>        case .diamonds:<br>            return &quot;♦&quot;<br>        case .clubs:<br>            return &quot;♣&quot;<br>        }<br>    }<br></p><p>    var bezierPath: UIBezierPath {<br>        switch self {<br>        case .spades:<br>            let path = UIBezierPath()<br>            // omitted lines ...<br>            return path<br>        case .hearts:<br>            let path = UIBezierPath()<br>            // omitted lines ...<br>            return path<br>        case .diamonds:<br>            let path = UIBezierPath()<br>            // omitted lines ...<br>            return path<br>        case .clubs:<br>            let path = UIBezierPath()<br>            // omitted lines ...<br>            return path<br>        }<br>    }<br>}<br>```<br></p><p>## Proposed solution<br></p><p>Support stored properties for enum cases just as each case were an<br>instance. Case properties are initialized block after each case<br>declaration.<br></p><p>```swift<br>enum Suit {<br>    let simpleDescription: String<br>    let color: UIColor<br>    let symbol: String<br>    let bezierPath: UIBezierPath<br></p><p>    case spades {<br>        simpleDescription = &quot;spades&quot;<br>        color = .blackColor()<br>        symbol = &quot;♠&quot;<br>        let bezierPath = UIBezierPath()<br>        // omitted lines ...<br>        self.bezierPath = bezierPath<br>    }<br></p><p>    case hearts {<br>        simpleDescription = &quot;hearts&quot;<br>        color = .redColor()<br>        symbol = &quot;♥&quot;<br>        let bezierPath = UIBezierPath()<br>        // omitted lines ...<br>        self.bezierPath = bezierPath<br>    }<br></p><p>    case diamonds {<br>        simpleDescription = &quot;diamonds&quot;<br>        color = .redColor()<br>        symbol = &quot;♦&quot;<br>        let bezierPath = UIBezierPath()<br>        // omitted lines ...<br>        self.bezierPath = bezierPath<br>    }<br></p><p>    case clubs {<br>        simpleDescription = &quot;clubs&quot;<br>        color = .blackColor()<br>        symbol = &quot;♣&quot;<br>        let bezierPath = UIBezierPath()<br>        // omitted lines ...<br>        self.bezierPath = bezierPath<br>    }<br>}<br></p><p>let symbol = Suit.spades.symbol // &quot;♠&quot;<br>```<br></p><p>The proposed solution improves:<br>- Readability as cases are closer with their related data;<br>- Improves code maintainability as a case can be removed or added in one place;<br>- Improved performance as there is no need to recreate static values;<br>- ~30% less lines of code in given example.<br></p><p>## Detailed design<br></p><p>#### Stored properties<br></p><p>Enum stored properties are supported the same way they are supported<br>for structs can classes. Unlike enum associated values, stored<br>properties are static to case and are shared for the same case.<br></p><p>Properties are accessed:<br>```swift<br>let simpleDescription = Suit.spades.simpleDescription<br>```<br></p><p>Mutable properties can be set:<br>```swift<br>Suit.spades.simpleDescription = &quot;new simple description&quot;<br>```<br></p><p>#### Initialization<br></p><p>If enum has uninitialized stored property it must be initialized in a<br>block after each case declaration. The block work the same way as<br>struct initialization. At the end of initialization block all<br>properties must be initialized.<br></p><p>```swift<br>enum Suit {<br>    var simpleDescription: String<br></p><p>    case spades {<br>        simpleDescription = &quot;spades&quot;<br>    }<br>}<br>```<br></p><p>Initialization block can be combine with use of `rawValue`:<br></p><p>```swift<br>enum Suit: Int {<br>    var simpleDescription: String<br></p><p>    case spades = 1 {<br>        simpleDescription = &quot;spades&quot;<br>    }<br>}<br>```<br>or associated values of the case:<br></p><p>```swift<br>enum Suit {<br>    var simpleDescription: String<br></p><p>    case spades(Int) {<br>        simpleDescription = &quot;spades&quot;<br>    }<br>}<br>```<br></p><p>## Impact on existing code<br></p><p>Stored properties for enums are not currently not supported, so there<br>is no impact on existing code.<br></p><p>## Alternatives considered<br></p><p>- Use labeled tuple as `rawValue` of the enum case. This approach is<br>not compatible as it conflicts with intention of `rawValue` of Swift<br>enum;<br>- Use per case initializer like [Java<br>Enum](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html).<br>Swift enum uses custom initializer syntax to setup instances, not<br>cases. So this approach is not suitable for Swift.<br></p><p><br>On Sun, May 29, 2016 at 3:42 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; I think that&#39;s the case with enums. You&#39;re changing their current behaviour of only having stored values to one in which it&#39;s computed (even if only once and then stored). Enums are IMO something that have a static value you know beforehand and can count on. That&#39;s why I&#39;m not fond of the accessor proposal. Otherwise I think we&#39;re transforming enums into a closed set of struct instances and one could do that already by using a private init.<br>&gt;<br>&gt;<br>&gt;&gt; On 29 May 2016, at 3:38 am, Jānis Kiršteins via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I agree with the argument about use of &quot;where&quot;, not replacing the raw<br>&gt;&gt; value and having some kind of initialization block. But I cannot see<br>&gt;&gt; why &quot;accessors&quot; concept is any better than stored properties to solve<br>&gt;&gt; the particular problem. The &quot;accessors&quot; concept has much wider scope<br>&gt;&gt; than enums and is a separate proposal.<br>&gt;&gt;<br>&gt;&gt; On Sat, May 28, 2016 at 11:39 PM, Brent Royal-Gordon<br>&gt;&gt; &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; - Abusing rawValue is just that: an abuse.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; My original proposal does not replace rawValue and is compatible with it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; `rawValue` has a different purpose from how you&#39;re using it. It&#39;s supposed to allow you to convert your type to some other *equivalent* type, like an equivalent integer or string. Moreover, it&#39;s supposed to allow you to *reconstruct* the instance from the raw value—remember, `RawRepresentable` has an `init(rawValue:)` requirement.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It is *not* supposed to be an ancillary bag of information on the side. You&#39;re cramming a square peg into a round hole here.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (Also, if you use `rawValue` for an ancillary bag of information, that means you *can&#39;t* use it on the same type for its intended purpose. For instance, you would not be able to assign numbers to your Planet enum&#39;s cases to help you serialize them or bridge them to Objective-C. That&#39;s not good.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; - Using `where` just doesn&#39;t match the use of `where` elsewhere in the language; everywhere else, it&#39;s some kind of condition.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It is also used in generic type constraints. Plus it reads like human<br>&gt;&gt;&gt;&gt; language: `case mercury where (mass: 3.303e+23, radius: 2.4397e6)`<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But a generic constraint is also a type of condition: it specifies types which are permitted and divides them from types that are not.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is *not* a condition. It&#39;s not anything like a condition. It&#39;s simply not consistent with anything else in the language.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; - Dictionaries are the most straightforward way to handle this with the current language, but their lack of exhaustiveness checking is a problem.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Dictionaries can be used as workaround, but they cannot (lack of<br>&gt;&gt;&gt;&gt; exhaustiveness) solve the problem.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree that they&#39;re a halfway solution.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If `ValuesEnumerable` were to be accepted (and to have a generic requirement for its `allValues` property), you could write a Dictionary-like type which ensured at initialization time that it was exhaustive. That&#39;s not as good as compile time, but it&#39;s not bad—sort of a three-quarters solution.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;        struct ExhaustiveDictionary&lt;Key: Hashable, Value where Key: ValuesEnumerable&gt;: Collection, DictionaryLiteralConvertible {<br>&gt;&gt;&gt;                private var dictionary: [Key: Value]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                init(dictionaryLiteral elements: (Key, Value)...) {<br>&gt;&gt;&gt;                        dictionary = [:]<br>&gt;&gt;&gt;                        for (k, v) in elements {<br>&gt;&gt;&gt;                                dictionary[k] = v<br>&gt;&gt;&gt;                        }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                        if dictionary.count != Key.allValues.count {<br>&gt;&gt;&gt;                                let missingKeys = Key.allValues.filter { dictionary[$0] == nil }<br>&gt;&gt;&gt;                                preconditionFailure(&quot;ExhaustiveDictionary is missing elements from \(Key.self): \(missingKeys)&quot;)<br>&gt;&gt;&gt;                        }<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                var startIndex: Dictionary.Index {<br>&gt;&gt;&gt;                        return dictionary.startIndex<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt;                var endIndex: Dictionary.Index {<br>&gt;&gt;&gt;                        return dictionary.endIndex<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt;                subscript(index: Dictionary.Index) -&gt; (Key, Value) {<br>&gt;&gt;&gt;                        return dictionary[index]<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt;                func index(after i: Dictionary.Index) -&gt; Dictionary.Index {<br>&gt;&gt;&gt;                        return dictionary.index(after: i)<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                subscript(key: Key) -&gt; Value {<br>&gt;&gt;&gt;                        get { return dictionary[key]! }<br>&gt;&gt;&gt;                        set { dictionary[key] = newValue }<br>&gt;&gt;&gt;                }<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; What I would do is borrow the &quot;accessors&quot; concept from the property behaviors proposal and extend it so that it supported both functions and variables.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Wouldn&#39;t accessor just be a redundant keyword here? Currently enums do<br>&gt;&gt;&gt;&gt; not support stored properties, so I guess there is no extra need to<br>&gt;&gt;&gt;&gt; mark properties with any special keyword.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The keyword is mainly to indicate the unusual syntax at the definition site, where you only have to specify the name of the accessor you&#39;re defining, not a `func` or `var` keyword, a return type, or even parameter names. (Like `willSet`, there&#39;s a default parameter name you can use.) Secondarily, though, I think it&#39;s helpful to indicate very explicitly that this is not an ordinary method or property definition, even if the compiler could perhaps sort things out without it. `accessor` is something a user can Google if they&#39;ve never seen it before.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Property accessors might work for enums with associated values, but<br>&gt;&gt;&gt;&gt; not so well without them.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The two have nothing to do with each other. I showed your planets example, which has no associated values but uses accessors just fine.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/74e45eca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Enums with static stored propertiesfor each case</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 31, 2016 at 01:00:00pm</p></header><div class="content"><p>Just complementing as I was on the run when I saw and responded the<br>previous message.<br></p><p>In my proposal, we would be allowing tuples to be used as if they were<br>value types in enums.<br></p><p>|   enum Planet : (mass: Double, radius: Double) {<br>|       case Mercury = (mass: 3.303e+23, radius: 2.4397e6)<br>|       case Venus = (mass: 4.869e+24, radius: 6.0518e6)<br>|       case Earth = (mass: 5.976e+24, radius: 6.37814e6)<br>|       case Mars = (mass: 6.421e+23, radius: 3.3972e6)<br>|       case Jupiter = (mass: 1.9e+27, radius: 7.1492e7)<br>|       case Saturn = (mass: 5.688e+26, radius: 6.0268e7)<br>|       case Uranus = (mass: 8.686e+25, radius: 2.5559e7)<br>|       case Neptune = (mass: 1.024e+26, radius: 2.4746e7)<br>|   }<br></p><p>Since tuples cannot be tested for uniqueness (I&#39;d even go further to<br>say this would be undesireable here), you would also not have the<br>init(rawValue:) method testing for tuples and thus you would not have<br>the rawValue property of single typed enums returning the tuple<br>either, just like non-typed enums (calling .rawValue on a non-typed<br>enum will return the enum value itself, thus calling<br>Planet.Mercury.rawValue would return .Mercury itself here too). This<br>imposes no changes on existing code and allows for the values to be<br>refered to directly without using .rawValue in the middle (e.g.<br>print(Planet.Mercury.radius) instead of<br>print(Planet.Mercury.rawValue.radius)). You could even think of<br>internally representing single typed enums using a single value tuple<br>like the following:<br></p><p>|   enum Order : Int {<br>|       case First = 1<br>|       case Second<br>|       case Third<br>|       case Fourth<br>|   }<br></p><p>could be still declared like this but be internally represented as if it were:<br></p><p>|   enum Order : (rawValue: Int) {<br>|       case First = (rawValue: 1)<br>|       case Second = (rawValue: 2)<br>|       case Third = (rawValue: 3)<br>|       case Fourth = (rawValue: 4)<br>|   }<br></p><p>But that&#39;s just a simplification for internal representation and may<br>not even be used (I think this will be left for the Apple team to<br>decide how it should be implemented, either way current raw values<br>won&#39;t be broken).<br></p><p>IMO, this proposal only expands the possible set of values a typed<br>enum can hold using a syntax that is as close to the current one as I<br>think possible. Enums are, as defined in the Swift documentation, &quot;a<br>common type for a group of related **values**&quot; afterall and it makes<br>no sense to me to associate computed properties (which could return<br>different values each time they&#39;re called) to store constant value<br>properties and it&#39;s also much more verbose. Tuples can do this job<br>much better, cleaner and efficiently. You may also remember enums with<br>associated values: their values are defined when the enum is<br>initialised and never change either; you may create a new instance<br>with new values derived from another instance but you can never change<br>the values of an instance. Thus allowing an enum value to hold a<br>computed property seem like we&#39;re changing enums into something else.<br></p><p>Just one more idea to bring to this proposal, I thought there could be<br>a way to still have the init(rawValue:) method using tuples by simply<br>declaring one of the values of the tuple to be rawValue itself. The<br>compiler would enforce the uniqueness of values in this field and the<br>initialiser could find the enum value by its raw value, like this:<br></p><p>|   enum Planet : (mass: Double, radius: Double, rawValue: Int) {<br>|      case Mercury = (mass: 3.303e+23, radius: 2.4397e6, rawValue: 1)<br>|      case Venus = (mass: 4.869e+24, radius: 6.0518e6, rawValue: 2)<br>|      case Earth = (mass: 5.976e+24, radius: 6.37814e6, rawValue: 3)<br>|      case Mars = (mass: 6.421e+23, radius: 3.3972e6, rawValue: 4)<br>|      case Jupiter = (mass: 1.9e+27, radius: 7.1492e7, rawValue: 5)<br>|      case Saturn = (mass: 5.688e+26, radius: 6.0268e7, rawValue: 6)<br>|      case Uranus = (mass: 8.686e+25, radius: 2.5559e7, rawValue: 7)<br>|      case Neptune = (mass: 1.024e+26, radius: 2.4746e7, rawValue: 8)<br>|   }<br></p><p>and thus allow the following code:<br></p><p>|   let planet = Planet(rawValue: 4)!<br>|   print(planet.mass)<br></p><p>You may argue this is hard to read the more fields the tuple holds,<br>but there is nothing preventing you from formating your code in<br>another way, for example:<br></p><p>|   enum Planet : (mass: Double, radius: Double, rawValue: Int) {<br>|      case Mercury = (<br>|          mass: 3.303e+23,<br>|          radius: 2.4397e6,<br>|          rawValue: 1<br>|      )<br>|      case Venus = (<br>|          mass: 4.869e+24,<br>|          radius: 6.0518e6,<br>|          rawValue: 2<br>|      )<br>|      // ....<br></p><p>That was my proposal for the problem you presented.<br></p><p>On 31 May 2016 at 11:23, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; As I said before, I&#39;m not in favour of this approach. And you completely<br>&gt; missed my proposal in the alternatives.<br>&gt;<br>&gt; ________________________________<br>&gt; From: Jānis Kiršteins<br>&gt; Sent: ‎31/‎05/‎2016 11:17 AM<br>&gt; To: Leonardo Pessoa<br>&gt; Cc: Brent Royal-Gordon; swift-evolution<br>&gt; Subject: Re: [swift-evolution] [Proposal] Enums with static stored<br>&gt; propertiesfor each case<br>&gt;<br>&gt; I wrote a proposal draft:<br>&gt;<br>&gt; # Enum case stored properties<br>&gt;<br>&gt; * Proposal: TBD<br>&gt; * Author: [Janis Kirsteins](https://github.com/kirsteins)<br>&gt; * Status: TBD<br>&gt; * Review manager: TBD<br>&gt;<br>&gt; ## Introduction<br>&gt;<br>&gt; This proposal allows each enum case to have stored properties.<br>&gt;<br>&gt; ## Motivation<br>&gt;<br>&gt; Enums cases can have a lot of constant (or variable) static values<br>&gt; associated with it. For example, planets can have mass, radius, age,<br>&gt; closest star etc. Currently there is no way to set or get those values<br>&gt; easily.<br>&gt;<br>&gt; Example below shows that is hard to read and manage static associated<br>&gt; values with each case. It is hard to add or remove case as it would<br>&gt; require to add or remove code in four different places in file. Also<br>&gt; static associated value like `UIBezierPath` is recreated each time the<br>&gt; property is computed while it&#39;s constant.<br>&gt;<br>&gt; ```swift<br>&gt; enum Suit {<br>&gt;     case spades<br>&gt;     case hearts<br>&gt;     case diamonds<br>&gt;     case clubs<br>&gt;<br>&gt;     var simpleDescription: String {<br>&gt;         switch self {<br>&gt;         case .spades:<br>&gt;             return &quot;spades&quot;<br>&gt;         case .hearts:<br>&gt;             return &quot;hearts&quot;<br>&gt;         case .diamonds:<br>&gt;             return &quot;diamonds&quot;<br>&gt;         case .clubs:<br>&gt;             return &quot;clubs&quot;<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     var color: UIColor {<br>&gt;         switch self {<br>&gt;         case .spades:<br>&gt;             return .blackColor()<br>&gt;         case .hearts:<br>&gt;             return .redColor()<br>&gt;         case .diamonds:<br>&gt;             return .redColor()<br>&gt;         case .clubs:<br>&gt;             return .blackColor()<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     var symbol: String {<br>&gt;         switch self {<br>&gt;         case .spades:<br>&gt;             return &quot;♠&quot;<br>&gt;         case .hearts:<br>&gt;             return &quot;♥&quot;<br>&gt;         case .diamonds:<br>&gt;             return &quot;♦&quot;<br>&gt;         case .clubs:<br>&gt;             return &quot;♣&quot;<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     var bezierPath: UIBezierPath {<br>&gt;         switch self {<br>&gt;         case .spades:<br>&gt;             let path = UIBezierPath()<br>&gt;             // omitted lines ...<br>&gt;             return path<br>&gt;         case .hearts:<br>&gt;             let path = UIBezierPath()<br>&gt;             // omitted lines ...<br>&gt;             return path<br>&gt;         case .diamonds:<br>&gt;             let path = UIBezierPath()<br>&gt;             // omitted lines ...<br>&gt;             return path<br>&gt;         case .clubs:<br>&gt;             let path = UIBezierPath()<br>&gt;             // omitted lines ...<br>&gt;             return path<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; ## Proposed solution<br>&gt;<br>&gt; Support stored properties for enum cases just as each case were an<br>&gt; instance. Case properties are initialized block after each case<br>&gt; declaration.<br>&gt;<br>&gt; ```swift<br>&gt; enum Suit {<br>&gt;     let simpleDescription: String<br>&gt;     let color: UIColor<br>&gt;     let symbol: String<br>&gt;     let bezierPath: UIBezierPath<br>&gt;<br>&gt;     case spades {<br>&gt;         simpleDescription = &quot;spades&quot;<br>&gt;         color = .blackColor()<br>&gt;         symbol = &quot;♠&quot;<br>&gt;         let bezierPath = UIBezierPath()<br>&gt;         // omitted lines ...<br>&gt;         self.bezierPath = bezierPath<br>&gt;     }<br>&gt;<br>&gt;     case hearts {<br>&gt;         simpleDescription = &quot;hearts&quot;<br>&gt;         color = .redColor()<br>&gt;         symbol = &quot;♥&quot;<br>&gt;         let bezierPath = UIBezierPath()<br>&gt;         // omitted lines ...<br>&gt;         self.bezierPath = bezierPath<br>&gt;     }<br>&gt;<br>&gt;     case diamonds {<br>&gt;         simpleDescription = &quot;diamonds&quot;<br>&gt;         color = .redColor()<br>&gt;         symbol = &quot;♦&quot;<br>&gt;         let bezierPath = UIBezierPath()<br>&gt;         // omitted lines ...<br>&gt;         self.bezierPath = bezierPath<br>&gt;     }<br>&gt;<br>&gt;     case clubs {<br>&gt;         simpleDescription = &quot;clubs&quot;<br>&gt;         color = .blackColor()<br>&gt;         symbol = &quot;♣&quot;<br>&gt;         let bezierPath = UIBezierPath()<br>&gt;         // omitted lines ...<br>&gt;         self.bezierPath = bezierPath<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; let symbol = Suit.spades.symbol // &quot;♠&quot;<br>&gt; ```<br>&gt;<br>&gt; The proposed solution improves:<br>&gt; - Readability as cases are closer with their related data;<br>&gt; - Improves code maintainability as a case can be removed or added in one<br>&gt; place;<br>&gt; - Improved performance as there is no need to recreate static values;<br>&gt; - ~30% less lines of code in given example.<br>&gt;<br>&gt; ## Detailed design<br>&gt;<br>&gt; #### Stored properties<br>&gt;<br>&gt; Enum stored properties are supported the same way they are supported<br>&gt; for structs can classes. Unlike enum associated values, stored<br>&gt; properties are static to case and are shared for the same case.<br>&gt;<br>&gt; Properties are accessed:<br>&gt; ```swift<br>&gt; let simpleDescription = Suit.spades.simpleDescription<br>&gt; ```<br>&gt;<br>&gt; Mutable properties can be set:<br>&gt; ```swift<br>&gt; Suit.spades.simpleDescription = &quot;new simple description&quot;<br>&gt; ```<br>&gt;<br>&gt; #### Initialization<br>&gt;<br>&gt; If enum has uninitialized stored property it must be initialized in a<br>&gt; block after each case declaration. The block work the same way as<br>&gt; struct initialization. At the end of initialization block all<br>&gt; properties must be initialized.<br>&gt;<br>&gt; ```swift<br>&gt; enum Suit {<br>&gt;     var simpleDescription: String<br>&gt;<br>&gt;     case spades {<br>&gt;         simpleDescription = &quot;spades&quot;<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; Initialization block can be combine with use of `rawValue`:<br>&gt;<br>&gt; ```swift<br>&gt; enum Suit: Int {<br>&gt;     var simpleDescription: String<br>&gt;<br>&gt;     case spades = 1 {<br>&gt;         simpleDescription = &quot;spades&quot;<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt; or associated values of the case:<br>&gt;<br>&gt; ```swift<br>&gt; enum Suit {<br>&gt;     var simpleDescription: String<br>&gt;<br>&gt;     case spades(Int) {<br>&gt;         simpleDescription = &quot;spades&quot;<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; ## Impact on existing code<br>&gt;<br>&gt; Stored properties for enums are not currently not supported, so there<br>&gt; is no impact on existing code.<br>&gt;<br>&gt; ## Alternatives considered<br>&gt;<br>&gt; - Use labeled tuple as `rawValue` of the enum case. This approach is<br>&gt; not compatible as it conflicts with intention of `rawValue` of Swift<br>&gt; enum;<br>&gt; - Use per case initializer like [Java<br>&gt; Enum](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html).<br>&gt; Swift enum uses custom initializer syntax to setup instances, not<br>&gt; cases. So this approach is not suitable for Swift.<br>&gt;<br>&gt;<br>&gt; On Sun, May 29, 2016 at 3:42 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt; I think that&#39;s the case with enums. You&#39;re changing their current<br>&gt;&gt; behaviour of only having stored values to one in which it&#39;s computed (even<br>&gt;&gt; if only once and then stored). Enums are IMO something that have a static<br>&gt;&gt; value you know beforehand and can count on. That&#39;s why I&#39;m not fond of the<br>&gt;&gt; accessor proposal. Otherwise I think we&#39;re transforming enums into a closed<br>&gt;&gt; set of struct instances and one could do that already by using a private<br>&gt;&gt; init.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On 29 May 2016, at 3:38 am, Jānis Kiršteins via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree with the argument about use of &quot;where&quot;, not replacing the raw<br>&gt;&gt;&gt; value and having some kind of initialization block. But I cannot see<br>&gt;&gt;&gt; why &quot;accessors&quot; concept is any better than stored properties to solve<br>&gt;&gt;&gt; the particular problem. The &quot;accessors&quot; concept has much wider scope<br>&gt;&gt;&gt; than enums and is a separate proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, May 28, 2016 at 11:39 PM, Brent Royal-Gordon<br>&gt;&gt;&gt; &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; - Abusing rawValue is just that: an abuse.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; My original proposal does not replace rawValue and is compatible with<br>&gt;&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; `rawValue` has a different purpose from how you&#39;re using it. It&#39;s<br>&gt;&gt;&gt;&gt; supposed to allow you to convert your type to some other *equivalent* type,<br>&gt;&gt;&gt;&gt; like an equivalent integer or string. Moreover, it&#39;s supposed to allow you<br>&gt;&gt;&gt;&gt; to *reconstruct* the instance from the raw value—remember,<br>&gt;&gt;&gt;&gt; `RawRepresentable` has an `init(rawValue:)` requirement.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It is *not* supposed to be an ancillary bag of information on the side.<br>&gt;&gt;&gt;&gt; You&#39;re cramming a square peg into a round hole here.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; (Also, if you use `rawValue` for an ancillary bag of information, that<br>&gt;&gt;&gt;&gt; means you *can&#39;t* use it on the same type for its intended purpose. For<br>&gt;&gt;&gt;&gt; instance, you would not be able to assign numbers to your Planet enum&#39;s<br>&gt;&gt;&gt;&gt; cases to help you serialize them or bridge them to Objective-C. That&#39;s not<br>&gt;&gt;&gt;&gt; good.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; - Using `where` just doesn&#39;t match the use of `where` elsewhere in the<br>&gt;&gt;&gt;&gt;&gt;&gt; language; everywhere else, it&#39;s some kind of condition.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; It is also used in generic type constraints. Plus it reads like human<br>&gt;&gt;&gt;&gt;&gt; language: `case mercury where (mass: 3.303e+23, radius: 2.4397e6)`<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; But a generic constraint is also a type of condition: it specifies types<br>&gt;&gt;&gt;&gt; which are permitted and divides them from types that are not.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is *not* a condition. It&#39;s not anything like a condition. It&#39;s<br>&gt;&gt;&gt;&gt; simply not consistent with anything else in the language.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; - Dictionaries are the most straightforward way to handle this with<br>&gt;&gt;&gt;&gt;&gt;&gt; the current language, but their lack of exhaustiveness checking is a<br>&gt;&gt;&gt;&gt;&gt;&gt; problem.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Dictionaries can be used as workaround, but they cannot (lack of<br>&gt;&gt;&gt;&gt;&gt; exhaustiveness) solve the problem.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I agree that they&#39;re a halfway solution.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If `ValuesEnumerable` were to be accepted (and to have a generic<br>&gt;&gt;&gt;&gt; requirement for its `allValues` property), you could write a Dictionary-like<br>&gt;&gt;&gt;&gt; type which ensured at initialization time that it was exhaustive. That&#39;s not<br>&gt;&gt;&gt;&gt; as good as compile time, but it&#39;s not bad—sort of a three-quarters solution.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;        struct ExhaustiveDictionary&lt;Key: Hashable, Value where Key:<br>&gt;&gt;&gt;&gt; ValuesEnumerable&gt;: Collection, DictionaryLiteralConvertible {<br>&gt;&gt;&gt;&gt;                private var dictionary: [Key: Value]<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                init(dictionaryLiteral elements: (Key, Value)...) {<br>&gt;&gt;&gt;&gt;                        dictionary = [:]<br>&gt;&gt;&gt;&gt;                        for (k, v) in elements {<br>&gt;&gt;&gt;&gt;                                dictionary[k] = v<br>&gt;&gt;&gt;&gt;                        }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                        if dictionary.count != Key.allValues.count {<br>&gt;&gt;&gt;&gt;                                let missingKeys = Key.allValues.filter {<br>&gt;&gt;&gt;&gt; dictionary[$0] == nil }<br>&gt;&gt;&gt;&gt;                                preconditionFailure(&quot;ExhaustiveDictionary<br>&gt;&gt;&gt;&gt; is missing elements from \(Key.self): \(missingKeys)&quot;)<br>&gt;&gt;&gt;&gt;                        }<br>&gt;&gt;&gt;&gt;                }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                var startIndex: Dictionary.Index {<br>&gt;&gt;&gt;&gt;                        return dictionary.startIndex<br>&gt;&gt;&gt;&gt;                }<br>&gt;&gt;&gt;&gt;                var endIndex: Dictionary.Index {<br>&gt;&gt;&gt;&gt;                        return dictionary.endIndex<br>&gt;&gt;&gt;&gt;                }<br>&gt;&gt;&gt;&gt;                subscript(index: Dictionary.Index) -&gt; (Key, Value) {<br>&gt;&gt;&gt;&gt;                        return dictionary[index]<br>&gt;&gt;&gt;&gt;                }<br>&gt;&gt;&gt;&gt;                func index(after i: Dictionary.Index) -&gt; Dictionary.Index<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;                        return dictionary.index(after: i)<br>&gt;&gt;&gt;&gt;                }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                subscript(key: Key) -&gt; Value {<br>&gt;&gt;&gt;&gt;                        get { return dictionary[key]! }<br>&gt;&gt;&gt;&gt;                        set { dictionary[key] = newValue }<br>&gt;&gt;&gt;&gt;                }<br>&gt;&gt;&gt;&gt;        }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; What I would do is borrow the &quot;accessors&quot; concept from the property<br>&gt;&gt;&gt;&gt;&gt;&gt; behaviors proposal and extend it so that it supported both functions and<br>&gt;&gt;&gt;&gt;&gt;&gt; variables.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Wouldn&#39;t accessor just be a redundant keyword here? Currently enums do<br>&gt;&gt;&gt;&gt;&gt; not support stored properties, so I guess there is no extra need to<br>&gt;&gt;&gt;&gt;&gt; mark properties with any special keyword.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The keyword is mainly to indicate the unusual syntax at the definition<br>&gt;&gt;&gt;&gt; site, where you only have to specify the name of the accessor you&#39;re<br>&gt;&gt;&gt;&gt; defining, not a `func` or `var` keyword, a return type, or even parameter<br>&gt;&gt;&gt;&gt; names. (Like `willSet`, there&#39;s a default parameter name you can use.)<br>&gt;&gt;&gt;&gt; Secondarily, though, I think it&#39;s helpful to indicate very explicitly that<br>&gt;&gt;&gt;&gt; this is not an ordinary method or property definition, even if the compiler<br>&gt;&gt;&gt;&gt; could perhaps sort things out without it. `accessor` is something a user can<br>&gt;&gt;&gt;&gt; Google if they&#39;ve never seen it before.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Property accessors might work for enums with associated values, but<br>&gt;&gt;&gt;&gt;&gt; not so well without them.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The two have nothing to do with each other. I showed your planets<br>&gt;&gt;&gt;&gt; example, which has no associated values but uses accessors just fine.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 31, 2016 at 06:00:00pm</p></header><div class="content"><p>I&#39;m not sure about my opinion on this proposal, but I believe you should <br>add this as alternatives of how we can have the similar features today <br>without injecting stored properties into enums  :<br></p><p>enum Suit {<br>     case spades<br>     case hearts<br>     case diamonds<br>     case clubs<br></p><p>     struct SuitInfo {<br>         let simpleDescription: String<br>         let color: UIColor<br>         let symbol: String<br>         let bezierPath: UIBezierPath<br>     }<br></p><p>     var info : SuitInfo {<br>         switch self {<br>         case .spades:<br>             let path = UIBezierPath()<br>             // omitted lines ...<br></p><p>             return SuitInfo(<br>                 simpleDescription: &quot;spades&quot;,<br>                 color: .blackColor(),<br>                 symbol: &quot;♠&quot;,<br>                 bezierPath: path)<br></p><p>         case .hearts:<br>             let path = UIBezierPath()<br>             // omitted lines ...<br></p><p>             return SuitInfo(<br>                 simpleDescription: &quot;hearts&quot;,<br>                 color: .redColor(),<br>                 symbol: &quot;♥&quot;,<br>                 bezierPath: path)<br></p><p>         case .diamonds:<br>             let path = UIBezierPath()<br>             // omitted lines ...<br></p><p>             return SuitInfo(<br>                 simpleDescription: &quot;diamonds&quot;,<br>                 color: .redColor(),<br>                 symbol: &quot;♦&quot;,<br>                 bezierPath: path)<br></p><p>         case .clubs:<br>             let path = UIBezierPath()<br>             // omitted lines ...<br></p><p>             return SuitInfo(<br>                 simpleDescription: &quot;clubs&quot;,<br>                 color: .blackColor(),<br>                 symbol: &quot;♣&quot;,<br>                 bezierPath: path)<br></p><p>         }<br>     }<br>}<br></p><p>and this:<br></p><p>enum Suit  {<br>     case spades<br>     case hearts<br>     case diamonds<br>     case clubs<br></p><p>     struct SuitInfo  {<br>         let simpleDescription: String<br>         let color: UIColor<br>         let symbol: String<br>         let bezierPath: UIBezierPath<br>     }<br></p><p>     static let spadesInfo : SuitInfo = {<br>         let path = UIBezierPath()<br>         // omitted lines ...<br></p><p>         return SuitInfo(<br>             simpleDescription: &quot;spades&quot;,<br>             color: .blackColor(),<br>             symbol: &quot;♠&quot;,<br>             bezierPath: path)<br>     }()<br></p><p>     static let heartsInfo : SuitInfo = {<br>         let path = UIBezierPath()<br>         // omitted lines ...<br></p><p>         return SuitInfo(<br>             simpleDescription: &quot;hearts&quot;,<br>             color: .redColor(),<br>             symbol: &quot;♥&quot;,<br>             bezierPath: path)<br>     }()<br></p><p>     static let diamondsInfo : SuitInfo = {<br>         let path = UIBezierPath()<br>         // omitted lines ...<br></p><p>         return SuitInfo(<br>             simpleDescription: &quot;diamonds&quot;,<br>             color: .redColor(),<br>             symbol: &quot;♦&quot;,<br>             bezierPath: path)<br>     }()<br></p><p>     static let clubsInfo : SuitInfo = {<br>         let path = UIBezierPath()<br>         // omitted lines ...<br></p><p>         return SuitInfo(<br>             simpleDescription: &quot;clubs&quot;,<br>             color: .blackColor(),<br>             symbol: &quot;♣&quot;,<br>             bezierPath: path)<br>     }()<br></p><p><br>     var info : SuitInfo {<br>         switch self {<br>             case .spades: return Suit.spadesInfo<br>             case .hearts: return Suit.heartsInfo<br>             case .diamonds: return Suit.diamondsInfo<br>             case .clubs: return Suit.clubsInfo<br>         }<br>     }<br>}<br></p><p><br>On 31.05.2016 17:17, Jānis Kiršteins via swift-evolution wrote:<br>&gt; I wrote a proposal draft:<br>&gt;<br>&gt; # Enum case stored properties<br>&gt;<br>&gt; * Proposal: TBD<br>&gt; * Author: [Janis Kirsteins](https://github.com/kirsteins)<br>&gt; * Status: TBD<br>&gt; * Review manager: TBD<br>&gt;<br>&gt; ## Introduction<br>&gt;<br>&gt; This proposal allows each enum case to have stored properties.<br>&gt;<br>&gt; ## Motivation<br>&gt;<br>&gt; Enums cases can have a lot of constant (or variable) static values<br>&gt; associated with it. For example, planets can have mass, radius, age,<br>&gt; closest star etc. Currently there is no way to set or get those values<br>&gt; easily.<br>&gt;<br>&gt; Example below shows that is hard to read and manage static associated<br>&gt; values with each case. It is hard to add or remove case as it would<br>&gt; require to add or remove code in four different places in file. Also<br>&gt; static associated value like `UIBezierPath` is recreated each time the<br>&gt; property is computed while it&#39;s constant.<br>&gt;<br>&gt; ```swift<br>&gt; enum Suit {<br>&gt;     case spades<br>&gt;     case hearts<br>&gt;     case diamonds<br>&gt;     case clubs<br>&gt;<br>&gt;     var simpleDescription: String {<br>&gt;         switch self {<br>&gt;         case .spades:<br>&gt;             return &quot;spades&quot;<br>&gt;         case .hearts:<br>&gt;             return &quot;hearts&quot;<br>&gt;         case .diamonds:<br>&gt;             return &quot;diamonds&quot;<br>&gt;         case .clubs:<br>&gt;             return &quot;clubs&quot;<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     var color: UIColor {<br>&gt;         switch self {<br>&gt;         case .spades:<br>&gt;             return .blackColor()<br>&gt;         case .hearts:<br>&gt;             return .redColor()<br>&gt;         case .diamonds:<br>&gt;             return .redColor()<br>&gt;         case .clubs:<br>&gt;             return .blackColor()<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     var symbol: String {<br>&gt;         switch self {<br>&gt;         case .spades:<br>&gt;             return &quot;♠&quot;<br>&gt;         case .hearts:<br>&gt;             return &quot;♥&quot;<br>&gt;         case .diamonds:<br>&gt;             return &quot;♦&quot;<br>&gt;         case .clubs:<br>&gt;             return &quot;♣&quot;<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     var bezierPath: UIBezierPath {<br>&gt;         switch self {<br>&gt;         case .spades:<br>&gt;             let path = UIBezierPath()<br>&gt;             // omitted lines ...<br>&gt;             return path<br>&gt;         case .hearts:<br>&gt;             let path = UIBezierPath()<br>&gt;             // omitted lines ...<br>&gt;             return path<br>&gt;         case .diamonds:<br>&gt;             let path = UIBezierPath()<br>&gt;             // omitted lines ...<br>&gt;             return path<br>&gt;         case .clubs:<br>&gt;             let path = UIBezierPath()<br>&gt;             // omitted lines ...<br>&gt;             return path<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; ## Proposed solution<br>&gt;<br>&gt; Support stored properties for enum cases just as each case were an<br>&gt; instance. Case properties are initialized block after each case<br>&gt; declaration.<br>&gt;<br>&gt; ```swift<br>&gt; enum Suit {<br>&gt;     let simpleDescription: String<br>&gt;     let color: UIColor<br>&gt;     let symbol: String<br>&gt;     let bezierPath: UIBezierPath<br>&gt;<br>&gt;     case spades {<br>&gt;         simpleDescription = &quot;spades&quot;<br>&gt;         color = .blackColor()<br>&gt;         symbol = &quot;♠&quot;<br>&gt;         let bezierPath = UIBezierPath()<br>&gt;         // omitted lines ...<br>&gt;         self.bezierPath = bezierPath<br>&gt;     }<br>&gt;<br>&gt;     case hearts {<br>&gt;         simpleDescription = &quot;hearts&quot;<br>&gt;         color = .redColor()<br>&gt;         symbol = &quot;♥&quot;<br>&gt;         let bezierPath = UIBezierPath()<br>&gt;         // omitted lines ...<br>&gt;         self.bezierPath = bezierPath<br>&gt;     }<br>&gt;<br>&gt;     case diamonds {<br>&gt;         simpleDescription = &quot;diamonds&quot;<br>&gt;         color = .redColor()<br>&gt;         symbol = &quot;♦&quot;<br>&gt;         let bezierPath = UIBezierPath()<br>&gt;         // omitted lines ...<br>&gt;         self.bezierPath = bezierPath<br>&gt;     }<br>&gt;<br>&gt;     case clubs {<br>&gt;         simpleDescription = &quot;clubs&quot;<br>&gt;         color = .blackColor()<br>&gt;         symbol = &quot;♣&quot;<br>&gt;         let bezierPath = UIBezierPath()<br>&gt;         // omitted lines ...<br>&gt;         self.bezierPath = bezierPath<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; let symbol = Suit.spades.symbol // &quot;♠&quot;<br>&gt; ```<br>&gt;<br>&gt; The proposed solution improves:<br>&gt; - Readability as cases are closer with their related data;<br>&gt; - Improves code maintainability as a case can be removed or added in one place;<br>&gt; - Improved performance as there is no need to recreate static values;<br>&gt; - ~30% less lines of code in given example.<br>&gt;<br>&gt; ## Detailed design<br>&gt;<br>&gt; #### Stored properties<br>&gt;<br>&gt; Enum stored properties are supported the same way they are supported<br>&gt; for structs can classes. Unlike enum associated values, stored<br>&gt; properties are static to case and are shared for the same case.<br>&gt;<br>&gt; Properties are accessed:<br>&gt; ```swift<br>&gt; let simpleDescription = Suit.spades.simpleDescription<br>&gt; ```<br>&gt;<br>&gt; Mutable properties can be set:<br>&gt; ```swift<br>&gt; Suit.spades.simpleDescription = &quot;new simple description&quot;<br>&gt; ```<br>&gt;<br>&gt; #### Initialization<br>&gt;<br>&gt; If enum has uninitialized stored property it must be initialized in a<br>&gt; block after each case declaration. The block work the same way as<br>&gt; struct initialization. At the end of initialization block all<br>&gt; properties must be initialized.<br>&gt;<br>&gt; ```swift<br>&gt; enum Suit {<br>&gt;     var simpleDescription: String<br>&gt;<br>&gt;     case spades {<br>&gt;         simpleDescription = &quot;spades&quot;<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; Initialization block can be combine with use of `rawValue`:<br>&gt;<br>&gt; ```swift<br>&gt; enum Suit: Int {<br>&gt;     var simpleDescription: String<br>&gt;<br>&gt;     case spades = 1 {<br>&gt;         simpleDescription = &quot;spades&quot;<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt; or associated values of the case:<br>&gt;<br>&gt; ```swift<br>&gt; enum Suit {<br>&gt;     var simpleDescription: String<br>&gt;<br>&gt;     case spades(Int) {<br>&gt;         simpleDescription = &quot;spades&quot;<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; ## Impact on existing code<br>&gt;<br>&gt; Stored properties for enums are not currently not supported, so there<br>&gt; is no impact on existing code.<br>&gt;<br>&gt; ## Alternatives considered<br>&gt;<br>&gt; - Use labeled tuple as `rawValue` of the enum case. This approach is<br>&gt; not compatible as it conflicts with intention of `rawValue` of Swift<br>&gt; enum;<br>&gt; - Use per case initializer like [Java<br>&gt; Enum](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html).<br>&gt; Swift enum uses custom initializer syntax to setup instances, not<br>&gt; cases. So this approach is not suitable for Swift.<br>&gt;<br>&gt;<br>&gt; On Sun, May 29, 2016 at 3:42 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt; I think that&#39;s the case with enums. You&#39;re changing their current behaviour of only having stored values to one in which it&#39;s computed (even if only once and then stored). Enums are IMO something that have a static value you know beforehand and can count on. That&#39;s why I&#39;m not fond of the accessor proposal. Otherwise I think we&#39;re transforming enums into a closed set of struct instances and one could do that already by using a private init.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On 29 May 2016, at 3:38 am, Jānis Kiršteins via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree with the argument about use of &quot;where&quot;, not replacing the raw<br>&gt;&gt;&gt; value and having some kind of initialization block. But I cannot see<br>&gt;&gt;&gt; why &quot;accessors&quot; concept is any better than stored properties to solve<br>&gt;&gt;&gt; the particular problem. The &quot;accessors&quot; concept has much wider scope<br>&gt;&gt;&gt; than enums and is a separate proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, May 28, 2016 at 11:39 PM, Brent Royal-Gordon<br>&gt;&gt;&gt; &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; - Abusing rawValue is just that: an abuse.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; My original proposal does not replace rawValue and is compatible with it.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; `rawValue` has a different purpose from how you&#39;re using it. It&#39;s supposed to allow you to convert your type to some other *equivalent* type, like an equivalent integer or string. Moreover, it&#39;s supposed to allow you to *reconstruct* the instance from the raw value—remember, `RawRepresentable` has an `init(rawValue:)` requirement.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It is *not* supposed to be an ancillary bag of information on the side. You&#39;re cramming a square peg into a round hole here.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; (Also, if you use `rawValue` for an ancillary bag of information, that means you *can&#39;t* use it on the same type for its intended purpose. For instance, you would not be able to assign numbers to your Planet enum&#39;s cases to help you serialize them or bridge them to Objective-C. That&#39;s not good.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; - Using `where` just doesn&#39;t match the use of `where` elsewhere in the language; everywhere else, it&#39;s some kind of condition.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; It is also used in generic type constraints. Plus it reads like human<br>&gt;&gt;&gt;&gt;&gt; language: `case mercury where (mass: 3.303e+23, radius: 2.4397e6)`<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; But a generic constraint is also a type of condition: it specifies types which are permitted and divides them from types that are not.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is *not* a condition. It&#39;s not anything like a condition. It&#39;s simply not consistent with anything else in the language.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; - Dictionaries are the most straightforward way to handle this with the current language, but their lack of exhaustiveness checking is a problem.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Dictionaries can be used as workaround, but they cannot (lack of<br>&gt;&gt;&gt;&gt;&gt; exhaustiveness) solve the problem.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I agree that they&#39;re a halfway solution.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If `ValuesEnumerable` were to be accepted (and to have a generic requirement for its `allValues` property), you could write a Dictionary-like type which ensured at initialization time that it was exhaustive. That&#39;s not as good as compile time, but it&#39;s not bad—sort of a three-quarters solution.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;        struct ExhaustiveDictionary&lt;Key: Hashable, Value where Key: ValuesEnumerable&gt;: Collection, DictionaryLiteralConvertible {<br>&gt;&gt;&gt;&gt;                private var dictionary: [Key: Value]<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                init(dictionaryLiteral elements: (Key, Value)...) {<br>&gt;&gt;&gt;&gt;                        dictionary = [:]<br>&gt;&gt;&gt;&gt;                        for (k, v) in elements {<br>&gt;&gt;&gt;&gt;                                dictionary[k] = v<br>&gt;&gt;&gt;&gt;                        }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                        if dictionary.count != Key.allValues.count {<br>&gt;&gt;&gt;&gt;                                let missingKeys = Key.allValues.filter { dictionary[$0] == nil }<br>&gt;&gt;&gt;&gt;                                preconditionFailure(&quot;ExhaustiveDictionary is missing elements from \(Key.self): \(missingKeys)&quot;)<br>&gt;&gt;&gt;&gt;                        }<br>&gt;&gt;&gt;&gt;                }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                var startIndex: Dictionary.Index {<br>&gt;&gt;&gt;&gt;                        return dictionary.startIndex<br>&gt;&gt;&gt;&gt;                }<br>&gt;&gt;&gt;&gt;                var endIndex: Dictionary.Index {<br>&gt;&gt;&gt;&gt;                        return dictionary.endIndex<br>&gt;&gt;&gt;&gt;                }<br>&gt;&gt;&gt;&gt;                subscript(index: Dictionary.Index) -&gt; (Key, Value) {<br>&gt;&gt;&gt;&gt;                        return dictionary[index]<br>&gt;&gt;&gt;&gt;                }<br>&gt;&gt;&gt;&gt;                func index(after i: Dictionary.Index) -&gt; Dictionary.Index {<br>&gt;&gt;&gt;&gt;                        return dictionary.index(after: i)<br>&gt;&gt;&gt;&gt;                }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                subscript(key: Key) -&gt; Value {<br>&gt;&gt;&gt;&gt;                        get { return dictionary[key]! }<br>&gt;&gt;&gt;&gt;                        set { dictionary[key] = newValue }<br>&gt;&gt;&gt;&gt;                }<br>&gt;&gt;&gt;&gt;        }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; What I would do is borrow the &quot;accessors&quot; concept from the property behaviors proposal and extend it so that it supported both functions and variables.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Wouldn&#39;t accessor just be a redundant keyword here? Currently enums do<br>&gt;&gt;&gt;&gt;&gt; not support stored properties, so I guess there is no extra need to<br>&gt;&gt;&gt;&gt;&gt; mark properties with any special keyword.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The keyword is mainly to indicate the unusual syntax at the definition site, where you only have to specify the name of the accessor you&#39;re defining, not a `func` or `var` keyword, a return type, or even parameter names. (Like `willSet`, there&#39;s a default parameter name you can use.) Secondarily, though, I think it&#39;s helpful to indicate very explicitly that this is not an ordinary method or property definition, even if the compiler could perhaps sort things out without it. `accessor` is something a user can Google if they&#39;ve never seen it before.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Property accessors might work for enums with associated values, but<br>&gt;&gt;&gt;&gt;&gt; not so well without them.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The two have nothing to do with each other. I showed your planets example, which has no associated values but uses accessors just fine.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>June  1, 2016 at 10:00:00am</p></header><div class="content"><p>One thing I did often in Java (and miss in Swift) is using their enums to build state machines or implement command patterns for common commands.<br></p><p>Java enums are a sealed set of subclasses of the enum base type with (hopefully) immutable, singleton instances. So you can do fun things like:<br>- Define the base class constructor to be called to instantiate the subclasses, and declare the cases with the constructor arguments<br>- Declare a method on the base type and refine it on 1-2 particular cases<br>- Declare the enum implements an interface, and implement that interface separately for each case.<br>- Define data accessors specific to the type (such as the planets example above)<br></p><p>I like the SuitInfo approach below - with extensions, I think I can get close to what I have done in the past with Java. Maybe one day there is syntax to do this in the language directly<br></p><p>-DW<br></p><p>&gt; On May 31, 2016, at 11:44 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m not sure about my opinion on this proposal, but I believe you should add this as alternatives of how we can have the similar features today without injecting stored properties into enums  :<br>&gt; <br>&gt; enum Suit {<br>&gt;    case spades<br>&gt;    case hearts<br>&gt;    case diamonds<br>&gt;    case clubs<br>&gt; <br>&gt;    struct SuitInfo {<br>&gt;        let simpleDescription: String<br>&gt;        let color: UIColor<br>&gt;        let symbol: String<br>&gt;        let bezierPath: UIBezierPath<br>&gt;    }<br>&gt; <br>&gt;    var info : SuitInfo {<br>&gt;        switch self {<br>&gt;        case .spades:<br>&gt;            let path = UIBezierPath()<br>&gt;            // omitted lines ...<br>&gt; <br>&gt;            return SuitInfo(<br>&gt;                simpleDescription: &quot;spades&quot;,<br>&gt;                color: .blackColor(),<br>&gt;                symbol: &quot;♠&quot;,<br>&gt;                bezierPath: path)<br>&gt; <br>&gt;        case .hearts:<br>&gt;            let path = UIBezierPath()<br>&gt;            // omitted lines ...<br>&gt; <br>&gt;            return SuitInfo(<br>&gt;                simpleDescription: &quot;hearts&quot;,<br>&gt;                color: .redColor(),<br>&gt;                symbol: &quot;♥&quot;,<br>&gt;                bezierPath: path)<br>&gt; <br>&gt;        case .diamonds:<br>&gt;            let path = UIBezierPath()<br>&gt;            // omitted lines ...<br>&gt; <br>&gt;            return SuitInfo(<br>&gt;                simpleDescription: &quot;diamonds&quot;,<br>&gt;                color: .redColor(),<br>&gt;                symbol: &quot;♦&quot;,<br>&gt;                bezierPath: path)<br>&gt; <br>&gt;        case .clubs:<br>&gt;            let path = UIBezierPath()<br>&gt;            // omitted lines ...<br>&gt; <br>&gt;            return SuitInfo(<br>&gt;                simpleDescription: &quot;clubs&quot;,<br>&gt;                color: .blackColor(),<br>&gt;                symbol: &quot;♣&quot;,<br>&gt;                bezierPath: path)<br>&gt; <br>&gt;        }<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; and this:<br>&gt; <br>&gt; enum Suit  {<br>&gt;    case spades<br>&gt;    case hearts<br>&gt;    case diamonds<br>&gt;    case clubs<br>&gt; <br>&gt;    struct SuitInfo  {<br>&gt;        let simpleDescription: String<br>&gt;        let color: UIColor<br>&gt;        let symbol: String<br>&gt;        let bezierPath: UIBezierPath<br>&gt;    }<br>&gt; <br>&gt;    static let spadesInfo : SuitInfo = {<br>&gt;        let path = UIBezierPath()<br>&gt;        // omitted lines ...<br>&gt; <br>&gt;        return SuitInfo(<br>&gt;            simpleDescription: &quot;spades&quot;,<br>&gt;            color: .blackColor(),<br>&gt;            symbol: &quot;♠&quot;,<br>&gt;            bezierPath: path)<br>&gt;    }()<br>&gt; <br>&gt;    static let heartsInfo : SuitInfo = {<br>&gt;        let path = UIBezierPath()<br>&gt;        // omitted lines ...<br>&gt; <br>&gt;        return SuitInfo(<br>&gt;            simpleDescription: &quot;hearts&quot;,<br>&gt;            color: .redColor(),<br>&gt;            symbol: &quot;♥&quot;,<br>&gt;            bezierPath: path)<br>&gt;    }()<br>&gt; <br>&gt;    static let diamondsInfo : SuitInfo = {<br>&gt;        let path = UIBezierPath()<br>&gt;        // omitted lines ...<br>&gt; <br>&gt;        return SuitInfo(<br>&gt;            simpleDescription: &quot;diamonds&quot;,<br>&gt;            color: .redColor(),<br>&gt;            symbol: &quot;♦&quot;,<br>&gt;            bezierPath: path)<br>&gt;    }()<br>&gt; <br>&gt;    static let clubsInfo : SuitInfo = {<br>&gt;        let path = UIBezierPath()<br>&gt;        // omitted lines ...<br>&gt; <br>&gt;        return SuitInfo(<br>&gt;            simpleDescription: &quot;clubs&quot;,<br>&gt;            color: .blackColor(),<br>&gt;            symbol: &quot;♣&quot;,<br>&gt;            bezierPath: path)<br>&gt;    }()<br>&gt; <br>&gt; <br>&gt;    var info : SuitInfo {<br>&gt;        switch self {<br>&gt;            case .spades: return Suit.spadesInfo<br>&gt;            case .hearts: return Suit.heartsInfo<br>&gt;            case .diamonds: return Suit.diamondsInfo<br>&gt;            case .clubs: return Suit.clubsInfo<br>&gt;        }<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; On 31.05.2016 17:17, Jānis Kiršteins via swift-evolution wrote:<br>&gt;&gt; I wrote a proposal draft:<br>&gt;&gt; <br>&gt;&gt; # Enum case stored properties<br>&gt;&gt; <br>&gt;&gt; * Proposal: TBD<br>&gt;&gt; * Author: [Janis Kirsteins](https://github.com/kirsteins)<br>&gt;&gt; * Status: TBD<br>&gt;&gt; * Review manager: TBD<br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal allows each enum case to have stored properties.<br>&gt;&gt; <br>&gt;&gt; ## Motivation<br>&gt;&gt; <br>&gt;&gt; Enums cases can have a lot of constant (or variable) static values<br>&gt;&gt; associated with it. For example, planets can have mass, radius, age,<br>&gt;&gt; closest star etc. Currently there is no way to set or get those values<br>&gt;&gt; easily.<br>&gt;&gt; <br>&gt;&gt; Example below shows that is hard to read and manage static associated<br>&gt;&gt; values with each case. It is hard to add or remove case as it would<br>&gt;&gt; require to add or remove code in four different places in file. Also<br>&gt;&gt; static associated value like `UIBezierPath` is recreated each time the<br>&gt;&gt; property is computed while it&#39;s constant.<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; enum Suit {<br>&gt;&gt;    case spades<br>&gt;&gt;    case hearts<br>&gt;&gt;    case diamonds<br>&gt;&gt;    case clubs<br>&gt;&gt; <br>&gt;&gt;    var simpleDescription: String {<br>&gt;&gt;        switch self {<br>&gt;&gt;        case .spades:<br>&gt;&gt;            return &quot;spades&quot;<br>&gt;&gt;        case .hearts:<br>&gt;&gt;            return &quot;hearts&quot;<br>&gt;&gt;        case .diamonds:<br>&gt;&gt;            return &quot;diamonds&quot;<br>&gt;&gt;        case .clubs:<br>&gt;&gt;            return &quot;clubs&quot;<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    var color: UIColor {<br>&gt;&gt;        switch self {<br>&gt;&gt;        case .spades:<br>&gt;&gt;            return .blackColor()<br>&gt;&gt;        case .hearts:<br>&gt;&gt;            return .redColor()<br>&gt;&gt;        case .diamonds:<br>&gt;&gt;            return .redColor()<br>&gt;&gt;        case .clubs:<br>&gt;&gt;            return .blackColor()<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    var symbol: String {<br>&gt;&gt;        switch self {<br>&gt;&gt;        case .spades:<br>&gt;&gt;            return &quot;♠&quot;<br>&gt;&gt;        case .hearts:<br>&gt;&gt;            return &quot;♥&quot;<br>&gt;&gt;        case .diamonds:<br>&gt;&gt;            return &quot;♦&quot;<br>&gt;&gt;        case .clubs:<br>&gt;&gt;            return &quot;♣&quot;<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    var bezierPath: UIBezierPath {<br>&gt;&gt;        switch self {<br>&gt;&gt;        case .spades:<br>&gt;&gt;            let path = UIBezierPath()<br>&gt;&gt;            // omitted lines ...<br>&gt;&gt;            return path<br>&gt;&gt;        case .hearts:<br>&gt;&gt;            let path = UIBezierPath()<br>&gt;&gt;            // omitted lines ...<br>&gt;&gt;            return path<br>&gt;&gt;        case .diamonds:<br>&gt;&gt;            let path = UIBezierPath()<br>&gt;&gt;            // omitted lines ...<br>&gt;&gt;            return path<br>&gt;&gt;        case .clubs:<br>&gt;&gt;            let path = UIBezierPath()<br>&gt;&gt;            // omitted lines ...<br>&gt;&gt;            return path<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; ## Proposed solution<br>&gt;&gt; <br>&gt;&gt; Support stored properties for enum cases just as each case were an<br>&gt;&gt; instance. Case properties are initialized block after each case<br>&gt;&gt; declaration.<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; enum Suit {<br>&gt;&gt;    let simpleDescription: String<br>&gt;&gt;    let color: UIColor<br>&gt;&gt;    let symbol: String<br>&gt;&gt;    let bezierPath: UIBezierPath<br>&gt;&gt; <br>&gt;&gt;    case spades {<br>&gt;&gt;        simpleDescription = &quot;spades&quot;<br>&gt;&gt;        color = .blackColor()<br>&gt;&gt;        symbol = &quot;♠&quot;<br>&gt;&gt;        let bezierPath = UIBezierPath()<br>&gt;&gt;        // omitted lines ...<br>&gt;&gt;        self.bezierPath = bezierPath<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    case hearts {<br>&gt;&gt;        simpleDescription = &quot;hearts&quot;<br>&gt;&gt;        color = .redColor()<br>&gt;&gt;        symbol = &quot;♥&quot;<br>&gt;&gt;        let bezierPath = UIBezierPath()<br>&gt;&gt;        // omitted lines ...<br>&gt;&gt;        self.bezierPath = bezierPath<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    case diamonds {<br>&gt;&gt;        simpleDescription = &quot;diamonds&quot;<br>&gt;&gt;        color = .redColor()<br>&gt;&gt;        symbol = &quot;♦&quot;<br>&gt;&gt;        let bezierPath = UIBezierPath()<br>&gt;&gt;        // omitted lines ...<br>&gt;&gt;        self.bezierPath = bezierPath<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    case clubs {<br>&gt;&gt;        simpleDescription = &quot;clubs&quot;<br>&gt;&gt;        color = .blackColor()<br>&gt;&gt;        symbol = &quot;♣&quot;<br>&gt;&gt;        let bezierPath = UIBezierPath()<br>&gt;&gt;        // omitted lines ...<br>&gt;&gt;        self.bezierPath = bezierPath<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let symbol = Suit.spades.symbol // &quot;♠&quot;<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; The proposed solution improves:<br>&gt;&gt; - Readability as cases are closer with their related data;<br>&gt;&gt; - Improves code maintainability as a case can be removed or added in one place;<br>&gt;&gt; - Improved performance as there is no need to recreate static values;<br>&gt;&gt; - ~30% less lines of code in given example.<br>&gt;&gt; <br>&gt;&gt; ## Detailed design<br>&gt;&gt; <br>&gt;&gt; #### Stored properties<br>&gt;&gt; <br>&gt;&gt; Enum stored properties are supported the same way they are supported<br>&gt;&gt; for structs can classes. Unlike enum associated values, stored<br>&gt;&gt; properties are static to case and are shared for the same case.<br>&gt;&gt; <br>&gt;&gt; Properties are accessed:<br>&gt;&gt; ```swift<br>&gt;&gt; let simpleDescription = Suit.spades.simpleDescription<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Mutable properties can be set:<br>&gt;&gt; ```swift<br>&gt;&gt; Suit.spades.simpleDescription = &quot;new simple description&quot;<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; #### Initialization<br>&gt;&gt; <br>&gt;&gt; If enum has uninitialized stored property it must be initialized in a<br>&gt;&gt; block after each case declaration. The block work the same way as<br>&gt;&gt; struct initialization. At the end of initialization block all<br>&gt;&gt; properties must be initialized.<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; enum Suit {<br>&gt;&gt;    var simpleDescription: String<br>&gt;&gt; <br>&gt;&gt;    case spades {<br>&gt;&gt;        simpleDescription = &quot;spades&quot;<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Initialization block can be combine with use of `rawValue`:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; enum Suit: Int {<br>&gt;&gt;    var simpleDescription: String<br>&gt;&gt; <br>&gt;&gt;    case spades = 1 {<br>&gt;&gt;        simpleDescription = &quot;spades&quot;<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; or associated values of the case:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; enum Suit {<br>&gt;&gt;    var simpleDescription: String<br>&gt;&gt; <br>&gt;&gt;    case spades(Int) {<br>&gt;&gt;        simpleDescription = &quot;spades&quot;<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; ## Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Stored properties for enums are not currently not supported, so there<br>&gt;&gt; is no impact on existing code.<br>&gt;&gt; <br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; <br>&gt;&gt; - Use labeled tuple as `rawValue` of the enum case. This approach is<br>&gt;&gt; not compatible as it conflicts with intention of `rawValue` of Swift<br>&gt;&gt; enum;<br>&gt;&gt; - Use per case initializer like [Java<br>&gt;&gt; Enum](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html).<br>&gt;&gt; Swift enum uses custom initializer syntax to setup instances, not<br>&gt;&gt; cases. So this approach is not suitable for Swift.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sun, May 29, 2016 at 3:42 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt;&gt; I think that&#39;s the case with enums. You&#39;re changing their current behaviour of only having stored values to one in which it&#39;s computed (even if only once and then stored). Enums are IMO something that have a static value you know beforehand and can count on. That&#39;s why I&#39;m not fond of the accessor proposal. Otherwise I think we&#39;re transforming enums into a closed set of struct instances and one could do that already by using a private init.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 29 May 2016, at 3:38 am, Jānis Kiršteins via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with the argument about use of &quot;where&quot;, not replacing the raw<br>&gt;&gt;&gt;&gt; value and having some kind of initialization block. But I cannot see<br>&gt;&gt;&gt;&gt; why &quot;accessors&quot; concept is any better than stored properties to solve<br>&gt;&gt;&gt;&gt; the particular problem. The &quot;accessors&quot; concept has much wider scope<br>&gt;&gt;&gt;&gt; than enums and is a separate proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, May 28, 2016 at 11:39 PM, Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Abusing rawValue is just that: an abuse.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; My original proposal does not replace rawValue and is compatible with it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; `rawValue` has a different purpose from how you&#39;re using it. It&#39;s supposed to allow you to convert your type to some other *equivalent* type, like an equivalent integer or string. Moreover, it&#39;s supposed to allow you to *reconstruct* the instance from the raw value—remember, `RawRepresentable` has an `init(rawValue:)` requirement.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It is *not* supposed to be an ancillary bag of information on the side. You&#39;re cramming a square peg into a round hole here.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (Also, if you use `rawValue` for an ancillary bag of information, that means you *can&#39;t* use it on the same type for its intended purpose. For instance, you would not be able to assign numbers to your Planet enum&#39;s cases to help you serialize them or bridge them to Objective-C. That&#39;s not good.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Using `where` just doesn&#39;t match the use of `where` elsewhere in the language; everywhere else, it&#39;s some kind of condition.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It is also used in generic type constraints. Plus it reads like human<br>&gt;&gt;&gt;&gt;&gt;&gt; language: `case mercury where (mass: 3.303e+23, radius: 2.4397e6)`<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But a generic constraint is also a type of condition: it specifies types which are permitted and divides them from types that are not.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is *not* a condition. It&#39;s not anything like a condition. It&#39;s simply not consistent with anything else in the language.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Dictionaries are the most straightforward way to handle this with the current language, but their lack of exhaustiveness checking is a problem.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Dictionaries can be used as workaround, but they cannot (lack of<br>&gt;&gt;&gt;&gt;&gt;&gt; exhaustiveness) solve the problem.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree that they&#39;re a halfway solution.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If `ValuesEnumerable` were to be accepted (and to have a generic requirement for its `allValues` property), you could write a Dictionary-like type which ensured at initialization time that it was exhaustive. That&#39;s not as good as compile time, but it&#39;s not bad—sort of a three-quarters solution.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;       struct ExhaustiveDictionary&lt;Key: Hashable, Value where Key: ValuesEnumerable&gt;: Collection, DictionaryLiteralConvertible {<br>&gt;&gt;&gt;&gt;&gt;               private var dictionary: [Key: Value]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;               init(dictionaryLiteral elements: (Key, Value)...) {<br>&gt;&gt;&gt;&gt;&gt;                       dictionary = [:]<br>&gt;&gt;&gt;&gt;&gt;                       for (k, v) in elements {<br>&gt;&gt;&gt;&gt;&gt;                               dictionary[k] = v<br>&gt;&gt;&gt;&gt;&gt;                       }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;                       if dictionary.count != Key.allValues.count {<br>&gt;&gt;&gt;&gt;&gt;                               let missingKeys = Key.allValues.filter { dictionary[$0] == nil }<br>&gt;&gt;&gt;&gt;&gt;                               preconditionFailure(&quot;ExhaustiveDictionary is missing elements from \(Key.self): \(missingKeys)&quot;)<br>&gt;&gt;&gt;&gt;&gt;                       }<br>&gt;&gt;&gt;&gt;&gt;               }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;               var startIndex: Dictionary.Index {<br>&gt;&gt;&gt;&gt;&gt;                       return dictionary.startIndex<br>&gt;&gt;&gt;&gt;&gt;               }<br>&gt;&gt;&gt;&gt;&gt;               var endIndex: Dictionary.Index {<br>&gt;&gt;&gt;&gt;&gt;                       return dictionary.endIndex<br>&gt;&gt;&gt;&gt;&gt;               }<br>&gt;&gt;&gt;&gt;&gt;               subscript(index: Dictionary.Index) -&gt; (Key, Value) {<br>&gt;&gt;&gt;&gt;&gt;                       return dictionary[index]<br>&gt;&gt;&gt;&gt;&gt;               }<br>&gt;&gt;&gt;&gt;&gt;               func index(after i: Dictionary.Index) -&gt; Dictionary.Index {<br>&gt;&gt;&gt;&gt;&gt;                       return dictionary.index(after: i)<br>&gt;&gt;&gt;&gt;&gt;               }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;               subscript(key: Key) -&gt; Value {<br>&gt;&gt;&gt;&gt;&gt;                       get { return dictionary[key]! }<br>&gt;&gt;&gt;&gt;&gt;                       set { dictionary[key] = newValue }<br>&gt;&gt;&gt;&gt;&gt;               }<br>&gt;&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What I would do is borrow the &quot;accessors&quot; concept from the property behaviors proposal and extend it so that it supported both functions and variables.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Wouldn&#39;t accessor just be a redundant keyword here? Currently enums do<br>&gt;&gt;&gt;&gt;&gt;&gt; not support stored properties, so I guess there is no extra need to<br>&gt;&gt;&gt;&gt;&gt;&gt; mark properties with any special keyword.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The keyword is mainly to indicate the unusual syntax at the definition site, where you only have to specify the name of the accessor you&#39;re defining, not a `func` or `var` keyword, a return type, or even parameter names. (Like `willSet`, there&#39;s a default parameter name you can use.) Secondarily, though, I think it&#39;s helpful to indicate very explicitly that this is not an ordinary method or property definition, even if the compiler could perhaps sort things out without it. `accessor` is something a user can Google if they&#39;ve never seen it before.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Property accessors might work for enums with associated values, but<br>&gt;&gt;&gt;&gt;&gt;&gt; not so well without them.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The two have nothing to do with each other. I showed your planets example, which has no associated values but uses accessors just fine.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/3ce76be7/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  1, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 1, 2016, at 9:48 AM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One thing I did often in Java (and miss in Swift) is using their enums to build state machines or implement command patterns for common commands.<br>&gt; <br>&gt; Java enums are a sealed set of subclasses of the enum base type with (hopefully) immutable, singleton instances. So you can do fun things like:<br>&gt; - Define the base class constructor to be called to instantiate the subclasses, and declare the cases with the constructor arguments<br>&gt; - Declare a method on the base type and refine it on 1-2 particular cases<br>&gt; - Declare the enum implements an interface, and implement that interface separately for each case.<br>&gt; - Define data accessors specific to the type (such as the planets example above)<br>&gt; <br>&gt; I like the SuitInfo approach below - with extensions, I think I can get close to what I have done in the past with Java. Maybe one day there is syntax to do this in the language directly<br></p><p>This is pretty similar to what we were discussing last week in this thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160523/018799.html<br></p><p>I&#39;m planning to write up a proposal when I have time (hopefully in the next week or so).<br></p><p>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On May 31, 2016, at 11:44 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure about my opinion on this proposal, but I believe you should add this as alternatives of how we can have the similar features today without injecting stored properties into enums  :<br>&gt;&gt; <br>&gt;&gt; enum Suit {<br>&gt;&gt;   case spades<br>&gt;&gt;   case hearts<br>&gt;&gt;   case diamonds<br>&gt;&gt;   case clubs<br>&gt;&gt; <br>&gt;&gt;   struct SuitInfo {<br>&gt;&gt;       let simpleDescription: String<br>&gt;&gt;       let color: UIColor<br>&gt;&gt;       let symbol: String<br>&gt;&gt;       let bezierPath: UIBezierPath<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   var info : SuitInfo {<br>&gt;&gt;       switch self {<br>&gt;&gt;       case .spades:<br>&gt;&gt;           let path = UIBezierPath()<br>&gt;&gt;           // omitted lines ...<br>&gt;&gt; <br>&gt;&gt;           return SuitInfo(<br>&gt;&gt;               simpleDescription: &quot;spades&quot;,<br>&gt;&gt;               color: .blackColor(),<br>&gt;&gt;               symbol: &quot;♠&quot;,<br>&gt;&gt;               bezierPath: path)<br>&gt;&gt; <br>&gt;&gt;       case .hearts:<br>&gt;&gt;           let path = UIBezierPath()<br>&gt;&gt;           // omitted lines ...<br>&gt;&gt; <br>&gt;&gt;           return SuitInfo(<br>&gt;&gt;               simpleDescription: &quot;hearts&quot;,<br>&gt;&gt;               color: .redColor(),<br>&gt;&gt;               symbol: &quot;♥&quot;,<br>&gt;&gt;               bezierPath: path)<br>&gt;&gt; <br>&gt;&gt;       case .diamonds:<br>&gt;&gt;           let path = UIBezierPath()<br>&gt;&gt;           // omitted lines ...<br>&gt;&gt; <br>&gt;&gt;           return SuitInfo(<br>&gt;&gt;               simpleDescription: &quot;diamonds&quot;,<br>&gt;&gt;               color: .redColor(),<br>&gt;&gt;               symbol: &quot;♦&quot;,<br>&gt;&gt;               bezierPath: path)<br>&gt;&gt; <br>&gt;&gt;       case .clubs:<br>&gt;&gt;           let path = UIBezierPath()<br>&gt;&gt;           // omitted lines ...<br>&gt;&gt; <br>&gt;&gt;           return SuitInfo(<br>&gt;&gt;               simpleDescription: &quot;clubs&quot;,<br>&gt;&gt;               color: .blackColor(),<br>&gt;&gt;               symbol: &quot;♣&quot;,<br>&gt;&gt;               bezierPath: path)<br>&gt;&gt; <br>&gt;&gt;       }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; and this:<br>&gt;&gt; <br>&gt;&gt; enum Suit  {<br>&gt;&gt;   case spades<br>&gt;&gt;   case hearts<br>&gt;&gt;   case diamonds<br>&gt;&gt;   case clubs<br>&gt;&gt; <br>&gt;&gt;   struct SuitInfo  {<br>&gt;&gt;       let simpleDescription: String<br>&gt;&gt;       let color: UIColor<br>&gt;&gt;       let symbol: String<br>&gt;&gt;       let bezierPath: UIBezierPath<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   static let spadesInfo : SuitInfo = {<br>&gt;&gt;       let path = UIBezierPath()<br>&gt;&gt;       // omitted lines ...<br>&gt;&gt; <br>&gt;&gt;       return SuitInfo(<br>&gt;&gt;           simpleDescription: &quot;spades&quot;,<br>&gt;&gt;           color: .blackColor(),<br>&gt;&gt;           symbol: &quot;♠&quot;,<br>&gt;&gt;           bezierPath: path)<br>&gt;&gt;   }()<br>&gt;&gt; <br>&gt;&gt;   static let heartsInfo : SuitInfo = {<br>&gt;&gt;       let path = UIBezierPath()<br>&gt;&gt;       // omitted lines ...<br>&gt;&gt; <br>&gt;&gt;       return SuitInfo(<br>&gt;&gt;           simpleDescription: &quot;hearts&quot;,<br>&gt;&gt;           color: .redColor(),<br>&gt;&gt;           symbol: &quot;♥&quot;,<br>&gt;&gt;           bezierPath: path)<br>&gt;&gt;   }()<br>&gt;&gt; <br>&gt;&gt;   static let diamondsInfo : SuitInfo = {<br>&gt;&gt;       let path = UIBezierPath()<br>&gt;&gt;       // omitted lines ...<br>&gt;&gt; <br>&gt;&gt;       return SuitInfo(<br>&gt;&gt;           simpleDescription: &quot;diamonds&quot;,<br>&gt;&gt;           color: .redColor(),<br>&gt;&gt;           symbol: &quot;♦&quot;,<br>&gt;&gt;           bezierPath: path)<br>&gt;&gt;   }()<br>&gt;&gt; <br>&gt;&gt;   static let clubsInfo : SuitInfo = {<br>&gt;&gt;       let path = UIBezierPath()<br>&gt;&gt;       // omitted lines ...<br>&gt;&gt; <br>&gt;&gt;       return SuitInfo(<br>&gt;&gt;           simpleDescription: &quot;clubs&quot;,<br>&gt;&gt;           color: .blackColor(),<br>&gt;&gt;           symbol: &quot;♣&quot;,<br>&gt;&gt;           bezierPath: path)<br>&gt;&gt;   }()<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;   var info : SuitInfo {<br>&gt;&gt;       switch self {<br>&gt;&gt;           case .spades: return Suit.spadesInfo<br>&gt;&gt;           case .hearts: return Suit.heartsInfo<br>&gt;&gt;           case .diamonds: return Suit.diamondsInfo<br>&gt;&gt;           case .clubs: return Suit.clubsInfo<br>&gt;&gt;       }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 31.05.2016 17:17, Jānis Kiršteins via swift-evolution wrote:<br>&gt;&gt;&gt; I wrote a proposal draft:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Enum case stored properties<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Proposal: TBD<br>&gt;&gt;&gt; * Author: [Janis Kirsteins](https://github.com/kirsteins)<br>&gt;&gt;&gt; * Status: TBD<br>&gt;&gt;&gt; * Review manager: TBD<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal allows each enum case to have stored properties.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Enums cases can have a lot of constant (or variable) static values<br>&gt;&gt;&gt; associated with it. For example, planets can have mass, radius, age,<br>&gt;&gt;&gt; closest star etc. Currently there is no way to set or get those values<br>&gt;&gt;&gt; easily.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example below shows that is hard to read and manage static associated<br>&gt;&gt;&gt; values with each case. It is hard to add or remove case as it would<br>&gt;&gt;&gt; require to add or remove code in four different places in file. Also<br>&gt;&gt;&gt; static associated value like `UIBezierPath` is recreated each time the<br>&gt;&gt;&gt; property is computed while it&#39;s constant.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; enum Suit {<br>&gt;&gt;&gt;   case spades<br>&gt;&gt;&gt;   case hearts<br>&gt;&gt;&gt;   case diamonds<br>&gt;&gt;&gt;   case clubs<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   var simpleDescription: String {<br>&gt;&gt;&gt;       switch self {<br>&gt;&gt;&gt;       case .spades:<br>&gt;&gt;&gt;           return &quot;spades&quot;<br>&gt;&gt;&gt;       case .hearts:<br>&gt;&gt;&gt;           return &quot;hearts&quot;<br>&gt;&gt;&gt;       case .diamonds:<br>&gt;&gt;&gt;           return &quot;diamonds&quot;<br>&gt;&gt;&gt;       case .clubs:<br>&gt;&gt;&gt;           return &quot;clubs&quot;<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   var color: UIColor {<br>&gt;&gt;&gt;       switch self {<br>&gt;&gt;&gt;       case .spades:<br>&gt;&gt;&gt;           return .blackColor()<br>&gt;&gt;&gt;       case .hearts:<br>&gt;&gt;&gt;           return .redColor()<br>&gt;&gt;&gt;       case .diamonds:<br>&gt;&gt;&gt;           return .redColor()<br>&gt;&gt;&gt;       case .clubs:<br>&gt;&gt;&gt;           return .blackColor()<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   var symbol: String {<br>&gt;&gt;&gt;       switch self {<br>&gt;&gt;&gt;       case .spades:<br>&gt;&gt;&gt;           return &quot;♠&quot;<br>&gt;&gt;&gt;       case .hearts:<br>&gt;&gt;&gt;           return &quot;♥&quot;<br>&gt;&gt;&gt;       case .diamonds:<br>&gt;&gt;&gt;           return &quot;♦&quot;<br>&gt;&gt;&gt;       case .clubs:<br>&gt;&gt;&gt;           return &quot;♣&quot;<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   var bezierPath: UIBezierPath {<br>&gt;&gt;&gt;       switch self {<br>&gt;&gt;&gt;       case .spades:<br>&gt;&gt;&gt;           let path = UIBezierPath()<br>&gt;&gt;&gt;           // omitted lines ...<br>&gt;&gt;&gt;           return path<br>&gt;&gt;&gt;       case .hearts:<br>&gt;&gt;&gt;           let path = UIBezierPath()<br>&gt;&gt;&gt;           // omitted lines ...<br>&gt;&gt;&gt;           return path<br>&gt;&gt;&gt;       case .diamonds:<br>&gt;&gt;&gt;           let path = UIBezierPath()<br>&gt;&gt;&gt;           // omitted lines ...<br>&gt;&gt;&gt;           return path<br>&gt;&gt;&gt;       case .clubs:<br>&gt;&gt;&gt;           let path = UIBezierPath()<br>&gt;&gt;&gt;           // omitted lines ...<br>&gt;&gt;&gt;           return path<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Support stored properties for enum cases just as each case were an<br>&gt;&gt;&gt; instance. Case properties are initialized block after each case<br>&gt;&gt;&gt; declaration.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; enum Suit {<br>&gt;&gt;&gt;   let simpleDescription: String<br>&gt;&gt;&gt;   let color: UIColor<br>&gt;&gt;&gt;   let symbol: String<br>&gt;&gt;&gt;   let bezierPath: UIBezierPath<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   case spades {<br>&gt;&gt;&gt;       simpleDescription = &quot;spades&quot;<br>&gt;&gt;&gt;       color = .blackColor()<br>&gt;&gt;&gt;       symbol = &quot;♠&quot;<br>&gt;&gt;&gt;       let bezierPath = UIBezierPath()<br>&gt;&gt;&gt;       // omitted lines ...<br>&gt;&gt;&gt;       self.bezierPath = bezierPath<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   case hearts {<br>&gt;&gt;&gt;       simpleDescription = &quot;hearts&quot;<br>&gt;&gt;&gt;       color = .redColor()<br>&gt;&gt;&gt;       symbol = &quot;♥&quot;<br>&gt;&gt;&gt;       let bezierPath = UIBezierPath()<br>&gt;&gt;&gt;       // omitted lines ...<br>&gt;&gt;&gt;       self.bezierPath = bezierPath<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   case diamonds {<br>&gt;&gt;&gt;       simpleDescription = &quot;diamonds&quot;<br>&gt;&gt;&gt;       color = .redColor()<br>&gt;&gt;&gt;       symbol = &quot;♦&quot;<br>&gt;&gt;&gt;       let bezierPath = UIBezierPath()<br>&gt;&gt;&gt;       // omitted lines ...<br>&gt;&gt;&gt;       self.bezierPath = bezierPath<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   case clubs {<br>&gt;&gt;&gt;       simpleDescription = &quot;clubs&quot;<br>&gt;&gt;&gt;       color = .blackColor()<br>&gt;&gt;&gt;       symbol = &quot;♣&quot;<br>&gt;&gt;&gt;       let bezierPath = UIBezierPath()<br>&gt;&gt;&gt;       // omitted lines ...<br>&gt;&gt;&gt;       self.bezierPath = bezierPath<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let symbol = Suit.spades.symbol // &quot;♠&quot;<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposed solution improves:<br>&gt;&gt;&gt; - Readability as cases are closer with their related data;<br>&gt;&gt;&gt; - Improves code maintainability as a case can be removed or added in one place;<br>&gt;&gt;&gt; - Improved performance as there is no need to recreate static values;<br>&gt;&gt;&gt; - ~30% less lines of code in given example.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #### Stored properties<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Enum stored properties are supported the same way they are supported<br>&gt;&gt;&gt; for structs can classes. Unlike enum associated values, stored<br>&gt;&gt;&gt; properties are static to case and are shared for the same case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Properties are accessed:<br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; let simpleDescription = Suit.spades.simpleDescription<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Mutable properties can be set:<br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; Suit.spades.simpleDescription = &quot;new simple description&quot;<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #### Initialization<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If enum has uninitialized stored property it must be initialized in a<br>&gt;&gt;&gt; block after each case declaration. The block work the same way as<br>&gt;&gt;&gt; struct initialization. At the end of initialization block all<br>&gt;&gt;&gt; properties must be initialized.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; enum Suit {<br>&gt;&gt;&gt;   var simpleDescription: String<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   case spades {<br>&gt;&gt;&gt;       simpleDescription = &quot;spades&quot;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Initialization block can be combine with use of `rawValue`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; enum Suit: Int {<br>&gt;&gt;&gt;   var simpleDescription: String<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   case spades = 1 {<br>&gt;&gt;&gt;       simpleDescription = &quot;spades&quot;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; or associated values of the case:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; enum Suit {<br>&gt;&gt;&gt;   var simpleDescription: String<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   case spades(Int) {<br>&gt;&gt;&gt;       simpleDescription = &quot;spades&quot;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Stored properties for enums are not currently not supported, so there<br>&gt;&gt;&gt; is no impact on existing code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Use labeled tuple as `rawValue` of the enum case. This approach is<br>&gt;&gt;&gt; not compatible as it conflicts with intention of `rawValue` of Swift<br>&gt;&gt;&gt; enum;<br>&gt;&gt;&gt; - Use per case initializer like [Java<br>&gt;&gt;&gt; Enum](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html).<br>&gt;&gt;&gt; Swift enum uses custom initializer syntax to setup instances, not<br>&gt;&gt;&gt; cases. So this approach is not suitable for Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sun, May 29, 2016 at 3:42 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt;&gt;&gt; I think that&#39;s the case with enums. You&#39;re changing their current behaviour of only having stored values to one in which it&#39;s computed (even if only once and then stored). Enums are IMO something that have a static value you know beforehand and can count on. That&#39;s why I&#39;m not fond of the accessor proposal. Otherwise I think we&#39;re transforming enums into a closed set of struct instances and one could do that already by using a private init.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 29 May 2016, at 3:38 am, Jānis Kiršteins via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree with the argument about use of &quot;where&quot;, not replacing the raw<br>&gt;&gt;&gt;&gt;&gt; value and having some kind of initialization block. But I cannot see<br>&gt;&gt;&gt;&gt;&gt; why &quot;accessors&quot; concept is any better than stored properties to solve<br>&gt;&gt;&gt;&gt;&gt; the particular problem. The &quot;accessors&quot; concept has much wider scope<br>&gt;&gt;&gt;&gt;&gt; than enums and is a separate proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sat, May 28, 2016 at 11:39 PM, Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt; &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Abusing rawValue is just that: an abuse.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; My original proposal does not replace rawValue and is compatible with it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; `rawValue` has a different purpose from how you&#39;re using it. It&#39;s supposed to allow you to convert your type to some other *equivalent* type, like an equivalent integer or string. Moreover, it&#39;s supposed to allow you to *reconstruct* the instance from the raw value—remember, `RawRepresentable` has an `init(rawValue:)` requirement.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It is *not* supposed to be an ancillary bag of information on the side. You&#39;re cramming a square peg into a round hole here.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; (Also, if you use `rawValue` for an ancillary bag of information, that means you *can&#39;t* use it on the same type for its intended purpose. For instance, you would not be able to assign numbers to your Planet enum&#39;s cases to help you serialize them or bridge them to Objective-C. That&#39;s not good.)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Using `where` just doesn&#39;t match the use of `where` elsewhere in the language; everywhere else, it&#39;s some kind of condition.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is also used in generic type constraints. Plus it reads like human<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; language: `case mercury where (mass: 3.303e+23, radius: 2.4397e6)`<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; But a generic constraint is also a type of condition: it specifies types which are permitted and divides them from types that are not.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is *not* a condition. It&#39;s not anything like a condition. It&#39;s simply not consistent with anything else in the language.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Dictionaries are the most straightforward way to handle this with the current language, but their lack of exhaustiveness checking is a problem.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dictionaries can be used as workaround, but they cannot (lack of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; exhaustiveness) solve the problem.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I agree that they&#39;re a halfway solution.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If `ValuesEnumerable` were to be accepted (and to have a generic requirement for its `allValues` property), you could write a Dictionary-like type which ensured at initialization time that it was exhaustive. That&#39;s not as good as compile time, but it&#39;s not bad—sort of a three-quarters solution.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;      struct ExhaustiveDictionary&lt;Key: Hashable, Value where Key: ValuesEnumerable&gt;: Collection, DictionaryLiteralConvertible {<br>&gt;&gt;&gt;&gt;&gt;&gt;              private var dictionary: [Key: Value]<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;              init(dictionaryLiteral elements: (Key, Value)...) {<br>&gt;&gt;&gt;&gt;&gt;&gt;                      dictionary = [:]<br>&gt;&gt;&gt;&gt;&gt;&gt;                      for (k, v) in elements {<br>&gt;&gt;&gt;&gt;&gt;&gt;                              dictionary[k] = v<br>&gt;&gt;&gt;&gt;&gt;&gt;                      }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;                      if dictionary.count != Key.allValues.count {<br>&gt;&gt;&gt;&gt;&gt;&gt;                              let missingKeys = Key.allValues.filter { dictionary[$0] == nil }<br>&gt;&gt;&gt;&gt;&gt;&gt;                              preconditionFailure(&quot;ExhaustiveDictionary is missing elements from \(Key.self): \(missingKeys)&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;                      }<br>&gt;&gt;&gt;&gt;&gt;&gt;              }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;              var startIndex: Dictionary.Index {<br>&gt;&gt;&gt;&gt;&gt;&gt;                      return dictionary.startIndex<br>&gt;&gt;&gt;&gt;&gt;&gt;              }<br>&gt;&gt;&gt;&gt;&gt;&gt;              var endIndex: Dictionary.Index {<br>&gt;&gt;&gt;&gt;&gt;&gt;                      return dictionary.endIndex<br>&gt;&gt;&gt;&gt;&gt;&gt;              }<br>&gt;&gt;&gt;&gt;&gt;&gt;              subscript(index: Dictionary.Index) -&gt; (Key, Value) {<br>&gt;&gt;&gt;&gt;&gt;&gt;                      return dictionary[index]<br>&gt;&gt;&gt;&gt;&gt;&gt;              }<br>&gt;&gt;&gt;&gt;&gt;&gt;              func index(after i: Dictionary.Index) -&gt; Dictionary.Index {<br>&gt;&gt;&gt;&gt;&gt;&gt;                      return dictionary.index(after: i)<br>&gt;&gt;&gt;&gt;&gt;&gt;              }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;              subscript(key: Key) -&gt; Value {<br>&gt;&gt;&gt;&gt;&gt;&gt;                      get { return dictionary[key]! }<br>&gt;&gt;&gt;&gt;&gt;&gt;                      set { dictionary[key] = newValue }<br>&gt;&gt;&gt;&gt;&gt;&gt;              }<br>&gt;&gt;&gt;&gt;&gt;&gt;      }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What I would do is borrow the &quot;accessors&quot; concept from the property behaviors proposal and extend it so that it supported both functions and variables.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Wouldn&#39;t accessor just be a redundant keyword here? Currently enums do<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; not support stored properties, so I guess there is no extra need to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; mark properties with any special keyword.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The keyword is mainly to indicate the unusual syntax at the definition site, where you only have to specify the name of the accessor you&#39;re defining, not a `func` or `var` keyword, a return type, or even parameter names. (Like `willSet`, there&#39;s a default parameter name you can use.) Secondarily, though, I think it&#39;s helpful to indicate very explicitly that this is not an ordinary method or property definition, even if the compiler could perhaps sort things out without it. `accessor` is something a user can Google if they&#39;ve never seen it before.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Property accessors might work for enums with associated values, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; not so well without them.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The two have nothing to do with each other. I showed your planets example, which has no associated values but uses accessors just fine.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>June  1, 2016 at 12:00:00pm</p></header><div class="content"><p>I&#39;m not much fond of Java enums but then Java also doesn&#39;t have<br>structs so I think enums there were created to be a mix of structs and<br>enums and that&#39;s why you can do all the things you mention on your<br>list. That said:<br>- The tuple typed enum approach is the closest thing we discussed to<br>constructors like the ones in Java enums;<br>- I never knew one could do that in Java but I think tuples can hold<br>function types;<br>- I also never heard one can do that in Java but I begin to think what<br>you really want are structs here;<br>- Both approaches here provide that, but accessors would allow for<br>dynamic content to be generated, not static.<br></p><p>Also Swift already allow for functions to be declared in enums and I<br>think this would be a better place than accessor properties to place<br>code that will generate dynamic results.<br></p><p>L<br></p><p>On 1 June 2016 at 11:59, Matthew Johnson via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt;&gt; On Jun 1, 2016, at 9:48 AM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; One thing I did often in Java (and miss in Swift) is using their enums to build state machines or implement command patterns for common commands.<br>&gt;&gt;<br>&gt;&gt; Java enums are a sealed set of subclasses of the enum base type with (hopefully) immutable, singleton instances. So you can do fun things like:<br>&gt;&gt; - Define the base class constructor to be called to instantiate the subclasses, and declare the cases with the constructor arguments<br>&gt;&gt; - Declare a method on the base type and refine it on 1-2 particular cases<br>&gt;&gt; - Declare the enum implements an interface, and implement that interface separately for each case.<br>&gt;&gt; - Define data accessors specific to the type (such as the planets example above)<br>&gt;&gt;<br>&gt;&gt; I like the SuitInfo approach below - with extensions, I think I can get close to what I have done in the past with Java. Maybe one day there is syntax to do this in the language directly<br>&gt;<br>&gt; This is pretty similar to what we were discussing last week in this thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160523/018799.html<br>&gt;<br>&gt; I&#39;m planning to write up a proposal when I have time (hopefully in the next week or so).<br>&gt;<br>&gt;&gt;<br>&gt;&gt; -DW<br>&gt;&gt;<br>&gt;&gt;&gt; On May 31, 2016, at 11:44 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m not sure about my opinion on this proposal, but I believe you should add this as alternatives of how we can have the similar features today without injecting stored properties into enums  :<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; enum Suit {<br>&gt;&gt;&gt;   case spades<br>&gt;&gt;&gt;   case hearts<br>&gt;&gt;&gt;   case diamonds<br>&gt;&gt;&gt;   case clubs<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   struct SuitInfo {<br>&gt;&gt;&gt;       let simpleDescription: String<br>&gt;&gt;&gt;       let color: UIColor<br>&gt;&gt;&gt;       let symbol: String<br>&gt;&gt;&gt;       let bezierPath: UIBezierPath<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   var info : SuitInfo {<br>&gt;&gt;&gt;       switch self {<br>&gt;&gt;&gt;       case .spades:<br>&gt;&gt;&gt;           let path = UIBezierPath()<br>&gt;&gt;&gt;           // omitted lines ...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;           return SuitInfo(<br>&gt;&gt;&gt;               simpleDescription: &quot;spades&quot;,<br>&gt;&gt;&gt;               color: .blackColor(),<br>&gt;&gt;&gt;               symbol: &quot;♠&quot;,<br>&gt;&gt;&gt;               bezierPath: path)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       case .hearts:<br>&gt;&gt;&gt;           let path = UIBezierPath()<br>&gt;&gt;&gt;           // omitted lines ...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;           return SuitInfo(<br>&gt;&gt;&gt;               simpleDescription: &quot;hearts&quot;,<br>&gt;&gt;&gt;               color: .redColor(),<br>&gt;&gt;&gt;               symbol: &quot;♥&quot;,<br>&gt;&gt;&gt;               bezierPath: path)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       case .diamonds:<br>&gt;&gt;&gt;           let path = UIBezierPath()<br>&gt;&gt;&gt;           // omitted lines ...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;           return SuitInfo(<br>&gt;&gt;&gt;               simpleDescription: &quot;diamonds&quot;,<br>&gt;&gt;&gt;               color: .redColor(),<br>&gt;&gt;&gt;               symbol: &quot;♦&quot;,<br>&gt;&gt;&gt;               bezierPath: path)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       case .clubs:<br>&gt;&gt;&gt;           let path = UIBezierPath()<br>&gt;&gt;&gt;           // omitted lines ...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;           return SuitInfo(<br>&gt;&gt;&gt;               simpleDescription: &quot;clubs&quot;,<br>&gt;&gt;&gt;               color: .blackColor(),<br>&gt;&gt;&gt;               symbol: &quot;♣&quot;,<br>&gt;&gt;&gt;               bezierPath: path)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; and this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; enum Suit  {<br>&gt;&gt;&gt;   case spades<br>&gt;&gt;&gt;   case hearts<br>&gt;&gt;&gt;   case diamonds<br>&gt;&gt;&gt;   case clubs<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   struct SuitInfo  {<br>&gt;&gt;&gt;       let simpleDescription: String<br>&gt;&gt;&gt;       let color: UIColor<br>&gt;&gt;&gt;       let symbol: String<br>&gt;&gt;&gt;       let bezierPath: UIBezierPath<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   static let spadesInfo : SuitInfo = {<br>&gt;&gt;&gt;       let path = UIBezierPath()<br>&gt;&gt;&gt;       // omitted lines ...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       return SuitInfo(<br>&gt;&gt;&gt;           simpleDescription: &quot;spades&quot;,<br>&gt;&gt;&gt;           color: .blackColor(),<br>&gt;&gt;&gt;           symbol: &quot;♠&quot;,<br>&gt;&gt;&gt;           bezierPath: path)<br>&gt;&gt;&gt;   }()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   static let heartsInfo : SuitInfo = {<br>&gt;&gt;&gt;       let path = UIBezierPath()<br>&gt;&gt;&gt;       // omitted lines ...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       return SuitInfo(<br>&gt;&gt;&gt;           simpleDescription: &quot;hearts&quot;,<br>&gt;&gt;&gt;           color: .redColor(),<br>&gt;&gt;&gt;           symbol: &quot;♥&quot;,<br>&gt;&gt;&gt;           bezierPath: path)<br>&gt;&gt;&gt;   }()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   static let diamondsInfo : SuitInfo = {<br>&gt;&gt;&gt;       let path = UIBezierPath()<br>&gt;&gt;&gt;       // omitted lines ...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       return SuitInfo(<br>&gt;&gt;&gt;           simpleDescription: &quot;diamonds&quot;,<br>&gt;&gt;&gt;           color: .redColor(),<br>&gt;&gt;&gt;           symbol: &quot;♦&quot;,<br>&gt;&gt;&gt;           bezierPath: path)<br>&gt;&gt;&gt;   }()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   static let clubsInfo : SuitInfo = {<br>&gt;&gt;&gt;       let path = UIBezierPath()<br>&gt;&gt;&gt;       // omitted lines ...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       return SuitInfo(<br>&gt;&gt;&gt;           simpleDescription: &quot;clubs&quot;,<br>&gt;&gt;&gt;           color: .blackColor(),<br>&gt;&gt;&gt;           symbol: &quot;♣&quot;,<br>&gt;&gt;&gt;           bezierPath: path)<br>&gt;&gt;&gt;   }()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   var info : SuitInfo {<br>&gt;&gt;&gt;       switch self {<br>&gt;&gt;&gt;           case .spades: return Suit.spadesInfo<br>&gt;&gt;&gt;           case .hearts: return Suit.heartsInfo<br>&gt;&gt;&gt;           case .diamonds: return Suit.diamondsInfo<br>&gt;&gt;&gt;           case .clubs: return Suit.clubsInfo<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 31.05.2016 17:17, Jānis Kiršteins via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; I wrote a proposal draft:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; # Enum case stored properties<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * Proposal: TBD<br>&gt;&gt;&gt;&gt; * Author: [Janis Kirsteins](https://github.com/kirsteins)<br>&gt;&gt;&gt;&gt; * Status: TBD<br>&gt;&gt;&gt;&gt; * Review manager: TBD<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This proposal allows each enum case to have stored properties.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Enums cases can have a lot of constant (or variable) static values<br>&gt;&gt;&gt;&gt; associated with it. For example, planets can have mass, radius, age,<br>&gt;&gt;&gt;&gt; closest star etc. Currently there is no way to set or get those values<br>&gt;&gt;&gt;&gt; easily.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Example below shows that is hard to read and manage static associated<br>&gt;&gt;&gt;&gt; values with each case. It is hard to add or remove case as it would<br>&gt;&gt;&gt;&gt; require to add or remove code in four different places in file. Also<br>&gt;&gt;&gt;&gt; static associated value like `UIBezierPath` is recreated each time the<br>&gt;&gt;&gt;&gt; property is computed while it&#39;s constant.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; enum Suit {<br>&gt;&gt;&gt;&gt;   case spades<br>&gt;&gt;&gt;&gt;   case hearts<br>&gt;&gt;&gt;&gt;   case diamonds<br>&gt;&gt;&gt;&gt;   case clubs<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   var simpleDescription: String {<br>&gt;&gt;&gt;&gt;       switch self {<br>&gt;&gt;&gt;&gt;       case .spades:<br>&gt;&gt;&gt;&gt;           return &quot;spades&quot;<br>&gt;&gt;&gt;&gt;       case .hearts:<br>&gt;&gt;&gt;&gt;           return &quot;hearts&quot;<br>&gt;&gt;&gt;&gt;       case .diamonds:<br>&gt;&gt;&gt;&gt;           return &quot;diamonds&quot;<br>&gt;&gt;&gt;&gt;       case .clubs:<br>&gt;&gt;&gt;&gt;           return &quot;clubs&quot;<br>&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   var color: UIColor {<br>&gt;&gt;&gt;&gt;       switch self {<br>&gt;&gt;&gt;&gt;       case .spades:<br>&gt;&gt;&gt;&gt;           return .blackColor()<br>&gt;&gt;&gt;&gt;       case .hearts:<br>&gt;&gt;&gt;&gt;           return .redColor()<br>&gt;&gt;&gt;&gt;       case .diamonds:<br>&gt;&gt;&gt;&gt;           return .redColor()<br>&gt;&gt;&gt;&gt;       case .clubs:<br>&gt;&gt;&gt;&gt;           return .blackColor()<br>&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   var symbol: String {<br>&gt;&gt;&gt;&gt;       switch self {<br>&gt;&gt;&gt;&gt;       case .spades:<br>&gt;&gt;&gt;&gt;           return &quot;♠&quot;<br>&gt;&gt;&gt;&gt;       case .hearts:<br>&gt;&gt;&gt;&gt;           return &quot;♥&quot;<br>&gt;&gt;&gt;&gt;       case .diamonds:<br>&gt;&gt;&gt;&gt;           return &quot;♦&quot;<br>&gt;&gt;&gt;&gt;       case .clubs:<br>&gt;&gt;&gt;&gt;           return &quot;♣&quot;<br>&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   var bezierPath: UIBezierPath {<br>&gt;&gt;&gt;&gt;       switch self {<br>&gt;&gt;&gt;&gt;       case .spades:<br>&gt;&gt;&gt;&gt;           let path = UIBezierPath()<br>&gt;&gt;&gt;&gt;           // omitted lines ...<br>&gt;&gt;&gt;&gt;           return path<br>&gt;&gt;&gt;&gt;       case .hearts:<br>&gt;&gt;&gt;&gt;           let path = UIBezierPath()<br>&gt;&gt;&gt;&gt;           // omitted lines ...<br>&gt;&gt;&gt;&gt;           return path<br>&gt;&gt;&gt;&gt;       case .diamonds:<br>&gt;&gt;&gt;&gt;           let path = UIBezierPath()<br>&gt;&gt;&gt;&gt;           // omitted lines ...<br>&gt;&gt;&gt;&gt;           return path<br>&gt;&gt;&gt;&gt;       case .clubs:<br>&gt;&gt;&gt;&gt;           let path = UIBezierPath()<br>&gt;&gt;&gt;&gt;           // omitted lines ...<br>&gt;&gt;&gt;&gt;           return path<br>&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Support stored properties for enum cases just as each case were an<br>&gt;&gt;&gt;&gt; instance. Case properties are initialized block after each case<br>&gt;&gt;&gt;&gt; declaration.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; enum Suit {<br>&gt;&gt;&gt;&gt;   let simpleDescription: String<br>&gt;&gt;&gt;&gt;   let color: UIColor<br>&gt;&gt;&gt;&gt;   let symbol: String<br>&gt;&gt;&gt;&gt;   let bezierPath: UIBezierPath<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   case spades {<br>&gt;&gt;&gt;&gt;       simpleDescription = &quot;spades&quot;<br>&gt;&gt;&gt;&gt;       color = .blackColor()<br>&gt;&gt;&gt;&gt;       symbol = &quot;♠&quot;<br>&gt;&gt;&gt;&gt;       let bezierPath = UIBezierPath()<br>&gt;&gt;&gt;&gt;       // omitted lines ...<br>&gt;&gt;&gt;&gt;       self.bezierPath = bezierPath<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   case hearts {<br>&gt;&gt;&gt;&gt;       simpleDescription = &quot;hearts&quot;<br>&gt;&gt;&gt;&gt;       color = .redColor()<br>&gt;&gt;&gt;&gt;       symbol = &quot;♥&quot;<br>&gt;&gt;&gt;&gt;       let bezierPath = UIBezierPath()<br>&gt;&gt;&gt;&gt;       // omitted lines ...<br>&gt;&gt;&gt;&gt;       self.bezierPath = bezierPath<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   case diamonds {<br>&gt;&gt;&gt;&gt;       simpleDescription = &quot;diamonds&quot;<br>&gt;&gt;&gt;&gt;       color = .redColor()<br>&gt;&gt;&gt;&gt;       symbol = &quot;♦&quot;<br>&gt;&gt;&gt;&gt;       let bezierPath = UIBezierPath()<br>&gt;&gt;&gt;&gt;       // omitted lines ...<br>&gt;&gt;&gt;&gt;       self.bezierPath = bezierPath<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   case clubs {<br>&gt;&gt;&gt;&gt;       simpleDescription = &quot;clubs&quot;<br>&gt;&gt;&gt;&gt;       color = .blackColor()<br>&gt;&gt;&gt;&gt;       symbol = &quot;♣&quot;<br>&gt;&gt;&gt;&gt;       let bezierPath = UIBezierPath()<br>&gt;&gt;&gt;&gt;       // omitted lines ...<br>&gt;&gt;&gt;&gt;       self.bezierPath = bezierPath<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let symbol = Suit.spades.symbol // &quot;♠&quot;<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The proposed solution improves:<br>&gt;&gt;&gt;&gt; - Readability as cases are closer with their related data;<br>&gt;&gt;&gt;&gt; - Improves code maintainability as a case can be removed or added in one place;<br>&gt;&gt;&gt;&gt; - Improved performance as there is no need to recreate static values;<br>&gt;&gt;&gt;&gt; - ~30% less lines of code in given example.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; #### Stored properties<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Enum stored properties are supported the same way they are supported<br>&gt;&gt;&gt;&gt; for structs can classes. Unlike enum associated values, stored<br>&gt;&gt;&gt;&gt; properties are static to case and are shared for the same case.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Properties are accessed:<br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; let simpleDescription = Suit.spades.simpleDescription<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Mutable properties can be set:<br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; Suit.spades.simpleDescription = &quot;new simple description&quot;<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; #### Initialization<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If enum has uninitialized stored property it must be initialized in a<br>&gt;&gt;&gt;&gt; block after each case declaration. The block work the same way as<br>&gt;&gt;&gt;&gt; struct initialization. At the end of initialization block all<br>&gt;&gt;&gt;&gt; properties must be initialized.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; enum Suit {<br>&gt;&gt;&gt;&gt;   var simpleDescription: String<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   case spades {<br>&gt;&gt;&gt;&gt;       simpleDescription = &quot;spades&quot;<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Initialization block can be combine with use of `rawValue`:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; enum Suit: Int {<br>&gt;&gt;&gt;&gt;   var simpleDescription: String<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   case spades = 1 {<br>&gt;&gt;&gt;&gt;       simpleDescription = &quot;spades&quot;<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; or associated values of the case:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; enum Suit {<br>&gt;&gt;&gt;&gt;   var simpleDescription: String<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   case spades(Int) {<br>&gt;&gt;&gt;&gt;       simpleDescription = &quot;spades&quot;<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Stored properties for enums are not currently not supported, so there<br>&gt;&gt;&gt;&gt; is no impact on existing code.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - Use labeled tuple as `rawValue` of the enum case. This approach is<br>&gt;&gt;&gt;&gt; not compatible as it conflicts with intention of `rawValue` of Swift<br>&gt;&gt;&gt;&gt; enum;<br>&gt;&gt;&gt;&gt; - Use per case initializer like [Java<br>&gt;&gt;&gt;&gt; Enum](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html).<br>&gt;&gt;&gt;&gt; Swift enum uses custom initializer syntax to setup instances, not<br>&gt;&gt;&gt;&gt; cases. So this approach is not suitable for Swift.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Sun, May 29, 2016 at 3:42 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I think that&#39;s the case with enums. You&#39;re changing their current behaviour of only having stored values to one in which it&#39;s computed (even if only once and then stored). Enums are IMO something that have a static value you know beforehand and can count on. That&#39;s why I&#39;m not fond of the accessor proposal. Otherwise I think we&#39;re transforming enums into a closed set of struct instances and one could do that already by using a private init.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On 29 May 2016, at 3:38 am, Jānis Kiršteins via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I agree with the argument about use of &quot;where&quot;, not replacing the raw<br>&gt;&gt;&gt;&gt;&gt;&gt; value and having some kind of initialization block. But I cannot see<br>&gt;&gt;&gt;&gt;&gt;&gt; why &quot;accessors&quot; concept is any better than stored properties to solve<br>&gt;&gt;&gt;&gt;&gt;&gt; the particular problem. The &quot;accessors&quot; concept has much wider scope<br>&gt;&gt;&gt;&gt;&gt;&gt; than enums and is a separate proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Sat, May 28, 2016 at 11:39 PM, Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Abusing rawValue is just that: an abuse.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My original proposal does not replace rawValue and is compatible with it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `rawValue` has a different purpose from how you&#39;re using it. It&#39;s supposed to allow you to convert your type to some other *equivalent* type, like an equivalent integer or string. Moreover, it&#39;s supposed to allow you to *reconstruct* the instance from the raw value—remember, `RawRepresentable` has an `init(rawValue:)` requirement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is *not* supposed to be an ancillary bag of information on the side. You&#39;re cramming a square peg into a round hole here.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (Also, if you use `rawValue` for an ancillary bag of information, that means you *can&#39;t* use it on the same type for its intended purpose. For instance, you would not be able to assign numbers to your Planet enum&#39;s cases to help you serialize them or bridge them to Objective-C. That&#39;s not good.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Using `where` just doesn&#39;t match the use of `where` elsewhere in the language; everywhere else, it&#39;s some kind of condition.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is also used in generic type constraints. Plus it reads like human<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; language: `case mercury where (mass: 3.303e+23, radius: 2.4397e6)`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But a generic constraint is also a type of condition: it specifies types which are permitted and divides them from types that are not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is *not* a condition. It&#39;s not anything like a condition. It&#39;s simply not consistent with anything else in the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Dictionaries are the most straightforward way to handle this with the current language, but their lack of exhaustiveness checking is a problem.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dictionaries can be used as workaround, but they cannot (lack of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; exhaustiveness) solve the problem.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I agree that they&#39;re a halfway solution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If `ValuesEnumerable` were to be accepted (and to have a generic requirement for its `allValues` property), you could write a Dictionary-like type which ensured at initialization time that it was exhaustive. That&#39;s not as good as compile time, but it&#39;s not bad—sort of a three-quarters solution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      struct ExhaustiveDictionary&lt;Key: Hashable, Value where Key: ValuesEnumerable&gt;: Collection, DictionaryLiteralConvertible {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;              private var dictionary: [Key: Value]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;              init(dictionaryLiteral elements: (Key, Value)...) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      dictionary = [:]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      for (k, v) in elements {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                              dictionary[k] = v<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      if dictionary.count != Key.allValues.count {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                              let missingKeys = Key.allValues.filter { dictionary[$0] == nil }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                              preconditionFailure(&quot;ExhaustiveDictionary is missing elements from \(Key.self): \(missingKeys)&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;              }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;              var startIndex: Dictionary.Index {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      return dictionary.startIndex<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;              }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;              var endIndex: Dictionary.Index {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      return dictionary.endIndex<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;              }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;              subscript(index: Dictionary.Index) -&gt; (Key, Value) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      return dictionary[index]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;              }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;              func index(after i: Dictionary.Index) -&gt; Dictionary.Index {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      return dictionary.index(after: i)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;              }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;              subscript(key: Key) -&gt; Value {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      get { return dictionary[key]! }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      set { dictionary[key] = newValue }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;              }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What I would do is borrow the &quot;accessors&quot; concept from the property behaviors proposal and extend it so that it supported both functions and variables.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Wouldn&#39;t accessor just be a redundant keyword here? Currently enums do<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not support stored properties, so I guess there is no extra need to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mark properties with any special keyword.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The keyword is mainly to indicate the unusual syntax at the definition site, where you only have to specify the name of the accessor you&#39;re defining, not a `func` or `var` keyword, a return type, or even parameter names. (Like `willSet`, there&#39;s a default parameter name you can use.) Secondarily, though, I think it&#39;s helpful to indicate very explicitly that this is not an ordinary method or property definition, even if the compiler could perhaps sort things out without it. `accessor` is something a user can Google if they&#39;ve never seen it before.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Property accessors might work for enums with associated values, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not so well without them.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The two have nothing to do with each other. I showed your planets example, which has no associated values but uses accessors just fine.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>June  1, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 9:48 AM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One thing I did often in Java (and miss in Swift) is using their enums to build state machines or implement command patterns for common commands.<br>&gt; <br>&gt; Java enums are a sealed set of subclasses of the enum base type with (hopefully) immutable, singleton instances. So you can do fun things like:<br>&gt; - Define the base class constructor to be called to instantiate the subclasses, and declare the cases with the constructor arguments<br>&gt; - Declare a method on the base type and refine it on 1-2 particular cases<br>&gt; - Declare the enum implements an interface, and implement that interface separately for each case.<br>&gt; - Define data accessors specific to the type (such as the planets example above)<br></p><p>+1 to this behavior — one of the increasingly rare places where Java is nicer than Swift. This is the natural generalization / next step of the stored properties of this thread, and I can confirm what David said: it’s useful in practice.<br></p><p>P<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>June  1, 2016 at 06:00:00pm</p></header><div class="content"><p>Hello David,<br></p><p>Could you elaborate on this more? Seeing the possibilities of FSM&#39;s in<br>Swift using its powerful enum and case pattern matching was one of the<br>moments in which Swift started increasing its allure factor ;).<br></p><p>Part 1 (background and theory):<br>http://www.figure.ink/blog/2015/1/31/swift-state-machines-part-1<br></p><p>Part 2 (start of the implementation):<br>http://www.figure.ink/blog/2015/2/1/swift-state-machines-part-2<br></p><p>Part 3:<br>http://www.figure.ink/blog/2015/2/8/swift-state-machines-part-3-follow-up<br></p><p>Part 4:<br>http://www.figure.ink/blog/2015/2/9/swift-state-machines-part-4-redirect<br></p><p><br></p><p>Final gist: https://gist.github.com/jemmons/f30f1de292751da0f1b7<br></p><p><br>On Wed, Jun 1, 2016 at 3:48 PM, David Waite via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; One thing I did often in Java (and miss in Swift) is using their enums to<br>&gt; build state machines or implement command patterns for common commands.<br>&gt;<br>&gt; Java enums are a sealed set of subclasses of the enum base type with<br>&gt; (hopefully) immutable, singleton instances. So you can do fun things like:<br>&gt; - Define the base class constructor to be called to instantiate the<br>&gt; subclasses, and declare the cases with the constructor arguments<br>&gt; - Declare a method on the base type and refine it on 1-2 particular cases<br>&gt; - Declare the enum implements an interface, and implement that interface<br>&gt; separately for each case.<br>&gt; - Define data accessors specific to the type (such as the planets example<br>&gt; above)<br>&gt;<br>&gt; I like the SuitInfo approach below - with extensions, I think I can get<br>&gt; close to what I have done in the past with Java. Maybe one day there is<br>&gt; syntax to do this in the language directly<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; &gt; On May 31, 2016, at 11:44 AM, Vladimir.S via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I&#39;m not sure about my opinion on this proposal, but I believe you should<br>&gt; add this as alternatives of how we can have the similar features today<br>&gt; without injecting stored properties into enums  :<br>&gt; &gt;<br>&gt; &gt; enum Suit {<br>&gt; &gt;    case spades<br>&gt; &gt;    case hearts<br>&gt; &gt;    case diamonds<br>&gt; &gt;    case clubs<br>&gt; &gt;<br>&gt; &gt;    struct SuitInfo {<br>&gt; &gt;        let simpleDescription: String<br>&gt; &gt;        let color: UIColor<br>&gt; &gt;        let symbol: String<br>&gt; &gt;        let bezierPath: UIBezierPath<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt;    var info : SuitInfo {<br>&gt; &gt;        switch self {<br>&gt; &gt;        case .spades:<br>&gt; &gt;            let path = UIBezierPath()<br>&gt; &gt;            // omitted lines ...<br>&gt; &gt;<br>&gt; &gt;            return SuitInfo(<br>&gt; &gt;                simpleDescription: &quot;spades&quot;,<br>&gt; &gt;                color: .blackColor(),<br>&gt; &gt;                symbol: &quot;♠&quot;,<br>&gt; &gt;                bezierPath: path)<br>&gt; &gt;<br>&gt; &gt;        case .hearts:<br>&gt; &gt;            let path = UIBezierPath()<br>&gt; &gt;            // omitted lines ...<br>&gt; &gt;<br>&gt; &gt;            return SuitInfo(<br>&gt; &gt;                simpleDescription: &quot;hearts&quot;,<br>&gt; &gt;                color: .redColor(),<br>&gt; &gt;                symbol: &quot;♥&quot;,<br>&gt; &gt;                bezierPath: path)<br>&gt; &gt;<br>&gt; &gt;        case .diamonds:<br>&gt; &gt;            let path = UIBezierPath()<br>&gt; &gt;            // omitted lines ...<br>&gt; &gt;<br>&gt; &gt;            return SuitInfo(<br>&gt; &gt;                simpleDescription: &quot;diamonds&quot;,<br>&gt; &gt;                color: .redColor(),<br>&gt; &gt;                symbol: &quot;♦&quot;,<br>&gt; &gt;                bezierPath: path)<br>&gt; &gt;<br>&gt; &gt;        case .clubs:<br>&gt; &gt;            let path = UIBezierPath()<br>&gt; &gt;            // omitted lines ...<br>&gt; &gt;<br>&gt; &gt;            return SuitInfo(<br>&gt; &gt;                simpleDescription: &quot;clubs&quot;,<br>&gt; &gt;                color: .blackColor(),<br>&gt; &gt;                symbol: &quot;♣&quot;,<br>&gt; &gt;                bezierPath: path)<br>&gt; &gt;<br>&gt; &gt;        }<br>&gt; &gt;    }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; and this:<br>&gt; &gt;<br>&gt; &gt; enum Suit  {<br>&gt; &gt;    case spades<br>&gt; &gt;    case hearts<br>&gt; &gt;    case diamonds<br>&gt; &gt;    case clubs<br>&gt; &gt;<br>&gt; &gt;    struct SuitInfo  {<br>&gt; &gt;        let simpleDescription: String<br>&gt; &gt;        let color: UIColor<br>&gt; &gt;        let symbol: String<br>&gt; &gt;        let bezierPath: UIBezierPath<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt;    static let spadesInfo : SuitInfo = {<br>&gt; &gt;        let path = UIBezierPath()<br>&gt; &gt;        // omitted lines ...<br>&gt; &gt;<br>&gt; &gt;        return SuitInfo(<br>&gt; &gt;            simpleDescription: &quot;spades&quot;,<br>&gt; &gt;            color: .blackColor(),<br>&gt; &gt;            symbol: &quot;♠&quot;,<br>&gt; &gt;            bezierPath: path)<br>&gt; &gt;    }()<br>&gt; &gt;<br>&gt; &gt;    static let heartsInfo : SuitInfo = {<br>&gt; &gt;        let path = UIBezierPath()<br>&gt; &gt;        // omitted lines ...<br>&gt; &gt;<br>&gt; &gt;        return SuitInfo(<br>&gt; &gt;            simpleDescription: &quot;hearts&quot;,<br>&gt; &gt;            color: .redColor(),<br>&gt; &gt;            symbol: &quot;♥&quot;,<br>&gt; &gt;            bezierPath: path)<br>&gt; &gt;    }()<br>&gt; &gt;<br>&gt; &gt;    static let diamondsInfo : SuitInfo = {<br>&gt; &gt;        let path = UIBezierPath()<br>&gt; &gt;        // omitted lines ...<br>&gt; &gt;<br>&gt; &gt;        return SuitInfo(<br>&gt; &gt;            simpleDescription: &quot;diamonds&quot;,<br>&gt; &gt;            color: .redColor(),<br>&gt; &gt;            symbol: &quot;♦&quot;,<br>&gt; &gt;            bezierPath: path)<br>&gt; &gt;    }()<br>&gt; &gt;<br>&gt; &gt;    static let clubsInfo : SuitInfo = {<br>&gt; &gt;        let path = UIBezierPath()<br>&gt; &gt;        // omitted lines ...<br>&gt; &gt;<br>&gt; &gt;        return SuitInfo(<br>&gt; &gt;            simpleDescription: &quot;clubs&quot;,<br>&gt; &gt;            color: .blackColor(),<br>&gt; &gt;            symbol: &quot;♣&quot;,<br>&gt; &gt;            bezierPath: path)<br>&gt; &gt;    }()<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;    var info : SuitInfo {<br>&gt; &gt;        switch self {<br>&gt; &gt;            case .spades: return Suit.spadesInfo<br>&gt; &gt;            case .hearts: return Suit.heartsInfo<br>&gt; &gt;            case .diamonds: return Suit.diamondsInfo<br>&gt; &gt;            case .clubs: return Suit.clubsInfo<br>&gt; &gt;        }<br>&gt; &gt;    }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On 31.05.2016 17:17, Jānis Kiršteins via swift-evolution wrote:<br>&gt; &gt;&gt; I wrote a proposal draft:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; # Enum case stored properties<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; * Proposal: TBD<br>&gt; &gt;&gt; * Author: [Janis Kirsteins](https://github.com/kirsteins)<br>&gt; &gt;&gt; * Status: TBD<br>&gt; &gt;&gt; * Review manager: TBD<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ## Introduction<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This proposal allows each enum case to have stored properties.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ## Motivation<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Enums cases can have a lot of constant (or variable) static values<br>&gt; &gt;&gt; associated with it. For example, planets can have mass, radius, age,<br>&gt; &gt;&gt; closest star etc. Currently there is no way to set or get those values<br>&gt; &gt;&gt; easily.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Example below shows that is hard to read and manage static associated<br>&gt; &gt;&gt; values with each case. It is hard to add or remove case as it would<br>&gt; &gt;&gt; require to add or remove code in four different places in file. Also<br>&gt; &gt;&gt; static associated value like `UIBezierPath` is recreated each time the<br>&gt; &gt;&gt; property is computed while it&#39;s constant.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ```swift<br>&gt; &gt;&gt; enum Suit {<br>&gt; &gt;&gt;    case spades<br>&gt; &gt;&gt;    case hearts<br>&gt; &gt;&gt;    case diamonds<br>&gt; &gt;&gt;    case clubs<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    var simpleDescription: String {<br>&gt; &gt;&gt;        switch self {<br>&gt; &gt;&gt;        case .spades:<br>&gt; &gt;&gt;            return &quot;spades&quot;<br>&gt; &gt;&gt;        case .hearts:<br>&gt; &gt;&gt;            return &quot;hearts&quot;<br>&gt; &gt;&gt;        case .diamonds:<br>&gt; &gt;&gt;            return &quot;diamonds&quot;<br>&gt; &gt;&gt;        case .clubs:<br>&gt; &gt;&gt;            return &quot;clubs&quot;<br>&gt; &gt;&gt;        }<br>&gt; &gt;&gt;    }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    var color: UIColor {<br>&gt; &gt;&gt;        switch self {<br>&gt; &gt;&gt;        case .spades:<br>&gt; &gt;&gt;            return .blackColor()<br>&gt; &gt;&gt;        case .hearts:<br>&gt; &gt;&gt;            return .redColor()<br>&gt; &gt;&gt;        case .diamonds:<br>&gt; &gt;&gt;            return .redColor()<br>&gt; &gt;&gt;        case .clubs:<br>&gt; &gt;&gt;            return .blackColor()<br>&gt; &gt;&gt;        }<br>&gt; &gt;&gt;    }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    var symbol: String {<br>&gt; &gt;&gt;        switch self {<br>&gt; &gt;&gt;        case .spades:<br>&gt; &gt;&gt;            return &quot;♠&quot;<br>&gt; &gt;&gt;        case .hearts:<br>&gt; &gt;&gt;            return &quot;♥&quot;<br>&gt; &gt;&gt;        case .diamonds:<br>&gt; &gt;&gt;            return &quot;♦&quot;<br>&gt; &gt;&gt;        case .clubs:<br>&gt; &gt;&gt;            return &quot;♣&quot;<br>&gt; &gt;&gt;        }<br>&gt; &gt;&gt;    }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    var bezierPath: UIBezierPath {<br>&gt; &gt;&gt;        switch self {<br>&gt; &gt;&gt;        case .spades:<br>&gt; &gt;&gt;            let path = UIBezierPath()<br>&gt; &gt;&gt;            // omitted lines ...<br>&gt; &gt;&gt;            return path<br>&gt; &gt;&gt;        case .hearts:<br>&gt; &gt;&gt;            let path = UIBezierPath()<br>&gt; &gt;&gt;            // omitted lines ...<br>&gt; &gt;&gt;            return path<br>&gt; &gt;&gt;        case .diamonds:<br>&gt; &gt;&gt;            let path = UIBezierPath()<br>&gt; &gt;&gt;            // omitted lines ...<br>&gt; &gt;&gt;            return path<br>&gt; &gt;&gt;        case .clubs:<br>&gt; &gt;&gt;            let path = UIBezierPath()<br>&gt; &gt;&gt;            // omitted lines ...<br>&gt; &gt;&gt;            return path<br>&gt; &gt;&gt;        }<br>&gt; &gt;&gt;    }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; ```<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ## Proposed solution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Support stored properties for enum cases just as each case were an<br>&gt; &gt;&gt; instance. Case properties are initialized block after each case<br>&gt; &gt;&gt; declaration.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ```swift<br>&gt; &gt;&gt; enum Suit {<br>&gt; &gt;&gt;    let simpleDescription: String<br>&gt; &gt;&gt;    let color: UIColor<br>&gt; &gt;&gt;    let symbol: String<br>&gt; &gt;&gt;    let bezierPath: UIBezierPath<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    case spades {<br>&gt; &gt;&gt;        simpleDescription = &quot;spades&quot;<br>&gt; &gt;&gt;        color = .blackColor()<br>&gt; &gt;&gt;        symbol = &quot;♠&quot;<br>&gt; &gt;&gt;        let bezierPath = UIBezierPath()<br>&gt; &gt;&gt;        // omitted lines ...<br>&gt; &gt;&gt;        self.bezierPath = bezierPath<br>&gt; &gt;&gt;    }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    case hearts {<br>&gt; &gt;&gt;        simpleDescription = &quot;hearts&quot;<br>&gt; &gt;&gt;        color = .redColor()<br>&gt; &gt;&gt;        symbol = &quot;♥&quot;<br>&gt; &gt;&gt;        let bezierPath = UIBezierPath()<br>&gt; &gt;&gt;        // omitted lines ...<br>&gt; &gt;&gt;        self.bezierPath = bezierPath<br>&gt; &gt;&gt;    }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    case diamonds {<br>&gt; &gt;&gt;        simpleDescription = &quot;diamonds&quot;<br>&gt; &gt;&gt;        color = .redColor()<br>&gt; &gt;&gt;        symbol = &quot;♦&quot;<br>&gt; &gt;&gt;        let bezierPath = UIBezierPath()<br>&gt; &gt;&gt;        // omitted lines ...<br>&gt; &gt;&gt;        self.bezierPath = bezierPath<br>&gt; &gt;&gt;    }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    case clubs {<br>&gt; &gt;&gt;        simpleDescription = &quot;clubs&quot;<br>&gt; &gt;&gt;        color = .blackColor()<br>&gt; &gt;&gt;        symbol = &quot;♣&quot;<br>&gt; &gt;&gt;        let bezierPath = UIBezierPath()<br>&gt; &gt;&gt;        // omitted lines ...<br>&gt; &gt;&gt;        self.bezierPath = bezierPath<br>&gt; &gt;&gt;    }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; let symbol = Suit.spades.symbol // &quot;♠&quot;<br>&gt; &gt;&gt; ```<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The proposed solution improves:<br>&gt; &gt;&gt; - Readability as cases are closer with their related data;<br>&gt; &gt;&gt; - Improves code maintainability as a case can be removed or added in<br>&gt; one place;<br>&gt; &gt;&gt; - Improved performance as there is no need to recreate static values;<br>&gt; &gt;&gt; - ~30% less lines of code in given example.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ## Detailed design<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; #### Stored properties<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Enum stored properties are supported the same way they are supported<br>&gt; &gt;&gt; for structs can classes. Unlike enum associated values, stored<br>&gt; &gt;&gt; properties are static to case and are shared for the same case.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Properties are accessed:<br>&gt; &gt;&gt; ```swift<br>&gt; &gt;&gt; let simpleDescription = Suit.spades.simpleDescription<br>&gt; &gt;&gt; ```<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Mutable properties can be set:<br>&gt; &gt;&gt; ```swift<br>&gt; &gt;&gt; Suit.spades.simpleDescription = &quot;new simple description&quot;<br>&gt; &gt;&gt; ```<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; #### Initialization<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; If enum has uninitialized stored property it must be initialized in a<br>&gt; &gt;&gt; block after each case declaration. The block work the same way as<br>&gt; &gt;&gt; struct initialization. At the end of initialization block all<br>&gt; &gt;&gt; properties must be initialized.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ```swift<br>&gt; &gt;&gt; enum Suit {<br>&gt; &gt;&gt;    var simpleDescription: String<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    case spades {<br>&gt; &gt;&gt;        simpleDescription = &quot;spades&quot;<br>&gt; &gt;&gt;    }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; ```<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Initialization block can be combine with use of `rawValue`:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ```swift<br>&gt; &gt;&gt; enum Suit: Int {<br>&gt; &gt;&gt;    var simpleDescription: String<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    case spades = 1 {<br>&gt; &gt;&gt;        simpleDescription = &quot;spades&quot;<br>&gt; &gt;&gt;    }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; ```<br>&gt; &gt;&gt; or associated values of the case:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ```swift<br>&gt; &gt;&gt; enum Suit {<br>&gt; &gt;&gt;    var simpleDescription: String<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    case spades(Int) {<br>&gt; &gt;&gt;        simpleDescription = &quot;spades&quot;<br>&gt; &gt;&gt;    }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; ```<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ## Impact on existing code<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Stored properties for enums are not currently not supported, so there<br>&gt; &gt;&gt; is no impact on existing code.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ## Alternatives considered<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - Use labeled tuple as `rawValue` of the enum case. This approach is<br>&gt; &gt;&gt; not compatible as it conflicts with intention of `rawValue` of Swift<br>&gt; &gt;&gt; enum;<br>&gt; &gt;&gt; - Use per case initializer like [Java<br>&gt; &gt;&gt; Enum](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html).<br>&gt; &gt;&gt; Swift enum uses custom initializer syntax to setup instances, not<br>&gt; &gt;&gt; cases. So this approach is not suitable for Swift.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Sun, May 29, 2016 at 3:42 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt; I think that&#39;s the case with enums. You&#39;re changing their current<br>&gt; behaviour of only having stored values to one in which it&#39;s computed (even<br>&gt; if only once and then stored). Enums are IMO something that have a static<br>&gt; value you know beforehand and can count on. That&#39;s why I&#39;m not fond of the<br>&gt; accessor proposal. Otherwise I think we&#39;re transforming enums into a closed<br>&gt; set of struct instances and one could do that already by using a private<br>&gt; init.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On 29 May 2016, at 3:38 am, Jānis Kiršteins via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I agree with the argument about use of &quot;where&quot;, not replacing the raw<br>&gt; &gt;&gt;&gt;&gt; value and having some kind of initialization block. But I cannot see<br>&gt; &gt;&gt;&gt;&gt; why &quot;accessors&quot; concept is any better than stored properties to solve<br>&gt; &gt;&gt;&gt;&gt; the particular problem. The &quot;accessors&quot; concept has much wider scope<br>&gt; &gt;&gt;&gt;&gt; than enums and is a separate proposal.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Sat, May 28, 2016 at 11:39 PM, Brent Royal-Gordon<br>&gt; &gt;&gt;&gt;&gt; &lt;brent at architechies.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; - Abusing rawValue is just that: an abuse.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; My original proposal does not replace rawValue and is compatible<br>&gt; with it.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; `rawValue` has a different purpose from how you&#39;re using it. It&#39;s<br>&gt; supposed to allow you to convert your type to some other *equivalent* type,<br>&gt; like an equivalent integer or string. Moreover, it&#39;s supposed to allow you<br>&gt; to *reconstruct* the instance from the raw value—remember,<br>&gt; `RawRepresentable` has an `init(rawValue:)` requirement.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; It is *not* supposed to be an ancillary bag of information on the<br>&gt; side. You&#39;re cramming a square peg into a round hole here.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; (Also, if you use `rawValue` for an ancillary bag of information,<br>&gt; that means you *can&#39;t* use it on the same type for its intended purpose.<br>&gt; For instance, you would not be able to assign numbers to your Planet enum&#39;s<br>&gt; cases to help you serialize them or bridge them to Objective-C. That&#39;s not<br>&gt; good.)<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; - Using `where` just doesn&#39;t match the use of `where` elsewhere in<br>&gt; the language; everywhere else, it&#39;s some kind of condition.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; It is also used in generic type constraints. Plus it reads like<br>&gt; human<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; language: `case mercury where (mass: 3.303e+23, radius: 2.4397e6)`<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; But a generic constraint is also a type of condition: it specifies<br>&gt; types which are permitted and divides them from types that are not.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; This is *not* a condition. It&#39;s not anything like a condition. It&#39;s<br>&gt; simply not consistent with anything else in the language.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; - Dictionaries are the most straightforward way to handle this<br>&gt; with the current language, but their lack of exhaustiveness checking is a<br>&gt; problem.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Dictionaries can be used as workaround, but they cannot (lack of<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; exhaustiveness) solve the problem.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I agree that they&#39;re a halfway solution.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; If `ValuesEnumerable` were to be accepted (and to have a generic<br>&gt; requirement for its `allValues` property), you could write a<br>&gt; Dictionary-like type which ensured at initialization time that it was<br>&gt; exhaustive. That&#39;s not as good as compile time, but it&#39;s not bad—sort of a<br>&gt; three-quarters solution.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;       struct ExhaustiveDictionary&lt;Key: Hashable, Value where Key:<br>&gt; ValuesEnumerable&gt;: Collection, DictionaryLiteralConvertible {<br>&gt; &gt;&gt;&gt;&gt;&gt;               private var dictionary: [Key: Value]<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;               init(dictionaryLiteral elements: (Key, Value)...) {<br>&gt; &gt;&gt;&gt;&gt;&gt;                       dictionary = [:]<br>&gt; &gt;&gt;&gt;&gt;&gt;                       for (k, v) in elements {<br>&gt; &gt;&gt;&gt;&gt;&gt;                               dictionary[k] = v<br>&gt; &gt;&gt;&gt;&gt;&gt;                       }<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;                       if dictionary.count != Key.allValues.count {<br>&gt; &gt;&gt;&gt;&gt;&gt;                               let missingKeys = Key.allValues.filter<br>&gt; { dictionary[$0] == nil }<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;  preconditionFailure(&quot;ExhaustiveDictionary is missing elements from<br>&gt; \(Key.self): \(missingKeys)&quot;)<br>&gt; &gt;&gt;&gt;&gt;&gt;                       }<br>&gt; &gt;&gt;&gt;&gt;&gt;               }<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;               var startIndex: Dictionary.Index {<br>&gt; &gt;&gt;&gt;&gt;&gt;                       return dictionary.startIndex<br>&gt; &gt;&gt;&gt;&gt;&gt;               }<br>&gt; &gt;&gt;&gt;&gt;&gt;               var endIndex: Dictionary.Index {<br>&gt; &gt;&gt;&gt;&gt;&gt;                       return dictionary.endIndex<br>&gt; &gt;&gt;&gt;&gt;&gt;               }<br>&gt; &gt;&gt;&gt;&gt;&gt;               subscript(index: Dictionary.Index) -&gt; (Key, Value) {<br>&gt; &gt;&gt;&gt;&gt;&gt;                       return dictionary[index]<br>&gt; &gt;&gt;&gt;&gt;&gt;               }<br>&gt; &gt;&gt;&gt;&gt;&gt;               func index(after i: Dictionary.Index) -&gt;<br>&gt; Dictionary.Index {<br>&gt; &gt;&gt;&gt;&gt;&gt;                       return dictionary.index(after: i)<br>&gt; &gt;&gt;&gt;&gt;&gt;               }<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;               subscript(key: Key) -&gt; Value {<br>&gt; &gt;&gt;&gt;&gt;&gt;                       get { return dictionary[key]! }<br>&gt; &gt;&gt;&gt;&gt;&gt;                       set { dictionary[key] = newValue }<br>&gt; &gt;&gt;&gt;&gt;&gt;               }<br>&gt; &gt;&gt;&gt;&gt;&gt;       }<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; What I would do is borrow the &quot;accessors&quot; concept from the<br>&gt; property behaviors proposal and extend it so that it supported both<br>&gt; functions and variables.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Wouldn&#39;t accessor just be a redundant keyword here? Currently enums<br>&gt; do<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; not support stored properties, so I guess there is no extra need to<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; mark properties with any special keyword.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; The keyword is mainly to indicate the unusual syntax at the<br>&gt; definition site, where you only have to specify the name of the accessor<br>&gt; you&#39;re defining, not a `func` or `var` keyword, a return type, or even<br>&gt; parameter names. (Like `willSet`, there&#39;s a default parameter name you can<br>&gt; use.) Secondarily, though, I think it&#39;s helpful to indicate very explicitly<br>&gt; that this is not an ordinary method or property definition, even if the<br>&gt; compiler could perhaps sort things out without it. `accessor` is something<br>&gt; a user can Google if they&#39;ve never seen it before.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Property accessors might work for enums with associated values, but<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; not so well without them.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; The two have nothing to do with each other. I showed your planets<br>&gt; example, which has no associated values but uses accessors just fine.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; --<br>&gt; &gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt; &gt;&gt;&gt;&gt;&gt; Architechies<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/b787c179/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 31, 2016 at 02:00:00pm</p></header><div class="content"><p>A huge +1 on the syntax change, which I think is a colossal improvement over the current situation and adds a lot of clarity to enum declarations.<br></p><p>Neutral on the necessity to add actual stored properties to the enums. If the new syntax were merely syntactic sugar that would effectively generate the switch statements behind the scenes, that would work for me too, and would probably offend fewer people.<br></p><p>Charles<br></p><p>&gt; On May 31, 2016, at 9:17 AM, Jānis Kiršteins via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I wrote a proposal draft:<br>&gt; <br>&gt; # Enum case stored properties<br>&gt; <br>&gt; * Proposal: TBD<br>&gt; * Author: [Janis Kirsteins](https://github.com/kirsteins)<br>&gt; * Status: TBD<br>&gt; * Review manager: TBD<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; This proposal allows each enum case to have stored properties.<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; Enums cases can have a lot of constant (or variable) static values<br>&gt; associated with it. For example, planets can have mass, radius, age,<br>&gt; closest star etc. Currently there is no way to set or get those values<br>&gt; easily.<br>&gt; <br>&gt; Example below shows that is hard to read and manage static associated<br>&gt; values with each case. It is hard to add or remove case as it would<br>&gt; require to add or remove code in four different places in file. Also<br>&gt; static associated value like `UIBezierPath` is recreated each time the<br>&gt; property is computed while it&#39;s constant.<br>&gt; <br>&gt; ```swift<br>&gt; enum Suit {<br>&gt;    case spades<br>&gt;    case hearts<br>&gt;    case diamonds<br>&gt;    case clubs<br>&gt; <br>&gt;    var simpleDescription: String {<br>&gt;        switch self {<br>&gt;        case .spades:<br>&gt;            return &quot;spades&quot;<br>&gt;        case .hearts:<br>&gt;            return &quot;hearts&quot;<br>&gt;        case .diamonds:<br>&gt;            return &quot;diamonds&quot;<br>&gt;        case .clubs:<br>&gt;            return &quot;clubs&quot;<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt;    var color: UIColor {<br>&gt;        switch self {<br>&gt;        case .spades:<br>&gt;            return .blackColor()<br>&gt;        case .hearts:<br>&gt;            return .redColor()<br>&gt;        case .diamonds:<br>&gt;            return .redColor()<br>&gt;        case .clubs:<br>&gt;            return .blackColor()<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt;    var symbol: String {<br>&gt;        switch self {<br>&gt;        case .spades:<br>&gt;            return &quot;♠&quot;<br>&gt;        case .hearts:<br>&gt;            return &quot;♥&quot;<br>&gt;        case .diamonds:<br>&gt;            return &quot;♦&quot;<br>&gt;        case .clubs:<br>&gt;            return &quot;♣&quot;<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt;    var bezierPath: UIBezierPath {<br>&gt;        switch self {<br>&gt;        case .spades:<br>&gt;            let path = UIBezierPath()<br>&gt;            // omitted lines ...<br>&gt;            return path<br>&gt;        case .hearts:<br>&gt;            let path = UIBezierPath()<br>&gt;            // omitted lines ...<br>&gt;            return path<br>&gt;        case .diamonds:<br>&gt;            let path = UIBezierPath()<br>&gt;            // omitted lines ...<br>&gt;            return path<br>&gt;        case .clubs:<br>&gt;            let path = UIBezierPath()<br>&gt;            // omitted lines ...<br>&gt;            return path<br>&gt;        }<br>&gt;    }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; Support stored properties for enum cases just as each case were an<br>&gt; instance. Case properties are initialized block after each case<br>&gt; declaration.<br>&gt; <br>&gt; ```swift<br>&gt; enum Suit {<br>&gt;    let simpleDescription: String<br>&gt;    let color: UIColor<br>&gt;    let symbol: String<br>&gt;    let bezierPath: UIBezierPath<br>&gt; <br>&gt;    case spades {<br>&gt;        simpleDescription = &quot;spades&quot;<br>&gt;        color = .blackColor()<br>&gt;        symbol = &quot;♠&quot;<br>&gt;        let bezierPath = UIBezierPath()<br>&gt;        // omitted lines ...<br>&gt;        self.bezierPath = bezierPath<br>&gt;    }<br>&gt; <br>&gt;    case hearts {<br>&gt;        simpleDescription = &quot;hearts&quot;<br>&gt;        color = .redColor()<br>&gt;        symbol = &quot;♥&quot;<br>&gt;        let bezierPath = UIBezierPath()<br>&gt;        // omitted lines ...<br>&gt;        self.bezierPath = bezierPath<br>&gt;    }<br>&gt; <br>&gt;    case diamonds {<br>&gt;        simpleDescription = &quot;diamonds&quot;<br>&gt;        color = .redColor()<br>&gt;        symbol = &quot;♦&quot;<br>&gt;        let bezierPath = UIBezierPath()<br>&gt;        // omitted lines ...<br>&gt;        self.bezierPath = bezierPath<br>&gt;    }<br>&gt; <br>&gt;    case clubs {<br>&gt;        simpleDescription = &quot;clubs&quot;<br>&gt;        color = .blackColor()<br>&gt;        symbol = &quot;♣&quot;<br>&gt;        let bezierPath = UIBezierPath()<br>&gt;        // omitted lines ...<br>&gt;        self.bezierPath = bezierPath<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; let symbol = Suit.spades.symbol // &quot;♠&quot;<br>&gt; ```<br>&gt; <br>&gt; The proposed solution improves:<br>&gt; - Readability as cases are closer with their related data;<br>&gt; - Improves code maintainability as a case can be removed or added in one place;<br>&gt; - Improved performance as there is no need to recreate static values;<br>&gt; - ~30% less lines of code in given example.<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; #### Stored properties<br>&gt; <br>&gt; Enum stored properties are supported the same way they are supported<br>&gt; for structs can classes. Unlike enum associated values, stored<br>&gt; properties are static to case and are shared for the same case.<br>&gt; <br>&gt; Properties are accessed:<br>&gt; ```swift<br>&gt; let simpleDescription = Suit.spades.simpleDescription<br>&gt; ```<br>&gt; <br>&gt; Mutable properties can be set:<br>&gt; ```swift<br>&gt; Suit.spades.simpleDescription = &quot;new simple description&quot;<br>&gt; ```<br>&gt; <br>&gt; #### Initialization<br>&gt; <br>&gt; If enum has uninitialized stored property it must be initialized in a<br>&gt; block after each case declaration. The block work the same way as<br>&gt; struct initialization. At the end of initialization block all<br>&gt; properties must be initialized.<br>&gt; <br>&gt; ```swift<br>&gt; enum Suit {<br>&gt;    var simpleDescription: String<br>&gt; <br>&gt;    case spades {<br>&gt;        simpleDescription = &quot;spades&quot;<br>&gt;    }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; Initialization block can be combine with use of `rawValue`:<br>&gt; <br>&gt; ```swift<br>&gt; enum Suit: Int {<br>&gt;    var simpleDescription: String<br>&gt; <br>&gt;    case spades = 1 {<br>&gt;        simpleDescription = &quot;spades&quot;<br>&gt;    }<br>&gt; }<br>&gt; ```<br>&gt; or associated values of the case:<br>&gt; <br>&gt; ```swift<br>&gt; enum Suit {<br>&gt;    var simpleDescription: String<br>&gt; <br>&gt;    case spades(Int) {<br>&gt;        simpleDescription = &quot;spades&quot;<br>&gt;    }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; Stored properties for enums are not currently not supported, so there<br>&gt; is no impact on existing code.<br>&gt; <br>&gt; ## Alternatives considered<br>&gt; <br>&gt; - Use labeled tuple as `rawValue` of the enum case. This approach is<br>&gt; not compatible as it conflicts with intention of `rawValue` of Swift<br>&gt; enum;<br>&gt; - Use per case initializer like [Java<br>&gt; Enum](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html).<br>&gt; Swift enum uses custom initializer syntax to setup instances, not<br>&gt; cases. So this approach is not suitable for Swift.<br>&gt; <br>&gt; <br>&gt; On Sun, May 29, 2016 at 3:42 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt; I think that&#39;s the case with enums. You&#39;re changing their current behaviour of only having stored values to one in which it&#39;s computed (even if only once and then stored). Enums are IMO something that have a static value you know beforehand and can count on. That&#39;s why I&#39;m not fond of the accessor proposal. Otherwise I think we&#39;re transforming enums into a closed set of struct instances and one could do that already by using a private init.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 29 May 2016, at 3:38 am, Jānis Kiršteins via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with the argument about use of &quot;where&quot;, not replacing the raw<br>&gt;&gt;&gt; value and having some kind of initialization block. But I cannot see<br>&gt;&gt;&gt; why &quot;accessors&quot; concept is any better than stored properties to solve<br>&gt;&gt;&gt; the particular problem. The &quot;accessors&quot; concept has much wider scope<br>&gt;&gt;&gt; than enums and is a separate proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sat, May 28, 2016 at 11:39 PM, Brent Royal-Gordon<br>&gt;&gt;&gt; &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; - Abusing rawValue is just that: an abuse.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My original proposal does not replace rawValue and is compatible with it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `rawValue` has a different purpose from how you&#39;re using it. It&#39;s supposed to allow you to convert your type to some other *equivalent* type, like an equivalent integer or string. Moreover, it&#39;s supposed to allow you to *reconstruct* the instance from the raw value—remember, `RawRepresentable` has an `init(rawValue:)` requirement.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is *not* supposed to be an ancillary bag of information on the side. You&#39;re cramming a square peg into a round hole here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (Also, if you use `rawValue` for an ancillary bag of information, that means you *can&#39;t* use it on the same type for its intended purpose. For instance, you would not be able to assign numbers to your Planet enum&#39;s cases to help you serialize them or bridge them to Objective-C. That&#39;s not good.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Using `where` just doesn&#39;t match the use of `where` elsewhere in the language; everywhere else, it&#39;s some kind of condition.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It is also used in generic type constraints. Plus it reads like human<br>&gt;&gt;&gt;&gt;&gt; language: `case mercury where (mass: 3.303e+23, radius: 2.4397e6)`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But a generic constraint is also a type of condition: it specifies types which are permitted and divides them from types that are not.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is *not* a condition. It&#39;s not anything like a condition. It&#39;s simply not consistent with anything else in the language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Dictionaries are the most straightforward way to handle this with the current language, but their lack of exhaustiveness checking is a problem.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Dictionaries can be used as workaround, but they cannot (lack of<br>&gt;&gt;&gt;&gt;&gt; exhaustiveness) solve the problem.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree that they&#39;re a halfway solution.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If `ValuesEnumerable` were to be accepted (and to have a generic requirement for its `allValues` property), you could write a Dictionary-like type which ensured at initialization time that it was exhaustive. That&#39;s not as good as compile time, but it&#39;s not bad—sort of a three-quarters solution.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       struct ExhaustiveDictionary&lt;Key: Hashable, Value where Key: ValuesEnumerable&gt;: Collection, DictionaryLiteralConvertible {<br>&gt;&gt;&gt;&gt;               private var dictionary: [Key: Value]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;               init(dictionaryLiteral elements: (Key, Value)...) {<br>&gt;&gt;&gt;&gt;                       dictionary = [:]<br>&gt;&gt;&gt;&gt;                       for (k, v) in elements {<br>&gt;&gt;&gt;&gt;                               dictionary[k] = v<br>&gt;&gt;&gt;&gt;                       }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;                       if dictionary.count != Key.allValues.count {<br>&gt;&gt;&gt;&gt;                               let missingKeys = Key.allValues.filter { dictionary[$0] == nil }<br>&gt;&gt;&gt;&gt;                               preconditionFailure(&quot;ExhaustiveDictionary is missing elements from \(Key.self): \(missingKeys)&quot;)<br>&gt;&gt;&gt;&gt;                       }<br>&gt;&gt;&gt;&gt;               }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;               var startIndex: Dictionary.Index {<br>&gt;&gt;&gt;&gt;                       return dictionary.startIndex<br>&gt;&gt;&gt;&gt;               }<br>&gt;&gt;&gt;&gt;               var endIndex: Dictionary.Index {<br>&gt;&gt;&gt;&gt;                       return dictionary.endIndex<br>&gt;&gt;&gt;&gt;               }<br>&gt;&gt;&gt;&gt;               subscript(index: Dictionary.Index) -&gt; (Key, Value) {<br>&gt;&gt;&gt;&gt;                       return dictionary[index]<br>&gt;&gt;&gt;&gt;               }<br>&gt;&gt;&gt;&gt;               func index(after i: Dictionary.Index) -&gt; Dictionary.Index {<br>&gt;&gt;&gt;&gt;                       return dictionary.index(after: i)<br>&gt;&gt;&gt;&gt;               }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;               subscript(key: Key) -&gt; Value {<br>&gt;&gt;&gt;&gt;                       get { return dictionary[key]! }<br>&gt;&gt;&gt;&gt;                       set { dictionary[key] = newValue }<br>&gt;&gt;&gt;&gt;               }<br>&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What I would do is borrow the &quot;accessors&quot; concept from the property behaviors proposal and extend it so that it supported both functions and variables.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Wouldn&#39;t accessor just be a redundant keyword here? Currently enums do<br>&gt;&gt;&gt;&gt;&gt; not support stored properties, so I guess there is no extra need to<br>&gt;&gt;&gt;&gt;&gt; mark properties with any special keyword.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The keyword is mainly to indicate the unusual syntax at the definition site, where you only have to specify the name of the accessor you&#39;re defining, not a `func` or `var` keyword, a return type, or even parameter names. (Like `willSet`, there&#39;s a default parameter name you can use.) Secondarily, though, I think it&#39;s helpful to indicate very explicitly that this is not an ordinary method or property definition, even if the compiler could perhaps sort things out without it. `accessor` is something a user can Google if they&#39;ve never seen it before.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Property accessors might work for enums with associated values, but<br>&gt;&gt;&gt;&gt;&gt; not so well without them.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The two have nothing to do with each other. I showed your planets example, which has no associated values but uses accessors just fine.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 31, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt;    case spades {<br>&lt;snip&gt;<br>&gt;        let bezierPath = UIBezierPath()<br></p><p>Does each instance of `.spades` have a *separate* UIBezierPath, or do all instances of `.spades` share one? If it&#39;s the former, I have strong doubts you&#39;ll actually get this through. If it&#39;s the latter, that isn&#39;t really what this syntax suggests is happening.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44a036cc421ee97534c54653a233db93?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Jānis Kiršteins</string> &lt;janis.kirsteins at gmail.com&gt;<p>June  1, 2016 at 10:00:00am</p></header><div class="content"><p>UIBezierPath is shared for all instances of the enum case. So stored<br>properties are stored per case, not per instance (you have associated<br>values for per instance values).<br></p><p>&gt; that isn&#39;t really what this syntax suggests is happening<br></p><p>Please explain what makes you think that way.<br></p><p><br>On Tue, May 31, 2016 at 11:52 PM, Brent Royal-Gordon<br>&lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;    case spades {<br>&gt; &lt;snip&gt;<br>&gt;&gt;        let bezierPath = UIBezierPath()<br>&gt;<br>&gt; Does each instance of `.spades` have a *separate* UIBezierPath, or do all instances of `.spades` share one? If it&#39;s the former, I have strong doubts you&#39;ll actually get this through. If it&#39;s the latter, that isn&#39;t really what this syntax suggests is happening.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  1, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; UIBezierPath is shared for all instances of the enum case. So stored<br>&gt; properties are stored per case, not per instance (you have associated<br>&gt; values for per instance values).<br>&gt; <br>&gt;&gt; that isn&#39;t really what this syntax suggests is happening<br>&gt; <br>&gt; Please explain what makes you think that way.<br></p><p>Because you wrote `let bezierPath = UIBezierPath()` in the middle of a type definition, and in all other types, you would get a new bezier path for each instance.<br></p><p>	struct Struct {<br>		let bezierPath = UIBezierPath()		// per instance<br>	}<br>	class Class {<br>		let bezierPath = UIBezierPath()		// per instance<br>	}<br>	func function() {<br>		let bezierPath = UIBezierPath()		// per call<br>	}<br>	enum Enum {<br>		case aCase {<br>			let bezierPath = UIBezierPath()	// shared?!?!<br>		}<br>	}<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44a036cc421ee97534c54653a233db93?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Jānis Kiršteins</string> &lt;janis.kirsteins at gmail.com&gt;<p>June  2, 2016 at 09:00:00am</p></header><div class="content"><p>As stated before it supposed to be per case initialization. You cannot<br>really have this analogy with other types as they have type and<br>instance while enums have type, case and instance. But consider this:<br></p><p>struct Struct {<br>    static let bezierPath: UIBezierPath // shared<br></p><p>    static func initialize() {<br>        bezierPath = UIBezierPath()<br>    }<br>}<br></p><p>On Thu, Jun 2, 2016 at 12:18 AM, Brent Royal-Gordon<br>&lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; UIBezierPath is shared for all instances of the enum case. So stored<br>&gt;&gt; properties are stored per case, not per instance (you have associated<br>&gt;&gt; values for per instance values).<br>&gt;&gt;<br>&gt;&gt;&gt; that isn&#39;t really what this syntax suggests is happening<br>&gt;&gt;<br>&gt;&gt; Please explain what makes you think that way.<br>&gt;<br>&gt; Because you wrote `let bezierPath = UIBezierPath()` in the middle of a type definition, and in all other types, you would get a new bezier path for each instance.<br>&gt;<br>&gt;         struct Struct {<br>&gt;                 let bezierPath = UIBezierPath()         // per instance<br>&gt;         }<br>&gt;         class Class {<br>&gt;                 let bezierPath = UIBezierPath()         // per instance<br>&gt;         }<br>&gt;         func function() {<br>&gt;                 let bezierPath = UIBezierPath()         // per call<br>&gt;         }<br>&gt;         enum Enum {<br>&gt;                 case aCase {<br>&gt;                         let bezierPath = UIBezierPath() // shared?!?!<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  2, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; As stated before it supposed to be per case initialization. You cannot<br>&gt; really have this analogy with other types as they have type and<br>&gt; instance while enums have type, case and instance.<br></p><p>No. If structs have just type and instance, then so do enums.<br></p><p>Cases in enums are analogous to stored properties in structs: they are a means of organizing and representing concrete storage. They are not first-class entities in the way that types and instances are. Much mischief comes from thinking of cases as pseudo-types, or as some sort of peer to a type.<br></p><p>&gt; But consider this:<br>&gt; <br>&gt; struct Struct {<br>&gt;    static let bezierPath: UIBezierPath // shared<br>&gt; <br>&gt;    static func initialize() {<br>&gt;        bezierPath = UIBezierPath()<br>&gt;    }<br>&gt; }<br></p><p>Yes, because there&#39;s a `static` keyword on that declaration. That marks it as something different from an ordinary `let`. Similarly, part of the idea of my use of accessors is that the `accessor` keyword marks it as something different from an ordinary `var`.<br></p><p>(Also, you shouldn&#39;t use `initialize()` in Swift; you should set the variable directly. Also also, I&#39;m pretty sure that wouldn&#39;t work at all, because `initialize()` is a normal method, not an initializer, and `bezierPath` is a constant.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44a036cc421ee97534c54653a233db93?s=50"></div><header><strong>[Proposal] Enums with static stored properties for each case</strong> from <string>Jānis Kiršteins</string> &lt;janis.kirsteins at gmail.com&gt;<p>June  2, 2016 at 01:00:00pm</p></header><div class="content"><p>I think you misunderstood my proposed syntax. To clarify:<br></p><p>enum Suit {<br>    let bezierPath: UIBezierPath // Stored property declaration<br></p><p>    case spades {<br>        let bezierPath = UIBezierPath() // Declare and initialize and<br>local variable, this is not stored property declaration<br>        // add drawing commands to bezierPath<br>        self.bezierPath = bezierPath // Initialize stored property<br>with local variable. Stored property is shared among cases<br>    }<br>}<br></p><p><br>I agree that cases should not be treated as pseudo-type, I am not<br>proposing that. What I am proposing is the that enum instance<br>behaviour and data can be very dependent of it case. And that there<br>should be easier and clearer ways to configure that using stored<br>properties.<br></p><p><br>On Thu, Jun 2, 2016 at 10:26 AM, Brent Royal-Gordon<br>&lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; As stated before it supposed to be per case initialization. You cannot<br>&gt;&gt; really have this analogy with other types as they have type and<br>&gt;&gt; instance while enums have type, case and instance.<br>&gt;<br>&gt; No. If structs have just type and instance, then so do enums.<br>&gt;<br>&gt; Cases in enums are analogous to stored properties in structs: they are a means of organizing and representing concrete storage. They are not first-class entities in the way that types and instances are. Much mischief comes from thinking of cases as pseudo-types, or as some sort of peer to a type.<br>&gt;<br>&gt;&gt; But consider this:<br>&gt;&gt;<br>&gt;&gt; struct Struct {<br>&gt;&gt;    static let bezierPath: UIBezierPath // shared<br>&gt;&gt;<br>&gt;&gt;    static func initialize() {<br>&gt;&gt;        bezierPath = UIBezierPath()<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;<br>&gt; Yes, because there&#39;s a `static` keyword on that declaration. That marks it as something different from an ordinary `let`. Similarly, part of the idea of my use of accessors is that the `accessor` keyword marks it as something different from an ordinary `var`.<br>&gt;<br>&gt; (Also, you shouldn&#39;t use `initialize()` in Swift; you should set the variable directly. Also also, I&#39;m pretty sure that wouldn&#39;t work at all, because `initialize()` is a normal method, not an initializer, and `bezierPath` is a constant.)<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
