<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/357b710213d3c0e01356f7c90f78b9f2?s=50"></div><header><strong>[Proposal]: Drastically improve searching API (indexOf(…)) of CollectionType</strong> from <string>Vincent Esche</string> &lt;regexident.mailinglists at gmail.com&gt;<p>January  4, 2016 at 04:00:00pm</p></header><div class="content"><p>After having had this code laying around on my Mac since 6/26/15 (waiting for Swift to go open source)<br>I figured it’s about damn time I submit the actual RFC for it. So without further ado…<br></p><p>One of the areas where Swift’s stdlib is still quite lacking is searching.<br>Which is a shame as searching (along with indexing) might be among<br>the most important tasks of computer science/software development.<br>One might not need fast collection searches for writing a banal fart or flashlight app,<br>but almost every other app is likely to benefit from having a proper searching API.<br></p><p>So I’d like to fix that.<br></p><p>Attached you find a full RFC along with the full and functional source code to make it happen.<br></p><p>I’d love to hear your opinion on this and will be more than happy to answer questions.<br></p><p>Rendered Version + Full Implementation: https://gist.github.com/regexident/2b7531bd748f57679671 &lt;https://gist.github.com/regexident/2b7531bd748f57679671&gt;<br>(The code is tested using Quick/Nimble. Tests would thus have to be ported to Swift’s XCTest.)<br></p><p>- Vincent<br></p><p>&gt; Markdown-dump for<br>&gt; <br>&gt; # Improved Collection Search<br>&gt; <br>&gt; * Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md)<br>&gt; * Author(s): [Vincent Esche](https://github.com/regexident)<br>&gt; * Status: **Review**<br>&gt; * Review manager: TBD<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; This RFC proposes an extension to the currently rather limited and linear searching API of `CollectionType`, that is `indexOf(element:)` and `indexOf(predicate:)`.<br>&gt; It proposes the backwards-compatible refactoring of those existing methods as well as the introduction of a view-based ensemble of methods for efficient binary-search.<br>&gt; <br>&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution)<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; Indexing of and searching in data is a big deal in software development. As such it is crucial to have capable means of doing so in a language that aspires to be a highly performant programming language.<br>&gt; <br>&gt; Swift&#39;s current API for searching is basically limited to these two methods on `CollectionType`:<br>&gt; <br>&gt; &gt; ```swift<br>&gt; &gt; func indexOf(element: Self.Generator.Element) -&gt; Self.Index?<br>&gt; &gt; ```<br>&gt; &gt; Returns the first index where value appears in self or nil if value is not found.<br>&gt; &gt;<br>&gt; &gt; **Complexity**: `O(self.count)`.<br>&gt; <br>&gt; and:<br>&gt; <br>&gt; &gt; ```swift<br>&gt; &gt; func indexOf(@noescape predicate: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.Index?<br>&gt; &gt; ```<br>&gt; &gt; Returns the first index where predicate returns true for the corresponding value, or nil if such value is not found.<br>&gt; &gt; <br>&gt; &gt; **Complexity**: `O(self.count)`.<br>&gt; <br>&gt; The author sees a couple of issue with these two methods:<br>&gt; <br>&gt; 1. They do not provide an option for restricting the &quot;haystack&quot; to a certain `range` of `self`.<br>&gt; 2. They do not provide a fast (`O(log2(self.count))`) path for sorted collections.<br>&gt; 3. They should not be limited to `CollectionType` but instead be moved to `Indexable`.<br>&gt; <br>&gt; In many situations it is desirable to perform fast searches on sorted collections instead of having to fall back to naïve linear searches.<br>&gt; <br>&gt; Further more while a single `index` might be the most common subject of interest, there are many scenarios where a `range` or `count` of matches are of more use.<br>&gt; <br>&gt; And anyone who is writing a custom ordered collection type will eventually want to find the insertion index for a given element and will thus end up writing some variant of `lowerBoundOf(…)` or `upperBoundOf(…)` (upon which all the other methods can be implemented, actually).<br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; The author proposes:<br>&gt; <br>&gt; 1. A backwards-compatible refactoring of `CollectionType.indices`, moving it to `Indexable`.<br>&gt; <br>&gt; 2. A backwards-compatible refactoring of `indexOf(…)` (adding optional `range:` and moving it to `Indexable`).<br>&gt; <br>&gt; 3. The addition of `rangeOf(…)`, `countOf(…)` and `isSorted(…)` to `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt; <br>&gt; 4. The introduction of a `BinarySearchView` on `Indexable`, allowing for fast (`O(log2(self.count))`) searches on `Indexable` via `indexOf(…)`, `rangeOf(…)`, `countOf(…)`, `lowerBoundOf(…)`, `upperBoundOf(…)` without cluttering `Indexable`&#39;s interface.<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; ### `CollectionType.indices`:<br>&gt; <br>&gt; The author proposes the relocation of `.indices` from `CollectionType` to `Indexable`:<br>&gt; <br>&gt; ```swift<br>&gt; extension Indexable {<br>&gt;     /// Return the range of valid index values.<br>&gt;     ///<br>&gt;     /// The result&#39;s `endIndex` is the same as that of `self`.  Because<br>&gt;     /// `Range` is half-open, iterating the values of the result produces<br>&gt;     /// all valid subscript arguments for `self`, omitting its `endIndex`.<br>&gt;     public var indices: Range&lt;Self.Index&gt; { get }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; After all all it does is provide a convenience method for generating a Range from its `startIndex` and `endIndex`. There is no need for `self` to be a `CollectionType` for this.<br>&gt; <br>&gt; This change should not break any existing code as it generalizes the property.<br>&gt; <br>&gt; ### `Indexable` of `Comparable` elements:<br>&gt; <br>&gt; The author proposes the addition of the following method on `Indexable where Element : Comparable`:<br>&gt; <br>&gt; ```swift<br>&gt; extension Indexable where Index: RandomAccessIndexType, _Element: Comparable {<br>&gt; 	/// Return true iff all elements in `self` within `range` are sorted according to `isOrderedBefore`.<br>&gt; 	///<br>&gt; 	/// - Complexity: O(`self.count`)<br>&gt; 	public func isSorted(range: Range&lt;Index&gt;? = nil) -&gt; Bool<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; This method would perform a linear scan of the `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt; <br>&gt; An actual implementation of these methods can be found in `Indexable.swift`.<br>&gt; <br>&gt; ### `Indexable` of `Equatable ` elements:<br>&gt; <br>&gt; The author proposes the addition of the following method on `Indexable where Element : Equatable`:<br>&gt; <br>&gt; ```swift<br>&gt; extension Indexable where Index : RandomAccessIndexType, _Element : Equatable {<br>&gt; <br>&gt;     /// Returns the first index where `element` appears in `self`<br>&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`self.count`)<br>&gt;     public func indexOf(element: _Element, range: Range&lt;Index&gt;? = default) -&gt; Self.Index?<br>&gt; <br>&gt;     /// Returns the first range where `element` appears in `self`<br>&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`self.count`)<br>&gt;     public func rangeOf(element: _Element, range: Range&lt;Index&gt;? = default) -&gt; Range&lt;Self.Index&gt;?<br>&gt; <br>&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;     /// within range `range` or `nil` if such an element is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`self.count`)<br>&gt;     public func countOf(element: _Element, range: Range&lt;Index&gt;? = default) -&gt; Int<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; These methods would perform a linear scan of the `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt; <br>&gt; An actual implementation of these methods can be found in `Indexable.swift`.<br>&gt; <br>&gt; ### `Indexable` of any elements:<br>&gt; <br>&gt; The author proposes the addition of the following methods on `Indexable`:<br>&gt; <br>&gt; ```swift<br>&gt; extension Indexable where Index : RandomAccessIndexType {<br>&gt; <br>&gt;     /// Returns the first index where an element appears in `self`<br>&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`self.count`)<br>&gt;     public func indexOf(range: Range&lt;Index&gt;? = default, @noescape predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Self.Index?<br>&gt; <br>&gt;     /// Returns the first range where an element appears in `self`<br>&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`self.count`)<br>&gt;     public func rangeOf(range: Range&lt;Index&gt;? = default, @noescape predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Range&lt;Self.Index&gt;?<br>&gt; <br>&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`self.count`)<br>&gt;     public func countOf(range: Range&lt;Index&gt;? = default, @noescape predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Int<br>&gt; <br>&gt;     /// Return true iff all elements in `self` within `range` are sorted according to `isOrderedBefore`.<br>&gt;     /// <br>&gt;     /// - Complexity: O(`self.count`)<br>&gt;     public func isSorted(range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (_Element, _Element) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; These methods would perform a linear scan of the `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt; <br>&gt; An actual implementation of these methods can be found in `Indexable.swift`.<br>&gt; <br>&gt; **Note**: For explanation of and reasoning behind the `lensView:` argument as well as the distinction between `T` and `Base._Element`, see below.<br>&gt; <br>&gt; ### `Indexable.binarySearchView(validateAgainst:?)`:<br>&gt; <br>&gt; The author proposes the addition of a `binarySearchView(validateAgainst:?)` method on `Indexable` for obtaining a specialized search view for performing searches with O(`log2(self.count)`) complexity:<br>&gt; <br>&gt; ```swift<br>&gt; extension Indexable where Index: RandomAccessIndexType {<br>&gt; 	/// Create a view into a sorted indexable that allows access within `bounds`.<br>&gt; 	///<br>&gt; 	/// - Complexity: O(`self.count`) if a validation closure is provided, otherwise O(`1`).<br>&gt; 	public func binarySearchView(validateAgainst isOrderedBefore: ((_Element, _Element) -&gt; Bool)? = nil) -&gt; BinarySearchView&lt;Self&gt;<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; ### `BinarySearchView&lt;T: Indexable&gt;`:<br>&gt; <br>&gt; The author proposes the introduction of a `BinarySearchView` struct with the following interface:<br>&gt; <br>&gt; ```swift<br>&gt; public struct BinarySearchView&lt;Base : Indexable where Base.Index : RandomAccessIndexType&gt; : Indexable {<br>&gt;     public typealias Index = Base.Index<br>&gt; <br>&gt;     public var startIndex: Base.Index { get }<br>&gt; <br>&gt;     public var endIndex: Base.Index { get }<br>&gt; <br>&gt;     public subscript (position: Index) -&gt; Base._Element { get }<br>&gt; <br>&gt;     /// Create a view into a sorted collection `base` that allows access within `bounds`.<br>&gt;     ///<br>&gt;     /// - Complexity: O(1).<br>&gt;     public init(base: Base, validateAgainst isOrderedBefore: ((Base._Element, Base._Element) -&gt; Bool)? = default)<br>&gt; <br>&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;     /// `lensView(element) &lt; value` evaluates to false or `nil` if `element` is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;     public func lowerBoundOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Base.Index<br>&gt; <br>&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;     /// `value &lt; lensView(element)` evaluates to true or `nil` if `element` is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;     public func upperBoundOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: ((T, T) -&gt; Bool) = default, @noescape lensView: Base._Element -&gt; T) -&gt; Base.Index<br>&gt; <br>&gt;     /// Returns the first index where an element appears in `self`<br>&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;     public func indexOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Base.Index?<br>&gt; <br>&gt;     /// Returns the range where an element appears in `self`<br>&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;     public func rangeOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Range&lt;Base.Index&gt;?<br>&gt; <br>&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;     public func countOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Int<br>&gt; <br>&gt;     internal let _base: Base<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; As well as the following extension for `Indexable where Element: Comparable`:<br>&gt; <br>&gt; ```swift<br>&gt; extension BinarySearchView where Base._Element : Comparable {<br>&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;     /// `… &lt; element` evaluates to false or `nil` if `element` is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;     public func lowerBoundOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Base.Index<br>&gt; <br>&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;     /// `element &lt; …` evaluates to true or `nil` if `element` is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;     public func upperBoundOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Base.Index<br>&gt; <br>&gt;     /// Returns the first index where `element` appears in `self`<br>&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;     public func indexOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Base.Index?<br>&gt; <br>&gt;     /// Returns the range where `element` appears in `self`<br>&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;     public func rangeOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Range&lt;Base.Index&gt;?<br>&gt; <br>&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;     public func countOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Int<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; These methods would perform a linear scan of the `Indexable` with a TIME complexity of `O(log2(self.count))`.<br>&gt; <br>&gt; An actual implementation of these methods can be found in `BinarySearchView.swift`.<br>&gt; <br>&gt; ### Why `lensView`?<br>&gt; <br>&gt; Let&#39;s assume one had a collection of Persons like this:<br>&gt; <br>&gt; ```swift<br>&gt; struct Person {<br>&gt;     let name: String<br>&gt;     let age: Int<br>&gt; }<br>&gt; <br>&gt; let persons: [Person] = [ … ]<br>&gt; ```<br>&gt; <br>&gt; Now let&#39;s assume one wanted to find the first person that&#39;s called `John Doe`. One could either change `Person` to conform to `Equatable`, allowing `indexOf(element:)` to be called on `persons`. Now that was easy, wasn&#39;t it?<br>&gt; <br>&gt; Fine, but what if one wanted to search `Person`s by both their `name` or their `age` depending on the given use case? You&#39;re out of luck now.<br>&gt; <br>&gt; Luckily there is a variant of `indexOf(…)` called `indexOf(predicate:)` that is available for any type of `Element` regardless of its conformance to `Equatable`:<br>&gt; <br>&gt; ```swift<br>&gt; let searchView = persons.binarySearchView()<br>&gt; let index = persons.indexOf { $0.name == &quot;John Doe&quot; }<br>&gt; ```<br>&gt; <br>&gt; Unfortunately however such a `predicate` cannot be used when searching for an element&#39;s property in a sorted(!) collection or a collection of non-`Comparable` elements within a TIME complexity of `O(log2(self.count))` as binary search uses `&lt;` instead of `==` internally and as the &quot;needle&quot; gets passed as both the first (in `indexOf(…)` itself) and second argument (in `lowerBoundOf(…)` which gets called by `indexOf(…)`) to the operator, one cannot simply change `predicate: (E) -&gt; Bool` to `isOrderedBefore: (V, E) -&gt; Bool` as that would result in a type mismatch (`(V, E)` vs. `(E, V)`).<br>&gt; <br>&gt; The use of `lensView` however allows one to do just that without making a mess.<br>&gt; <br>&gt; ```swift<br>&gt; let searchView = persons.binarySearchView() // sorted!<br>&gt; let index = searchView.indexOf(&quot;John Doe&quot;) { $0.name }<br>&gt; ```<br>&gt; <br>&gt; The `lensView` works similarly to how keypaths work in Objective-C, just type-safe.<br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; The author proposes:<br>&gt; <br>&gt; 1. Moving `CollectionType.indices` to `Indexable` should not cause any issues with existing code.<br>&gt; <br>&gt; 2. Changing `indexOf(element:)` to `indexOf(element:range:?)` should not cause any issues with existing code as the `range` argument is optional and the default behaves like it used to.<br>&gt; <br>&gt; 2. Changing `indexOf(predicate:)` to `indexOf(range:?predicate:)` should not cause any issues with existing code either, as the `range` argument is optional and the default behaves like it used to. Swift&#39;s trailing-closure magic allows `indexOf(predicate: …)` to still properly map to `indexOf(range: nil, predicate: …)`.<br>&gt; <br>&gt; 3. The addition of `rangeOf(…)`, `countOf(…)` and `isSorted(…)` to `Indexable` do not conflict with any existing API.<br>&gt; <br>&gt; 4. The introduction of a `BinarySearchView` on `Indexable` does not conflict with any existing API.<br>&gt; <br>&gt; ## Alternatives considered<br>&gt; <br>&gt; The author&#39;s initial approach was to implement all methods on Indexable. This however required all methods to either be provided in two variants (one for unsorted, one for sorted `Indexable`s):<br>&gt; <br>&gt; ```swift<br>&gt; final public func indexOf(element: _Element, range: Range&lt;Index&gt;? = nil) -&gt; Index? {<br>&gt; 	return …<br>&gt; }<br>&gt; <br>&gt; final public func sortedIndexOf(element: _Element, range: Range&lt;Index&gt;? = nil) -&gt; Index? {<br>&gt; 	return …<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; Or require the introduction of an additional argument:<br>&gt; <br>&gt; ```swift<br>&gt; final public func indexOf(element: _Element, range: Range&lt;Index&gt;? = nil, isSorted: Bool = true) -&gt; Index? {<br>&gt;     if isSorted {<br>&gt;         return …<br>&gt;     } else {<br>&gt;         return …<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; It also would have cluttered `Indexable` with methods such as `lowerBoundOf` and `upperBoundOf`, which are only ever applicable when `self` is sorted accordingly. The introduction of a dedicated BinarySearchView fixes these issues.<br>&gt; <br>&gt; One also would have had to switch from `predicate: (T) -&gt; Bool` to `isOrderedBefore: (T, T) -&gt; Bool` for all methods for the second unified API alternative.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/8ac8984d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal]: Drastically improve searching API (indexOf(…)) of CollectionType</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  4, 2016 at 12:00:00pm</p></header><div class="content"><p>I&#39;m not sure about the rest of this, but...<br></p><p>&gt;&gt; 1. A backwards-compatible refactoring of `CollectionType.indices`, moving it to `Indexable`.<br>&gt;&gt; <br>&gt;&gt; 2. A backwards-compatible refactoring of `indexOf(…)` (adding optional `range:` and moving it to `Indexable`).<br>&gt;&gt; <br>&gt;&gt; 3. The addition of `rangeOf(…)`, `countOf(…)` and `isSorted(…)` to `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt; <br>&gt;&gt; 4. The introduction of a `BinarySearchView` on `Indexable`, allowing for fast (`O(log2(self.count))`) searches on `Indexable` via `indexOf(…)`, `rangeOf(…)`, `countOf(…)`, `lowerBoundOf(…)`, `upperBoundOf(…)` without cluttering `Indexable`&#39;s interface.<br></p><p>I don&#39;t think you quite understand what `Indexable` is for.<br></p><p>`Indexable` is a minimal protocol containing the very most basic parts of `CollectionType`&#39;s interface. It&#39;s used to avoid circular definitions in `CollectionType`. The doc comments on it describe it as &quot;almost an implementation detail&quot;. I don&#39;t think it&#39;s appropriate to move a whole bunch of stuff into `Indexable` when it&#39;s supposed to be a minimal protocol.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal]: Drastically improve searching API (indexOf(…)) of CollectionType</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January  4, 2016 at 06:00:00pm</p></header><div class="content"><p>The proposed additions to Indexible only require Indices… I don&#39;t see how<br>adding them is such a mistake. If we can gain these behaviors while only<br>*requiring* that minimum interface… go for it.<br></p><p>TJ<br></p><p>On Mon, Jan 4, 2016 at 3:49 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;m not sure about the rest of this, but...<br>&gt;<br>&gt; &gt;&gt; 1. A backwards-compatible refactoring of `CollectionType.indices`,<br>&gt; moving it to `Indexable`.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 2. A backwards-compatible refactoring of `indexOf(…)` (adding optional<br>&gt; `range:` and moving it to `Indexable`).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 3. The addition of `rangeOf(…)`, `countOf(…)` and `isSorted(…)` to<br>&gt; `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 4. The introduction of a `BinarySearchView` on `Indexable`, allowing<br>&gt; for fast (`O(log2(self.count))`) searches on `Indexable` via `indexOf(…)`,<br>&gt; `rangeOf(…)`, `countOf(…)`, `lowerBoundOf(…)`, `upperBoundOf(…)` without<br>&gt; cluttering `Indexable`&#39;s interface.<br>&gt;<br>&gt; I don&#39;t think you quite understand what `Indexable` is for.<br>&gt;<br>&gt; `Indexable` is a minimal protocol containing the very most basic parts of<br>&gt; `CollectionType`&#39;s interface. It&#39;s used to avoid circular definitions in<br>&gt; `CollectionType`. The doc comments on it describe it as &quot;almost an<br>&gt; implementation detail&quot;. I don&#39;t think it&#39;s appropriate to move a whole<br>&gt; bunch of stuff into `Indexable` when it&#39;s supposed to be a minimal protocol.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/b6a15b70/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/357b710213d3c0e01356f7c90f78b9f2?s=50"></div><header><strong>[Proposal]: Drastically improve searching API (indexOf(…)) of CollectionType</strong> from <string>Vincent Esche</string> &lt;regexident.mailinglists at gmail.com&gt;<p>January  5, 2016 at 01:00:00am</p></header><div class="content"><p>That was my reasoning behind choosing Indexable and not CollectionType.<br></p><p>Neither the Swift documents, nor the “headers” indicate any semi-privateness of Indexable, AFAIK.<br>(Apart from maybe Base._Element kind of hinting at it, but then again it’s Indexable, not _Indexable.)<br></p><p>Anyway, I’d be totally fine with sticking it on CollectionType, if that’s preferred.<br></p><p>Vincent<br></p><p>&gt; On 05 Jan 2016, at 00:58, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The proposed additions to Indexible only require Indices… I don&#39;t see how adding them is such a mistake. If we can gain these behaviors while only *requiring* that minimum interface… go for it.<br>&gt; <br>&gt; TJ<br>&gt; <br>&gt; On Mon, Jan 4, 2016 at 3:49 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I&#39;m not sure about the rest of this, but...<br>&gt; <br>&gt; &gt;&gt; 1. A backwards-compatible refactoring of `CollectionType.indices`, moving it to `Indexable`.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 2. A backwards-compatible refactoring of `indexOf(…)` (adding optional `range:` and moving it to `Indexable`).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 3. The addition of `rangeOf(…)`, `countOf(…)` and `isSorted(…)` to `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 4. The introduction of a `BinarySearchView` on `Indexable`, allowing for fast (`O(log2(self.count))`) searches on `Indexable` via `indexOf(…)`, `rangeOf(…)`, `countOf(…)`, `lowerBoundOf(…)`, `upperBoundOf(…)` without cluttering `Indexable`&#39;s interface.<br>&gt; <br>&gt; I don&#39;t think you quite understand what `Indexable` is for.<br>&gt; <br>&gt; `Indexable` is a minimal protocol containing the very most basic parts of `CollectionType`&#39;s interface. It&#39;s used to avoid circular definitions in `CollectionType`. The doc comments on it describe it as &quot;almost an implementation detail&quot;. I don&#39;t think it&#39;s appropriate to move a whole bunch of stuff into `Indexable` when it&#39;s supposed to be a minimal protocol.<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/24024a50/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/357b710213d3c0e01356f7c90f78b9f2?s=50"></div><header><strong>[Proposal]: Drastically improve searching API (indexOf(…)) of CollectionType</strong> from <string>Vincent Esche</string> &lt;regexident.mailinglists at gmail.com&gt;<p>January  5, 2016 at 02:00:00am</p></header><div class="content"><p>There are a couple of things I’m not 100% happy with/sure about:<br></p><p>1.<br>I don’t like how it’s<br>“&lt;index/range/count&gt;Of(element:range:)” but “&lt;index/range/count&gt;Of(range:predicate:)”.<br>The reason I went for “&lt;index/range/count&gt;Of(range:predicate:)” was to go with the standard pattern of putting closures last and thus allowing for trailing closure syntax.<br></p><p>The current order allows for this:<br>“&lt;index/range/count&gt;Of(0..10)  { $0.name == “Foobar&quot; }”<br>which I like syntax-wise.<br>It however makes it look like one was looking for a range (&quot;indexOf(0..10, …)”), not the predicate.<br></p><p>While the alternative requires this:<br>“&lt;index/range/count&gt;Of(predicate: { $0.name == “Foobar&quot; }, range: 0..10)”<br></p><p>I’m actually leaning towards the latter now. Dang!<br></p><p>2.<br>I’m unsure about the name of “lensView”. I first went with “transform”, then with “mappingFunction”, but found that neither of those made it clear that the closure should provide a specific view into the element.  Both “transform&quot; and “mappingFunction” imply the transformation from one data type to another. It’s not about transforming. It’s about accessing.<br>Thus looked for names of similar patterns and found “keypaths” (kind of) in ObjC and lenses in Haskell. To people familiar with functional programming the name should be clear. The closure passed to “lensView” is basically the getter part of a functional lens.<br>Anyway, I’m not too attached to the name and more than open to suggestions.<br></p><p>3.<br>“BinarySearchView.init(base:validateAgainst:)” currently asserts. This should probably be split into two init functions. One assuming the base to be sorted (“BinarySearchView.init(base:)”, O(1)). And one allowing for a check, returning nil on failure (“BinarySearchView.init?(base:validateAgainst:)”, O(self.count)). Or should at least throw an error, instead of panicking.<br></p><p>Note: I made some minor documentation changes/fixes.<br>See https://gist.github.com/regexident/2b7531bd748f57679671 &lt;https://gist.github.com/regexident/2b7531bd748f57679671&gt; for up-to-date RFC/source code (vs. Markdown-dump at bottom of OP).<br></p><p>- Vincent<br></p><p>&gt; On 04 Jan 2016, at 16:13, Vincent Esche &lt;regexident.mailinglists at gmail.com&gt; wrote:<br>&gt; <br>&gt; After having had this code laying around on my Mac since 6/26/15 (waiting for Swift to go open source)<br>&gt; I figured it’s about damn time I submit the actual RFC for it. So without further ado…<br>&gt; <br>&gt; One of the areas where Swift’s stdlib is still quite lacking is searching.<br>&gt; Which is a shame as searching (along with indexing) might be among<br>&gt; the most important tasks of computer science/software development.<br>&gt; One might not need fast collection searches for writing a banal fart or flashlight app,<br>&gt; but almost every other app is likely to benefit from having a proper searching API.<br>&gt; <br>&gt; So I’d like to fix that.<br>&gt; <br>&gt; Attached you find a full RFC along with the full and functional source code to make it happen.<br>&gt; <br>&gt; I’d love to hear your opinion on this and will be more than happy to answer questions.<br>&gt; <br>&gt; Rendered Version + Full Implementation: https://gist.github.com/regexident/2b7531bd748f57679671 &lt;https://gist.github.com/regexident/2b7531bd748f57679671&gt;<br>&gt; (The code is tested using Quick/Nimble. Tests would thus have to be ported to Swift’s XCTest.)<br>&gt; <br>&gt; - Vincent<br>&gt; <br>&gt;&gt; Markdown-dump for<br>&gt;&gt; <br>&gt;&gt; # Improved Collection Search<br>&gt;&gt; <br>&gt;&gt; * Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;)<br>&gt;&gt; * Author(s): [Vincent Esche](https://github.com/regexident &lt;https://github.com/regexident&gt;)<br>&gt;&gt; * Status: **Review**<br>&gt;&gt; * Review manager: TBD<br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; This RFC proposes an extension to the currently rather limited and linear searching API of `CollectionType`, that is `indexOf(element:)` and `indexOf(predicate:)`.<br>&gt;&gt; It proposes the backwards-compatible refactoring of those existing methods as well as the introduction of a view-based ensemble of methods for efficient binary-search.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution &lt;https://lists.swift.org/pipermail/swift-evolution&gt;)<br>&gt;&gt; <br>&gt;&gt; ## Motivation<br>&gt;&gt; <br>&gt;&gt; Indexing of and searching in data is a big deal in software development. As such it is crucial to have capable means of doing so in a language that aspires to be a highly performant programming language.<br>&gt;&gt; <br>&gt;&gt; Swift&#39;s current API for searching is basically limited to these two methods on `CollectionType`:<br>&gt;&gt; <br>&gt;&gt; &gt; ```swift<br>&gt;&gt; &gt; func indexOf(element: Self.Generator.Element) -&gt; Self.Index?<br>&gt;&gt; &gt; ```<br>&gt;&gt; &gt; Returns the first index where value appears in self or nil if value is not found.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; **Complexity**: `O(self.count)`.<br>&gt;&gt; <br>&gt;&gt; and:<br>&gt;&gt; <br>&gt;&gt; &gt; ```swift<br>&gt;&gt; &gt; func indexOf(@noescape predicate: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.Index?<br>&gt;&gt; &gt; ```<br>&gt;&gt; &gt; Returns the first index where predicate returns true for the corresponding value, or nil if such value is not found.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; **Complexity**: `O(self.count)`.<br>&gt;&gt; <br>&gt;&gt; The author sees a couple of issue with these two methods:<br>&gt;&gt; <br>&gt;&gt; 1. They do not provide an option for restricting the &quot;haystack&quot; to a certain `range` of `self`.<br>&gt;&gt; 2. They do not provide a fast (`O(log2(self.count))`) path for sorted collections.<br>&gt;&gt; 3. They should not be limited to `CollectionType` but instead be moved to `Indexable`.<br>&gt;&gt; <br>&gt;&gt; In many situations it is desirable to perform fast searches on sorted collections instead of having to fall back to naïve linear searches.<br>&gt;&gt; <br>&gt;&gt; Further more while a single `index` might be the most common subject of interest, there are many scenarios where a `range` or `count` of matches are of more use.<br>&gt;&gt; <br>&gt;&gt; And anyone who is writing a custom ordered collection type will eventually want to find the insertion index for a given element and will thus end up writing some variant of `lowerBoundOf(…)` or `upperBoundOf(…)` (upon which all the other methods can be implemented, actually).<br>&gt;&gt; <br>&gt;&gt; ## Proposed solution<br>&gt;&gt; <br>&gt;&gt; The author proposes:<br>&gt;&gt; <br>&gt;&gt; 1. A backwards-compatible refactoring of `CollectionType.indices`, moving it to `Indexable`.<br>&gt;&gt; <br>&gt;&gt; 2. A backwards-compatible refactoring of `indexOf(…)` (adding optional `range:` and moving it to `Indexable`).<br>&gt;&gt; <br>&gt;&gt; 3. The addition of `rangeOf(…)`, `countOf(…)` and `isSorted(…)` to `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt; <br>&gt;&gt; 4. The introduction of a `BinarySearchView` on `Indexable`, allowing for fast (`O(log2(self.count))`) searches on `Indexable` via `indexOf(…)`, `rangeOf(…)`, `countOf(…)`, `lowerBoundOf(…)`, `upperBoundOf(…)` without cluttering `Indexable`&#39;s interface.<br>&gt;&gt; <br>&gt;&gt; ## Detailed design<br>&gt;&gt; <br>&gt;&gt; ### `CollectionType.indices`:<br>&gt;&gt; <br>&gt;&gt; The author proposes the relocation of `.indices` from `CollectionType` to `Indexable`:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; extension Indexable {<br>&gt;&gt;     /// Return the range of valid index values.<br>&gt;&gt;     ///<br>&gt;&gt;     /// The result&#39;s `endIndex` is the same as that of `self`.  Because<br>&gt;&gt;     /// `Range` is half-open, iterating the values of the result produces<br>&gt;&gt;     /// all valid subscript arguments for `self`, omitting its `endIndex`.<br>&gt;&gt;     public var indices: Range&lt;Self.Index&gt; { get }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; After all all it does is provide a convenience method for generating a Range from its `startIndex` and `endIndex`. There is no need for `self` to be a `CollectionType` for this.<br>&gt;&gt; <br>&gt;&gt; This change should not break any existing code as it generalizes the property.<br>&gt;&gt; <br>&gt;&gt; ### `Indexable` of `Comparable` elements:<br>&gt;&gt; <br>&gt;&gt; The author proposes the addition of the following method on `Indexable where Element : Comparable`:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; extension Indexable where Index: RandomAccessIndexType, _Element: Comparable {<br>&gt;&gt; 	/// Return true iff all elements in `self` within `range` are sorted according to `isOrderedBefore`.<br>&gt;&gt; 	///<br>&gt;&gt; 	/// - Complexity: O(`self.count`)<br>&gt;&gt; 	public func isSorted(range: Range&lt;Index&gt;? = nil) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; This method would perform a linear scan of the `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt; <br>&gt;&gt; An actual implementation of these methods can be found in `Indexable.swift`.<br>&gt;&gt; <br>&gt;&gt; ### `Indexable` of `Equatable ` elements:<br>&gt;&gt; <br>&gt;&gt; The author proposes the addition of the following method on `Indexable where Element : Equatable`:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; extension Indexable where Index : RandomAccessIndexType, _Element : Equatable {<br>&gt;&gt; <br>&gt;&gt;     /// Returns the first index where `element` appears in `self`<br>&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;     public func indexOf(element: _Element, range: Range&lt;Index&gt;? = default) -&gt; Self.Index?<br>&gt;&gt; <br>&gt;&gt;     /// Returns the first range where `element` appears in `self`<br>&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;     public func rangeOf(element: _Element, range: Range&lt;Index&gt;? = default) -&gt; Range&lt;Self.Index&gt;?<br>&gt;&gt; <br>&gt;&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;&gt;     /// within range `range` or `nil` if such an element is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;     public func countOf(element: _Element, range: Range&lt;Index&gt;? = default) -&gt; Int<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; These methods would perform a linear scan of the `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt; <br>&gt;&gt; An actual implementation of these methods can be found in `Indexable.swift`.<br>&gt;&gt; <br>&gt;&gt; ### `Indexable` of any elements:<br>&gt;&gt; <br>&gt;&gt; The author proposes the addition of the following methods on `Indexable`:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; extension Indexable where Index : RandomAccessIndexType {<br>&gt;&gt; <br>&gt;&gt;     /// Returns the first index where an element appears in `self`<br>&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;     public func indexOf(range: Range&lt;Index&gt;? = default, @noescape predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Self.Index?<br>&gt;&gt; <br>&gt;&gt;     /// Returns the first range where an element appears in `self`<br>&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;     public func rangeOf(range: Range&lt;Index&gt;? = default, @noescape predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Range&lt;Self.Index&gt;?<br>&gt;&gt; <br>&gt;&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;     public func countOf(range: Range&lt;Index&gt;? = default, @noescape predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Int<br>&gt;&gt; <br>&gt;&gt;     /// Return true iff all elements in `self` within `range` are sorted according to `isOrderedBefore`.<br>&gt;&gt;     /// <br>&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;     public func isSorted(range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (_Element, _Element) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; These methods would perform a linear scan of the `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt; <br>&gt;&gt; An actual implementation of these methods can be found in `Indexable.swift`.<br>&gt;&gt; <br>&gt;&gt; **Note**: For explanation of and reasoning behind the `lensView:` argument as well as the distinction between `T` and `Base._Element`, see below.<br>&gt;&gt; <br>&gt;&gt; ### `Indexable.binarySearchView(validateAgainst:?)`:<br>&gt;&gt; <br>&gt;&gt; The author proposes the addition of a `binarySearchView(validateAgainst:?)` method on `Indexable` for obtaining a specialized search view for performing searches with O(`log2(self.count)`) complexity:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; extension Indexable where Index: RandomAccessIndexType {<br>&gt;&gt; 	/// Create a view into a sorted indexable that allows access within `bounds`.<br>&gt;&gt; 	///<br>&gt;&gt; 	/// - Complexity: O(`self.count`) if a validation closure is provided, otherwise O(`1`).<br>&gt;&gt; 	public func binarySearchView(validateAgainst isOrderedBefore: ((_Element, _Element) -&gt; Bool)? = nil) -&gt; BinarySearchView&lt;Self&gt;<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; ### `BinarySearchView&lt;T: Indexable&gt;`:<br>&gt;&gt; <br>&gt;&gt; The author proposes the introduction of a `BinarySearchView` struct with the following interface:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; public struct BinarySearchView&lt;Base : Indexable where Base.Index : RandomAccessIndexType&gt; : Indexable {<br>&gt;&gt;     public typealias Index = Base.Index<br>&gt;&gt; <br>&gt;&gt;     public var startIndex: Base.Index { get }<br>&gt;&gt; <br>&gt;&gt;     public var endIndex: Base.Index { get }<br>&gt;&gt; <br>&gt;&gt;     public subscript (position: Index) -&gt; Base._Element { get }<br>&gt;&gt; <br>&gt;&gt;     /// Create a view into a sorted collection `base` that allows access within `bounds`.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(1).<br>&gt;&gt;     public init(base: Base, validateAgainst isOrderedBefore: ((Base._Element, Base._Element) -&gt; Bool)? = default)<br>&gt;&gt; <br>&gt;&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;&gt;     /// `lensView(element) &lt; value` evaluates to false or `nil` if `element` is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;     public func lowerBoundOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Base.Index<br>&gt;&gt; <br>&gt;&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;&gt;     /// `value &lt; lensView(element)` evaluates to true or `nil` if `element` is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;     public func upperBoundOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: ((T, T) -&gt; Bool) = default, @noescape lensView: Base._Element -&gt; T) -&gt; Base.Index<br>&gt;&gt; <br>&gt;&gt;     /// Returns the first index where an element appears in `self`<br>&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;     public func indexOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Base.Index?<br>&gt;&gt; <br>&gt;&gt;     /// Returns the range where an element appears in `self`<br>&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;     public func rangeOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Range&lt;Base.Index&gt;?<br>&gt;&gt; <br>&gt;&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;     public func countOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Int<br>&gt;&gt; <br>&gt;&gt;     internal let _base: Base<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; As well as the following extension for `Indexable where Element: Comparable`:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; extension BinarySearchView where Base._Element : Comparable {<br>&gt;&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;&gt;     /// `… &lt; element` evaluates to false or `nil` if `element` is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;     public func lowerBoundOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Base.Index<br>&gt;&gt; <br>&gt;&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;&gt;     /// `element &lt; …` evaluates to true or `nil` if `element` is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;     public func upperBoundOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Base.Index<br>&gt;&gt; <br>&gt;&gt;     /// Returns the first index where `element` appears in `self`<br>&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;     public func indexOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Base.Index?<br>&gt;&gt; <br>&gt;&gt;     /// Returns the range where `element` appears in `self`<br>&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;     public func rangeOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Range&lt;Base.Index&gt;?<br>&gt;&gt; <br>&gt;&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;     public func countOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Int<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; These methods would perform a linear scan of the `Indexable` with a TIME complexity of `O(log2(self.count))`.<br>&gt;&gt; <br>&gt;&gt; An actual implementation of these methods can be found in `BinarySearchView.swift`.<br>&gt;&gt; <br>&gt;&gt; ### Why `lensView`?<br>&gt;&gt; <br>&gt;&gt; Let&#39;s assume one had a collection of Persons like this:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; struct Person {<br>&gt;&gt;     let name: String<br>&gt;&gt;     let age: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let persons: [Person] = [ … ]<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Now let&#39;s assume one wanted to find the first person that&#39;s called `John Doe`. One could either change `Person` to conform to `Equatable`, allowing `indexOf(element:)` to be called on `persons`. Now that was easy, wasn&#39;t it?<br>&gt;&gt; <br>&gt;&gt; Fine, but what if one wanted to search `Person`s by both their `name` or their `age` depending on the given use case? You&#39;re out of luck now.<br>&gt;&gt; <br>&gt;&gt; Luckily there is a variant of `indexOf(…)` called `indexOf(predicate:)` that is available for any type of `Element` regardless of its conformance to `Equatable`:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; let searchView = persons.binarySearchView()<br>&gt;&gt; let index = persons.indexOf { $0.name == &quot;John Doe&quot; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Unfortunately however such a `predicate` cannot be used when searching for an element&#39;s property in a sorted(!) collection or a collection of non-`Comparable` elements within a TIME complexity of `O(log2(self.count))` as binary search uses `&lt;` instead of `==` internally and as the &quot;needle&quot; gets passed as both the first (in `indexOf(…)` itself) and second argument (in `lowerBoundOf(…)` which gets called by `indexOf(…)`) to the operator, one cannot simply change `predicate: (E) -&gt; Bool` to `isOrderedBefore: (V, E) -&gt; Bool` as that would result in a type mismatch (`(V, E)` vs. `(E, V)`).<br>&gt;&gt; <br>&gt;&gt; The use of `lensView` however allows one to do just that without making a mess.<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; let searchView = persons.binarySearchView() // sorted!<br>&gt;&gt; let index = searchView.indexOf(&quot;John Doe&quot;) { $0.name }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; The `lensView` works similarly to how keypaths work in Objective-C, just type-safe.<br>&gt;&gt; <br>&gt;&gt; ## Impact on existing code<br>&gt;&gt; <br>&gt;&gt; The author proposes:<br>&gt;&gt; <br>&gt;&gt; 1. Moving `CollectionType.indices` to `Indexable` should not cause any issues with existing code.<br>&gt;&gt; <br>&gt;&gt; 2. Changing `indexOf(element:)` to `indexOf(element:range:?)` should not cause any issues with existing code as the `range` argument is optional and the default behaves like it used to.<br>&gt;&gt; <br>&gt;&gt; 2. Changing `indexOf(predicate:)` to `indexOf(range:?predicate:)` should not cause any issues with existing code either, as the `range` argument is optional and the default behaves like it used to. Swift&#39;s trailing-closure magic allows `indexOf(predicate: …)` to still properly map to `indexOf(range: nil, predicate: …)`.<br>&gt;&gt; <br>&gt;&gt; 3. The addition of `rangeOf(…)`, `countOf(…)` and `isSorted(…)` to `Indexable` do not conflict with any existing API.<br>&gt;&gt; <br>&gt;&gt; 4. The introduction of a `BinarySearchView` on `Indexable` does not conflict with any existing API.<br>&gt;&gt; <br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The author&#39;s initial approach was to implement all methods on Indexable. This however required all methods to either be provided in two variants (one for unsorted, one for sorted `Indexable`s):<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; final public func indexOf(element: _Element, range: Range&lt;Index&gt;? = nil) -&gt; Index? {<br>&gt;&gt; 	return …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; final public func sortedIndexOf(element: _Element, range: Range&lt;Index&gt;? = nil) -&gt; Index? {<br>&gt;&gt; 	return …<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Or require the introduction of an additional argument:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; final public func indexOf(element: _Element, range: Range&lt;Index&gt;? = nil, isSorted: Bool = true) -&gt; Index? {<br>&gt;&gt;     if isSorted {<br>&gt;&gt;         return …<br>&gt;&gt;     } else {<br>&gt;&gt;         return …<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; It also would have cluttered `Indexable` with methods such as `lowerBoundOf` and `upperBoundOf`, which are only ever applicable when `self` is sorted accordingly. The introduction of a dedicated BinarySearchView fixes these issues.<br>&gt;&gt; <br>&gt;&gt; One also would have had to switch from `predicate: (T) -&gt; Bool` to `isOrderedBefore: (T, T) -&gt; Bool` for all methods for the second unified API alternative.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/67bb1c94/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f5228ad4a1fad94f1a7d3d05b0c0ff6a?s=50"></div><header><strong>[Proposal]: Drastically improve searching API (indexOf(…)) of CollectionType</strong> from <string>Donnacha Oisín Kidney</string> &lt;oisin.kidney at gmail.com&gt;<p>January  5, 2016 at 02:00:00am</p></header><div class="content"><p>Unless I’m confused, all of the “ranged” overloads can already be achieved by composing ranged subscripts with the indexOf, etc., methods:<br></p><p>let ar = [0, 1, 2, 3, 4, 5]<br>let ind = ar[3...5].indexOf { n in n % 2 == 0 }<br>ar[ind!] // 4<br></p><p>&gt; On 5 Jan 2016, at 01:00, Vincent Esche via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There are a couple of things I’m not 100% happy with/sure about:<br>&gt; <br>&gt; 1.<br>&gt; I don’t like how it’s<br>&gt; “&lt;index/range/count&gt;Of(element:range:)” but “&lt;index/range/count&gt;Of(range:predicate:)”.<br>&gt; The reason I went for “&lt;index/range/count&gt;Of(range:predicate:)” was to go with the standard pattern of putting closures last and thus allowing for trailing closure syntax.<br>&gt; <br>&gt; The current order allows for this:<br>&gt; “&lt;index/range/count&gt;Of(0..10)  { $0.name == “Foobar&quot; }”<br>&gt; which I like syntax-wise.<br>&gt; It however makes it look like one was looking for a range (&quot;indexOf(0..10, …)”), not the predicate.<br>&gt; <br>&gt; While the alternative requires this:<br>&gt; “&lt;index/range/count&gt;Of(predicate: { $0.name == “Foobar&quot; }, range: 0..10)”<br>&gt; <br>&gt; I’m actually leaning towards the latter now. Dang!<br>&gt; <br>&gt; 2.<br>&gt; I’m unsure about the name of “lensView”. I first went with “transform”, then with “mappingFunction”, but found that neither of those made it clear that the closure should provide a specific view into the element.  Both “transform&quot; and “mappingFunction” imply the transformation from one data type to another. It’s not about transforming. It’s about accessing.<br>&gt; Thus looked for names of similar patterns and found “keypaths” (kind of) in ObjC and lenses in Haskell. To people familiar with functional programming the name should be clear. The closure passed to “lensView” is basically the getter part of a functional lens.<br>&gt; Anyway, I’m not too attached to the name and more than open to suggestions.<br>&gt; <br>&gt; 3.<br>&gt; “BinarySearchView.init(base:validateAgainst:)” currently asserts. This should probably be split into two init functions. One assuming the base to be sorted (“BinarySearchView.init(base:)”, O(1)). And one allowing for a check, returning nil on failure (“BinarySearchView.init?(base:validateAgainst:)”, O(self.count)). Or should at least throw an error, instead of panicking.<br>&gt; <br>&gt; Note: I made some minor documentation changes/fixes.<br>&gt; See https://gist.github.com/regexident/2b7531bd748f57679671 &lt;https://gist.github.com/regexident/2b7531bd748f57679671&gt; for up-to-date RFC/source code (vs. Markdown-dump at bottom of OP).<br>&gt; <br>&gt; - Vincent<br>&gt; <br>&gt;&gt; On 04 Jan 2016, at 16:13, Vincent Esche &lt;regexident.mailinglists at gmail.com &lt;mailto:regexident.mailinglists at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; After having had this code laying around on my Mac since 6/26/15 (waiting for Swift to go open source)<br>&gt;&gt; I figured it’s about damn time I submit the actual RFC for it. So without further ado…<br>&gt;&gt; <br>&gt;&gt; One of the areas where Swift’s stdlib is still quite lacking is searching.<br>&gt;&gt; Which is a shame as searching (along with indexing) might be among<br>&gt;&gt; the most important tasks of computer science/software development.<br>&gt;&gt; One might not need fast collection searches for writing a banal fart or flashlight app,<br>&gt;&gt; but almost every other app is likely to benefit from having a proper searching API.<br>&gt;&gt; <br>&gt;&gt; So I’d like to fix that.<br>&gt;&gt; <br>&gt;&gt; Attached you find a full RFC along with the full and functional source code to make it happen.<br>&gt;&gt; <br>&gt;&gt; I’d love to hear your opinion on this and will be more than happy to answer questions.<br>&gt;&gt; <br>&gt;&gt; Rendered Version + Full Implementation: https://gist.github.com/regexident/2b7531bd748f57679671 &lt;https://gist.github.com/regexident/2b7531bd748f57679671&gt;<br>&gt;&gt; (The code is tested using Quick/Nimble. Tests would thus have to be ported to Swift’s XCTest.)<br>&gt;&gt; <br>&gt;&gt; - Vincent<br>&gt;&gt; <br>&gt;&gt;&gt; Markdown-dump for<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Improved Collection Search<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;)<br>&gt;&gt;&gt; * Author(s): [Vincent Esche](https://github.com/regexident &lt;https://github.com/regexident&gt;)<br>&gt;&gt;&gt; * Status: **Review**<br>&gt;&gt;&gt; * Review manager: TBD<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This RFC proposes an extension to the currently rather limited and linear searching API of `CollectionType`, that is `indexOf(element:)` and `indexOf(predicate:)`.<br>&gt;&gt;&gt; It proposes the backwards-compatible refactoring of those existing methods as well as the introduction of a view-based ensemble of methods for efficient binary-search.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution &lt;https://lists.swift.org/pipermail/swift-evolution&gt;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Indexing of and searching in data is a big deal in software development. As such it is crucial to have capable means of doing so in a language that aspires to be a highly performant programming language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift&#39;s current API for searching is basically limited to these two methods on `CollectionType`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; ```swift<br>&gt;&gt;&gt; &gt; func indexOf(element: Self.Generator.Element) -&gt; Self.Index?<br>&gt;&gt;&gt; &gt; ```<br>&gt;&gt;&gt; &gt; Returns the first index where value appears in self or nil if value is not found.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; **Complexity**: `O(self.count)`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; ```swift<br>&gt;&gt;&gt; &gt; func indexOf(@noescape predicate: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.Index?<br>&gt;&gt;&gt; &gt; ```<br>&gt;&gt;&gt; &gt; Returns the first index where predicate returns true for the corresponding value, or nil if such value is not found.<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; **Complexity**: `O(self.count)`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The author sees a couple of issue with these two methods:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. They do not provide an option for restricting the &quot;haystack&quot; to a certain `range` of `self`.<br>&gt;&gt;&gt; 2. They do not provide a fast (`O(log2(self.count))`) path for sorted collections.<br>&gt;&gt;&gt; 3. They should not be limited to `CollectionType` but instead be moved to `Indexable`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In many situations it is desirable to perform fast searches on sorted collections instead of having to fall back to naïve linear searches.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Further more while a single `index` might be the most common subject of interest, there are many scenarios where a `range` or `count` of matches are of more use.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And anyone who is writing a custom ordered collection type will eventually want to find the insertion index for a given element and will thus end up writing some variant of `lowerBoundOf(…)` or `upperBoundOf(…)` (upon which all the other methods can be implemented, actually).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The author proposes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. A backwards-compatible refactoring of `CollectionType.indices`, moving it to `Indexable`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. A backwards-compatible refactoring of `indexOf(…)` (adding optional `range:` and moving it to `Indexable`).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. The addition of `rangeOf(…)`, `countOf(…)` and `isSorted(…)` to `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 4. The introduction of a `BinarySearchView` on `Indexable`, allowing for fast (`O(log2(self.count))`) searches on `Indexable` via `indexOf(…)`, `rangeOf(…)`, `countOf(…)`, `lowerBoundOf(…)`, `upperBoundOf(…)` without cluttering `Indexable`&#39;s interface.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### `CollectionType.indices`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The author proposes the relocation of `.indices` from `CollectionType` to `Indexable`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; extension Indexable {<br>&gt;&gt;&gt;     /// Return the range of valid index values.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// The result&#39;s `endIndex` is the same as that of `self`.  Because<br>&gt;&gt;&gt;     /// `Range` is half-open, iterating the values of the result produces<br>&gt;&gt;&gt;     /// all valid subscript arguments for `self`, omitting its `endIndex`.<br>&gt;&gt;&gt;     public var indices: Range&lt;Self.Index&gt; { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After all all it does is provide a convenience method for generating a Range from its `startIndex` and `endIndex`. There is no need for `self` to be a `CollectionType` for this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This change should not break any existing code as it generalizes the property.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### `Indexable` of `Comparable` elements:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The author proposes the addition of the following method on `Indexable where Element : Comparable`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; extension Indexable where Index: RandomAccessIndexType, _Element: Comparable {<br>&gt;&gt;&gt; 	/// Return true iff all elements in `self` within `range` are sorted according to `isOrderedBefore`.<br>&gt;&gt;&gt; 	///<br>&gt;&gt;&gt; 	/// - Complexity: O(`self.count`)<br>&gt;&gt;&gt; 	public func isSorted(range: Range&lt;Index&gt;? = nil) -&gt; Bool<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This method would perform a linear scan of the `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An actual implementation of these methods can be found in `Indexable.swift`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### `Indexable` of `Equatable ` elements:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The author proposes the addition of the following method on `Indexable where Element : Equatable`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; extension Indexable where Index : RandomAccessIndexType, _Element : Equatable {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Returns the first index where `element` appears in `self`<br>&gt;&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;     public func indexOf(element: _Element, range: Range&lt;Index&gt;? = default) -&gt; Self.Index?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Returns the first range where `element` appears in `self`<br>&gt;&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;     public func rangeOf(element: _Element, range: Range&lt;Index&gt;? = default) -&gt; Range&lt;Self.Index&gt;?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;&gt;&gt;     /// within range `range` or `nil` if such an element is not found.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;     public func countOf(element: _Element, range: Range&lt;Index&gt;? = default) -&gt; Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These methods would perform a linear scan of the `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An actual implementation of these methods can be found in `Indexable.swift`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### `Indexable` of any elements:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The author proposes the addition of the following methods on `Indexable`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; extension Indexable where Index : RandomAccessIndexType {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Returns the first index where an element appears in `self`<br>&gt;&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;     public func indexOf(range: Range&lt;Index&gt;? = default, @noescape predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Self.Index?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Returns the first range where an element appears in `self`<br>&gt;&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;     public func rangeOf(range: Range&lt;Index&gt;? = default, @noescape predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Range&lt;Self.Index&gt;?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;     public func countOf(range: Range&lt;Index&gt;? = default, @noescape predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Return true iff all elements in `self` within `range` are sorted according to `isOrderedBefore`.<br>&gt;&gt;&gt;     /// <br>&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;     public func isSorted(range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (_Element, _Element) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These methods would perform a linear scan of the `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An actual implementation of these methods can be found in `Indexable.swift`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; **Note**: For explanation of and reasoning behind the `lensView:` argument as well as the distinction between `T` and `Base._Element`, see below.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### `Indexable.binarySearchView(validateAgainst:?)`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The author proposes the addition of a `binarySearchView(validateAgainst:?)` method on `Indexable` for obtaining a specialized search view for performing searches with O(`log2(self.count)`) complexity:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; extension Indexable where Index: RandomAccessIndexType {<br>&gt;&gt;&gt; 	/// Create a view into a sorted indexable that allows access within `bounds`.<br>&gt;&gt;&gt; 	///<br>&gt;&gt;&gt; 	/// - Complexity: O(`self.count`) if a validation closure is provided, otherwise O(`1`).<br>&gt;&gt;&gt; 	public func binarySearchView(validateAgainst isOrderedBefore: ((_Element, _Element) -&gt; Bool)? = nil) -&gt; BinarySearchView&lt;Self&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### `BinarySearchView&lt;T: Indexable&gt;`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The author proposes the introduction of a `BinarySearchView` struct with the following interface:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; public struct BinarySearchView&lt;Base : Indexable where Base.Index : RandomAccessIndexType&gt; : Indexable {<br>&gt;&gt;&gt;     public typealias Index = Base.Index<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public var startIndex: Base.Index { get }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public var endIndex: Base.Index { get }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public subscript (position: Index) -&gt; Base._Element { get }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Create a view into a sorted collection `base` that allows access within `bounds`.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(1).<br>&gt;&gt;&gt;     public init(base: Base, validateAgainst isOrderedBefore: ((Base._Element, Base._Element) -&gt; Bool)? = default)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;&gt;&gt;     /// `lensView(element) &lt; value` evaluates to false or `nil` if `element` is not found.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;     public func lowerBoundOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Base.Index<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;&gt;&gt;     /// `value &lt; lensView(element)` evaluates to true or `nil` if `element` is not found.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;     public func upperBoundOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: ((T, T) -&gt; Bool) = default, @noescape lensView: Base._Element -&gt; T) -&gt; Base.Index<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Returns the first index where an element appears in `self`<br>&gt;&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;     public func indexOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Base.Index?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Returns the range where an element appears in `self`<br>&gt;&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;     public func rangeOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Range&lt;Base.Index&gt;?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;     public func countOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     internal let _base: Base<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As well as the following extension for `Indexable where Element: Comparable`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; extension BinarySearchView where Base._Element : Comparable {<br>&gt;&gt;&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;&gt;&gt;     /// `… &lt; element` evaluates to false or `nil` if `element` is not found.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;     public func lowerBoundOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Base.Index<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;&gt;&gt;     /// `element &lt; …` evaluates to true or `nil` if `element` is not found.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;     public func upperBoundOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Base.Index<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Returns the first index where `element` appears in `self`<br>&gt;&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;     public func indexOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Base.Index?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Returns the range where `element` appears in `self`<br>&gt;&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;     public func rangeOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Range&lt;Base.Index&gt;?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;     public func countOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These methods would perform a linear scan of the `Indexable` with a TIME complexity of `O(log2(self.count))`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An actual implementation of these methods can be found in `BinarySearchView.swift`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### Why `lensView`?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let&#39;s assume one had a collection of Persons like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; struct Person {<br>&gt;&gt;&gt;     let name: String<br>&gt;&gt;&gt;     let age: Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let persons: [Person] = [ … ]<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now let&#39;s assume one wanted to find the first person that&#39;s called `John Doe`. One could either change `Person` to conform to `Equatable`, allowing `indexOf(element:)` to be called on `persons`. Now that was easy, wasn&#39;t it?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fine, but what if one wanted to search `Person`s by both their `name` or their `age` depending on the given use case? You&#39;re out of luck now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Luckily there is a variant of `indexOf(…)` called `indexOf(predicate:)` that is available for any type of `Element` regardless of its conformance to `Equatable`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; let searchView = persons.binarySearchView()<br>&gt;&gt;&gt; let index = persons.indexOf { $0.name == &quot;John Doe&quot; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately however such a `predicate` cannot be used when searching for an element&#39;s property in a sorted(!) collection or a collection of non-`Comparable` elements within a TIME complexity of `O(log2(self.count))` as binary search uses `&lt;` instead of `==` internally and as the &quot;needle&quot; gets passed as both the first (in `indexOf(…)` itself) and second argument (in `lowerBoundOf(…)` which gets called by `indexOf(…)`) to the operator, one cannot simply change `predicate: (E) -&gt; Bool` to `isOrderedBefore: (V, E) -&gt; Bool` as that would result in a type mismatch (`(V, E)` vs. `(E, V)`).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The use of `lensView` however allows one to do just that without making a mess.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; let searchView = persons.binarySearchView() // sorted!<br>&gt;&gt;&gt; let index = searchView.indexOf(&quot;John Doe&quot;) { $0.name }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The `lensView` works similarly to how keypaths work in Objective-C, just type-safe.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The author proposes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Moving `CollectionType.indices` to `Indexable` should not cause any issues with existing code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Changing `indexOf(element:)` to `indexOf(element:range:?)` should not cause any issues with existing code as the `range` argument is optional and the default behaves like it used to.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Changing `indexOf(predicate:)` to `indexOf(range:?predicate:)` should not cause any issues with existing code either, as the `range` argument is optional and the default behaves like it used to. Swift&#39;s trailing-closure magic allows `indexOf(predicate: …)` to still properly map to `indexOf(range: nil, predicate: …)`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. The addition of `rangeOf(…)`, `countOf(…)` and `isSorted(…)` to `Indexable` do not conflict with any existing API.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 4. The introduction of a `BinarySearchView` on `Indexable` does not conflict with any existing API.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The author&#39;s initial approach was to implement all methods on Indexable. This however required all methods to either be provided in two variants (one for unsorted, one for sorted `Indexable`s):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; final public func indexOf(element: _Element, range: Range&lt;Index&gt;? = nil) -&gt; Index? {<br>&gt;&gt;&gt; 	return …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; final public func sortedIndexOf(element: _Element, range: Range&lt;Index&gt;? = nil) -&gt; Index? {<br>&gt;&gt;&gt; 	return …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or require the introduction of an additional argument:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; final public func indexOf(element: _Element, range: Range&lt;Index&gt;? = nil, isSorted: Bool = true) -&gt; Index? {<br>&gt;&gt;&gt;     if isSorted {<br>&gt;&gt;&gt;         return …<br>&gt;&gt;&gt;     } else {<br>&gt;&gt;&gt;         return …<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It also would have cluttered `Indexable` with methods such as `lowerBoundOf` and `upperBoundOf`, which are only ever applicable when `self` is sorted accordingly. The introduction of a dedicated BinarySearchView fixes these issues.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One also would have had to switch from `predicate: (T) -&gt; Bool` to `isOrderedBefore: (T, T) -&gt; Bool` for all methods for the second unified API alternative.<br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/4f5f71f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/357b710213d3c0e01356f7c90f78b9f2?s=50"></div><header><strong>[Proposal]: Drastically improve searching API (indexOf(…)) of CollectionType</strong> from <string>Vincent Esche</string> &lt;regexident.mailinglists at gmail.com&gt;<p>January  5, 2016 at 12:00:00pm</p></header><div class="content"><p>Fair point! I’m all in favor of a simple(r) API. Noted, and thanks for the comment!<br></p><p>&gt; On 05 Jan 2016, at 03:07, Donnacha Oisín Kidney &lt;oisin.kidney at gmail.com&gt; wrote:<br>&gt; <br>&gt; Unless I’m confused, all of the “ranged” overloads can already be achieved by composing ranged subscripts with the indexOf, etc., methods:<br>&gt; <br>&gt; let ar = [0, 1, 2, 3, 4, 5]<br>&gt; let ind = ar[3...5].indexOf { n in n % 2 == 0 }<br>&gt; ar[ind!] // 4<br>&gt; <br>&gt;&gt; On 5 Jan 2016, at 01:00, Vincent Esche via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There are a couple of things I’m not 100% happy with/sure about:<br>&gt;&gt; <br>&gt;&gt; 1.<br>&gt;&gt; I don’t like how it’s<br>&gt;&gt; “&lt;index/range/count&gt;Of(element:range:)” but “&lt;index/range/count&gt;Of(range:predicate:)”.<br>&gt;&gt; The reason I went for “&lt;index/range/count&gt;Of(range:predicate:)” was to go with the standard pattern of putting closures last and thus allowing for trailing closure syntax.<br>&gt;&gt; <br>&gt;&gt; The current order allows for this:<br>&gt;&gt; “&lt;index/range/count&gt;Of(0..10)  { $0.name == “Foobar&quot; }”<br>&gt;&gt; which I like syntax-wise.<br>&gt;&gt; It however makes it look like one was looking for a range (&quot;indexOf(0..10, …)”), not the predicate.<br>&gt;&gt; <br>&gt;&gt; While the alternative requires this:<br>&gt;&gt; “&lt;index/range/count&gt;Of(predicate: { $0.name == “Foobar&quot; }, range: 0..10)”<br>&gt;&gt; <br>&gt;&gt; I’m actually leaning towards the latter now. Dang!<br>&gt;&gt; <br>&gt;&gt; 2.<br>&gt;&gt; I’m unsure about the name of “lensView”. I first went with “transform”, then with “mappingFunction”, but found that neither of those made it clear that the closure should provide a specific view into the element.  Both “transform&quot; and “mappingFunction” imply the transformation from one data type to another. It’s not about transforming. It’s about accessing.<br>&gt;&gt; Thus looked for names of similar patterns and found “keypaths” (kind of) in ObjC and lenses in Haskell. To people familiar with functional programming the name should be clear. The closure passed to “lensView” is basically the getter part of a functional lens.<br>&gt;&gt; Anyway, I’m not too attached to the name and more than open to suggestions.<br>&gt;&gt; <br>&gt;&gt; 3.<br>&gt;&gt; “BinarySearchView.init(base:validateAgainst:)” currently asserts. This should probably be split into two init functions. One assuming the base to be sorted (“BinarySearchView.init(base:)”, O(1)). And one allowing for a check, returning nil on failure (“BinarySearchView.init?(base:validateAgainst:)”, O(self.count)). Or should at least throw an error, instead of panicking.<br>&gt;&gt; <br>&gt;&gt; Note: I made some minor documentation changes/fixes.<br>&gt;&gt; See https://gist.github.com/regexident/2b7531bd748f57679671 &lt;https://gist.github.com/regexident/2b7531bd748f57679671&gt; for up-to-date RFC/source code (vs. Markdown-dump at bottom of OP).<br>&gt;&gt; <br>&gt;&gt; - Vincent<br>&gt;&gt; <br>&gt;&gt;&gt; On 04 Jan 2016, at 16:13, Vincent Esche &lt;regexident.mailinglists at gmail.com &lt;mailto:regexident.mailinglists at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After having had this code laying around on my Mac since 6/26/15 (waiting for Swift to go open source)<br>&gt;&gt;&gt; I figured it’s about damn time I submit the actual RFC for it. So without further ado…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One of the areas where Swift’s stdlib is still quite lacking is searching.<br>&gt;&gt;&gt; Which is a shame as searching (along with indexing) might be among<br>&gt;&gt;&gt; the most important tasks of computer science/software development.<br>&gt;&gt;&gt; One might not need fast collection searches for writing a banal fart or flashlight app,<br>&gt;&gt;&gt; but almost every other app is likely to benefit from having a proper searching API.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So I’d like to fix that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Attached you find a full RFC along with the full and functional source code to make it happen.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d love to hear your opinion on this and will be more than happy to answer questions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Rendered Version + Full Implementation: https://gist.github.com/regexident/2b7531bd748f57679671 &lt;https://gist.github.com/regexident/2b7531bd748f57679671&gt;<br>&gt;&gt;&gt; (The code is tested using Quick/Nimble. Tests would thus have to be ported to Swift’s XCTest.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Vincent<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Markdown-dump for<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; # Improved Collection Search<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;)<br>&gt;&gt;&gt;&gt; * Author(s): [Vincent Esche](https://github.com/regexident &lt;https://github.com/regexident&gt;)<br>&gt;&gt;&gt;&gt; * Status: **Review**<br>&gt;&gt;&gt;&gt; * Review manager: TBD<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This RFC proposes an extension to the currently rather limited and linear searching API of `CollectionType`, that is `indexOf(element:)` and `indexOf(predicate:)`.<br>&gt;&gt;&gt;&gt; It proposes the backwards-compatible refactoring of those existing methods as well as the introduction of a view-based ensemble of methods for efficient binary-search.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution &lt;https://lists.swift.org/pipermail/swift-evolution&gt;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Indexing of and searching in data is a big deal in software development. As such it is crucial to have capable means of doing so in a language that aspires to be a highly performant programming language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift&#39;s current API for searching is basically limited to these two methods on `CollectionType`:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; ```swift<br>&gt;&gt;&gt;&gt; &gt; func indexOf(element: Self.Generator.Element) -&gt; Self.Index?<br>&gt;&gt;&gt;&gt; &gt; ```<br>&gt;&gt;&gt;&gt; &gt; Returns the first index where value appears in self or nil if value is not found.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; **Complexity**: `O(self.count)`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; ```swift<br>&gt;&gt;&gt;&gt; &gt; func indexOf(@noescape predicate: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.Index?<br>&gt;&gt;&gt;&gt; &gt; ```<br>&gt;&gt;&gt;&gt; &gt; Returns the first index where predicate returns true for the corresponding value, or nil if such value is not found.<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; &gt; **Complexity**: `O(self.count)`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The author sees a couple of issue with these two methods:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. They do not provide an option for restricting the &quot;haystack&quot; to a certain `range` of `self`.<br>&gt;&gt;&gt;&gt; 2. They do not provide a fast (`O(log2(self.count))`) path for sorted collections.<br>&gt;&gt;&gt;&gt; 3. They should not be limited to `CollectionType` but instead be moved to `Indexable`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In many situations it is desirable to perform fast searches on sorted collections instead of having to fall back to naïve linear searches.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Further more while a single `index` might be the most common subject of interest, there are many scenarios where a `range` or `count` of matches are of more use.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And anyone who is writing a custom ordered collection type will eventually want to find the insertion index for a given element and will thus end up writing some variant of `lowerBoundOf(…)` or `upperBoundOf(…)` (upon which all the other methods can be implemented, actually).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The author proposes:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. A backwards-compatible refactoring of `CollectionType.indices`, moving it to `Indexable`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. A backwards-compatible refactoring of `indexOf(…)` (adding optional `range:` and moving it to `Indexable`).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. The addition of `rangeOf(…)`, `countOf(…)` and `isSorted(…)` to `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 4. The introduction of a `BinarySearchView` on `Indexable`, allowing for fast (`O(log2(self.count))`) searches on `Indexable` via `indexOf(…)`, `rangeOf(…)`, `countOf(…)`, `lowerBoundOf(…)`, `upperBoundOf(…)` without cluttering `Indexable`&#39;s interface.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ### `CollectionType.indices`:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The author proposes the relocation of `.indices` from `CollectionType` to `Indexable`:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; extension Indexable {<br>&gt;&gt;&gt;&gt;     /// Return the range of valid index values.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// The result&#39;s `endIndex` is the same as that of `self`.  Because<br>&gt;&gt;&gt;&gt;     /// `Range` is half-open, iterating the values of the result produces<br>&gt;&gt;&gt;&gt;     /// all valid subscript arguments for `self`, omitting its `endIndex`.<br>&gt;&gt;&gt;&gt;     public var indices: Range&lt;Self.Index&gt; { get }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; After all all it does is provide a convenience method for generating a Range from its `startIndex` and `endIndex`. There is no need for `self` to be a `CollectionType` for this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This change should not break any existing code as it generalizes the property.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ### `Indexable` of `Comparable` elements:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The author proposes the addition of the following method on `Indexable where Element : Comparable`:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; extension Indexable where Index: RandomAccessIndexType, _Element: Comparable {<br>&gt;&gt;&gt;&gt; 	/// Return true iff all elements in `self` within `range` are sorted according to `isOrderedBefore`.<br>&gt;&gt;&gt;&gt; 	///<br>&gt;&gt;&gt;&gt; 	/// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;&gt; 	public func isSorted(range: Range&lt;Index&gt;? = nil) -&gt; Bool<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This method would perform a linear scan of the `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; An actual implementation of these methods can be found in `Indexable.swift`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ### `Indexable` of `Equatable ` elements:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The author proposes the addition of the following method on `Indexable where Element : Equatable`:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; extension Indexable where Index : RandomAccessIndexType, _Element : Equatable {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Returns the first index where `element` appears in `self`<br>&gt;&gt;&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;&gt;     public func indexOf(element: _Element, range: Range&lt;Index&gt;? = default) -&gt; Self.Index?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Returns the first range where `element` appears in `self`<br>&gt;&gt;&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;&gt;     public func rangeOf(element: _Element, range: Range&lt;Index&gt;? = default) -&gt; Range&lt;Self.Index&gt;?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;&gt;&gt;&gt;     /// within range `range` or `nil` if such an element is not found.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;&gt;     public func countOf(element: _Element, range: Range&lt;Index&gt;? = default) -&gt; Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; These methods would perform a linear scan of the `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; An actual implementation of these methods can be found in `Indexable.swift`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ### `Indexable` of any elements:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The author proposes the addition of the following methods on `Indexable`:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; extension Indexable where Index : RandomAccessIndexType {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Returns the first index where an element appears in `self`<br>&gt;&gt;&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;&gt;     public func indexOf(range: Range&lt;Index&gt;? = default, @noescape predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Self.Index?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Returns the first range where an element appears in `self`<br>&gt;&gt;&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;&gt;     public func rangeOf(range: Range&lt;Index&gt;? = default, @noescape predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Range&lt;Self.Index&gt;?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;&gt;&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;&gt;     public func countOf(range: Range&lt;Index&gt;? = default, @noescape predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Return true iff all elements in `self` within `range` are sorted according to `isOrderedBefore`.<br>&gt;&gt;&gt;&gt;     /// <br>&gt;&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;&gt;     public func isSorted(range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (_Element, _Element) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; These methods would perform a linear scan of the `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; An actual implementation of these methods can be found in `Indexable.swift`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; **Note**: For explanation of and reasoning behind the `lensView:` argument as well as the distinction between `T` and `Base._Element`, see below.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ### `Indexable.binarySearchView(validateAgainst:?)`:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The author proposes the addition of a `binarySearchView(validateAgainst:?)` method on `Indexable` for obtaining a specialized search view for performing searches with O(`log2(self.count)`) complexity:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; extension Indexable where Index: RandomAccessIndexType {<br>&gt;&gt;&gt;&gt; 	/// Create a view into a sorted indexable that allows access within `bounds`.<br>&gt;&gt;&gt;&gt; 	///<br>&gt;&gt;&gt;&gt; 	/// - Complexity: O(`self.count`) if a validation closure is provided, otherwise O(`1`).<br>&gt;&gt;&gt;&gt; 	public func binarySearchView(validateAgainst isOrderedBefore: ((_Element, _Element) -&gt; Bool)? = nil) -&gt; BinarySearchView&lt;Self&gt;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ### `BinarySearchView&lt;T: Indexable&gt;`:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The author proposes the introduction of a `BinarySearchView` struct with the following interface:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; public struct BinarySearchView&lt;Base : Indexable where Base.Index : RandomAccessIndexType&gt; : Indexable {<br>&gt;&gt;&gt;&gt;     public typealias Index = Base.Index<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     public var startIndex: Base.Index { get }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     public var endIndex: Base.Index { get }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     public subscript (position: Index) -&gt; Base._Element { get }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Create a view into a sorted collection `base` that allows access within `bounds`.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// - Complexity: O(1).<br>&gt;&gt;&gt;&gt;     public init(base: Base, validateAgainst isOrderedBefore: ((Base._Element, Base._Element) -&gt; Bool)? = default)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;&gt;&gt;&gt;     /// `lensView(element) &lt; value` evaluates to false or `nil` if `element` is not found.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;&gt;     public func lowerBoundOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Base.Index<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;&gt;&gt;&gt;     /// `value &lt; lensView(element)` evaluates to true or `nil` if `element` is not found.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;&gt;     public func upperBoundOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: ((T, T) -&gt; Bool) = default, @noescape lensView: Base._Element -&gt; T) -&gt; Base.Index<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Returns the first index where an element appears in `self`<br>&gt;&gt;&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;&gt;     public func indexOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Base.Index?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Returns the range where an element appears in `self`<br>&gt;&gt;&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;&gt;     public func rangeOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Range&lt;Base.Index&gt;?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;&gt;&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;&gt;     public func countOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     internal let _base: Base<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As well as the following extension for `Indexable where Element: Comparable`:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; extension BinarySearchView where Base._Element : Comparable {<br>&gt;&gt;&gt;&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;&gt;&gt;&gt;     /// `… &lt; element` evaluates to false or `nil` if `element` is not found.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;&gt;     public func lowerBoundOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Base.Index<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;&gt;&gt;&gt;     /// `element &lt; …` evaluates to true or `nil` if `element` is not found.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;&gt;     public func upperBoundOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Base.Index<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Returns the first index where `element` appears in `self`<br>&gt;&gt;&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;&gt;     public func indexOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Base.Index?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Returns the range where `element` appears in `self`<br>&gt;&gt;&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;&gt;     public func rangeOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Range&lt;Base.Index&gt;?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;&gt;&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;&gt;     public func countOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; These methods would perform a linear scan of the `Indexable` with a TIME complexity of `O(log2(self.count))`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; An actual implementation of these methods can be found in `BinarySearchView.swift`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ### Why `lensView`?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let&#39;s assume one had a collection of Persons like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; struct Person {<br>&gt;&gt;&gt;&gt;     let name: String<br>&gt;&gt;&gt;&gt;     let age: Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let persons: [Person] = [ … ]<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now let&#39;s assume one wanted to find the first person that&#39;s called `John Doe`. One could either change `Person` to conform to `Equatable`, allowing `indexOf(element:)` to be called on `persons`. Now that was easy, wasn&#39;t it?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Fine, but what if one wanted to search `Person`s by both their `name` or their `age` depending on the given use case? You&#39;re out of luck now.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Luckily there is a variant of `indexOf(…)` called `indexOf(predicate:)` that is available for any type of `Element` regardless of its conformance to `Equatable`:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; let searchView = persons.binarySearchView()<br>&gt;&gt;&gt;&gt; let index = persons.indexOf { $0.name == &quot;John Doe&quot; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unfortunately however such a `predicate` cannot be used when searching for an element&#39;s property in a sorted(!) collection or a collection of non-`Comparable` elements within a TIME complexity of `O(log2(self.count))` as binary search uses `&lt;` instead of `==` internally and as the &quot;needle&quot; gets passed as both the first (in `indexOf(…)` itself) and second argument (in `lowerBoundOf(…)` which gets called by `indexOf(…)`) to the operator, one cannot simply change `predicate: (E) -&gt; Bool` to `isOrderedBefore: (V, E) -&gt; Bool` as that would result in a type mismatch (`(V, E)` vs. `(E, V)`).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The use of `lensView` however allows one to do just that without making a mess.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; let searchView = persons.binarySearchView() // sorted!<br>&gt;&gt;&gt;&gt; let index = searchView.indexOf(&quot;John Doe&quot;) { $0.name }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The `lensView` works similarly to how keypaths work in Objective-C, just type-safe.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The author proposes:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Moving `CollectionType.indices` to `Indexable` should not cause any issues with existing code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Changing `indexOf(element:)` to `indexOf(element:range:?)` should not cause any issues with existing code as the `range` argument is optional and the default behaves like it used to.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Changing `indexOf(predicate:)` to `indexOf(range:?predicate:)` should not cause any issues with existing code either, as the `range` argument is optional and the default behaves like it used to. Swift&#39;s trailing-closure magic allows `indexOf(predicate: …)` to still properly map to `indexOf(range: nil, predicate: …)`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. The addition of `rangeOf(…)`, `countOf(…)` and `isSorted(…)` to `Indexable` do not conflict with any existing API.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 4. The introduction of a `BinarySearchView` on `Indexable` does not conflict with any existing API.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The author&#39;s initial approach was to implement all methods on Indexable. This however required all methods to either be provided in two variants (one for unsorted, one for sorted `Indexable`s):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; final public func indexOf(element: _Element, range: Range&lt;Index&gt;? = nil) -&gt; Index? {<br>&gt;&gt;&gt;&gt; 	return …<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; final public func sortedIndexOf(element: _Element, range: Range&lt;Index&gt;? = nil) -&gt; Index? {<br>&gt;&gt;&gt;&gt; 	return …<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or require the introduction of an additional argument:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; final public func indexOf(element: _Element, range: Range&lt;Index&gt;? = nil, isSorted: Bool = true) -&gt; Index? {<br>&gt;&gt;&gt;&gt;     if isSorted {<br>&gt;&gt;&gt;&gt;         return …<br>&gt;&gt;&gt;&gt;     } else {<br>&gt;&gt;&gt;&gt;         return …<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It also would have cluttered `Indexable` with methods such as `lowerBoundOf` and `upperBoundOf`, which are only ever applicable when `self` is sorted accordingly. The introduction of a dedicated BinarySearchView fixes these issues.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One also would have had to switch from `predicate: (T) -&gt; Bool` to `isOrderedBefore: (T, T) -&gt; Bool` for all methods for the second unified API alternative.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/e9b231ad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/357b710213d3c0e01356f7c90f78b9f2?s=50"></div><header><strong>[Proposal]: Drastically improve searching API (indexOf(…)) of CollectionType</strong> from <string>Vincent Esche</string> &lt;regexident.mailinglists at gmail.com&gt;<p>January  7, 2016 at 07:00:00pm</p></header><div class="content"><p>I’ve updated a couple of things in the proposal draft:<br></p><p>1.<br>Given the obvious redundancy of “range:” in the existence of &quot;CollectionType.subscript(bounds:)” I’ve removed it from the proposed API.<br>For the sake of lightweighted-ness and speed “BinarySearchView&quot; now accepts a range and supports ranged subscripts itself (required for efficient implementation of rangeOf).<br></p><p>2.<br>“isOrderedBefore” and “predicate” now support throwing closures, as does the rest of stdlib. Changed affected methods to rethrow accordingly.<br></p><p>3.<br>BinarySearchView now as two initializers: “init(base:bounds?:)” and “init(base:bounds?:isOrderedBefore:) throws”. Changed the latter from &quot;assert()” to &quot;throw BinarySearchViewError.BaseNotSorted”.<br></p><p>This solves two of the issues (1 &amp; 3) I previously had with the implementation.<br></p><p>Updated Proposal Draft: https://gist.github.com/regexident/2b7531bd748f57679671<br></p><p>Any comments welcome.<br></p><p>- Vincent<br></p><p>&gt; On 05 Jan 2016, at 12:15, Vincent Esche &lt;regexident.mailinglists at gmail.com&gt; wrote:<br>&gt; <br>&gt; Fair point! I’m all in favor of a simple(r) API. Noted, and thanks for the comment!<br>&gt; <br>&gt;&gt; On 05 Jan 2016, at 03:07, Donnacha Oisín Kidney &lt;oisin.kidney at gmail.com &lt;mailto:oisin.kidney at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Unless I’m confused, all of the “ranged” overloads can already be achieved by composing ranged subscripts with the indexOf, etc., methods:<br>&gt;&gt; <br>&gt;&gt; let ar = [0, 1, 2, 3, 4, 5]<br>&gt;&gt; let ind = ar[3...5].indexOf { n in n % 2 == 0 }<br>&gt;&gt; ar[ind!] // 4<br>&gt;&gt; <br>&gt;&gt;&gt; On 5 Jan 2016, at 01:00, Vincent Esche via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are a couple of things I’m not 100% happy with/sure about:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1.<br>&gt;&gt;&gt; I don’t like how it’s<br>&gt;&gt;&gt; “&lt;index/range/count&gt;Of(element:range:)” but “&lt;index/range/count&gt;Of(range:predicate:)”.<br>&gt;&gt;&gt; The reason I went for “&lt;index/range/count&gt;Of(range:predicate:)” was to go with the standard pattern of putting closures last and thus allowing for trailing closure syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The current order allows for this:<br>&gt;&gt;&gt; “&lt;index/range/count&gt;Of(0..10)  { $0.name == “Foobar&quot; }”<br>&gt;&gt;&gt; which I like syntax-wise.<br>&gt;&gt;&gt; It however makes it look like one was looking for a range (&quot;indexOf(0..10, …)”), not the predicate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While the alternative requires this:<br>&gt;&gt;&gt; “&lt;index/range/count&gt;Of(predicate: { $0.name == “Foobar&quot; }, range: 0..10)”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m actually leaning towards the latter now. Dang!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2.<br>&gt;&gt;&gt; I’m unsure about the name of “lensView”. I first went with “transform”, then with “mappingFunction”, but found that neither of those made it clear that the closure should provide a specific view into the element.  Both “transform&quot; and “mappingFunction” imply the transformation from one data type to another. It’s not about transforming. It’s about accessing.<br>&gt;&gt;&gt; Thus looked for names of similar patterns and found “keypaths” (kind of) in ObjC and lenses in Haskell. To people familiar with functional programming the name should be clear. The closure passed to “lensView” is basically the getter part of a functional lens.<br>&gt;&gt;&gt; Anyway, I’m not too attached to the name and more than open to suggestions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3.<br>&gt;&gt;&gt; “BinarySearchView.init(base:validateAgainst:)” currently asserts. This should probably be split into two init functions. One assuming the base to be sorted (“BinarySearchView.init(base:)”, O(1)). And one allowing for a check, returning nil on failure (“BinarySearchView.init?(base:validateAgainst:)”, O(self.count)). Or should at least throw an error, instead of panicking.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note: I made some minor documentation changes/fixes.<br>&gt;&gt;&gt; See https://gist.github.com/regexident/2b7531bd748f57679671 &lt;https://gist.github.com/regexident/2b7531bd748f57679671&gt; for up-to-date RFC/source code (vs. Markdown-dump at bottom of OP).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Vincent<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 04 Jan 2016, at 16:13, Vincent Esche &lt;regexident.mailinglists at gmail.com &lt;mailto:regexident.mailinglists at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; After having had this code laying around on my Mac since 6/26/15 (waiting for Swift to go open source)<br>&gt;&gt;&gt;&gt; I figured it’s about damn time I submit the actual RFC for it. So without further ado…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One of the areas where Swift’s stdlib is still quite lacking is searching.<br>&gt;&gt;&gt;&gt; Which is a shame as searching (along with indexing) might be among<br>&gt;&gt;&gt;&gt; the most important tasks of computer science/software development.<br>&gt;&gt;&gt;&gt; One might not need fast collection searches for writing a banal fart or flashlight app,<br>&gt;&gt;&gt;&gt; but almost every other app is likely to benefit from having a proper searching API.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So I’d like to fix that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Attached you find a full RFC along with the full and functional source code to make it happen.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d love to hear your opinion on this and will be more than happy to answer questions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Rendered Version + Full Implementation: https://gist.github.com/regexident/2b7531bd748f57679671 &lt;https://gist.github.com/regexident/2b7531bd748f57679671&gt;<br>&gt;&gt;&gt;&gt; (The code is tested using Quick/Nimble. Tests would thus have to be ported to Swift’s XCTest.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Vincent<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Markdown-dump for<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; # Improved Collection Search<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;)<br>&gt;&gt;&gt;&gt;&gt; * Author(s): [Vincent Esche](https://github.com/regexident &lt;https://github.com/regexident&gt;)<br>&gt;&gt;&gt;&gt;&gt; * Status: **Review**<br>&gt;&gt;&gt;&gt;&gt; * Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This RFC proposes an extension to the currently rather limited and linear searching API of `CollectionType`, that is `indexOf(element:)` and `indexOf(predicate:)`.<br>&gt;&gt;&gt;&gt;&gt; It proposes the backwards-compatible refactoring of those existing methods as well as the introduction of a view-based ensemble of methods for efficient binary-search.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution &lt;https://lists.swift.org/pipermail/swift-evolution&gt;)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Indexing of and searching in data is a big deal in software development. As such it is crucial to have capable means of doing so in a language that aspires to be a highly performant programming language.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift&#39;s current API for searching is basically limited to these two methods on `CollectionType`:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; &gt; func indexOf(element: Self.Generator.Element) -&gt; Self.Index?<br>&gt;&gt;&gt;&gt;&gt; &gt; ```<br>&gt;&gt;&gt;&gt;&gt; &gt; Returns the first index where value appears in self or nil if value is not found.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; **Complexity**: `O(self.count)`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; and:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; &gt; func indexOf(@noescape predicate: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.Index?<br>&gt;&gt;&gt;&gt;&gt; &gt; ```<br>&gt;&gt;&gt;&gt;&gt; &gt; Returns the first index where predicate returns true for the corresponding value, or nil if such value is not found.<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; **Complexity**: `O(self.count)`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The author sees a couple of issue with these two methods:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. They do not provide an option for restricting the &quot;haystack&quot; to a certain `range` of `self`.<br>&gt;&gt;&gt;&gt;&gt; 2. They do not provide a fast (`O(log2(self.count))`) path for sorted collections.<br>&gt;&gt;&gt;&gt;&gt; 3. They should not be limited to `CollectionType` but instead be moved to `Indexable`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In many situations it is desirable to perform fast searches on sorted collections instead of having to fall back to naïve linear searches.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Further more while a single `index` might be the most common subject of interest, there are many scenarios where a `range` or `count` of matches are of more use.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And anyone who is writing a custom ordered collection type will eventually want to find the insertion index for a given element and will thus end up writing some variant of `lowerBoundOf(…)` or `upperBoundOf(…)` (upon which all the other methods can be implemented, actually).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The author proposes:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. A backwards-compatible refactoring of `CollectionType.indices`, moving it to `Indexable`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. A backwards-compatible refactoring of `indexOf(…)` (adding optional `range:` and moving it to `Indexable`).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 3. The addition of `rangeOf(…)`, `countOf(…)` and `isSorted(…)` to `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 4. The introduction of a `BinarySearchView` on `Indexable`, allowing for fast (`O(log2(self.count))`) searches on `Indexable` via `indexOf(…)`, `rangeOf(…)`, `countOf(…)`, `lowerBoundOf(…)`, `upperBoundOf(…)` without cluttering `Indexable`&#39;s interface.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ### `CollectionType.indices`:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The author proposes the relocation of `.indices` from `CollectionType` to `Indexable`:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; extension Indexable {<br>&gt;&gt;&gt;&gt;&gt;     /// Return the range of valid index values.<br>&gt;&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;&gt;     /// The result&#39;s `endIndex` is the same as that of `self`.  Because<br>&gt;&gt;&gt;&gt;&gt;     /// `Range` is half-open, iterating the values of the result produces<br>&gt;&gt;&gt;&gt;&gt;     /// all valid subscript arguments for `self`, omitting its `endIndex`.<br>&gt;&gt;&gt;&gt;&gt;     public var indices: Range&lt;Self.Index&gt; { get }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; After all all it does is provide a convenience method for generating a Range from its `startIndex` and `endIndex`. There is no need for `self` to be a `CollectionType` for this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This change should not break any existing code as it generalizes the property.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ### `Indexable` of `Comparable` elements:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The author proposes the addition of the following method on `Indexable where Element : Comparable`:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; extension Indexable where Index: RandomAccessIndexType, _Element: Comparable {<br>&gt;&gt;&gt;&gt;&gt; 	/// Return true iff all elements in `self` within `range` are sorted according to `isOrderedBefore`.<br>&gt;&gt;&gt;&gt;&gt; 	///<br>&gt;&gt;&gt;&gt;&gt; 	/// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;&gt;&gt; 	public func isSorted(range: Range&lt;Index&gt;? = nil) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This method would perform a linear scan of the `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; An actual implementation of these methods can be found in `Indexable.swift`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ### `Indexable` of `Equatable ` elements:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The author proposes the addition of the following method on `Indexable where Element : Equatable`:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; extension Indexable where Index : RandomAccessIndexType, _Element : Equatable {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     /// Returns the first index where `element` appears in `self`<br>&gt;&gt;&gt;&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;&gt;&gt;     public func indexOf(element: _Element, range: Range&lt;Index&gt;? = default) -&gt; Self.Index?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     /// Returns the first range where `element` appears in `self`<br>&gt;&gt;&gt;&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;&gt;&gt;     public func rangeOf(element: _Element, range: Range&lt;Index&gt;? = default) -&gt; Range&lt;Self.Index&gt;?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;&gt;&gt;&gt;&gt;     /// within range `range` or `nil` if such an element is not found.<br>&gt;&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;&gt;&gt;     public func countOf(element: _Element, range: Range&lt;Index&gt;? = default) -&gt; Int<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; These methods would perform a linear scan of the `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; An actual implementation of these methods can be found in `Indexable.swift`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ### `Indexable` of any elements:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The author proposes the addition of the following methods on `Indexable`:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; extension Indexable where Index : RandomAccessIndexType {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     /// Returns the first index where an element appears in `self`<br>&gt;&gt;&gt;&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;&gt;&gt;     public func indexOf(range: Range&lt;Index&gt;? = default, @noescape predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Self.Index?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     /// Returns the first range where an element appears in `self`<br>&gt;&gt;&gt;&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;&gt;&gt;     public func rangeOf(range: Range&lt;Index&gt;? = default, @noescape predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Range&lt;Self.Index&gt;?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;&gt;&gt;&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;&gt;&gt;     public func countOf(range: Range&lt;Index&gt;? = default, @noescape predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Int<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     /// Return true iff all elements in `self` within `range` are sorted according to `isOrderedBefore`.<br>&gt;&gt;&gt;&gt;&gt;     /// <br>&gt;&gt;&gt;&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;&gt;&gt;&gt;     public func isSorted(range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (_Element, _Element) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; These methods would perform a linear scan of the `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; An actual implementation of these methods can be found in `Indexable.swift`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; **Note**: For explanation of and reasoning behind the `lensView:` argument as well as the distinction between `T` and `Base._Element`, see below.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ### `Indexable.binarySearchView(validateAgainst:?)`:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The author proposes the addition of a `binarySearchView(validateAgainst:?)` method on `Indexable` for obtaining a specialized search view for performing searches with O(`log2(self.count)`) complexity:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; extension Indexable where Index: RandomAccessIndexType {<br>&gt;&gt;&gt;&gt;&gt; 	/// Create a view into a sorted indexable that allows access within `bounds`.<br>&gt;&gt;&gt;&gt;&gt; 	///<br>&gt;&gt;&gt;&gt;&gt; 	/// - Complexity: O(`self.count`) if a validation closure is provided, otherwise O(`1`).<br>&gt;&gt;&gt;&gt;&gt; 	public func binarySearchView(validateAgainst isOrderedBefore: ((_Element, _Element) -&gt; Bool)? = nil) -&gt; BinarySearchView&lt;Self&gt;<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ### `BinarySearchView&lt;T: Indexable&gt;`:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The author proposes the introduction of a `BinarySearchView` struct with the following interface:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; public struct BinarySearchView&lt;Base : Indexable where Base.Index : RandomAccessIndexType&gt; : Indexable {<br>&gt;&gt;&gt;&gt;&gt;     public typealias Index = Base.Index<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     public var startIndex: Base.Index { get }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     public var endIndex: Base.Index { get }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     public subscript (position: Index) -&gt; Base._Element { get }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     /// Create a view into a sorted collection `base` that allows access within `bounds`.<br>&gt;&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;&gt;     /// - Complexity: O(1).<br>&gt;&gt;&gt;&gt;&gt;     public init(base: Base, validateAgainst isOrderedBefore: ((Base._Element, Base._Element) -&gt; Bool)? = default)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;&gt;&gt;&gt;&gt;     /// `lensView(element) &lt; value` evaluates to false or `nil` if `element` is not found.<br>&gt;&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;&gt;&gt;     public func lowerBoundOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Base.Index<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;&gt;&gt;&gt;&gt;     /// `value &lt; lensView(element)` evaluates to true or `nil` if `element` is not found.<br>&gt;&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;&gt;&gt;     public func upperBoundOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: ((T, T) -&gt; Bool) = default, @noescape lensView: Base._Element -&gt; T) -&gt; Base.Index<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     /// Returns the first index where an element appears in `self`<br>&gt;&gt;&gt;&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;&gt;&gt;     public func indexOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Base.Index?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     /// Returns the range where an element appears in `self`<br>&gt;&gt;&gt;&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;&gt;&gt;     public func rangeOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Range&lt;Base.Index&gt;?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;&gt;&gt;&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;&gt;&gt;     public func countOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Int<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     internal let _base: Base<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As well as the following extension for `Indexable where Element: Comparable`:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; extension BinarySearchView where Base._Element : Comparable {<br>&gt;&gt;&gt;&gt;&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;&gt;&gt;&gt;&gt;     /// `… &lt; element` evaluates to false or `nil` if `element` is not found.<br>&gt;&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;&gt;&gt;     public func lowerBoundOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Base.Index<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;&gt;&gt;&gt;&gt;     /// `element &lt; …` evaluates to true or `nil` if `element` is not found.<br>&gt;&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;&gt;&gt;     public func upperBoundOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Base.Index<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     /// Returns the first index where `element` appears in `self`<br>&gt;&gt;&gt;&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;&gt;&gt;     public func indexOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Base.Index?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     /// Returns the range where `element` appears in `self`<br>&gt;&gt;&gt;&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;&gt;&gt;     public func rangeOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Range&lt;Base.Index&gt;?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;&gt;&gt;&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;&gt;&gt;&gt;     ///<br>&gt;&gt;&gt;&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;&gt;&gt;&gt;     public func countOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Int<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; These methods would perform a linear scan of the `Indexable` with a TIME complexity of `O(log2(self.count))`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; An actual implementation of these methods can be found in `BinarySearchView.swift`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ### Why `lensView`?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let&#39;s assume one had a collection of Persons like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; struct Person {<br>&gt;&gt;&gt;&gt;&gt;     let name: String<br>&gt;&gt;&gt;&gt;&gt;     let age: Int<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let persons: [Person] = [ … ]<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now let&#39;s assume one wanted to find the first person that&#39;s called `John Doe`. One could either change `Person` to conform to `Equatable`, allowing `indexOf(element:)` to be called on `persons`. Now that was easy, wasn&#39;t it?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Fine, but what if one wanted to search `Person`s by both their `name` or their `age` depending on the given use case? You&#39;re out of luck now.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Luckily there is a variant of `indexOf(…)` called `indexOf(predicate:)` that is available for any type of `Element` regardless of its conformance to `Equatable`:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; let searchView = persons.binarySearchView()<br>&gt;&gt;&gt;&gt;&gt; let index = persons.indexOf { $0.name == &quot;John Doe&quot; }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Unfortunately however such a `predicate` cannot be used when searching for an element&#39;s property in a sorted(!) collection or a collection of non-`Comparable` elements within a TIME complexity of `O(log2(self.count))` as binary search uses `&lt;` instead of `==` internally and as the &quot;needle&quot; gets passed as both the first (in `indexOf(…)` itself) and second argument (in `lowerBoundOf(…)` which gets called by `indexOf(…)`) to the operator, one cannot simply change `predicate: (E) -&gt; Bool` to `isOrderedBefore: (V, E) -&gt; Bool` as that would result in a type mismatch (`(V, E)` vs. `(E, V)`).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The use of `lensView` however allows one to do just that without making a mess.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; let searchView = persons.binarySearchView() // sorted!<br>&gt;&gt;&gt;&gt;&gt; let index = searchView.indexOf(&quot;John Doe&quot;) { $0.name }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The `lensView` works similarly to how keypaths work in Objective-C, just type-safe.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The author proposes:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. Moving `CollectionType.indices` to `Indexable` should not cause any issues with existing code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. Changing `indexOf(element:)` to `indexOf(element:range:?)` should not cause any issues with existing code as the `range` argument is optional and the default behaves like it used to.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. Changing `indexOf(predicate:)` to `indexOf(range:?predicate:)` should not cause any issues with existing code either, as the `range` argument is optional and the default behaves like it used to. Swift&#39;s trailing-closure magic allows `indexOf(predicate: …)` to still properly map to `indexOf(range: nil, predicate: …)`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 3. The addition of `rangeOf(…)`, `countOf(…)` and `isSorted(…)` to `Indexable` do not conflict with any existing API.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 4. The introduction of a `BinarySearchView` on `Indexable` does not conflict with any existing API.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The author&#39;s initial approach was to implement all methods on Indexable. This however required all methods to either be provided in two variants (one for unsorted, one for sorted `Indexable`s):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; final public func indexOf(element: _Element, range: Range&lt;Index&gt;? = nil) -&gt; Index? {<br>&gt;&gt;&gt;&gt;&gt; 	return …<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; final public func sortedIndexOf(element: _Element, range: Range&lt;Index&gt;? = nil) -&gt; Index? {<br>&gt;&gt;&gt;&gt;&gt; 	return …<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Or require the introduction of an additional argument:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; final public func indexOf(element: _Element, range: Range&lt;Index&gt;? = nil, isSorted: Bool = true) -&gt; Index? {<br>&gt;&gt;&gt;&gt;&gt;     if isSorted {<br>&gt;&gt;&gt;&gt;&gt;         return …<br>&gt;&gt;&gt;&gt;&gt;     } else {<br>&gt;&gt;&gt;&gt;&gt;         return …<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It also would have cluttered `Indexable` with methods such as `lowerBoundOf` and `upperBoundOf`, which are only ever applicable when `self` is sorted accordingly. The introduction of a dedicated BinarySearchView fixes these issues.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One also would have had to switch from `predicate: (T) -&gt; Bool` to `isOrderedBefore: (T, T) -&gt; Bool` for all methods for the second unified API alternative.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/041ca16d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bd58c3ddbbd7ee00d675f3e95214663d?s=50"></div><header><strong>[Proposal]: Drastically improve searching API (indexOf(…)) of CollectionType</strong> from <string>Florian Bachmann</string> &lt;bachmann.florian at gmail.com&gt;<p>January  5, 2016 at 05:00:00pm</p></header><div class="content"><p>Hey Vincent,<br>good proposal, love to see this in production. Better collection search<br>would become quite handy :-)<br></p><p>regards,<br>Flori<br></p><p>On Mon, Jan 4, 2016 at 4:13 PM, Vincent Esche via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; After having had this code laying around on my Mac since 6/26/15 (waiting<br>&gt; for Swift to go open source)<br>&gt; I figured it’s about damn time I submit the actual RFC for it. So without<br>&gt; further ado…<br>&gt;<br>&gt; One of the areas where Swift’s stdlib is still quite lacking is searching.<br>&gt; Which is a shame as searching (along with indexing) might be among<br>&gt; the most important tasks of computer science/software development.<br>&gt; One might not need fast collection searches for writing a banal fart or<br>&gt; flashlight app,<br>&gt; but almost every other app is likely to benefit from having a proper<br>&gt; searching API.<br>&gt;<br>&gt; So I’d like to fix that.<br>&gt;<br>&gt; Attached you find a full RFC along with the full and functional source<br>&gt; code to make it happen.<br>&gt;<br>&gt; I’d love to hear your opinion on this and will be more than happy to<br>&gt; answer questions.<br>&gt;<br>&gt; Rendered Version + Full Implementation:<br>&gt; https://gist.github.com/regexident/2b7531bd748f57679671<br>&gt; (The code is tested using Quick/Nimble. Tests would thus have to be ported<br>&gt; to Swift’s XCTest.)<br>&gt;<br>&gt; - Vincent<br>&gt;<br>&gt; Markdown-dump for<br>&gt;<br>&gt; # Improved Collection Search<br>&gt;<br>&gt; * Proposal: [SE-NNNN](<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md<br>&gt; )<br>&gt; * Author(s): [Vincent Esche](https://github.com/regexident)<br>&gt; * Status: **Review**<br>&gt; * Review manager: TBD<br>&gt;<br>&gt; ## Introduction<br>&gt;<br>&gt; This RFC proposes an extension to the currently rather limited and linear<br>&gt; searching API of `CollectionType`, that is `indexOf(element:)` and<br>&gt; `indexOf(predicate:)`.<br>&gt; It proposes the backwards-compatible refactoring of those existing methods<br>&gt; as well as the introduction of a view-based ensemble of methods for<br>&gt; efficient binary-search.<br>&gt;<br>&gt; Swift-evolution thread: [link to the discussion thread for that proposal](<br>&gt; https://lists.swift.org/pipermail/swift-evolution)<br>&gt;<br>&gt; ## Motivation<br>&gt;<br>&gt; Indexing of and searching in data is a big deal in software development.<br>&gt; As such it is crucial to have capable means of doing so in a language that<br>&gt; aspires to be a highly performant programming language.<br>&gt;<br>&gt; Swift&#39;s current API for searching is basically limited to these two<br>&gt; methods on `CollectionType`:<br>&gt;<br>&gt; &gt; ```swift<br>&gt; &gt; func indexOf(element: Self.Generator.Element) -&gt; Self.Index?<br>&gt; &gt; ```<br>&gt; &gt; Returns the first index where value appears in self or nil if value is<br>&gt; not found.<br>&gt; &gt;<br>&gt; &gt; **Complexity**: `O(self.count)`.<br>&gt;<br>&gt; and:<br>&gt;<br>&gt; &gt; ```swift<br>&gt; &gt; func indexOf(@noescape predicate: (Self.Generator.Element) throws -&gt;<br>&gt; Bool) rethrows -&gt; Self.Index?<br>&gt; &gt; ```<br>&gt; &gt; Returns the first index where predicate returns true for the<br>&gt; corresponding value, or nil if such value is not found.<br>&gt; &gt;<br>&gt; &gt; **Complexity**: `O(self.count)`.<br>&gt;<br>&gt; The author sees a couple of issue with these two methods:<br>&gt;<br>&gt; 1. They do not provide an option for restricting the &quot;haystack&quot; to a<br>&gt; certain `range` of `self`.<br>&gt; 2. They do not provide a fast (`O(log2(self.count))`) path for sorted<br>&gt; collections.<br>&gt; 3. They should not be limited to `CollectionType` but instead be moved to<br>&gt; `Indexable`.<br>&gt;<br>&gt; In many situations it is desirable to perform fast searches on sorted<br>&gt; collections instead of having to fall back to naïve linear searches.<br>&gt;<br>&gt; Further more while a single `index` might be the most common subject of<br>&gt; interest, there are many scenarios where a `range` or `count` of matches<br>&gt; are of more use.<br>&gt;<br>&gt; And anyone who is writing a custom ordered collection type will eventually<br>&gt; want to find the insertion index for a given element and will thus end up<br>&gt; writing some variant of `lowerBoundOf(…)` or `upperBoundOf(…)` (upon which<br>&gt; all the other methods can be implemented, actually).<br>&gt;<br>&gt; ## Proposed solution<br>&gt;<br>&gt; The author proposes:<br>&gt;<br>&gt; 1. A backwards-compatible refactoring of `CollectionType.indices`, moving<br>&gt; it to `Indexable`.<br>&gt;<br>&gt; 2. A backwards-compatible refactoring of `indexOf(…)` (adding optional<br>&gt; `range:` and moving it to `Indexable`).<br>&gt;<br>&gt; 3. The addition of `rangeOf(…)`, `countOf(…)` and `isSorted(…)` to<br>&gt; `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;<br>&gt; 4. The introduction of a `BinarySearchView` on `Indexable`, allowing for<br>&gt; fast (`O(log2(self.count))`) searches on `Indexable` via `indexOf(…)`,<br>&gt; `rangeOf(…)`, `countOf(…)`, `lowerBoundOf(…)`, `upperBoundOf(…)` without<br>&gt; cluttering `Indexable`&#39;s interface.<br>&gt;<br>&gt; ## Detailed design<br>&gt;<br>&gt; ### `CollectionType.indices`:<br>&gt;<br>&gt; The author proposes the relocation of `.indices` from `CollectionType` to<br>&gt; `Indexable`:<br>&gt;<br>&gt; ```swift<br>&gt; extension Indexable {<br>&gt;     /// Return the range of valid index values.<br>&gt;     ///<br>&gt;     /// The result&#39;s `endIndex` is the same as that of `self`.  Because<br>&gt;     /// `Range` is half-open, iterating the values of the result produces<br>&gt;     /// all valid subscript arguments for `self`, omitting its `endIndex`.<br>&gt;     public var indices: Range&lt;Self.Index&gt; { get }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; After all all it does is provide a convenience method for generating a<br>&gt; Range from its `startIndex` and `endIndex`. There is no need for `self` to<br>&gt; be a `CollectionType` for this.<br>&gt;<br>&gt; This change should not break any existing code as it generalizes the<br>&gt; property.<br>&gt;<br>&gt; ### `Indexable` of `Comparable` elements:<br>&gt;<br>&gt; The author proposes the addition of the following method on `Indexable<br>&gt; where Element : Comparable`:<br>&gt;<br>&gt; ```swift<br>&gt; extension Indexable where Index: RandomAccessIndexType, _Element:<br>&gt; Comparable {<br>&gt; /// Return true iff all elements in `self` within `range` are sorted<br>&gt; according to `isOrderedBefore`.<br>&gt; ///<br>&gt; /// - Complexity: O(`self.count`)<br>&gt; public func isSorted(range: Range&lt;Index&gt;? = nil) -&gt; Bool<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; This method would perform a linear scan of the `Indexable` with a TIME<br>&gt; complexity of `O(self.count)`.<br>&gt;<br>&gt; An actual implementation of these methods can be found in<br>&gt; `Indexable.swift`.<br>&gt;<br>&gt; ### `Indexable` of `Equatable ` elements:<br>&gt;<br>&gt; The author proposes the addition of the following method on `Indexable<br>&gt; where Element : Equatable`:<br>&gt;<br>&gt; ```swift<br>&gt; extension Indexable where Index : RandomAccessIndexType, _Element :<br>&gt; Equatable {<br>&gt;<br>&gt;     /// Returns the first index where `element` appears in `self`<br>&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`self.count`)<br>&gt;     public func indexOf(element: _Element, range: Range&lt;Index&gt;? = default)<br>&gt; -&gt; Self.Index?<br>&gt;<br>&gt;     /// Returns the first range where `element` appears in `self`<br>&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`self.count`)<br>&gt;     public func rangeOf(element: _Element, range: Range&lt;Index&gt;? = default)<br>&gt; -&gt; Range&lt;Self.Index&gt;?<br>&gt;<br>&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;     /// within range `range` or `nil` if such an element is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`self.count`)<br>&gt;     public func countOf(element: _Element, range: Range&lt;Index&gt;? = default)<br>&gt; -&gt; Int<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; These methods would perform a linear scan of the `Indexable` with a TIME<br>&gt; complexity of `O(self.count)`.<br>&gt;<br>&gt; An actual implementation of these methods can be found in<br>&gt; `Indexable.swift`.<br>&gt;<br>&gt; ### `Indexable` of any elements:<br>&gt;<br>&gt; The author proposes the addition of the following methods on `Indexable`:<br>&gt;<br>&gt; ```swift<br>&gt; extension Indexable where Index : RandomAccessIndexType {<br>&gt;<br>&gt;     /// Returns the first index where an element appears in `self`<br>&gt;     /// within range `range` for which `lensView(element) == value` or<br>&gt; `nil` if such an element is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`self.count`)<br>&gt;     public func indexOf(range: Range&lt;Index&gt;? = default, @noescape<br>&gt; predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Self.Index?<br>&gt;<br>&gt;     /// Returns the first range where an element appears in `self`<br>&gt;     /// within range `range` for which `lensView(element) == value` or<br>&gt; `nil` if such an element is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`self.count`)<br>&gt;     public func rangeOf(range: Range&lt;Index&gt;? = default, @noescape<br>&gt; predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Range&lt;Self.Index&gt;?<br>&gt;<br>&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`self.count`)<br>&gt;     public func countOf(range: Range&lt;Index&gt;? = default, @noescape<br>&gt; predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Int<br>&gt;<br>&gt;     /// Return true iff all elements in `self` within `range` are sorted<br>&gt; according to `isOrderedBefore`.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`self.count`)<br>&gt;     public func isSorted(range: Range&lt;Index&gt;? = default, @noescape<br>&gt; isOrderedBefore: (_Element, _Element) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; These methods would perform a linear scan of the `Indexable` with a TIME<br>&gt; complexity of `O(self.count)`.<br>&gt;<br>&gt; An actual implementation of these methods can be found in<br>&gt; `Indexable.swift`.<br>&gt;<br>&gt; **Note**: For explanation of and reasoning behind the `lensView:` argument<br>&gt; as well as the distinction between `T` and `Base._Element`, see below.<br>&gt;<br>&gt; ### `Indexable.binarySearchView(validateAgainst:?)`:<br>&gt;<br>&gt; The author proposes the addition of a<br>&gt; `binarySearchView(validateAgainst:?)` method on `Indexable` for obtaining a<br>&gt; specialized search view for performing searches with O(`log2(self.count)`)<br>&gt; complexity:<br>&gt;<br>&gt; ```swift<br>&gt; extension Indexable where Index: RandomAccessIndexType {<br>&gt; /// Create a view into a sorted indexable that allows access within<br>&gt; `bounds`.<br>&gt; ///<br>&gt; /// - Complexity: O(`self.count`) if a validation closure is provided,<br>&gt; otherwise O(`1`).<br>&gt; public func binarySearchView(validateAgainst isOrderedBefore: ((_Element,<br>&gt; _Element) -&gt; Bool)? = nil) -&gt; BinarySearchView&lt;Self&gt;<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; ### `BinarySearchView&lt;T: Indexable&gt;`:<br>&gt;<br>&gt; The author proposes the introduction of a `BinarySearchView` struct with<br>&gt; the following interface:<br>&gt;<br>&gt; ```swift<br>&gt; public struct BinarySearchView&lt;Base : Indexable where Base.Index :<br>&gt; RandomAccessIndexType&gt; : Indexable {<br>&gt;     public typealias Index = Base.Index<br>&gt;<br>&gt;     public var startIndex: Base.Index { get }<br>&gt;<br>&gt;     public var endIndex: Base.Index { get }<br>&gt;<br>&gt;     public subscript (position: Index) -&gt; Base._Element { get }<br>&gt;<br>&gt;     /// Create a view into a sorted collection `base` that allows access<br>&gt; within `bounds`.<br>&gt;     ///<br>&gt;     /// - Complexity: O(1).<br>&gt;     public init(base: Base, validateAgainst isOrderedBefore:<br>&gt; ((Base._Element, Base._Element) -&gt; Bool)? = default)<br>&gt;<br>&gt;     /// Returns first index of the first `element` in `self` within range<br>&gt; `range` for which<br>&gt;     /// `lensView(element) &lt; value` evaluates to false or `nil` if<br>&gt; `element` is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;     public func lowerBoundOf&lt;T : Comparable&gt;(value: T, range:<br>&gt; Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool =<br>&gt; default, @noescape lensView: Base._Element -&gt; T) -&gt; Base.Index<br>&gt;<br>&gt;     /// Returns first index of the first `element` in `self` within range<br>&gt; `range` for which<br>&gt;     /// `value &lt; lensView(element)` evaluates to true or `nil` if<br>&gt; `element` is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;     public func upperBoundOf&lt;T : Comparable&gt;(value: T, range:<br>&gt; Range&lt;Index&gt;? = default, @noescape isOrderedBefore: ((T, T) -&gt; Bool) =<br>&gt; default, @noescape lensView: Base._Element -&gt; T) -&gt; Base.Index<br>&gt;<br>&gt;     /// Returns the first index where an element appears in `self`<br>&gt;     /// within range `range` for which `lensView(element) == value` or<br>&gt; `nil` if such an element is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;     public func indexOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? =<br>&gt; default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape<br>&gt; lensView: Base._Element -&gt; T) -&gt; Base.Index?<br>&gt;<br>&gt;     /// Returns the range where an element appears in `self`<br>&gt;     /// within range `range` for which `lensView(element) == value` or<br>&gt; `nil` if such an element is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;     public func rangeOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? =<br>&gt; default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape<br>&gt; lensView: Base._Element -&gt; T) -&gt; Range&lt;Base.Index&gt;?<br>&gt;<br>&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;     /// within range `range` for which `lensView(element) == value` or<br>&gt; `nil` if such an element is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;     public func countOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? =<br>&gt; default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape<br>&gt; lensView: Base._Element -&gt; T) -&gt; Int<br>&gt;<br>&gt;     internal let _base: Base<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; As well as the following extension for `Indexable where Element:<br>&gt; Comparable`:<br>&gt;<br>&gt; ```swift<br>&gt; extension BinarySearchView where Base._Element : Comparable {<br>&gt;     /// Returns first index of the first `element` in `self` within range<br>&gt; `range` for which<br>&gt;     /// `… &lt; element` evaluates to false or `nil` if `element` is not<br>&gt; found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;     public func lowerBoundOf(element: Base._Element, range: Range&lt;Index&gt;?<br>&gt; = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt;<br>&gt; Bool = default) -&gt; Base.Index<br>&gt;<br>&gt;     /// Returns first index of the first `element` in `self` within range<br>&gt; `range` for which<br>&gt;     /// `element &lt; …` evaluates to true or `nil` if `element` is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;     public func upperBoundOf(element: Base._Element, range: Range&lt;Index&gt;?<br>&gt; = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt;<br>&gt; Bool = default) -&gt; Base.Index<br>&gt;<br>&gt;     /// Returns the first index where `element` appears in `self`<br>&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;     public func indexOf(element: Base._Element, range: Range&lt;Index&gt;? =<br>&gt; default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool<br>&gt; = default) -&gt; Base.Index?<br>&gt;<br>&gt;     /// Returns the range where `element` appears in `self`<br>&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;     public func rangeOf(element: Base._Element, range: Range&lt;Index&gt;? =<br>&gt; default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool<br>&gt; = default) -&gt; Range&lt;Base.Index&gt;?<br>&gt;<br>&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;     ///<br>&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;     public func countOf(element: Base._Element, range: Range&lt;Index&gt;? =<br>&gt; default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool<br>&gt; = default) -&gt; Int<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; These methods would perform a linear scan of the `Indexable` with a TIME<br>&gt; complexity of `O(log2(self.count))`.<br>&gt;<br>&gt; An actual implementation of these methods can be found in<br>&gt; `BinarySearchView.swift`.<br>&gt;<br>&gt; ### Why `lensView`?<br>&gt;<br>&gt; Let&#39;s assume one had a collection of Persons like this:<br>&gt;<br>&gt; ```swift<br>&gt; struct Person {<br>&gt;     let name: String<br>&gt;     let age: Int<br>&gt; }<br>&gt;<br>&gt; let persons: [Person] = [ … ]<br>&gt; ```<br>&gt;<br>&gt; Now let&#39;s assume one wanted to find the first person that&#39;s called `John<br>&gt; Doe`. One could either change `Person` to conform to `Equatable`, allowing<br>&gt; `indexOf(element:)` to be called on `persons`. Now that was easy, wasn&#39;t it?<br>&gt;<br>&gt; Fine, but what if one wanted to search `Person`s by both their `name` or<br>&gt; their `age` depending on the given use case? You&#39;re out of luck now.<br>&gt;<br>&gt; Luckily there is a variant of `indexOf(…)` called `indexOf(predicate:)`<br>&gt; that is available for any type of `Element` regardless of its conformance<br>&gt; to `Equatable`:<br>&gt;<br>&gt; ```swift<br>&gt; let searchView = persons.binarySearchView()<br>&gt; let index = persons.indexOf { $0.name == &quot;John Doe&quot; }<br>&gt; ```<br>&gt;<br>&gt; Unfortunately however such a `predicate` cannot be used when searching for<br>&gt; an element&#39;s property in a sorted(!) collection or a collection of<br>&gt; non-`Comparable` elements within a TIME complexity of `O(log2(self.count))`<br>&gt; as binary search uses `&lt;` instead of `==` internally and as the &quot;needle&quot;<br>&gt; gets passed as both the first (in `indexOf(…)` itself) and second argument<br>&gt; (in `lowerBoundOf(…)` which gets called by `indexOf(…)`) to the operator,<br>&gt; one cannot simply change `predicate: (E) -&gt; Bool` to `isOrderedBefore: (V,<br>&gt; E) -&gt; Bool` as that would result in a type mismatch (`(V, E)` vs. `(E, V)`).<br>&gt;<br>&gt; The use of `lensView` however allows one to do just that without making a<br>&gt; mess.<br>&gt;<br>&gt; ```swift<br>&gt; let searchView = persons.binarySearchView() // sorted!<br>&gt; let index = searchView.indexOf(&quot;John Doe&quot;) { $0.name }<br>&gt; ```<br>&gt;<br>&gt; The `lensView` works similarly to how keypaths work in Objective-C, just<br>&gt; type-safe.<br>&gt;<br>&gt; ## Impact on existing code<br>&gt;<br>&gt; The author proposes:<br>&gt;<br>&gt; 1. Moving `CollectionType.indices` to `Indexable` should not cause any<br>&gt; issues with existing code.<br>&gt;<br>&gt; 2. Changing `indexOf(element:)` to `indexOf(element:range:?)` should not<br>&gt; cause any issues with existing code as the `range` argument is optional and<br>&gt; the default behaves like it used to.<br>&gt;<br>&gt; 2. Changing `indexOf(predicate:)` to `indexOf(range:?predicate:)` should<br>&gt; not cause any issues with existing code either, as the `range` argument is<br>&gt; optional and the default behaves like it used to. Swift&#39;s trailing-closure<br>&gt; magic allows `indexOf(predicate: …)` to still properly map to<br>&gt; `indexOf(range: nil, predicate: …)`.<br>&gt;<br>&gt; 3. The addition of `rangeOf(…)`, `countOf(…)` and `isSorted(…)` to<br>&gt; `Indexable` do not conflict with any existing API.<br>&gt;<br>&gt; 4. The introduction of a `BinarySearchView` on `Indexable` does not<br>&gt; conflict with any existing API.<br>&gt;<br>&gt; ## Alternatives considered<br>&gt;<br>&gt; The author&#39;s initial approach was to implement all methods on Indexable.<br>&gt; This however required all methods to either be provided in two variants<br>&gt; (one for unsorted, one for sorted `Indexable`s):<br>&gt;<br>&gt; ```swift<br>&gt; final public func indexOf(element: _Element, range: Range&lt;Index&gt;? = nil)<br>&gt; -&gt; Index? {<br>&gt; return …<br>&gt; }<br>&gt;<br>&gt; final public func sortedIndexOf(element: _Element, range: Range&lt;Index&gt;? =<br>&gt; nil) -&gt; Index? {<br>&gt; return …<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; Or require the introduction of an additional argument:<br>&gt;<br>&gt; ```swift<br>&gt; final public func indexOf(element: _Element, range: Range&lt;Index&gt;? = nil,<br>&gt; isSorted: Bool = true) -&gt; Index? {<br>&gt;     if isSorted {<br>&gt;         return …<br>&gt;     } else {<br>&gt;         return …<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; It also would have cluttered `Indexable` with methods such as<br>&gt; `lowerBoundOf` and `upperBoundOf`, which are only ever applicable when<br>&gt; `self` is sorted accordingly. The introduction of a dedicated<br>&gt; BinarySearchView fixes these issues.<br>&gt;<br>&gt; One also would have had to switch from `predicate: (T) -&gt; Bool` to<br>&gt; `isOrderedBefore: (T, T) -&gt; Bool` for all methods for the second unified<br>&gt; API alternative.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/fcc17425/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dc18a7074ca1d3f16d35f1a86c3a87c1?s=50"></div><header><strong>[Proposal]: Drastically improve searching API (indexOf(…)) of CollectionType</strong> from <string>Nikolaj Schumacher</string> &lt;me at nschum.de&gt;<p>January  7, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi Vincent,<br></p><p>I’m all for more search in the standard library. Most of these functions are very likely to be re-implemented in slightly different ways across projects and therefore would benefit from standardization.<br></p><p>Here are my notes on things that I think need some work:<br></p><p>- I dislike the possible assumption of a Collection to be “sorted&quot; without validation. That’s an optimization that I consider too risky for a standard library. I think validation should be mandatory and also a “precondition&quot; rather than a thrown error. (What are you supposed to do when you catch the error? The only thing I can think of is: Sort and try again.)<br></p><p>[Note: I only realized before sending that you had just changed this *to* an error. Why?]<br></p><p>- To me the name “binarySearchView” actually implies that it’s a sorted view into the collection (i.e. sorted once for O(log n) lookups afterwards). I would look for a different name, perhaps this one, inspired by your comment and modelled after “lazy&quot;:<br></p><p>let index = assumeSorted(persons).indexOf(&quot;John Doe”)<br></p><p>- I find it especially problematic that each method in BinarySearchView requires that the collection be sorted according to that method’s arguments beforehand. That is, the interface will let me use methods with any comparison function even though just one will work.<br></p><p>let persons = [Person(name: &quot;Alice&quot;, age: 50), Person(name: &quot;Bob&quot;, age: 30)]<br>let searchView = persons.binarySearchView // assuming sorted!<br>searchView.indexOf(Person(name: &quot;Alice&quot;, age: 50), isOrderedBefore: &lt;) // works<br>searchView.indexOf(Person(name: &quot;Alice&quot;, age: 50), isOrderedBefore: &gt;) // nonsense<br></p><p>The same applies to &quot;lensViews&quot;: The following code is wrong, but looks fine at first glance:<br></p><p>let searchView = persons.binarySearchView // assuming sorted!<br>searchView.indexOf(&quot;John Doe&quot;) { $0.name } // works<br>searchView.indexOf(30) { $0.ago } // nonsense<br></p><p>It would be safer to make both properties of the searchView to avoid that possibility in the first place.<br></p><p>let searchView = persons.binarySearchView(&lt;, {$0.name}) // assuming sorted!<br>searchView.indexOf(&quot;John Doe”)<br></p><p>- Have you considered just returning dictionaries, like Python’s “Counter&quot;? That’s O(n), the same as the cost of validation, but allows O(1) lookups afterwards, even if the collection isn’t sorted.<br></p><p>- Have you considered including subsequence search?<br></p><p>Conclusion:<br>- Search functions, yes please!<br>- Search views need work, but might not even be worth it if validation is mandatory<br>- I would probably just remove lensView and maybe put that into separate proposal and consider its use across the entire stdlib. It seems like an orthogonal issue and the proposal would be more focused without. But I don’t see much benefit over using “map”, yet.<br></p><p><br>Nik<br></p><p><br></p><p>&gt; On 4 Jan 2016, at 16:13, Vincent Esche via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; After having had this code laying around on my Mac since 6/26/15 (waiting for Swift to go open source)<br>&gt; I figured it’s about damn time I submit the actual RFC for it. So without further ado…<br>&gt; <br>&gt; One of the areas where Swift’s stdlib is still quite lacking is searching.<br>&gt; Which is a shame as searching (along with indexing) might be among<br>&gt; the most important tasks of computer science/software development.<br>&gt; One might not need fast collection searches for writing a banal fart or flashlight app,<br>&gt; but almost every other app is likely to benefit from having a proper searching API.<br>&gt; <br>&gt; So I’d like to fix that.<br>&gt; <br>&gt; Attached you find a full RFC along with the full and functional source code to make it happen.<br>&gt; <br>&gt; I’d love to hear your opinion on this and will be more than happy to answer questions.<br>&gt; <br>&gt; Rendered Version + Full Implementation: https://gist.github.com/regexident/2b7531bd748f57679671 &lt;https://gist.github.com/regexident/2b7531bd748f57679671&gt;<br>&gt; (The code is tested using Quick/Nimble. Tests would thus have to be ported to Swift’s XCTest.)<br>&gt; <br>&gt; - Vincent<br>&gt; <br>&gt;&gt; Markdown-dump for<br>&gt;&gt; <br>&gt;&gt; # Improved Collection Search<br>&gt;&gt; <br>&gt;&gt; * Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;)<br>&gt;&gt; * Author(s): [Vincent Esche](https://github.com/regexident &lt;https://github.com/regexident&gt;)<br>&gt;&gt; * Status: **Review**<br>&gt;&gt; * Review manager: TBD<br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; This RFC proposes an extension to the currently rather limited and linear searching API of `CollectionType`, that is `indexOf(element:)` and `indexOf(predicate:)`.<br>&gt;&gt; It proposes the backwards-compatible refactoring of those existing methods as well as the introduction of a view-based ensemble of methods for efficient binary-search.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution &lt;https://lists.swift.org/pipermail/swift-evolution&gt;)<br>&gt;&gt; <br>&gt;&gt; ## Motivation<br>&gt;&gt; <br>&gt;&gt; Indexing of and searching in data is a big deal in software development. As such it is crucial to have capable means of doing so in a language that aspires to be a highly performant programming language.<br>&gt;&gt; <br>&gt;&gt; Swift&#39;s current API for searching is basically limited to these two methods on `CollectionType`:<br>&gt;&gt; <br>&gt;&gt; &gt; ```swift<br>&gt;&gt; &gt; func indexOf(element: Self.Generator.Element) -&gt; Self.Index?<br>&gt;&gt; &gt; ```<br>&gt;&gt; &gt; Returns the first index where value appears in self or nil if value is not found.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; **Complexity**: `O(self.count)`.<br>&gt;&gt; <br>&gt;&gt; and:<br>&gt;&gt; <br>&gt;&gt; &gt; ```swift<br>&gt;&gt; &gt; func indexOf(@noescape predicate: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.Index?<br>&gt;&gt; &gt; ```<br>&gt;&gt; &gt; Returns the first index where predicate returns true for the corresponding value, or nil if such value is not found.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; **Complexity**: `O(self.count)`.<br>&gt;&gt; <br>&gt;&gt; The author sees a couple of issue with these two methods:<br>&gt;&gt; <br>&gt;&gt; 1. They do not provide an option for restricting the &quot;haystack&quot; to a certain `range` of `self`.<br>&gt;&gt; 2. They do not provide a fast (`O(log2(self.count))`) path for sorted collections.<br>&gt;&gt; 3. They should not be limited to `CollectionType` but instead be moved to `Indexable`.<br>&gt;&gt; <br>&gt;&gt; In many situations it is desirable to perform fast searches on sorted collections instead of having to fall back to naïve linear searches.<br>&gt;&gt; <br>&gt;&gt; Further more while a single `index` might be the most common subject of interest, there are many scenarios where a `range` or `count` of matches are of more use.<br>&gt;&gt; <br>&gt;&gt; And anyone who is writing a custom ordered collection type will eventually want to find the insertion index for a given element and will thus end up writing some variant of `lowerBoundOf(…)` or `upperBoundOf(…)` (upon which all the other methods can be implemented, actually).<br>&gt;&gt; <br>&gt;&gt; ## Proposed solution<br>&gt;&gt; <br>&gt;&gt; The author proposes:<br>&gt;&gt; <br>&gt;&gt; 1. A backwards-compatible refactoring of `CollectionType.indices`, moving it to `Indexable`.<br>&gt;&gt; <br>&gt;&gt; 2. A backwards-compatible refactoring of `indexOf(…)` (adding optional `range:` and moving it to `Indexable`).<br>&gt;&gt; <br>&gt;&gt; 3. The addition of `rangeOf(…)`, `countOf(…)` and `isSorted(…)` to `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt; <br>&gt;&gt; 4. The introduction of a `BinarySearchView` on `Indexable`, allowing for fast (`O(log2(self.count))`) searches on `Indexable` via `indexOf(…)`, `rangeOf(…)`, `countOf(…)`, `lowerBoundOf(…)`, `upperBoundOf(…)` without cluttering `Indexable`&#39;s interface.<br>&gt;&gt; <br>&gt;&gt; ## Detailed design<br>&gt;&gt; <br>&gt;&gt; ### `CollectionType.indices`:<br>&gt;&gt; <br>&gt;&gt; The author proposes the relocation of `.indices` from `CollectionType` to `Indexable`:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; extension Indexable {<br>&gt;&gt;     /// Return the range of valid index values.<br>&gt;&gt;     ///<br>&gt;&gt;     /// The result&#39;s `endIndex` is the same as that of `self`.  Because<br>&gt;&gt;     /// `Range` is half-open, iterating the values of the result produces<br>&gt;&gt;     /// all valid subscript arguments for `self`, omitting its `endIndex`.<br>&gt;&gt;     public var indices: Range&lt;Self.Index&gt; { get }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; After all all it does is provide a convenience method for generating a Range from its `startIndex` and `endIndex`. There is no need for `self` to be a `CollectionType` for this.<br>&gt;&gt; <br>&gt;&gt; This change should not break any existing code as it generalizes the property.<br>&gt;&gt; <br>&gt;&gt; ### `Indexable` of `Comparable` elements:<br>&gt;&gt; <br>&gt;&gt; The author proposes the addition of the following method on `Indexable where Element : Comparable`:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; extension Indexable where Index: RandomAccessIndexType, _Element: Comparable {<br>&gt;&gt; 	/// Return true iff all elements in `self` within `range` are sorted according to `isOrderedBefore`.<br>&gt;&gt; 	///<br>&gt;&gt; 	/// - Complexity: O(`self.count`)<br>&gt;&gt; 	public func isSorted(range: Range&lt;Index&gt;? = nil) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; This method would perform a linear scan of the `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt; <br>&gt;&gt; An actual implementation of these methods can be found in `Indexable.swift`.<br>&gt;&gt; <br>&gt;&gt; ### `Indexable` of `Equatable ` elements:<br>&gt;&gt; <br>&gt;&gt; The author proposes the addition of the following method on `Indexable where Element : Equatable`:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; extension Indexable where Index : RandomAccessIndexType, _Element : Equatable {<br>&gt;&gt; <br>&gt;&gt;     /// Returns the first index where `element` appears in `self`<br>&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;     public func indexOf(element: _Element, range: Range&lt;Index&gt;? = default) -&gt; Self.Index?<br>&gt;&gt; <br>&gt;&gt;     /// Returns the first range where `element` appears in `self`<br>&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;     public func rangeOf(element: _Element, range: Range&lt;Index&gt;? = default) -&gt; Range&lt;Self.Index&gt;?<br>&gt;&gt; <br>&gt;&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;&gt;     /// within range `range` or `nil` if such an element is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;     public func countOf(element: _Element, range: Range&lt;Index&gt;? = default) -&gt; Int<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; These methods would perform a linear scan of the `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt; <br>&gt;&gt; An actual implementation of these methods can be found in `Indexable.swift`.<br>&gt;&gt; <br>&gt;&gt; ### `Indexable` of any elements:<br>&gt;&gt; <br>&gt;&gt; The author proposes the addition of the following methods on `Indexable`:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; extension Indexable where Index : RandomAccessIndexType {<br>&gt;&gt; <br>&gt;&gt;     /// Returns the first index where an element appears in `self`<br>&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;     public func indexOf(range: Range&lt;Index&gt;? = default, @noescape predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Self.Index?<br>&gt;&gt; <br>&gt;&gt;     /// Returns the first range where an element appears in `self`<br>&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;     public func rangeOf(range: Range&lt;Index&gt;? = default, @noescape predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Range&lt;Self.Index&gt;?<br>&gt;&gt; <br>&gt;&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;     public func countOf(range: Range&lt;Index&gt;? = default, @noescape predicate: (_Element) throws -&gt; Bool) rethrows -&gt; Int<br>&gt;&gt; <br>&gt;&gt;     /// Return true iff all elements in `self` within `range` are sorted according to `isOrderedBefore`.<br>&gt;&gt;     /// <br>&gt;&gt;     /// - Complexity: O(`self.count`)<br>&gt;&gt;     public func isSorted(range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (_Element, _Element) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; These methods would perform a linear scan of the `Indexable` with a TIME complexity of `O(self.count)`.<br>&gt;&gt; <br>&gt;&gt; An actual implementation of these methods can be found in `Indexable.swift`.<br>&gt;&gt; <br>&gt;&gt; **Note**: For explanation of and reasoning behind the `lensView:` argument as well as the distinction between `T` and `Base._Element`, see below.<br>&gt;&gt; <br>&gt;&gt; ### `Indexable.binarySearchView(validateAgainst:?)`:<br>&gt;&gt; <br>&gt;&gt; The author proposes the addition of a `binarySearchView(validateAgainst:?)` method on `Indexable` for obtaining a specialized search view for performing searches with O(`log2(self.count)`) complexity:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; extension Indexable where Index: RandomAccessIndexType {<br>&gt;&gt; 	/// Create a view into a sorted indexable that allows access within `bounds`.<br>&gt;&gt; 	///<br>&gt;&gt; 	/// - Complexity: O(`self.count`) if a validation closure is provided, otherwise O(`1`).<br>&gt;&gt; 	public func binarySearchView(validateAgainst isOrderedBefore: ((_Element, _Element) -&gt; Bool)? = nil) -&gt; BinarySearchView&lt;Self&gt;<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; ### `BinarySearchView&lt;T: Indexable&gt;`:<br>&gt;&gt; <br>&gt;&gt; The author proposes the introduction of a `BinarySearchView` struct with the following interface:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; public struct BinarySearchView&lt;Base : Indexable where Base.Index : RandomAccessIndexType&gt; : Indexable {<br>&gt;&gt;     public typealias Index = Base.Index<br>&gt;&gt; <br>&gt;&gt;     public var startIndex: Base.Index { get }<br>&gt;&gt; <br>&gt;&gt;     public var endIndex: Base.Index { get }<br>&gt;&gt; <br>&gt;&gt;     public subscript (position: Index) -&gt; Base._Element { get }<br>&gt;&gt; <br>&gt;&gt;     /// Create a view into a sorted collection `base` that allows access within `bounds`.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(1).<br>&gt;&gt;     public init(base: Base, validateAgainst isOrderedBefore: ((Base._Element, Base._Element) -&gt; Bool)? = default)<br>&gt;&gt; <br>&gt;&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;&gt;     /// `lensView(element) &lt; value` evaluates to false or `nil` if `element` is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;     public func lowerBoundOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Base.Index<br>&gt;&gt; <br>&gt;&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;&gt;     /// `value &lt; lensView(element)` evaluates to true or `nil` if `element` is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;     public func upperBoundOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: ((T, T) -&gt; Bool) = default, @noescape lensView: Base._Element -&gt; T) -&gt; Base.Index<br>&gt;&gt; <br>&gt;&gt;     /// Returns the first index where an element appears in `self`<br>&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;     public func indexOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Base.Index?<br>&gt;&gt; <br>&gt;&gt;     /// Returns the range where an element appears in `self`<br>&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;     public func rangeOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Range&lt;Base.Index&gt;?<br>&gt;&gt; <br>&gt;&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;&gt;     /// within range `range` for which `lensView(element) == value` or `nil` if such an element is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;     public func countOf&lt;T : Comparable&gt;(value: T, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (T, T) -&gt; Bool = default, @noescape lensView: Base._Element -&gt; T) -&gt; Int<br>&gt;&gt; <br>&gt;&gt;     internal let _base: Base<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; As well as the following extension for `Indexable where Element: Comparable`:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; extension BinarySearchView where Base._Element : Comparable {<br>&gt;&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;&gt;     /// `… &lt; element` evaluates to false or `nil` if `element` is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;     public func lowerBoundOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Base.Index<br>&gt;&gt; <br>&gt;&gt;     /// Returns first index of the first `element` in `self` within range `range` for which<br>&gt;&gt;     /// `element &lt; …` evaluates to true or `nil` if `element` is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;     public func upperBoundOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Base.Index<br>&gt;&gt; <br>&gt;&gt;     /// Returns the first index where `element` appears in `self`<br>&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;     public func indexOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Base.Index?<br>&gt;&gt; <br>&gt;&gt;     /// Returns the range where `element` appears in `self`<br>&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;     public func rangeOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Range&lt;Base.Index&gt;?<br>&gt;&gt; <br>&gt;&gt;     /// Returns the number of `element`s that appear in `self`<br>&gt;&gt;     /// within range `range` or `nil` if `element` is not found.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(`log2(self.count)`).<br>&gt;&gt;     public func countOf(element: Base._Element, range: Range&lt;Index&gt;? = default, @noescape isOrderedBefore: (Base._Element, Base._Element) -&gt; Bool = default) -&gt; Int<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; These methods would perform a linear scan of the `Indexable` with a TIME complexity of `O(log2(self.count))`.<br>&gt;&gt; <br>&gt;&gt; An actual implementation of these methods can be found in `BinarySearchView.swift`.<br>&gt;&gt; <br>&gt;&gt; ### Why `lensView`?<br>&gt;&gt; <br>&gt;&gt; Let&#39;s assume one had a collection of Persons like this:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; struct Person {<br>&gt;&gt;     let name: String<br>&gt;&gt;     let age: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let persons: [Person] = [ … ]<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Now let&#39;s assume one wanted to find the first person that&#39;s called `John Doe`. One could either change `Person` to conform to `Equatable`, allowing `indexOf(element:)` to be called on `persons`. Now that was easy, wasn&#39;t it?<br>&gt;&gt; <br>&gt;&gt; Fine, but what if one wanted to search `Person`s by both their `name` or their `age` depending on the given use case? You&#39;re out of luck now.<br>&gt;&gt; <br>&gt;&gt; Luckily there is a variant of `indexOf(…)` called `indexOf(predicate:)` that is available for any type of `Element` regardless of its conformance to `Equatable`:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; let searchView = persons.binarySearchView()<br>&gt;&gt; let index = persons.indexOf { $0.name == &quot;John Doe&quot; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Unfortunately however such a `predicate` cannot be used when searching for an element&#39;s property in a sorted(!) collection or a collection of non-`Comparable` elements within a TIME complexity of `O(log2(self.count))` as binary search uses `&lt;` instead of `==` internally and as the &quot;needle&quot; gets passed as both the first (in `indexOf(…)` itself) and second argument (in `lowerBoundOf(…)` which gets called by `indexOf(…)`) to the operator, one cannot simply change `predicate: (E) -&gt; Bool` to `isOrderedBefore: (V, E) -&gt; Bool` as that would result in a type mismatch (`(V, E)` vs. `(E, V)`).<br>&gt;&gt; <br>&gt;&gt; The use of `lensView` however allows one to do just that without making a mess.<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; let searchView = persons.binarySearchView() // sorted!<br>&gt;&gt; let index = searchView.indexOf(&quot;John Doe&quot;) { $0.name }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; The `lensView` works similarly to how keypaths work in Objective-C, just type-safe.<br>&gt;&gt; <br>&gt;&gt; ## Impact on existing code<br>&gt;&gt; <br>&gt;&gt; The author proposes:<br>&gt;&gt; <br>&gt;&gt; 1. Moving `CollectionType.indices` to `Indexable` should not cause any issues with existing code.<br>&gt;&gt; <br>&gt;&gt; 2. Changing `indexOf(element:)` to `indexOf(element:range:?)` should not cause any issues with existing code as the `range` argument is optional and the default behaves like it used to.<br>&gt;&gt; <br>&gt;&gt; 2. Changing `indexOf(predicate:)` to `indexOf(range:?predicate:)` should not cause any issues with existing code either, as the `range` argument is optional and the default behaves like it used to. Swift&#39;s trailing-closure magic allows `indexOf(predicate: …)` to still properly map to `indexOf(range: nil, predicate: …)`.<br>&gt;&gt; <br>&gt;&gt; 3. The addition of `rangeOf(…)`, `countOf(…)` and `isSorted(…)` to `Indexable` do not conflict with any existing API.<br>&gt;&gt; <br>&gt;&gt; 4. The introduction of a `BinarySearchView` on `Indexable` does not conflict with any existing API.<br>&gt;&gt; <br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The author&#39;s initial approach was to implement all methods on Indexable. This however required all methods to either be provided in two variants (one for unsorted, one for sorted `Indexable`s):<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; final public func indexOf(element: _Element, range: Range&lt;Index&gt;? = nil) -&gt; Index? {<br>&gt;&gt; 	return …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; final public func sortedIndexOf(element: _Element, range: Range&lt;Index&gt;? = nil) -&gt; Index? {<br>&gt;&gt; 	return …<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Or require the introduction of an additional argument:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; final public func indexOf(element: _Element, range: Range&lt;Index&gt;? = nil, isSorted: Bool = true) -&gt; Index? {<br>&gt;&gt;     if isSorted {<br>&gt;&gt;         return …<br>&gt;&gt;     } else {<br>&gt;&gt;         return …<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; It also would have cluttered `Indexable` with methods such as `lowerBoundOf` and `upperBoundOf`, which are only ever applicable when `self` is sorted accordingly. The introduction of a dedicated BinarySearchView fixes these issues.<br>&gt;&gt; <br>&gt;&gt; One also would have had to switch from `predicate: (T) -&gt; Bool` to `isOrderedBefore: (T, T) -&gt; Bool` for all methods for the second unified API alternative.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/63e715f4/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
