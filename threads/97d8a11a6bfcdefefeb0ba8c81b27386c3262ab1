<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>Pitch: Remove `NonObjectiveCBase` and replace `isUniquelyReferenced` by `isUniquelyReferencedUnsafe`</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 16, 2016 at 12:00:00pm</p></header><div class="content"><p>https://bugs.swift.org/browse/SR-1962<br></p><p># Remove `NonObjectiveCBase` and replace `isUniquelyReferenced` by `isUniquelyReferencedUnsafe`<br></p><p>## Introduction<br></p><p>Remove `NonObjectiveCBase` and replace`isUniquelyReferenced&lt;T: NonObjectiveCBase&gt;(_ object: T)` by `isUniquelyReferencedUnsafe&lt;T: AnyObject&gt;(_ object: T)`. This will remove surface API. Instead of a type check dynamically check the non-`@objc` constraint under `-Onone`.<br></p><p>## Motivation<br></p><p>Today we have `isUniquelyReferenced` which only works on subclasses of<br>NonObjectiveCBase, and we have `isUniquelyReferencedNonObjC` which also works on<br>`@objc` classes.<br></p><p>```swift<br>class SwiftKlazz : NonObjectiveCBase {}<br>class ObjcKlazz : NSObject {}<br></p><p>expectTrue(isUniquelyReferenced(SwiftKlazz()))<br>expectFalse(isUniquelyReferencedNonObjC(ObjcKlazz()))<br></p><p>// Would not compile:<br>expectFalse(isUniquelyReferenced(ObjcKlazz()))<br>```<br></p><p>In most cases we expect developers to be using the ManagedBufferPointer type. In<br>cases where they want to use a custom class they would use<br>`isUniquelyReferenced` today and can use `isUniquelyReferencedUnsafe` in the<br>future.<br></p><p>```swift<br>class SwiftKlazz : NonObjectiveCBase {}<br>class ObjcKlazz : NSObject {}<br></p><p>expectTrue(isUniquelyReferencedUnsafe(SwiftKlazz()))<br>// Would trap under -Onone:<br>expectFalse(isUniquelyReferencedUnsafe(ObjcKlazz()))<br>```<br></p><p>Replacing `isUniquelyReferenced&lt;T : NonObjectiveCBase&gt;` by<br>`isUniquelyReferencedUnsafe&lt;T: AnyObject&gt;` will allow us to remove the<br>`NonObjectiveCBase` class from the standard library thereby shrink API surface.<br>We argue that trading type safety for less API surface is a good trade-off to<br>make with this low-level API.<br></p><p><br>## Proposed solution<br></p><p>Replace `isUniquelyReferenced&lt;T : NonObjectiveCBase&gt;` by<br>`isUniquelyReferencedUnsafe&lt;T: AnyObject&gt;` and remove the `NonObjectiveCBase`<br>class from the standard library.<br></p><p>## Detailed design<br></p><p>Remove the `NonObjectiveCBase` class and change<br>`isUniquelyReferenced&lt;T: NonObjectiveCBase&gt;(_ object: T&gt;` to:<br></p><p>```swift<br>/// Returns `true` iff `object` is a non-`@objc` class instance with a single<br>/// strong reference. `object` is assumed to be a non-`@objc` class instance.<br>/// In debug mode this function will check this assumption. Otherwise, it is<br>/// undefined what happens.<br>///<br>/// * Does *not* modify `object`; the use of `inout` is an<br>///   implementation artifact.<br>/// * Weak references do not affect the result of this function.<br>///<br>/// Useful for implementing the copy-on-write optimization for the<br>/// deep storage of value types:<br>///<br>///     mutating func modifyMe(_ arg: X) {<br>///       if isUniquelyReferencedUnsafe(&amp;myStorage) {<br>///         myStorage.modifyInPlace(arg)<br>///       }<br>///       else {<br>///         myStorage = myStorage.createModified(arg)<br>///       }<br>///     }<br>///<br>/// This function is safe to use for `mutating` functions in<br>/// multithreaded code because a false positive would imply that there<br>/// is already a user-level data race on the value being mutated.<br>public func isUniquelyReferencedUnsafe&lt;T : AnyObject&gt;(<br>  _ object: inout T<br>) -&gt; Bool {<br>  _debugPrecondition(<br>    _usesNativeSwiftReferenceCounting(object.dynamicType),<br>    &quot;instance must be a non- at objc class instance&quot;)<br>  return _isUnique(&amp;object)<br>}<br>```<br></p><p>Note, that today at -O we would actually not cause undefined behavior but<br>rather just return false. We don&#39;t want to guarantee this in the future so the<br>comment specifies undefined behavior.<br></p><p>## Impact on existing code<br></p><p>Existing code that uses `isUniquelyReferenced` will need to remove the<br>`NonObjectiveCBase` base class and replace calls to `isUniquelyReferenced` by<br>`isUniquelyReferencedUnsafe`. The old API will be marked unavailable to help migration.<br></p><p>## Alternatives considered<br></p><p>Leave the status quo and pay for type safety with additional API surface.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Pitch: Remove `NonObjectiveCBase` and replace `isUniquelyReferenced` by `isUniquelyReferencedUnsafe`</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July 16, 2016 at 01:00:00pm</p></header><div class="content"><p>On Sat, Jul 16, 2016 at 12:47 PM, Arnold Schwaighofer via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; ## Proposed solution<br>&gt;<br>&gt; Replace `isUniquelyReferenced&lt;T : NonObjectiveCBase&gt;` by<br>&gt; `isUniquelyReferencedUnsafe&lt;T: AnyObject&gt;` and remove the `NonObjectiveCBase`<br>&gt; class from the standard library.<br></p><p>Thank you for this proposal!<br></p><p>For presentation and clarity, could you show the full family of<br>`isUniquely*` functions in the design section, including those<br>functions that you are not proposing to change?  This will make it<br>easier to see what choices users will get.  It would be also great to<br>include the API of similar ManagedBuffer and ManagedBufferPointer<br>APIs, if any exist.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>Pitch: Remove `NonObjectiveCBase` and replace `isUniquelyReferenced` by `isUniquelyReferencedUnsafe`</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 16, 2016 at 06:00:00pm</p></header><div class="content"><p>Thank you Dmitri for your feedback. Updated draft below.<br></p><p>https://github.com/aschwaighofer/swift-evolution/blob/remove_nonobjectivecbase/proposals/0000-remove-nonobjectivecbase.md<br></p><p>Remove NonObjectiveCBase and replace isUniquelyReferenced by isUniquelyReferencedUnsafe<br></p><p>Proposal: SE-0000 &lt;https://github.com/aschwaighofer/swift-evolution/blob/remove_nonobjectivecbase/proposals/0000-remove-nonobjectivecbase.md&gt;<br>Author: Arnold Schwaighofer &lt;https://github.com/aschwaighofer&gt;<br>Status: Pitch<br>Review manager: TBD<br> &lt;https://github.com/aschwaighofer/swift-evolution/blob/remove_nonobjectivecbase/proposals/0000-remove-nonobjectivecbase.md#introduction&gt;Introduction<br></p><p>Remove NonObjectiveCBase and replace isUniquelyReferenced&lt;T: NonObjectiveCBase&gt;(_ object: T) byisUniquelyReferencedUnsafe&lt;T: AnyObject&gt;(_ object: T). This will remove surface API. Instead of a type check dynamically check the non- at objc constraint under -Onone.<br></p><p>Swift-evolution thread: Pitch &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160711/024515.html&gt;<br>Swift bug: SR-1962 &lt;http://bugs.swift.org/browse/SR-1962&gt;<br>Branch with change to stdlib: remove_nonobjectivecbase &lt;https://github.com/aschwaighofer/swift/tree/remove_nonobjectivecbase&gt;<br> &lt;https://github.com/aschwaighofer/swift-evolution/blob/remove_nonobjectivecbase/proposals/0000-remove-nonobjectivecbase.md#motivation&gt;Motivation<br></p><p>Today we have isUniquelyReferenced which only works on subclasses of NonObjectiveCBase, and we have isUniquelyReferencedNonObjC which also works on @objc classes.<br></p><p>class SwiftKlazz : NonObjectiveCBase {}<br>class ObjcKlazz : NSObject {}<br></p><p>expectTrue(isUniquelyReferenced(SwiftKlazz()))<br>expectFalse(isUniquelyReferencedNonObjC(ObjcKlazz()))<br></p><p>// Would not compile:<br>expectFalse(isUniquelyReferenced(ObjcKlazz()))<br>In most cases we expect developers to be using the ManagedBufferPointer type. In cases where they want to use a custom class they would use isUniquelyReferenced today and can use isUniquelyReferencedUnsafe in the future.<br></p><p>class SwiftKlazz : NonObjectiveCBase {}<br>class ObjcKlazz : NSObject {}<br></p><p>expectTrue(isUniquelyReferencedUnsafe(SwiftKlazz()))<br>// Would trap under -Onone:<br>expectFalse(isUniquelyReferencedUnsafe(ObjcKlazz()))<br>Replacing isUniquelyReferenced&lt;T : NonObjectiveCBase&gt; by isUniquelyReferencedUnsafe&lt;T: AnyObject&gt; will allow us to remove the NonObjectiveCBase class from the standard library thereby shrink API surface. We argue that trading type safety for less API surface is a good trade-off to make with this low-level API.<br></p><p> &lt;https://github.com/aschwaighofer/swift-evolution/blob/remove_nonobjectivecbase/proposals/0000-remove-nonobjectivecbase.md#proposed-solution&gt;Proposed solution<br></p><p>Replace isUniquelyReferenced&lt;T : NonObjectiveCBase&gt; by isUniquelyReferencedUnsafe&lt;T: AnyObject&gt; and remove the NonObjectiveCBase class from the standard library.<br></p><p> &lt;https://github.com/aschwaighofer/swift-evolution/blob/remove_nonobjectivecbase/proposals/0000-remove-nonobjectivecbase.md#detailed-design&gt;Detailed design<br></p><p>Todays APIs that can be used to check uniqueness is the family of isUniquelyReferenced functions.<br></p><p>/// Returns `true` iff `object` is a non-`@objc` class instance with<br>/// a single strong reference.<br>///<br>/// * Does *not* modify `object`; the use of `inout` is an<br>///   implementation artifact.<br>/// * If `object` is an Objective-C class instance, returns `false`.<br>/// * Weak references do not affect the result of this function.<br>///<br>/// Useful for implementing the copy-on-write optimization for the<br>/// deep storage of value types:<br>///<br>///     mutating func modifyMe(_ arg: X) {<br>///       if isUniquelyReferencedNonObjC(&amp;myStorage) {<br>///         myStorage.modifyInPlace(arg)<br>///       }<br>///       else {<br>///         myStorage = self.createModified(myStorage, arg)<br>///       }<br>///     }<br>public func isUniquelyReferencedNonObjC&lt;T : AnyObject&gt;(_ object: inout T) -&gt; Bool<br>public func isUniquelyReferencedNonObjC&lt;T : AnyObject&gt;(_ object: inout T?) -&gt; Bool<br></p><p>/// A common base class for classes that need to be non-`@objc`,<br>/// recognizably in the type system.<br>public class NonObjectiveCBase {<br>  public init() {}<br>}<br></p><p>public func isUniquelyReferenced&lt;T : NonObjectiveCBase&gt;(<br>  _ object: inout T<br>) -&gt; Bool<br>And the somewhat higher level APIs that can be used to model a storage with several elements ManagedBufferPointer.<br></p><p>/// Contains a buffer object, and provides access to an instance of<br>/// `Header` and contiguous storage for an arbitrary number of<br>/// `Element` instances stored in that buffer.<br>///<br>/// For most purposes, the `ManagedBuffer` class works fine for this<br>/// purpose, and can simply be used on its own.  However, in cases<br>/// where objects of various different classes must serve as storage,<br>/// `ManagedBufferPointer` is needed.<br>///<br>/// A valid buffer class is non-`@objc`, with no declared stored<br>///   properties.  Its `deinit` must destroy its<br>///   stored `Header` and any constructed `Element`s.<br>/// `Header` and contiguous storage for an arbitrary number of<br>/// `Element` instances stored in that buffer.<br>public struct ManagedBufferPointer&lt;Header, Element&gt; : Equatable {<br>  /// Create with new storage containing an initial `Header` and space<br>  /// for at least `minimumCapacity` `element`s.<br>  ///<br>  /// - parameter bufferClass: The class of the object used for storage.<br>  /// - parameter minimumCapacity: The minimum number of `Element`s that<br>  ///   must be able to be stored in the new buffer.<br>  /// - parameter initialHeader: A function that produces the initial<br>  ///   `Header` instance stored in the buffer, given the `buffer`<br>  ///   object and a function that can be called on it to get the actual<br>  ///   number of allocated elements.<br>  ///<br>  /// - Precondition: `minimumCapacity &gt;= 0`, and the type indicated by<br>  ///   `bufferClass` is a non-`@objc` class with no declared stored<br>  ///   properties.  The `deinit` of `bufferClass` must destroy its<br>  ///   stored `Header` and any constructed `Element`s.<br>  public init(<br>    bufferClass: AnyClass,<br>    minimumCapacity: Int,<br>    initialHeader: @noescape (buffer: AnyObject, capacity: @noescape (AnyObject) -&gt; Int) throws -&gt; Header<br>  ) rethrows<br></p><p>  /// Returns `true` iff `self` holds the only strong reference to its buffer.<br>  ///<br>  /// See `isUniquelyReferenced` for details.<br>  public mutating func holdsUniqueReference() -&gt; Bool<br></p><p>  /// Returns `true` iff either `self` holds the only strong reference<br>  /// to its buffer or the pinned has been &#39;pinned&#39;.<br>  ///<br>  /// See `isUniquelyReferenced` for details.<br>  public mutating func holdsUniqueOrPinnedReference() -&gt; Bool<br></p><p>  internal var _nativeBuffer: Builtin.NativeObject<br>}<br></p><p>/// A class whose instances contain a property of type `Header` and raw<br>/// storage for an array of `Element`, whose size is determined at<br>/// instance creation.<br>public class ManagedBuffer&lt;Header, Element&gt;<br>  : ManagedProtoBuffer&lt;Header, Element&gt; {<br></p><p>  /// Create a new instance of the most-derived class, calling<br>  /// `initialHeader` on the partially-constructed object to<br>  /// generate an initial `Header`.<br>  public final class func create(<br>    minimumCapacity: Int,<br>    initialHeader: @noescape (ManagedProtoBuffer&lt;Header, Element&gt;) throws -&gt; Header<br>  ) rethrows -&gt; ManagedBuffer&lt;Header, Element&gt; {<br></p><p>    let p = try ManagedBufferPointer&lt;Header, Element&gt;(<br>      bufferClass: self,<br>      minimumCapacity: minimumCapacity,<br>      initialHeader: { buffer, _ in<br>        try initialHeader(<br>          unsafeDowncast(buffer, to: ManagedProtoBuffer&lt;Header, Element&gt;.self))<br>      })<br></p><p>    return unsafeDowncast(p.buffer, to: ManagedBuffer&lt;Header, Element&gt;.self)<br>  }<br>}<br>We propose to remove the NonObjectiveCBase class and change isUniquelyReferenced&lt;T: NonObjectiveCBase&gt;(_ object: T&gt; to:<br></p><p>/// Returns `true` iff `object` is a non-`@objc` class instance with a single<br>/// strong reference. `object` is assumed to be a non-`@objc` class instance.<br>/// In debug mode this function will check this assumption. Otherwise, it is<br>/// undefined what happens.<br>///<br>/// * Does *not* modify `object`; the use of `inout` is an<br>///   implementation artifact.<br>/// * Weak references do not affect the result of this function.<br>///<br>/// Useful for implementing the copy-on-write optimization for the<br>/// deep storage of value types:<br>///<br>///     mutating func modifyMe(_ arg: X) {<br>///       if isUniquelyReferencedUnsafe(&amp;myStorage) {<br>///         myStorage.modifyInPlace(arg)<br>///       }<br>///       else {<br>///         myStorage = myStorage.createModified(arg)<br>///       }<br>///     }<br>///<br>/// This function is safe to use for `mutating` functions in<br>/// multithreaded code because a false positive would imply that there<br>/// is already a user-level data race on the value being mutated.<br>public func isUniquelyReferencedUnsafe&lt;T : AnyObject&gt;(<br>  _ object: inout T<br>) -&gt; Bool {<br>  _debugPrecondition(<br>    _usesNativeSwiftReferenceCounting(object.dynamicType),<br>    &quot;instance must be a non- at objc class instance&quot;)<br>  return _isUnique(&amp;object)<br>}<br>Note, that today at -O we would actually not cause undefined behavior but rather just return false. We don&#39;t want to guarantee this in the future so the comment specifies undefined behavior.<br></p><p> &lt;https://github.com/aschwaighofer/swift-evolution/blob/remove_nonobjectivecbase/proposals/0000-remove-nonobjectivecbase.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>Existing code that uses isUniquelyReferenced will need to remove the NonObjectiveCBase base class and replace calls to isUniquelyReferenced by isUniquelyReferencedUnsafe. The old API will be marked unavailable to help migration.<br></p><p> &lt;https://github.com/aschwaighofer/swift-evolution/blob/remove_nonobjectivecbase/proposals/0000-remove-nonobjectivecbase.md#alternatives-considered&gt;Alternatives considered<br></p><p>Leave the status quo and pay for type safety with additional API surface.<br></p><p><br>&gt; On Jul 16, 2016, at 1:21 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; For presentation and clarity, could you show the full family of<br>&gt; `isUniquely*` functions in the design section, including those<br>&gt; functions that you are not proposing to change?  This will make it<br>&gt; easier to see what choices users will get.  It would be also great to<br>&gt; include the API of similar ManagedBuffer and ManagedBufferPointer<br>&gt; APIs, if any exist.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/8a2e6982/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Pitch: Remove `NonObjectiveCBase` and replace `isUniquelyReferenced` by `isUniquelyReferencedUnsafe`</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July 16, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jul 16, 2016, at 6:46 PM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Replace isUniquelyReferenced&lt;T : NonObjectiveCBase&gt; by isUniquelyReferencedUnsafe&lt;T: AnyObject&gt; and remove the NonObjectiveCBase class from the standard library.<br>&gt; <br>&gt; <br></p><p>So we’ll have:<br></p><p>- isUniquelyReferencedNonObjC(object): true iff object is uniquely referenced and NonObjC<br></p><p>- isUniquelyReferencedUnsafe(object): true iff object is uniquely reference, assert NonObjC<br></p><p>I’m going to be picky. The “Unsafe” suffix doesn’t make sense to me. If you think this is an unsafe API then it should be:<br>“unsafeIsUniquelyReferenced”.<br></p><p>But I don’t really see how it is unsafe in the usual sense. If you want to convey that the programmer needs to satisfy some precondition, which is not generally associated with unsafety, then it should be:<br>“isUniquelyReferencedAssumingNonObjC”<br></p><p>Frankly, the type was a nicer way to do this, by I understand removing it from the API surface.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/c6dbf57a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>Pitch: Remove `NonObjectiveCBase` and replace `isUniquelyReferenced` by `isUniquelyReferencedUnsafe`</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 16, 2016 at 08:00:00pm</p></header><div class="content"><p>Thank you for the feedback. Answers online.<br></p><p>Sent from my iPhone<br></p><p>&gt; On Jul 16, 2016, at 7:38 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 16, 2016, at 6:46 PM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Replace isUniquelyReferenced&lt;T : NonObjectiveCBase&gt; by isUniquelyReferencedUnsafe&lt;T: AnyObject&gt; and remove the NonObjectiveCBase class from the standard library.<br>&gt;&gt; <br>&gt; <br>&gt; So we’ll have:<br>&gt; <br>&gt; - isUniquelyReferencedNonObjC(object): true iff object is uniquely referenced and NonObjC<br>&gt; <br>&gt; - isUniquelyReferencedUnsafe(object): true iff object is uniquely reference, assert NonObjC<br>&gt; <br>&gt; I’m going to be picky. The “Unsafe” suffix doesn’t make sense to me. If you think this is an unsafe API then it should be:<br>&gt; “unsafeIsUniquelyReferenced”.<br>&gt; <br>&gt; But I don’t really see how it is unsafe in the usual sense. If you want to convey that the programmer needs to satisfy some precondition, which is not generally associated with unsafety, then it should be:<br>&gt; “isUniquelyReferencedAssumingNonObjC”<br>&gt; <br></p><p>Makes sense to me. I think it is unsafe in the sense if you don&#39;t satisfy the precondition the resulting behavior is undefined in modes other than -Onone and not checked by a precondition predicate that traps.<br></p><p>&gt; unsafeIsUniquelyReferenced<br></p><p>I find it kind of nice to recognize a predicate by the &#39;is&#39; prefix. All unsafe APIs start with the word unsafe though. I could not find an unsafe freestanding predicate.<br></p><p>[As the implementor of the underlying builtin you may remember that it is not actually undefined and will return a implementation defined value (false) for objc classes. But we might not want to guarantee this going forward.]<br></p><p>&gt; Frankly, the type was a nicer way to do this, by I understand removing it from the API surface.<br>&gt; <br>&gt; -Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/bc608249/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Pitch: Remove `NonObjectiveCBase` and replace `isUniquelyReferenced` by `isUniquelyReferencedUnsafe`</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July 16, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jul 16, 2016, at 8:36 PM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt; <br>&gt; Thank you for the feedback. Answers online.<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Jul 16, 2016, at 7:38 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 16, 2016, at 6:46 PM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Replace isUniquelyReferenced&lt;T : NonObjectiveCBase&gt; by isUniquelyReferencedUnsafe&lt;T: AnyObject&gt; and remove the NonObjectiveCBase class from the standard library.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; So we’ll have:<br>&gt;&gt; <br>&gt;&gt; - isUniquelyReferencedNonObjC(object): true iff object is uniquely referenced and NonObjC<br>&gt;&gt; <br>&gt;&gt; - isUniquelyReferencedUnsafe(object): true iff object is uniquely reference, assert NonObjC<br>&gt;&gt; <br>&gt;&gt; I’m going to be picky. The “Unsafe” suffix doesn’t make sense to me. If you think this is an unsafe API then it should be:<br>&gt;&gt; “unsafeIsUniquelyReferenced”.<br>&gt;&gt; <br>&gt;&gt; But I don’t really see how it is unsafe in the usual sense. If you want to convey that the programmer needs to satisfy some precondition, which is not generally associated with unsafety, then it should be:<br>&gt;&gt; “isUniquelyReferencedAssumingNonObjC”<br>&gt;&gt; <br>&gt; <br>&gt; Makes sense to me. I think it is unsafe in the sense if you don&#39;t satisfy the precondition the resulting behavior is undefined in modes other than -Onone and not checked by a precondition predicate that traps.<br>&gt; <br>&gt;&gt; unsafeIsUniquelyReferenced<br>&gt; <br>&gt; I find it kind of nice to recognize a predicate by the &#39;is&#39; prefix. All unsafe APIs start with the word unsafe though. I could not find an unsafe freestanding predicate.<br>&gt; <br>&gt; [As the implementor of the underlying builtin you may remember that it is not actually undefined and will return a implementation defined value (false) for objc classes. But we might not want to guarantee this going forward.]<br></p><p><br>Oh yeah. I think I only kept the two versions for fear of breaking the API. Since you’re renaming the second one anyway, why not just delete it with a fixit that it&#39;s renamed to isUniquelyReferencedNonObjC?<br></p><p>The “assuming” version of the API is extremely confusing in addition to being useless.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/b5d9a9fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>Pitch: Remove `NonObjectiveCBase` and replace `isUniquelyReferenced` by `isUniquelyReferencedUnsafe`</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 16, 2016 at 09:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jul 16, 2016, at 8:45 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 16, 2016, at 8:36 PM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thank you for the feedback. Answers online.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 16, 2016, at 7:38 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 16, 2016, at 6:46 PM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Replace isUniquelyReferenced&lt;T : NonObjectiveCBase&gt; by isUniquelyReferencedUnsafe&lt;T: AnyObject&gt; and remove the NonObjectiveCBase class from the standard library.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So we’ll have:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - isUniquelyReferencedNonObjC(object): true iff object is uniquely referenced and NonObjC<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - isUniquelyReferencedUnsafe(object): true iff object is uniquely reference, assert NonObjC<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m going to be picky. The “Unsafe” suffix doesn’t make sense to me. If you think this is an unsafe API then it should be:<br>&gt;&gt;&gt; “unsafeIsUniquelyReferenced”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But I don’t really see how it is unsafe in the usual sense. If you want to convey that the programmer needs to satisfy some precondition, which is not generally associated with unsafety, then it should be:<br>&gt;&gt;&gt; “isUniquelyReferencedAssumingNonObjC”<br>&gt;&gt; <br>&gt;&gt; Makes sense to me. I think it is unsafe in the sense if you don&#39;t satisfy the precondition the resulting behavior is undefined in modes other than -Onone and not checked by a precondition predicate that traps.<br>&gt;&gt; <br>&gt;&gt;&gt; unsafeIsUniquelyReferenced<br>&gt;&gt; <br>&gt;&gt; I find it kind of nice to recognize a predicate by the &#39;is&#39; prefix. All unsafe APIs start with the word unsafe though. I could not find an unsafe freestanding predicate.<br>&gt;&gt; <br>&gt;&gt; [As the implementor of the underlying builtin you may remember that it is not actually undefined and will return a implementation defined value (false) for objc classes. But we might not want to guarantee this going forward.]<br>&gt; <br>&gt; <br>&gt; Oh yeah. I think I only kept the two versions for fear of breaking the API. Since you’re renaming the second one anyway, why not just delete it with a fixit that it&#39;s renamed to isUniquelyReferencedNonObjC?<br>&gt; <br>&gt; The “assuming” version of the API is extremely confusing in addition to being useless.<br></p><p>The unsafe version would allow us to emit more efficient code (in the future) for a static unknown object type but we know it is a native type (but not which so we can&#39;t just cast it, this is public API so we can&#39;t cast to Builtin.NativeObject).<br></p><p>  var self: AnyObject // really: AnyNativeObject<br>  ...<br>  if (!unsafeIsUniquelyReferenced(&amp;self))<br>    self = self.copy()<br>  }<br></p><p>I admit this is somewhat contrived and am happy to just nuke the API if we agree there is no value in the use case above.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/13e9ae44/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Pitch: Remove `NonObjectiveCBase` and replace `isUniquelyReferenced` by `isUniquelyReferencedUnsafe`</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July 16, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jul 16, 2016, at 9:17 PM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Jul 16, 2016, at 8:45 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 16, 2016, at 8:36 PM, Arnold &lt;aschwaighofer at apple.com &lt;mailto:aschwaighofer at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you for the feedback. Answers online.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 16, 2016, at 7:38 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 16, 2016, at 6:46 PM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Replace isUniquelyReferenced&lt;T : NonObjectiveCBase&gt; by isUniquelyReferencedUnsafe&lt;T: AnyObject&gt; and remove the NonObjectiveCBase class from the standard library.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So we’ll have:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - isUniquelyReferencedNonObjC(object): true iff object is uniquely referenced and NonObjC<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - isUniquelyReferencedUnsafe(object): true iff object is uniquely reference, assert NonObjC<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m going to be picky. The “Unsafe” suffix doesn’t make sense to me. If you think this is an unsafe API then it should be:<br>&gt;&gt;&gt;&gt; “unsafeIsUniquelyReferenced”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But I don’t really see how it is unsafe in the usual sense. If you want to convey that the programmer needs to satisfy some precondition, which is not generally associated with unsafety, then it should be:<br>&gt;&gt;&gt;&gt; “isUniquelyReferencedAssumingNonObjC”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Makes sense to me. I think it is unsafe in the sense if you don&#39;t satisfy the precondition the resulting behavior is undefined in modes other than -Onone and not checked by a precondition predicate that traps.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; unsafeIsUniquelyReferenced<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I find it kind of nice to recognize a predicate by the &#39;is&#39; prefix. All unsafe APIs start with the word unsafe though. I could not find an unsafe freestanding predicate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [As the implementor of the underlying builtin you may remember that it is not actually undefined and will return a implementation defined value (false) for objc classes. But we might not want to guarantee this going forward.]<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Oh yeah. I think I only kept the two versions for fear of breaking the API. Since you’re renaming the second one anyway, why not just delete it with a fixit that it&#39;s renamed to isUniquelyReferencedNonObjC?<br>&gt;&gt; <br>&gt;&gt; The “assuming” version of the API is extremely confusing in addition to being useless.<br>&gt; <br>&gt; The unsafe version would allow us to emit more efficient code (in the future) for a static unknown object type but we know it is a native type (but not which so we can&#39;t just cast it, this is public API so we can&#39;t cast to Builtin.NativeObject).<br>&gt; <br>&gt;   var self: AnyObject // really: AnyNativeObject<br>&gt;   ...<br>&gt;   if (!unsafeIsUniquelyReferenced(&amp;self))<br>&gt;     self = self.copy()<br>&gt;   }<br>&gt; <br>&gt; I admit this is somewhat contrived and am happy to just nuke the API if we agree there is no value in the use case above.<br></p><p>There is no sense advertising this API under some new name if it hasn’t even been implemented. The API can be added when it makes sense.<br></p><p>+1 for eliminating it.<br></p><p>-Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/f441fa0b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>Pitch: Remove `NonObjectiveCBase` and replace `isUniquelyReferenced` by `isUniquelyReferencedUnsafe`</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 16, 2016 at 09:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jul 16, 2016, at 9:23 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 16, 2016, at 9:17 PM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 16, 2016, at 8:45 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 16, 2016, at 8:36 PM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thank you for the feedback. Answers online.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 16, 2016, at 7:38 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 16, 2016, at 6:46 PM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Replace isUniquelyReferenced&lt;T : NonObjectiveCBase&gt; by isUniquelyReferencedUnsafe&lt;T: AnyObject&gt; and remove the NonObjectiveCBase class from the standard library.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So we’ll have:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - isUniquelyReferencedNonObjC(object): true iff object is uniquely referenced and NonObjC<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - isUniquelyReferencedUnsafe(object): true iff object is uniquely reference, assert NonObjC<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m going to be picky. The “Unsafe” suffix doesn’t make sense to me. If you think this is an unsafe API then it should be:<br>&gt;&gt;&gt;&gt;&gt; “unsafeIsUniquelyReferenced”.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But I don’t really see how it is unsafe in the usual sense. If you want to convey that the programmer needs to satisfy some precondition, which is not generally associated with unsafety, then it should be:<br>&gt;&gt;&gt;&gt;&gt; “isUniquelyReferencedAssumingNonObjC”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Makes sense to me. I think it is unsafe in the sense if you don&#39;t satisfy the precondition the resulting behavior is undefined in modes other than -Onone and not checked by a precondition predicate that traps.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; unsafeIsUniquelyReferenced<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I find it kind of nice to recognize a predicate by the &#39;is&#39; prefix. All unsafe APIs start with the word unsafe though. I could not find an unsafe freestanding predicate.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [As the implementor of the underlying builtin you may remember that it is not actually undefined and will return a implementation defined value (false) for objc classes. But we might not want to guarantee this going forward.]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Oh yeah. I think I only kept the two versions for fear of breaking the API. Since you’re renaming the second one anyway, why not just delete it with a fixit that it&#39;s renamed to isUniquelyReferencedNonObjC?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The “assuming” version of the API is extremely confusing in addition to being useless.<br>&gt;&gt; <br>&gt;&gt; The unsafe version would allow us to emit more efficient code (in the future) for a static unknown object type but we know it is a native type (but not which so we can&#39;t just cast it, this is public API so we can&#39;t cast to Builtin.NativeObject).<br>&gt;&gt; <br>&gt;&gt;   var self: AnyObject // really: AnyNativeObject<br>&gt;&gt;   ...<br>&gt;&gt;   if (!unsafeIsUniquelyReferenced(&amp;self))<br>&gt;&gt;     self = self.copy()<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; I admit this is somewhat contrived and am happy to just nuke the API if we agree there is no value in the use case above.<br>&gt; <br>&gt; There is no sense advertising this API under some new name if it hasn’t even been implemented. The API can be added when it makes sense.<br>&gt; <br>&gt; +1 for eliminating it.<br></p><p>Today you can implement something similar using NonObjectiveCBase as your base class:<br></p><p> var self: NonObjectiveCBase<br> ...<br> if (isUniquelyReferenced(&amp;self) {...}<br></p><p>And get the runtime performance of the native check.<br></p><p>If we implemented &#39;unsafeIsUniquelyReferenced&#39; we would just unsafeBitCast the &#39;object&#39; argument to Builtin.NativeObject and get the same performance.<br></p><p>I admit that this may be far fetched but I am trying to anticipated possible use cases that work today.<br></p><p>That use case will still work after nuking the API using the &#39;NonObjC&#39; variant albeit slightly slower.<br></p><p>If we need to support it with best performance we can always bring the API back as you said.<br></p><p>+1 for nuking it from me<br></p><p>I will change the proposal.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/53d43442/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>Pitch: Remove `NonObjectiveCBase` and replace `isUniquelyReferenced` by `isUniquelyReferencedUnsafe`</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 16, 2016 at 10:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jul 16, 2016, at 9:41 PM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On Jul 16, 2016, at 9:23 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 16, 2016, at 9:17 PM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 16, 2016, at 8:45 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 16, 2016, at 8:36 PM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thank you for the feedback. Answers online.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 16, 2016, at 7:38 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 16, 2016, at 6:46 PM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Replace isUniquelyReferenced&lt;T : NonObjectiveCBase&gt; by isUniquelyReferencedUnsafe&lt;T: AnyObject&gt; and remove the NonObjectiveCBase class from the standard library.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So we’ll have:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - isUniquelyReferencedNonObjC(object): true iff object is uniquely referenced and NonObjC<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - isUniquelyReferencedUnsafe(object): true iff object is uniquely reference, assert NonObjC<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m going to be picky. The “Unsafe” suffix doesn’t make sense to me. If you think this is an unsafe API then it should be:<br>&gt;&gt;&gt;&gt;&gt;&gt; “unsafeIsUniquelyReferenced”.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; But I don’t really see how it is unsafe in the usual sense. If you want to convey that the programmer needs to satisfy some precondition, which is not generally associated with unsafety, then it should be:<br>&gt;&gt;&gt;&gt;&gt;&gt; “isUniquelyReferencedAssumingNonObjC”<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Makes sense to me. I think it is unsafe in the sense if you don&#39;t satisfy the precondition the resulting behavior is undefined in modes other than -Onone and not checked by a precondition predicate that traps.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; unsafeIsUniquelyReferenced<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I find it kind of nice to recognize a predicate by the &#39;is&#39; prefix. All unsafe APIs start with the word unsafe though. I could not find an unsafe freestanding predicate.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; [As the implementor of the underlying builtin you may remember that it is not actually undefined and will return a implementation defined value (false) for objc classes. But we might not want to guarantee this going forward.]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Oh yeah. I think I only kept the two versions for fear of breaking the API. Since you’re renaming the second one anyway, why not just delete it with a fixit that it&#39;s renamed to isUniquelyReferencedNonObjC?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The “assuming” version of the API is extremely confusing in addition to being useless.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The unsafe version would allow us to emit more efficient code (in the future) for a static unknown object type but we know it is a native type (but not which so we can&#39;t just cast it, this is public API so we can&#39;t cast to Builtin.NativeObject).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   var self: AnyObject // really: AnyNativeObject<br>&gt;&gt;&gt;   ...<br>&gt;&gt;&gt;   if (!unsafeIsUniquelyReferenced(&amp;self))<br>&gt;&gt;&gt;     self = self.copy()<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I admit this is somewhat contrived and am happy to just nuke the API if we agree there is no value in the use case above.<br>&gt;&gt; <br>&gt;&gt; There is no sense advertising this API under some new name if it hasn’t even been implemented. The API can be added when it makes sense.<br>&gt;&gt; <br>&gt;&gt; +1 for eliminating it.<br>&gt; <br>&gt; Today you can implement something similar using NonObjectiveCBase as your base class:<br>&gt; <br>&gt;  var self: NonObjectiveCBase<br>&gt;  ...<br>&gt;  if (isUniquelyReferenced(&amp;self) {...}<br>&gt; <br>&gt; And get the runtime performance of the native check.<br></p><p>Actually, this code could just implement their own &#39;class NonObjCBase&#39; base class and just use isUniquelyReferencedNonObj for the same performance as before ...<br>&gt; <br>&gt; If we implemented &#39;unsafeIsUniquelyReferenced&#39; we would just unsafeBitCast the &#39;object&#39; argument to Builtin.NativeObject and get the same performance.<br>&gt; <br>&gt; I admit that this may be far fetched but I am trying to anticipated possible use cases that work today.<br>&gt; <br>&gt; That use case will still work after nuking the API using the &#39;NonObjC&#39; variant albeit slightly slower.<br>&gt; <br>&gt; If we need to support it with best performance we can always bring the API back as you said.<br>&gt; <br>&gt; +1 for nuking it from me<br>&gt; <br>&gt; I will change the proposal.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/b40a53e6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>Pitch: Remove `NonObjectiveCBase` and replace `isUniquelyReferenced` by `isUniquelyReferencedUnsafe`</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 16, 2016 at 10:00:00pm</p></header><div class="content"><p>Updated proposal:<br></p><p>Remove NonObjectiveCBase and isUniquelyReferenced<br></p><p>Proposal: SE-0000 &lt;https://github.com/aschwaighofer/swift-evolution/blob/remove_nonobjectivecbase/proposals/0000-remove-nonobjectivecbase.md&gt;<br>Author: Arnold Schwaighofer &lt;https://github.com/aschwaighofer&gt;<br>Status: Pitch<br>Review manager: TBD<br> &lt;https://github.com/aschwaighofer/swift-evolution/tree/remove_nonobjectivecbase#introduction&gt;Introduction<br></p><p>Remove NonObjectiveCBase and isUniquelyReferenced&lt;T: NonObjectiveCBase&gt;(_ object: T). isUniquelyReferenced can be replaced by isUniquelyReferencedNonObjC&lt;T: AnyObject&gt;(_ object: T). This replacement is as performant as the call to isUniquelyReferenced in cases where the compiler has static knowledge that the type of object is a native Swift class. This change will remove surface API.<br></p><p>Swift-evolution thread: Pitch &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160711/024515.html&gt;<br>Swift bug: SR-1962 &lt;http://bugs.swift.org/browse/SR-1962&gt;<br>Branch with change to stdlib: remove_nonobjectivecbase &lt;https://github.com/aschwaighofer/swift/tree/remove_nonobjectivecbase&gt;<br> &lt;https://github.com/aschwaighofer/swift-evolution/tree/remove_nonobjectivecbase#motivation&gt;Motivation<br></p><p>Today we have isUniquelyReferenced which only works on subclasses of NonObjectiveCBase, and we have isUniquelyReferencedNonObjC which also works on @objc classes.<br></p><p>class SwiftKlazz : NonObjectiveCBase {}<br>class ObjcKlazz : NSObject {}<br></p><p>expectTrue(isUniquelyReferenced(SwiftKlazz()))<br>expectFalse(isUniquelyReferencedNonObjC(ObjcKlazz()))<br></p><p>// Would not compile:<br>expectFalse(isUniquelyReferenced(ObjcKlazz()))<br>In most cases we expect developers to be using the ManagedBufferPointer type. In cases where they want to use a custom class they would use isUniquelyReferenced today and can use isUniquelyReferencedNonObjC in the future.<br></p><p>class SwiftKlazz {}<br></p><p>expectTrue(isUniquelyReferencedNonObjC(SwiftKlazz()))<br>Removing isUniquelyReferenced&lt;T : NonObjectiveCBase&gt; will allow us to remove the NonObjectiveCBase class from the standard library thereby further shrinking API surface.<br></p><p> &lt;https://github.com/aschwaighofer/swift-evolution/tree/remove_nonobjectivecbase#proposed-solution&gt;Proposed solution<br></p><p>Remove isUniquelyReferenced&lt;T : NonObjectiveCBase&gt; and remove the NonObjectiveCBase class from the standard library. Clients of the the isUniquelyReferenced API can be migrated to use isUniquelyReferencedNonObjC. In most cases -- where the type of the object parameter is statically known to be a native non- at objc class -- the resulting code will have identical performance characteristics. In cases where the type is statically not known it will have the slight overhead of first checking that the dynamic type is not an @objc class.<br></p><p> &lt;https://github.com/aschwaighofer/swift-evolution/tree/remove_nonobjectivecbase#detailed-design&gt;Detailed design<br></p><p>Todays APIs that can be used to check uniqueness is the family of isUniquelyReferenced functions.<br></p><p>/// Returns `true` iff `object` is a non-`@objc` class instance with<br>/// a single strong reference.<br>///<br>/// * Does *not* modify `object`; the use of `inout` is an<br>///   implementation artifact.<br>/// * If `object` is an Objective-C class instance, returns `false`.<br>/// * Weak references do not affect the result of this function.<br>///<br>/// Useful for implementing the copy-on-write optimization for the<br>/// deep storage of value types:<br>///<br>///     mutating func modifyMe(_ arg: X) {<br>///       if isUniquelyReferencedNonObjC(&amp;myStorage) {<br>///         myStorage.modifyInPlace(arg)<br>///       }<br>///       else {<br>///         myStorage = self.createModified(myStorage, arg)<br>///       }<br>///     }<br>public func isUniquelyReferencedNonObjC&lt;T : AnyObject&gt;(_ object: inout T) -&gt; Bool<br>public func isUniquelyReferencedNonObjC&lt;T : AnyObject&gt;(_ object: inout T?) -&gt; Bool<br></p><p>/// A common base class for classes that need to be non-`@objc`,<br>/// recognizably in the type system.<br>public class NonObjectiveCBase {<br>  public init() {}<br>}<br></p><p>public func isUniquelyReferenced&lt;T : NonObjectiveCBase&gt;(<br>  _ object: inout T<br>) -&gt; Bool<br>And the somewhat higher level APIs that can be used to model a storage with several elements ManagedBufferPointer.<br></p><p>/// Contains a buffer object, and provides access to an instance of<br>/// `Header` and contiguous storage for an arbitrary number of<br>/// `Element` instances stored in that buffer.<br>///<br>/// For most purposes, the `ManagedBuffer` class works fine for this<br>/// purpose, and can simply be used on its own.  However, in cases<br>/// where objects of various different classes must serve as storage,<br>/// `ManagedBufferPointer` is needed.<br>///<br>/// A valid buffer class is non-`@objc`, with no declared stored<br>///   properties.  Its `deinit` must destroy its<br>///   stored `Header` and any constructed `Element`s.<br>/// `Header` and contiguous storage for an arbitrary number of<br>/// `Element` instances stored in that buffer.<br>public struct ManagedBufferPointer&lt;Header, Element&gt; : Equatable {<br>  /// Create with new storage containing an initial `Header` and space<br>  /// for at least `minimumCapacity` `element`s.<br>  ///<br>  /// - parameter bufferClass: The class of the object used for storage.<br>  /// - parameter minimumCapacity: The minimum number of `Element`s that<br>  ///   must be able to be stored in the new buffer.<br>  /// - parameter initialHeader: A function that produces the initial<br>  ///   `Header` instance stored in the buffer, given the `buffer`<br>  ///   object and a function that can be called on it to get the actual<br>  ///   number of allocated elements.<br>  ///<br>  /// - Precondition: `minimumCapacity &gt;= 0`, and the type indicated by<br>  ///   `bufferClass` is a non-`@objc` class with no declared stored<br>  ///   properties.  The `deinit` of `bufferClass` must destroy its<br>  ///   stored `Header` and any constructed `Element`s.<br>  public init(<br>    bufferClass: AnyClass,<br>    minimumCapacity: Int,<br>    initialHeader: @noescape (buffer: AnyObject, capacity: @noescape (AnyObject) -&gt; Int) throws -&gt; Header<br>  ) rethrows<br></p><p>  /// Returns `true` iff `self` holds the only strong reference to its buffer.<br>  ///<br>  /// See `isUniquelyReferenced` for details.<br>  public mutating func holdsUniqueReference() -&gt; Bool<br></p><p>  /// Returns `true` iff either `self` holds the only strong reference<br>  /// to its buffer or the pinned has been &#39;pinned&#39;.<br>  ///<br>  /// See `isUniquelyReferenced` for details.<br>  public mutating func holdsUniqueOrPinnedReference() -&gt; Bool<br></p><p>  internal var _nativeBuffer: Builtin.NativeObject<br>}<br></p><p>/// A class whose instances contain a property of type `Header` and raw<br>/// storage for an array of `Element`, whose size is determined at<br>/// instance creation.<br>public class ManagedBuffer&lt;Header, Element&gt;<br>  : ManagedProtoBuffer&lt;Header, Element&gt; {<br></p><p>  /// Create a new instance of the most-derived class, calling<br>  /// `initialHeader` on the partially-constructed object to<br>  /// generate an initial `Header`.<br>  public final class func create(<br>    minimumCapacity: Int,<br>    initialHeader: @noescape (ManagedProtoBuffer&lt;Header, Element&gt;) throws -&gt; Header<br>  ) rethrows -&gt; ManagedBuffer&lt;Header, Element&gt; {<br></p><p>    let p = try ManagedBufferPointer&lt;Header, Element&gt;(<br>      bufferClass: self,<br>      minimumCapacity: minimumCapacity,<br>      initialHeader: { buffer, _ in<br>        try initialHeader(<br>          unsafeDowncast(buffer, to: ManagedProtoBuffer&lt;Header, Element&gt;.self))<br>      })<br></p><p>    return unsafeDowncast(p.buffer, to: ManagedBuffer&lt;Header, Element&gt;.self)<br>  }<br>}<br>We propose to remove the NonObjectiveCBase class and isUniquelyReferenced&lt;T: NonObjectiveCBase&gt;(_ object: T&gt;.<br></p><p> &lt;https://github.com/aschwaighofer/swift-evolution/tree/remove_nonobjectivecbase#impact-on-existing-code&gt;Impact on existing code<br></p><p>Existing code that uses isUniquelyReferenced will need to remove the NonObjectiveCBase base class and replace calls to isUniquelyReferenced by isUniquelyReferencedNonObjC. The old API will be marked unavailable to help migration.<br></p><p> &lt;https://github.com/aschwaighofer/swift-evolution/tree/remove_nonobjectivecbase#alternatives-considered&gt;Alternatives considered<br></p><p>Leave the status quo and pay for type safety with additional API surface. Another alternative we considered -- the first version of this proposal -- was to replace the isUniquelyReferenced API by an isUniquelyReferencedUnsafe&lt;T: AnyObject&gt;(_ object: T) API that would assume the object to be a non- at objc class and only check this precondition under -Onone. There is however no good reason to keep this API given that the isUniquelyReferencedNonObjC is as performant when the type is statically known to be non- at objc class.<br>&gt; On Jul 16, 2016, at 10:12 PM, Arnold via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Jul 16, 2016, at 9:41 PM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On Jul 16, 2016, at 9:23 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 16, 2016, at 9:17 PM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 16, 2016, at 8:45 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 16, 2016, at 8:36 PM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thank you for the feedback. Answers online.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 16, 2016, at 7:38 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 16, 2016, at 6:46 PM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Replace isUniquelyReferenced&lt;T : NonObjectiveCBase&gt; by isUniquelyReferencedUnsafe&lt;T: AnyObject&gt; and remove the NonObjectiveCBase class from the standard library.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; So we’ll have:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - isUniquelyReferencedNonObjC(object): true iff object is uniquely referenced and NonObjC<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - isUniquelyReferencedUnsafe(object): true iff object is uniquely reference, assert NonObjC<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m going to be picky. The “Unsafe” suffix doesn’t make sense to me. If you think this is an unsafe API then it should be:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; “unsafeIsUniquelyReferenced”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But I don’t really see how it is unsafe in the usual sense. If you want to convey that the programmer needs to satisfy some precondition, which is not generally associated with unsafety, then it should be:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; “isUniquelyReferencedAssumingNonObjC”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Makes sense to me. I think it is unsafe in the sense if you don&#39;t satisfy the precondition the resulting behavior is undefined in modes other than -Onone and not checked by a precondition predicate that traps.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; unsafeIsUniquelyReferenced<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I find it kind of nice to recognize a predicate by the &#39;is&#39; prefix. All unsafe APIs start with the word unsafe though. I could not find an unsafe freestanding predicate.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; [As the implementor of the underlying builtin you may remember that it is not actually undefined and will return a implementation defined value (false) for objc classes. But we might not want to guarantee this going forward.]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Oh yeah. I think I only kept the two versions for fear of breaking the API. Since you’re renaming the second one anyway, why not just delete it with a fixit that it&#39;s renamed to isUniquelyReferencedNonObjC?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The “assuming” version of the API is extremely confusing in addition to being useless.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The unsafe version would allow us to emit more efficient code (in the future) for a static unknown object type but we know it is a native type (but not which so we can&#39;t just cast it, this is public API so we can&#39;t cast to Builtin.NativeObject).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   var self: AnyObject // really: AnyNativeObject<br>&gt;&gt;&gt;&gt;   ...<br>&gt;&gt;&gt;&gt;   if (!unsafeIsUniquelyReferenced(&amp;self))<br>&gt;&gt;&gt;&gt;     self = self.copy()<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I admit this is somewhat contrived and am happy to just nuke the API if we agree there is no value in the use case above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is no sense advertising this API under some new name if it hasn’t even been implemented. The API can be added when it makes sense.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 for eliminating it.<br>&gt;&gt; <br>&gt;&gt; Today you can implement something similar using NonObjectiveCBase as your base class:<br>&gt;&gt; <br>&gt;&gt;  var self: NonObjectiveCBase<br>&gt;&gt;  ...<br>&gt;&gt;  if (isUniquelyReferenced(&amp;self) {...}<br>&gt;&gt; <br>&gt;&gt; And get the runtime performance of the native check.<br>&gt; <br>&gt; Actually, this code could just implement their own &#39;class NonObjCBase&#39; base class and just use isUniquelyReferencedNonObj for the same performance as before ...<br>&gt;&gt; <br>&gt;&gt; If we implemented &#39;unsafeIsUniquelyReferenced&#39; we would just unsafeBitCast the &#39;object&#39; argument to Builtin.NativeObject and get the same performance.<br>&gt;&gt; <br>&gt;&gt; I admit that this may be far fetched but I am trying to anticipated possible use cases that work today.<br>&gt;&gt; <br>&gt;&gt; That use case will still work after nuking the API using the &#39;NonObjC&#39; variant albeit slightly slower.<br>&gt;&gt; <br>&gt;&gt; If we need to support it with best performance we can always bring the API back as you said.<br>&gt;&gt; <br>&gt;&gt; +1 for nuking it from me<br>&gt;&gt; <br>&gt;&gt; I will change the proposal.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/0710d346/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>Pitch: Remove `NonObjectiveCBase` and replace `isUniquelyReferenced` by `isUniquelyReferencedUnsafe`</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 18, 2016 at 02:00:00pm</p></header><div class="content"><p>TL;DR:  Remove the isUniquelyReferenced&lt;T: NonObjectiveCBase&gt;(_ object: T) API. All its current use cases can be satisfied equally performant by the isUniquelyReferencedNonObjC&lt;T : AnyObject&gt;(_ object: T) API.<br></p><p>This will reduce API surface by both the NonObjectiveCBase class and the isUniquelyReferenced API.<br></p><p>I think this is pretty uncontroversial, too?<br></p><p>[Today’s implementation of both APIs is the same builtin call. The compiler can optimize out the check for objective-c class ancestry when it sees that the static type of ‘object’ is not an @objc-class.]<br></p><p><br>&gt; On Jul 16, 2016, at 10:50 PM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Updated proposal:<br>&gt; <br>&gt; Remove NonObjectiveCBase and isUniquelyReferenced<br>&gt; <br>&gt; 	• Proposal: SE-0000<br>&gt; 	• Author: Arnold Schwaighofer<br>&gt; 	• Status: Pitch<br>&gt; 	• Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; Remove NonObjectiveCBase and isUniquelyReferenced&lt;T: NonObjectiveCBase&gt;(_ object: T). isUniquelyReferenced can be replaced by isUniquelyReferencedNonObjC&lt;T: AnyObject&gt;(_ object: T). This replacement is as performant as the call to isUniquelyReferenced in cases where the compiler has static knowledge that the type of object is a native Swift class. This change will remove surface API.<br>&gt; <br>&gt; 	• Swift-evolution thread: Pitch<br>&gt; 	• Swift bug: SR-1962<br>&gt; 	• Branch with change to stdlib: remove_nonobjectivecbase<br>&gt; Motivation<br>&gt; <br>&gt; Today we have isUniquelyReferenced which only works on subclasses of NonObjectiveCBase, and we have isUniquelyReferencedNonObjC which also works on @objc classes.<br>&gt; <br>&gt; class SwiftKlazz : NonObjectiveCBase<br>&gt;  {}<br>&gt; <br>&gt; class ObjcKlazz :<br>&gt;  NSObject {}<br>&gt; <br>&gt; expectTrue(<br>&gt; isUniquelyReferenced<br>&gt; (SwiftKlazz()))<br>&gt; expectFalse(<br>&gt; isUniquelyReferencedNonObjC<br>&gt; (ObjcKlazz()))<br>&gt; <br>&gt; <br>&gt; // Would not compile:<br>&gt; <br>&gt; expectFalse(<br>&gt; isUniquelyReferenced(ObjcKlazz()))<br>&gt; In most cases we expect developers to be using the ManagedBufferPointer type. In cases where they want to use a custom class they would use isUniquelyReferenced today and can use isUniquelyReferencedNonObjC in the future.<br>&gt; <br>&gt; class<br>&gt;  SwiftKlazz {}<br>&gt; <br>&gt; expectTrue(<br>&gt; isUniquelyReferencedNonObjC(SwiftKlazz()))<br>&gt; Removing isUniquelyReferenced&lt;T : NonObjectiveCBase&gt; will allow us to remove the NonObjectiveCBase class from the standard library thereby further shrinking API surface.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Remove isUniquelyReferenced&lt;T : NonObjectiveCBase&gt; and remove the NonObjectiveCBase class from the standard library. Clients of the the isUniquelyReferenced API can be migrated to use isUniquelyReferencedNonObjC. In most cases -- where the type of the object parameter is statically known to be a native non- at objc class -- the resulting code will have identical performance characteristics. In cases where the type is statically not known it will have the slight overhead of first checking that the dynamic type is not an @objc class.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; Todays APIs that can be used to check uniqueness is the family of isUniquelyReferenced functions.<br>&gt; <br>&gt; /// Returns `true` iff `object` is a non-`@objc` class instance with<br>&gt; /// a single strong reference.<br>&gt; ///<br>&gt; /// * Does *not* modify `object`; the use of `inout` is an<br>&gt; ///   implementation artifact.<br>&gt; /// * If `object` is an Objective-C class instance, returns `false`.<br>&gt; /// * Weak references do not affect the result of this function.<br>&gt; ///<br>&gt; /// Useful for implementing the copy-on-write optimization for the<br>&gt; /// deep storage of value types:<br>&gt; ///<br>&gt; ///     mutating func modifyMe(_ arg: X) {<br>&gt; ///       if isUniquelyReferencedNonObjC(&amp;myStorage) {<br>&gt; ///         myStorage.modifyInPlace(arg)<br>&gt; ///       }<br>&gt; ///       else {<br>&gt; ///         myStorage = self.createModified(myStorage, arg)<br>&gt; ///       }<br>&gt; ///     }<br>&gt; public func isUniquelyReferencedNonObjC&lt;T : AnyObject&gt;(_ object: inout T) -&gt; Bool<br>&gt; public func isUniquelyReferencedNonObjC&lt;T : AnyObject&gt;(_ object: inout T?) -&gt; Bool<br>&gt; <br>&gt; <br>&gt; <br>&gt; /// A common base class for classes that need to be non-`@objc`,<br>&gt; /// recognizably in the type system.<br>&gt; public class NonObjectiveCBase<br>&gt;  {<br>&gt;   <br>&gt; public init<br>&gt; () {}<br>&gt; }<br>&gt; <br>&gt; <br>&gt; public func isUniquelyReferenced&lt;T : NonObjectiveCBase<br>&gt; &gt;(<br>&gt;   <br>&gt; _ object: inout T<br>&gt; <br>&gt; ) <br>&gt; -&gt; Bool<br>&gt; And the somewhat higher level APIs that can be used to model a storage with several elements ManagedBufferPointer.<br>&gt; <br>&gt; /// Contains a buffer object, and provides access to an instance of<br>&gt; /// `Header` and contiguous storage for an arbitrary number of<br>&gt; /// `Element` instances stored in that buffer.<br>&gt; ///<br>&gt; /// For most purposes, the `ManagedBuffer` class works fine for this<br>&gt; /// purpose, and can simply be used on its own.  However, in cases<br>&gt; /// where objects of various different classes must serve as storage,<br>&gt; /// `ManagedBufferPointer` is needed.<br>&gt; ///<br>&gt; /// A valid buffer class is non-`@objc`, with no declared stored<br>&gt; ///   properties.  Its `deinit` must destroy its<br>&gt; ///   stored `Header` and any constructed `Element`s.<br>&gt; /// `Header` and contiguous storage for an arbitrary number of<br>&gt; /// `Element` instances stored in that buffer.<br>&gt; public struct ManagedBufferPointer&lt;Header, Element&gt; : Equatable<br>&gt;  {<br>&gt;   <br>&gt; /// Create with new storage containing an initial `Header` and space<br>&gt; <br>&gt;   <br>&gt; /// for at least `minimumCapacity` `element`s.<br>&gt; <br>&gt;   <br>&gt; ///<br>&gt; <br>&gt;   <br>&gt; /// - parameter bufferClass: The class of the object used for storage.<br>&gt; <br>&gt;   <br>&gt; /// - parameter minimumCapacity: The minimum number of `Element`s that<br>&gt; <br>&gt;   <br>&gt; ///   must be able to be stored in the new buffer.<br>&gt; <br>&gt;   <br>&gt; /// - parameter initialHeader: A function that produces the initial<br>&gt; <br>&gt;   <br>&gt; ///   `Header` instance stored in the buffer, given the `buffer`<br>&gt; <br>&gt;   <br>&gt; ///   object and a function that can be called on it to get the actual<br>&gt; <br>&gt;   <br>&gt; ///   number of allocated elements.<br>&gt; <br>&gt;   <br>&gt; ///<br>&gt; <br>&gt;   <br>&gt; /// - Precondition: `minimumCapacity &gt;= 0`, and the type indicated by<br>&gt; <br>&gt;   <br>&gt; ///   `bufferClass` is a non-`@objc` class with no declared stored<br>&gt; <br>&gt;   <br>&gt; ///   properties.  The `deinit` of `bufferClass` must destroy its<br>&gt; <br>&gt;   <br>&gt; ///   stored `Header` and any constructed `Element`s.<br>&gt; <br>&gt;   <br>&gt; public init<br>&gt; (<br>&gt;     bufferClass: <br>&gt; AnyClass<br>&gt; ,<br>&gt;     minimumCapacity: <br>&gt; Int<br>&gt; ,<br>&gt;     initialHeader: <br>&gt; @noescape (buffer: AnyObject, capacity: @noescape (AnyObject) -&gt; Int) throws -&gt;<br>&gt;  Header<br>&gt;   ) <br>&gt; rethrows<br>&gt; <br>&gt; <br>&gt;   <br>&gt; /// Returns `true` iff `self` holds the only strong reference to its buffer.<br>&gt; <br>&gt;   <br>&gt; ///<br>&gt; <br>&gt;   <br>&gt; /// See `isUniquelyReferenced` for details.<br>&gt; <br>&gt;   <br>&gt; public mutating func holdsUniqueReference() -&gt; Bool<br>&gt; <br>&gt; <br>&gt;   <br>&gt; /// Returns `true` iff either `self` holds the only strong reference<br>&gt; <br>&gt;   <br>&gt; /// to its buffer or the pinned has been &#39;pinned&#39;.<br>&gt; <br>&gt;   <br>&gt; ///<br>&gt; <br>&gt;   <br>&gt; /// See `isUniquelyReferenced` for details.<br>&gt; <br>&gt;   <br>&gt; public mutating func holdsUniqueOrPinnedReference() -&gt; Bool<br>&gt; <br>&gt; <br>&gt;   <br>&gt; internal var _nativeBuffer: Builtin.<br>&gt; NativeObject<br>&gt; }<br>&gt; <br>&gt; <br>&gt; /// A class whose instances contain a property of type `Header` and raw<br>&gt; /// storage for an array of `Element`, whose size is determined at<br>&gt; /// instance creation.<br>&gt; public class ManagedBuffer&lt;Header, Element&gt;<br>&gt; <br>&gt;   <br>&gt; : ManagedProtoBuffer&lt;Header, Element&gt;<br>&gt;  {<br>&gt; <br>&gt;   <br>&gt; /// Create a new instance of the most-derived class, calling<br>&gt; <br>&gt;   <br>&gt; /// `initialHeader` on the partially-constructed object to<br>&gt; <br>&gt;   <br>&gt; /// generate an initial `Header`.<br>&gt; <br>&gt;   <br>&gt; public final class func create<br>&gt; (<br>&gt;     minimumCapacity: <br>&gt; Int<br>&gt; ,<br>&gt;     initialHeader: <br>&gt; @noescape (ManagedProtoBuffer&lt;Header, Element&gt;) throws -&gt;<br>&gt;  Header<br>&gt;   ) <br>&gt; rethrows -&gt; ManagedBuffer&lt;Header, Element&gt;<br>&gt;  {<br>&gt; <br>&gt;     <br>&gt; let p = try ManagedBufferPointer&lt;Header, Element&gt;<br>&gt; (<br>&gt;       bufferClass: <br>&gt; self<br>&gt; ,<br>&gt;       minimumCapacity: minimumCapacity,<br>&gt;       initialHeader: { buffer, _ <br>&gt; in<br>&gt; <br>&gt;         <br>&gt; try<br>&gt;  initialHeader(<br>&gt;           <br>&gt; unsafeDowncast(buffer, to: ManagedProtoBuffer&lt;Header, Element&gt;.self<br>&gt; ))<br>&gt;       })<br>&gt; <br>&gt;     <br>&gt; return unsafeDowncast(p.buffer, to: ManagedBuffer&lt;Header, Element&gt;.self<br>&gt; )<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; We propose to remove the NonObjectiveCBase class and isUniquelyReferenced&lt;T: NonObjectiveCBase&gt;(_ object: T&gt;.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; Existing code that uses isUniquelyReferenced will need to remove the NonObjectiveCBase base class and replace calls to isUniquelyReferenced by isUniquelyReferencedNonObjC. The old API will be marked unavailable to help migration.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Leave the status quo and pay for type safety with additional API surface. Another alternative we considered -- the first version of this proposal -- was to replace the isUniquelyReferenced API by an isUniquelyReferencedUnsafe&lt;T: AnyObject&gt;(_ object: T) API that would assume the object to be a non- at objc class and only check this precondition under -Onone. There is however no good reason to keep this API given that the isUniquelyReferencedNonObjC is as performant when the type is statically known to be non- at objc class.<br>&gt;&gt; On Jul 16, 2016, at 10:12 PM, Arnold via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On Jul 16, 2016, at 9:41 PM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 16, 2016, at 9:23 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 16, 2016, at 9:17 PM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 16, 2016, at 8:45 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 16, 2016, at 8:36 PM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thank you for the feedback. Answers online.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 16, 2016, at 7:38 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 16, 2016, at 6:46 PM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Replace isUniquelyReferenced&lt;T : NonObjectiveCBase&gt; by isUniquelyReferencedUnsafe&lt;T: AnyObject&gt; and remove the NonObjectiveCBase class from the standard library.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So we’ll have:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - isUniquelyReferencedNonObjC(object): true iff object is uniquely referenced and NonObjC<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - isUniquelyReferencedUnsafe(object): true iff object is uniquely reference, assert NonObjC<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m going to be picky. The “Unsafe” suffix doesn’t make sense to me. If you think this is an unsafe API then it should be:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; “unsafeIsUniquelyReferenced”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But I don’t really see how it is unsafe in the usual sense. If you want to convey that the programmer needs to satisfy some precondition, which is not generally associated with unsafety, then it should be:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; “isUniquelyReferencedAssumingNonObjC”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Makes sense to me. I think it is unsafe in the sense if you don&#39;t satisfy the precondition the resulting behavior is undefined in modes other than -Onone and not checked by a precondition predicate that traps.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unsafeIsUniquelyReferenced<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I find it kind of nice to recognize a predicate by the &#39;is&#39; prefix. All unsafe APIs start with the word unsafe though. I could not find an unsafe freestanding predicate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; [As the implementor of the underlying builtin you may remember that it is not actually undefined and will return a implementation defined value (false) for objc classes. But we might not want to guarantee this going forward.]<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Oh yeah. I think I only kept the two versions for fear of breaking the API. Since you’re renaming the second one anyway, why not just delete it with a fixit that it&#39;s renamed to isUniquelyReferencedNonObjC?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The “assuming” version of the API is extremely confusing in addition to being useless.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The unsafe version would allow us to emit more efficient code (in the future) for a static unknown object type but we know it is a native type (but not which so we can&#39;t just cast it, this is public API so we can&#39;t cast to Builtin.NativeObject).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   var self: AnyObject // really: AnyNativeObject<br>&gt;&gt;&gt;&gt;&gt;   ...<br>&gt;&gt;&gt;&gt;&gt;   if (!unsafeIsUniquelyReferenced(&amp;self))<br>&gt;&gt;&gt;&gt;&gt;     self = self.copy()<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I admit this is somewhat contrived and am happy to just nuke the API if we agree there is no value in the use case above.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is no sense advertising this API under some new name if it hasn’t even been implemented. The API can be added when it makes sense.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1 for eliminating it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Today you can implement something similar using NonObjectiveCBase as your base class:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  var self: NonObjectiveCBase<br>&gt;&gt;&gt;  ...<br>&gt;&gt;&gt;  if (isUniquelyReferenced(&amp;self) {...}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And get the runtime performance of the native check.<br>&gt;&gt; <br>&gt;&gt; Actually, this code could just implement their own &#39;class NonObjCBase&#39; base class and just use isUniquelyReferencedNonObj for the same performance as before ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we implemented &#39;unsafeIsUniquelyReferenced&#39; we would just unsafeBitCast the &#39;object&#39; argument to Builtin.NativeObject and get the same performance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I admit that this may be far fetched but I am trying to anticipated possible use cases that work today.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That use case will still work after nuking the API using the &#39;NonObjC&#39; variant albeit slightly slower.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we need to support it with best performance we can always bring the API back as you said.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 for nuking it from me<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I will change the proposal.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/724d0296dfeefeabab41ca0bd2a74736?s=50"></div><header><strong>Pitch: Remove `NonObjectiveCBase` and replace `isUniquelyReferenced` by `isUniquelyReferencedUnsafe`</strong> from <string>Jaden Geller</string> &lt;jgeller at caltech.edu&gt;<p>July 16, 2016 at 03:00:00pm</p></header><div class="content"><p>Some explanation of the benefit of keeping both `isUniquelyReferencedUnsafe` and `isUniqueReferencedNonObjC` would be useful. I’m not entirely sure why the latter is useful. If it is useful, I’m not sure why we can’t just have `isUniquelyReferencedUnsafe` and `isObjC`.<br></p><p>&gt; On Jul 16, 2016, at 1:21 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Sat, Jul 16, 2016 at 12:47 PM, Arnold Schwaighofer via<br>&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; ## Proposed solution<br>&gt;&gt; <br>&gt;&gt; Replace `isUniquelyReferenced&lt;T : NonObjectiveCBase&gt;` by<br>&gt;&gt; `isUniquelyReferencedUnsafe&lt;T: AnyObject&gt;` and remove the `NonObjectiveCBase`<br>&gt;&gt; class from the standard library.<br>&gt; <br>&gt; Thank you for this proposal!<br>&gt; <br>&gt; For presentation and clarity, could you show the full family of<br>&gt; `isUniquely*` functions in the design section, including those<br>&gt; functions that you are not proposing to change?  This will make it<br>&gt; easier to see what choices users will get.  It would be also great to<br>&gt; include the API of similar ManagedBuffer and ManagedBufferPointer<br>&gt; APIs, if any exist.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
