<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>access control</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 23, 2016 at 07:00:00pm</p></header><div class="content"><p>on Sat Jan 23 2016, Ilya Belenkiy &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;&gt; Yes, but with an API based access control, <br>&gt;&gt; <br>&gt;&gt; I don&#39;t know what that term means, sorry.<br>&gt;<br>&gt; I had to come up with this term to distinguish it from a file based<br>&gt; access control. In API based access control, visibility of anything is<br>&gt; tied to the declaration instead of the file it is in. <br>&gt;<br>&gt; It’s the model that C++ and C# ( and I am sure many others) use. In<br>&gt; file based access control, visibility of anything is tied to the file<br>&gt; it is in and has little to do with the class API itself. It’s the<br>&gt; model that Swift currently follows.<br></p><p>I disagree with your analysis.  Every declaration in Swift has a<br>visibility.  That visibility is attached to the declaration itself, not<br>to the file.  Every declaration can live in only one spot, and that&#39;s<br>where the visibility is set.  You can&#39;t go to another file and do<br>something there to alter the declaration&#39;s visibility.  The fact that we<br>made the most restrictive visibilty level &quot;visibile within the file&quot;<br>rather than &quot;visible within the type&quot; does not mean the model is<br>fundamentally different.<br></p><p>&gt;&gt;&gt; anyone modifying / extending the class can instantly see the author’s<br>&gt;&gt;&gt; intent from the API declaration, <br>&gt;&gt; <br>&gt;&gt; I don&#39;t see how that&#39;s different from what we have in Swift.  Private<br>&gt;&gt; APIs are the ones you don&#39;t want anyone to touch because they can break<br>&gt;&gt; your invariants.<br>&gt;<br>&gt; In Swift, any additional code in the same source file can use the APIs<br>&gt; declared private and break your invariants. The semantic meaning of<br>&gt; private is not “use only inside the class” but “use only inside this<br>&gt; file”. It is currently impossible to express “use only inside the<br>&gt; class” semantics.<br></p><p>That is true.  The question is, would having a way to express that be<br>worth the complexity it introduces?  Reasonable people can disagree<br>about that.  <br></p><p>&gt;&gt; Seeing the keyword “private” isn&#39;t enough for you in Swift, but it is in<br>&gt;&gt; C++?  Why?<br>&gt;<br>&gt; Because in Swift, private means “use only inside this file” and not<br>&gt; “use only inside this class / scope”. In C++ private means “use only<br>&gt; inside this class”. Moreover, C++ puts a special emphasis on this —<br>&gt; variables are private inside the class unless the code specifically<br>&gt; says otherwise.<br></p><p>I ended up generally being explicit about scoping in C++ anyway: The<br>most-accessible (public) part of a C++ class declaration should appear<br>at the top, so you end up with everything thereafter being public unless<br>you go out of your way to explicitly specify access.<br></p><p>&gt;&gt;  Defining one type per file is usually a good practice anyway.<br>&gt;<br>&gt; This really depends on the context. There is value in keeping similar<br>&gt; concepts / implementations in the same file. <br></p><p>Usually when they have an intimate relationship and need access to one<br>another&#39;s implementation details.  We didn&#39;t want to end up with<br>&quot;friend&quot; as in C++, so we made file-level access control what you get<br>from &quot;private.&quot;<br></p><p>For what it&#39;s worth, my background, up until a few years ago, is as a<br>C++ programmer.  I was a little uncomfortable at first with the idea of<br>giving up a &quot;limit-to-the-type&quot; level of access control, but when I<br>considered how real C++ code was developed I realized that people<br>generally control changes to code at file-level granularity.  If they<br>want protection from themselves, they can choose the file boundaries<br>accordingly.  IMO it&#39;s a good trade to avoid having a wart like &quot;friend&quot;<br>in the language.  Another level of access control might be useful, but<br>I don&#39;t think it&#39;s crucial.<br></p><p>&gt; If one class and one extension per file become a requirement,<br>&gt; then private will have the same semantics as in C++. It will also<br>&gt; become very inconvenient to write code because even a small extension<br>&gt; with 1 method that can fit on one line will require a separate file.<br></p><p>Whoa, I never said anything about one extension per file, or about<br>requirements.<br></p><p>&gt;&gt; Without prohibiting class extensions from being made in the same file<br>&gt;&gt; where the class is defined—a capability we want to keep available to<br>&gt;&gt; class authors—that will always be the case.<br>&gt;<br>&gt; It doesn’t have to be. My proposal (still a pull request) provides a<br>&gt; way to explicitly declare a function or a property to be private to<br>&gt; the scope where it is defined. So extensions and subclasses declared<br>&gt; in the same file cannot access it and break the invariant. If it’s<br>&gt; applied to both class definitions and extensions, it’s very consistent<br>&gt; and provides an explicit declaration of intent that can (and should)<br>&gt; be enforced by the compiler.<br>&gt;<br>&gt;&gt; Therefore, you have the<br>&gt;&gt; same scenario as in C++: anyone who modifies the file where a class is<br>&gt;&gt; defined might be violating its invariants.  It&#39;s just that in C++ the<br>&gt;&gt; violator has to write code between a particular set of braces.  When<br>&gt;&gt; reviewing diffs it&#39;s very common not to have enough context to see those<br>&gt;&gt; braces anyway.<br>&gt;<br>&gt; This is a crucial distinction. That particular set of braces defines a<br>&gt; scope which acts as a black box and hides the implementation<br>&gt; details. Anything outside the scope cannot damage the internal state,<br>&gt; and the compiler *enforces* it. <br></p><p>We do that in Swift as well; we just chose a different box boundary.<br></p><p>&gt; In Swift, the compiler only enforces that the API is not visible from<br>&gt; another file because the language has no way to express “this should<br>&gt; be visible only in the scope to hide implementation details”. The only<br>&gt; exception to that are functions inside other functions and local<br>&gt; variables — right now this is the only way to completely hide<br>&gt; implementation details, but it’s very limited.<br>&gt;<br>&gt; My main 2 points are that it’s impossible to express the intent of a<br>&gt; truly local access level to hide implementation details, and because<br>&gt; of that, the compiler cannot enforce this intent.<br>&gt;<br>&gt;&gt; When reviewing diffs it&#39;s very common not to have enough context to<br>&gt;&gt; see those braces anyway.<br>&gt;<br>&gt; This depends on how thoroughly the code is reviewed. But the main<br>&gt; point there is that when you find out, you know that whoever worked<br>&gt; around a private API did so knowing that he was introducing a<br>&gt; hack. Because Swift has no way of expressing “this is private to the<br>&gt; class, not just file it’s in”, someone may not know and make a<br>&gt; mistake, and the compiler cannot catch it. My proposal makes the<br>&gt; intent expressible in the language and enforceable by the compiler.<br></p><p>I think you&#39;ll agree that if you ignore (or are ignorant of) the intent<br>behind the application of any given access control construct, and you<br>have the ability to change all the code in the project, you are likely<br>to break someone&#39;s invariants.  If you aren&#39;t willing to treat something<br>that&#39;s labelled as &quot;private&quot; as &quot;don&#39;t touch unless you know what you&#39;re<br>doing,&quot; there&#39;s nothing the compiler can do to enforce correctness, and<br>there&#39;s not much difference between making make changes in the file<br>where it&#39;s declared and making changes between the braces where it&#39;s<br>declared.<br></p><p>&gt;&gt; Not at all in the same way.  In C++, you can&#39;t add methods to a class<br>&gt;&gt; outside the file where it&#39;s declared unless there&#39;s some really horrible<br>&gt;&gt; preprocessor stuff going on, and even then the class author would have<br>&gt;&gt; had to explicitly left that door open for you.<br>&gt;<br>&gt; True, but my proposal deals with extensions the same way it does with<br>&gt; class definitions — it provides a way to hide implementation details<br>&gt; in a scope (whether it be a class definition or an extension scope)<br>&gt; and make them invisible to everything else including extensions or<br>&gt; other extensions or anything else in the same file. It provides a way<br>&gt; to express the intent in the language and enforce it by the compiler.<br></p><p>I think it&#39;s possible to believe that your feature would be useful<br>without also believing there&#39;s something fundamentally wrong with the<br>current model, and your arguments make it sound to me like you think<br>you&#39;re getting a lot more certainty from C++&#39;s &quot;private&quot; than you<br>actually are.<br></p><p><br>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 24, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; I think it&#39;s possible to believe that your feature would be useful<br>&gt; without also believing there&#39;s something fundamentally wrong with the<br>&gt; current model, and your arguments make it sound to me like you think<br>&gt; you&#39;re getting a lot more certainty from C++&#39;s &quot;private&quot; than you<br>&gt; actually are.<br></p><p><br>Data encapsulation is a cornerstone of object oriented programming. Swift has classes, and yet it is impossible to completely hide state / implementation details inside the class. Moreover, it’s impossible to express that something is intended to be completely hidden. Since such a fundamental idea is not supported, there is something fundamentally wrong with the current model. Swift is already a great language, and this issue aside, it’s by far the best language I’ve used. In all other areas Swift does a great job to help the programmer write correct code. This is one weird and very noticeable deviation.<br></p><p>&gt; We do that in Swift as well; we just chose a different box boundary.<br></p><p>The box boundary is not arbitrary. The current model is perfect for code without classes. But for classes, data encapsulation is not just a “nice to have” feature. It’s such a fundamental part of object oriented programming that it’s expected. This would be like having no functions in a functional language or no variables in a procedural language :–)<br></p><p>&gt; Whoa, I never said anything about one extension per file, or about<br>&gt; requirements.<br></p><p>This would be the only way to make the current meaning of private perfectly match what everybody outside of Swift expects it to mean.<br></p><p>&gt; That is true.  The question is, would having a way to express that be<br>&gt; worth the complexity it introduces?  Reasonable people can disagree<br>&gt; about that.  <br></p><p>I think that it’s worth every bit. I can live without “protected”. It can be argued that once you expose something, you lose control over it. But “private” is different. I’ll reference data encapsulation again. I don’t understand how anyone can seriously argue that it’s not important in a language that aims to support object oriented programming.<br></p><p>&gt; Usually when they have an intimate relationship and need access to one<br>&gt; another&#39;s implementation details.  We didn&#39;t want to end up with<br>&gt; &quot;friend&quot; as in C++, so we made file-level access control what you get<br>&gt; from &quot;private.”<br></p><p>Yes, I totally agree that having a way to say “available to all in this file” is useful precisely for this reason. I just think that it’s misnamed. The honest way to call it would be something like “file internal”. But even if the right name is already taken, we can still have the access level itself. I proposed “local” or “scoped”. (I’d prefer to rename private to file internal and call local “private”, but that raises backward compatibility issues, and I didn’t want the proposal to be rejected just for that reason.)<br></p><p>&gt; For what it&#39;s worth, my background, up until a few years ago, is as a<br>&gt; C++ programmer.  I was a little uncomfortable at first with the idea of<br>&gt; giving up a &quot;limit-to-the-type&quot; level of access control, but when I<br>&gt; considered how real C++ code was developed I realized that people<br>&gt; generally control changes to code at file-level granularity.  If they<br>&gt; want protection from themselves, they can choose the file boundaries<br>&gt; accordingly.  IMO it&#39;s a good trade to avoid having a wart like &quot;friend&quot;<br>&gt; in the language.  Another level of access control might be useful, but<br>&gt; I don&#39;t think it&#39;s crucial.<br></p><p>This may be true, but the right solution is not do abandon data encapsulation. It’s to make it easy to use correctly. I always used const in C++ wherever possible, but it was a pain. Swift implementation is perfect. Very easy to use and encourages good practice. I don’t see why the same couldn’t be done with access control. (I think that making “local” the default access level would be a perfect solution, but simply having the option would be good enough for me. I’d use it everywhere to hide internal state and implementation details.)<br></p><p>&gt; On Jan 23, 2016, at 10:01 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat Jan 23 2016, Ilya Belenkiy &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; Yes, but with an API based access control, <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know what that term means, sorry.<br>&gt;&gt; <br>&gt;&gt; I had to come up with this term to distinguish it from a file based<br>&gt;&gt; access control. In API based access control, visibility of anything is<br>&gt;&gt; tied to the declaration instead of the file it is in. <br>&gt;&gt; <br>&gt;&gt; It’s the model that C++ and C# ( and I am sure many others) use. In<br>&gt;&gt; file based access control, visibility of anything is tied to the file<br>&gt;&gt; it is in and has little to do with the class API itself. It’s the<br>&gt;&gt; model that Swift currently follows.<br>&gt; <br>&gt; I disagree with your analysis.  Every declaration in Swift has a<br>&gt; visibility.  That visibility is attached to the declaration itself, not<br>&gt; to the file.  Every declaration can live in only one spot, and that&#39;s<br>&gt; where the visibility is set.  You can&#39;t go to another file and do<br>&gt; something there to alter the declaration&#39;s visibility.  The fact that we<br>&gt; made the most restrictive visibilty level &quot;visibile within the file&quot;<br>&gt; rather than &quot;visible within the type&quot; does not mean the model is<br>&gt; fundamentally different.<br>&gt; <br>&gt;&gt;&gt;&gt; anyone modifying / extending the class can instantly see the author’s<br>&gt;&gt;&gt;&gt; intent from the API declaration, <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t see how that&#39;s different from what we have in Swift.  Private<br>&gt;&gt;&gt; APIs are the ones you don&#39;t want anyone to touch because they can break<br>&gt;&gt;&gt; your invariants.<br>&gt;&gt; <br>&gt;&gt; In Swift, any additional code in the same source file can use the APIs<br>&gt;&gt; declared private and break your invariants. The semantic meaning of<br>&gt;&gt; private is not “use only inside the class” but “use only inside this<br>&gt;&gt; file”. It is currently impossible to express “use only inside the<br>&gt;&gt; class” semantics.<br>&gt; <br>&gt; That is true.  The question is, would having a way to express that be<br>&gt; worth the complexity it introduces?  Reasonable people can disagree<br>&gt; about that.  <br>&gt; <br>&gt;&gt;&gt; Seeing the keyword “private” isn&#39;t enough for you in Swift, but it is in<br>&gt;&gt;&gt; C++?  Why?<br>&gt;&gt; <br>&gt;&gt; Because in Swift, private means “use only inside this file” and not<br>&gt;&gt; “use only inside this class / scope”. In C++ private means “use only<br>&gt;&gt; inside this class”. Moreover, C++ puts a special emphasis on this —<br>&gt;&gt; variables are private inside the class unless the code specifically<br>&gt;&gt; says otherwise.<br>&gt; <br>&gt; I ended up generally being explicit about scoping in C++ anyway: The<br>&gt; most-accessible (public) part of a C++ class declaration should appear<br>&gt; at the top, so you end up with everything thereafter being public unless<br>&gt; you go out of your way to explicitly specify access.<br>&gt; <br>&gt;&gt;&gt; Defining one type per file is usually a good practice anyway.<br>&gt;&gt; <br>&gt;&gt; This really depends on the context. There is value in keeping similar<br>&gt;&gt; concepts / implementations in the same file. <br>&gt; <br>&gt; Usually when they have an intimate relationship and need access to one<br>&gt; another&#39;s implementation details.  We didn&#39;t want to end up with<br>&gt; &quot;friend&quot; as in C++, so we made file-level access control what you get<br>&gt; from &quot;private.&quot;<br>&gt; <br>&gt; For what it&#39;s worth, my background, up until a few years ago, is as a<br>&gt; C++ programmer.  I was a little uncomfortable at first with the idea of<br>&gt; giving up a &quot;limit-to-the-type&quot; level of access control, but when I<br>&gt; considered how real C++ code was developed I realized that people<br>&gt; generally control changes to code at file-level granularity.  If they<br>&gt; want protection from themselves, they can choose the file boundaries<br>&gt; accordingly.  IMO it&#39;s a good trade to avoid having a wart like &quot;friend&quot;<br>&gt; in the language.  Another level of access control might be useful, but<br>&gt; I don&#39;t think it&#39;s crucial.<br>&gt; <br>&gt;&gt; If one class and one extension per file become a requirement,<br>&gt;&gt; then private will have the same semantics as in C++. It will also<br>&gt;&gt; become very inconvenient to write code because even a small extension<br>&gt;&gt; with 1 method that can fit on one line will require a separate file.<br>&gt; <br>&gt; Whoa, I never said anything about one extension per file, or about<br>&gt; requirements.<br>&gt; <br>&gt;&gt;&gt; Without prohibiting class extensions from being made in the same file<br>&gt;&gt;&gt; where the class is defined—a capability we want to keep available to<br>&gt;&gt;&gt; class authors—that will always be the case.<br>&gt;&gt; <br>&gt;&gt; It doesn’t have to be. My proposal (still a pull request) provides a<br>&gt;&gt; way to explicitly declare a function or a property to be private to<br>&gt;&gt; the scope where it is defined. So extensions and subclasses declared<br>&gt;&gt; in the same file cannot access it and break the invariant. If it’s<br>&gt;&gt; applied to both class definitions and extensions, it’s very consistent<br>&gt;&gt; and provides an explicit declaration of intent that can (and should)<br>&gt;&gt; be enforced by the compiler.<br>&gt;&gt; <br>&gt;&gt;&gt; Therefore, you have the<br>&gt;&gt;&gt; same scenario as in C++: anyone who modifies the file where a class is<br>&gt;&gt;&gt; defined might be violating its invariants.  It&#39;s just that in C++ the<br>&gt;&gt;&gt; violator has to write code between a particular set of braces.  When<br>&gt;&gt;&gt; reviewing diffs it&#39;s very common not to have enough context to see those<br>&gt;&gt;&gt; braces anyway.<br>&gt;&gt; <br>&gt;&gt; This is a crucial distinction. That particular set of braces defines a<br>&gt;&gt; scope which acts as a black box and hides the implementation<br>&gt;&gt; details. Anything outside the scope cannot damage the internal state,<br>&gt;&gt; and the compiler *enforces* it. <br>&gt; <br>&gt; We do that in Swift as well; we just chose a different box boundary.<br>&gt; <br>&gt;&gt; In Swift, the compiler only enforces that the API is not visible from<br>&gt;&gt; another file because the language has no way to express “this should<br>&gt;&gt; be visible only in the scope to hide implementation details”. The only<br>&gt;&gt; exception to that are functions inside other functions and local<br>&gt;&gt; variables — right now this is the only way to completely hide<br>&gt;&gt; implementation details, but it’s very limited.<br>&gt;&gt; <br>&gt;&gt; My main 2 points are that it’s impossible to express the intent of a<br>&gt;&gt; truly local access level to hide implementation details, and because<br>&gt;&gt; of that, the compiler cannot enforce this intent.<br>&gt;&gt; <br>&gt;&gt;&gt; When reviewing diffs it&#39;s very common not to have enough context to<br>&gt;&gt;&gt; see those braces anyway.<br>&gt;&gt; <br>&gt;&gt; This depends on how thoroughly the code is reviewed. But the main<br>&gt;&gt; point there is that when you find out, you know that whoever worked<br>&gt;&gt; around a private API did so knowing that he was introducing a<br>&gt;&gt; hack. Because Swift has no way of expressing “this is private to the<br>&gt;&gt; class, not just file it’s in”, someone may not know and make a<br>&gt;&gt; mistake, and the compiler cannot catch it. My proposal makes the<br>&gt;&gt; intent expressible in the language and enforceable by the compiler.<br>&gt; <br>&gt; I think you&#39;ll agree that if you ignore (or are ignorant of) the intent<br>&gt; behind the application of any given access control construct, and you<br>&gt; have the ability to change all the code in the project, you are likely<br>&gt; to break someone&#39;s invariants.  If you aren&#39;t willing to treat something<br>&gt; that&#39;s labelled as &quot;private&quot; as &quot;don&#39;t touch unless you know what you&#39;re<br>&gt; doing,&quot; there&#39;s nothing the compiler can do to enforce correctness, and<br>&gt; there&#39;s not much difference between making make changes in the file<br>&gt; where it&#39;s declared and making changes between the braces where it&#39;s<br>&gt; declared.<br>&gt; <br>&gt;&gt;&gt; Not at all in the same way.  In C++, you can&#39;t add methods to a class<br>&gt;&gt;&gt; outside the file where it&#39;s declared unless there&#39;s some really horrible<br>&gt;&gt;&gt; preprocessor stuff going on, and even then the class author would have<br>&gt;&gt;&gt; had to explicitly left that door open for you.<br>&gt;&gt; <br>&gt;&gt; True, but my proposal deals with extensions the same way it does with<br>&gt;&gt; class definitions — it provides a way to hide implementation details<br>&gt;&gt; in a scope (whether it be a class definition or an extension scope)<br>&gt;&gt; and make them invisible to everything else including extensions or<br>&gt;&gt; other extensions or anything else in the same file. It provides a way<br>&gt;&gt; to express the intent in the language and enforce it by the compiler.<br>&gt; <br>&gt; I think it&#39;s possible to believe that your feature would be useful<br>&gt; without also believing there&#39;s something fundamentally wrong with the<br>&gt; current model, and your arguments make it sound to me like you think<br>&gt; you&#39;re getting a lot more certainty from C++&#39;s &quot;private&quot; than you<br>&gt; actually are.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/ecfdeaff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>access control</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 24, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 24, 2016, at 1:15 PM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I think it&#39;s possible to believe that your feature would be useful<br>&gt;&gt; without also believing there&#39;s something fundamentally wrong with the<br>&gt;&gt; current model, and your arguments make it sound to me like you think<br>&gt;&gt; you&#39;re getting a lot more certainty from C++&#39;s &quot;private&quot; than you<br>&gt;&gt; actually are.<br>&gt; <br>&gt; <br>&gt; Data encapsulation is a cornerstone of object oriented programming. Swift has classes, and yet it is impossible to completely hide state / implementation details inside the class. Moreover, it’s impossible to express that something is intended to be completely hidden. Since such a fundamental idea is not supported, there is something fundamentally wrong with the current model. Swift is already a great language, and this issue aside, it’s by far the best language I’ve used. In all other areas Swift does a great job to help the programmer write correct code. This is one weird and very noticeable deviation.<br></p><p>Data encapsulation is indeed one of the cornerstone of OO, but every design decision is a trade-off. Is Python not object-oriented because they lack a private keyword, and have the convention of marking internal items with a leading underscore?<br></p><p>In addition, it is not possible to completely hide state/implementation details in any language (at least that I have experience with). Java, for instance, will let me use the security manager and RTTI to modify private values, and even has JNI code to modify final values as well (this is how System.out works). There are projects that fundamentally depend on being able to access private fields, such as Spring, partly because the Java standard library tells them to (@Injectable).<br></p><p>Even with a “perfect” language mechanism, consumers of the binary will still patch it if they need to in order to get the functionality they want.<br></p><p>The best anyone can do is make the breaking of encapsulation an explicit choice. I’m intuiting that you think that writing code into the file where the class was defined is not explicit enough. I feel comfortable saying to my team members that you have to justify adding code next to a class in the same way you would need to justify changing the implementation of that class. The difference between ‘local’ and ‘private’ access is a copy/paste of a function from an extension into the class body within the same file.<br></p><p>-DW<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6c95cd06f79f91eaf9f58e4f1c50a25a?s=50"></div><header><strong>access control</strong> from <string>Ondrej Barina</string> &lt;obarina at gmail.com&gt;<p>January 25, 2016 at 10:00:00am</p></header><div class="content"><p>IIya:  Private access on file is just fine. I do not understand why you are<br>so much against it. Just stop for 10 minutes and think about it...<br>Ondrej Barina<br></p><p>On Mon, Jan 25, 2016 at 3:54 AM, David Waite via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 24, 2016, at 1:15 PM, Ilya Belenkiy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; I think it&#39;s possible to believe that your feature would be useful<br>&gt; &gt;&gt; without also believing there&#39;s something fundamentally wrong with the<br>&gt; &gt;&gt; current model, and your arguments make it sound to me like you think<br>&gt; &gt;&gt; you&#39;re getting a lot more certainty from C++&#39;s &quot;private&quot; than you<br>&gt; &gt;&gt; actually are.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Data encapsulation is a cornerstone of object oriented programming.<br>&gt; Swift has classes, and yet it is impossible to completely hide state /<br>&gt; implementation details inside the class. Moreover, it’s impossible to<br>&gt; express that something is intended to be completely hidden. Since such a<br>&gt; fundamental idea is not supported, there is something fundamentally wrong<br>&gt; with the current model. Swift is already a great language, and this issue<br>&gt; aside, it’s by far the best language I’ve used. In all other areas Swift<br>&gt; does a great job to help the programmer write correct code. This is one<br>&gt; weird and very noticeable deviation.<br>&gt;<br>&gt; Data encapsulation is indeed one of the cornerstone of OO, but every<br>&gt; design decision is a trade-off. Is Python not object-oriented because they<br>&gt; lack a private keyword, and have the convention of marking internal items<br>&gt; with a leading underscore?<br>&gt;<br>&gt; In addition, it is not possible to completely hide state/implementation<br>&gt; details in any language (at least that I have experience with). Java, for<br>&gt; instance, will let me use the security manager and RTTI to modify private<br>&gt; values, and even has JNI code to modify final values as well (this is how<br>&gt; System.out works). There are projects that fundamentally depend on being<br>&gt; able to access private fields, such as Spring, partly because the Java<br>&gt; standard library tells them to (@Injectable).<br>&gt;<br>&gt; Even with a “perfect” language mechanism, consumers of the binary will<br>&gt; still patch it if they need to in order to get the functionality they want.<br>&gt;<br>&gt; The best anyone can do is make the breaking of encapsulation an explicit<br>&gt; choice. I’m intuiting that you think that writing code into the file where<br>&gt; the class was defined is not explicit enough. I feel comfortable saying to<br>&gt; my team members that you have to justify adding code next to a class in the<br>&gt; same way you would need to justify changing the implementation of that<br>&gt; class. The difference between ‘local’ and ‘private’ access is a copy/paste<br>&gt; of a function from an extension into the class body within the same file.<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/cfbca0fe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 25, 2016 at 07:00:00am</p></header><div class="content"><p>&gt;  I do not understand why you are so much against it<br></p><p>Data encapsulation is a cornerstone of object oriented programming. Swift has classes, and yet it is impossible to completely hide state / implementation details inside the class. Moreover, it’s impossible to express that something is intended to be completely hidden. Since such a fundamental idea is not supported, there is something fundamentally wrong with the current model. <br></p><p>&gt; Just stop for 10 minutes and think about it…<br></p><p>https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)<br></p><p>&gt; On Jan 25, 2016, at 4:21 AM, Ondrej Barina &lt;obarina at gmail.com&gt; wrote:<br>&gt; <br>&gt; IIya:  Private access on file is just fine. I do not understand why you are so much against it. Just stop for 10 minutes and think about it...<br>&gt; Ondrej Barina<br>&gt; <br>&gt; On Mon, Jan 25, 2016 at 3:54 AM, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Jan 24, 2016, at 1:15 PM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; I think it&#39;s possible to believe that your feature would be useful<br>&gt; &gt;&gt; without also believing there&#39;s something fundamentally wrong with the<br>&gt; &gt;&gt; current model, and your arguments make it sound to me like you think<br>&gt; &gt;&gt; you&#39;re getting a lot more certainty from C++&#39;s &quot;private&quot; than you<br>&gt; &gt;&gt; actually are.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Data encapsulation is a cornerstone of object oriented programming. Swift has classes, and yet it is impossible to completely hide state / implementation details inside the class. Moreover, it’s impossible to express that something is intended to be completely hidden. Since such a fundamental idea is not supported, there is something fundamentally wrong with the current model. Swift is already a great language, and this issue aside, it’s by far the best language I’ve used. In all other areas Swift does a great job to help the programmer write correct code. This is one weird and very noticeable deviation.<br>&gt; <br>&gt; Data encapsulation is indeed one of the cornerstone of OO, but every design decision is a trade-off. Is Python not object-oriented because they lack a private keyword, and have the convention of marking internal items with a leading underscore?<br>&gt; <br>&gt; In addition, it is not possible to completely hide state/implementation details in any language (at least that I have experience with). Java, for instance, will let me use the security manager and RTTI to modify private values, and even has JNI code to modify final values as well (this is how System.out works). There are projects that fundamentally depend on being able to access private fields, such as Spring, partly because the Java standard library tells them to (@Injectable).<br>&gt; <br>&gt; Even with a “perfect” language mechanism, consumers of the binary will still patch it if they need to in order to get the functionality they want.<br>&gt; <br>&gt; The best anyone can do is make the breaking of encapsulation an explicit choice. I’m intuiting that you think that writing code into the file where the class was defined is not explicit enough. I feel comfortable saying to my team members that you have to justify adding code next to a class in the same way you would need to justify changing the implementation of that class. The difference between ‘local’ and ‘private’ access is a copy/paste of a function from an extension into the class body within the same file.<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/ded8e1f3/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 25, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Data encapsulation is indeed one of the cornerstone of OO, but every design decision is a trade-off. Is Python not object-oriented because they lack a private keyword, and have the convention of marking internal items with a leading underscore?<br></p><p><br>Then Python has the same problem. A language that *supports* OOP should not leave such an important part of OOP to coding by convention. <br></p><p>I don’t think that there is a trade-off here. My proposal doesn’t break anything. It only adds one more modifier which is not inconsistent with the existing access control. I also think that it will be easy to implement for anyone who is familiar with the code.<br></p><p>&gt; In addition, it is not possible to completely hide state/implementation details in any language (at least that I have experience with).<br></p><p>It’s the same argument as the worth of having a strong type system. In C++, you can reinterpret any pointer any way you want, but it still has a very strong type system and a very strong access control. The intent is to catch *accidental* mistakes, not a deliberate misuse. The compiler is much better at this than any convention.<br></p><p>&gt; The best anyone can do is make the breaking of encapsulation an explicit choice. I’m intuiting that you think that writing code into the file where the class was defined is not explicit enough.<br></p><p>Right now, it’s impossible to make the distinction: is something truly private or can be used safely in the same file? The language has no way of expressing it. The class internal state is not encapsulated outside the bounds of the class.<br></p><p>&gt; I feel comfortable saying to my team members that you have to justify adding code next to a class in the same way you would need to justify changing the implementation of that class. The difference between ‘local’ and ‘private’ access is a copy/paste of a function from an extension into the class body within the same file.<br></p><p>It’s more than just extensions. Right now *anything* in the same file can access the class internal state. It’s a deliberate choice, and having this level of access control may be useful. “local” would provide the currently missing real data encapsulation from anything outside the class (including its extensions).<br></p><p>&gt; On Jan 24, 2016, at 9:54 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 24, 2016, at 1:15 PM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I think it&#39;s possible to believe that your feature would be useful<br>&gt;&gt;&gt; without also believing there&#39;s something fundamentally wrong with the<br>&gt;&gt;&gt; current model, and your arguments make it sound to me like you think<br>&gt;&gt;&gt; you&#39;re getting a lot more certainty from C++&#39;s &quot;private&quot; than you<br>&gt;&gt;&gt; actually are.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Data encapsulation is a cornerstone of object oriented programming. Swift has classes, and yet it is impossible to completely hide state / implementation details inside the class. Moreover, it’s impossible to express that something is intended to be completely hidden. Since such a fundamental idea is not supported, there is something fundamentally wrong with the current model. Swift is already a great language, and this issue aside, it’s by far the best language I’ve used. In all other areas Swift does a great job to help the programmer write correct code. This is one weird and very noticeable deviation.<br>&gt; <br>&gt; Data encapsulation is indeed one of the cornerstone of OO, but every design decision is a trade-off. Is Python not object-oriented because they lack a private keyword, and have the convention of marking internal items with a leading underscore?<br>&gt; <br>&gt; In addition, it is not possible to completely hide state/implementation details in any language (at least that I have experience with). Java, for instance, will let me use the security manager and RTTI to modify private values, and even has JNI code to modify final values as well (this is how System.out works). There are projects that fundamentally depend on being able to access private fields, such as Spring, partly because the Java standard library tells them to (@Injectable).<br>&gt; <br>&gt; Even with a “perfect” language mechanism, consumers of the binary will still patch it if they need to in order to get the functionality they want.<br>&gt; <br>&gt; The best anyone can do is make the breaking of encapsulation an explicit choice. I’m intuiting that you think that writing code into the file where the class was defined is not explicit enough. I feel comfortable saying to my team members that you have to justify adding code next to a class in the same way you would need to justify changing the implementation of that class. The difference between ‘local’ and ‘private’ access is a copy/paste of a function from an extension into the class body within the same file.<br>&gt; <br>&gt; -DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/490f599d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>access control</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 25, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 25, 2016, at 4:47 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Data encapsulation is indeed one of the cornerstone of OO, but every design decision is a trade-off. Is Python not object-oriented because they lack a private keyword, and have the convention of marking internal items with a leading underscore?<br>&gt; <br>&gt; <br>&gt; Then Python has the same problem. A language that *supports* OOP should not leave such an important part of OOP to coding by convention. <br></p><p>I think this where you are being lead astray. A language does not need to have strict access controls in order to be considered OO. Languages like C#, Java, and to some extent, C++ tend to make people think this. You don’t even need “classes” to do OO either.<br></p><p>&gt;&gt; The best anyone can do is make the breaking of encapsulation an explicit choice. I’m intuiting that you think that writing code into the file where the class was defined is not explicit enough.<br>&gt; <br>&gt; Right now, it’s impossible to make the distinction: is something truly private or can be used safely in the same file? The language has no way of expressing it. The class internal state is not encapsulated outside the bounds of the class.<br></p><p>This really seems like an academic problem vs a pragmatic problem. There’s also no concept of “friend” in Swift either, which is another construct that would have be invented to allow the “private” things to be used by others elsewhere. <br></p><p>-David<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 25, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; A language does not need to have strict access controls in order to be considered OO. <br></p><p>This is a matter of terminology. It still doesn’t change the fact that data encapsulation is a fundamental feature of object oriented programming that is currently not supported.<br></p><p>&gt; You don’t even need “classes” to do OO either.<br></p><p>In this terminology C is also object oriented. You can have opaque pointers to structs with functions around them. Swift current support for data encapsulation is exactly like that. But people don’t do this kind of programming in C precisely because the compiler can provide a lot more help than this.<br></p><p>&gt; This really seems like an academic problem vs a pragmatic problem. <br></p><p><br>It’s very pragmatic. With properly marked access level and well designed interfaces, the class implementor may rely on the compiler to ensure that the class invariants / internal state will not become corrupt. Without it, the code is much more likely to break due to human error. It’s the same reasoning as with having ARC rather than doing manual retain / release and having destructors that are called automatically instead of calling cleanup code manually.<br></p><p>&gt;  There’s also no concept of “friend” in Swift either<br></p><p>file based access level is a good solution for this. But it’s not a solution at all for real data encapsulation.<br></p><p>&gt; On Jan 25, 2016, at 12:09 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 25, 2016, at 4:47 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Data encapsulation is indeed one of the cornerstone of OO, but every design decision is a trade-off. Is Python not object-oriented because they lack a private keyword, and have the convention of marking internal items with a leading underscore?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Then Python has the same problem. A language that *supports* OOP should not leave such an important part of OOP to coding by convention. <br>&gt; <br>&gt; I think this where you are being lead astray. A language does not need to have strict access controls in order to be considered OO. Languages like C#, Java, and to some extent, C++ tend to make people think this. You don’t even need “classes” to do OO either.<br>&gt; <br>&gt;&gt;&gt; The best anyone can do is make the breaking of encapsulation an explicit choice. I’m intuiting that you think that writing code into the file where the class was defined is not explicit enough.<br>&gt;&gt; <br>&gt;&gt; Right now, it’s impossible to make the distinction: is something truly private or can be used safely in the same file? The language has no way of expressing it. The class internal state is not encapsulated outside the bounds of the class.<br>&gt; <br>&gt; This really seems like an academic problem vs a pragmatic problem. There’s also no concept of “friend” in Swift either, which is another construct that would have be invented to allow the “private” things to be used by others elsewhere. <br>&gt; <br>&gt; -David<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>access control</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 25, 2016 at 01:00:00pm</p></header><div class="content"><p>There would be no difference at all between local and private if you had one class per file. It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br></p><p>Félix<br></p><p>&gt; Le 25 janv. 2016 à 13:16:45, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; A language does not need to have strict access controls in order to be considered OO. <br>&gt; <br>&gt; This is a matter of terminology. It still doesn’t change the fact that data encapsulation is a fundamental feature of object oriented programming that is currently not supported.<br>&gt; <br>&gt;&gt; You don’t even need “classes” to do OO either.<br>&gt; <br>&gt; In this terminology C is also object oriented. You can have opaque pointers to structs with functions around them. Swift current support for data encapsulation is exactly like that. But people don’t do this kind of programming in C precisely because the compiler can provide a lot more help than this.<br>&gt; <br>&gt;&gt; This really seems like an academic problem vs a pragmatic problem. <br>&gt; <br>&gt; <br>&gt; It’s very pragmatic. With properly marked access level and well designed interfaces, the class implementor may rely on the compiler to ensure that the class invariants / internal state will not become corrupt. Without it, the code is much more likely to break due to human error. It’s the same reasoning as with having ARC rather than doing manual retain / release and having destructors that are called automatically instead of calling cleanup code manually.<br>&gt; <br>&gt;&gt; There’s also no concept of “friend” in Swift either<br>&gt; <br>&gt; file based access level is a good solution for this. But it’s not a solution at all for real data encapsulation.<br>&gt; <br>&gt;&gt; On Jan 25, 2016, at 12:09 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 25, 2016, at 4:47 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Data encapsulation is indeed one of the cornerstone of OO, but every design decision is a trade-off. Is Python not object-oriented because they lack a private keyword, and have the convention of marking internal items with a leading underscore?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then Python has the same problem. A language that *supports* OOP should not leave such an important part of OOP to coding by convention. <br>&gt;&gt; <br>&gt;&gt; I think this where you are being lead astray. A language does not need to have strict access controls in order to be considered OO. Languages like C#, Java, and to some extent, C++ tend to make people think this. You don’t even need “classes” to do OO either.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; The best anyone can do is make the breaking of encapsulation an explicit choice. I’m intuiting that you think that writing code into the file where the class was defined is not explicit enough.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right now, it’s impossible to make the distinction: is something truly private or can be used safely in the same file? The language has no way of expressing it. The class internal state is not encapsulated outside the bounds of the class.<br>&gt;&gt; <br>&gt;&gt; This really seems like an academic problem vs a pragmatic problem. There’s also no concept of “friend” in Swift either, which is another construct that would have be invented to allow the “private” things to be used by others elsewhere. <br>&gt;&gt; <br>&gt;&gt; -David<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/767a255a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 25, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; There would be no difference at all between local and private if you had one class per file.<br></p><p>AND if this rule was enforced by the compiler. This would also have to be one extension per file, even if it’s one line of code.<br></p><p>Since this rule is not enforced, at most, this is coding by convention. By the same reasoning, we could have just one type, object, and name every variable by including the type name we want it to be. No need for a strong type system. And anyone insisting that we need a type system would surely be wrong because there would be a very simple solution — just make the type name part of the variable name. And yet, Swift does have a strong type system. It should have strong access control for the very same reason: the compiler can enforce it and eliminate lots of human errors.<br></p><p>&gt; It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br></p><p>And yet both statements are true: it is possible to break the class invariant right now without modifying the class source code, and “local” would solve that problem.<br></p><p>&gt; On Jan 25, 2016, at 1:43 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; There would be no difference at all between local and private if you had one class per file. It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 25 janv. 2016 à 13:16:45, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; A language does not need to have strict access controls in order to be considered OO. <br>&gt;&gt; <br>&gt;&gt; This is a matter of terminology. It still doesn’t change the fact that data encapsulation is a fundamental feature of object oriented programming that is currently not supported.<br>&gt;&gt; <br>&gt;&gt;&gt; You don’t even need “classes” to do OO either.<br>&gt;&gt; <br>&gt;&gt; In this terminology C is also object oriented. You can have opaque pointers to structs with functions around them. Swift current support for data encapsulation is exactly like that. But people don’t do this kind of programming in C precisely because the compiler can provide a lot more help than this.<br>&gt;&gt; <br>&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It’s very pragmatic. With properly marked access level and well designed interfaces, the class implementor may rely on the compiler to ensure that the class invariants / internal state will not become corrupt. Without it, the code is much more likely to break due to human error. It’s the same reasoning as with having ARC rather than doing manual retain / release and having destructors that are called automatically instead of calling cleanup code manually.<br>&gt;&gt; <br>&gt;&gt;&gt; There’s also no concept of “friend” in Swift either<br>&gt;&gt; <br>&gt;&gt; file based access level is a good solution for this. But it’s not a solution at all for real data encapsulation.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 25, 2016, at 12:09 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 25, 2016, at 4:47 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Data encapsulation is indeed one of the cornerstone of OO, but every design decision is a trade-off. Is Python not object-oriented because they lack a private keyword, and have the convention of marking internal items with a leading underscore?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Then Python has the same problem. A language that *supports* OOP should not leave such an important part of OOP to coding by convention. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this where you are being lead astray. A language does not need to have strict access controls in order to be considered OO. Languages like C#, Java, and to some extent, C++ tend to make people think this. You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The best anyone can do is make the breaking of encapsulation an explicit choice. I’m intuiting that you think that writing code into the file where the class was defined is not explicit enough.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right now, it’s impossible to make the distinction: is something truly private or can be used safely in the same file? The language has no way of expressing it. The class internal state is not encapsulated outside the bounds of the class.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. There’s also no concept of “friend” in Swift either, which is another construct that would have be invented to allow the “private” things to be used by others elsewhere. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -David<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/cac6b468/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>access control</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>January 25, 2016 at 07:00:00pm</p></header><div class="content"><p>That is difficult to disagree with. Similar points made for static typing can be made for this.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 25 Jan 2016, at 19:33, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; There would be no difference at all between local and private if you had one class per file.<br>&gt; <br>&gt; AND if this rule was enforced by the compiler. This would also have to be one extension per file, even if it’s one line of code.<br>&gt; <br>&gt; Since this rule is not enforced, at most, this is coding by convention. By the same reasoning, we could have just one type, object, and name every variable by including the type name we want it to be. No need for a strong type system. And anyone insisting that we need a type system would surely be wrong because there would be a very simple solution — just make the type name part of the variable name. And yet, Swift does have a strong type system. It should have strong access control for the very same reason: the compiler can enforce it and eliminate lots of human errors.<br>&gt; <br>&gt;&gt; It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt; <br>&gt; And yet both statements are true: it is possible to break the class invariant right now without modifying the class source code, and “local” would solve that problem.<br>&gt; <br>&gt;&gt; On Jan 25, 2016, at 1:43 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There would be no difference at all between local and private if you had one class per file. It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 25 janv. 2016 à 13:16:45, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A language does not need to have strict access controls in order to be considered OO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a matter of terminology. It still doesn’t change the fact that data encapsulation is a fundamental feature of object oriented programming that is currently not supported.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this terminology C is also object oriented. You can have opaque pointers to structs with functions around them. Swift current support for data encapsulation is exactly like that. But people don’t do this kind of programming in C precisely because the compiler can provide a lot more help than this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s very pragmatic. With properly marked access level and well designed interfaces, the class implementor may rely on the compiler to ensure that the class invariants / internal state will not become corrupt. Without it, the code is much more likely to break due to human error. It’s the same reasoning as with having ARC rather than doing manual retain / release and having destructors that are called automatically instead of calling cleanup code manually.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There’s also no concept of “friend” in Swift either<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; file based access level is a good solution for this. But it’s not a solution at all for real data encapsulation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 12:09 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 4:47 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Data encapsulation is indeed one of the cornerstone of OO, but every design decision is a trade-off. Is Python not object-oriented because they lack a private keyword, and have the convention of marking internal items with a leading underscore?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Then Python has the same problem. A language that *supports* OOP should not leave such an important part of OOP to coding by convention.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think this where you are being lead astray. A language does not need to have strict access controls in order to be considered OO. Languages like C#, Java, and to some extent, C++ tend to make people think this. You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The best anyone can do is make the breaking of encapsulation an explicit choice. I’m intuiting that you think that writing code into the file where the class was defined is not explicit enough.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Right now, it’s impossible to make the distinction: is something truly private or can be used safely in the same file? The language has no way of expressing it. The class internal state is not encapsulated outside the bounds of the class.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. There’s also no concept of “friend” in Swift either, which is another construct that would have be invented to allow the “private” things to be used by others elsewhere. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/4945481a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>access control</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 25, 2016 at 03:00:00pm</p></header><div class="content"><p>I don&#39;t understand your conception of encapsulation. The way you&#39;re putting it, because of Swift&#39;s access modifiers, encapsulation is relative to whether you have access to the original source or not. However, this is trivially true in any condition and whether Swift promoted a &quot;private&quot; or &quot;local&quot; access modifier would change nothing to it.<br></p><p>In my opinion, this solution will be confusing to a lot of people, and the problem that it solves is many orders of magnitude less important than strong typing. A &quot;local&quot; access modifier is not a breakthrough solution that will make it substantially easier to statically reason about programs to make them faster, provide refactoring tools, or help editing. It&#39;s a design tool intended for humans only, and it&#39;s extremely ambiguous with private.<br></p><p>A new programmer makes a class and asks you if fields and methods should be private or local. What do you tell him?<br></p><p>Félix<br></p><p>&gt; Le 25 janv. 2016 à 14:33:18, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; a écrit :<br>&gt; <br>&gt;&gt; There would be no difference at all between local and private if you had one class per file.<br>&gt; <br>&gt; AND if this rule was enforced by the compiler. This would also have to be one extension per file, even if it’s one line of code.<br>&gt; <br>&gt; Since this rule is not enforced, at most, this is coding by convention. By the same reasoning, we could have just one type, object, and name every variable by including the type name we want it to be. No need for a strong type system. And anyone insisting that we need a type system would surely be wrong because there would be a very simple solution — just make the type name part of the variable name. And yet, Swift does have a strong type system. It should have strong access control for the very same reason: the compiler can enforce it and eliminate lots of human errors.<br>&gt; <br>&gt;&gt; It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt; <br>&gt; And yet both statements are true: it is possible to break the class invariant right now without modifying the class source code, and “local” would solve that problem.<br>&gt; <br>&gt;&gt; On Jan 25, 2016, at 1:43 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There would be no difference at all between local and private if you had one class per file. It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 25 janv. 2016 à 13:16:45, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A language does not need to have strict access controls in order to be considered OO. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a matter of terminology. It still doesn’t change the fact that data encapsulation is a fundamental feature of object oriented programming that is currently not supported.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this terminology C is also object oriented. You can have opaque pointers to structs with functions around them. Swift current support for data encapsulation is exactly like that. But people don’t do this kind of programming in C precisely because the compiler can provide a lot more help than this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s very pragmatic. With properly marked access level and well designed interfaces, the class implementor may rely on the compiler to ensure that the class invariants / internal state will not become corrupt. Without it, the code is much more likely to break due to human error. It’s the same reasoning as with having ARC rather than doing manual retain / release and having destructors that are called automatically instead of calling cleanup code manually.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There’s also no concept of “friend” in Swift either<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; file based access level is a good solution for this. But it’s not a solution at all for real data encapsulation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 25, 2016, at 12:09 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 4:47 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Data encapsulation is indeed one of the cornerstone of OO, but every design decision is a trade-off. Is Python not object-oriented because they lack a private keyword, and have the convention of marking internal items with a leading underscore?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Then Python has the same problem. A language that *supports* OOP should not leave such an important part of OOP to coding by convention. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think this where you are being lead astray. A language does not need to have strict access controls in order to be considered OO. Languages like C#, Java, and to some extent, C++ tend to make people think this. You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The best anyone can do is make the breaking of encapsulation an explicit choice. I’m intuiting that you think that writing code into the file where the class was defined is not explicit enough.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Right now, it’s impossible to make the distinction: is something truly private or can be used safely in the same file? The language has no way of expressing it. The class internal state is not encapsulated outside the bounds of the class.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. There’s also no concept of “friend” in Swift either, which is another construct that would have be invented to allow the “private” things to be used by others elsewhere. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/0d7bc7ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 25, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; I don&#39;t understand your conception of encapsulation. The way you&#39;re putting it, because of Swift&#39;s access modifiers, encapsulation is relative to whether you have access to the original source or not. <br></p><p>It’s not *my* conception of encapsulation. There is only one: a class provides a public interface, and the internal state can be accessed only through that public interface. The only way to get to the private state is to modify the class itself. This is not the case with Swift — any code in the same file as the class can get access to the internal state and potentially break it.<br></p><p>&gt;  The way you&#39;re putting it, because of Swift&#39;s access modifiers, encapsulation is relative to whether you have access to the original source or not. However, this is trivially true in any condition and whether Swift promoted a &quot;private&quot; or &quot;local&quot; access modifier would change nothing to it.<br></p><p>The difference is that with “local” you must change the class definition itself, and the change is very visible. With “private”, as long as the change is in the same file, the caller could accidentally (or deliberately) call an API that is meant to be private and break the object internal state.<br></p><p>&gt; In my opinion, this solution will be confusing to a lot of people<br></p><p>That may be only because of unfortunate names for these access modifiers. What is now called “private” should really be “file internal” or something like that. And “local” should be “private”. But that name is already taken. Another alternative is to do the automatic renaming, but I didn’t want to overload the proposal with that. If this is the only issue, it can be solved very easily.<br></p><p>&gt; the problem that it solves is many orders of magnitude less important than strong typing<br></p><p><br>This is a matter of opinion. I think that it’s just as important, but it should be many orders of magnitude easier to implement.<br></p><p>&gt; A &quot;local&quot; access modifier is not a breakthrough solution that will make it substantially easier to statically reason about programs to make them faster, provide refactoring tools, or help editing.<br></p><p>Not a breakthrough at all — it’s a basic feature that any language that supports OOP should have. But it does make it substantially easier to eliminate human error due to accidental misuse of APIs that are intended to be completely hidden and today cannot be.<br></p><p>&gt; It&#39;s a design tool intended for humans only, and it&#39;s extremely ambiguous with private.<br></p><p>It’s a tool for both humans and the compiler. Humans can clearly see the author’s intent, and the compiler can enforce it.<br></p><p>It’s not ambiguous at all: “private’ (really should be “file internal”) is to hide visibility in the same file. “local” is to hide it inside the class (or extension). The only ambiguous part is the naming. The original name (“private”) is unfortunate. I’d be happy to change it, but I am not sure if it’s possible at this point.<br></p><p>&gt; A new programmer makes a class and asks you if fields and methods should be private or local. What do you tell him?<br></p><p>local, of course. Only the public class API should be exposed to the outside world. “private” is a trade-off, similar to “friend” in C++. Unless that trade-off is necessary, there is no need to use “private” the way it is today (if we had “local”).<br></p><p>&gt; On Jan 25, 2016, at 3:26 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; I don&#39;t understand your conception of encapsulation. The way you&#39;re putting it, because of Swift&#39;s access modifiers, encapsulation is relative to whether you have access to the original source or not. However, this is trivially true in any condition and whether Swift promoted a &quot;private&quot; or &quot;local&quot; access modifier would change nothing to it.<br>&gt; <br>&gt; In my opinion, this solution will be confusing to a lot of people, and the problem that it solves is many orders of magnitude less important than strong typing. A &quot;local&quot; access modifier is not a breakthrough solution that will make it substantially easier to statically reason about programs to make them faster, provide refactoring tools, or help editing. It&#39;s a design tool intended for humans only, and it&#39;s extremely ambiguous with private.<br>&gt; <br>&gt; A new programmer makes a class and asks you if fields and methods should be private or local. What do you tell him?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 25 janv. 2016 à 14:33:18, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com &lt;mailto:ilya.belenkiy at gmail.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; There would be no difference at all between local and private if you had one class per file.<br>&gt;&gt; <br>&gt;&gt; AND if this rule was enforced by the compiler. This would also have to be one extension per file, even if it’s one line of code.<br>&gt;&gt; <br>&gt;&gt; Since this rule is not enforced, at most, this is coding by convention. By the same reasoning, we could have just one type, object, and name every variable by including the type name we want it to be. No need for a strong type system. And anyone insisting that we need a type system would surely be wrong because there would be a very simple solution — just make the type name part of the variable name. And yet, Swift does have a strong type system. It should have strong access control for the very same reason: the compiler can enforce it and eliminate lots of human errors.<br>&gt;&gt; <br>&gt;&gt;&gt; It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt;&gt; <br>&gt;&gt; And yet both statements are true: it is possible to break the class invariant right now without modifying the class source code, and “local” would solve that problem.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 25, 2016, at 1:43 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There would be no difference at all between local and private if you had one class per file. It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 25 janv. 2016 à 13:16:45, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A language does not need to have strict access controls in order to be considered OO. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a matter of terminology. It still doesn’t change the fact that data encapsulation is a fundamental feature of object oriented programming that is currently not supported.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this terminology C is also object oriented. You can have opaque pointers to structs with functions around them. Swift current support for data encapsulation is exactly like that. But people don’t do this kind of programming in C precisely because the compiler can provide a lot more help than this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s very pragmatic. With properly marked access level and well designed interfaces, the class implementor may rely on the compiler to ensure that the class invariants / internal state will not become corrupt. Without it, the code is much more likely to break due to human error. It’s the same reasoning as with having ARC rather than doing manual retain / release and having destructors that are called automatically instead of calling cleanup code manually.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There’s also no concept of “friend” in Swift either<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; file based access level is a good solution for this. But it’s not a solution at all for real data encapsulation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 12:09 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 4:47 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Data encapsulation is indeed one of the cornerstone of OO, but every design decision is a trade-off. Is Python not object-oriented because they lack a private keyword, and have the convention of marking internal items with a leading underscore?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Then Python has the same problem. A language that *supports* OOP should not leave such an important part of OOP to coding by convention. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think this where you are being lead astray. A language does not need to have strict access controls in order to be considered OO. Languages like C#, Java, and to some extent, C++ tend to make people think this. You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The best anyone can do is make the breaking of encapsulation an explicit choice. I’m intuiting that you think that writing code into the file where the class was defined is not explicit enough.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Right now, it’s impossible to make the distinction: is something truly private or can be used safely in the same file? The language has no way of expressing it. The class internal state is not encapsulated outside the bounds of the class.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. There’s also no concept of “friend” in Swift either, which is another construct that would have be invented to allow the “private” things to be used by others elsewhere. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/fb232f81/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>access control</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 25, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Am 25.01.2016 um 20:33 schrieb Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; There would be no difference at all between local and private if you had one class per file.<br>&gt; <br>&gt; AND if this rule was enforced by the compiler. This would also have to be one extension per file, even if it’s one line of code.<br></p><p>Why should the compiler enforce this? That’s my design decision.<br>For the same reason the compiler does not enforce where I have to put „private“ (it can make suggestions like many IDEs do and offer fix-its, like „this method can be made private as it is not used outside the class“ or „this class can be put into its own file as its private methods are not used by other components in this file“.<br></p><p><br>&gt; Since this rule is not enforced, at most, this is coding by convention. By the same reasoning, we could have just one type, object, and name every variable by including the type name we want it to be. No need for a strong type system. And anyone insisting that we need a type system would surely be wrong because there would be a very simple solution — just make the type name part of the variable name.<br></p><p>No, there is a clear difference: making the type name part of the variable name enforces no compiler checks whereas putting something into different files does. <br></p><p><br>&gt; And yet, Swift does have a strong type system. It should have strong access control for the very same reason: the compiler can enforce it and eliminate lots of human errors.<br>&gt; <br>&gt;&gt; It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt; <br>&gt; And yet both statements are true: it is possible to break the class invariant right now without modifying the class source code, and “local” would solve that problem.<br></p><p>But you need to modify the file. With „local“ it is possible to break the class invariant without modifying the source code of a private method just by adding some public methods that call the private ones. Seems quite the same to me.<br></p><p>That being said I have nothing against a „local“ access modifier but I personally don’t see a real need for it. I would wish for a better name, though...<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt;&gt; On Jan 25, 2016, at 1:43 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There would be no difference at all between local and private if you had one class per file. It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 25 janv. 2016 à 13:16:45, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A language does not need to have strict access controls in order to be considered OO. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a matter of terminology. It still doesn’t change the fact that data encapsulation is a fundamental feature of object oriented programming that is currently not supported.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this terminology C is also object oriented. You can have opaque pointers to structs with functions around them. Swift current support for data encapsulation is exactly like that. But people don’t do this kind of programming in C precisely because the compiler can provide a lot more help than this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s very pragmatic. With properly marked access level and well designed interfaces, the class implementor may rely on the compiler to ensure that the class invariants / internal state will not become corrupt. Without it, the code is much more likely to break due to human error. It’s the same reasoning as with having ARC rather than doing manual retain / release and having destructors that are called automatically instead of calling cleanup code manually.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There’s also no concept of “friend” in Swift either<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; file based access level is a good solution for this. But it’s not a solution at all for real data encapsulation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 25, 2016, at 12:09 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 4:47 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Data encapsulation is indeed one of the cornerstone of OO, but every design decision is a trade-off. Is Python not object-oriented because they lack a private keyword, and have the convention of marking internal items with a leading underscore?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Then Python has the same problem. A language that *supports* OOP should not leave such an important part of OOP to coding by convention. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think this where you are being lead astray. A language does not need to have strict access controls in order to be considered OO. Languages like C#, Java, and to some extent, C++ tend to make people think this. You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The best anyone can do is make the breaking of encapsulation an explicit choice. I’m intuiting that you think that writing code into the file where the class was defined is not explicit enough.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Right now, it’s impossible to make the distinction: is something truly private or can be used safely in the same file? The language has no way of expressing it. The class internal state is not encapsulated outside the bounds of the class.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. There’s also no concept of “friend” in Swift either, which is another construct that would have be invented to allow the “private” things to be used by others elsewhere. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/6146cf7d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 25, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Why should the compiler enforce this? That’s my design decision.<br></p><p><br>It would enforce whatever design decision you make.<br></p><p>&gt; For the same reason the compiler does not enforce where I have to put „private“ (it can make suggestions like many IDEs do and offer fix-its, like „this method can be made private as it is not used outside the class“ or „this class can be put into its own file as its private methods are not used by other components in this file“.<br></p><p>But once you do put it, it enforces it, and that’s the whole point of having access control.<br></p><p>&gt; No, there is a clear difference: making the type name part of the variable name enforces no compiler checks whereas putting something into different files does. <br></p><p>Similarly, putting all of the source code in the same file is equivalent to no checks.<br></p><p>&gt; But you need to modify the file. With „local“ it is possible to break the class invariant without modifying the source code of a private method just by adding some public methods that call the private ones. Seems quite the same to me.<br></p><p>No because then you change the class definition itself.<br></p><p>&gt;  I would wish for a better name, though…<br></p><p>Me too. I wish “private” was “file internal” and “local” could be “private”. But the right name is already taken.<br></p><p>&gt; On Jan 25, 2016, at 4:44 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 25.01.2016 um 20:33 schrieb Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; There would be no difference at all between local and private if you had one class per file.<br>&gt;&gt; <br>&gt;&gt; AND if this rule was enforced by the compiler. This would also have to be one extension per file, even if it’s one line of code.<br>&gt; <br>&gt; Why should the compiler enforce this? That’s my design decision.<br>&gt; For the same reason the compiler does not enforce where I have to put „private“ (it can make suggestions like many IDEs do and offer fix-its, like „this method can be made private as it is not used outside the class“ or „this class can be put into its own file as its private methods are not used by other components in this file“.<br>&gt; <br>&gt; <br>&gt;&gt; Since this rule is not enforced, at most, this is coding by convention. By the same reasoning, we could have just one type, object, and name every variable by including the type name we want it to be. No need for a strong type system. And anyone insisting that we need a type system would surely be wrong because there would be a very simple solution — just make the type name part of the variable name. <br>&gt; <br>&gt; No, there is a clear difference: making the type name part of the variable name enforces no compiler checks whereas putting something into different files does. <br>&gt; <br>&gt; <br>&gt;&gt; And yet, Swift does have a strong type system. It should have strong access control for the very same reason: the compiler can enforce it and eliminate lots of human errors.<br>&gt;&gt; <br>&gt;&gt;&gt; It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt;&gt; <br>&gt;&gt; And yet both statements are true: it is possible to break the class invariant right now without modifying the class source code, and “local” would solve that problem.<br>&gt; <br>&gt; But you need to modify the file. With „local“ it is possible to break the class invariant without modifying the source code of a private method just by adding some public methods that call the private ones. Seems quite the same to me.<br>&gt; <br>&gt; That being said I have nothing against a „local“ access modifier but I personally don’t see a real need for it. I would wish for a better name, though...<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 25, 2016, at 1:43 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There would be no difference at all between local and private if you had one class per file. It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 25 janv. 2016 à 13:16:45, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A language does not need to have strict access controls in order to be considered OO. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a matter of terminology. It still doesn’t change the fact that data encapsulation is a fundamental feature of object oriented programming that is currently not supported.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this terminology C is also object oriented. You can have opaque pointers to structs with functions around them. Swift current support for data encapsulation is exactly like that. But people don’t do this kind of programming in C precisely because the compiler can provide a lot more help than this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s very pragmatic. With properly marked access level and well designed interfaces, the class implementor may rely on the compiler to ensure that the class invariants / internal state will not become corrupt. Without it, the code is much more likely to break due to human error. It’s the same reasoning as with having ARC rather than doing manual retain / release and having destructors that are called automatically instead of calling cleanup code manually.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There’s also no concept of “friend” in Swift either<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; file based access level is a good solution for this. But it’s not a solution at all for real data encapsulation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 12:09 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 4:47 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Data encapsulation is indeed one of the cornerstone of OO, but every design decision is a trade-off. Is Python not object-oriented because they lack a private keyword, and have the convention of marking internal items with a leading underscore?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Then Python has the same problem. A language that *supports* OOP should not leave such an important part of OOP to coding by convention. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think this where you are being lead astray. A language does not need to have strict access controls in order to be considered OO. Languages like C#, Java, and to some extent, C++ tend to make people think this. You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The best anyone can do is make the breaking of encapsulation an explicit choice. I’m intuiting that you think that writing code into the file where the class was defined is not explicit enough.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Right now, it’s impossible to make the distinction: is something truly private or can be used safely in the same file? The language has no way of expressing it. The class internal state is not encapsulated outside the bounds of the class.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. There’s also no concept of “friend” in Swift either, which is another construct that would have be invented to allow the “private” things to be used by others elsewhere. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/1354090c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b8fbb69a582e03b56bd4c125aef9e3f?s=50"></div><header><strong>access control</strong> from <string>Haravikk</string> &lt;e-mail at haravikk.me&gt;<p>January 25, 2016 at 10:00:00pm</p></header><div class="content"><p>Just to add my thoughts to this increasingly convoluted thread, but while I agree that the way that private works right now is fine for most purposes, I would also like to see a Java style protected option as well for many of the reasons mentioned, but most importantly that it allows me to define an abstract or sub-classable type in one file, and have it sub-classed elsewhere without having to expose internal, sub-class only, methods to everything else.<br></p><p>That said, in Swift the ability to put actual code in extensions largely eliminates the need for abstract classes, which cuts down on quite a lot of necessary sub-classing, at least in my experience. But still, private isn’t ideal for keep sub-class only methods hidden; keeping stuff like that hidden is nice purely from a clutter/auto-complete perspective, let alone the requirement it puts on teams to have a naming convention for sub-class oriented methods.<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 2475 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/51084b08/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>access control</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 25, 2016 at 04:00:00pm</p></header><div class="content"><p>Let&#39;s please keep &quot;protected&quot; on a separate thread. Adding &quot;protected&quot; and adding &quot;local&quot; are pretty much completely orthogonal.<br></p><p>Jordan<br></p><p><br>&gt; On Jan 25, 2016, at 14:19, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Just to add my thoughts to this increasingly convoluted thread, but while I agree that the way that private works right now is fine for most purposes, I would also like to see a Java style protected option as well for many of the reasons mentioned, but most importantly that it allows me to define an abstract or sub-classable type in one file, and have it sub-classed elsewhere without having to expose internal, sub-class only, methods to everything else.<br>&gt; <br>&gt; That said, in Swift the ability to put actual code in extensions largely eliminates the need for abstract classes, which cuts down on quite a lot of necessary sub-classing, at least in my experience. But still, private isn’t ideal for keep sub-class only methods hidden; keeping stuff like that hidden is nice purely from a clutter/auto-complete perspective, let alone the requirement it puts on teams to have a naming convention for sub-class oriented methods._______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>access control</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 27, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Am 25.01.2016 um 23:03 schrieb Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;:<br>&gt; <br>&gt;&gt; Why should the compiler enforce this? That’s my design decision.<br>&gt; <br>&gt; <br>&gt; It would enforce whatever design decision you make.<br></p><p>It does enforce my design decision. If I decide to put several things into the same file this is a design decision stating that I want them being able to access their private members and other code outside of this file to not being able to do that. This is enforced.<br>Conversely if I don&#39;t want shared access, I put them into different files. Both design decisions are supported by the compiler.<br></p><p>&gt;&gt; For the same reason the compiler does not enforce where I have to put „private“ (it can make suggestions like many IDEs do and offer fix-its, like „this method can be made private as it is not used outside the class“ or „this class can be put into its own file as its private methods are not used by other components in this file“.<br>&gt; <br>&gt; But once you do put it, it enforces it, and that’s the whole point of having access control.<br></p><p>Exactly and the compiler does support and enforce my decisions.<br></p><p>&gt;&gt; No, there is a clear difference: making the type name part of the variable name enforces no compiler checks whereas putting something into different files does. <br>&gt; <br>&gt; Similarly, putting all of the source code in the same file is equivalent to no checks.<br></p><p>No, that&#39;s the equivalent to not putting type information in the variable name.<br>In you naming example there is no difference, as nothing is enforced.<br>With putting things in different files the compiler enforces that private access is not possible. Just like I intended. If I put them into the same file I&#39;m stating that private access is allowed, so there is nothing to enforce. <br></p><p>&gt;&gt; But you need to modify the file. With „local“ it is possible to break the class invariant without modifying the source code of a private method just by adding some public methods that call the private ones. Seems quite the same to me.<br>&gt; <br>&gt; No because then you change the class definition itself.<br></p><p>You are changing code within the boundary of your (intended) access control. No difference there.<br></p><p>-Thorsten<br></p><p><br>&gt;&gt;  I would wish for a better name, though…<br>&gt; <br>&gt; Me too. I wish “private” was “file internal” and “local” could be “private”. But the right name is already taken.<br>&gt; <br>&gt;&gt;&gt; On Jan 25, 2016, at 4:44 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 25.01.2016 um 20:33 schrieb Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There would be no difference at all between local and private if you had one class per file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; AND if this rule was enforced by the compiler. This would also have to be one extension per file, even if it’s one line of code.<br>&gt;&gt; <br>&gt;&gt; Why should the compiler enforce this? That’s my design decision.<br>&gt;&gt; For the same reason the compiler does not enforce where I have to put „private“ (it can make suggestions like many IDEs do and offer fix-its, like „this method can be made private as it is not used outside the class“ or „this class can be put into its own file as its private methods are not used by other components in this file“.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Since this rule is not enforced, at most, this is coding by convention. By the same reasoning, we could have just one type, object, and name every variable by including the type name we want it to be. No need for a strong type system. And anyone insisting that we need a type system would surely be wrong because there would be a very simple solution — just make the type name part of the variable name. <br>&gt;&gt; <br>&gt;&gt; No, there is a clear difference: making the type name part of the variable name enforces no compiler checks whereas putting something into different files does. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; And yet, Swift does have a strong type system. It should have strong access control for the very same reason: the compiler can enforce it and eliminate lots of human errors.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And yet both statements are true: it is possible to break the class invariant right now without modifying the class source code, and “local” would solve that problem.<br>&gt;&gt; <br>&gt;&gt; But you need to modify the file. With „local“ it is possible to break the class invariant without modifying the source code of a private method just by adding some public methods that call the private ones. Seems quite the same to me.<br>&gt;&gt; <br>&gt;&gt; That being said I have nothing against a „local“ access modifier but I personally don’t see a real need for it. I would wish for a better name, though...<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 25, 2016, at 1:43 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There would be no difference at all between local and private if you had one class per file. It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 25 janv. 2016 à 13:16:45, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A language does not need to have strict access controls in order to be considered OO. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is a matter of terminology. It still doesn’t change the fact that data encapsulation is a fundamental feature of object oriented programming that is currently not supported.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In this terminology C is also object oriented. You can have opaque pointers to structs with functions around them. Swift current support for data encapsulation is exactly like that. But people don’t do this kind of programming in C precisely because the compiler can provide a lot more help than this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It’s very pragmatic. With properly marked access level and well designed interfaces, the class implementor may rely on the compiler to ensure that the class invariants / internal state will not become corrupt. Without it, the code is much more likely to break due to human error. It’s the same reasoning as with having ARC rather than doing manual retain / release and having destructors that are called automatically instead of calling cleanup code manually.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There’s also no concept of “friend” in Swift either<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; file based access level is a good solution for this. But it’s not a solution at all for real data encapsulation.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 12:09 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 4:47 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Data encapsulation is indeed one of the cornerstone of OO, but every design decision is a trade-off. Is Python not object-oriented because they lack a private keyword, and have the convention of marking internal items with a leading underscore?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Then Python has the same problem. A language that *supports* OOP should not leave such an important part of OOP to coding by convention. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think this where you are being lead astray. A language does not need to have strict access controls in order to be considered OO. Languages like C#, Java, and to some extent, C++ tend to make people think this. You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The best anyone can do is make the breaking of encapsulation an explicit choice. I’m intuiting that you think that writing code into the file where the class was defined is not explicit enough.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right now, it’s impossible to make the distinction: is something truly private or can be used safely in the same file? The language has no way of expressing it. The class internal state is not encapsulated outside the bounds of the class.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. There’s also no concept of “friend” in Swift either, which is another construct that would have be invented to allow the “private” things to be used by others elsewhere. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/750c430a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 9:36 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Am 25.01.2016 um 23:03 schrieb Ilya Belenkiy &lt;ilya.belenkiy at gmail.com &lt;mailto:ilya.belenkiy at gmail.com&gt;&gt;:<br>&gt; <br>&gt;&gt;&gt; Why should the compiler enforce this? That’s my design decision.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It would enforce whatever design decision you make.<br>&gt; <br>&gt; It does enforce my design decision. If I decide to put several things into the same file this is a design decision stating that I want them being able to access their private members and other code outside of this file to not being able to do that. This is enforced.<br>&gt; Conversely if I don&#39;t want shared access, I put them into different files. Both design decisions are supported by the compiler.<br></p><p>What if we want shared access for some members but not others?  It is not possible to express this or have the compiler enforce it today.  <br></p><p>Aside from that, as has been noted several times, the most common need is “current scope only”.  It would be nice if that could actually be expressed in the language.  There are often valid reasons to organize code such that more than one scope exists in the same file without a desire to share implementation details between the scopes.  Right now there is a tension between code layout and the visibility semantics we actually desire and intend.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt;&gt;&gt; For the same reason the compiler does not enforce where I have to put „private“ (it can make suggestions like many IDEs do and offer fix-its, like „this method can be made private as it is not used outside the class“ or „this class can be put into its own file as its private methods are not used by other components in this file“.<br>&gt;&gt; <br>&gt;&gt; But once you do put it, it enforces it, and that’s the whole point of having access control.<br>&gt; <br>&gt; Exactly and the compiler does support and enforce my decisions.<br>&gt; <br>&gt;&gt;&gt; No, there is a clear difference: making the type name part of the variable name enforces no compiler checks whereas putting something into different files does. <br>&gt;&gt; <br>&gt;&gt; Similarly, putting all of the source code in the same file is equivalent to no checks.<br>&gt; <br>&gt; No, that&#39;s the equivalent to not putting type information in the variable name.<br>&gt; In you naming example there is no difference, as nothing is enforced.<br>&gt; With putting things in different files the compiler enforces that private access is not possible. Just like I intended. If I put them into the same file I&#39;m stating that private access is allowed, so there is nothing to enforce. <br>&gt; <br>&gt;&gt;&gt; But you need to modify the file. With „local“ it is possible to break the class invariant without modifying the source code of a private method just by adding some public methods that call the private ones. Seems quite the same to me.<br>&gt;&gt; <br>&gt;&gt; No because then you change the class definition itself.<br>&gt; <br>&gt; You are changing code within the boundary of your (intended) access control. No difference there.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt;&gt;  I would wish for a better name, though…<br>&gt;&gt; <br>&gt;&gt; Me too. I wish “private” was “file internal” and “local” could be “private”. But the right name is already taken.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 25, 2016, at 4:44 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 25.01.2016 um 20:33 schrieb Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There would be no difference at all between local and private if you had one class per file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; AND if this rule was enforced by the compiler. This would also have to be one extension per file, even if it’s one line of code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why should the compiler enforce this? That’s my design decision.<br>&gt;&gt;&gt; For the same reason the compiler does not enforce where I have to put „private“ (it can make suggestions like many IDEs do and offer fix-its, like „this method can be made private as it is not used outside the class“ or „this class can be put into its own file as its private methods are not used by other components in this file“.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since this rule is not enforced, at most, this is coding by convention. By the same reasoning, we could have just one type, object, and name every variable by including the type name we want it to be. No need for a strong type system. And anyone insisting that we need a type system would surely be wrong because there would be a very simple solution — just make the type name part of the variable name. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, there is a clear difference: making the type name part of the variable name enforces no compiler checks whereas putting something into different files does. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And yet, Swift does have a strong type system. It should have strong access control for the very same reason: the compiler can enforce it and eliminate lots of human errors.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And yet both statements are true: it is possible to break the class invariant right now without modifying the class source code, and “local” would solve that problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But you need to modify the file. With „local“ it is possible to break the class invariant without modifying the source code of a private method just by adding some public methods that call the private ones. Seems quite the same to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That being said I have nothing against a „local“ access modifier but I personally don’t see a real need for it. I would wish for a better name, though...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 1:43 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There would be no difference at all between local and private if you had one class per file. It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 25 janv. 2016 à 13:16:45, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; A language does not need to have strict access controls in order to be considered OO. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is a matter of terminology. It still doesn’t change the fact that data encapsulation is a fundamental feature of object oriented programming that is currently not supported.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In this terminology C is also object oriented. You can have opaque pointers to structs with functions around them. Swift current support for data encapsulation is exactly like that. But people don’t do this kind of programming in C precisely because the compiler can provide a lot more help than this.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It’s very pragmatic. With properly marked access level and well designed interfaces, the class implementor may rely on the compiler to ensure that the class invariants / internal state will not become corrupt. Without it, the code is much more likely to break due to human error. It’s the same reasoning as with having ARC rather than doing manual retain / release and having destructors that are called automatically instead of calling cleanup code manually.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There’s also no concept of “friend” in Swift either<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; file based access level is a good solution for this. But it’s not a solution at all for real data encapsulation.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 12:09 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 4:47 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Data encapsulation is indeed one of the cornerstone of OO, but every design decision is a trade-off. Is Python not object-oriented because they lack a private keyword, and have the convention of marking internal items with a leading underscore?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Then Python has the same problem. A language that *supports* OOP should not leave such an important part of OOP to coding by convention. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think this where you are being lead astray. A language does not need to have strict access controls in order to be considered OO. Languages like C#, Java, and to some extent, C++ tend to make people think this. You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The best anyone can do is make the breaking of encapsulation an explicit choice. I’m intuiting that you think that writing code into the file where the class was defined is not explicit enough.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right now, it’s impossible to make the distinction: is something truly private or can be used safely in the same file? The language has no way of expressing it. The class internal state is not encapsulated outside the bounds of the class.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. There’s also no concept of “friend” in Swift either, which is another construct that would have be invented to allow the “private” things to be used by others elsewhere. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/4fcf749c/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 25, 2016 at 04:00:00pm</p></header><div class="content"><p>I want to try and offer a concrete example of the usefulness of this idea in real code.  I had a look through the popular Alamofire library.  Every use of `private` in that library could actually use `local` instead if it existed.  <br></p><p>In some cases these would be equivalent because there is only one type / scope in the file anyway.  However, in most cases they actually do communicate something different.  There are a few ways this is possible:<br></p><p>In some cases, this is because there is a nested type involved and the `private` members are inside the nested type.  They should not be visible outside the scope of the nested type.  <br></p><p>In other cases, there are extensions of other types.  These extensions add methods that are closely related to the primary type / extension involved in the file.  The private members of the type <br></p><p>One other case that didn’t appear in Alamofire, but I have seen elsewhere is a case where you conform several types to the same protocol (usually a simple protocol) in the same file.  In this case there may be helper methods that support the protocol implementation but should not be visible to the other implementations of the protocol that are in the same file.<br></p><p>It seems like “current scope” is probably the most frequent intent of `private`, while `file` is actually less commonly necessary, but is certainly the right thing in some cases (and is much better than `friend`).<br></p><p>I agree with Ilya that it would probably be better if `private` was actually scope-based.  Rather than `internal` we could have `module` and `file` access modifiers to make it clear when there is broader visibility and make it clear exactly what that visibility is.  This would be my preference and I think it would provide the most clarity.<br></p><p>On the other hand, changing the meaning of `private` is probably not going to happen at this point (or would at least likely receive even more pushback than `local`), thus the proposal to add a new modifier and not change the meaning of existing modifiers.<br></p><p>I suggest those who are pushing back on this look through some real-world code.  How often do you actually need the file-level visibility of a `private` member?  This is likely only needed in a significant minority of uses of `private`. <br></p><p>Saying what you mean and meaning what you say adds clarity to the code.  It helps readers and future maintainers of the code understand the thinking of the author.  Right now, we do not have the ability to say what we actually mean with regards to access control in a significant number of cases.   It is the inability to express the most frequent intent of `private` that Ilya’s proposal is attempting to address (while not taking away the necessary ability to share visibility within a file in some cases).  <br></p><p>-Matthew<br></p><p><br>&gt; On Jan 25, 2016, at 3:44 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 25.01.2016 um 20:33 schrieb Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; There would be no difference at all between local and private if you had one class per file.<br>&gt;&gt; <br>&gt;&gt; AND if this rule was enforced by the compiler. This would also have to be one extension per file, even if it’s one line of code.<br>&gt; <br>&gt; Why should the compiler enforce this? That’s my design decision.<br>&gt; For the same reason the compiler does not enforce where I have to put „private“ (it can make suggestions like many IDEs do and offer fix-its, like „this method can be made private as it is not used outside the class“ or „this class can be put into its own file as its private methods are not used by other components in this file“.<br>&gt; <br>&gt; <br>&gt;&gt; Since this rule is not enforced, at most, this is coding by convention. By the same reasoning, we could have just one type, object, and name every variable by including the type name we want it to be. No need for a strong type system. And anyone insisting that we need a type system would surely be wrong because there would be a very simple solution — just make the type name part of the variable name.<br>&gt; <br>&gt; No, there is a clear difference: making the type name part of the variable name enforces no compiler checks whereas putting something into different files does. <br>&gt; <br>&gt; <br>&gt;&gt; And yet, Swift does have a strong type system. It should have strong access control for the very same reason: the compiler can enforce it and eliminate lots of human errors.<br>&gt;&gt; <br>&gt;&gt;&gt; It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt;&gt; <br>&gt;&gt; And yet both statements are true: it is possible to break the class invariant right now without modifying the class source code, and “local” would solve that problem.<br>&gt; <br>&gt; But you need to modify the file. With „local“ it is possible to break the class invariant without modifying the source code of a private method just by adding some public methods that call the private ones. Seems quite the same to me.<br>&gt; <br>&gt; That being said I have nothing against a „local“ access modifier but I personally don’t see a real need for it. I would wish for a better name, though...<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 25, 2016, at 1:43 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There would be no difference at all between local and private if you had one class per file. It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 25 janv. 2016 à 13:16:45, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A language does not need to have strict access controls in order to be considered OO. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a matter of terminology. It still doesn’t change the fact that data encapsulation is a fundamental feature of object oriented programming that is currently not supported.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this terminology C is also object oriented. You can have opaque pointers to structs with functions around them. Swift current support for data encapsulation is exactly like that. But people don’t do this kind of programming in C precisely because the compiler can provide a lot more help than this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s very pragmatic. With properly marked access level and well designed interfaces, the class implementor may rely on the compiler to ensure that the class invariants / internal state will not become corrupt. Without it, the code is much more likely to break due to human error. It’s the same reasoning as with having ARC rather than doing manual retain / release and having destructors that are called automatically instead of calling cleanup code manually.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There’s also no concept of “friend” in Swift either<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; file based access level is a good solution for this. But it’s not a solution at all for real data encapsulation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 12:09 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 4:47 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Data encapsulation is indeed one of the cornerstone of OO, but every design decision is a trade-off. Is Python not object-oriented because they lack a private keyword, and have the convention of marking internal items with a leading underscore?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Then Python has the same problem. A language that *supports* OOP should not leave such an important part of OOP to coding by convention. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think this where you are being lead astray. A language does not need to have strict access controls in order to be considered OO. Languages like C#, Java, and to some extent, C++ tend to make people think this. You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The best anyone can do is make the breaking of encapsulation an explicit choice. I’m intuiting that you think that writing code into the file where the class was defined is not explicit enough.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Right now, it’s impossible to make the distinction: is something truly private or can be used safely in the same file? The language has no way of expressing it. The class internal state is not encapsulated outside the bounds of the class.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. There’s also no concept of “friend” in Swift either, which is another construct that would have be invented to allow the “private” things to be used by others elsewhere. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/788e5cc2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>access control</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>January 26, 2016 at 12:00:00am</p></header><div class="content"><p>I feel the discussion is starting to get a bit circular :) At this point, think it is important to try to discover additional benefits of both solutions rather then reiterating the same arguments, so I think that Matthew is going the right direction by trying to bring practical aspects of the issue into the view. So far, the presented arguments were mostly ideological. As far as I understand it, Ilya’s point is based around a very rigorous notion of encapsulation (which I personally disagree with, but it doesn’t matter) and the necessity to enforce the design invariants. The definition scope access here aids as a safeguard that separates the public and the private interface. This is obviously an important feature and the reasoning is principally valid. On the other side, the opponents argue that such separation is barely useful on practice, because a single file in a well designed code is usually restricted to a few closely related declarations, so the chance to mix up the private and the public interface is actually pretty slim.  And the private interface is invisible outside the file level, so the large scale aspect of this issue never becomes valid. There is undoubtedly some truth in this as well. Personally, I would be ok with either, but I am more tending towards the view that definition scope access is unnecessary. Let me present some arguments:<br></p><p>1. It only solves a small subset of a larger problem. If we really give were to stress the importance of enforced design invariants that much, then definition scope access is actually not enough. What we really need is a permission system, where we describe the exact usage of a member, e.g. this method can be only called from that one or this method can’t be called if the state is like this etc. In the end, unless we have built-in means to prove our code, invariants need to be tested with tests and assertions — and these should catch any misuse of private APIs.<br></p><p>2. The problem it solves is arguably barely worth mentioning. How often do you have to add principally new types to a file with other declarations? How often is it easy to confuse private and public interfaces? It is really such a common thing to accidentally misuse an API and do not notice it? Usually, I would not bring any substantial functionality into a source file written by others without first gaining basic understanding about the other contents of that file. And also, usually, if I am about to bring any substantial functionality into a source file written by others, I do it because I understand what is going on there and I just want to improve/enhance something. For instance (to bring some anecdotic evidence into play), I am mainly working with a language that lacks any access declarations whatsoever (R), and I never really had an issue with this. And I am often employing techniques which involve metaprogramming and on-the-fly replacement of definition scopes, so its fairly complex stuff.  It is usually very clear which functionality is meant to be private and which is meant to be public, and to be honest, I quite frequently find myself accusing the private one for a number of reasons (usually efficiency and performance). <br></p><p>3. It assumes that the designer gets the design correct on the first try. How do you know whether you should declare a property local or private? Maybe you start as local (default) but at some point realise that it would be useful to open it up to other scopes for efficiency/other reasons? Especially in the initial design phase, there is a lot of moving around. Redeclaring invariants is not without effort, even though this is a very minor criticism point. Just wanted to mention it for the sake of completeness (of what came into my mind).<br></p><p>4. It hinders competent extenders. Imagine you understand the code really well. You want to add a new auxiliary public function, and it would be much more efficient if you accessed the private interface directly. However, the original designer did not anticipate your use case, so they declared that interface local. So you’d need to go and change the modifiers to private, which is kind of unnecessary effort. <br></p><p>To sum it up, I believe that restricting access like that gives you a sense of false security. It is not really likely to prevent bugs from happening, but it does limit the extendability of the code. The issues it aims to solved can be easily solved by minimal degree of coding discipline (such as: do not go changing around stuff in a file unless you understand what you are doing) and I doubt that experienced programmers are likely to encounter these issues very frequently (I know I never did, and I wouldn’t even call myself that experienced). Code testing should be performed by debug assertions and unit tests, which will easily detect any relevant case of API misuse. In the end, I believe that definition scope restricts mostly for ideological, but not practical reasons, given the coding style most appropriate with Swift. <br></p><p>Can we add a definition scope access to Swift? Sure, it won’t change much. Will we benefit from this change? I doubt so. The current system is good enough and its quite elegant in allowing one to implement tightly related functionality. <br></p><p>Finally some comments on Matthew’s post<br></p><p>&gt; In some cases, this is because there is a nested type involved and the `private` members are inside the nested type.  They should not be visible outside the scope of the nested type.  <br></p><p><br>But sometimes, if one wants to extend functionality or improve efficiency, and know what they are doing, having access to these private members could be beneficial. If they should not be visible outside of the scope in the first place, the person who implements the container type probably knows it and is unlikely to access them directly<br></p><p>&gt; One other case that didn’t appear in Alamofire, but I have seen elsewhere is a case where you conform several types to the same protocol (usually a simple protocol) in the same file.  In this case there may be helper methods that support the protocol implementation but should not be visible to the other implementations of the protocol that are in the same file.<br></p><p><br>How likely is one to call one of those helper methods in actual code? I don’t see any potential for confusion at all. Unless you are working on a type that extents the type with the private method, but it doesn’t seem to be your example<br></p><p>&gt; It seems like “current scope” is probably the most frequent intent of `private`<br></p><p>That is undoubtedly true. However, the question should be put the other way: how frequently does the file scope obscure, obfuscate or otherwise denies this frequent use?<br></p><p>&gt; I suggest those who are pushing back on this look through some real-world code.  How often do you actually need the file-level visibility of a `private` member?  This is likely only needed in a significant minority of uses of `private`. <br></p><p><br>Personally, I use it quite often because of the way I like to design things as groups of tightly interdependent components (friends, if you want) who are aware of each other’s inner workings. I also want to have full access to the interface of any project I work on because I trust myself to make the judgement whether I am allowed to use a particular functionality or not. Definition scope restricts me without giving me any benefit I can immediately recognise. <br></p><p>Best, <br></p><p> Taras<br></p><p><br>&gt; On 25 Jan 2016, at 23:16, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I want to try and offer a concrete example of the usefulness of this idea in real code.  I had a look through the popular Alamofire library.  Every use of `private` in that library could actually use `local` instead if it existed.  <br>&gt; <br>&gt; In some cases these would be equivalent because there is only one type / scope in the file anyway.  However, in most cases they actually do communicate something different.  There are a few ways this is possible:<br>&gt; <br>&gt; In some cases, this is because there is a nested type involved and the `private` members are inside the nested type.  They should not be visible outside the scope of the nested type.  <br>&gt; <br>&gt; In other cases, there are extensions of other types.  These extensions add methods that are closely related to the primary type / extension involved in the file.  The private members of the type <br>&gt; <br>&gt; One other case that didn’t appear in Alamofire, but I have seen elsewhere is a case where you conform several types to the same protocol (usually a simple protocol) in the same file.  In this case there may be helper methods that support the protocol implementation but should not be visible to the other implementations of the protocol that are in the same file.<br>&gt; <br>&gt; It seems like “current scope” is probably the most frequent intent of `private`, while `file` is actually less commonly necessary, but is certainly the right thing in some cases (and is much better than `friend`).<br>&gt; <br>&gt; I agree with Ilya that it would probably be better if `private` was actually scope-based.  Rather than `internal` we could have `module` and `file` access modifiers to make it clear when there is broader visibility and make it clear exactly what that visibility is.  This would be my preference and I think it would provide the most clarity.<br>&gt; <br>&gt; On the other hand, changing the meaning of `private` is probably not going to happen at this point (or would at least likely receive even more pushback than `local`), thus the proposal to add a new modifier and not change the meaning of existing modifiers.<br>&gt; <br>&gt; I suggest those who are pushing back on this look through some real-world code.  How often do you actually need the file-level visibility of a `private` member?  This is likely only needed in a significant minority of uses of `private`. <br>&gt; <br>&gt; Saying what you mean and meaning what you say adds clarity to the code.  It helps readers and future maintainers of the code understand the thinking of the author.  Right now, we do not have the ability to say what we actually mean with regards to access control in a significant number of cases.   It is the inability to express the most frequent intent of `private` that Ilya’s proposal is attempting to address (while not taking away the necessary ability to share visibility within a file in some cases).  <br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 25, 2016, at 3:44 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 25.01.2016 um 20:33 schrieb Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There would be no difference at all between local and private if you had one class per file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; AND if this rule was enforced by the compiler. This would also have to be one extension per file, even if it’s one line of code.<br>&gt;&gt; <br>&gt;&gt; Why should the compiler enforce this? That’s my design decision.<br>&gt;&gt; For the same reason the compiler does not enforce where I have to put „private“ (it can make suggestions like many IDEs do and offer fix-its, like „this method can be made private as it is not used outside the class“ or „this class can be put into its own file as its private methods are not used by other components in this file“.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Since this rule is not enforced, at most, this is coding by convention. By the same reasoning, we could have just one type, object, and name every variable by including the type name we want it to be. No need for a strong type system. And anyone insisting that we need a type system would surely be wrong because there would be a very simple solution — just make the type name part of the variable name.<br>&gt;&gt; <br>&gt;&gt; No, there is a clear difference: making the type name part of the variable name enforces no compiler checks whereas putting something into different files does. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; And yet, Swift does have a strong type system. It should have strong access control for the very same reason: the compiler can enforce it and eliminate lots of human errors.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And yet both statements are true: it is possible to break the class invariant right now without modifying the class source code, and “local” would solve that problem.<br>&gt;&gt; <br>&gt;&gt; But you need to modify the file. With „local“ it is possible to break the class invariant without modifying the source code of a private method just by adding some public methods that call the private ones. Seems quite the same to me.<br>&gt;&gt; <br>&gt;&gt; That being said I have nothing against a „local“ access modifier but I personally don’t see a real need for it. I would wish for a better name, though...<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 25, 2016, at 1:43 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There would be no difference at all between local and private if you had one class per file. It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 25 janv. 2016 à 13:16:45, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A language does not need to have strict access controls in order to be considered OO. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is a matter of terminology. It still doesn’t change the fact that data encapsulation is a fundamental feature of object oriented programming that is currently not supported.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In this terminology C is also object oriented. You can have opaque pointers to structs with functions around them. Swift current support for data encapsulation is exactly like that. But people don’t do this kind of programming in C precisely because the compiler can provide a lot more help than this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It’s very pragmatic. With properly marked access level and well designed interfaces, the class implementor may rely on the compiler to ensure that the class invariants / internal state will not become corrupt. Without it, the code is much more likely to break due to human error. It’s the same reasoning as with having ARC rather than doing manual retain / release and having destructors that are called automatically instead of calling cleanup code manually.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There’s also no concept of “friend” in Swift either<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; file based access level is a good solution for this. But it’s not a solution at all for real data encapsulation.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 12:09 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 4:47 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Data encapsulation is indeed one of the cornerstone of OO, but every design decision is a trade-off. Is Python not object-oriented because they lack a private keyword, and have the convention of marking internal items with a leading underscore?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Then Python has the same problem. A language that *supports* OOP should not leave such an important part of OOP to coding by convention. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think this where you are being lead astray. A language does not need to have strict access controls in order to be considered OO. Languages like C#, Java, and to some extent, C++ tend to make people think this. You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The best anyone can do is make the breaking of encapsulation an explicit choice. I’m intuiting that you think that writing code into the file where the class was defined is not explicit enough.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right now, it’s impossible to make the distinction: is something truly private or can be used safely in the same file? The language has no way of expressing it. The class internal state is not encapsulated outside the bounds of the class.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. There’s also no concept of “friend” in Swift either, which is another construct that would have be invented to allow the “private” things to be used by others elsewhere. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/a8174107/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 25, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 25, 2016, at 5:40 PM, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt; <br>&gt; I feel the discussion is starting to get a bit circular :) At this point, think it is important to try to discover additional benefits of both solutions rather then reiterating the same arguments, so I think that Matthew is going the right direction by trying to bring practical aspects of the issue into the view. So far, the presented arguments were mostly ideological. As far as I understand it, Ilya’s point is based around a very rigorous notion of encapsulation (which I personally disagree with, but it doesn’t matter) and the necessity to enforce the design invariants. The definition scope access here aids as a safeguard that separates the public and the private interface. This is obviously an important feature and the reasoning is principally valid. On the other side, the opponents argue that such separation is barely useful on practice, because a single file in a well designed code is usually restricted to a few closely related declarations, so the chance to mix up the private and the public interface is actually pretty slim.  And the private interface is invisible outside the file level, so the large scale aspect of this issue never becomes valid. There is undoubtedly some truth in this as well. Personally, I would be ok with either, but I am more tending towards the view that definition scope access is unnecessary. Let me present some arguments:<br>&gt; <br>&gt; 1. It only solves a small subset of a larger problem. If we really give were to stress the importance of enforced design invariants that much, then definition scope access is actually not enough. What we really need is a permission system, where we describe the exact usage of a member, e.g. this method can be only called from that one or this method can’t be called if the state is like this etc. In the end, unless we have built-in means to prove our code, invariants need to be tested with tests and assertions — and these should catch any misuse of private APIs.<br></p><p>Something like this is overkill.  It gets really complex really fast to cover a minority of situations.  What Ilya is proposing is simple and covers the majority of cases. <br></p><p>&gt; <br>&gt; 2. The problem it solves is arguably barely worth mentioning. How often do you have to add principally new types to a file with other declarations?<br></p><p>It is actually going to be pretty common in Swift to have members that should not reasonably accessed outside of their defining scope, while other scopes do exist in the same file.  This is what I found in Alamofire.  I chose that as an example of a popular and respected Swift code base that we all have access to.  The pattern I found there holds in other code as well.<br></p><p>&gt; How often is it easy to confuse private and public interfaces? It is really such a common thing to accidentally misuse an API and do not notice it?<br></p><p>More important than preventing misuse is making intent and use clear.  When I was looking through the Alamofire code I could “guess” that the `private` members were only accessed in the defining scope, but couldn’t know for sure until I searched their names throughout the file.  It is helpful to know immediately the scope of possible use when reading code as it simplifies your mental model of the code.<br></p><p>&gt; Usually, I would not bring any substantial functionality into a source file written by others without first gaining basic understanding about the other contents of that file. And also, usually, if I am about to bring any substantial functionality into a source file written by others, I do it because I understand what is going on there and I just want to improve/enhance something. For instance (to bring some anecdotic evidence into play), I am mainly working with a language that lacks any access declarations whatsoever (R), and I never really had an issue with this. And I am often employing techniques which involve metaprogramming and on-the-fly replacement of definition scopes, so its fairly complex stuff.  It is usually very clear which functionality is meant to be private and which is meant to be public, and to be honest, I quite frequently find myself accusing the private one for a number of reasons (usually efficiency and performance). <br>&gt; <br>&gt; 3. It assumes that the designer gets the design correct on the first try. How do you know whether you should declare a property local or private? Maybe you start as local (default) but at some point realise that it would be useful to open it up to other scopes for efficiency/other reasons?<br></p><p>How do you know `private` is right and not `internal`?  The same concern potentially applies.  In most cases you will have a reasonable idea of what your intent is.  Of course any aspect of your code might change over time and this no exception.<br></p><p>&gt; Especially in the initial design phase, there is a lot of moving around. Redeclaring invariants is not without effort, even though this is a very minor criticism point. Just wanted to mention it for the sake of completeness (of what came into my mind).<br>&gt; <br>&gt; 4. It hinders competent extenders. Imagine you understand the code really well. You want to add a new auxiliary public function, and it would be much more efficient if you accessed the private interface directly. However, the original designer did not anticipate your use case, so they declared that interface local. So you’d need to go and change the modifiers to private, which is kind of unnecessary effort. <br></p><p>I don’t agree that it is unnecessary effort.  First, if you add the `public` method in the same scope you don’t need to do anything.  Second, if you add the `public` method anywhere other than the current file you already need to change to `internal` so there is no difference in effort.  Only when you add a `public` member somewhere outside the same scope but inside the same file will any “additional” effort be necessary.  <br></p><p>IMO it is a good thing that you need to consider what you are doing in this case.  In many cases it will be perfectly fine and you will just change the access control.  But in other cases, maybe there is more happening than you expected and you must take care in how you access the private member.  In other cases, maybe you should add the `public` member inside the same scope rather than elsewhere in the same file, leaving access control intact.  Stopping to consider these cases is not a bad thing.<br></p><p>&gt; <br>&gt; To sum it up, I believe that restricting access like that gives you a sense of false security.<br>&gt; It is not really likely to prevent bugs from happening, but it does limit the extendability of the code.<br></p><p>It doesn’t limit extendability at all.  As you noted, it is simple to increase visibility if you already have access to the file, allowing you to extend the code as you wish.<br></p><p>&gt; The issues it aims to solved can be easily solved by minimal degree of coding discipline (such as: do not go changing around stuff in a file unless you understand what you are doing) and I doubt that experienced programmers are likely to encounter these issues very frequently (I know I never did, and I wouldn’t even call myself that experienced). Code testing should be performed by debug assertions and unit tests, which will easily detect any relevant case of API misuse. In the end, I believe that definition scope restricts mostly for ideological, but not practical reasons, given the coding style most appropriate with Swift. <br>&gt; <br></p><p>I know Ilya has been emphasizing the argument around protecting invariants.  IMO the stronger argument is that the distinction between scope visibility and file visibility aids understanding of the intent and current usage of a member.  Those who take advantage of the narrower, scope-based access modifier will find it is more common than file based visibility.  They will be able to make more assumptions with certainty when reading code in their projects.  <br></p><p>I agree that this is not a game-changer, but the benefit is also not trivial at all.  It is easily significant enough to warrant a relatively simple feature addition IMO.<br></p><p>&gt; Can we add a definition scope access to Swift? Sure, it won’t change much. Will we benefit from this change? I doubt so. The current system is good enough and its quite elegant in allowing one to implement tightly related functionality. <br>&gt; <br>&gt; Finally some comments on Matthew’s post<br>&gt; <br>&gt;&gt; In some cases, this is because there is a nested type involved and the `private` members are inside the nested type.  They should not be visible outside the scope of the nested type.  <br>&gt; <br>&gt; <br>&gt; But sometimes, if one wants to extend functionality or improve efficiency, and know what they are doing, having access to these private members could be beneficial. If they should not be visible outside of the scope in the first place, the person who implements the container type probably knows it and is unlikely to access them directly<br></p><p>I don’t disagree.  But this doesn’t allow the implementer to communicate their intent to readers of the code (unless they use comments).<br></p><p>&gt; <br>&gt;&gt; One other case that didn’t appear in Alamofire, but I have seen elsewhere is a case where you conform several types to the same protocol (usually a simple protocol) in the same file.  In this case there may be helper methods that support the protocol implementation but should not be visible to the other implementations of the protocol that are in the same file.<br>&gt; <br>&gt; <br>&gt; How likely is one to call one of those helper methods in actual code? I don’t see any potential for confusion at all. Unless you are working on a type that extents the type with the private method, but it doesn’t seem to be your example<br></p><p>It isn’t likely, but the point is that a scope-based access modifier would make the intent 100% clear, without question.  There is no reason we should accept any doubt about intent when making the intent clear is a simple language enhancement that is actually the right thing in most cases (scope level visibility rather than file level visibility).<br></p><p>&gt; <br>&gt;&gt; It seems like “current scope” is probably the most frequent intent of `private`<br>&gt; <br>&gt; That is undoubtedly true. However, the question should be put the other way: how frequently does the file scope obscure, obfuscate or otherwise denies this frequent use?<br></p><p>Any time there is more than one scope there is at least some potential for this.  As mentioned, I could not be sure in several cases when reading Alamofire without searching the file.  I think the language should make it possible to specify intent clearly in the most common use case.  It simply does not do that today.<br></p><p>&gt; <br>&gt;&gt; I suggest those who are pushing back on this look through some real-world code.  How often do you actually need the file-level visibility of a `private` member?  This is likely only needed in a significant minority of uses of `private`. <br>&gt; <br>&gt; <br>&gt; Personally, I use it quite often because of the way I like to design things as groups of tightly interdependent components (friends, if you want) who are aware of each other’s inner workings.<br>&gt; I also want to have full access to the interface of any project I work on because I trust myself to make the judgement whether I am allowed to use a particular functionality or not. Definition scope restricts me without giving me any benefit I can immediately recognize. <br></p><p>Nobody is arguing that this should be the default or that you should be required to use it.  If you don’t see the benefit you would not need to use it.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; Best, <br>&gt; <br>&gt;  Taras<br>&gt; <br>&gt; <br>&gt;&gt; On 25 Jan 2016, at 23:16, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I want to try and offer a concrete example of the usefulness of this idea in real code.  I had a look through the popular Alamofire library.  Every use of `private` in that library could actually use `local` instead if it existed.  <br>&gt;&gt; <br>&gt;&gt; In some cases these would be equivalent because there is only one type / scope in the file anyway.  However, in most cases they actually do communicate something different.  There are a few ways this is possible:<br>&gt;&gt; <br>&gt;&gt; In some cases, this is because there is a nested type involved and the `private` members are inside the nested type.  They should not be visible outside the scope of the nested type.  <br>&gt;&gt; <br>&gt;&gt; In other cases, there are extensions of other types.  These extensions add methods that are closely related to the primary type / extension involved in the file.  The private members of the type <br>&gt;&gt; <br>&gt;&gt; One other case that didn’t appear in Alamofire, but I have seen elsewhere is a case where you conform several types to the same protocol (usually a simple protocol) in the same file.  In this case there may be helper methods that support the protocol implementation but should not be visible to the other implementations of the protocol that are in the same file.<br>&gt;&gt; <br>&gt;&gt; It seems like “current scope” is probably the most frequent intent of `private`, while `file` is actually less commonly necessary, but is certainly the right thing in some cases (and is much better than `friend`).<br>&gt;&gt; <br>&gt;&gt; I agree with Ilya that it would probably be better if `private` was actually scope-based.  Rather than `internal` we could have `module` and `file` access modifiers to make it clear when there is broader visibility and make it clear exactly what that visibility is.  This would be my preference and I think it would provide the most clarity.<br>&gt;&gt; <br>&gt;&gt; On the other hand, changing the meaning of `private` is probably not going to happen at this point (or would at least likely receive even more pushback than `local`), thus the proposal to add a new modifier and not change the meaning of existing modifiers.<br>&gt;&gt; <br>&gt;&gt; I suggest those who are pushing back on this look through some real-world code.  How often do you actually need the file-level visibility of a `private` member?  This is likely only needed in a significant minority of uses of `private`. <br>&gt;&gt; <br>&gt;&gt; Saying what you mean and meaning what you say adds clarity to the code.  It helps readers and future maintainers of the code understand the thinking of the author.  Right now, we do not have the ability to say what we actually mean with regards to access control in a significant number of cases.   It is the inability to express the most frequent intent of `private` that Ilya’s proposal is attempting to address (while not taking away the necessary ability to share visibility within a file in some cases).  <br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 25, 2016, at 3:44 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 25.01.2016 um 20:33 schrieb Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There would be no difference at all between local and private if you had one class per file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; AND if this rule was enforced by the compiler. This would also have to be one extension per file, even if it’s one line of code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why should the compiler enforce this? That’s my design decision.<br>&gt;&gt;&gt; For the same reason the compiler does not enforce where I have to put „private“ (it can make suggestions like many IDEs do and offer fix-its, like „this method can be made private as it is not used outside the class“ or „this class can be put into its own file as its private methods are not used by other components in this file“.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since this rule is not enforced, at most, this is coding by convention. By the same reasoning, we could have just one type, object, and name every variable by including the type name we want it to be. No need for a strong type system. And anyone insisting that we need a type system would surely be wrong because there would be a very simple solution — just make the type name part of the variable name.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, there is a clear difference: making the type name part of the variable name enforces no compiler checks whereas putting something into different files does. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And yet, Swift does have a strong type system. It should have strong access control for the very same reason: the compiler can enforce it and eliminate lots of human errors.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And yet both statements are true: it is possible to break the class invariant right now without modifying the class source code, and “local” would solve that problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But you need to modify the file. With „local“ it is possible to break the class invariant without modifying the source code of a private method just by adding some public methods that call the private ones. Seems quite the same to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That being said I have nothing against a „local“ access modifier but I personally don’t see a real need for it. I would wish for a better name, though...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 1:43 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There would be no difference at all between local and private if you had one class per file. It seems very very bold to me to say that Swift &quot;doesn&#39;t support encapsulation&quot; but that local would solve that problem.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 25 janv. 2016 à 13:16:45, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; A language does not need to have strict access controls in order to be considered OO. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is a matter of terminology. It still doesn’t change the fact that data encapsulation is a fundamental feature of object oriented programming that is currently not supported.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In this terminology C is also object oriented. You can have opaque pointers to structs with functions around them. Swift current support for data encapsulation is exactly like that. But people don’t do this kind of programming in C precisely because the compiler can provide a lot more help than this.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It’s very pragmatic. With properly marked access level and well designed interfaces, the class implementor may rely on the compiler to ensure that the class invariants / internal state will not become corrupt. Without it, the code is much more likely to break due to human error. It’s the same reasoning as with having ARC rather than doing manual retain / release and having destructors that are called automatically instead of calling cleanup code manually.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There’s also no concept of “friend” in Swift either<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; file based access level is a good solution for this. But it’s not a solution at all for real data encapsulation.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 12:09 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 4:47 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Data encapsulation is indeed one of the cornerstone of OO, but every design decision is a trade-off. Is Python not object-oriented because they lack a private keyword, and have the convention of marking internal items with a leading underscore?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Then Python has the same problem. A language that *supports* OOP should not leave such an important part of OOP to coding by convention. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think this where you are being lead astray. A language does not need to have strict access controls in order to be considered OO. Languages like C#, Java, and to some extent, C++ tend to make people think this. You don’t even need “classes” to do OO either.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The best anyone can do is make the breaking of encapsulation an explicit choice. I’m intuiting that you think that writing code into the file where the class was defined is not explicit enough.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right now, it’s impossible to make the distinction: is something truly private or can be used safely in the same file? The language has no way of expressing it. The class internal state is not encapsulated outside the bounds of the class.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This really seems like an academic problem vs a pragmatic problem. There’s also no concept of “friend” in Swift either, which is another construct that would have be invented to allow the “private” things to be used by others elsewhere. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/94250ce5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>access control</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>January 25, 2016 at 10:00:00pm</p></header><div class="content"><p>I agree with everything Matthew Johnson said in his response. In addition:<br></p><p>On Mon, Jan 25, 2016 at 5:40 PM, Taras Zakharko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Personally, I use it quite often because of the way I like to design<br>&gt; things as groups of tightly interdependent components (friends, if you<br>&gt; want) who are aware of each other’s inner workings. I also want to have<br>&gt; full access to the interface of any project I work on because I trust<br>&gt; myself to make the judgement whether I am allowed to use a particular<br>&gt; functionality or not.<br></p><p><br>By this logic, you don&#39;t want or need private (Swift&#39;s private-to-file)<br>either. You just want/need internal and public, because you trust your<br>judgement and you want access to everything in the project.<br></p><p>I trust my judgement, but I don&#39;t trust my memory. In six months, I won&#39;t<br>remember every detail of the code I wrote today. Private-to-file is a<br>message from past-me to future-me: &quot;Dear future-Rob, you don&#39;t need to<br>worry about looking for any use of this element outside this file, but if<br>you want to make it visible to other files, you better study it to make<br>sure it&#39;s safe to expose. Warmest regards, past-Rob.&quot;<br></p><p>This is a useful message. It helps jog future-Rob&#39;s memory, it saves<br>future-Rob from bugs, and it lets past-Rob rest easy because the message is<br>guaranteed to be delivered, and is guaranteed to be correct. No comment or<br>policy or convention can make that guarantee.<br></p><p>I want the ability to send another useful message: &quot;Dear future-Rob, you<br>don&#39;t need to worry about looking for any use of this element outside this<br>class, but if you want to make it visible to other classes, you better<br>study it to make sure it&#39;s safe to expose. Very truly yours, past-Rob.&quot;<br></p><p>Note that moving a private class to its own file to make its privates more<br>private does not work. Now I have to make the formerly-private class an<br>internal class, so I&#39;m not sending the first message anymore.<br></p><p>I&#39;m not arguing that Swift needs, say, Scala&#39;s level of detail in its<br>access modifiers, but I think an access modifier for private-to-class or<br>private-to-instance or private-to-scope would let past-Rob convey useful<br>information to future-Rob in a lot of places where currently the<br>information is less precise or entirely absent, and that this ability is<br>useful enough to justify the additional language complexity.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/ed6ceb55/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 26, 2016 at 08:00:00am</p></header><div class="content"><p>This a great writeup on clarity of intent. I’d like to add that in principle, if clarity of intent was the only goal, it could be achieved by a universally agreed on convention, like putting _ in front of the method or property (or type) . We could put it in guidelines and rely on it in all Swift projects. The other part that it is enforced by the compiler is equally important. The reasoning is the same as having real types instead of conventions for naming objects:<br></p><p>Imagine that the Swift compiler did nothing for types — it was just a useful way to convey the coder’s intent. Maintaining the code in this context would become much more difficult:<br></p><p>1) the compiler would not help catch mistakes.<br>2) the tools would not provide contextual auto completions or useful type related information in general<br></p><p>I am sure that everyone would be less comfortable shipping a large codebase that didn’t go through all the type checks. Exactly the same reasoning applies to “local”. If it’s just a convention that is not enforced by the compiler, we lose a very useful way to verify code correctness. In addition to that, everything that is marked as “local” (or “_” in front of the name)  now shows up in code completions and adds noise and temptation to cut corners (often this would be “faster” functions that already assume certain things about the state that may generally not be true). There are plenty of discussions about Cocoa private APIs on the web where the only thing that is stopping people is whether using them will pass the app store check (and if there is a secret back door still). That specific boundary is addressed with “internal”, but the same is true at the scale of a class.<br></p><p>&gt; On Jan 25, 2016, at 11:22 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree with everything Matthew Johnson said in his response. In addition:<br>&gt; <br>&gt; On Mon, Jan 25, 2016 at 5:40 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Personally, I use it quite often because of the way I like to design things as groups of tightly interdependent components (friends, if you want) who are aware of each other’s inner workings. I also want to have full access to the interface of any project I work on because I trust myself to make the judgement whether I am allowed to use a particular functionality or not.<br>&gt; <br>&gt; By this logic, you don&#39;t want or need private (Swift&#39;s private-to-file) either. You just want/need internal and public, because you trust your judgement and you want access to everything in the project.<br>&gt; <br>&gt; I trust my judgement, but I don&#39;t trust my memory. In six months, I won&#39;t remember every detail of the code I wrote today. Private-to-file is a message from past-me to future-me: &quot;Dear future-Rob, you don&#39;t need to worry about looking for any use of this element outside this file, but if you want to make it visible to other files, you better study it to make sure it&#39;s safe to expose. Warmest regards, past-Rob.&quot;<br>&gt; <br>&gt; This is a useful message. It helps jog future-Rob&#39;s memory, it saves future-Rob from bugs, and it lets past-Rob rest easy because the message is guaranteed to be delivered, and is guaranteed to be correct. No comment or policy or convention can make that guarantee.<br>&gt; <br>&gt; I want the ability to send another useful message: &quot;Dear future-Rob, you don&#39;t need to worry about looking for any use of this element outside this class, but if you want to make it visible to other classes, you better study it to make sure it&#39;s safe to expose. Very truly yours, past-Rob.&quot;<br>&gt; <br>&gt; Note that moving a private class to its own file to make its privates more private does not work. Now I have to make the formerly-private class an internal class, so I&#39;m not sending the first message anymore.<br>&gt; <br>&gt; I&#39;m not arguing that Swift needs, say, Scala&#39;s level of detail in its access modifiers, but I think an access modifier for private-to-class or private-to-instance or private-to-scope would let past-Rob convey useful information to future-Rob in a lot of places where currently the information is less precise or entirely absent, and that this ability is useful enough to justify the additional language complexity.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/973ee21c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>access control</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>January 26, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt; On Jan 25, 2016, at 11:22 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; By this logic, you don&#39;t want or need private (Swift&#39;s private-to-file) either. You just want/need internal and public, because you trust your judgement and you want access to everything in the project.<br></p><p>This is certainly not what I wrote. What I said is that hiding the private interface becomes a practical concern on large scale, when you deal with projects or libraries. Swift already solves that issue with per-file and per-module visibility. And when editing the narrow scope (the file), one should make sure that one knows that they are doing (not unlike what you wrote yourself). <br></p><p>&gt;&gt; I&#39;m not arguing that Swift needs, say, Scala&#39;s level of detail in its access modifiers, but I think an access modifier for private-to-class or private-to-instance or private-to-scope would let past-Rob convey useful information to future-Rob in a lot of places where currently the information is less precise or entirely absent, and that this ability is useful enough to justify the additional language complexity.<br></p><p>Oh, I quite agree with you here. But I still don’t think that declaration scope access is really necessary to achieve this (because quite honestly, the future-Taras messages are best conveyed through documentation strings :) ). See also the summary at the end of my mail. Subclass scope is a different story, because it has many practical uses, but thats a topic for another discussion. <br></p><p>&gt; On 26 Jan 2016, at 14:00, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; The reasoning is the same as having real types instead of conventions for naming objects:<br></p><p>I do not believe that your example is even remotely appropriate. These problems are on a totally different scale. You can’t seriously mean the the lack of definition scope access poses challenges that are even remotely similar to those associated with the lack of type checking. <br></p><p>&gt; There are plenty of discussions about Cocoa private APIs on the web where the only thing that is stopping people is whether using them will pass the app store check (and if there is a secret back door still). That specific boundary is addressed with “internal”, but the same is true at the scale of a class.<br></p><p>No compiler sugar will prevent people from using your internal APIs if they want to. With Objective-C this is particularly easy, due to the dynamic nature of the language. Even if Swift had the definition scope access modifier, one could get access to your private interface by reverse-engineering the memory layout of your object and accessing the state directly. The only real argument in favour of definition scope is bug prevention, and as far as I am concerned, it is a matter of opinion (I do like your point about autocompletion though). Again, as I wrote before, I am ambivalent. I don’t think that Swift will loose anything by introducing definition scope access but I also don’t think that it will gain anything. <br></p><p>At any rate, I can’t help but notice that we are going in circles here. I think that the decision should be made by the core Swift team, who should evaluate how well it fits with their vision. <br></p><p>Best, <br></p><p> Taras<br></p><p>&gt; On 26 Jan 2016, at 14:00, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This a great writeup on clarity of intent. I’d like to add that in principle, if clarity of intent was the only goal, it could be achieved by a universally agreed on convention, like putting _ in front of the method or property (or type) . We could put it in guidelines and rely on it in all Swift projects. The other part that it is enforced by the compiler is equally important. The reasoning is the same as having real types instead of conventions for naming objects:<br>&gt; <br>&gt; Imagine that the Swift compiler did nothing for types — it was just a useful way to convey the coder’s intent. Maintaining the code in this context would become much more difficult:<br>&gt; <br>&gt; 1) the compiler would not help catch mistakes.<br>&gt; 2) the tools would not provide contextual auto completions or useful type related information in general<br>&gt; <br>&gt; I am sure that everyone would be less comfortable shipping a large codebase that didn’t go through all the type checks. Exactly the same reasoning applies to “local”. If it’s just a convention that is not enforced by the compiler, we lose a very useful way to verify code correctness. In addition to that, everything that is marked as “local” (or “_” in front of the name)  now shows up in code completions and adds noise and temptation to cut corners (often this would be “faster” functions that already assume certain things about the state that may generally not be true). There are plenty of discussions about Cocoa private APIs on the web where the only thing that is stopping people is whether using them will pass the app store check (and if there is a secret back door still). That specific boundary is addressed with “internal”, but the same is true at the scale of a class.<br>&gt; <br>&gt;&gt; On Jan 25, 2016, at 11:22 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree with everything Matthew Johnson said in his response. In addition:<br>&gt;&gt; <br>&gt;&gt; On Mon, Jan 25, 2016 at 5:40 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Personally, I use it quite often because of the way I like to design things as groups of tightly interdependent components (friends, if you want) who are aware of each other’s inner workings. I also want to have full access to the interface of any project I work on because I trust myself to make the judgement whether I am allowed to use a particular functionality or not.<br>&gt;&gt; <br>&gt;&gt; By this logic, you don&#39;t want or need private (Swift&#39;s private-to-file) either. You just want/need internal and public, because you trust your judgement and you want access to everything in the project.<br>&gt;&gt; <br>&gt;&gt; I trust my judgement, but I don&#39;t trust my memory. In six months, I won&#39;t remember every detail of the code I wrote today. Private-to-file is a message from past-me to future-me: &quot;Dear future-Rob, you don&#39;t need to worry about looking for any use of this element outside this file, but if you want to make it visible to other files, you better study it to make sure it&#39;s safe to expose. Warmest regards, past-Rob.&quot;<br>&gt;&gt; <br>&gt;&gt; This is a useful message. It helps jog future-Rob&#39;s memory, it saves future-Rob from bugs, and it lets past-Rob rest easy because the message is guaranteed to be delivered, and is guaranteed to be correct. No comment or policy or convention can make that guarantee.<br>&gt;&gt; <br>&gt;&gt; I want the ability to send another useful message: &quot;Dear future-Rob, you don&#39;t need to worry about looking for any use of this element outside this class, but if you want to make it visible to other classes, you better study it to make sure it&#39;s safe to expose. Very truly yours, past-Rob.&quot;<br>&gt;&gt; <br>&gt;&gt; Note that moving a private class to its own file to make its privates more private does not work. Now I have to make the formerly-private class an internal class, so I&#39;m not sending the first message anymore.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not arguing that Swift needs, say, Scala&#39;s level of detail in its access modifiers, but I think an access modifier for private-to-class or private-to-instance or private-to-scope would let past-Rob convey useful information to future-Rob in a lot of places where currently the information is less precise or entirely absent, and that this ability is useful enough to justify the additional language complexity.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/5436769a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 26, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jan 26, 2016, at 7:36 AM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jan 25, 2016, at 11:22 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; By this logic, you don&#39;t want or need private (Swift&#39;s private-to-file) either. You just want/need internal and public, because you trust your judgement and you want access to everything in the project.<br>&gt; <br>&gt; This is certainly not what I wrote. What I said is that hiding the private interface becomes a practical concern on large scale, when you deal with projects or libraries. Swift already solves that issue with per-file and per-module visibility. And when editing the narrow scope (the file), one should make sure that one knows that they are doing (not unlike what you wrote yourself). <br>&gt; <br>&gt;&gt;&gt; I&#39;m not arguing that Swift needs, say, Scala&#39;s level of detail in its access modifiers, but I think an access modifier for private-to-class or private-to-instance or private-to-scope would let past-Rob convey useful information to future-Rob in a lot of places where currently the information is less precise or entirely absent, and that this ability is useful enough to justify the additional language complexity.<br>&gt; <br>&gt; Oh, I quite agree with you here. But I still don’t think that declaration scope access is really necessary to achieve this (because quite honestly, the future-Taras messages are best conveyed through documentation strings :)<br></p><p>Doc strings easily become out of sync with the code.  The critical part of the “message” is that it actually aligns with the current state of the code.  This is only guaranteed if it is part of the language and enforced by the compiler.<br></p><p><br>&gt; ). See also the summary at the end of my mail. Subclass scope is a different story, because it has many practical uses, but thats a topic for another discussion. <br>&gt; <br>&gt;&gt; On 26 Jan 2016, at 14:00, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; The reasoning is the same as having real types instead of conventions for naming objects:<br>&gt; <br>&gt; I do not believe that your example is even remotely appropriate. These problems are on a totally different scale. You can’t seriously mean the the lack of definition scope access poses challenges that are even remotely similar to those associated with the lack of type checking. <br></p><p>I’ll let Ilya respond for himself.  But I agree with you.  This proposal provides orders of magnitude less value.  Nevertheless, it provides value that is significantly greater than the small increment in complexity that an additional access modifier adds to the language.<br></p><p>&gt; <br>&gt;&gt; There are plenty of discussions about Cocoa private APIs on the web where the only thing that is stopping people is whether using them will pass the app store check (and if there is a secret back door still). That specific boundary is addressed with “internal”, but the same is true at the scale of a class.<br>&gt; <br>&gt; No compiler sugar will prevent people from using your internal APIs if they want to. With Objective-C this is particularly easy, due to the dynamic nature of the language. Even if Swift had the definition scope access modifier, one could get access to your private interface by reverse-engineering the memory layout of your object and accessing the state directly. The only real argument in favour of definition scope is bug prevention, and as far as I am concerned, it is a matter of opinion (I do like your point about autocompletion though). Again, as I wrote before, I am ambivalent. I don’t think that Swift will loose anything by introducing definition scope access but I also don’t think that it will gain anything. <br>&gt; <br>&gt; At any rate, I can’t help but notice that we are going in circles here. I think that the decision should be made by the core Swift team, who should evaluate how well it fits with their vision. <br>&gt; <br>&gt; Best, <br>&gt; <br>&gt;  Taras<br>&gt; <br>&gt;&gt; On 26 Jan 2016, at 14:00, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This a great writeup on clarity of intent. I’d like to add that in principle, if clarity of intent was the only goal, it could be achieved by a universally agreed on convention, like putting _ in front of the method or property (or type) . We could put it in guidelines and rely on it in all Swift projects. The other part that it is enforced by the compiler is equally important. The reasoning is the same as having real types instead of conventions for naming objects:<br>&gt;&gt; <br>&gt;&gt; Imagine that the Swift compiler did nothing for types — it was just a useful way to convey the coder’s intent. Maintaining the code in this context would become much more difficult:<br>&gt;&gt; <br>&gt;&gt; 1) the compiler would not help catch mistakes.<br>&gt;&gt; 2) the tools would not provide contextual auto completions or useful type related information in general<br>&gt;&gt; <br>&gt;&gt; I am sure that everyone would be less comfortable shipping a large codebase that didn’t go through all the type checks. Exactly the same reasoning applies to “local”. If it’s just a convention that is not enforced by the compiler, we lose a very useful way to verify code correctness. In addition to that, everything that is marked as “local” (or “_” in front of the name)  now shows up in code completions and adds noise and temptation to cut corners (often this would be “faster” functions that already assume certain things about the state that may generally not be true). There are plenty of discussions about Cocoa private APIs on the web where the only thing that is stopping people is whether using them will pass the app store check (and if there is a secret back door still). That specific boundary is addressed with “internal”, but the same is true at the scale of a class.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 25, 2016, at 11:22 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with everything Matthew Johnson said in his response. In addition:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Jan 25, 2016 at 5:40 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Personally, I use it quite often because of the way I like to design things as groups of tightly interdependent components (friends, if you want) who are aware of each other’s inner workings. I also want to have full access to the interface of any project I work on because I trust myself to make the judgement whether I am allowed to use a particular functionality or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By this logic, you don&#39;t want or need private (Swift&#39;s private-to-file) either. You just want/need internal and public, because you trust your judgement and you want access to everything in the project.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I trust my judgement, but I don&#39;t trust my memory. In six months, I won&#39;t remember every detail of the code I wrote today. Private-to-file is a message from past-me to future-me: &quot;Dear future-Rob, you don&#39;t need to worry about looking for any use of this element outside this file, but if you want to make it visible to other files, you better study it to make sure it&#39;s safe to expose. Warmest regards, past-Rob.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a useful message. It helps jog future-Rob&#39;s memory, it saves future-Rob from bugs, and it lets past-Rob rest easy because the message is guaranteed to be delivered, and is guaranteed to be correct. No comment or policy or convention can make that guarantee.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I want the ability to send another useful message: &quot;Dear future-Rob, you don&#39;t need to worry about looking for any use of this element outside this class, but if you want to make it visible to other classes, you better study it to make sure it&#39;s safe to expose. Very truly yours, past-Rob.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that moving a private class to its own file to make its privates more private does not work. Now I have to make the formerly-private class an internal class, so I&#39;m not sending the first message anymore.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not arguing that Swift needs, say, Scala&#39;s level of detail in its access modifiers, but I think an access modifier for private-to-class or private-to-instance or private-to-scope would let past-Rob convey useful information to future-Rob in a lot of places where currently the information is less precise or entirely absent, and that this ability is useful enough to justify the additional language complexity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/8de452c6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 26, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; This is certainly not what I wrote. What I said is that hiding the private interface becomes a practical concern on large scale, when you deal with projects or libraries. Swift already solves that issue with per-file and per-module visibility. And when editing the narrow scope (the file), one should make sure that one knows that they are doing (not unlike what you wrote yourself). <br></p><p><br>Why not automate it if we can?<br></p><p>&gt; Oh, I quite agree with you here. But I still don’t think that declaration scope access is really necessary to achieve this (because quite honestly, the future-Taras messages are best conveyed through documentation strings :) ). <br></p><p>Would you remove all type checking and rely solely on the documentation to make function calls? If you wouldn’t, exactly the same reasoning applies to *where* a function can be called.<br></p><p>&gt; I do not believe that your example is even remotely appropriate. These problems are on a totally different scale. You can’t seriously mean the the lack of definition scope access poses challenges that are even remotely similar to those associated with the lack of type checking. <br></p><p>I can and I do. Data encapsulation is a cornerstone for object oriented programming for a very good reason.<br></p><p>&gt; No compiler sugar will prevent people from using your internal APIs if they want to. <br></p><p>True, but the same applies to type checking. We should have real data encapsulation for exactly the same reason.<br></p><p>&gt; At any rate, I can’t help but notice that we are going in circles here. <br></p><p>We are. I hope that my pull request with the proposal will be merged and reviewed soon. This issue has already received plenty of discussion here.<br></p><p>&gt; On Jan 26, 2016, at 8:36 AM, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jan 25, 2016, at 11:22 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; By this logic, you don&#39;t want or need private (Swift&#39;s private-to-file) either. You just want/need internal and public, because you trust your judgement and you want access to everything in the project.<br>&gt; <br>&gt; This is certainly not what I wrote. What I said is that hiding the private interface becomes a practical concern on large scale, when you deal with projects or libraries. Swift already solves that issue with per-file and per-module visibility. And when editing the narrow scope (the file), one should make sure that one knows that they are doing (not unlike what you wrote yourself). <br>&gt; <br>&gt;&gt;&gt; I&#39;m not arguing that Swift needs, say, Scala&#39;s level of detail in its access modifiers, but I think an access modifier for private-to-class or private-to-instance or private-to-scope would let past-Rob convey useful information to future-Rob in a lot of places where currently the information is less precise or entirely absent, and that this ability is useful enough to justify the additional language complexity.<br>&gt; <br>&gt; Oh, I quite agree with you here. But I still don’t think that declaration scope access is really necessary to achieve this (because quite honestly, the future-Taras messages are best conveyed through documentation strings :) ). See also the summary at the end of my mail. Subclass scope is a different story, because it has many practical uses, but thats a topic for another discussion. <br>&gt; <br>&gt;&gt; On 26 Jan 2016, at 14:00, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; The reasoning is the same as having real types instead of conventions for naming objects:<br>&gt; <br>&gt; I do not believe that your example is even remotely appropriate. These problems are on a totally different scale. You can’t seriously mean the the lack of definition scope access poses challenges that are even remotely similar to those associated with the lack of type checking. <br>&gt; <br>&gt;&gt; There are plenty of discussions about Cocoa private APIs on the web where the only thing that is stopping people is whether using them will pass the app store check (and if there is a secret back door still). That specific boundary is addressed with “internal”, but the same is true at the scale of a class.<br>&gt; <br>&gt; No compiler sugar will prevent people from using your internal APIs if they want to. With Objective-C this is particularly easy, due to the dynamic nature of the language. Even if Swift had the definition scope access modifier, one could get access to your private interface by reverse-engineering the memory layout of your object and accessing the state directly. The only real argument in favour of definition scope is bug prevention, and as far as I am concerned, it is a matter of opinion (I do like your point about autocompletion though). Again, as I wrote before, I am ambivalent. I don’t think that Swift will loose anything by introducing definition scope access but I also don’t think that it will gain anything. <br>&gt; <br>&gt; At any rate, I can’t help but notice that we are going in circles here. I think that the decision should be made by the core Swift team, who should evaluate how well it fits with their vision. <br>&gt; <br>&gt; Best, <br>&gt; <br>&gt;  Taras<br>&gt; <br>&gt;&gt; On 26 Jan 2016, at 14:00, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This a great writeup on clarity of intent. I’d like to add that in principle, if clarity of intent was the only goal, it could be achieved by a universally agreed on convention, like putting _ in front of the method or property (or type) . We could put it in guidelines and rely on it in all Swift projects. The other part that it is enforced by the compiler is equally important. The reasoning is the same as having real types instead of conventions for naming objects:<br>&gt;&gt; <br>&gt;&gt; Imagine that the Swift compiler did nothing for types — it was just a useful way to convey the coder’s intent. Maintaining the code in this context would become much more difficult:<br>&gt;&gt; <br>&gt;&gt; 1) the compiler would not help catch mistakes.<br>&gt;&gt; 2) the tools would not provide contextual auto completions or useful type related information in general<br>&gt;&gt; <br>&gt;&gt; I am sure that everyone would be less comfortable shipping a large codebase that didn’t go through all the type checks. Exactly the same reasoning applies to “local”. If it’s just a convention that is not enforced by the compiler, we lose a very useful way to verify code correctness. In addition to that, everything that is marked as “local” (or “_” in front of the name)  now shows up in code completions and adds noise and temptation to cut corners (often this would be “faster” functions that already assume certain things about the state that may generally not be true). There are plenty of discussions about Cocoa private APIs on the web where the only thing that is stopping people is whether using them will pass the app store check (and if there is a secret back door still). That specific boundary is addressed with “internal”, but the same is true at the scale of a class.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 25, 2016, at 11:22 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with everything Matthew Johnson said in his response. In addition:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Jan 25, 2016 at 5:40 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Personally, I use it quite often because of the way I like to design things as groups of tightly interdependent components (friends, if you want) who are aware of each other’s inner workings. I also want to have full access to the interface of any project I work on because I trust myself to make the judgement whether I am allowed to use a particular functionality or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By this logic, you don&#39;t want or need private (Swift&#39;s private-to-file) either. You just want/need internal and public, because you trust your judgement and you want access to everything in the project.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I trust my judgement, but I don&#39;t trust my memory. In six months, I won&#39;t remember every detail of the code I wrote today. Private-to-file is a message from past-me to future-me: &quot;Dear future-Rob, you don&#39;t need to worry about looking for any use of this element outside this file, but if you want to make it visible to other files, you better study it to make sure it&#39;s safe to expose. Warmest regards, past-Rob.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a useful message. It helps jog future-Rob&#39;s memory, it saves future-Rob from bugs, and it lets past-Rob rest easy because the message is guaranteed to be delivered, and is guaranteed to be correct. No comment or policy or convention can make that guarantee.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I want the ability to send another useful message: &quot;Dear future-Rob, you don&#39;t need to worry about looking for any use of this element outside this class, but if you want to make it visible to other classes, you better study it to make sure it&#39;s safe to expose. Very truly yours, past-Rob.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that moving a private class to its own file to make its privates more private does not work. Now I have to make the formerly-private class an internal class, so I&#39;m not sending the first message anymore.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not arguing that Swift needs, say, Scala&#39;s level of detail in its access modifiers, but I think an access modifier for private-to-class or private-to-instance or private-to-scope would let past-Rob convey useful information to future-Rob in a lot of places where currently the information is less precise or entirely absent, and that this ability is useful enough to justify the additional language complexity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/aab557e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 26, 2016 at 11:00:00am</p></header><div class="content"><p>&gt;&gt; I do not believe that your example is even remotely appropriate. These problems are on a totally different scale. You can’t seriously mean the the lack of definition scope access poses challenges that are even remotely similar to those associated with the lack of type checking. <br>&gt; <br></p><p>I’d like to add one more thing here: the whole point of having distinct types is to be able to specify what can be done with instances of those types and to enforce it. Access control is part of that — it tells what can (and cannot) be done with an instance of a particular type. It is a small part in terms of complexity involved in both specifying and enforcing types, but it’s an important part of the solution to the real problem that the type system solves: what operations are available for an instance of a type.<br></p><p>&gt; On Jan 26, 2016, at 9:29 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; This is certainly not what I wrote. What I said is that hiding the private interface becomes a practical concern on large scale, when you deal with projects or libraries. Swift already solves that issue with per-file and per-module visibility. And when editing the narrow scope (the file), one should make sure that one knows that they are doing (not unlike what you wrote yourself). <br>&gt; <br>&gt; <br>&gt; Why not automate it if we can?<br>&gt; <br>&gt;&gt; Oh, I quite agree with you here. But I still don’t think that declaration scope access is really necessary to achieve this (because quite honestly, the future-Taras messages are best conveyed through documentation strings :) ). <br>&gt; <br>&gt; Would you remove all type checking and rely solely on the documentation to make function calls? If you wouldn’t, exactly the same reasoning applies to *where* a function can be called.<br>&gt; <br>&gt;&gt; I do not believe that your example is even remotely appropriate. These problems are on a totally different scale. You can’t seriously mean the the lack of definition scope access poses challenges that are even remotely similar to those associated with the lack of type checking. <br>&gt; <br>&gt; I can and I do. Data encapsulation is a cornerstone for object oriented programming for a very good reason.<br>&gt; <br>&gt;&gt; No compiler sugar will prevent people from using your internal APIs if they want to. <br>&gt; <br>&gt; True, but the same applies to type checking. We should have real data encapsulation for exactly the same reason.<br>&gt; <br>&gt;&gt; At any rate, I can’t help but notice that we are going in circles here. <br>&gt; <br>&gt; We are. I hope that my pull request with the proposal will be merged and reviewed soon. This issue has already received plenty of discussion here.<br>&gt; <br>&gt;&gt; On Jan 26, 2016, at 8:36 AM, Taras Zakharko &lt;taras.zakharko at uzh.ch &lt;mailto:taras.zakharko at uzh.ch&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 25, 2016, at 11:22 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; By this logic, you don&#39;t want or need private (Swift&#39;s private-to-file) either. You just want/need internal and public, because you trust your judgement and you want access to everything in the project.<br>&gt;&gt; <br>&gt;&gt; This is certainly not what I wrote. What I said is that hiding the private interface becomes a practical concern on large scale, when you deal with projects or libraries. Swift already solves that issue with per-file and per-module visibility. And when editing the narrow scope (the file), one should make sure that one knows that they are doing (not unlike what you wrote yourself). <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not arguing that Swift needs, say, Scala&#39;s level of detail in its access modifiers, but I think an access modifier for private-to-class or private-to-instance or private-to-scope would let past-Rob convey useful information to future-Rob in a lot of places where currently the information is less precise or entirely absent, and that this ability is useful enough to justify the additional language complexity.<br>&gt;&gt; <br>&gt;&gt; Oh, I quite agree with you here. But I still don’t think that declaration scope access is really necessary to achieve this (because quite honestly, the future-Taras messages are best conveyed through documentation strings :) ). See also the summary at the end of my mail. Subclass scope is a different story, because it has many practical uses, but thats a topic for another discussion. <br>&gt;&gt; <br>&gt;&gt;&gt; On 26 Jan 2016, at 14:00, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; The reasoning is the same as having real types instead of conventions for naming objects:<br>&gt;&gt; <br>&gt;&gt; I do not believe that your example is even remotely appropriate. These problems are on a totally different scale. You can’t seriously mean the the lack of definition scope access poses challenges that are even remotely similar to those associated with the lack of type checking. <br>&gt;&gt; <br>&gt;&gt;&gt; There are plenty of discussions about Cocoa private APIs on the web where the only thing that is stopping people is whether using them will pass the app store check (and if there is a secret back door still). That specific boundary is addressed with “internal”, but the same is true at the scale of a class.<br>&gt;&gt; <br>&gt;&gt; No compiler sugar will prevent people from using your internal APIs if they want to. With Objective-C this is particularly easy, due to the dynamic nature of the language. Even if Swift had the definition scope access modifier, one could get access to your private interface by reverse-engineering the memory layout of your object and accessing the state directly. The only real argument in favour of definition scope is bug prevention, and as far as I am concerned, it is a matter of opinion (I do like your point about autocompletion though). Again, as I wrote before, I am ambivalent. I don’t think that Swift will loose anything by introducing definition scope access but I also don’t think that it will gain anything. <br>&gt;&gt; <br>&gt;&gt; At any rate, I can’t help but notice that we are going in circles here. I think that the decision should be made by the core Swift team, who should evaluate how well it fits with their vision. <br>&gt;&gt; <br>&gt;&gt; Best, <br>&gt;&gt; <br>&gt;&gt;  Taras<br>&gt;&gt; <br>&gt;&gt;&gt; On 26 Jan 2016, at 14:00, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This a great writeup on clarity of intent. I’d like to add that in principle, if clarity of intent was the only goal, it could be achieved by a universally agreed on convention, like putting _ in front of the method or property (or type) . We could put it in guidelines and rely on it in all Swift projects. The other part that it is enforced by the compiler is equally important. The reasoning is the same as having real types instead of conventions for naming objects:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Imagine that the Swift compiler did nothing for types — it was just a useful way to convey the coder’s intent. Maintaining the code in this context would become much more difficult:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) the compiler would not help catch mistakes.<br>&gt;&gt;&gt; 2) the tools would not provide contextual auto completions or useful type related information in general<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am sure that everyone would be less comfortable shipping a large codebase that didn’t go through all the type checks. Exactly the same reasoning applies to “local”. If it’s just a convention that is not enforced by the compiler, we lose a very useful way to verify code correctness. In addition to that, everything that is marked as “local” (or “_” in front of the name)  now shows up in code completions and adds noise and temptation to cut corners (often this would be “faster” functions that already assume certain things about the state that may generally not be true). There are plenty of discussions about Cocoa private APIs on the web where the only thing that is stopping people is whether using them will pass the app store check (and if there is a secret back door still). That specific boundary is addressed with “internal”, but the same is true at the scale of a class.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 25, 2016, at 11:22 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with everything Matthew Johnson said in his response. In addition:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Jan 25, 2016 at 5:40 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Personally, I use it quite often because of the way I like to design things as groups of tightly interdependent components (friends, if you want) who are aware of each other’s inner workings. I also want to have full access to the interface of any project I work on because I trust myself to make the judgement whether I am allowed to use a particular functionality or not.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; By this logic, you don&#39;t want or need private (Swift&#39;s private-to-file) either. You just want/need internal and public, because you trust your judgement and you want access to everything in the project.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I trust my judgement, but I don&#39;t trust my memory. In six months, I won&#39;t remember every detail of the code I wrote today. Private-to-file is a message from past-me to future-me: &quot;Dear future-Rob, you don&#39;t need to worry about looking for any use of this element outside this file, but if you want to make it visible to other files, you better study it to make sure it&#39;s safe to expose. Warmest regards, past-Rob.&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a useful message. It helps jog future-Rob&#39;s memory, it saves future-Rob from bugs, and it lets past-Rob rest easy because the message is guaranteed to be delivered, and is guaranteed to be correct. No comment or policy or convention can make that guarantee.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I want the ability to send another useful message: &quot;Dear future-Rob, you don&#39;t need to worry about looking for any use of this element outside this class, but if you want to make it visible to other classes, you better study it to make sure it&#39;s safe to expose. Very truly yours, past-Rob.&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that moving a private class to its own file to make its privates more private does not work. Now I have to make the formerly-private class an internal class, so I&#39;m not sending the first message anymore.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not arguing that Swift needs, say, Scala&#39;s level of detail in its access modifiers, but I think an access modifier for private-to-class or private-to-instance or private-to-scope would let past-Rob convey useful information to future-Rob in a lot of places where currently the information is less precise or entirely absent, and that this ability is useful enough to justify the additional language complexity.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/3e6a1550/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 27, 2016 at 07:00:00am</p></header><div class="content"><p>I am not sure who to ask, so I’ll ask here:<br></p><p>At what stage do proposals get merged into the “proposals” folder? Is there some order in which proposals get scheduled for review? My proposal was thoroughly discussed twice on this list. Is there anything else that I can do to get it scheduled for a review?<br></p><p>&gt; On Jan 26, 2016, at 9:29 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; This is certainly not what I wrote. What I said is that hiding the private interface becomes a practical concern on large scale, when you deal with projects or libraries. Swift already solves that issue with per-file and per-module visibility. And when editing the narrow scope (the file), one should make sure that one knows that they are doing (not unlike what you wrote yourself). <br>&gt; <br>&gt; <br>&gt; Why not automate it if we can?<br>&gt; <br>&gt;&gt; Oh, I quite agree with you here. But I still don’t think that declaration scope access is really necessary to achieve this (because quite honestly, the future-Taras messages are best conveyed through documentation strings :) ). <br>&gt; <br>&gt; Would you remove all type checking and rely solely on the documentation to make function calls? If you wouldn’t, exactly the same reasoning applies to *where* a function can be called.<br>&gt; <br>&gt;&gt; I do not believe that your example is even remotely appropriate. These problems are on a totally different scale. You can’t seriously mean the the lack of definition scope access poses challenges that are even remotely similar to those associated with the lack of type checking. <br>&gt; <br>&gt; I can and I do. Data encapsulation is a cornerstone for object oriented programming for a very good reason.<br>&gt; <br>&gt;&gt; No compiler sugar will prevent people from using your internal APIs if they want to. <br>&gt; <br>&gt; True, but the same applies to type checking. We should have real data encapsulation for exactly the same reason.<br>&gt; <br>&gt;&gt; At any rate, I can’t help but notice that we are going in circles here. <br>&gt; <br>&gt; We are. I hope that my pull request with the proposal will be merged and reviewed soon. This issue has already received plenty of discussion here.<br>&gt; <br>&gt;&gt; On Jan 26, 2016, at 8:36 AM, Taras Zakharko &lt;taras.zakharko at uzh.ch &lt;mailto:taras.zakharko at uzh.ch&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 25, 2016, at 11:22 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; By this logic, you don&#39;t want or need private (Swift&#39;s private-to-file) either. You just want/need internal and public, because you trust your judgement and you want access to everything in the project.<br>&gt;&gt; <br>&gt;&gt; This is certainly not what I wrote. What I said is that hiding the private interface becomes a practical concern on large scale, when you deal with projects or libraries. Swift already solves that issue with per-file and per-module visibility. And when editing the narrow scope (the file), one should make sure that one knows that they are doing (not unlike what you wrote yourself). <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not arguing that Swift needs, say, Scala&#39;s level of detail in its access modifiers, but I think an access modifier for private-to-class or private-to-instance or private-to-scope would let past-Rob convey useful information to future-Rob in a lot of places where currently the information is less precise or entirely absent, and that this ability is useful enough to justify the additional language complexity.<br>&gt;&gt; <br>&gt;&gt; Oh, I quite agree with you here. But I still don’t think that declaration scope access is really necessary to achieve this (because quite honestly, the future-Taras messages are best conveyed through documentation strings :) ). See also the summary at the end of my mail. Subclass scope is a different story, because it has many practical uses, but thats a topic for another discussion. <br>&gt;&gt; <br>&gt;&gt;&gt; On 26 Jan 2016, at 14:00, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; The reasoning is the same as having real types instead of conventions for naming objects:<br>&gt;&gt; <br>&gt;&gt; I do not believe that your example is even remotely appropriate. These problems are on a totally different scale. You can’t seriously mean the the lack of definition scope access poses challenges that are even remotely similar to those associated with the lack of type checking. <br>&gt;&gt; <br>&gt;&gt;&gt; There are plenty of discussions about Cocoa private APIs on the web where the only thing that is stopping people is whether using them will pass the app store check (and if there is a secret back door still). That specific boundary is addressed with “internal”, but the same is true at the scale of a class.<br>&gt;&gt; <br>&gt;&gt; No compiler sugar will prevent people from using your internal APIs if they want to. With Objective-C this is particularly easy, due to the dynamic nature of the language. Even if Swift had the definition scope access modifier, one could get access to your private interface by reverse-engineering the memory layout of your object and accessing the state directly. The only real argument in favour of definition scope is bug prevention, and as far as I am concerned, it is a matter of opinion (I do like your point about autocompletion though). Again, as I wrote before, I am ambivalent. I don’t think that Swift will loose anything by introducing definition scope access but I also don’t think that it will gain anything. <br>&gt;&gt; <br>&gt;&gt; At any rate, I can’t help but notice that we are going in circles here. I think that the decision should be made by the core Swift team, who should evaluate how well it fits with their vision. <br>&gt;&gt; <br>&gt;&gt; Best, <br>&gt;&gt; <br>&gt;&gt;  Taras<br>&gt;&gt; <br>&gt;&gt;&gt; On 26 Jan 2016, at 14:00, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This a great writeup on clarity of intent. I’d like to add that in principle, if clarity of intent was the only goal, it could be achieved by a universally agreed on convention, like putting _ in front of the method or property (or type) . We could put it in guidelines and rely on it in all Swift projects. The other part that it is enforced by the compiler is equally important. The reasoning is the same as having real types instead of conventions for naming objects:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Imagine that the Swift compiler did nothing for types — it was just a useful way to convey the coder’s intent. Maintaining the code in this context would become much more difficult:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) the compiler would not help catch mistakes.<br>&gt;&gt;&gt; 2) the tools would not provide contextual auto completions or useful type related information in general<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am sure that everyone would be less comfortable shipping a large codebase that didn’t go through all the type checks. Exactly the same reasoning applies to “local”. If it’s just a convention that is not enforced by the compiler, we lose a very useful way to verify code correctness. In addition to that, everything that is marked as “local” (or “_” in front of the name)  now shows up in code completions and adds noise and temptation to cut corners (often this would be “faster” functions that already assume certain things about the state that may generally not be true). There are plenty of discussions about Cocoa private APIs on the web where the only thing that is stopping people is whether using them will pass the app store check (and if there is a secret back door still). That specific boundary is addressed with “internal”, but the same is true at the scale of a class.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 25, 2016, at 11:22 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with everything Matthew Johnson said in his response. In addition:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Jan 25, 2016 at 5:40 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Personally, I use it quite often because of the way I like to design things as groups of tightly interdependent components (friends, if you want) who are aware of each other’s inner workings. I also want to have full access to the interface of any project I work on because I trust myself to make the judgement whether I am allowed to use a particular functionality or not.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; By this logic, you don&#39;t want or need private (Swift&#39;s private-to-file) either. You just want/need internal and public, because you trust your judgement and you want access to everything in the project.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I trust my judgement, but I don&#39;t trust my memory. In six months, I won&#39;t remember every detail of the code I wrote today. Private-to-file is a message from past-me to future-me: &quot;Dear future-Rob, you don&#39;t need to worry about looking for any use of this element outside this file, but if you want to make it visible to other files, you better study it to make sure it&#39;s safe to expose. Warmest regards, past-Rob.&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a useful message. It helps jog future-Rob&#39;s memory, it saves future-Rob from bugs, and it lets past-Rob rest easy because the message is guaranteed to be delivered, and is guaranteed to be correct. No comment or policy or convention can make that guarantee.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I want the ability to send another useful message: &quot;Dear future-Rob, you don&#39;t need to worry about looking for any use of this element outside this class, but if you want to make it visible to other classes, you better study it to make sure it&#39;s safe to expose. Very truly yours, past-Rob.&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that moving a private class to its own file to make its privates more private does not work. Now I have to make the formerly-private class an internal class, so I&#39;m not sending the first message anymore.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not arguing that Swift needs, say, Scala&#39;s level of detail in its access modifiers, but I think an access modifier for private-to-class or private-to-instance or private-to-scope would let past-Rob convey useful information to future-Rob in a lot of places where currently the information is less precise or entirely absent, and that this ability is useful enough to justify the additional language complexity.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/57d7919a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>access control</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 28, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 4:43 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I am not sure who to ask, so I’ll ask here:<br>&gt; <br>&gt; At what stage do proposals get merged into the “proposals” folder? Is there some order in which proposals get scheduled for review? My proposal was thoroughly discussed twice on this list. Is there anything else that I can do to get it scheduled for a review?<br></p><p>One of the core team members will get it merged today. Sorry for the delay! There is a *lot* going on in swift-evolution land.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt;&gt; On Jan 26, 2016, at 9:29 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com &lt;mailto:ilya.belenkiy at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; This is certainly not what I wrote. What I said is that hiding the private interface becomes a practical concern on large scale, when you deal with projects or libraries. Swift already solves that issue with per-file and per-module visibility. And when editing the narrow scope (the file), one should make sure that one knows that they are doing (not unlike what you wrote yourself). <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Why not automate it if we can?<br>&gt;&gt; <br>&gt;&gt;&gt; Oh, I quite agree with you here. But I still don’t think that declaration scope access is really necessary to achieve this (because quite honestly, the future-Taras messages are best conveyed through documentation strings :) ). <br>&gt;&gt; <br>&gt;&gt; Would you remove all type checking and rely solely on the documentation to make function calls? If you wouldn’t, exactly the same reasoning applies to *where* a function can be called.<br>&gt;&gt; <br>&gt;&gt;&gt; I do not believe that your example is even remotely appropriate. These problems are on a totally different scale. You can’t seriously mean the the lack of definition scope access poses challenges that are even remotely similar to those associated with the lack of type checking. <br>&gt;&gt; <br>&gt;&gt; I can and I do. Data encapsulation is a cornerstone for object oriented programming for a very good reason.<br>&gt;&gt; <br>&gt;&gt;&gt; No compiler sugar will prevent people from using your internal APIs if they want to. <br>&gt;&gt; <br>&gt;&gt; True, but the same applies to type checking. We should have real data encapsulation for exactly the same reason.<br>&gt;&gt; <br>&gt;&gt;&gt; At any rate, I can’t help but notice that we are going in circles here. <br>&gt;&gt; <br>&gt;&gt; We are. I hope that my pull request with the proposal will be merged and reviewed soon. This issue has already received plenty of discussion here.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 26, 2016, at 8:36 AM, Taras Zakharko &lt;taras.zakharko at uzh.ch &lt;mailto:taras.zakharko at uzh.ch&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 11:22 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; By this logic, you don&#39;t want or need private (Swift&#39;s private-to-file) either. You just want/need internal and public, because you trust your judgement and you want access to everything in the project.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is certainly not what I wrote. What I said is that hiding the private interface becomes a practical concern on large scale, when you deal with projects or libraries. Swift already solves that issue with per-file and per-module visibility. And when editing the narrow scope (the file), one should make sure that one knows that they are doing (not unlike what you wrote yourself). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m not arguing that Swift needs, say, Scala&#39;s level of detail in its access modifiers, but I think an access modifier for private-to-class or private-to-instance or private-to-scope would let past-Rob convey useful information to future-Rob in a lot of places where currently the information is less precise or entirely absent, and that this ability is useful enough to justify the additional language complexity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Oh, I quite agree with you here. But I still don’t think that declaration scope access is really necessary to achieve this (because quite honestly, the future-Taras messages are best conveyed through documentation strings :) ). See also the summary at the end of my mail. Subclass scope is a different story, because it has many practical uses, but thats a topic for another discussion. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 26 Jan 2016, at 14:00, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; The reasoning is the same as having real types instead of conventions for naming objects:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I do not believe that your example is even remotely appropriate. These problems are on a totally different scale. You can’t seriously mean the the lack of definition scope access poses challenges that are even remotely similar to those associated with the lack of type checking. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are plenty of discussions about Cocoa private APIs on the web where the only thing that is stopping people is whether using them will pass the app store check (and if there is a secret back door still). That specific boundary is addressed with “internal”, but the same is true at the scale of a class.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No compiler sugar will prevent people from using your internal APIs if they want to. With Objective-C this is particularly easy, due to the dynamic nature of the language. Even if Swift had the definition scope access modifier, one could get access to your private interface by reverse-engineering the memory layout of your object and accessing the state directly. The only real argument in favour of definition scope is bug prevention, and as far as I am concerned, it is a matter of opinion (I do like your point about autocompletion though). Again, as I wrote before, I am ambivalent. I don’t think that Swift will loose anything by introducing definition scope access but I also don’t think that it will gain anything. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At any rate, I can’t help but notice that we are going in circles here. I think that the decision should be made by the core Swift team, who should evaluate how well it fits with their vision. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best, <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Taras<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 26 Jan 2016, at 14:00, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This a great writeup on clarity of intent. I’d like to add that in principle, if clarity of intent was the only goal, it could be achieved by a universally agreed on convention, like putting _ in front of the method or property (or type) . We could put it in guidelines and rely on it in all Swift projects. The other part that it is enforced by the compiler is equally important. The reasoning is the same as having real types instead of conventions for naming objects:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Imagine that the Swift compiler did nothing for types — it was just a useful way to convey the coder’s intent. Maintaining the code in this context would become much more difficult:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) the compiler would not help catch mistakes.<br>&gt;&gt;&gt;&gt; 2) the tools would not provide contextual auto completions or useful type related information in general<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am sure that everyone would be less comfortable shipping a large codebase that didn’t go through all the type checks. Exactly the same reasoning applies to “local”. If it’s just a convention that is not enforced by the compiler, we lose a very useful way to verify code correctness. In addition to that, everything that is marked as “local” (or “_” in front of the name)  now shows up in code completions and adds noise and temptation to cut corners (often this would be “faster” functions that already assume certain things about the state that may generally not be true). There are plenty of discussions about Cocoa private APIs on the web where the only thing that is stopping people is whether using them will pass the app store check (and if there is a secret back door still). That specific boundary is addressed with “internal”, but the same is true at the scale of a class.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 11:22 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree with everything Matthew Johnson said in his response. In addition:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mon, Jan 25, 2016 at 5:40 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Personally, I use it quite often because of the way I like to design things as groups of tightly interdependent components (friends, if you want) who are aware of each other’s inner workings. I also want to have full access to the interface of any project I work on because I trust myself to make the judgement whether I am allowed to use a particular functionality or not.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; By this logic, you don&#39;t want or need private (Swift&#39;s private-to-file) either. You just want/need internal and public, because you trust your judgement and you want access to everything in the project.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I trust my judgement, but I don&#39;t trust my memory. In six months, I won&#39;t remember every detail of the code I wrote today. Private-to-file is a message from past-me to future-me: &quot;Dear future-Rob, you don&#39;t need to worry about looking for any use of this element outside this file, but if you want to make it visible to other files, you better study it to make sure it&#39;s safe to expose. Warmest regards, past-Rob.&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is a useful message. It helps jog future-Rob&#39;s memory, it saves future-Rob from bugs, and it lets past-Rob rest easy because the message is guaranteed to be delivered, and is guaranteed to be correct. No comment or policy or convention can make that guarantee.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I want the ability to send another useful message: &quot;Dear future-Rob, you don&#39;t need to worry about looking for any use of this element outside this class, but if you want to make it visible to other classes, you better study it to make sure it&#39;s safe to expose. Very truly yours, past-Rob.&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Note that moving a private class to its own file to make its privates more private does not work. Now I have to make the formerly-private class an internal class, so I&#39;m not sending the first message anymore.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m not arguing that Swift needs, say, Scala&#39;s level of detail in its access modifiers, but I think an access modifier for private-to-class or private-to-instance or private-to-scope would let past-Rob convey useful information to future-Rob in a lot of places where currently the information is less precise or entirely absent, and that this ability is useful enough to justify the additional language complexity.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/ead9f1d5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 28, 2016 at 05:00:00pm</p></header><div class="content"><p>Great, thank you!<br>On Thu, Jan 28, 2016 at 12:05 PM Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br></p><p>&gt; On Jan 27, 2016, at 4:43 AM, Ilya Belenkiy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I am not sure who to ask, so I’ll ask here:<br>&gt;<br>&gt; At what stage do proposals get merged into the “proposals” folder? Is<br>&gt; there some order in which proposals get scheduled for review? My proposal<br>&gt; was thoroughly discussed twice on this list. Is there anything else that I<br>&gt; can do to get it scheduled for a review?<br>&gt;<br>&gt;<br>&gt; One of the core team members will get it merged today. Sorry for the<br>&gt; delay! There is a *lot* going on in swift-evolution land.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt; On Jan 26, 2016, at 9:29 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; This is certainly not what I wrote. What I said is that hiding the private<br>&gt; interface becomes a practical concern on large scale, when you deal with<br>&gt; projects or libraries. Swift already solves that issue with per-file and<br>&gt; per-module visibility. And when editing the narrow scope (the file), one<br>&gt; should make sure that one knows that they are doing (not unlike what you<br>&gt; wrote yourself).<br>&gt;<br>&gt;<br>&gt; Why not automate it if we can?<br>&gt;<br>&gt; Oh, I quite agree with you here. But I still don’t think that declaration<br>&gt; scope access is really necessary to achieve this (because quite honestly,<br>&gt; the future-Taras messages are best conveyed through documentation strings<br>&gt; :) ).<br>&gt;<br>&gt;<br>&gt; Would you remove all type checking and rely solely on the documentation to<br>&gt; make function calls? If you wouldn’t, exactly the same reasoning applies to<br>&gt; *where* a function can be called.<br>&gt;<br>&gt; I do not believe that your example is even remotely appropriate. These<br>&gt; problems are on a totally different scale. You can’t seriously mean the the<br>&gt; lack of definition scope access poses challenges that are even remotely<br>&gt; similar to those associated with the lack of type checking.<br>&gt;<br>&gt;<br>&gt; I can and I do. Data encapsulation is a cornerstone for object oriented<br>&gt; programming for a very good reason.<br>&gt;<br>&gt; No compiler sugar will prevent people from using your internal APIs if<br>&gt; they want to.<br>&gt;<br>&gt;<br>&gt; True, but the same applies to type checking. We should have real data<br>&gt; encapsulation for exactly the same reason.<br>&gt;<br>&gt; At any rate, I can’t help but notice that we are going in circles here.<br>&gt;<br>&gt;<br>&gt; We are. I hope that my pull request with the proposal will be merged and<br>&gt; reviewed soon. This issue has already received plenty of discussion here.<br>&gt;<br>&gt; On Jan 26, 2016, at 8:36 AM, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt;<br>&gt; On Jan 25, 2016, at 11:22 PM, Rob Mayoff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; By this logic, you don&#39;t want or need private (Swift&#39;s private-to-file)<br>&gt; either. You just want/need internal and public, because you trust your<br>&gt; judgement and you want access to everything in the project.<br>&gt;<br>&gt;<br>&gt; This is certainly not what I wrote. What I said is that hiding the private<br>&gt; interface becomes a practical concern on large scale, when you deal with<br>&gt; projects or libraries. Swift already solves that issue with per-file and<br>&gt; per-module visibility. And when editing the narrow scope (the file), one<br>&gt; should make sure that one knows that they are doing (not unlike what you<br>&gt; wrote yourself).<br>&gt;<br>&gt; I&#39;m not arguing that Swift needs, say, Scala&#39;s level of detail in its<br>&gt; access modifiers, but I think an access modifier for private-to-class or<br>&gt; private-to-instance or private-to-scope would let past-Rob convey useful<br>&gt; information to future-Rob in a lot of places where currently the<br>&gt; information is less precise or entirely absent, and that this ability is<br>&gt; useful enough to justify the additional language complexity.<br>&gt;<br>&gt;<br>&gt; Oh, I quite agree with you here. But I still don’t think that declaration<br>&gt; scope access is really necessary to achieve this (because quite honestly,<br>&gt; the future-Taras messages are best conveyed through documentation strings<br>&gt; :) ). See also the summary at the end of my mail. Subclass scope is a<br>&gt; different story, because it has many practical uses, but thats a topic for<br>&gt; another discussion.<br>&gt;<br>&gt; On 26 Jan 2016, at 14:00, Ilya Belenkiy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The reasoning is the same as having real types instead of conventions for<br>&gt; naming objects:<br>&gt;<br>&gt;<br>&gt; I do not believe that your example is even remotely appropriate. These<br>&gt; problems are on a totally different scale. You can’t seriously mean the the<br>&gt; lack of definition scope access poses challenges that are even remotely<br>&gt; similar to those associated with the lack of type checking.<br>&gt;<br>&gt; There are plenty of discussions about Cocoa private APIs on the web where<br>&gt; the only thing that is stopping people is whether using them will pass the<br>&gt; app store check (and if there is a secret back door still). That specific<br>&gt; boundary is addressed with “internal”, but the same is true at the scale of<br>&gt; a class.<br>&gt;<br>&gt;<br>&gt; No compiler sugar will prevent people from using your internal APIs if<br>&gt; they want to. With Objective-C this is particularly easy, due to the<br>&gt; dynamic nature of the language. Even if Swift had the definition scope<br>&gt; access modifier, one could get access to your private interface by<br>&gt; reverse-engineering the memory layout of your object and accessing the<br>&gt; state directly. The only real argument in favour of definition scope is bug<br>&gt; prevention, and as far as I am concerned, it is a matter of opinion (I do<br>&gt; like your point about autocompletion though). Again, as I wrote before, I<br>&gt; am ambivalent. I don’t think that Swift will loose anything by introducing<br>&gt; definition scope access but I also don’t think that it will gain anything.<br>&gt;<br>&gt; At any rate, I can’t help but notice that we are going in circles here. I<br>&gt; think that the decision should be made by the core Swift team, who should<br>&gt; evaluate how well it fits with their vision.<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt;  Taras<br>&gt;<br>&gt; On 26 Jan 2016, at 14:00, Ilya Belenkiy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; This a great writeup on clarity of intent. I’d like to add that in<br>&gt; principle, if clarity of intent was the only goal, it could be achieved by<br>&gt; a universally agreed on convention, like putting _ in front of the method<br>&gt; or property (or type) . We could put it in guidelines and rely on it in all<br>&gt; Swift projects. The other part that it is enforced by the compiler is<br>&gt; equally important. The reasoning is the same as having real types instead<br>&gt; of conventions for naming objects:<br>&gt;<br>&gt; Imagine that the Swift compiler did nothing for types — it was just a<br>&gt; useful way to convey the coder’s intent. Maintaining the code in this<br>&gt; context would become much more difficult:<br>&gt;<br>&gt; 1) the compiler would not help catch mistakes.<br>&gt; 2) the tools would not provide contextual auto completions or useful type<br>&gt; related information in general<br>&gt;<br>&gt; I am sure that everyone would be less comfortable shipping a large<br>&gt; codebase that didn’t go through all the type checks. Exactly the same<br>&gt; reasoning applies to “local”. If it’s just a convention that is not<br>&gt; enforced by the compiler, we lose a very useful way to verify code<br>&gt; correctness. In addition to that, everything that is marked as “local” (or<br>&gt; “_” in front of the name)  now shows up in code completions and adds noise<br>&gt; and temptation to cut corners (often this would be “faster” functions that<br>&gt; already assume certain things about the state that may generally not be<br>&gt; true). There are plenty of discussions about Cocoa private APIs on the web<br>&gt; where the only thing that is stopping people is whether using them will<br>&gt; pass the app store check (and if there is a secret back door still). That<br>&gt; specific boundary is addressed with “internal”, but the same is true at the<br>&gt; scale of a class.<br>&gt;<br>&gt; On Jan 25, 2016, at 11:22 PM, Rob Mayoff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I agree with everything Matthew Johnson said in his response. In addition:<br>&gt;<br>&gt; On Mon, Jan 25, 2016 at 5:40 PM, Taras Zakharko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Personally, I use it quite often because of the way I like to design<br>&gt;&gt; things as groups of tightly interdependent components (friends, if you<br>&gt;&gt; want) who are aware of each other’s inner workings. I also want to have<br>&gt;&gt; full access to the interface of any project I work on because I trust<br>&gt;&gt; myself to make the judgement whether I am allowed to use a particular<br>&gt;&gt; functionality or not.<br>&gt;<br>&gt;<br>&gt; By this logic, you don&#39;t want or need private (Swift&#39;s private-to-file)<br>&gt; either. You just want/need internal and public, because you trust your<br>&gt; judgement and you want access to everything in the project.<br>&gt;<br>&gt; I trust my judgement, but I don&#39;t trust my memory. In six months, I won&#39;t<br>&gt; remember every detail of the code I wrote today. Private-to-file is a<br>&gt; message from past-me to future-me: &quot;Dear future-Rob, you don&#39;t need to<br>&gt; worry about looking for any use of this element outside this file, but if<br>&gt; you want to make it visible to other files, you better study it to make<br>&gt; sure it&#39;s safe to expose. Warmest regards, past-Rob.&quot;<br>&gt;<br>&gt; This is a useful message. It helps jog future-Rob&#39;s memory, it saves<br>&gt; future-Rob from bugs, and it lets past-Rob rest easy because the message is<br>&gt; guaranteed to be delivered, and is guaranteed to be correct. No comment or<br>&gt; policy or convention can make that guarantee.<br>&gt;<br>&gt; I want the ability to send another useful message: &quot;Dear future-Rob, you<br>&gt; don&#39;t need to worry about looking for any use of this element outside this<br>&gt; class, but if you want to make it visible to other classes, you better<br>&gt; study it to make sure it&#39;s safe to expose. Very truly yours, past-Rob.&quot;<br>&gt;<br>&gt; Note that moving a private class to its own file to make its privates more<br>&gt; private does not work. Now I have to make the formerly-private class an<br>&gt; internal class, so I&#39;m not sending the first message anymore.<br>&gt;<br>&gt; I&#39;m not arguing that Swift needs, say, Scala&#39;s level of detail in its<br>&gt; access modifiers, but I think an access modifier for private-to-class or<br>&gt; private-to-instance or private-to-scope would let past-Rob convey useful<br>&gt; information to future-Rob in a lot of places where currently the<br>&gt; information is less precise or entirely absent, and that this ability is<br>&gt; useful enough to justify the additional language complexity.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/00e41dac/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 26, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jan 26, 2016, at 7:00 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This a great writeup on clarity of intent. I’d like to add that in principle, if clarity of intent was the only goal, it could be achieved by a universally agreed on convention, like putting _ in front of the method or property (or type) . We could put it in guidelines and rely on it in all Swift projects. The other part that it is enforced by the compiler is equally important.<br></p><p>I agree.  Most of the value comes from clarity of intent backed by a compiler guarantee.  That is how we know the code actually follows the intent.  I’m pretty sure Rob intended the compiler guarantee to be a critical part of the “message” past-Rob sends future-Rob.<br></p><p>&gt; The reasoning is the same as having real types instead of conventions for naming objects:<br>&gt; <br>&gt; Imagine that the Swift compiler did nothing for types — it was just a useful way to convey the coder’s intent. Maintaining the code in this context would become much more difficult:<br>&gt; <br>&gt; 1) the compiler would not help catch mistakes.<br>&gt; 2) the tools would not provide contextual auto completions or useful type related information in general<br>&gt; <br>&gt; I am sure that everyone would be less comfortable shipping a large codebase that didn’t go through all the type checks. Exactly the same reasoning applies to “local”. If it’s just a convention that is not enforced by the compiler, we lose a very useful way to verify code correctness. In addition to that, everything that is marked as “local” (or “_” in front of the name)  now shows up in code completions and adds noise and temptation to cut corners (often this would be “faster” functions that already assume certain things about the state that may generally not be true). There are plenty of discussions about Cocoa private APIs on the web where the only thing that is stopping people is whether using them will pass the app store check (and if there is a secret back door still). That specific boundary is addressed with “internal”, but the same is true at the scale of a class.<br>&gt; <br>&gt;&gt; On Jan 25, 2016, at 11:22 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree with everything Matthew Johnson said in his response. In addition:<br>&gt;&gt; <br>&gt;&gt; On Mon, Jan 25, 2016 at 5:40 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Personally, I use it quite often because of the way I like to design things as groups of tightly interdependent components (friends, if you want) who are aware of each other’s inner workings. I also want to have full access to the interface of any project I work on because I trust myself to make the judgement whether I am allowed to use a particular functionality or not.<br>&gt;&gt; <br>&gt;&gt; By this logic, you don&#39;t want or need private (Swift&#39;s private-to-file) either. You just want/need internal and public, because you trust your judgement and you want access to everything in the project.<br>&gt;&gt; <br>&gt;&gt; I trust my judgement, but I don&#39;t trust my memory. In six months, I won&#39;t remember every detail of the code I wrote today. Private-to-file is a message from past-me to future-me: &quot;Dear future-Rob, you don&#39;t need to worry about looking for any use of this element outside this file, but if you want to make it visible to other files, you better study it to make sure it&#39;s safe to expose. Warmest regards, past-Rob.&quot;<br>&gt;&gt; <br>&gt;&gt; This is a useful message. It helps jog future-Rob&#39;s memory, it saves future-Rob from bugs, and it lets past-Rob rest easy because the message is guaranteed to be delivered, and is guaranteed to be correct. No comment or policy or convention can make that guarantee.<br>&gt;&gt; <br>&gt;&gt; I want the ability to send another useful message: &quot;Dear future-Rob, you don&#39;t need to worry about looking for any use of this element outside this class, but if you want to make it visible to other classes, you better study it to make sure it&#39;s safe to expose. Very truly yours, past-Rob.&quot;<br>&gt;&gt; <br>&gt;&gt; Note that moving a private class to its own file to make its privates more private does not work. Now I have to make the formerly-private class an internal class, so I&#39;m not sending the first message anymore.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not arguing that Swift needs, say, Scala&#39;s level of detail in its access modifiers, but I think an access modifier for private-to-class or private-to-instance or private-to-scope would let past-Rob convey useful information to future-Rob in a lot of places where currently the information is less precise or entirely absent, and that this ability is useful enough to justify the additional language complexity.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/4c665d2b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 26, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jan 25, 2016, at 10:22 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree with everything Matthew Johnson said in his response. In addition:<br>&gt; <br>&gt; On Mon, Jan 25, 2016 at 5:40 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Personally, I use it quite often because of the way I like to design things as groups of tightly interdependent components (friends, if you want) who are aware of each other’s inner workings. I also want to have full access to the interface of any project I work on because I trust myself to make the judgement whether I am allowed to use a particular functionality or not.<br>&gt; <br>&gt; By this logic, you don&#39;t want or need private (Swift&#39;s private-to-file) either. You just want/need internal and public, because you trust your judgement and you want access to everything in the project.<br>&gt; <br>&gt; I trust my judgement, but I don&#39;t trust my memory. In six months, I won&#39;t remember every detail of the code I wrote today. Private-to-file is a message from past-me to future-me: &quot;Dear future-Rob, you don&#39;t need to worry about looking for any use of this element outside this file, but if you want to make it visible to other files, you better study it to make sure it&#39;s safe to expose. Warmest regards, past-Rob.&quot;<br>&gt; <br>&gt; This is a useful message. It helps jog future-Rob&#39;s memory, it saves future-Rob from bugs, and it lets past-Rob rest easy because the message is guaranteed to be delivered, and is guaranteed to be correct. No comment or policy or convention can make that guarantee.<br></p><p>+1<br></p><p>&gt; <br>&gt; I want the ability to send another useful message: &quot;Dear future-Rob, you don&#39;t need to worry about looking for any use of this element outside this class, but if you want to make it visible to other classes, you better study it to make sure it&#39;s safe to expose. Very truly yours, past-Rob.”<br></p><p>+1<br></p><p>&gt; <br>&gt; Note that moving a private class to its own file to make its privates more private does not work. Now I have to make the formerly-private class an internal class, so I&#39;m not sending the first message anymore.<br>&gt; <br>&gt; I&#39;m not arguing that Swift needs, say, Scala&#39;s level of detail in its access modifiers, but I think an access modifier for private-to-class or private-to-instance or private-to-scope would let past-Rob convey useful information to future-Rob in a lot of places where currently the information is less precise or entirely absent, and that this ability is useful enough to justify the additional language complexity.<br></p><p>Exactly.  It is significant benefit, at least to some of us, with a relatively minor cost in incremental complexity.<br></p><p>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/ad4c37ee/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
