<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>Idea: delegates as protocols and property types with specialised behaviours.</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>January  4, 2016 at 01:00:00am</p></header><div class="content"><p>At the moment, the delegate pattern is just one use of protocols. We create<br>a protocol with a set of declared functions, implemented either in a<br>protocol extension or in the conforming type - the delegate - and another<br>type calls functions of its delegate, notifying them when certain events<br>occur.<br></p><p>I&#39;m wondering if uses of the delegate pattern can or should be made more<br>explicitly readable. The form I have in mind creates a keyword &#39;delegate&#39;,<br>which is used in two contexts; one to replace &#39;protocol&#39; in the declaration<br>of a protocol intended as a delegate, and one to declare a property of the<br>delegate type.<br></p><p>So, for example:<br>delegate UITableViewDataSource { }<br></p><p>and<br>class UITableView<br>{<br>    delegate dataSource : UITableViewDataSource<br>    delegate delegate : UITableViewDelegate<br>}<br></p><p>(I realise this example uses &#39;delegate&#39; both as a keyword and a property<br>name, and would cause a lot of rewriting for types which generically refer<br>to their delegates with the property name &#39;delegate&#39;, so perhaps this isn&#39;t<br>the best choice of keyword, but bear with me, the idea may still have<br>merit.)<br></p><p>As a term for declaring a property, &#39;delegate&#39; could be synonymous with<br>&#39;weak var&#39;, and the type would be implicitly a non-force-unwrapped<br>optional. I can&#39;t presently think of a type in Objective C or Swift which<br>requires a strong reference to its delegate. (It might be preferred that<br>the &quot;?&quot; remain explicit for readability).<br></p><p>Here are two suggestions from where delegates could benefit from being<br>distinct types.<br></p><p>First: if the delegate pattern is observational (i.e. the type with a<br>delegate property calls its delegate&#39;s functions as notifications), then<br>there can be a need for multiple observers (e.g. multiple services in an<br>app being notified that location services have been started).<br>(I&#39;ve tried implementing something like this; an array of references to<br>observer-type delegates at the moment maintains strong references to all<br>delegates, so I&#39;ve created a custom struct with a weak reference to the<br>specific protocol&#39;s type and called &#39;forEach&#39; on a sequence of such<br>structs; if the reference is nil, the struct can be removed from the<br>sequence. Much as I&#39;d like this struct to be generic, I don&#39;t think I can<br>create a generic struct with a protocol as the associated type.)<br>This might be declared with a keyword in the same way properties are<br>modified with lazy / weak:<br>multiple delegate : CLLocationManagerDelegate?<br></p><p>Second: the delegate pattern, if applied to a group of delegates, might not<br>be strictly observational, but might also respond in some way - a sequence<br>of delegates could be called in turn, with candidates being asked if they<br>can respond, returning false if they can&#39;t, true if they can.<br></p><p>Third: delegates could also form a stack. For example, in an NSXMLParser,<br>the parser&#39;s delegate can change during parsing, as types handle their<br>&#39;layer&#39; of parsing and then pass control to child or parent parser-delegate<br>types. This could be simplified to calling something akin to:<br>&#39;parser.delegate.push(childType)&#39; or &#39;parser.delegate.pop()&#39;<br>This might be declared like this:<br>stack delegate : NSXMLParserDelegate?<br></p><p>I may be combining too many ideas into one proposal, or there may be more<br>ideas others can add. Is this worthy of discussion?<br></p><p>-- Ross O&#39;Brien<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/e8b64422/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/49e77a417c2ab608756778c4a75ee14f?s=50"></div><header><strong>Idea: delegates as protocols and property types with specialised behaviours.</strong> from <string>Alex Popov</string> &lt;hello at alexpopov.ca&gt;<p>January  4, 2016 at 01:00:00am</p></header><div class="content"><p>I don&#39;t think this is necessary, but if it does go through, I would prefer the `?` be optional, as occasionally I make my delegates `unowned` so that I don&#39;t have to do a bunch of nil handling/coalescing in the case where the delegate strictly owns the other object and both will be deallocated together.The stack and multiple declarations are interesting, but if Swift 3 brings us the generics we need, those should be possible to implement without adding new keywords/complexity to the language.Alex Popov Jr.<br>Principal iOS developer | Shelfie<br></p><p><br>    _____________________________<br>From: Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt;<br>Sent: Sunday, January 3, 2016 17:07<br>Subject: [swift-evolution] Idea: delegates as protocols and property types with specialised behaviours.<br>To: swift-evolution &lt;swift-evolution at swift.org&gt;<br></p><p><br>           At the moment, the delegate pattern is just one use of protocols. We create a protocol with a set of declared functions, implemented either in a protocol extension or in the conforming type - the delegate - and another type calls functions of its delegate, notifying them when certain events occur.    <br>          <br>          I&#39;m wondering if uses of the delegate pattern can or should be made more explicitly readable. The form I have in mind creates a keyword &#39;delegate&#39;, which is used in two contexts; one to replace &#39;protocol&#39; in the declaration of a protocol intended as a delegate, and one to declare a property of the delegate type.          <br>          So, for example:          delegate UITableViewDataSource { }          <br>          and          class UITableView          {              delegate dataSource : UITableViewDataSource              delegate delegate : UITableViewDelegate          }          <br>          (I realise this example uses &#39;delegate&#39; both as a keyword and a property name, and would cause a lot of rewriting for types which generically refer to their delegates with the property name &#39;delegate&#39;, so perhaps this isn&#39;t the best choice of keyword, but bear with me, the idea may still have merit.)          <br>          As a term for declaring a property, &#39;delegate&#39; could be synonymous with &#39;weak var&#39;, and the type would be implicitly a non-force-unwrapped optional. I can&#39;t presently think of a type in Objective C or Swift which requires a strong reference to its delegate. (It might be preferred that the &quot;?&quot; remain explicit for readability).          <br>          Here are two suggestions from where delegates could benefit from being distinct types.          <br>          First: if the delegate pattern is observational (i.e. the type with a delegate property calls its delegate&#39;s functions as notifications), then there can be a need for multiple observers (e.g. multiple services in an app being notified that location services have been started).          (I&#39;ve tried implementing something like this; an array of references to observer-type delegates at the moment maintains strong references to all delegates, so I&#39;ve created a custom struct with a weak reference to the specific protocol&#39;s type and called &#39;forEach&#39; on a sequence of such structs; if the reference is nil, the struct can be removed from the sequence. Much as I&#39;d like this struct to be generic, I don&#39;t think I can create a generic struct with a protocol as the associated type.)          This might be declared with a keyword in the same way properties are modified with lazy / weak:          multiple delegate : CLLocationManagerDelegate?          <br>          Second: the delegate pattern, if applied to a group of delegates, might not be strictly observational, but might also respond in some way - a sequence of delegates could be called in turn, with candidates being asked if they can respond, returning false if they can&#39;t, true if they can.          <br>          Third: delegates could also form a stack. For example, in an NSXMLParser, the parser&#39;s delegate can change during parsing, as types handle their &#39;layer&#39; of parsing and then pass control to child or parent parser-delegate types. This could be simplified to calling something akin to: &#39;parser.delegate.push(childType)&#39; or &#39;parser.delegate.pop()&#39;          This might be declared like this:          stack delegate : NSXMLParserDelegate?          <br>          I may be combining too many ideas into one proposal, or there may be more ideas others can add. Is this worthy of discussion?          <br>          -- Ross O&#39;Brien          <br></p><p><br>  <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/8c467a46/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
