<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>[Discussion] Here we go again: Extension Functions</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>February 25, 2016 at 05:00:00pm</p></header><div class="content"><p>I&#39;m reopening a topic that has already been discussed here at length[1]: setup closures and `self`-binding closures.<br></p><p>I&#39;ve been wondering if Swift could adopt what Kotlin calls &quot;extension function expressions&quot;[2]. These would allow us to encode a closure&#39;s receiver type (`self`) into the closure type itself, providing a powerful, type-safe way to define DSLs.<br></p><p>Erica&#39;s earlier draft proposed this builder pattern:<br></p><p>    with let task = NSTask() {<br>        launchPath = &quot;/usr/bin/mdfind&quot;<br>        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>        standardOutput = pipe<br>    }<br></p><p>With extension functions, we could approach something similar:<br></p><p>    func with&lt;T&gt;(value: T, body: T.() -&gt; ()) -&gt; T {<br>        value.body()<br>        return value<br>    }<br></p><p>    let task = with(NSTask()) {<br>        launchPath = &quot;/usr/bin/mdfind&quot;<br>        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>        standardOutput = pipe<br>    }<br></p><p>Or, using the `then`[3] pattern:<br></p><p>    protocol Builder {}<br>    extension Builder {<br>        func then(body: Self.() -&gt; ()) -&gt; Self {<br>            body()<br>            return self<br>        }<br>    }<br>    extension NSTask: Builder {}<br>    <br>    let task = NSTask().then {<br>        launchPath = &quot;/usr/bin/mdfind&quot;<br>        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>        standardOutput = pipe<br>    }<br></p><p>How about BDD-style frameworks (like Quick/Nimble[4] and Spectre[5])?<br></p><p>    describe(&quot;a person&quot;) {<br>        let person = Person(name: &quot;Kyle&quot;)<br></p><p>        it(&quot;has a name&quot;) {<br>            try expect(person.name) == &quot;Kyle&quot;<br>        }<br>    }<br></p><p>And HTML builders?<br></p><p>    html {<br>        head { title(&quot;Hello, World!&quot;) }<br>    }<br></p><p>And block-based, transactional APIs?<br></p><p>    db.inTransaction {<br>        delete(&quot;users&quot;, &quot;first_name = ?&quot;, [&quot;Jake&quot;])<br>    }<br></p><p>The main benefits have been previously discussed:<br></p><p>1. The ability to remove noise (&quot;$0&quot; everywhere)<br>2. The ability to avoid defining globals (in favor of a safer, scoped interface)<br></p><p>Would such an enhancement be feasible?<br></p><p>---<br>Stephen<br></p><p>Footnotes:<br></p><p>[1] A probably-incomplete list:<br>- &quot;Idea for enabling DSLs: bind to self in closures&quot;: https://lists.swift.org/pipermail/swift-evolution/2015-December/000114.html<br>- &quot;Request for Discussion: Setup closures&quot;: https://lists.swift.org/pipermail/swift-evolution/2015-December/000211.html<br>- &quot;Method cascading (was Re: Request for Discussion: Setup closures)&quot;: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000729.html<br>- &quot;Fluent syntax (replacing void with a useful default return value)&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/374<br>- &quot;Lexical scope statement (with .. do)&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/1408<br>- &quot;Scoped resources (like C# using statement)&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/1641<br>- &quot;Customized Inline Init Closure&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/1946<br>- &quot;Then Support&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/2054<br>- &quot;Draft proposal: multi-property assignment .= operator&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/2960<br>- &quot;Custom default names for arguments of closures&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/6969<br>- https://bugs.swift.org/browse/SR-160<br></p><p>[2] https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver<br>[3] https://github.com/devxoul/Then<br>[4] https://github.com/Quick/Quick<br>[5] https://github.com/kylef/Spectre<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] Here we go again: Extension Functions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 25, 2016 at 07:00:00pm</p></header><div class="content"><p>I&#39;m really intrigued to see where this goes. Thanks, Stephen.<br></p><p>-- Erica<br></p><p>&gt; On Feb 25, 2016, at 3:47 PM, Stephen Celis via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m reopening a topic that has already been discussed here at length[1]: setup closures and `self`-binding closures.<br>&gt; <br>&gt; I&#39;ve been wondering if Swift could adopt what Kotlin calls &quot;extension function expressions&quot;[2]. These would allow us to encode a closure&#39;s receiver type (`self`) into the closure type itself, providing a powerful, type-safe way to define DSLs.<br>&gt; <br>&gt; Erica&#39;s earlier draft proposed this builder pattern:<br>&gt; <br>&gt;    with let task = NSTask() {<br>&gt;        launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;        standardOutput = pipe<br>&gt;    }<br>&gt; <br>&gt; With extension functions, we could approach something similar:<br>&gt; <br>&gt;    func with&lt;T&gt;(value: T, body: T.() -&gt; ()) -&gt; T {<br>&gt;        value.body()<br>&gt;        return value<br>&gt;    }<br>&gt; <br>&gt;    let task = with(NSTask()) {<br>&gt;        launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;        standardOutput = pipe<br>&gt;    }<br>&gt; <br>&gt; Or, using the `then`[3] pattern:<br>&gt; <br>&gt;    protocol Builder {}<br>&gt;    extension Builder {<br>&gt;        func then(body: Self.() -&gt; ()) -&gt; Self {<br>&gt;            body()<br>&gt;            return self<br>&gt;        }<br>&gt;    }<br>&gt;    extension NSTask: Builder {}<br>&gt; <br>&gt;    let task = NSTask().then {<br>&gt;        launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;        standardOutput = pipe<br>&gt;    }<br>&gt; <br>&gt; How about BDD-style frameworks (like Quick/Nimble[4] and Spectre[5])?<br>&gt; <br>&gt;    describe(&quot;a person&quot;) {<br>&gt;        let person = Person(name: &quot;Kyle&quot;)<br>&gt; <br>&gt;        it(&quot;has a name&quot;) {<br>&gt;            try expect(person.name) == &quot;Kyle&quot;<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; And HTML builders?<br>&gt; <br>&gt;    html {<br>&gt;        head { title(&quot;Hello, World!&quot;) }<br>&gt;    }<br>&gt; <br>&gt; And block-based, transactional APIs?<br>&gt; <br>&gt;    db.inTransaction {<br>&gt;        delete(&quot;users&quot;, &quot;first_name = ?&quot;, [&quot;Jake&quot;])<br>&gt;    }<br>&gt; <br>&gt; The main benefits have been previously discussed:<br>&gt; <br>&gt; 1. The ability to remove noise (&quot;$0&quot; everywhere)<br>&gt; 2. The ability to avoid defining globals (in favor of a safer, scoped interface)<br>&gt; <br>&gt; Would such an enhancement be feasible?<br>&gt; <br>&gt; ---<br>&gt; Stephen<br>&gt; <br>&gt; Footnotes:<br>&gt; <br>&gt; [1] A probably-incomplete list:<br>&gt; - &quot;Idea for enabling DSLs: bind to self in closures&quot;: https://lists.swift.org/pipermail/swift-evolution/2015-December/000114.html<br>&gt; - &quot;Request for Discussion: Setup closures&quot;: https://lists.swift.org/pipermail/swift-evolution/2015-December/000211.html<br>&gt; - &quot;Method cascading (was Re: Request for Discussion: Setup closures)&quot;: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000729.html<br>&gt; - &quot;Fluent syntax (replacing void with a useful default return value)&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/374<br>&gt; - &quot;Lexical scope statement (with .. do)&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/1408<br>&gt; - &quot;Scoped resources (like C# using statement)&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/1641<br>&gt; - &quot;Customized Inline Init Closure&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/1946<br>&gt; - &quot;Then Support&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/2054<br>&gt; - &quot;Draft proposal: multi-property assignment .= operator&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/2960<br>&gt; - &quot;Custom default names for arguments of closures&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/6969<br>&gt; - https://bugs.swift.org/browse/SR-160<br>&gt; <br>&gt; [2] https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver<br>&gt; [3] https://github.com/devxoul/Then<br>&gt; [4] https://github.com/Quick/Quick<br>&gt; [5] https://github.com/kylef/Spectre<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Discussion] Here we go again: Extension Functions</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>February 25, 2016 at 10:00:00pm</p></header><div class="content"><p>+1 to this or something like it. <br></p><p>Right now I’m relying on crap^H^H^H^Hstuff like dispatch_get_specific to provide that kind of context without introducing something like Quick’s global “World”.<br></p><p>Russ<br></p><p>&gt; On Feb 25, 2016, at 2:47 PM, Stephen Celis via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m reopening a topic that has already been discussed here at length[1]: setup closures and `self`-binding closures.<br>&gt; <br>&gt; I&#39;ve been wondering if Swift could adopt what Kotlin calls &quot;extension function expressions&quot;[2]. These would allow us to encode a closure&#39;s receiver type (`self`) into the closure type itself, providing a powerful, type-safe way to define DSLs.<br>&gt; <br>&gt; Erica&#39;s earlier draft proposed this builder pattern:<br>&gt; <br>&gt;    with let task = NSTask() {<br>&gt;        launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;        standardOutput = pipe<br>&gt;    }<br>&gt; <br>&gt; With extension functions, we could approach something similar:<br>&gt; <br>&gt;    func with&lt;T&gt;(value: T, body: T.() -&gt; ()) -&gt; T {<br>&gt;        value.body()<br>&gt;        return value<br>&gt;    }<br>&gt; <br>&gt;    let task = with(NSTask()) {<br>&gt;        launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;        standardOutput = pipe<br>&gt;    }<br>&gt; <br>&gt; Or, using the `then`[3] pattern:<br>&gt; <br>&gt;    protocol Builder {}<br>&gt;    extension Builder {<br>&gt;        func then(body: Self.() -&gt; ()) -&gt; Self {<br>&gt;            body()<br>&gt;            return self<br>&gt;        }<br>&gt;    }<br>&gt;    extension NSTask: Builder {}<br>&gt; <br>&gt;    let task = NSTask().then {<br>&gt;        launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;        standardOutput = pipe<br>&gt;    }<br>&gt; <br>&gt; How about BDD-style frameworks (like Quick/Nimble[4] and Spectre[5])?<br>&gt; <br>&gt;    describe(&quot;a person&quot;) {<br>&gt;        let person = Person(name: &quot;Kyle&quot;)<br>&gt; <br>&gt;        it(&quot;has a name&quot;) {<br>&gt;            try expect(person.name) == &quot;Kyle&quot;<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; And HTML builders?<br>&gt; <br>&gt;    html {<br>&gt;        head { title(&quot;Hello, World!&quot;) }<br>&gt;    }<br>&gt; <br>&gt; And block-based, transactional APIs?<br>&gt; <br>&gt;    db.inTransaction {<br>&gt;        delete(&quot;users&quot;, &quot;first_name = ?&quot;, [&quot;Jake&quot;])<br>&gt;    }<br>&gt; <br>&gt; The main benefits have been previously discussed:<br>&gt; <br>&gt; 1. The ability to remove noise (&quot;$0&quot; everywhere)<br>&gt; 2. The ability to avoid defining globals (in favor of a safer, scoped interface)<br>&gt; <br>&gt; Would such an enhancement be feasible?<br>&gt; <br>&gt; ---<br>&gt; Stephen<br>&gt; <br>&gt; Footnotes:<br>&gt; <br>&gt; [1] A probably-incomplete list:<br>&gt; - &quot;Idea for enabling DSLs: bind to self in closures&quot;: https://lists.swift.org/pipermail/swift-evolution/2015-December/000114.html<br>&gt; - &quot;Request for Discussion: Setup closures&quot;: https://lists.swift.org/pipermail/swift-evolution/2015-December/000211.html<br>&gt; - &quot;Method cascading (was Re: Request for Discussion: Setup closures)&quot;: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000729.html<br>&gt; - &quot;Fluent syntax (replacing void with a useful default return value)&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/374<br>&gt; - &quot;Lexical scope statement (with .. do)&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/1408<br>&gt; - &quot;Scoped resources (like C# using statement)&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/1641<br>&gt; - &quot;Customized Inline Init Closure&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/1946<br>&gt; - &quot;Then Support&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/2054<br>&gt; - &quot;Draft proposal: multi-property assignment .= operator&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/2960<br>&gt; - &quot;Custom default names for arguments of closures&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/6969<br>&gt; - https://bugs.swift.org/browse/SR-160<br>&gt; <br>&gt; [2] https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver<br>&gt; [3] https://github.com/devxoul/Then<br>&gt; [4] https://github.com/Quick/Quick<br>&gt; [5] https://github.com/kylef/Spectre<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a32f0c9071fd24f75322395496dc6a32?s=50"></div><header><strong>[Discussion] Here we go again: Extension Functions</strong> from <string>Eugene Gubin</string> &lt;hemet.mail at gmail.com&gt;<p>February 26, 2016 at 10:00:00am</p></header><div class="content"><p>+1 very interesting idea<br></p><p>2016-02-26 9:09 GMT+03:00 Russ Bishop via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; +1 to this or something like it.<br>&gt;<br>&gt; Right now I’m relying on crap^H^H^H^Hstuff like dispatch_get_specific to<br>&gt; provide that kind of context without introducing something like Quick’s<br>&gt; global “World”.<br>&gt;<br>&gt; Russ<br>&gt;<br>&gt; &gt; On Feb 25, 2016, at 2:47 PM, Stephen Celis via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I&#39;m reopening a topic that has already been discussed here at length[1]:<br>&gt; setup closures and `self`-binding closures.<br>&gt; &gt;<br>&gt; &gt; I&#39;ve been wondering if Swift could adopt what Kotlin calls &quot;extension<br>&gt; function expressions&quot;[2]. These would allow us to encode a closure&#39;s<br>&gt; receiver type (`self`) into the closure type itself, providing a powerful,<br>&gt; type-safe way to define DSLs.<br>&gt; &gt;<br>&gt; &gt; Erica&#39;s earlier draft proposed this builder pattern:<br>&gt; &gt;<br>&gt; &gt;    with let task = NSTask() {<br>&gt; &gt;        launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt; &gt;        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt; &gt;        standardOutput = pipe<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; With extension functions, we could approach something similar:<br>&gt; &gt;<br>&gt; &gt;    func with&lt;T&gt;(value: T, body: T.() -&gt; ()) -&gt; T {<br>&gt; &gt;        value.body()<br>&gt; &gt;        return value<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt;    let task = with(NSTask()) {<br>&gt; &gt;        launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt; &gt;        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt; &gt;        standardOutput = pipe<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; Or, using the `then`[3] pattern:<br>&gt; &gt;<br>&gt; &gt;    protocol Builder {}<br>&gt; &gt;    extension Builder {<br>&gt; &gt;        func then(body: Self.() -&gt; ()) -&gt; Self {<br>&gt; &gt;            body()<br>&gt; &gt;            return self<br>&gt; &gt;        }<br>&gt; &gt;    }<br>&gt; &gt;    extension NSTask: Builder {}<br>&gt; &gt;<br>&gt; &gt;    let task = NSTask().then {<br>&gt; &gt;        launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt; &gt;        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt; &gt;        standardOutput = pipe<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; How about BDD-style frameworks (like Quick/Nimble[4] and Spectre[5])?<br>&gt; &gt;<br>&gt; &gt;    describe(&quot;a person&quot;) {<br>&gt; &gt;        let person = Person(name: &quot;Kyle&quot;)<br>&gt; &gt;<br>&gt; &gt;        it(&quot;has a name&quot;) {<br>&gt; &gt;            try expect(person.name) == &quot;Kyle&quot;<br>&gt; &gt;        }<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; And HTML builders?<br>&gt; &gt;<br>&gt; &gt;    html {<br>&gt; &gt;        head { title(&quot;Hello, World!&quot;) }<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; And block-based, transactional APIs?<br>&gt; &gt;<br>&gt; &gt;    db.inTransaction {<br>&gt; &gt;        delete(&quot;users&quot;, &quot;first_name = ?&quot;, [&quot;Jake&quot;])<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; The main benefits have been previously discussed:<br>&gt; &gt;<br>&gt; &gt; 1. The ability to remove noise (&quot;$0&quot; everywhere)<br>&gt; &gt; 2. The ability to avoid defining globals (in favor of a safer, scoped<br>&gt; interface)<br>&gt; &gt;<br>&gt; &gt; Would such an enhancement be feasible?<br>&gt; &gt;<br>&gt; &gt; ---<br>&gt; &gt; Stephen<br>&gt; &gt;<br>&gt; &gt; Footnotes:<br>&gt; &gt;<br>&gt; &gt; [1] A probably-incomplete list:<br>&gt; &gt; - &quot;Idea for enabling DSLs: bind to self in closures&quot;:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/2015-December/000114.html<br>&gt; &gt; - &quot;Request for Discussion: Setup closures&quot;:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/2015-December/000211.html<br>&gt; &gt; - &quot;Method cascading (was Re: Request for Discussion: Setup closures)&quot;:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000729.html<br>&gt; &gt; - &quot;Fluent syntax (replacing void with a useful default return value)&quot;:<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/374<br>&gt; &gt; - &quot;Lexical scope statement (with .. do)&quot;:<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/1408<br>&gt; &gt; - &quot;Scoped resources (like C# using statement)&quot;:<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/1641<br>&gt; &gt; - &quot;Customized Inline Init Closure&quot;:<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/1946<br>&gt; &gt; - &quot;Then Support&quot;:<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/2054<br>&gt; &gt; - &quot;Draft proposal: multi-property assignment .= operator&quot;:<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/2960<br>&gt; &gt; - &quot;Custom default names for arguments of closures&quot;:<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/6969<br>&gt; &gt; - https://bugs.swift.org/browse/SR-160<br>&gt; &gt;<br>&gt; &gt; [2]<br>&gt; https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver<br>&gt; &gt; [3] https://github.com/devxoul/Then<br>&gt; &gt; [4] https://github.com/Quick/Quick<br>&gt; &gt; [5] https://github.com/kylef/Spectre<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/dcca6a4a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b9f0c10986385f3c7f50615d6176be3?s=50"></div><header><strong>[Discussion] Here we go again: Extension Functions</strong> from <string>Pierre Monod-Broca</string> &lt;pierre at monod-broca.fr&gt;<p>February 26, 2016 at 01:00:00pm</p></header><div class="content"><p>+1 on the idea.<br></p><p>I&#39;m less convinced by the suggested syntax, to me it feels a bit weird.<br></p><p>I&#39;m thinking an attribute on the closure&#39;s first parameter, for exemple (feel free to suggest other names):<br></p><p>func with&lt;T&gt;(value: T, body: (bound T) -&gt; ()) -&gt; T {<br>    body(value)<br>    return value<br>}<br></p><p><br>&gt; Le 26 févr. 2016 à 08:22, Eugene Gubin via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; +1 very interesting idea<br>&gt; <br>&gt; 2016-02-26 9:09 GMT+03:00 Russ Bishop via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; +1 to this or something like it.<br>&gt; <br>&gt; Right now I’m relying on crap^H^H^H^Hstuff like dispatch_get_specific to provide that kind of context without introducing something like Quick’s global “World”.<br>&gt; <br>&gt; Russ<br>&gt; <br>&gt; &gt; On Feb 25, 2016, at 2:47 PM, Stephen Celis via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I&#39;m reopening a topic that has already been discussed here at length[1]: setup closures and `self`-binding closures.<br>&gt; &gt;<br>&gt; &gt; I&#39;ve been wondering if Swift could adopt what Kotlin calls &quot;extension function expressions&quot;[2]. These would allow us to encode a closure&#39;s receiver type (`self`) into the closure type itself, providing a powerful, type-safe way to define DSLs.<br>&gt; &gt;<br>&gt; &gt; Erica&#39;s earlier draft proposed this builder pattern:<br>&gt; &gt;<br>&gt; &gt;    with let task = NSTask() {<br>&gt; &gt;        launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt; &gt;        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt; &gt;        standardOutput = pipe<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; With extension functions, we could approach something similar:<br>&gt; &gt;<br>&gt; &gt;    func with&lt;T&gt;(value: T, body: T.() -&gt; ()) -&gt; T {<br>&gt; &gt;        value.body()<br>&gt; &gt;        return value<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt;    let task = with(NSTask()) {<br>&gt; &gt;        launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt; &gt;        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt; &gt;        standardOutput = pipe<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; Or, using the `then`[3] pattern:<br>&gt; &gt;<br>&gt; &gt;    protocol Builder {}<br>&gt; &gt;    extension Builder {<br>&gt; &gt;        func then(body: Self.() -&gt; ()) -&gt; Self {<br>&gt; &gt;            body()<br>&gt; &gt;            return self<br>&gt; &gt;        }<br>&gt; &gt;    }<br>&gt; &gt;    extension NSTask: Builder {}<br>&gt; &gt;<br>&gt; &gt;    let task = NSTask().then {<br>&gt; &gt;        launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt; &gt;        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt; &gt;        standardOutput = pipe<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; How about BDD-style frameworks (like Quick/Nimble[4] and Spectre[5])?<br>&gt; &gt;<br>&gt; &gt;    describe(&quot;a person&quot;) {<br>&gt; &gt;        let person = Person(name: &quot;Kyle&quot;)<br>&gt; &gt;<br>&gt; &gt;        it(&quot;has a name&quot;) {<br>&gt; &gt;            try expect(person.name &lt;http://person.name/&gt;) == &quot;Kyle&quot;<br>&gt; &gt;        }<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; And HTML builders?<br>&gt; &gt;<br>&gt; &gt;    html {<br>&gt; &gt;        head { title(&quot;Hello, World!&quot;) }<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; And block-based, transactional APIs?<br>&gt; &gt;<br>&gt; &gt;    db.inTransaction {<br>&gt; &gt;        delete(&quot;users&quot;, &quot;first_name = ?&quot;, [&quot;Jake&quot;])<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; The main benefits have been previously discussed:<br>&gt; &gt;<br>&gt; &gt; 1. The ability to remove noise (&quot;$0&quot; everywhere)<br>&gt; &gt; 2. The ability to avoid defining globals (in favor of a safer, scoped interface)<br>&gt; &gt;<br>&gt; &gt; Would such an enhancement be feasible?<br>&gt; &gt;<br>&gt; &gt; ---<br>&gt; &gt; Stephen<br>&gt; &gt;<br>&gt; &gt; Footnotes:<br>&gt; &gt;<br>&gt; &gt; [1] A probably-incomplete list:<br>&gt; &gt; - &quot;Idea for enabling DSLs: bind to self in closures&quot;: https://lists.swift.org/pipermail/swift-evolution/2015-December/000114.html &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000114.html&gt;<br>&gt; &gt; - &quot;Request for Discussion: Setup closures&quot;: https://lists.swift.org/pipermail/swift-evolution/2015-December/000211.html &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000211.html&gt;<br>&gt; &gt; - &quot;Method cascading (was Re: Request for Discussion: Setup closures)&quot;: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000729.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000729.html&gt;<br>&gt; &gt; - &quot;Fluent syntax (replacing void with a useful default return value)&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/374 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/374&gt;<br>&gt; &gt; - &quot;Lexical scope statement (with .. do)&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/1408 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/1408&gt;<br>&gt; &gt; - &quot;Scoped resources (like C# using statement)&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/1641 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/1641&gt;<br>&gt; &gt; - &quot;Customized Inline Init Closure&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/1946 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/1946&gt;<br>&gt; &gt; - &quot;Then Support&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/2054 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/2054&gt;<br>&gt; &gt; - &quot;Draft proposal: multi-property assignment .= operator&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/2960 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/2960&gt;<br>&gt; &gt; - &quot;Custom default names for arguments of closures&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/6969 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/6969&gt;<br>&gt; &gt; - https://bugs.swift.org/browse/SR-160 &lt;https://bugs.swift.org/browse/SR-160&gt;<br>&gt; &gt;<br>&gt; &gt; [2] https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver &lt;https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver&gt;<br>&gt; &gt; [3] https://github.com/devxoul/Then &lt;https://github.com/devxoul/Then&gt;<br>&gt; &gt; [4] https://github.com/Quick/Quick &lt;https://github.com/Quick/Quick&gt;<br>&gt; &gt; [5] https://github.com/kylef/Spectre &lt;https://github.com/kylef/Spectre&gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/7ea8ea0a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>[Discussion] Here we go again: Extension Functions</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>February 26, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 26, 2016, at 7:21 AM, Pierre Monod-Broca via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m less convinced by the suggested syntax, to me it feels a bit weird.<br>&gt; <br>&gt; I&#39;m thinking an attribute on the closure&#39;s first parameter, for exemple (feel free to suggest other names):<br>&gt; <br>&gt; func with&lt;T&gt;(value: T, body: (bound T) -&gt; ()) -&gt; T {<br>&gt;     body(value)<br>&gt;     return value<br>&gt; }<br></p><p>While I&#39;m not married to `T.() -&gt; ()`, I do like that it:<br></p><p>- Separates the self parameter from the parameter list<br>- Avoids an additional keyword<br></p><p>We could also try reusing the recently removed curry syntax:<br></p><p>    func with&lt;T&gt;(value: T, body: (T)() -&gt; Void) -&gt; T {<br>        value.body(value)<br>        return value<br>    }<br></p><p>Given that curried versions of instance methods are available on the class, and given the fact that the instance versions of these methods have a bound `self` (and would likely have an extension function signature), it might make more sense than using dot-notation.<br></p><p>Stephen<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Discussion] Here we go again: Extension Functions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 29, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; I&#39;m thinking an attribute on the closure&#39;s first parameter, for exemple (feel free to suggest other names):<br>&gt; <br>&gt; func with&lt;T&gt;(value: T, body: (bound T) -&gt; ()) -&gt; T {<br></p><p>Is there a reason to avoid the obvious answer?<br></p><p>	func with&lt;T&gt;(value: T, body: (self: T) -&gt; ()) -&gt; T {<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>[Discussion] Here we go again: Extension Functions</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>February 29, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Feb 29, 2016, at 3:59 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I&#39;m thinking an attribute on the closure&#39;s first parameter, for exemple (feel free to suggest other names):<br>&gt;&gt; <br>&gt;&gt; func with&lt;T&gt;(value: T, body: (bound T) -&gt; ()) -&gt; T {<br>&gt; <br>&gt; Is there a reason to avoid the obvious answer?<br>&gt; <br>&gt; 	func with&lt;T&gt;(value: T, body: (self: T) -&gt; ()) -&gt; T {<br></p><p>I don&#39;t see any reason why that couldn&#39;t work.<br></p><p>With that change would the call site may change, too?<br></p><p>    body(self)<br></p><p>Stephen<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Discussion] Here we go again: Extension Functions</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February 29, 2016 at 01:00:00pm</p></header><div class="content"><p>I have chills when I hear the idea of a closure changing the `self` from underneath me. JavaScript made me this way.<br></p><p>Of course, this is different than JavaScript, because it’s type-safe and you have to explicitly make a specific closure behave this way.<br></p><p>Still:<br>- I fear that this can be awfully confusing because there’s no indication on call site that the closure has a different `self`.<br>- what if you do want to use your “outer self” inside the self-binding closure? Sure, in some cases, you could differentiate by `foo` and `self.foo`, but I suspect most self-binding closures would also be @noescape. And so, back to the JavaScript-like convention of `let this = self`? Ugh :(<br></p><p>I do like that this syntax is not super noisy with all the $0’s, and also has the advantage that it doesn’t break when you only have a single expression (https://github.com/devxoul/Then#trouble-shooting &lt;https://github.com/devxoul/Then#trouble-shooting&gt;). But maybe it’s not the way to go.<br></p><p>— Radek<br></p><p>&gt; On 25 Feb 2016, at 23:47, Stephen Celis via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m reopening a topic that has already been discussed here at length[1]: setup closures and `self`-binding closures.<br>&gt; <br>&gt; I&#39;ve been wondering if Swift could adopt what Kotlin calls &quot;extension function expressions&quot;[2]. These would allow us to encode a closure&#39;s receiver type (`self`) into the closure type itself, providing a powerful, type-safe way to define DSLs.<br>&gt; <br>&gt; Erica&#39;s earlier draft proposed this builder pattern:<br>&gt; <br>&gt;    with let task = NSTask() {<br>&gt;        launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;        standardOutput = pipe<br>&gt;    }<br>&gt; <br>&gt; With extension functions, we could approach something similar:<br>&gt; <br>&gt;    func with&lt;T&gt;(value: T, body: T.() -&gt; ()) -&gt; T {<br>&gt;        value.body()<br>&gt;        return value<br>&gt;    }<br>&gt; <br>&gt;    let task = with(NSTask()) {<br>&gt;        launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;        standardOutput = pipe<br>&gt;    }<br>&gt; <br>&gt; Or, using the `then`[3] pattern:<br>&gt; <br>&gt;    protocol Builder {}<br>&gt;    extension Builder {<br>&gt;        func then(body: Self.() -&gt; ()) -&gt; Self {<br>&gt;            body()<br>&gt;            return self<br>&gt;        }<br>&gt;    }<br>&gt;    extension NSTask: Builder {}<br>&gt; <br>&gt;    let task = NSTask().then {<br>&gt;        launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;        standardOutput = pipe<br>&gt;    }<br>&gt; <br>&gt; How about BDD-style frameworks (like Quick/Nimble[4] and Spectre[5])?<br>&gt; <br>&gt;    describe(&quot;a person&quot;) {<br>&gt;        let person = Person(name: &quot;Kyle&quot;)<br>&gt; <br>&gt;        it(&quot;has a name&quot;) {<br>&gt;            try expect(person.name) == &quot;Kyle&quot;<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; And HTML builders?<br>&gt; <br>&gt;    html {<br>&gt;        head { title(&quot;Hello, World!&quot;) }<br>&gt;    }<br>&gt; <br>&gt; And block-based, transactional APIs?<br>&gt; <br>&gt;    db.inTransaction {<br>&gt;        delete(&quot;users&quot;, &quot;first_name = ?&quot;, [&quot;Jake&quot;])<br>&gt;    }<br>&gt; <br>&gt; The main benefits have been previously discussed:<br>&gt; <br>&gt; 1. The ability to remove noise (&quot;$0&quot; everywhere)<br>&gt; 2. The ability to avoid defining globals (in favor of a safer, scoped interface)<br>&gt; <br>&gt; Would such an enhancement be feasible?<br>&gt; <br>&gt; ---<br>&gt; Stephen<br>&gt; <br>&gt; Footnotes:<br>&gt; <br>&gt; [1] A probably-incomplete list:<br>&gt; - &quot;Idea for enabling DSLs: bind to self in closures&quot;: https://lists.swift.org/pipermail/swift-evolution/2015-December/000114.html<br>&gt; - &quot;Request for Discussion: Setup closures&quot;: https://lists.swift.org/pipermail/swift-evolution/2015-December/000211.html<br>&gt; - &quot;Method cascading (was Re: Request for Discussion: Setup closures)&quot;: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000729.html<br>&gt; - &quot;Fluent syntax (replacing void with a useful default return value)&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/374<br>&gt; - &quot;Lexical scope statement (with .. do)&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/1408<br>&gt; - &quot;Scoped resources (like C# using statement)&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/1641<br>&gt; - &quot;Customized Inline Init Closure&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/1946<br>&gt; - &quot;Then Support&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/2054<br>&gt; - &quot;Draft proposal: multi-property assignment .= operator&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/2960<br>&gt; - &quot;Custom default names for arguments of closures&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/6969<br>&gt; - https://bugs.swift.org/browse/SR-160<br>&gt; <br>&gt; [2] https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver<br>&gt; [3] https://github.com/devxoul/Then<br>&gt; [4] https://github.com/Quick/Quick<br>&gt; [5] https://github.com/kylef/Spectre<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/30791d2f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>[Discussion] Here we go again: Extension Functions</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>February 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Feb 29, 2016, at 7:33 AM, Radosław Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt; <br>&gt; I have chills when I hear the idea of a closure changing the `self` from underneath me. JavaScript made me this way.<br>&gt; <br>&gt; Of course, this is different than JavaScript, because it’s type-safe and you have to explicitly make a specific closure behave this way.<br>&gt; <br>&gt; Still:<br>&gt; - I fear that this can be awfully confusing because there’s no indication on call site that the closure has a different `self`.<br></p><p>Is this much different than the argument made against implicit vs. explicit `self` when calling methods and properties? Couldn&#39;t the context and editor make this fairly easy to disambiguate on the event that it _is_ confusing?<br></p><p>I agree that `with` presented problems in JavaScript (not just ambiguity, but forward-compatibility), and though `with` could be built rather easily in Swift using extension functions, it&#39;s not the core concept here (in any case, a protocol extension-based `then` would probably be preferred over `with`).<br></p><p>Ruby is another type-unsafe language with a community that heavily employs these kinds of DSLs via `instance_{eval,exec}`. The few issues I have with Ruby&#39;s system disappear with type safety and compile-time guarantees.<br></p><p>&gt; - what if you do want to use your “outer self” inside the self-binding closure? Sure, in some cases, you could differentiate by `foo` and `self.foo`, but I suspect most self-binding closures would also be @noescape. And so, back to the JavaScript-like convention of `let this = self`? Ugh :(<br></p><p>In the past life I spent with Ruby, I don&#39;t ever remember fighting this, but in those rare cases that you want to refer to &quot;outer&quot; self, I don&#39;t see a prelude of `let value = self` or `let valueNeededForClosure = property` being a problem. Capture lists offer a shorthand:<br></p><p>    db.inTransaction { [name] in<br>        delete(&quot;users&quot;, &quot;name = ?&quot;, [name])<br>    }<br></p><p>(While I believe it would be possible for the compiler to cascade to outer `self` methods and properties, I&#39;m not convinced this is a good idea.)<br></p><p>&gt; I do like that this syntax is not super noisy with all the $0’s, and also has the advantage that it doesn’t break when you only have a single expression (https://github.com/devxoul/Then#trouble-shooting). But maybe it’s not the way to go.<br></p><p>Was there an earlier version you preferred (see my long list at the beginning of this thread)? Do you have alternate ideas or ways to improve upon the idea of using extension functions?<br></p><p>Stephen<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Discussion] Here we go again: Extension Functions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 29, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; - I fear that this can be awfully confusing because there’s no indication on call site that the closure has a different `self`.<br>&gt; - what if you do want to use your “outer self” inside the self-binding closure? Sure, in some cases, you could differentiate by `foo` and `self.foo`, but I suspect most self-binding closures would also be @noescape. And so, back to the JavaScript-like convention of `let this = self`? Ugh :(<br></p><p>Personally, I wouldn&#39;t mind having the feature structured in the following fashion:<br></p><p>* You can use `self` as the internal name of any parameter to any function. (Though perhaps not in a method, which already has an implicit parameter with the internal name `self`.)<br>* If you do, that parameter is the receiver of all receiverless method calls.<br>* A closure with `self: T` in its parameter list is simply a hint to SourceKit that its code completion should name the parameter `self`.<br></p><p>That way, any closure which rebound self would be explicitly marked at the top with `self in`, and if you wanted to access the outer `self`, you could always simply give the parameter a different name.<br></p><p>This would add a small syntactic burden to uses of `with` and other DSLs, but it might be worth it to make the behavior explicit.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>[Discussion] Here we go again: Extension Functions</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>February 29, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Feb 29, 2016, at 6:38 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; Personally, I wouldn&#39;t mind having the feature structured in the following fashion:<br>&gt; <br>&gt; * You can use `self` as the internal name of any parameter to any function. (Though perhaps not in a method, which already has an implicit parameter with the internal name `self`.)<br>&gt; * If you do, that parameter is the receiver of all receiverless method calls.<br>&gt; * A closure with `self: T` in its parameter list is simply a hint to SourceKit that its code completion should name the parameter `self`.<br>&gt; <br>&gt; That way, any closure which rebound self would be explicitly marked at the top with `self in`, and if you wanted to access the outer `self`, you could always simply give the parameter a different name.<br>&gt; <br>&gt; This would add a small syntactic burden to uses of `with` and other DSLs, but it might be worth it to make the behavior explicit.<br></p><p>The `self in` solution was actually one of the first suggestions on this list:<br></p><p>https://lists.swift.org/pipermail/swift-evolution/2015-December/000114.html<br></p><p>I do think it gets rather wordy in DSLs, though, and that implicit `self` should be favored if it works (for the same reason we allow implicit `self`). There&#39;s a lot of noise:<br></p><p>    html { self in<br>        head { self in<br>            title(&quot;Hello&quot;)<br>        }<br>        body { self in<br>            section { self in<br>                p(&quot;Hello, &quot;, span(name))<br>            }<br>        }<br>    }<br></p><p>Vs.<br></p><p>    html {<br>        head {<br>            title(&quot;Hello&quot;)<br>        }<br>        body {<br>            section {<br>                p(&quot;Hello, &quot;, span(name))<br>            }<br>        }<br>    }<br></p><p>Even &quot;$0&quot; feels less noisy, depending on the DSL:<br></p><p>    html {<br>        $0.head {<br>            $0.title(&quot;Hello&quot;)<br>        }<br>        $0.body {<br>            $0.section {<br>                $0.p(&quot;Hello, &quot;, $0.span(name))<br>            }<br>        }<br>    }<br></p><p>--<br>Stephen<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b9f0c10986385f3c7f50615d6176be3?s=50"></div><header><strong>[Discussion] Here we go again: Extension Functions</strong> from <string>Pierre Monod-Broca</string> &lt;pierre at monod-broca.fr&gt;<p>March  1, 2016 at 12:00:00pm</p></header><div class="content"><p>+1 on changing the meaning of `self`, it&#39;s scary<br></p><p>&gt; Le 29 févr. 2016 à 13:33, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I have chills when I hear the idea of a closure changing the `self` from underneath me. JavaScript made me this way.<br>&gt; <br>&gt; Of course, this is different than JavaScript, because it’s type-safe and you have to explicitly make a specific closure behave this way.<br>&gt; <br>&gt; Still:<br>&gt; - I fear that this can be awfully confusing because there’s no indication on call site that the closure has a different `self`.<br>&gt; - what if you do want to use your “outer self” inside the self-binding closure? Sure, in some cases, you could differentiate by `foo` and `self.foo`, but I suspect most self-binding closures would also be @noescape. And so, back to the JavaScript-like convention of `let this = self`? Ugh :(<br>&gt; <br>&gt; I do like that this syntax is not super noisy with all the $0’s, and also has the advantage that it doesn’t break when you only have a single expression (https://github.com/devxoul/Then#trouble-shooting &lt;https://github.com/devxoul/Then#trouble-shooting&gt;). But maybe it’s not the way to go.<br>&gt; <br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 25 Feb 2016, at 23:47, Stephen Celis via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m reopening a topic that has already been discussed here at length[1]: setup closures and `self`-binding closures.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve been wondering if Swift could adopt what Kotlin calls &quot;extension function expressions&quot;[2]. These would allow us to encode a closure&#39;s receiver type (`self`) into the closure type itself, providing a powerful, type-safe way to define DSLs.<br>&gt;&gt; <br>&gt;&gt; Erica&#39;s earlier draft proposed this builder pattern:<br>&gt;&gt; <br>&gt;&gt;    with let task = NSTask() {<br>&gt;&gt;        launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;&gt;        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;&gt;        standardOutput = pipe<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; With extension functions, we could approach something similar:<br>&gt;&gt; <br>&gt;&gt;    func with&lt;T&gt;(value: T, body: T.() -&gt; ()) -&gt; T {<br>&gt;&gt;        value.body()<br>&gt;&gt;        return value<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    let task = with(NSTask()) {<br>&gt;&gt;        launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;&gt;        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;&gt;        standardOutput = pipe<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; Or, using the `then`[3] pattern:<br>&gt;&gt; <br>&gt;&gt;    protocol Builder {}<br>&gt;&gt;    extension Builder {<br>&gt;&gt;        func then(body: Self.() -&gt; ()) -&gt; Self {<br>&gt;&gt;            body()<br>&gt;&gt;            return self<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt;    extension NSTask: Builder {}<br>&gt;&gt; <br>&gt;&gt;    let task = NSTask().then {<br>&gt;&gt;        launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;&gt;        arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;&gt;        standardOutput = pipe<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; How about BDD-style frameworks (like Quick/Nimble[4] and Spectre[5])?<br>&gt;&gt; <br>&gt;&gt;    describe(&quot;a person&quot;) {<br>&gt;&gt;        let person = Person(name: &quot;Kyle&quot;)<br>&gt;&gt; <br>&gt;&gt;        it(&quot;has a name&quot;) {<br>&gt;&gt;            try expect(person.name) == &quot;Kyle&quot;<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; And HTML builders?<br>&gt;&gt; <br>&gt;&gt;    html {<br>&gt;&gt;        head { title(&quot;Hello, World!&quot;) }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; And block-based, transactional APIs?<br>&gt;&gt; <br>&gt;&gt;    db.inTransaction {<br>&gt;&gt;        delete(&quot;users&quot;, &quot;first_name = ?&quot;, [&quot;Jake&quot;])<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; The main benefits have been previously discussed:<br>&gt;&gt; <br>&gt;&gt; 1. The ability to remove noise (&quot;$0&quot; everywhere)<br>&gt;&gt; 2. The ability to avoid defining globals (in favor of a safer, scoped interface)<br>&gt;&gt; <br>&gt;&gt; Would such an enhancement be feasible?<br>&gt;&gt; <br>&gt;&gt; ---<br>&gt;&gt; Stephen<br>&gt;&gt; <br>&gt;&gt; Footnotes:<br>&gt;&gt; <br>&gt;&gt; [1] A probably-incomplete list:<br>&gt;&gt; - &quot;Idea for enabling DSLs: bind to self in closures&quot;: https://lists.swift.org/pipermail/swift-evolution/2015-December/000114.html &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000114.html&gt;<br>&gt;&gt; - &quot;Request for Discussion: Setup closures&quot;: https://lists.swift.org/pipermail/swift-evolution/2015-December/000211.html &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000211.html&gt;<br>&gt;&gt; - &quot;Method cascading (was Re: Request for Discussion: Setup closures)&quot;: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000729.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000729.html&gt;<br>&gt;&gt; - &quot;Fluent syntax (replacing void with a useful default return value)&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/374 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/374&gt;<br>&gt;&gt; - &quot;Lexical scope statement (with .. do)&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/1408 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/1408&gt;<br>&gt;&gt; - &quot;Scoped resources (like C# using statement)&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/1641 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/1641&gt;<br>&gt;&gt; - &quot;Customized Inline Init Closure&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/1946 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/1946&gt;<br>&gt;&gt; - &quot;Then Support&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/2054 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/2054&gt;<br>&gt;&gt; - &quot;Draft proposal: multi-property assignment .= operator&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/2960 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/2960&gt;<br>&gt;&gt; - &quot;Custom default names for arguments of closures&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/6969 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/6969&gt;<br>&gt;&gt; - https://bugs.swift.org/browse/SR-160 &lt;https://bugs.swift.org/browse/SR-160&gt;<br>&gt;&gt; <br>&gt;&gt; [2] https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver &lt;https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver&gt;<br>&gt;&gt; [3] https://github.com/devxoul/Then &lt;https://github.com/devxoul/Then&gt;<br>&gt;&gt; [4] https://github.com/Quick/Quick &lt;https://github.com/Quick/Quick&gt;<br>&gt;&gt; [5] https://github.com/kylef/Spectre &lt;https://github.com/kylef/Spectre&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/5881a786/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
