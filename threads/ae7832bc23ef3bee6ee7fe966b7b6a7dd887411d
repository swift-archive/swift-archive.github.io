<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/80cc9ac2aefba975bdbf2881e3df8238?s=50"></div><header><strong>NSMutableData memory leak</strong> from <string>Ian Partridge</string> &lt;ipartridge at gmail.com&gt;<p>May 16, 2016 at 05:00:00pm</p></header><div class="content"><p>import Foundation<br>while true {<br>  var myData: NSMutableData? = NSMutableData(capacity: 0)<br>  myData = nil<br>}<br></p><p><br>Running this infinite loop with swift-corelibs-foundation shows a steady<br>memory leak, with the process&#39;s RSS increasing over time.  No leak is seen<br>with Foundation on Darwin.<br></p><p>Instrumenting with Valgrind&#39;s massif profiler shows this stacktrace is<br>responsible for the leak:<br></p><p>67.36% (114,349B) (heap allocation functions) malloc/new/new[],<br>--alloc-fns, etc.<br>-&gt;65.01% (110,352B) 0x59F7A89: _CFDataInit<br>  -&gt;65.01% (110,352B) 0x5B8A8DF:<br>_TTSf4n_n_n_g_n___TFC10Foundation6NSDatacfT5bytesGSqGSpT___6lengthSi4copySb11deallocatorGSqFTGSpT__Si_T___S0_<br>    -&gt;65.01% (110,352B) 0x5B873ED:<br>_TFC10Foundation13NSMutableDataCfT8capacitySi_GSqS0__<br>      -&gt;65.01% (110,352B) 0x40105D: main<br></p><p>I&#39;ve stepped through the code with a debugger and observed that the<br>requested capacity is thrown away<br>&lt;https://github.com/apple/swift-corelibs-foundation/blob/df239bbbdf5bcdd9ea31c394c6af4dd7c328f99d/Foundation/NSData.swift#L904&gt;<br>[1]<br>to begin with.  The leak occurs regardless of the capacity requested.<br></p><p>The deinitializer for NSData does call through to _CFDeinit(), which does<br>then call the finalize()<br>&lt;https://github.com/apple/swift-corelibs-foundation/blob/ea6179dd35be2c7d9a8f953579f626a5f1be6511/CoreFoundation/Base.subproj/CFRuntime.c#L1773&gt;<br>[2]<br>function and hence through to __CFDataDeallocate()<br>&lt;https://github.com/apple/swift-corelibs-foundation/blob/ea3014bd7883e428727272118cbf37dc56522be6/CoreFoundation/Collections.subproj/CFData.c#L294&gt;<br>[3].<br>However, once in __CFDataDeallocate(), the code to free the buffer is<br>skipped, because __kCFDontDeallocate is set.<br></p><p>If I hack _CFDataInit() so that __kCFDontDeallocate isn&#39;t set (by<br>commenting out this line<br>&lt;https://github.com/apple/swift-corelibs-foundation/blob/ea3014bd7883e428727272118cbf37dc56522be6/CoreFoundation/Collections.subproj/CFData.c#L337&gt;<br>[4])<br>then I get crashes elsewhere - so this obviously isn&#39;t the right approach.<br></p><p>I can see that some work has been done in this area<br>&lt;https://github.com/apple/swift-corelibs-foundation/commit/ea3014bd7883e428727272118cbf37dc56522be6&gt;<br>[5]<br>previously by Philippe so I&#39;m wondering if anyone can advise on what might<br>be going on here?<br></p><p>The init?(length:) initializer avoids CFData entirely and calls malloc()<br>and free() directly.  I&#39;m not sure why that approach was taken and whether<br>it&#39;s relevant to my issue.<br></p><p>Any help would be gratefully received!<br></p><p>Thanks,<br></p><p>[1]<br>https://github.com/apple/swift-corelibs-foundation/blob/df239bbbdf5bcdd9ea31c394c6af4dd7c328f99d/Foundation/NSData.swift#L904<br>[2]<br>https://github.com/apple/swift-corelibs-foundation/blob/ea6179dd35be2c7d9a8f953579f626a5f1be6511/CoreFoundation/Base.subproj/CFRuntime.c#L1773<br>[3]<br>https://github.com/apple/swift-corelibs-foundation/blob/ea3014bd7883e428727272118cbf37dc56522be6/CoreFoundation/Collections.subproj/CFData.c#L294<br>[4]<br>https://github.com/apple/swift-corelibs-foundation/blob/ea3014bd7883e428727272118cbf37dc56522be6/CoreFoundation/Collections.subproj/CFData.c#L337<br>[5]<br>https://github.com/apple/swift-corelibs-foundation/commit/ea3014bd7883e428727272118cbf37dc56522be6<br></p><p>-- <br>Ian Partridge<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160516/ae78411d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>NSMutableData memory leak</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>May 16, 2016 at 09:00:00am</p></header><div class="content"><p>I think there is probably some likely issue with the fact that NSMutableData is a subclass and the layout initialization is not properly setup during the init for that object.<br></p><p>__kCFDontDeallocate is used to mark the allocated memory as managed by the deallocator blocks. So I bet the problem is that the code-path for NSMutableData(capacity: 0) is hitting the donâ€™t deallocate code path incorrectly (where as the other versions are hitting the appropriate flagging; hence the crashes)<br></p><p>Does this also occur in the Darwin builds of this? (Using SwiftFoundtion instead of Foundation)<br></p><p>&gt; On May 16, 2016, at 9:34 AM, Ian Partridge via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; while true {<br>&gt;   var myData: NSMutableData? = NSMutableData(capacity: 0)<br>&gt;   myData = nil<br>&gt; }<br>&gt; <br>&gt; Running this infinite loop with swift-corelibs-foundation shows a steady memory leak, with the process&#39;s RSS increasing over time.  No leak is seen with Foundation on Darwin.<br>&gt; <br>&gt; Instrumenting with Valgrind&#39;s massif profiler shows this stacktrace is responsible for the leak:<br>&gt; <br>&gt; 67.36% (114,349B) (heap allocation functions) malloc/new/new[], --alloc-fns, etc.<br>&gt; -&gt;65.01% (110,352B) 0x59F7A89: _CFDataInit<br>&gt;   -&gt;65.01% (110,352B) 0x5B8A8DF: _TTSf4n_n_n_g_n___TFC10Foundation6NSDatacfT5bytesGSqGSpT___6lengthSi4copySb11deallocatorGSqFTGSpT__Si_T___S0_<br>&gt;     -&gt;65.01% (110,352B) 0x5B873ED: _TFC10Foundation13NSMutableDataCfT8capacitySi_GSqS0__<br>&gt;       -&gt;65.01% (110,352B) 0x40105D: main<br>&gt; I&#39;ve stepped through the code with a debugger and observed that the requested capacity is thrown away &lt;https://github.com/apple/swift-corelibs-foundation/blob/df239bbbdf5bcdd9ea31c394c6af4dd7c328f99d/Foundation/NSData.swift#L904&gt; [1] to begin with.  The leak occurs regardless of the capacity requested.<br>&gt; <br>&gt; The deinitializer for NSData does call through to _CFDeinit(), which does then call the finalize() &lt;https://github.com/apple/swift-corelibs-foundation/blob/ea6179dd35be2c7d9a8f953579f626a5f1be6511/CoreFoundation/Base.subproj/CFRuntime.c#L1773&gt; [2] function and hence through to __CFDataDeallocate() &lt;https://github.com/apple/swift-corelibs-foundation/blob/ea3014bd7883e428727272118cbf37dc56522be6/CoreFoundation/Collections.subproj/CFData.c#L294&gt; [3].  However, once in __CFDataDeallocate(), the code to free the buffer is skipped, because __kCFDontDeallocate is set.<br>&gt; <br>&gt; If I hack _CFDataInit() so that __kCFDontDeallocate isn&#39;t set (by commenting out this line &lt;https://github.com/apple/swift-corelibs-foundation/blob/ea3014bd7883e428727272118cbf37dc56522be6/CoreFoundation/Collections.subproj/CFData.c#L337&gt; [4]) then I get crashes elsewhere - so this obviously isn&#39;t the right approach.<br>&gt; <br>&gt; I can see that some work has been done in this area &lt;https://github.com/apple/swift-corelibs-foundation/commit/ea3014bd7883e428727272118cbf37dc56522be6&gt; [5] previously by Philippe so I&#39;m wondering if anyone can advise on what might be going on here?<br>&gt; <br>&gt; The init?(length:) initializer avoids CFData entirely and calls malloc() and free() directly.  I&#39;m not sure why that approach was taken and whether it&#39;s relevant to my issue.<br>&gt; <br>&gt; Any help would be gratefully received!<br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; [1] https://github.com/apple/swift-corelibs-foundation/blob/df239bbbdf5bcdd9ea31c394c6af4dd7c328f99d/Foundation/NSData.swift#L904 &lt;https://github.com/apple/swift-corelibs-foundation/blob/df239bbbdf5bcdd9ea31c394c6af4dd7c328f99d/Foundation/NSData.swift#L904&gt;<br>&gt; [2] https://github.com/apple/swift-corelibs-foundation/blob/ea6179dd35be2c7d9a8f953579f626a5f1be6511/CoreFoundation/Base.subproj/CFRuntime.c#L1773 &lt;https://github.com/apple/swift-corelibs-foundation/blob/ea6179dd35be2c7d9a8f953579f626a5f1be6511/CoreFoundation/Base.subproj/CFRuntime.c#L1773&gt;<br>&gt; [3] https://github.com/apple/swift-corelibs-foundation/blob/ea3014bd7883e428727272118cbf37dc56522be6/CoreFoundation/Collections.subproj/CFData.c#L294 &lt;https://github.com/apple/swift-corelibs-foundation/blob/ea3014bd7883e428727272118cbf37dc56522be6/CoreFoundation/Collections.subproj/CFData.c#L294&gt;<br>&gt; [4] https://github.com/apple/swift-corelibs-foundation/blob/ea3014bd7883e428727272118cbf37dc56522be6/CoreFoundation/Collections.subproj/CFData.c#L337 &lt;https://github.com/apple/swift-corelibs-foundation/blob/ea3014bd7883e428727272118cbf37dc56522be6/CoreFoundation/Collections.subproj/CFData.c#L337&gt;<br>&gt; [5] https://github.com/apple/swift-corelibs-foundation/commit/ea3014bd7883e428727272118cbf37dc56522be6 &lt;https://github.com/apple/swift-corelibs-foundation/commit/ea3014bd7883e428727272118cbf37dc56522be6&gt;<br>&gt; <br>&gt; -- <br>&gt; Ian Partridge<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160516/58049ac4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/80cc9ac2aefba975bdbf2881e3df8238?s=50"></div><header><strong>NSMutableData memory leak</strong> from <string>Ian Partridge</string> &lt;ipartridge at gmail.com&gt;<p>May 16, 2016 at 05:00:00pm</p></header><div class="content"><p>On 16 May 2016 at 17:43, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; I think there is probably some likely issue with the fact that NSMutableData is a subclass and the layout initialization is not properly setup during the init for that object.<br>&gt;<br>&gt; __kCFDontDeallocate is used to mark the allocated memory as managed by the deallocator blocks. So I bet the problem is that the code-path for NSMutableData(capacity: 0) is hitting the donâ€™t deallocate code path incorrectly (where as the other versions are hitting the appropriate flagging; hence the crashes)<br>&gt;<br>&gt; Does this also occur in the Darwin builds of this? (Using SwiftFoundtion instead of Foundation)<br></p><p>Yes, I have been investigating this using a new TestNSData test under XCode.<br></p><p>-- <br>Ian Partridge<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/80cc9ac2aefba975bdbf2881e3df8238?s=50"></div><header><strong>NSMutableData memory leak</strong> from <string>Ian Partridge</string> &lt;ipartridge at gmail.com&gt;<p>May 18, 2016 at 04:00:00pm</p></header><div class="content"><p>We&#39;re continuing to investigate this, and have raised SR-1552 to track<br>it - https://bugs.swift.org/browse/SR-1552<br></p><p>-- <br>Ian Partridge<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
