<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 27, 2016 at 12:00:00pm</p></header><div class="content"><p>on Sat Jun 25 2016, Austin Zheng &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jun 25, 2016, at 6:23 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Austin,<br>&gt;&gt; <br>&gt;&gt; I’m sorry to say, but this proposal makes me really sad.  I consider<br>&gt;&gt; associated type inference one of the more elegant aspects of Swift.<br>&gt;&gt; It would be very unfortunate to lose it.<br>&gt;<br>&gt; There are lots of &quot;elegant&quot; things that Swift could do, but has chosen<br>&gt; not to do for pragmatic reasons (e.g. generalized implicit<br>&gt; conversions, type inference that crosses statement boundaries). Given<br>&gt; how terrible the development experience can be right now in the worst<br>&gt; case, I would happily trade off some measure of convenience for better<br>&gt; tooling.<br></p><p>Well, the type checker&#39;s inference engine has *always* been kinda<br>unreliable, and the experience is made much worse by the lack of<br>recursive protocol requirements and the inability to express other<br>constraints that would better guide inference, and by the “underscored<br>protocols” such as _Indexable that are required to work around those<br>limitations.  IMO it&#39;s premature to remove this feature before the<br>inference engine is made sane, the generics features are added, and the<br>library is correspondingly cleaned up, because we don&#39;t really know what<br>the user experience would be.<br></p><p>Finally, I am very concerned that there are protocols such as Collection,<br>with many inferrable associated types, and that conforming to these<br>protocols could become *much* uglier.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 27, 2016 at 01:00:00pm</p></header><div class="content"><p>Thanks for your response, Dave.<br></p><p>There is a bit of a dilemma here: wait until the generics and type system<br>features have stabilized at the risk of making major source-breaking<br>changes after 3.0, or make changes now without clarity about the future of<br>the generics system.<br></p><p>Given that this topic showed up both in Chris&#39;s list of open design topics<br>and in the generics manifesto, I assume that someone on the core team<br>wanted a discussion about it before Swift 3 closes. I would be interested<br>in knowing if that&#39;s true.<br></p><p>Best,<br>Austin<br></p><p><br></p><p>On Mon, Jun 27, 2016 at 12:56 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Sat Jun 25 2016, Austin Zheng &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; On Jun 25, 2016, at 6:23 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Hi Austin,<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’m sorry to say, but this proposal makes me really sad.  I consider<br>&gt; &gt;&gt; associated type inference one of the more elegant aspects of Swift.<br>&gt; &gt;&gt; It would be very unfortunate to lose it.<br>&gt; &gt;<br>&gt; &gt; There are lots of &quot;elegant&quot; things that Swift could do, but has chosen<br>&gt; &gt; not to do for pragmatic reasons (e.g. generalized implicit<br>&gt; &gt; conversions, type inference that crosses statement boundaries). Given<br>&gt; &gt; how terrible the development experience can be right now in the worst<br>&gt; &gt; case, I would happily trade off some measure of convenience for better<br>&gt; &gt; tooling.<br>&gt;<br>&gt; Well, the type checker&#39;s inference engine has *always* been kinda<br>&gt; unreliable, and the experience is made much worse by the lack of<br>&gt; recursive protocol requirements and the inability to express other<br>&gt; constraints that would better guide inference, and by the “underscored<br>&gt; protocols” such as _Indexable that are required to work around those<br>&gt; limitations.  IMO it&#39;s premature to remove this feature before the<br>&gt; inference engine is made sane, the generics features are added, and the<br>&gt; library is correspondingly cleaned up, because we don&#39;t really know what<br>&gt; the user experience would be.<br>&gt;<br>&gt; Finally, I am very concerned that there are protocols such as Collection,<br>&gt; with many inferrable associated types, and that conforming to these<br>&gt; protocols could become *much* uglier.<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/c6ebbe82/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 27, 2016 at 03:00:00pm</p></header><div class="content"><p>on Mon Jun 27 2016, Austin Zheng &lt;austinzheng-AT-gmail.com&gt; wrote:<br></p><p>&gt; Thanks for your response, Dave.<br>&gt;<br>&gt; There is a bit of a dilemma here: wait until the generics and type system<br>&gt; features have stabilized at the risk of making major source-breaking<br>&gt; changes after 3.0, or make changes now without clarity about the future of<br>&gt; the generics system.<br>&gt;<br>&gt; Given that this topic showed up both in Chris&#39;s list of open design topics<br>&gt; and in the generics manifesto, I assume that someone on the core team<br>&gt; wanted a discussion about it before Swift 3 closes. I would be interested<br>&gt; in knowing if that&#39;s true.<br></p><p>I don&#39;t know anything more than you do, I&#39;m afraid.<br></p><p>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt; On Mon, Jun 27, 2016 at 12:56 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Sat Jun 25 2016, Austin Zheng &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; On Jun 25, 2016, at 6:23 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Hi Austin,<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I’m sorry to say, but this proposal makes me really sad.  I consider<br>&gt;&gt; &gt;&gt; associated type inference one of the more elegant aspects of Swift.<br>&gt;&gt; &gt;&gt; It would be very unfortunate to lose it.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; There are lots of &quot;elegant&quot; things that Swift could do, but has chosen<br>&gt;&gt; &gt; not to do for pragmatic reasons (e.g. generalized implicit<br>&gt;&gt; &gt; conversions, type inference that crosses statement boundaries). Given<br>&gt;&gt; &gt; how terrible the development experience can be right now in the worst<br>&gt;&gt; &gt; case, I would happily trade off some measure of convenience for better<br>&gt;&gt; &gt; tooling.<br>&gt;&gt;<br>&gt;&gt; Well, the type checker&#39;s inference engine has *always* been kinda<br>&gt;&gt; unreliable, and the experience is made much worse by the lack of<br>&gt;&gt; recursive protocol requirements and the inability to express other<br>&gt;&gt; constraints that would better guide inference, and by the “underscored<br>&gt;&gt; protocols” such as _Indexable that are required to work around those<br>&gt;&gt; limitations.  IMO it&#39;s premature to remove this feature before the<br>&gt;&gt; inference engine is made sane, the generics features are added, and the<br>&gt;&gt; library is correspondingly cleaned up, because we don&#39;t really know what<br>&gt;&gt; the user experience would be.<br>&gt;&gt;<br>&gt;&gt; Finally, I am very concerned that there are protocols such as Collection,<br>&gt;&gt; with many inferrable associated types, and that conforming to these<br>&gt;&gt; protocols could become *much* uglier.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p><p>-- <br>Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 28, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 12:56 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat Jun 25 2016, Austin Zheng &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 25, 2016, at 6:23 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Austin,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m sorry to say, but this proposal makes me really sad.  I consider<br>&gt;&gt;&gt; associated type inference one of the more elegant aspects of Swift.<br>&gt;&gt;&gt; It would be very unfortunate to lose it.<br>&gt;&gt; <br>&gt;&gt; There are lots of &quot;elegant&quot; things that Swift could do, but has chosen<br>&gt;&gt; not to do for pragmatic reasons (e.g. generalized implicit<br>&gt;&gt; conversions, type inference that crosses statement boundaries). Given<br>&gt;&gt; how terrible the development experience can be right now in the worst<br>&gt;&gt; case, I would happily trade off some measure of convenience for better<br>&gt;&gt; tooling.<br>&gt; <br>&gt; Well, the type checker&#39;s inference engine has *always* been kinda<br>&gt; unreliable,<br></p><p>Dave is dramatically understating the pain that this inference has caused. Because this is the only place we do global type inference, it’s put tremendous pressure on the type checker that caused a huge number of bugs, crashes, and outright incomprehensible behavior. I reimplemented the inference of associated type witnesses in April of 2015 (https://github.com/apple/swift/commit/126e404fe5bf0be81206f22c83a61f6689d18854 &lt;https://github.com/apple/swift/commit/126e404fe5bf0be81206f22c83a61f6689d18854&gt;, for reference), when the existing implementation unbearable. It got *far* better, but it’s still not global *enough* to actually be predictable, and the legacy of this mis-feature manifests in a number of weird ways (e.g., typealiases in protocol extensions cannot be used to satisfy associated type requirements, weird rules for when a defaulted associated type gets used).<br></p><p>&gt; and the experience is made much worse by the lack of<br>&gt; recursive protocol requirements and the inability to express other<br>&gt; constraints that would better guide inference, and by the “underscored<br>&gt; protocols” such as _Indexable that are required to work around those<br>&gt; limitations.  IMO it&#39;s premature to remove this feature before the<br>&gt; inference engine is made sane, the generics features are added, and the<br>&gt; library is correspondingly cleaned up, because we don&#39;t really know what<br>&gt; the user experience would be.<br></p><p>Well, there’s a chicken-and-egg problem. The complexity of this inference is getting in the way of other improvements. For example, inference of associated types for conditional conformances requires that associated type witness deduction consider additional requirements, which is a complexity we would entirely avoid<br></p><p>&gt; Finally, I am very concerned that there are protocols such as Collection,<br>&gt; with many inferrable associated types, and that conforming to these<br>&gt; protocols could become *much* uglier.<br></p><p>That’s the general concern I have as well: how much boilerplate does this add? In many cases, we get some of the associated type witnesses for Collection types for free, and I don’t know to what extent we can emulate that with defaulted associated type requirements and typealiases in protocol extensions.<br></p><p>That said, I’ll take some minor regressions in this area for the massive simplification that this proposal brings.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/641a34c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 28, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 1:25 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 12:56 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sat Jun 25 2016, Austin Zheng &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 25, 2016, at 6:23 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Austin,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m sorry to say, but this proposal makes me really sad.  I consider<br>&gt;&gt;&gt;&gt; associated type inference one of the more elegant aspects of Swift.<br>&gt;&gt;&gt;&gt; It would be very unfortunate to lose it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are lots of &quot;elegant&quot; things that Swift could do, but has chosen<br>&gt;&gt;&gt; not to do for pragmatic reasons (e.g. generalized implicit<br>&gt;&gt;&gt; conversions, type inference that crosses statement boundaries). Given<br>&gt;&gt;&gt; how terrible the development experience can be right now in the worst<br>&gt;&gt;&gt; case, I would happily trade off some measure of convenience for better<br>&gt;&gt;&gt; tooling.<br>&gt;&gt; <br>&gt;&gt; Well, the type checker&#39;s inference engine has *always* been kinda<br>&gt;&gt; unreliable,<br>&gt; <br>&gt; Dave is dramatically understating the pain that this inference has caused. Because this is the only place we do global type inference, it’s put tremendous pressure on the type checker that caused a huge number of bugs, crashes, and outright incomprehensible behavior. I reimplemented the inference of associated type witnesses in April of 2015 (https://github.com/apple/swift/commit/126e404fe5bf0be81206f22c83a61f6689d18854 &lt;https://github.com/apple/swift/commit/126e404fe5bf0be81206f22c83a61f6689d18854&gt;, for reference), when the existing implementation unbearable. It got *far* better, but it’s still not global *enough* to actually be predictable, and the legacy of this mis-feature manifests in a number of weird ways (e.g., typealiases in protocol extensions cannot be used to satisfy associated type requirements, weird rules for when a defaulted associated type gets used).<br>&gt; <br>&gt;&gt; and the experience is made much worse by the lack of<br>&gt;&gt; recursive protocol requirements and the inability to express other<br>&gt;&gt; constraints that would better guide inference, and by the “underscored<br>&gt;&gt; protocols” such as _Indexable that are required to work around those<br>&gt;&gt; limitations.  IMO it&#39;s premature to remove this feature before the<br>&gt;&gt; inference engine is made sane, the generics features are added, and the<br>&gt;&gt; library is correspondingly cleaned up, because we don&#39;t really know what<br>&gt;&gt; the user experience would be.<br>&gt; <br>&gt; Well, there’s a chicken-and-egg problem. The complexity of this inference is getting in the way of other improvements. For example, inference of associated types for conditional conformances requires that associated type witness deduction consider additional requirements, which is a complexity we would entirely avoid<br>&gt; <br>&gt;&gt; Finally, I am very concerned that there are protocols such as Collection,<br>&gt;&gt; with many inferrable associated types, and that conforming to these<br>&gt;&gt; protocols could become *much* uglier.<br>&gt; <br>&gt; That’s the general concern I have as well: how much boilerplate does this add? In many cases, we get some of the associated type witnesses for Collection types for free, and I don’t know to what extent we can emulate that with defaulted associated type requirements and typealiases in protocol extensions.<br>&gt; <br>&gt; That said, I’ll take some minor regressions in this area for the massive simplification that this proposal brings.<br></p><p>Do you have any comments on Dmitri’s suggested alternative?  I would like to see that discussed before any proposals are reviewed.  That discussion is likely to influence my opinion quite a bit.<br></p><p>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/352e0ab6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19ca8ea29768acdbb87dc016d7d9a8e4?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Paulo Faria</string> &lt;paulo at zewo.io&gt;<p>June 29, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 3:34 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Finally, I am very concerned that there are protocols such as Collection,<br>&gt;&gt;&gt; with many inferrable associated types, and that conforming to these<br>&gt;&gt;&gt; protocols could become *much* uglier.<br></p><p>Unfortunately I have a specific use case in which this argument would be very strong.<br></p><p>Basically this:<br></p><p>extension TodoController : ResourceController {}<br></p><p>Would have to become this:<br></p><p>extension TodoController : ResourceController {<br>    public typealias CreateInput = Todo<br>    public typealias UpdateInput = Todo<br></p><p>    public typealias ListOutput = Todo<br>    public typealias CreateOutput = Todo<br>    public typealias DetailOutput = Todo<br>    public typealias UpdateOutput = Todo<br></p><p>    public typealias DetailID = String<br>    public typealias UpdateID = String<br>    public typealias DestroyID = String<br>}<br></p><p>I could reduce the amount of associated types but this would reduce the flexibility of the protocol by a huge factor and would make it much less powerful. I’m very torn about this because I do want generics to get better. Specifically I’m looking forward to conditional conformances. But this would be a too high cost imho. I know this is just one example. But maybe there are more examples like this out there. I have to admit this one really got to me. :(<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/e3658baa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 9:45 PM, Paulo Faria &lt;paulo at zewo.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 28, 2016, at 3:34 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Finally, I am very concerned that there are protocols such as Collection,<br>&gt;&gt;&gt;&gt; with many inferrable associated types, and that conforming to these<br>&gt;&gt;&gt;&gt; protocols could become *much* uglier.<br>&gt; <br>&gt; Unfortunately I have a specific use case in which this argument would be very strong.<br>&gt; <br>&gt; Basically this:<br>&gt; <br>&gt; extension TodoController : ResourceController {}<br>&gt; <br>&gt; Would have to become this:<br>&gt; <br>&gt; extension TodoController : ResourceController {<br>&gt;     public typealias CreateInput = Todo<br>&gt;     public typealias UpdateInput = Todo<br>&gt; <br>&gt;     public typealias ListOutput = Todo<br>&gt;     public typealias CreateOutput = Todo<br>&gt;     public typealias DetailOutput = Todo<br>&gt;     public typealias UpdateOutput = Todo<br>&gt; <br>&gt;     public typealias DetailID = String<br>&gt;     public typealias UpdateID = String<br>&gt;     public typealias DestroyID = String<br>&gt; }<br>&gt; <br>&gt; I could reduce the amount of associated types but this would reduce the flexibility of the protocol by a huge factor and would make it much less powerful. I’m very torn about this because I do want generics to get better. Specifically I’m looking forward to conditional conformances. But this would be a too high cost imho. I know this is just one example. But maybe there are more examples like this out there. I have to admit this one really got to me. :(<br></p><p><br>Do these associated types have meaningful defaults? We’re not talking about eliminating the ability to have default types for associated types, e.g.,<br></p><p>	public protocol ResourceController {<br>	  associatedtype CreateInput<br>	  associatedtype UpdateInput = CreateInput<br></p><p>	  associatedtype ListOutput<br>	  associatedtype CreateOutput = ListOutput<br>	  associatedtype DetailOutput = ListOutput<br>	  associatedtype UpdateOutput = ListOutput<br></p><p>	  associatedtype DetailID<br>	  associatedtype UpdateID = DetailID<br>	  associatedtype DestroyID = DetailID<br>	}<br></p><p>which might reduce the common case for conforming to the protocol to be, e.g.,<br></p><p>	extension TodoController : ResourceController {<br>	  public typealias CreateInput = Todo<br>	  public typealias ListOutput = Todo<br>	  public typealias DetailID = String<br>	}<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/0ded92e6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19ca8ea29768acdbb87dc016d7d9a8e4?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Paulo Faria</string> &lt;paulo at zewo.io&gt;<p>June 29, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 1:51 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; Do these associated types have meaningful defaults? We’re not talking about eliminating the ability to have default types for associated types, e.g.,<br>&gt; <br>&gt; 	public protocol ResourceController {<br>&gt; 	  associatedtype CreateInput<br>&gt; 	  associatedtype UpdateInput = CreateInput<br>&gt; <br>&gt; 	  associatedtype ListOutput<br>&gt; 	  associatedtype CreateOutput = ListOutput<br>&gt; 	  associatedtype DetailOutput = ListOutput<br>&gt; 	  associatedtype UpdateOutput = ListOutput<br>&gt; <br>&gt; 	  associatedtype DetailID<br>&gt; 	  associatedtype UpdateID = DetailID<br>&gt; 	  associatedtype DestroyID = DetailID<br>&gt; 	}<br>&gt; <br>&gt; which might reduce the common case for conforming to the protocol to be, e.g.,<br>&gt; <br>&gt; 	extension TodoController : ResourceController {<br>&gt; 	  public typealias CreateInput = Todo<br>&gt; 	  public typealias ListOutput = Todo<br>&gt; 	  public typealias DetailID = String<br>&gt; 	}<br>&gt; <br>&gt; 	- Doug<br></p><p>Unfortunately no. The whole purpose of having so many associated types is that the user can simply chose the types he wants to use as the input and output of each function required in the protocol.<br></p><p>public protocol ResourceController {<br>    associatedtype CreateInput: StructuredDataInitializable<br>    associatedtype UpdateInput: StructuredDataInitializable<br></p><p>    associatedtype ListOutput: StructuredDataFallibleRepresentable<br>    associatedtype CreateOutput: StructuredDataFallibleRepresentable<br>    associatedtype DetailOutput: StructuredDataFallibleRepresentable<br>    associatedtype UpdateOutput: StructuredDataFallibleRepresentable<br></p><p>    associatedtype DetailID: PathParameterInitializable<br>    associatedtype UpdateID: PathParameterInitializable<br>    associatedtype DestroyID: PathParameterInitializable<br></p><p>    func list() throws -&gt; [ListOutput]<br>    func create(element: CreateInput) throws -&gt; CreateOutput<br>    func detail(id: DetailID) throws -&gt; DetailOutput<br>    func update(id: UpdateID, element: UpdateInput) throws -&gt; UpdateOutput<br>    func destroy(id: DestroyID) throws<br>}<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/b4acdbe7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19ca8ea29768acdbb87dc016d7d9a8e4?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Paulo Faria</string> &lt;paulo at zewo.io&gt;<p>June 29, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 1:51 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; which might reduce the common case for conforming to the protocol to be, e.g.,<br></p><p>But yeah! I guess that could help In the case the type is the same! Thanks for the tip.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/b83e3acc/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19ca8ea29768acdbb87dc016d7d9a8e4?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Paulo Faria</string> &lt;paulo at zewo.io&gt;<p>June 29, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 1:51 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; which might reduce the common case for conforming to the protocol to be, e.g.,<br></p><p>Just discovered another horrible implication of type inference removal for the same use case. :OOO<br></p><p>This is the full code for the protocol<br></p><p>public protocol ResourceController {<br>    associatedtype DetailID: PathParameterInitializable = UpdateID<br>    associatedtype UpdateID: PathParameterInitializable<br>    associatedtype DestroyID: PathParameterInitializable = UpdateID<br></p><p>    associatedtype CreateInput: StructuredDataInitializable = UpdateInput<br>    associatedtype UpdateInput: StructuredDataInitializable<br></p><p>    associatedtype ListOutput: StructuredDataFallibleRepresentable = UpdateOutput<br>    associatedtype CreateOutput: StructuredDataFallibleRepresentable = UpdateOutput<br>    associatedtype DetailOutput: StructuredDataFallibleRepresentable = UpdateOutput<br>    associatedtype UpdateOutput: StructuredDataFallibleRepresentable<br></p><p>    func list() throws -&gt; [ListOutput]<br>    func create(element: CreateInput) throws -&gt; CreateOutput<br>    func detail(id: DetailID) throws -&gt; DetailOutput<br>    func update(id: UpdateID, element: UpdateInput) throws -&gt; UpdateOutput<br>    func destroy(id: DestroyID) throws<br>}<br></p><p>extension ResourceController {<br>    public func list() throws -&gt; [ListOutput] {<br>        throw ClientError.notFound<br>    }<br></p><p>    public func create(element: CreateInput) throws -&gt; CreateOutput {<br>        throw ClientError.notFound<br>    }<br></p><p>    public func detail(id: DetailID) throws -&gt; DetailOutput {<br>        throw ClientError.notFound<br>    }<br></p><p>    public func update(id: UpdateID, element: UpdateInput) throws -&gt; UpdateOutput {<br>        throw ClientError.notFound<br>    }<br></p><p>    public func destroy(id: DestroyID) throws {<br>        throw ClientError.notFound<br>    }<br>}<br></p><p>Suppose we have an implementation like this:<br></p><p>public struct TodoController : ResourceController {<br>    public typealias CreateInput = NotTodo<br>    public typealias UpdateInput = NotTodo<br></p><p>    public typealias ListOutput = NotTodo<br>    public typealias CreateOutput = NotTodo<br>    public typealias DetailOutput = NotTodo<br>    public typealias UpdateOutput = NotTodo<br></p><p>    public typealias DetailID = NotString<br>    public typealias UpdateID = NotString<br>    public typealias DestroyID = NotString<br></p><p>    public func list() throws -&gt; [Todo] {<br>        ...<br>    }<br></p><p>    public func create(element todo: Todo) throws -&gt; Todo {<br>        ...<br>    }<br></p><p>    public func detail(id: String) throws -&gt; Todo {<br>        ...<br>    }<br></p><p>    public func update(id: String, element todo: Todo) throws -&gt; Todo {<br>        ...<br>    }<br></p><p>    public func destroy(id: String) throws {<br>        ...<br>    }<br>}<br></p><p>Notice that the typealiases and the function declarations don’t match. But the compiler doesn’t complain because the protocol has default implementations in the protocol extension. This means that if the person implementing the protocol doesn’t make sure the types match exactly, there’s gonna be unexpected behaviour. Which I’m sure he/she will take quite some time to figure out. :(<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/46172673/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 28, 2016 at 10:00:00pm</p></header><div class="content"><p>I&#39;m not sure this is a problem. Once you bind the associated types explicitly, the requirements using those associated types need to match the bound types otherwise the type checker will emit an error. If you have default associated types and default implementations, but then bind the associated types differently and do not update your type-specific implementations to use those other types, you will get an error message. This is how explicitly specifying associated types works today.<br></p><p>Austin<br></p><p>&gt; On Jun 28, 2016, at 10:17 PM, Paulo Faria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 1:51 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; which might reduce the common case for conforming to the protocol to be, e.g.,<br>&gt; <br>&gt; Just discovered another horrible implication of type inference removal for the same use case. :OOO<br>&gt; <br>&gt; This is the full code for the protocol<br>&gt; <br>&gt; public protocol ResourceController {<br>&gt;     associatedtype DetailID: PathParameterInitializable = UpdateID<br>&gt;     associatedtype UpdateID: PathParameterInitializable<br>&gt;     associatedtype DestroyID: PathParameterInitializable = UpdateID<br>&gt; <br>&gt;     associatedtype CreateInput: StructuredDataInitializable = UpdateInput<br>&gt;     associatedtype UpdateInput: StructuredDataInitializable<br>&gt; <br>&gt;     associatedtype ListOutput: StructuredDataFallibleRepresentable = UpdateOutput<br>&gt;     associatedtype CreateOutput: StructuredDataFallibleRepresentable = UpdateOutput<br>&gt;     associatedtype DetailOutput: StructuredDataFallibleRepresentable = UpdateOutput<br>&gt;     associatedtype UpdateOutput: StructuredDataFallibleRepresentable<br>&gt; <br>&gt;     func list() throws -&gt; [ListOutput]<br>&gt;     func create(element: CreateInput) throws -&gt; CreateOutput<br>&gt;     func detail(id: DetailID) throws -&gt; DetailOutput<br>&gt;     func update(id: UpdateID, element: UpdateInput) throws -&gt; UpdateOutput<br>&gt;     func destroy(id: DestroyID) throws<br>&gt; }<br>&gt; <br>&gt; extension ResourceController {<br>&gt;     public func list() throws -&gt; [ListOutput] {<br>&gt;         throw ClientError.notFound<br>&gt;     }<br>&gt; <br>&gt;     public func create(element: CreateInput) throws -&gt; CreateOutput {<br>&gt;         throw ClientError.notFound<br>&gt;     }<br>&gt; <br>&gt;     public func detail(id: DetailID) throws -&gt; DetailOutput {<br>&gt;         throw ClientError.notFound<br>&gt;     }<br>&gt; <br>&gt;     public func update(id: UpdateID, element: UpdateInput) throws -&gt; UpdateOutput {<br>&gt;         throw ClientError.notFound<br>&gt;     }<br>&gt; <br>&gt;     public func destroy(id: DestroyID) throws {<br>&gt;         throw ClientError.notFound<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Suppose we have an implementation like this:<br>&gt; <br>&gt; public struct TodoController : ResourceController {<br>&gt;     public typealias CreateInput = NotTodo<br>&gt;     public typealias UpdateInput = NotTodo<br>&gt; <br>&gt;     public typealias ListOutput = NotTodo<br>&gt;     public typealias CreateOutput = NotTodo<br>&gt;     public typealias DetailOutput = NotTodo<br>&gt;     public typealias UpdateOutput = NotTodo<br>&gt; <br>&gt;     public typealias DetailID = NotString<br>&gt;     public typealias UpdateID = NotString<br>&gt;     public typealias DestroyID = NotString<br>&gt; <br>&gt;     public func list() throws -&gt; [Todo] {<br>&gt;         ...<br>&gt;     }<br>&gt; <br>&gt;     public func create(element todo: Todo) throws -&gt; Todo {<br>&gt;         ...<br>&gt;     }<br>&gt; <br>&gt;     public func detail(id: String) throws -&gt; Todo {<br>&gt;         ...<br>&gt;     }<br>&gt; <br>&gt;     public func update(id: String, element todo: Todo) throws -&gt; Todo {<br>&gt;         ...<br>&gt;     }<br>&gt; <br>&gt;     public func destroy(id: String) throws {<br>&gt;         ...<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Notice that the typealiases and the function declarations don’t match. But the compiler doesn’t complain because the protocol has default implementations in the protocol extension. This means that if the person implementing the protocol doesn’t make sure the types match exactly, there’s gonna be unexpected behaviour. Which I’m sure he/she will take quite some time to figure out. :(<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/09bf8238/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19ca8ea29768acdbb87dc016d7d9a8e4?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Paulo Faria</string> &lt;paulo at zewo.io&gt;<p>June 29, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 2:28 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m not sure this is a problem. Once you bind the associated types explicitly, the requirements using those associated types need to match the bound types otherwise the type checker will emit an error. If you have default associated types and default implementations, but then bind the associated types differently and do not update your type-specific implementations to use those other types, you will get an error message. This is how explicitly specifying associated types works today.<br>&gt; <br>&gt; Austin<br></p><p>The problem is that it doesn’t give me any error message. I tested it.<br> <br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/bf0833cb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 28, 2016 at 10:00:00pm</p></header><div class="content"><p>If you tested it, there&#39;s a problem with the current behavior independent of associated type inference, and it should be fixed whether or not the proposal is accepted.<br></p><p>&gt; On Jun 28, 2016, at 10:47 PM, Paulo Faria &lt;paulo at zewo.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 2:28 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure this is a problem. Once you bind the associated types explicitly, the requirements using those associated types need to match the bound types otherwise the type checker will emit an error. If you have default associated types and default implementations, but then bind the associated types differently and do not update your type-specific implementations to use those other types, you will get an error message. This is how explicitly specifying associated types works today.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt; <br>&gt; The problem is that it doesn’t give me any error message. I tested it.<br>&gt;  <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/e77d5bcc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19ca8ea29768acdbb87dc016d7d9a8e4?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Paulo Faria</string> &lt;paulo at zewo.io&gt;<p>June 29, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 2:48 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; If you tested it, there&#39;s a problem with the current behavior independent of associated type inference, and it should be fixed whether or not the proposal is accepted.<br></p><p>I don’t think it should be an error. Normally we can have any number of functions with the same name but different return types. By failing in this specific case would be like saying that when you implement a protocol with an associated type you can only return what’s defined in the associated type. I don’t think that should be the behaviour we expect.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/49a178fe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 28, 2016 at 10:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jun 28, 2016, at 10:51 PM, Paulo Faria &lt;paulo at zewo.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 2:48 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If you tested it, there&#39;s a problem with the current behavior independent of associated type inference, and it should be fixed whether or not the proposal is accepted.<br>&gt; <br>&gt; I don’t think it should be an error. Normally we can have any number of functions with the same name but different return types. By failing in this specific case would be like saying that when you implement a protocol with an associated type you can only return what’s defined in the associated type. I don’t think that should be the behaviour we expect.<br></p><p>This seems very related to the near-miss checking I mentioned in my other reply to Austin. <br></p><p>  - Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/112e7aa8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19ca8ea29768acdbb87dc016d7d9a8e4?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Paulo Faria</string> &lt;paulo at zewo.io&gt;<p>June 29, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 2:54 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; This seems very related to the near-miss checking I mentioned in my other reply to Austin. <br></p><p>Yeah. Well, if we get the error message. It’s better than nothing. I don’t know the specifics about compilers and rules and what not. But it seems to me it would be opening an exception just for that specific case. And that might be something that would make the compiler rules more complex. So if we don’t get the message, we get more consistency in the rules, but on the other hand we make it easier for people to accidentally get unexpected behaviour. <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/33e1c294/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19ca8ea29768acdbb87dc016d7d9a8e4?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Paulo Faria</string> &lt;paulo at zewo.io&gt;<p>June 29, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 2:54 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Jun 28, 2016, at 10:51 PM, Paulo Faria &lt;paulo at zewo.io &lt;mailto:paulo at zewo.io&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 2:48 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you tested it, there&#39;s a problem with the current behavior independent of associated type inference, and it should be fixed whether or not the proposal is accepted.<br>&gt;&gt; <br>&gt;&gt; I don’t think it should be an error. Normally we can have any number of functions with the same name but different return types. By failing in this specific case would be like saying that when you implement a protocol with an associated type you can only return what’s defined in the associated type. I don’t think that should be the behaviour we expect.<br>&gt; <br>&gt; This seems very related to the near-miss checking I mentioned in my other reply to Austin. <br>&gt; <br>&gt;   - Doug<br>&gt; <br></p><p>Actually, the more I think about it I get the conclusion that It really shouldn’t be an error. Otherwise this would mean that you wouldn’t be able to use the default implementation and have a function with the same name but returning another type. And if we can’t get an error; We’re just making it easier for the bugs by forcing one to keep the typealias and his own implementation in sync. With inference this wouldn’t exist. This is a really hard one. Looks like the decision is already made. If this is really the case; All I can say is that I really hope this comes back in Swift 4. <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/906e3f2c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 28, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 11:36 PM, Paulo Faria &lt;paulo at zewo.io&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 29, 2016, at 2:54 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On Jun 28, 2016, at 10:51 PM, Paulo Faria &lt;paulo at zewo.io &lt;mailto:paulo at zewo.io&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 2:48 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you tested it, there&#39;s a problem with the current behavior independent of associated type inference, and it should be fixed whether or not the proposal is accepted.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think it should be an error. Normally we can have any number of functions with the same name but different return types. By failing in this specific case would be like saying that when you implement a protocol with an associated type you can only return what’s defined in the associated type. I don’t think that should be the behaviour we expect.<br>&gt;&gt; <br>&gt;&gt; This seems very related to the near-miss checking I mentioned in my other reply to Austin. <br>&gt;&gt; <br>&gt;&gt;   - Doug<br>&gt;&gt; <br>&gt; <br>&gt; Actually, the more I think about it I get the conclusion that It really shouldn’t be an error. Otherwise this would mean that you wouldn’t be able to use the default implementation and have a function with the same name but returning another type. And if we can’t get an error; We’re just making it easier for the bugs by forcing one to keep the typealias and his own implementation in sync. With inference this wouldn’t exist. This is a really hard one. Looks like the decision is already made. If this is really the case; All I can say is that I really hope this comes back in Swift 4. <br></p><p>For reference, my implementation makes it a warning, not an error, and you can suppress the warning by moving the similar-but-not-selected declaration to a different extension.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/ac58dfa1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19ca8ea29768acdbb87dc016d7d9a8e4?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Paulo Faria</string> &lt;paulo at zewo.io&gt;<p>June 29, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 3:40 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 28, 2016, at 11:36 PM, Paulo Faria &lt;paulo at zewo.io &lt;mailto:paulo at zewo.io&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 2:54 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 10:51 PM, Paulo Faria &lt;paulo at zewo.io &lt;mailto:paulo at zewo.io&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 2:48 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you tested it, there&#39;s a problem with the current behavior independent of associated type inference, and it should be fixed whether or not the proposal is accepted.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t think it should be an error. Normally we can have any number of functions with the same name but different return types. By failing in this specific case would be like saying that when you implement a protocol with an associated type you can only return what’s defined in the associated type. I don’t think that should be the behaviour we expect.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This seems very related to the near-miss checking I mentioned in my other reply to Austin. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   - Doug<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Actually, the more I think about it I get the conclusion that It really shouldn’t be an error. Otherwise this would mean that you wouldn’t be able to use the default implementation and have a function with the same name but returning another type. And if we can’t get an error; We’re just making it easier for the bugs by forcing one to keep the typealias and his own implementation in sync. With inference this wouldn’t exist. This is a really hard one. Looks like the decision is already made. If this is really the case; All I can say is that I really hope this comes back in Swift 4. <br>&gt; <br>&gt; For reference, my implementation makes it a warning, not an error, and you can suppress the warning by moving the similar-but-not-selected declaration to a different extension.<br>&gt; <br>&gt; 	- Doug<br></p><p>Your implementation is the current one?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/859e6de3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 28, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 11:43 PM, Paulo Faria &lt;paulo at zewo.io&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 29, 2016, at 3:40 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 11:36 PM, Paulo Faria &lt;paulo at zewo.io &lt;mailto:paulo at zewo.io&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 2:54 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 28, 2016, at 10:51 PM, Paulo Faria &lt;paulo at zewo.io &lt;mailto:paulo at zewo.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 2:48 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If you tested it, there&#39;s a problem with the current behavior independent of associated type inference, and it should be fixed whether or not the proposal is accepted.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don’t think it should be an error. Normally we can have any number of functions with the same name but different return types. By failing in this specific case would be like saying that when you implement a protocol with an associated type you can only return what’s defined in the associated type. I don’t think that should be the behaviour we expect.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This seems very related to the near-miss checking I mentioned in my other reply to Austin. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   - Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Actually, the more I think about it I get the conclusion that It really shouldn’t be an error. Otherwise this would mean that you wouldn’t be able to use the default implementation and have a function with the same name but returning another type. And if we can’t get an error; We’re just making it easier for the bugs by forcing one to keep the typealias and his own implementation in sync. With inference this wouldn’t exist. This is a really hard one. Looks like the decision is already made. If this is really the case; All I can say is that I really hope this comes back in Swift 4. <br>&gt;&gt; <br>&gt;&gt; For reference, my implementation makes it a warning, not an error, and you can suppress the warning by moving the similar-but-not-selected declaration to a different extension.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt; <br>&gt; Your implementation is the current one?<br></p><p><br>No, I never committed it because at the time we were still talking about an “implements” keyword (or similar) to indicate that a particular declaration was intended to satisfy a protocol requirement.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/011ee831/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19ca8ea29768acdbb87dc016d7d9a8e4?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Paulo Faria</string> &lt;paulo at zewo.io&gt;<p>June 29, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 3:45 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 28, 2016, at 11:43 PM, Paulo Faria &lt;paulo at zewo.io &lt;mailto:paulo at zewo.io&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 3:40 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 28, 2016, at 11:36 PM, Paulo Faria &lt;paulo at zewo.io &lt;mailto:paulo at zewo.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 2:54 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 28, 2016, at 10:51 PM, Paulo Faria &lt;paulo at zewo.io &lt;mailto:paulo at zewo.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 2:48 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you tested it, there&#39;s a problem with the current behavior independent of associated type inference, and it should be fixed whether or not the proposal is accepted.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don’t think it should be an error. Normally we can have any number of functions with the same name but different return types. By failing in this specific case would be like saying that when you implement a protocol with an associated type you can only return what’s defined in the associated type. I don’t think that should be the behaviour we expect.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This seems very related to the near-miss checking I mentioned in my other reply to Austin. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   - Doug<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Actually, the more I think about it I get the conclusion that It really shouldn’t be an error. Otherwise this would mean that you wouldn’t be able to use the default implementation and have a function with the same name but returning another type. And if we can’t get an error; We’re just making it easier for the bugs by forcing one to keep the typealias and his own implementation in sync. With inference this wouldn’t exist. This is a really hard one. Looks like the decision is already made. If this is really the case; All I can say is that I really hope this comes back in Swift 4. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For reference, my implementation makes it a warning, not an error, and you can suppress the warning by moving the similar-but-not-selected declaration to a different extension.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; Your implementation is the current one?<br>&gt; <br>&gt; <br>&gt; No, I never committed it because at the time we were still talking about an “implements” keyword (or similar) to indicate that a particular declaration was intended to satisfy a protocol requirement.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br></p><p>Awesome! I hope the final implementation has the warning.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/93079332/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 28, 2016 at 04:00:00pm</p></header><div class="content"><p>on Tue Jun 28 2016, Douglas Gregor &lt;dgregor-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 27, 2016, at 12:56 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sat Jun 25 2016, Austin Zheng &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Jun 25, 2016, at 6:23 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Austin,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m sorry to say, but this proposal makes me really sad.  I consider<br>&gt;&gt;&gt;&gt; associated type inference one of the more elegant aspects of Swift.<br>&gt;&gt;&gt;&gt; It would be very unfortunate to lose it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are lots of &quot;elegant&quot; things that Swift could do, but has chosen<br>&gt;&gt;&gt; not to do for pragmatic reasons (e.g. generalized implicit<br>&gt;&gt;&gt; conversions, type inference that crosses statement boundaries). Given<br>&gt;&gt;&gt; how terrible the development experience can be right now in the worst<br>&gt;&gt;&gt; case, I would happily trade off some measure of convenience for better<br>&gt;&gt;&gt; tooling.<br>&gt;&gt; <br>&gt;&gt; Well, the type checker&#39;s inference engine has *always* been kinda<br>&gt;&gt; unreliable,<br>&gt;<br>&gt; Dave is dramatically understating the pain that this inference has<br>&gt; caused. <br></p><p>What are you talking about? I did not characterize the magnitude of the<br>pain in any way whatsoever.<br></p><p>&gt; Because this is the only place we do global type inference, it’s put<br>&gt; tremendous pressure on the type checker that caused a huge number of<br>&gt; bugs, crashes, and outright incomprehensible behavior. I reimplemented<br>&gt; the inference of associated type witnesses in April of 2015<br>&gt; (https://github.com/apple/swift/commit/126e404fe5bf0be81206f22c83a61f6689d18854<br>&gt; &lt;https://github.com/apple/swift/commit/126e404fe5bf0be81206f22c83a61f6689d18854&gt;,<br>&gt; for reference), when the existing implementation unbearable. It got<br>&gt; *far* better, but it’s still not global *enough* to actually be<br>&gt; predictable, and the legacy of this mis-feature manifests in a number<br>&gt; of weird ways (e.g., typealiases in protocol extensions cannot be used<br>&gt; to satisfy associated type requirements, weird rules for when a<br>&gt; defaulted associated type gets used).<br>&gt;<br>&gt;&gt; and the experience is made much worse by the lack of<br>&gt;&gt; recursive protocol requirements and the inability to express other<br>&gt;&gt; constraints that would better guide inference, and by the “underscored<br>&gt;&gt; protocols” such as _Indexable that are required to work around those<br>&gt;&gt; limitations.  IMO it&#39;s premature to remove this feature before the<br>&gt;&gt; inference engine is made sane, the generics features are added, and the<br>&gt;&gt; library is correspondingly cleaned up, because we don&#39;t really know what<br>&gt;&gt; the user experience would be.<br>&gt;<br>&gt; Well, there’s a chicken-and-egg problem. The complexity of this<br>&gt; inference is getting in the way of other improvements. <br></p><p>I figured that might be the case.  If we have to drop that inference in<br>order to evolve the other improvements in a sane way, I strongly endorse<br>doing so, at least temporarily :-) But I think we should be prepared to<br>re-evaluate the situation after the dust settles.<br></p><p>&gt; For example, inference of associated types for conditional<br>&gt; conformances requires that associated type witness deduction consider<br>&gt; additional requirements, which is a complexity we would entirely avoid<br>&gt;<br>&gt;&gt; Finally, I am very concerned that there are protocols such as Collection,<br>&gt;&gt; with many inferrable associated types, and that conforming to these<br>&gt;&gt; protocols could become *much* uglier.<br>&gt;<br>&gt; That’s the general concern I have as well: how much boilerplate does<br>&gt; this add? In many cases, we get some of the associated type witnesses<br>&gt; for Collection types for free, and I don’t know to what extent we can<br>&gt; emulate that with defaulted associated type requirements and<br>&gt; typealiases in protocol extensions.<br>&gt;<br>&gt; That said, I’ll take some minor regressions in this area for the<br>&gt; massive simplification that this proposal brings.<br></p><p>It remains to be seen how minor the usability regressions are, of<br>course.<br></p><p>-- <br>Dave<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 28, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 11:25 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Finally, I am very concerned that there are protocols such as Collection,<br>&gt;&gt; with many inferrable associated types, and that conforming to these<br>&gt;&gt; protocols could become *much* uglier.<br>&gt; <br>&gt; That’s the general concern I have as well: how much boilerplate does this add? In many cases, we get some of the associated type witnesses for Collection types for free, and I don’t know to what extent we can emulate that with defaulted associated type requirements and typealiases in protocol extensions.<br>&gt; <br>&gt; That said, I’ll take some minor regressions in this area for the massive simplification that this proposal brings.<br></p><p>Another point to add to Doug’s great summary: instead of keeping it, it is better in many ways to remove this feature in Swift 3, improve the generics model throughout Swift 4 cycle, and then consider adding inference back when we know more.  <br></p><p>The benefits of adding it back will be even more clear in the future, and the implementation cost will also be more knowable as the rest of the generics system is baked out.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/18bae046/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
