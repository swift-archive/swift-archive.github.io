<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f8978dbb959b069613e2d027420615f?s=50"></div><header><strong>copy-on-write proposal</strong> from <string>Erik Eckstein</string> &lt;eeckstein at apple.com&gt;<p>October 11, 2016 at 04:00:00pm</p></header><div class="content"><p>This is a proposal for representing copy-on-write buffers in SIL. Actually it’s still a draft for a proposal. It also heavily depends on how we move forward with SIL ownership.<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: CopyOnWrite.rst<br>Type: application/octet-stream<br>Size: 21944 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161011/ea46f7c5/attachment.obj&gt;<br>-------------- next part --------------<br></p><p>If you have any comments, please let me know.<br></p><p>Erik<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>copy-on-write proposal</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>October 11, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; ----<br>&gt; <br>&gt; :orphan:<br>&gt; <br>&gt; .. highlight:: sil<br>&gt; <br>&gt; ===================================<br>&gt; Copy-On-Write Representation in SIL<br>&gt; ===================================<br>&gt; <br>&gt; .. contents::<br>&gt; <br>&gt; Overview<br>&gt; ========<br>&gt; <br>&gt; This document proposes:<br>&gt; <br>&gt; - An ownership attribute to define copy-on-write (COW) buffers in Swift data<br>&gt;   types.<br>&gt; <br>&gt; - A representation of COW buffers in SIL so that optimizations can take benefit<br>&gt;   of it.<br>&gt; <br>&gt; The basic idea is to enable the SIL optimizer to reason about COW data types<br>&gt; in the same way as a programmer can do.<br></p><p>in the same way as a programmer can do =&gt; just as a programmer can.<br></p><p>&gt; <br>&gt; <br>&gt; This means: a COW buffer can only be modified by its owning SIL value, because<br>&gt; either it&#39;s uniquely referenced or the buffer is copied before modified.<br></p><p>modified =&gt; modification.<br></p><p>&gt; <br>&gt; .. note::<br>&gt;     In the following the term &quot;buffer&quot; refers to a Swift heap object.<br>&gt;     It can be any heap object, not necessarily a “buffer” with e.g. tail-allocated elements.<br>&gt; <br>&gt; COW Types<br>&gt; =========<br>&gt; <br>&gt; The basic structure of COW data types can be simplified as follows::<br>&gt; <br>&gt;     class COWBuffer {<br>&gt;       var someData: Int<br>&gt;       ...<br>&gt;     }<br>&gt; <br>&gt;     struct COWType {<br>&gt;       var b : COWBuffer<br>&gt; <br>&gt;       mutating func change_it() {<br>&gt;         if (!isUniquelyReferenced(b)) {<br>&gt;           b = copy_buffer(b)<br>&gt;         }<br>&gt;         b.someData = ...<br>&gt;       }<br>&gt;     }<br>&gt; <br>&gt; Currently the COW behavior of such types is just defined by their implementation.<br>&gt; But there is no representation of this special behavior in the SIL.<br>&gt; So the SIL optimizer has no clue about it and cannot take advantage of it.<br>&gt; <br>&gt; For example::<br>&gt; <br>&gt;     func foo(arr : [Int]) {<br>&gt;       x = arr[0]<br>&gt;       opaque_function()<br>&gt;       y = arr[0] // can RLE replace this with y = x?<br>&gt;     }<br>&gt; <br>&gt; If opaque_function() wants to change the contents of the array buffer it first<br>&gt; has to copy it. But the optimizer does not know it so it has to conservatively<br>&gt; assume that opaque_function() will write to the location of arr[0].<br>&gt; <br>&gt; Copy-on-write Ownership Attribute<br>&gt; =================================<br>&gt; <br>&gt; This section proposes an ownership attribute to define a copy-on-write buffer.<br>&gt; <br>&gt; Swift Syntax<br>&gt; ------------<br>&gt; <br>&gt; A COW buffer reference can be defined with a new ownership attribute for the<br>&gt; buffer variable declaration (similar to “weak” and “unowned”)::<br>&gt; <br>&gt;     struct COWType {<br>&gt;       copy_on_write var b : COWBuffer<br>&gt; <br>&gt;       // ...<br>&gt;     }<br>&gt; <br>&gt; The ``copy_on_write`` attribute is purely used for optimization purposes.<br>&gt; It does not change the semantics of the program.<br>&gt; <br>&gt; .. note::<br>&gt; <br>&gt;   “copy_on_write” is a  working title. TODO: decide on the name.<br>&gt;   Maybe it should be a @-attribute, like @copy_on_write?<br>&gt;   Another question is if we should open this attribute for the public or just<br>&gt;   use it internally in the library, because violating the implied rules<br>&gt;   (see below) could break memory safety.<br>&gt; <br>&gt; Implementation<br>&gt; --------------<br>&gt; <br>&gt; The ``copy_on_write`` references can be represented in the AST as a special<br></p><p>&quot;The&quot; is not needed here I think.<br></p><p>&gt; ``StorageType``, just like how ``unowned`` and ``weak`` is represented.<br></p><p>is represented =&gt; are represented.<br></p><p>&gt; The canonical type of a ``CopyOnWriteStorageType`` would be the referenced<br>&gt; buffer class type.<br>&gt; <br>&gt; In SIL the buffer reference will have type::<br>&gt; <br>&gt;     $@sil_cow COWBuffer<br>&gt; <br>&gt; where ``COWBuffer`` is the type of the referenced heap object.<br>&gt; <br>&gt; Two conversion instructions are needed to convert from a ``@sil_cow`` reference<br>&gt; type to a regular reference type::<br>&gt; <br>&gt;     cow_to_ref<br>&gt;     ref_to_cow<br>&gt;  <br>&gt; Again, this is similar to ``ref_to_unowned`` and ``unowned_to_ref``.<br>&gt; <br>&gt; For example the SIL code for::<br>&gt; <br>&gt;     var c: COWType<br>&gt;     let x = c.b.someData<br>&gt; <br>&gt; would be::<br>&gt; <br>&gt;     %1 = struct_extract %1 : COWType, #COWType.b<br>&gt;     %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;     %3 = ref_element_addr %2 : $COWBuffer, #COWBuffer.someData<br>&gt;     %4 = load %3 : $*Int<br>&gt; <br>&gt; The ``ref_to_cow`` instruction is needed to store a new buffer reference into a<br>&gt; COW type.<br>&gt; <br>&gt; COW Buffers and the Optimizer<br>&gt; =============================<br>&gt; <br>&gt; A reference to a COW buffer gives the optimizer additional information:<br>&gt; <br>&gt;   *A buffer, referenced by a @sil_cow reference is considered to be immutable<br>&gt;   during the lifetime of the reference.*<br>&gt; <br>&gt; This means any address derived from a ``cow_to_ref`` instruction can be<br>&gt; considered to point to immutable memory.<br>&gt; <br>&gt; Some examples of optimizations which will benefit from copy-on-write<br>&gt; representation in SIL:<br>&gt; <br>&gt; - Redundant load elimination<br>&gt; <br>&gt;   RLE can assume that opaque code does not modify a COW buffer.<br>&gt;   Example::<br>&gt; <br>&gt;       %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;       %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;       %4 = load %3 : $*Int<br>&gt;       %5 = apply %foo()                        // Cannot overwrite memory location %3<br>&gt;       %6 = load %3 : $*Int                     // Can be replaced by %4<br>&gt; <br>&gt;   Currently we do some ad-hoc optimizations for array, based on semantics,<br>&gt;   like array count propagation. These hacks would not be needed anymore.<br>&gt; <br>&gt;   Note that it’s not required to check if a ``cow_to_ref`` reference (or a<br>&gt;   projected address) escapes. Even if it escapes, it will reference immutable<br>&gt;   memory.<br>&gt; <br>&gt; - CSE, loop hoisting<br>&gt; <br>&gt;   Similar to RLE: the optimizer can assume that opaque code cannot modify a<br>&gt;   COW buffer<br>&gt; <br>&gt; - ARC optimization<br>&gt; <br>&gt;   Knowing that some opaque code cannot overwrite a reference in the COW buffer<br>&gt;   can remove retain/release pairs across such code::<br>&gt; <br>&gt;       %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;       %3 = ref_element_addr %2 : $COWBuffer, #someRef<br>&gt;       %4 = load_strong %3 : $*MyClass          // Can do a load_strong [guarantee]<br>&gt;       %5 = apply %foo()                        // Cannot overwrite someRef and dealloc the object<br>&gt;       // Use %4<br>&gt;       destroy_value %4 : $MyClass<br>&gt; <br>&gt; Scoping instructions<br>&gt; --------------------<br>&gt; <br>&gt; To let the optimizer reason about the immutability of the COW buffer, it is<br>&gt; important to *bind* the lifetime of the buffer content to the lifetime of the<br>&gt; buffer reference. For example::<br>&gt; <br>&gt;     %b1 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference<br>&gt;     // load something from %b1<br>&gt;     %a = apply %foo(%baddr : $@sil_cow COWBuffer)<br>&gt;     %b2 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference again<br>&gt;     // load something from %b2<br>&gt;  <br>&gt; The question is: can RLE forward the load of the buffer reference and replace<br>&gt; ``%b2`` with ``%b1``? It must not be able to do so if ``foo()`` modifies the<br>&gt; buffer.<br>&gt; <br>&gt; To enforce this restriction, the scope of any buffer modification must be<br>&gt; enclosed in a pair of SIL instructions. Those instructions define the scope<br>&gt; of the mutation. Both instructions take the *address* of the buffer<br>&gt; reference as operand and act as a potential write to the buffer reference. <br>&gt; <br>&gt; The purpose of the scoping instructions is to strictly separate the liferanges<br>&gt; of references to an immutable buffer and references to the mutable buffer.<br>&gt; <br>&gt; The following example shows why the scoping instructions (specifically the<br>&gt; end-of-scope instruction) are required to prevent loop-hoisting from<br>&gt; interleaving mutable and immutable liferanges::<br>&gt; <br>&gt;     // there should be a begin-of-scope %baddr<br>&gt;     %mut_b = load %baddr<br>&gt;     store %x to %mut_b    // modification of the buffer<br>&gt;     // there should be a end-of-scope %baddr<br>&gt; <br>&gt;     loop {<br>&gt;       %b = load %baddr<br>&gt;       %y = load %b        // load from the buffer<br>&gt;       ...<br>&gt;     }<br>&gt; <br>&gt; If there is no end-of-scope instruction, loop hoisting could do::<br>&gt; <br>&gt;     %mut_b = load %baddr<br>&gt;     %b = load %baddr        // moved out of the loop<br>&gt;     store %x to %mut_b<br>&gt; <br>&gt;     loop {<br>&gt;       %y = load %b<br>&gt;       ...<br>&gt;     }<br>&gt; <br>&gt; Now the optimizer assumes that ``%b`` references an immutable buffer, so it could<br>&gt; also hoist the load::<br>&gt; <br>&gt;     %mut_b = load %baddr<br>&gt;     %b = load %baddr<br>&gt;     %y = load %b          // Wrong! Will be overwritten by the following store<br>&gt;     store %x to %mut_b<br>&gt; <br>&gt;     loop {<br>&gt;       ...<br>&gt;     }<br>&gt; <br>&gt; <br>&gt; The following sections describe two alternatives to implement the scoping.<br>&gt; <br>&gt; Scoping Alternative 1: Explicit Built-ins<br>&gt; -----------------------------------------<br>&gt; <br>&gt; SIL instructions<br>&gt; ^^^^^^^^^^^^^^^^<br>&gt; <br>&gt; The existing ``is_unique`` instruction is changed to a terminator instruction::<br>&gt; <br>&gt;     bb0:<br>&gt;       is_unique_addr_br %0 : $*@sil_cow COWBuffer, bb1, bb2  // %0 is the address of the COWBuffer reference<br>&gt;     bb1(%1 : $COWBuffer): // the true-block. The payload %1 is the unique reference. Physically identical to &quot;load %0”<br>&gt;       // usually empty<br>&gt;       br bb3(%1 : $COWBuffer)<br>&gt;     bb2:                  // the false-block<br>&gt;       // usually contains:<br>&gt;       %2 = apply %copy_buffer<br>&gt;       %3 = cow_to_ref %2<br>&gt;       store_strong %3 to %0 : $*@sil_cow COWBuffer<br>&gt;       br bb3(%2 : $COWBuffer)<br>&gt;     bb3(%4 : $COWBuffer):<br>&gt;       // Modify the buffer referenced by %4<br>&gt;       // ...<br>&gt; <br>&gt; The end-of-scope instruction is::<br>&gt; <br>&gt;     end_unique_addr %0 : $*COWBuffer<br>&gt; <br>&gt; It is important that the references to the unique buffers (``%1``, ``%2``) must<br>&gt; not outlive ``end_unique_addr``. In most cases this can be check by the SIL<br>&gt; verifier.<br>&gt; <br>&gt; The two instructions must be paired properly but not necessarily in the<br>&gt; same function.<br>&gt; <br></p><p>Would this require a new form of function signature?<br></p><p>&gt; <br>&gt; The purpose of an ``is_unique_addr_br`` - ``end_unique_addr`` pair is to<br>&gt; separate the lifetimes of mutable and immutable accesses to the COW buffer.<br>&gt; Both instructions take an address to the COW buffer reference and are<br>&gt; considered as potential stores to the reference.<br>&gt; This makes sure that the SIL optimizer cannot mix-up buffer reference lifetimes<br>&gt; across these instructions.<br>&gt; For example, RLE cannot combine two buffer loads which are interleaved with<br>&gt; a ``is_unique_addr_br``::<br>&gt; <br>&gt;     %1 = load_strong %0 : $*@sil_cow COWBuffer<br>&gt;     // do something with %1<br>&gt;     …<br>&gt;     is_unique_addr_br %0 : $*@sil_cow COWBuffer<br>&gt;     …<br>&gt;     %2 = load_strong %0 : $*@sil_cow COWBuffer // RLE cannot replace this with %1<br></p><p>Can you make this a complete example.<br></p><p>&gt; <br>&gt; Another important thing is that the COW buffer can only be mutated by using the<br>&gt; reference of the ``is_unique_addr_br`` true-block argument.<br></p><p>On the face this claim is incorrect. I think it is important to be clear here that you mean without any further copying done. It seems to contradict your example above of doing mutable things in bb3.<br></p><p>&gt; The COW buffer cannot be modified by simply loading/extracting the reference<br>&gt; from the COWType.<br>&gt; Example::<br>&gt; <br>&gt;   %1 = load_strong %0 : $*COWBuffer<br>&gt;   %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;   %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;   store %7 : $Int to %3 : $*Int            // Violation!<br>&gt; <br>&gt; Most obvious violations to this constraint can be catched by the SILVerifier.<br>&gt; <br>&gt; The ``_addr`` variants of the instructions also have a non-addr counterpart::<br>&gt; <br>&gt;     is_unique_br %0 : $COWBuffer, bb1, bb2.  // consumes %0 and produces the true-block arg as owned<br>&gt; <br>&gt;     %1 = end_unique %0 : $COWBuffer // consumes %0 and produces %1 as owned<br>&gt; <br>&gt; These instructions are generated by Mem2reg (or a similar optimization)<br>&gt; in case the COW value is stored (in a temporary alloc_stack location)<br>&gt; just for the sake of passing an address to ``is_unique_addr_br`` and<br>&gt; ``end_unique_addr``.<br>&gt; For example in the following code, where the COW data is passed as-value and<br>&gt; all the mutating functions are inlined::<br>&gt; <br>&gt;     func foo(arr : [Int], x: Int) {<br>&gt;       arr[0] = 27<br>&gt;       …<br>&gt;       y = arr[x]<br>&gt;       …<br>&gt;     }<br>&gt; <br>&gt; Finally it’s probably a good idea to add an instruction for converting an<br>&gt; immutable reference to a mutable reference::<br>&gt; <br>&gt;     %1 = start_unique %0 : $COWBuffer // consumes %0 and produces %1 : $COWBuffer as owned<br>&gt; <br>&gt; which is basically just a simpler representation of the following pattern::<br>&gt; <br>&gt;     bb0:<br>&gt;       is_unique_br %0 : $@sil_cow COWBuffer, bb1, bb2<br>&gt;     bb1(%1 : $COWBuffer):<br>&gt;       … // main control flow continues here<br>&gt;     bb2:<br>&gt;       unreachable<br>&gt; <br>&gt; An optimizations, which eliminate uniqueness checks, would replace a<br>&gt; ``is_unique_br`` by a ``start_unique``.<br></p><p>Question, I imagine that make_mutable is a very common case. Why not just provide such an instruction?<br></p><p>&gt; <br>&gt; Built-ins<br>&gt; ^^^^^^^^^<br>&gt; <br>&gt; A COW type implementor can generate the new instructions by using a set of built-ins::<br>&gt; <br>&gt;     func isUnique&lt;BufferType&gt;(_ buffer: inout BufferType) -&gt; BufferType?<br>&gt;     func endUnique&lt;BufferType&gt;(_ buffer: inout BufferType)  <br>&gt; <br>&gt; For example::<br>&gt; <br>&gt;     struct COWType {<br>&gt;       copy_on_write var b : COWBuffer<br>&gt; <br>&gt;       mutating func makeMutable() -&gt; COWBuffer {<br>&gt;         if let uniqueBuffer = isUnique(&amp;self.b) {<br>&gt;           return uniqueBuffer<br>&gt;         }<br>&gt;         let copiedBuffer = copyBuffer(self.b)<br>&gt;         self.b = copiedBuffer<br>&gt;         return copiedBuffer<br>&gt;       }<br>&gt; <br>&gt;       mutating func setSomeData(x: Int) {<br>&gt;         let uniqueBuffer = makeMutable()<br>&gt;         uniqueBuffer.someData = x<br>&gt;         endUnique(&amp;self.b)<br>&gt;       }<br>&gt;     }<br>&gt; <br>&gt; The ``isUnique`` built-in returns an optional unique buffer reference.<br>&gt; Physically this is the COW buffer which is passed as the inout argument.<br>&gt; The result is nil if the buffer is not uniquely referenced.<br>&gt; In this case usually the original buffer is copied and the reference to the<br>&gt; copy is written back to the original buffer reference location<br>&gt; (``self.b = copiedBuffer``).<br>&gt; Starting at the point of the write-back, the reference to the copy also becomes<br>&gt; a unique buffer reference.<br>&gt; <br>&gt; The ``isUnique`` built-in is lowered to the ``is_unique_addr_br`` pattern which<br>&gt; constructs the Optional in the successor blocks. Using ``isUnique`` in an<br>&gt; if-let (as shown above) will end up in two consecutive CFG &quot;diamonds&quot;.<br>&gt; Simplify-CFG can combine those into a single ``is_unique_addr_br`` diamond.<br>&gt; <br>&gt; .. note::<br>&gt;   This makes the definition of the unique buffer location lifetime a little bit<br>&gt;   problematic, because the false-branch of ``isUnique`` is not equivalent to<br>&gt;   the false-branch of the ``is_unique_addr_br`` instruction (before SimplifyCFG<br>&gt;   can do its job).<br>&gt; <br>&gt; The rules for using ``copy_on_write`` and the built-ins are:<br>&gt; <br>&gt; 1. ``isUnique`` must be paired with ``endUnique``, but not necessarily in the<br>&gt;    same function.<br>&gt; <br>&gt; 2. The COW buffer may only be mutated by using the unique buffer reference.<br>&gt; <br>&gt; 3. The COW buffer must not be mutated outside the ``isUnique`` - ``endUnique``<br>&gt;    pair.<br>&gt; <br>&gt; 4. During the lifetime of the unique buffer reference, the original COW buffer<br>&gt;    reference must not be used in any way, e.g. for reading from the buffer.<br>&gt; <br>&gt;    Note that the lifetime of the unique buffer reference does not include the<br>&gt;    part between the begin of the ``isUnique`` false-branch and the write-back<br>&gt;    of the copy. This means is okay to read from the buffer (using ``self.b``)<br>&gt;    for the purpose of copying.<br>&gt; <br>&gt; Examples::<br>&gt; <br>&gt;     mutating func setSomeData(x: Int) {<br>&gt;       let uniqueBuffer = makeMutable()<br>&gt;       uniqueBuffer.someData = x<br>&gt;       // violates rule 1<br>&gt;     }<br>&gt; <br>&gt;     mutating func setSomeData(x: Int) {<br>&gt;       makeMutable()<br>&gt;       self.b.someData = x // violates rule 2<br>&gt;       endUnique(&amp;self.b)<br>&gt;     }<br>&gt; <br>&gt;     mutating func setSomeData(x: Int) {<br>&gt;       let uniqueBuffer = makeMutable()<br>&gt;       uniqueBuffer.someData = x<br>&gt;       endUnique(&amp;self.b)<br>&gt;       uniqueBuffer.someData = 27 // violates rule 3<br>&gt;     }<br>&gt; <br>&gt;     mutating func incrementSomeData() {<br>&gt;       let uniqueBuffer = makeMutable()<br>&gt;       uniqueBuffer.someData = self.b.someData + 1 // violates rule 4<br>&gt;       endUnique(&amp;self.b)<br>&gt;     }<br>&gt; <br>&gt; <br>&gt; The intention of the rules is to ensure that there is no overlap of a<br>&gt; &quot;read-only&quot; life-range with a &quot;mutable&quot; life-range of the buffer reference.<br>&gt; It’s the responsibility of the implementor to follow the rules.<br>&gt; But the compiler (a mandatory diagnostics pass and the SIL verifier) can<br>&gt; statically detect rule violations in obvious cases (with inter-procedural<br>&gt; analysis maybe even in most cases).<br>&gt; <br>&gt; This approach would require to change some of the internals of our<br>&gt; current COW data structures in the stdlib (Array, Dictionary, etc.).<br>&gt; For example, the Array make_mutable semantic functions currently do not return<br>&gt; the unique buffer.<br>&gt; <br>&gt; Scoping Alternative 2: Implicit Inout Scopes<br>&gt; --------------------------------------------<br>&gt; <br>&gt; There is an idea (proposal?) to change the representation of inout variables<br>&gt; in SIL. This is independent of this proposal, but can be helpful for the<br>&gt; purpose of defining the scope of a COW mutation.<br>&gt; <br>&gt; The basic idea is that SILGen inserts scoping instructions for *all* inout<br>&gt; variables. And those scoping instructions can be used to define the mutating<br>&gt; scope of a COW buffer.<br>&gt; <br>&gt; The scoping instructions which are inserted by SILGen for an inout scope are::<br>&gt; <br>&gt;     begin_exclusive<br>&gt;     end_exclusive<br>&gt; <br>&gt; Simliar to ``is_unique_addr_br`` and ``end_unique_addr``, those instructions take the<br>&gt; address of the inout variable as argument. For the optimizer those instructions<br>&gt; look like potential writes to the inout variable.<br>&gt; <br>&gt; The implementor of a COW type has to follow the rule that the COW buffer may<br>&gt; only be modified in mutating functions of the COW type. But this is the case<br>&gt; anyway because any modification needs a uniqueness check and this can only be<br>&gt; done in mutating functions.<br>&gt; <br>&gt; Example::<br>&gt; <br>&gt;     // &gt; mutating func setSomeData(x: Int) {<br>&gt;     // Accepts a unique reference to the array value (avoiding refcount operations)<br>&gt;     sil @setSomeData : $(Int, @inout Array) -&gt; () {<br>&gt;     bb_entry(%x : Int, %arrayref : $*Array&lt;T&gt;) // Begin scope #0<br>&gt; <br>&gt;     // &gt;   makeMutable() (inlined)<br>&gt;     // Forward the unique reference to the `self` array value, still avoiding refcount operations.<br>&gt;     // Begin the inlined exclusive scope (could be trivially removed).<br>&gt;     begin_exclusive %arrayref : $*Array&lt;T&gt; // Begin scope #1<br>&gt; <br>&gt;     // &gt;    if !isUnique(&amp;self._storage) {<br>&gt;     // Extract a unique inout reference to the class reference to the array storage.<br>&gt;     // This begins the isUnique() argument&#39;s exclusive scope. The memory is already exclusive<br>&gt;     // but the scope helps ensure this is the only alias to _storage.<br>&gt;     %arrayref._storageref = struct_element_addr [exclusive] %arrayref, #Array._storage<br>&gt; <br>&gt;     // Uniqueness checking requires an inout reference to the class reference.<br>&gt;     // The is_unique instruction does not need to create a new storage reference.<br>&gt;     // It&#39;s only purpose is to check the RC count, ensure that the checked reference<br>&gt;     // is inout, and prevent the inout scope from being optimized away.<br>&gt;     %isuniq = is_unique %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt; <br>&gt;     // End the isUnique argument&#39;s exclusive scope (can also be trivially removed).<br>&gt;     end_exclusive %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt; <br>&gt;     br %isuniq, bb_continue, bb_slow<br>&gt; <br>&gt;     bb_slow:<br>&gt;     // &gt;      self._storage = copyBuffer(self._storage)<br>&gt;     // Produce a new class reference to storage with verifiably unique RC semantics.<br>&gt;     %copied_storage_class = alloc_ref ...<br>&gt;     // A begin/end exclusive scope is implicit in store [assign].<br>&gt;     store [assign] %copied_storage_class to %arrayref._storageref<br>&gt;     br bb_continue<br>&gt; <br>&gt;     bb_continue:<br>&gt; <br>&gt;     // This marks the end of makeMutable&#39;s inout `self` scope. Because Array<br>&gt;     // contains a &quot;copy_on_write&quot; property, the SIL verifier needs to<br>&gt;     // prove that %arrayref.#_storage has not escaped at this point. This<br>&gt;     // is equivalent to checking that %arrayref itself is not copied, and<br>&gt;     // checking each projection of the &quot;copy_on_write&quot; storage property<br>&gt;     // (%arrayref._storageref) is not copied. Or, if any copies are present,<br>&gt;     // they must be consumed within this scope.<br>&gt;     end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #1<br>&gt; <br>&gt;     // &gt;    self._storage.someData = x<br>&gt;     // An _addr instruction with one load/store use doesn&#39;t really need its own scope.<br>&gt;     %arrayref._storageref = struct_element_addr %arrayref, #Array._storage<br>&gt; <br>&gt;     // ARC optimization can promote this to a borrow, replacing strong_release with end_borrow.<br>&gt;     %arrayref.cow_storage = load [copy] %arrayref._storageref : $*@sil_cow ArrayStorage<br>&gt;     %arrayref._storage = cow_to_ref %arrayref.cow_storage : $@sil_cow ArrayStorage<br>&gt; <br>&gt;     // Write some data into the CoW buffer.<br>&gt;     // (For simplicity, pretend ArrayStorage has a &quot;someData&quot; field).<br>&gt;     // A single-use _addr instruction, so no scope.<br>&gt;     %somedata_addr = ref_element_addr %arrayref._storage, #someData<br>&gt;     // A store with an implicit [exclusive] scope.<br>&gt;     store [assign] %x to %somedata_addr<br>&gt; <br>&gt;     strong_release %arrayref._storage : $*ArrayStorage&lt;T&gt;<br>&gt; <br>&gt;     // End the isUnique argument&#39;s exclusive scope.<br>&gt;     // The same verification is needed here, but the inner scope would be eliminated.<br>&gt;     end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #0<br>&gt; <br>&gt; In general this approach looks more &quot;user-friendly&quot; than the first alternative.<br>&gt; But it depends on implementing the general feature to insert the inout scoping<br>&gt; instructions.<br>&gt; Also, we still have to think through all the details of this approach.<br>&gt; <br>&gt; Dependency between a buffer reference to the scope-begin<br>&gt; --------------------------------------------------------<br>&gt; <br>&gt; With both alternatives there is no explicit dependency from a buffer reference<br>&gt; to a scope-begin instruction::<br>&gt; <br>&gt;     %b_cow = load %baddr<br>&gt;     %b = cow_to_ref %b_cow<br>&gt;     %x = load %b             // No dependency between this...<br>&gt;     ...<br>&gt;     begin_exclusive %baddr   // ... and this instruction.<br>&gt;     ...<br>&gt; <br>&gt; So in theory the optimizer is free to reschedule the instructions::<br>&gt; <br>&gt;     %b_cow = load %baddr<br>&gt;     %b = cow_to_ref %b_cow<br>&gt;     ...<br>&gt;     begin_exclusive %baddr<br>&gt;     %x = load %b             // Wrong! Buffer could be modified here<br>&gt;     ...<br>&gt; <br>&gt; We still have to figure out how to cope with this.<br>&gt; <br>&gt; - We could add an end-of-lifetime instruction for a COW buffer reference, which<br>&gt;   the optimizer may not move over a begin-of-scope instruction.<br>&gt; <br>&gt; - Or we just define the implicit rule for the optimizer that any use of a COW<br>&gt;   reference may not be moved over a begin-of-scope instruction.<br>&gt; <br>&gt; Preconditions<br>&gt; =============<br>&gt; <br>&gt; To benefit from COW optimizations in the stdlib Array, Set and Dictionary data<br>&gt; structures we first need eager bridging, meaning getting rid of the bridged<br>&gt; buffer. At least for Array this is implemented as low-level bit operations and<br>&gt; optimizations cannot reason about it (e.g. finding a reasonable RC-root for the<br>&gt; buffer reference).<br>&gt; <br>&gt; Another thing is that we currently cannot use ``copy_on_write`` for Array<br>&gt; because of pinning. Array pins it’s buffer when passing an element address to<br>&gt; an inout parameter. This allows the array buffer to be modified even if its<br>&gt; reference count is &gt; 1. With ``copy_on_write``, a programmer could break memory<br>&gt; safety when violating the inout rule. Example::<br>&gt; <br>&gt;     var arr = [MyClass()]  // a global array<br>&gt; <br>&gt;     foo(&amp;arr[0])        // Pins the buffer of arr during the call<br>&gt; <br>&gt;     func foo(_ x: inout MyClass) -&gt; Int {<br>&gt;       let b = arr       // The ref-count of the buffer is not incremented, because it is pinned!<br>&gt;       let r = b[0]      // optimizer removes the retain of r because it thinks the following code cannot modify b<br>&gt;       arr.removeAll()   // does not copy the array buffer and thus de-allocates r<br>&gt;       return r.i        // use-after-free!<br>&gt;     }<br></p><p>From a quick (re-)reading, this proposal still makes sense to me. My largest comment is that I would really like to have some way that the program will assert if the constraints are violated. Otherwise it will be difficult to debug when your invariants are broken. The state machine seems simple enough that I think you could reuse the pinned buffer and (if necessary) 1 additional bit in the object header (or perhaps tagged pointer bits).<br></p><p>Michael<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On Oct 11, 2016, at 4:48 PM, Erik Eckstein via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is a proposal for representing copy-on-write buffers in SIL. Actually it’s still a draft for a proposal. It also heavily depends on how we move forward with SIL ownership.<br>&gt;&gt; If you have any comments, please let me know.<br>&gt;&gt; <br>&gt;&gt; Erik<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f8978dbb959b069613e2d027420615f?s=50"></div><header><strong>copy-on-write proposal</strong> from <string>Erik Eckstein</string> &lt;eeckstein at apple.com&gt;<p>October 12, 2016 at 09:00:00am</p></header><div class="content"><p>Thanks for the feedback! Here is an updated version of the proposal: https://github.com/eeckstein/swift/blob/cow-proposal/docs/proposals/CopyOnWrite.rst &lt;https://github.com/eeckstein/swift/blob/cow-proposal/docs/proposals/CopyOnWrite.rst&gt;<br>(you can look at the history to see the changes compared to the previous version)<br></p><p>&gt; On Oct 11, 2016, at 7:57 PM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; ----<br>&gt;&gt; <br>&gt;&gt; :orphan:<br>&gt;&gt; <br>&gt;&gt; .. highlight:: sil<br>&gt;&gt; <br>&gt;&gt; ===================================<br>&gt;&gt; Copy-On-Write Representation in SIL<br>&gt;&gt; ===================================<br>&gt;&gt; <br>&gt;&gt; .. contents::<br>&gt;&gt; <br>&gt;&gt; Overview<br>&gt;&gt; ========<br>&gt;&gt; <br>&gt;&gt; This document proposes:<br>&gt;&gt; <br>&gt;&gt; - An ownership attribute to define copy-on-write (COW) buffers in Swift data<br>&gt;&gt;  types.<br>&gt;&gt; <br>&gt;&gt; - A representation of COW buffers in SIL so that optimizations can take benefit<br>&gt;&gt;  of it.<br>&gt;&gt; <br>&gt;&gt; The basic idea is to enable the SIL optimizer to reason about COW data types<br>&gt;&gt; in the same way as a programmer can do.<br>&gt; <br>&gt; in the same way as a programmer can do =&gt; just as a programmer can.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This means: a COW buffer can only be modified by its owning SIL value, because<br>&gt;&gt; either it&#39;s uniquely referenced or the buffer is copied before modified.<br>&gt; <br>&gt; modified =&gt; modification.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; .. note::<br>&gt;&gt;    In the following the term &quot;buffer&quot; refers to a Swift heap object.<br>&gt;&gt;    It can be any heap object, not necessarily a “buffer” with e.g. tail-allocated elements.<br>&gt;&gt; <br>&gt;&gt; COW Types<br>&gt;&gt; =========<br>&gt;&gt; <br>&gt;&gt; The basic structure of COW data types can be simplified as follows::<br>&gt;&gt; <br>&gt;&gt;    class COWBuffer {<br>&gt;&gt;      var someData: Int<br>&gt;&gt;      ...<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    struct COWType {<br>&gt;&gt;      var b : COWBuffer<br>&gt;&gt; <br>&gt;&gt;      mutating func change_it() {<br>&gt;&gt;        if (!isUniquelyReferenced(b)) {<br>&gt;&gt;          b = copy_buffer(b)<br>&gt;&gt;        }<br>&gt;&gt;        b.someData = ...<br>&gt;&gt;      }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; Currently the COW behavior of such types is just defined by their implementation.<br>&gt;&gt; But there is no representation of this special behavior in the SIL.<br>&gt;&gt; So the SIL optimizer has no clue about it and cannot take advantage of it.<br>&gt;&gt; <br>&gt;&gt; For example::<br>&gt;&gt; <br>&gt;&gt;    func foo(arr : [Int]) {<br>&gt;&gt;      x = arr[0]<br>&gt;&gt;      opaque_function()<br>&gt;&gt;      y = arr[0] // can RLE replace this with y = x?<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; If opaque_function() wants to change the contents of the array buffer it first<br>&gt;&gt; has to copy it. But the optimizer does not know it so it has to conservatively<br>&gt;&gt; assume that opaque_function() will write to the location of arr[0].<br>&gt;&gt; <br>&gt;&gt; Copy-on-write Ownership Attribute<br>&gt;&gt; =================================<br>&gt;&gt; <br>&gt;&gt; This section proposes an ownership attribute to define a copy-on-write buffer.<br>&gt;&gt; <br>&gt;&gt; Swift Syntax<br>&gt;&gt; ------------<br>&gt;&gt; <br>&gt;&gt; A COW buffer reference can be defined with a new ownership attribute for the<br>&gt;&gt; buffer variable declaration (similar to “weak” and “unowned”)::<br>&gt;&gt; <br>&gt;&gt;    struct COWType {<br>&gt;&gt;      copy_on_write var b : COWBuffer<br>&gt;&gt; <br>&gt;&gt;      // ...<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; The ``copy_on_write`` attribute is purely used for optimization purposes.<br>&gt;&gt; It does not change the semantics of the program.<br>&gt;&gt; <br>&gt;&gt; .. note::<br>&gt;&gt; <br>&gt;&gt;  “copy_on_write” is a  working title. TODO: decide on the name.<br>&gt;&gt;  Maybe it should be a @-attribute, like @copy_on_write?<br>&gt;&gt;  Another question is if we should open this attribute for the public or just<br>&gt;&gt;  use it internally in the library, because violating the implied rules<br>&gt;&gt;  (see below) could break memory safety.<br>&gt;&gt; <br>&gt;&gt; Implementation<br>&gt;&gt; --------------<br>&gt;&gt; <br>&gt;&gt; The ``copy_on_write`` references can be represented in the AST as a special<br>&gt; <br>&gt; &quot;The&quot; is not needed here I think.<br>&gt; <br>&gt;&gt; ``StorageType``, just like how ``unowned`` and ``weak`` is represented.<br>&gt; <br>&gt; is represented =&gt; are represented.<br>&gt; <br>&gt;&gt; The canonical type of a ``CopyOnWriteStorageType`` would be the referenced<br>&gt;&gt; buffer class type.<br>&gt;&gt; <br>&gt;&gt; In SIL the buffer reference will have type::<br>&gt;&gt; <br>&gt;&gt;    $@sil_cow COWBuffer<br>&gt;&gt; <br>&gt;&gt; where ``COWBuffer`` is the type of the referenced heap object.<br>&gt;&gt; <br>&gt;&gt; Two conversion instructions are needed to convert from a ``@sil_cow`` reference<br>&gt;&gt; type to a regular reference type::<br>&gt;&gt; <br>&gt;&gt;    cow_to_ref<br>&gt;&gt;    ref_to_cow<br>&gt;&gt; <br>&gt;&gt; Again, this is similar to ``ref_to_unowned`` and ``unowned_to_ref``.<br>&gt;&gt; <br>&gt;&gt; For example the SIL code for::<br>&gt;&gt; <br>&gt;&gt;    var c: COWType<br>&gt;&gt;    let x = c.b.someData<br>&gt;&gt; <br>&gt;&gt; would be::<br>&gt;&gt; <br>&gt;&gt;    %1 = struct_extract %1 : COWType, #COWType.b<br>&gt;&gt;    %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;    %3 = ref_element_addr %2 : $COWBuffer, #COWBuffer.someData<br>&gt;&gt;    %4 = load %3 : $*Int<br>&gt;&gt; <br>&gt;&gt; The ``ref_to_cow`` instruction is needed to store a new buffer reference into a<br>&gt;&gt; COW type.<br>&gt;&gt; <br>&gt;&gt; COW Buffers and the Optimizer<br>&gt;&gt; =============================<br>&gt;&gt; <br>&gt;&gt; A reference to a COW buffer gives the optimizer additional information:<br>&gt;&gt; <br>&gt;&gt;  *A buffer, referenced by a @sil_cow reference is considered to be immutable<br>&gt;&gt;  during the lifetime of the reference.*<br>&gt;&gt; <br>&gt;&gt; This means any address derived from a ``cow_to_ref`` instruction can be<br>&gt;&gt; considered to point to immutable memory.<br>&gt;&gt; <br>&gt;&gt; Some examples of optimizations which will benefit from copy-on-write<br>&gt;&gt; representation in SIL:<br>&gt;&gt; <br>&gt;&gt; - Redundant load elimination<br>&gt;&gt; <br>&gt;&gt;  RLE can assume that opaque code does not modify a COW buffer.<br>&gt;&gt;  Example::<br>&gt;&gt; <br>&gt;&gt;      %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;      %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;&gt;      %4 = load %3 : $*Int<br>&gt;&gt;      %5 = apply %foo()                        // Cannot overwrite memory location %3<br>&gt;&gt;      %6 = load %3 : $*Int                     // Can be replaced by %4<br>&gt;&gt; <br>&gt;&gt;  Currently we do some ad-hoc optimizations for array, based on semantics,<br>&gt;&gt;  like array count propagation. These hacks would not be needed anymore.<br>&gt;&gt; <br>&gt;&gt;  Note that it’s not required to check if a ``cow_to_ref`` reference (or a<br>&gt;&gt;  projected address) escapes. Even if it escapes, it will reference immutable<br>&gt;&gt;  memory.<br>&gt;&gt; <br>&gt;&gt; - CSE, loop hoisting<br>&gt;&gt; <br>&gt;&gt;  Similar to RLE: the optimizer can assume that opaque code cannot modify a<br>&gt;&gt;  COW buffer<br>&gt;&gt; <br>&gt;&gt; - ARC optimization<br>&gt;&gt; <br>&gt;&gt;  Knowing that some opaque code cannot overwrite a reference in the COW buffer<br>&gt;&gt;  can remove retain/release pairs across such code::<br>&gt;&gt; <br>&gt;&gt;      %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;      %3 = ref_element_addr %2 : $COWBuffer, #someRef<br>&gt;&gt;      %4 = load_strong %3 : $*MyClass          // Can do a load_strong [guarantee]<br>&gt;&gt;      %5 = apply %foo()                        // Cannot overwrite someRef and dealloc the object<br>&gt;&gt;      // Use %4<br>&gt;&gt;      destroy_value %4 : $MyClass<br>&gt;&gt; <br>&gt;&gt; Scoping instructions<br>&gt;&gt; --------------------<br>&gt;&gt; <br>&gt;&gt; To let the optimizer reason about the immutability of the COW buffer, it is<br>&gt;&gt; important to *bind* the lifetime of the buffer content to the lifetime of the<br>&gt;&gt; buffer reference. For example::<br>&gt;&gt; <br>&gt;&gt;    %b1 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference<br>&gt;&gt;    // load something from %b1<br>&gt;&gt;    %a = apply %foo(%baddr : $@sil_cow COWBuffer)<br>&gt;&gt;    %b2 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference again<br>&gt;&gt;    // load something from %b2<br>&gt;&gt; <br>&gt;&gt; The question is: can RLE forward the load of the buffer reference and replace<br>&gt;&gt; ``%b2`` with ``%b1``? It must not be able to do so if ``foo()`` modifies the<br>&gt;&gt; buffer.<br>&gt;&gt; <br>&gt;&gt; To enforce this restriction, the scope of any buffer modification must be<br>&gt;&gt; enclosed in a pair of SIL instructions. Those instructions define the scope<br>&gt;&gt; of the mutation. Both instructions take the *address* of the buffer<br>&gt;&gt; reference as operand and act as a potential write to the buffer reference. <br>&gt;&gt; <br>&gt;&gt; The purpose of the scoping instructions is to strictly separate the liferanges<br>&gt;&gt; of references to an immutable buffer and references to the mutable buffer.<br>&gt;&gt; <br>&gt;&gt; The following example shows why the scoping instructions (specifically the<br>&gt;&gt; end-of-scope instruction) are required to prevent loop-hoisting from<br>&gt;&gt; interleaving mutable and immutable liferanges::<br>&gt;&gt; <br>&gt;&gt;    // there should be a begin-of-scope %baddr<br>&gt;&gt;    %mut_b = load %baddr<br>&gt;&gt;    store %x to %mut_b    // modification of the buffer<br>&gt;&gt;    // there should be a end-of-scope %baddr<br>&gt;&gt; <br>&gt;&gt;    loop {<br>&gt;&gt;      %b = load %baddr<br>&gt;&gt;      %y = load %b        // load from the buffer<br>&gt;&gt;      ...<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; If there is no end-of-scope instruction, loop hoisting could do::<br>&gt;&gt; <br>&gt;&gt;    %mut_b = load %baddr<br>&gt;&gt;    %b = load %baddr        // moved out of the loop<br>&gt;&gt;    store %x to %mut_b<br>&gt;&gt; <br>&gt;&gt;    loop {<br>&gt;&gt;      %y = load %b<br>&gt;&gt;      ...<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; Now the optimizer assumes that ``%b`` references an immutable buffer, so it could<br>&gt;&gt; also hoist the load::<br>&gt;&gt; <br>&gt;&gt;    %mut_b = load %baddr<br>&gt;&gt;    %b = load %baddr<br>&gt;&gt;    %y = load %b          // Wrong! Will be overwritten by the following store<br>&gt;&gt;    store %x to %mut_b<br>&gt;&gt; <br>&gt;&gt;    loop {<br>&gt;&gt;      ...<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The following sections describe two alternatives to implement the scoping.<br>&gt;&gt; <br>&gt;&gt; Scoping Alternative 1: Explicit Built-ins<br>&gt;&gt; -----------------------------------------<br>&gt;&gt; <br>&gt;&gt; SIL instructions<br>&gt;&gt; ^^^^^^^^^^^^^^^^<br>&gt;&gt; <br>&gt;&gt; The existing ``is_unique`` instruction is changed to a terminator instruction::<br>&gt;&gt; <br>&gt;&gt;    bb0:<br>&gt;&gt;      is_unique_addr_br %0 : $*@sil_cow COWBuffer, bb1, bb2  // %0 is the address of the COWBuffer reference<br>&gt;&gt;    bb1(%1 : $COWBuffer): // the true-block. The payload %1 is the unique reference. Physically identical to &quot;load %0”<br>&gt;&gt;      // usually empty<br>&gt;&gt;      br bb3(%1 : $COWBuffer)<br>&gt;&gt;    bb2:                  // the false-block<br>&gt;&gt;      // usually contains:<br>&gt;&gt;      %2 = apply %copy_buffer<br>&gt;&gt;      %3 = cow_to_ref %2<br>&gt;&gt;      store_strong %3 to %0 : $*@sil_cow COWBuffer<br>&gt;&gt;      br bb3(%2 : $COWBuffer)<br>&gt;&gt;    bb3(%4 : $COWBuffer):<br>&gt;&gt;      // Modify the buffer referenced by %4<br>&gt;&gt;      // ...<br>&gt;&gt; <br>&gt;&gt; The end-of-scope instruction is::<br>&gt;&gt; <br>&gt;&gt;    end_unique_addr %0 : $*COWBuffer<br>&gt;&gt; <br>&gt;&gt; It is important that the references to the unique buffers (``%1``, ``%2``) must<br>&gt;&gt; not outlive ``end_unique_addr``. In most cases this can be check by the SIL<br>&gt;&gt; verifier.<br>&gt;&gt; <br>&gt;&gt; The two instructions must be paired properly but not necessarily in the<br>&gt;&gt; same function.<br>&gt;&gt; <br>&gt; <br>&gt; Would this require a new form of function signature?<br></p><p>No<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; The purpose of an ``is_unique_addr_br`` - ``end_unique_addr`` pair is to<br>&gt;&gt; separate the lifetimes of mutable and immutable accesses to the COW buffer.<br>&gt;&gt; Both instructions take an address to the COW buffer reference and are<br>&gt;&gt; considered as potential stores to the reference.<br>&gt;&gt; This makes sure that the SIL optimizer cannot mix-up buffer reference lifetimes<br>&gt;&gt; across these instructions.<br>&gt;&gt; For example, RLE cannot combine two buffer loads which are interleaved with<br>&gt;&gt; a ``is_unique_addr_br``::<br>&gt;&gt; <br>&gt;&gt;    %1 = load_strong %0 : $*@sil_cow COWBuffer<br>&gt;&gt;    // do something with %1<br>&gt;&gt;    …<br>&gt;&gt;    is_unique_addr_br %0 : $*@sil_cow COWBuffer<br>&gt;&gt;    …<br>&gt;&gt;    %2 = load_strong %0 : $*@sil_cow COWBuffer // RLE cannot replace this with %1<br>&gt; <br>&gt; Can you make this a complete example.<br></p><p>I think in this short version it’s easier to understand. But I added a comment beside the is_unique_addr_br for clarification.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; Another important thing is that the COW buffer can only be mutated by using the<br>&gt;&gt; reference of the ``is_unique_addr_br`` true-block argument.<br>&gt; <br>&gt; On the face this claim is incorrect. I think it is important to be clear here that you mean without any further copying done. It seems to contradict your example above of doing mutable things in bb3.<br>&gt; <br></p><p>You are right. I rewrote this sentence.<br></p><p>&gt;&gt; The COW buffer cannot be modified by simply loading/extracting the reference<br>&gt;&gt; from the COWType.<br>&gt;&gt; Example::<br>&gt;&gt; <br>&gt;&gt;  %1 = load_strong %0 : $*COWBuffer<br>&gt;&gt;  %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;  %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;&gt;  store %7 : $Int to %3 : $*Int            // Violation!<br>&gt;&gt; <br>&gt;&gt; Most obvious violations to this constraint can be catched by the SILVerifier.<br>&gt;&gt; <br>&gt;&gt; The ``_addr`` variants of the instructions also have a non-addr counterpart::<br>&gt;&gt; <br>&gt;&gt;    is_unique_br %0 : $COWBuffer, bb1, bb2.  // consumes %0 and produces the true-block arg as owned<br>&gt;&gt; <br>&gt;&gt;    %1 = end_unique %0 : $COWBuffer // consumes %0 and produces %1 as owned<br>&gt;&gt; <br>&gt;&gt; These instructions are generated by Mem2reg (or a similar optimization)<br>&gt;&gt; in case the COW value is stored (in a temporary alloc_stack location)<br>&gt;&gt; just for the sake of passing an address to ``is_unique_addr_br`` and<br>&gt;&gt; ``end_unique_addr``.<br>&gt;&gt; For example in the following code, where the COW data is passed as-value and<br>&gt;&gt; all the mutating functions are inlined::<br>&gt;&gt; <br>&gt;&gt;    func foo(arr : [Int], x: Int) {<br>&gt;&gt;      arr[0] = 27<br>&gt;&gt;      …<br>&gt;&gt;      y = arr[x]<br>&gt;&gt;      …<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; Finally it’s probably a good idea to add an instruction for converting an<br>&gt;&gt; immutable reference to a mutable reference::<br>&gt;&gt; <br>&gt;&gt;    %1 = start_unique %0 : $COWBuffer // consumes %0 and produces %1 : $COWBuffer as owned<br>&gt;&gt; <br>&gt;&gt; which is basically just a simpler representation of the following pattern::<br>&gt;&gt; <br>&gt;&gt;    bb0:<br>&gt;&gt;      is_unique_br %0 : $@sil_cow COWBuffer, bb1, bb2<br>&gt;&gt;    bb1(%1 : $COWBuffer):<br>&gt;&gt;      … // main control flow continues here<br>&gt;&gt;    bb2:<br>&gt;&gt;      unreachable<br>&gt;&gt; <br>&gt;&gt; An optimizations, which eliminate uniqueness checks, would replace a<br>&gt;&gt; ``is_unique_br`` by a ``start_unique``.<br>&gt; <br>&gt; Question, I imagine that make_mutable is a very common case. Why not just provide such an instruction?<br></p><p>What should a make_mutable instruction do? Or are you just suggesting to rename start_unique to make_mutable?<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; Built-ins<br>&gt;&gt; ^^^^^^^^^<br>&gt;&gt; <br>&gt;&gt; A COW type implementor can generate the new instructions by using a set of built-ins::<br>&gt;&gt; <br>&gt;&gt;    func isUnique&lt;BufferType&gt;(_ buffer: inout BufferType) -&gt; BufferType?<br>&gt;&gt;    func endUnique&lt;BufferType&gt;(_ buffer: inout BufferType)  <br>&gt;&gt; <br>&gt;&gt; For example::<br>&gt;&gt; <br>&gt;&gt;    struct COWType {<br>&gt;&gt;      copy_on_write var b : COWBuffer<br>&gt;&gt; <br>&gt;&gt;      mutating func makeMutable() -&gt; COWBuffer {<br>&gt;&gt;        if let uniqueBuffer = isUnique(&amp;self.b) {<br>&gt;&gt;          return uniqueBuffer<br>&gt;&gt;        }<br>&gt;&gt;        let copiedBuffer = copyBuffer(self.b)<br>&gt;&gt;        self.b = copiedBuffer<br>&gt;&gt;        return copiedBuffer<br>&gt;&gt;      }<br>&gt;&gt; <br>&gt;&gt;      mutating func setSomeData(x: Int) {<br>&gt;&gt;        let uniqueBuffer = makeMutable()<br>&gt;&gt;        uniqueBuffer.someData = x<br>&gt;&gt;        endUnique(&amp;self.b)<br>&gt;&gt;      }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; The ``isUnique`` built-in returns an optional unique buffer reference.<br>&gt;&gt; Physically this is the COW buffer which is passed as the inout argument.<br>&gt;&gt; The result is nil if the buffer is not uniquely referenced.<br>&gt;&gt; In this case usually the original buffer is copied and the reference to the<br>&gt;&gt; copy is written back to the original buffer reference location<br>&gt;&gt; (``self.b = copiedBuffer``).<br>&gt;&gt; Starting at the point of the write-back, the reference to the copy also becomes<br>&gt;&gt; a unique buffer reference.<br>&gt;&gt; <br>&gt;&gt; The ``isUnique`` built-in is lowered to the ``is_unique_addr_br`` pattern which<br>&gt;&gt; constructs the Optional in the successor blocks. Using ``isUnique`` in an<br>&gt;&gt; if-let (as shown above) will end up in two consecutive CFG &quot;diamonds&quot;.<br>&gt;&gt; Simplify-CFG can combine those into a single ``is_unique_addr_br`` diamond.<br>&gt;&gt; <br>&gt;&gt; .. note::<br>&gt;&gt;  This makes the definition of the unique buffer location lifetime a little bit<br>&gt;&gt;  problematic, because the false-branch of ``isUnique`` is not equivalent to<br>&gt;&gt;  the false-branch of the ``is_unique_addr_br`` instruction (before SimplifyCFG<br>&gt;&gt;  can do its job).<br>&gt;&gt; <br>&gt;&gt; The rules for using ``copy_on_write`` and the built-ins are:<br>&gt;&gt; <br>&gt;&gt; 1. ``isUnique`` must be paired with ``endUnique``, but not necessarily in the<br>&gt;&gt;   same function.<br>&gt;&gt; <br>&gt;&gt; 2. The COW buffer may only be mutated by using the unique buffer reference.<br>&gt;&gt; <br>&gt;&gt; 3. The COW buffer must not be mutated outside the ``isUnique`` - ``endUnique``<br>&gt;&gt;   pair.<br>&gt;&gt; <br>&gt;&gt; 4. During the lifetime of the unique buffer reference, the original COW buffer<br>&gt;&gt;   reference must not be used in any way, e.g. for reading from the buffer.<br>&gt;&gt; <br>&gt;&gt;   Note that the lifetime of the unique buffer reference does not include the<br>&gt;&gt;   part between the begin of the ``isUnique`` false-branch and the write-back<br>&gt;&gt;   of the copy. This means is okay to read from the buffer (using ``self.b``)<br>&gt;&gt;   for the purpose of copying.<br>&gt;&gt; <br>&gt;&gt; Examples::<br>&gt;&gt; <br>&gt;&gt;    mutating func setSomeData(x: Int) {<br>&gt;&gt;      let uniqueBuffer = makeMutable()<br>&gt;&gt;      uniqueBuffer.someData = x<br>&gt;&gt;      // violates rule 1<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    mutating func setSomeData(x: Int) {<br>&gt;&gt;      makeMutable()<br>&gt;&gt;      self.b.someData = x // violates rule 2<br>&gt;&gt;      endUnique(&amp;self.b)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    mutating func setSomeData(x: Int) {<br>&gt;&gt;      let uniqueBuffer = makeMutable()<br>&gt;&gt;      uniqueBuffer.someData = x<br>&gt;&gt;      endUnique(&amp;self.b)<br>&gt;&gt;      uniqueBuffer.someData = 27 // violates rule 3<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    mutating func incrementSomeData() {<br>&gt;&gt;      let uniqueBuffer = makeMutable()<br>&gt;&gt;      uniqueBuffer.someData = self.b.someData + 1 // violates rule 4<br>&gt;&gt;      endUnique(&amp;self.b)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The intention of the rules is to ensure that there is no overlap of a<br>&gt;&gt; &quot;read-only&quot; life-range with a &quot;mutable&quot; life-range of the buffer reference.<br>&gt;&gt; It’s the responsibility of the implementor to follow the rules.<br>&gt;&gt; But the compiler (a mandatory diagnostics pass and the SIL verifier) can<br>&gt;&gt; statically detect rule violations in obvious cases (with inter-procedural<br>&gt;&gt; analysis maybe even in most cases).<br>&gt;&gt; <br>&gt;&gt; This approach would require to change some of the internals of our<br>&gt;&gt; current COW data structures in the stdlib (Array, Dictionary, etc.).<br>&gt;&gt; For example, the Array make_mutable semantic functions currently do not return<br>&gt;&gt; the unique buffer.<br>&gt;&gt; <br>&gt;&gt; Scoping Alternative 2: Implicit Inout Scopes<br>&gt;&gt; --------------------------------------------<br>&gt;&gt; <br>&gt;&gt; There is an idea (proposal?) to change the representation of inout variables<br>&gt;&gt; in SIL. This is independent of this proposal, but can be helpful for the<br>&gt;&gt; purpose of defining the scope of a COW mutation.<br>&gt;&gt; <br>&gt;&gt; The basic idea is that SILGen inserts scoping instructions for *all* inout<br>&gt;&gt; variables. And those scoping instructions can be used to define the mutating<br>&gt;&gt; scope of a COW buffer.<br>&gt;&gt; <br>&gt;&gt; The scoping instructions which are inserted by SILGen for an inout scope are::<br>&gt;&gt; <br>&gt;&gt;    begin_exclusive<br>&gt;&gt;    end_exclusive<br>&gt;&gt; <br>&gt;&gt; Simliar to ``is_unique_addr_br`` and ``end_unique_addr``, those instructions take the<br>&gt;&gt; address of the inout variable as argument. For the optimizer those instructions<br>&gt;&gt; look like potential writes to the inout variable.<br>&gt;&gt; <br>&gt;&gt; The implementor of a COW type has to follow the rule that the COW buffer may<br>&gt;&gt; only be modified in mutating functions of the COW type. But this is the case<br>&gt;&gt; anyway because any modification needs a uniqueness check and this can only be<br>&gt;&gt; done in mutating functions.<br>&gt;&gt; <br>&gt;&gt; Example::<br>&gt;&gt; <br>&gt;&gt;    // &gt; mutating func setSomeData(x: Int) {<br>&gt;&gt;    // Accepts a unique reference to the array value (avoiding refcount operations)<br>&gt;&gt;    sil @setSomeData : $(Int, @inout Array) -&gt; () {<br>&gt;&gt;    bb_entry(%x : Int, %arrayref : $*Array&lt;T&gt;) // Begin scope #0<br>&gt;&gt; <br>&gt;&gt;    // &gt;   makeMutable() (inlined)<br>&gt;&gt;    // Forward the unique reference to the `self` array value, still avoiding refcount operations.<br>&gt;&gt;    // Begin the inlined exclusive scope (could be trivially removed).<br>&gt;&gt;    begin_exclusive %arrayref : $*Array&lt;T&gt; // Begin scope #1<br>&gt;&gt; <br>&gt;&gt;    // &gt;    if !isUnique(&amp;self._storage) {<br>&gt;&gt;    // Extract a unique inout reference to the class reference to the array storage.<br>&gt;&gt;    // This begins the isUnique() argument&#39;s exclusive scope. The memory is already exclusive<br>&gt;&gt;    // but the scope helps ensure this is the only alias to _storage.<br>&gt;&gt;    %arrayref._storageref = struct_element_addr [exclusive] %arrayref, #Array._storage<br>&gt;&gt; <br>&gt;&gt;    // Uniqueness checking requires an inout reference to the class reference.<br>&gt;&gt;    // The is_unique instruction does not need to create a new storage reference.<br>&gt;&gt;    // It&#39;s only purpose is to check the RC count, ensure that the checked reference<br>&gt;&gt;    // is inout, and prevent the inout scope from being optimized away.<br>&gt;&gt;    %isuniq = is_unique %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt;&gt; <br>&gt;&gt;    // End the isUnique argument&#39;s exclusive scope (can also be trivially removed).<br>&gt;&gt;    end_exclusive %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt;&gt; <br>&gt;&gt;    br %isuniq, bb_continue, bb_slow<br>&gt;&gt; <br>&gt;&gt;    bb_slow:<br>&gt;&gt;    // &gt;      self._storage = copyBuffer(self._storage)<br>&gt;&gt;    // Produce a new class reference to storage with verifiably unique RC semantics.<br>&gt;&gt;    %copied_storage_class = alloc_ref ...<br>&gt;&gt;    // A begin/end exclusive scope is implicit in store [assign].<br>&gt;&gt;    store [assign] %copied_storage_class to %arrayref._storageref<br>&gt;&gt;    br bb_continue<br>&gt;&gt; <br>&gt;&gt;    bb_continue:<br>&gt;&gt; <br>&gt;&gt;    // This marks the end of makeMutable&#39;s inout `self` scope. Because Array<br>&gt;&gt;    // contains a &quot;copy_on_write&quot; property, the SIL verifier needs to<br>&gt;&gt;    // prove that %arrayref.#_storage has not escaped at this point. This<br>&gt;&gt;    // is equivalent to checking that %arrayref itself is not copied, and<br>&gt;&gt;    // checking each projection of the &quot;copy_on_write&quot; storage property<br>&gt;&gt;    // (%arrayref._storageref) is not copied. Or, if any copies are present,<br>&gt;&gt;    // they must be consumed within this scope.<br>&gt;&gt;    end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #1<br>&gt;&gt; <br>&gt;&gt;    // &gt;    self._storage.someData = x<br>&gt;&gt;    // An _addr instruction with one load/store use doesn&#39;t really need its own scope.<br>&gt;&gt;    %arrayref._storageref = struct_element_addr %arrayref, #Array._storage<br>&gt;&gt; <br>&gt;&gt;    // ARC optimization can promote this to a borrow, replacing strong_release with end_borrow.<br>&gt;&gt;    %arrayref.cow_storage = load [copy] %arrayref._storageref : $*@sil_cow ArrayStorage<br>&gt;&gt;    %arrayref._storage = cow_to_ref %arrayref.cow_storage : $@sil_cow ArrayStorage<br>&gt;&gt; <br>&gt;&gt;    // Write some data into the CoW buffer.<br>&gt;&gt;    // (For simplicity, pretend ArrayStorage has a &quot;someData&quot; field).<br>&gt;&gt;    // A single-use _addr instruction, so no scope.<br>&gt;&gt;    %somedata_addr = ref_element_addr %arrayref._storage, #someData<br>&gt;&gt;    // A store with an implicit [exclusive] scope.<br>&gt;&gt;    store [assign] %x to %somedata_addr<br>&gt;&gt; <br>&gt;&gt;    strong_release %arrayref._storage : $*ArrayStorage&lt;T&gt;<br>&gt;&gt; <br>&gt;&gt;    // End the isUnique argument&#39;s exclusive scope.<br>&gt;&gt;    // The same verification is needed here, but the inner scope would be eliminated.<br>&gt;&gt;    end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #0<br>&gt;&gt; <br>&gt;&gt; In general this approach looks more &quot;user-friendly&quot; than the first alternative.<br>&gt;&gt; But it depends on implementing the general feature to insert the inout scoping<br>&gt;&gt; instructions.<br>&gt;&gt; Also, we still have to think through all the details of this approach.<br>&gt;&gt; <br>&gt;&gt; Dependency between a buffer reference to the scope-begin<br>&gt;&gt; --------------------------------------------------------<br>&gt;&gt; <br>&gt;&gt; With both alternatives there is no explicit dependency from a buffer reference<br>&gt;&gt; to a scope-begin instruction::<br>&gt;&gt; <br>&gt;&gt;    %b_cow = load %baddr<br>&gt;&gt;    %b = cow_to_ref %b_cow<br>&gt;&gt;    %x = load %b             // No dependency between this...<br>&gt;&gt;    ...<br>&gt;&gt;    begin_exclusive %baddr   // ... and this instruction.<br>&gt;&gt;    ...<br>&gt;&gt; <br>&gt;&gt; So in theory the optimizer is free to reschedule the instructions::<br>&gt;&gt; <br>&gt;&gt;    %b_cow = load %baddr<br>&gt;&gt;    %b = cow_to_ref %b_cow<br>&gt;&gt;    ...<br>&gt;&gt;    begin_exclusive %baddr<br>&gt;&gt;    %x = load %b             // Wrong! Buffer could be modified here<br>&gt;&gt;    ...<br>&gt;&gt; <br>&gt;&gt; We still have to figure out how to cope with this.<br>&gt;&gt; <br>&gt;&gt; - We could add an end-of-lifetime instruction for a COW buffer reference, which<br>&gt;&gt;  the optimizer may not move over a begin-of-scope instruction.<br>&gt;&gt; <br>&gt;&gt; - Or we just define the implicit rule for the optimizer that any use of a COW<br>&gt;&gt;  reference may not be moved over a begin-of-scope instruction.<br>&gt;&gt; <br>&gt;&gt; Preconditions<br>&gt;&gt; =============<br>&gt;&gt; <br>&gt;&gt; To benefit from COW optimizations in the stdlib Array, Set and Dictionary data<br>&gt;&gt; structures we first need eager bridging, meaning getting rid of the bridged<br>&gt;&gt; buffer. At least for Array this is implemented as low-level bit operations and<br>&gt;&gt; optimizations cannot reason about it (e.g. finding a reasonable RC-root for the<br>&gt;&gt; buffer reference).<br>&gt;&gt; <br>&gt;&gt; Another thing is that we currently cannot use ``copy_on_write`` for Array<br>&gt;&gt; because of pinning. Array pins it’s buffer when passing an element address to<br>&gt;&gt; an inout parameter. This allows the array buffer to be modified even if its<br>&gt;&gt; reference count is &gt; 1. With ``copy_on_write``, a programmer could break memory<br>&gt;&gt; safety when violating the inout rule. Example::<br>&gt;&gt; <br>&gt;&gt;    var arr = [MyClass()]  // a global array<br>&gt;&gt; <br>&gt;&gt;    foo(&amp;arr[0])        // Pins the buffer of arr during the call<br>&gt;&gt; <br>&gt;&gt;    func foo(_ x: inout MyClass) -&gt; Int {<br>&gt;&gt;      let b = arr       // The ref-count of the buffer is not incremented, because it is pinned!<br>&gt;&gt;      let r = b[0]      // optimizer removes the retain of r because it thinks the following code cannot modify b<br>&gt;&gt;      arr.removeAll()   // does not copy the array buffer and thus de-allocates r<br>&gt;&gt;      return r.i        // use-after-free!<br>&gt;&gt;    }<br>&gt; <br>&gt; From a quick (re-)reading, this proposal still makes sense to me. My largest comment is that I would really like to have some way that the program will assert if the constraints are violated. Otherwise it will be difficult to debug when your invariants are broken. The state machine seems simple enough that I think you could reuse the pinned buffer and (if necessary) 1 additional bit in the object header (or perhaps tagged pointer bits).<br></p><p>Yeah, we could do this. I think it would just be sufficient to write a null pointer into the cow reference on at the begin-scope and restore it at the end-scope. It’s the same thing as having runtime checks for not violating borrowing rules.<br></p><p>&gt; <br>&gt; Michael<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 11, 2016, at 4:48 PM, Erik Eckstein via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a proposal for representing copy-on-write buffers in SIL. Actually it’s still a draft for a proposal. It also heavily depends on how we move forward with SIL ownership.<br>&gt;&gt;&gt; If you have any comments, please let me know.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Erik<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161012/8b9922e7/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b81089e81d6bb1e14b5adb746725de1?s=50"></div><header><strong>copy-on-write proposal</strong> from <string>Alexis</string> &lt;abeingessner at apple.com&gt;<p>October 12, 2016 at 02:00:00pm</p></header><div class="content"><p>I’m having trouble figuring something out: is all of this contingent on all of the relevant operations being completely inlined into a single function at the SIL level? Could failing to inline a standard library function lead to performance cliffs? I understand this is generally true of inlining and dead-code elimination; but I’m wondering how this affects the abstractions we expose. Can we know that some things will “always” work, even if parts aren’t inlined?<br></p><p>&gt; On Oct 11, 2016, at 7:48 PM, Erik Eckstein via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; This is a proposal for representing copy-on-write buffers in SIL. Actually it’s still a draft for a proposal. It also heavily depends on how we move forward with SIL ownership.<br>&gt; &lt;CopyOnWrite.rst&gt;<br>&gt; If you have any comments, please let me know.<br>&gt; <br>&gt; Erik<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f8978dbb959b069613e2d027420615f?s=50"></div><header><strong>copy-on-write proposal</strong> from <string>Erik Eckstein</string> &lt;eeckstein at apple.com&gt;<p>October 12, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 12, 2016, at 11:19 AM, Alexis &lt;abeingessner at apple.com&gt; wrote:<br>&gt; <br>&gt; I’m having trouble figuring something out: is all of this contingent on all of the relevant operations being completely inlined into a single function at the SIL level? Could failing to inline a standard library function lead to performance cliffs? I understand this is generally true of inlining and dead-code elimination; but I’m wondering how this affects the abstractions we expose. Can we know that some things will “always” work, even if parts aren’t inlined?<br></p><p>Yes, also these optimizations heavily rely on inlining. I would say that originally almost everything is inside a called function, just think of all the generated getters/setters. But usually this is not a problem because most of the relevant functions are quite small and always inlined anyway.<br></p><p><br>&gt; <br>&gt;&gt; On Oct 11, 2016, at 7:48 PM, Erik Eckstein via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is a proposal for representing copy-on-write buffers in SIL. Actually it’s still a draft for a proposal. It also heavily depends on how we move forward with SIL ownership.<br>&gt;&gt; &lt;CopyOnWrite.rst&gt;<br>&gt;&gt; If you have any comments, please let me know.<br>&gt;&gt; <br>&gt;&gt; Erik<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>copy-on-write proposal</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>October 12, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Oct 12, 2016, at 11:19 AM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m having trouble figuring something out: is all of this contingent on all of the relevant operations being completely inlined into a single function at the SIL level? Could failing to inline a standard library function lead to performance cliffs? I understand this is generally true of inlining and dead-code elimination; but I’m wondering how this affects the abstractions we expose. Can we know that some things will “always” work, even if parts aren’t inlined?<br></p><p>Well, actually there are two basic approaches that you see within the SIL optimizer. One relies on being able to analyze all instructions between two points in the CFG. That depends on full inlining or deep IPA. The other approach relies on knowledge about aliasing, uniqueness, immutability, and so on reach a conclusion about some opaque region of code.<br></p><p>Some of our optimizations rely on full inlining and conservative analysis, but the more we can capture semantics in SIL, the more we can employ the second approach, which improves the power and robustness of the optimizer.<br></p><p>Erik proposed redundant-load elimination and ARC optimizations that both need to prove the absence of a store to a particular memory location within some region. With the proposed copy-on-write attribute, we can now prove the absence of a store without analyzing any of the instructions in that region. I think this is an good example of the second approach where we can optimize around opaque regions of code. So it’s worth making sure our representation supports that.<br></p><p>It is still true though that enough inlining needs to take place such that we can see a load of the Array storage and access to that storage all in the same function scope.<br></p><p>-Andy<br></p><p>&gt;&gt; On Oct 11, 2016, at 7:48 PM, Erik Eckstein via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is a proposal for representing copy-on-write buffers in SIL. Actually it’s still a draft for a proposal. It also heavily depends on how we move forward with SIL ownership.<br>&gt;&gt; &lt;CopyOnWrite.rst&gt;<br>&gt;&gt; If you have any comments, please let me know.<br>&gt;&gt; <br>&gt;&gt; Erik<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>copy-on-write proposal</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 13, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 11, 2016, at 4:48 PM, Erik Eckstein via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; This is a proposal for representing copy-on-write buffers in SIL. Actually it’s still a draft for a proposal. It also heavily depends on how we move forward with SIL ownership.<br>&gt; &lt;CopyOnWrite.rst&gt;<br>&gt; If you have any comments, please let me know.<br></p><p>The SIL-level design seems sensible to me at a glance. At the language level, I think it would make more sense to treat this as an attribute on class types rather than on properties in structs using the class. I don&#39;t think many people reuse class definitions as both shared reference types and as value type payloads, but beyond that, I think that making it an attribute of classes would put us into a better position to leverage the borrow model to enforce the &quot;mutable-only-when-unique&quot; aspect of COW implementations. John alluded to this in the &quot;SIL address types and borrowing&quot; thread:<br></p><p>&gt; I wonder if it would make more sense to make copy-on-write buffer references a move-only type, so that as long as you were just working with the raw reference (as opposed to the CoW aggregate, which would remain copyable) it wouldn&#39;t get implicitly copied anymore.  You could have mutable and immutable buffer reference types, both move-only, and there could be a consuming checkUnique operation on the immutable one that, I dunno, returned an Either of the mutable and immutable versions.<br>&gt; <br>&gt; For CoW aggregates, you&#39;d need some @copied attribute on the field to make sure that the CoW attribute was still copyable.  Within the implementation of the type, though, you would be projecting out the reference immediately, and thereafter you&#39;d be certain that you were borrowing / moving it around as appropriate.<br></p><p>If &#39;copy-on-write&#39; were a trait on classes, then we could distinguish unique and nonunique references to the class. A unique reference would act like a move-only type to prevent accidental loss of uniqueness. We can also allow a copy-on-write class to have &quot;mutating&quot; methods, and only allow mutation on unique references. It seems to me like, exploring this direction, we could also come up with a way for the high-level value-semantics operations on the struct to statically indicate which methods are known to leave the value&#39;s buffers in a unique state, or which return values that are uniquely owned, which would give the optimizer more ability to avoid uniqueness checks across calls without relying on inlining and IPO.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f8978dbb959b069613e2d027420615f?s=50"></div><header><strong>copy-on-write proposal</strong> from <string>Erik Eckstein</string> &lt;eeckstein at apple.com&gt;<p>October 13, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Oct 13, 2016, at 10:36 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 11, 2016, at 4:48 PM, Erik Eckstein via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is a proposal for representing copy-on-write buffers in SIL. Actually it’s still a draft for a proposal. It also heavily depends on how we move forward with SIL ownership.<br>&gt;&gt; &lt;CopyOnWrite.rst&gt;<br>&gt;&gt; If you have any comments, please let me know.<br>&gt; <br>&gt; The SIL-level design seems sensible to me at a glance. At the language level, I think it would make more sense to treat this as an attribute on class types rather than on properties in structs using the class. I don&#39;t think many people reuse class definitions as both shared reference types and as value type payloads, but beyond that, I think that making it an attribute of classes would put us into a better position to leverage the borrow model to enforce the &quot;mutable-only-when-unique&quot; aspect of COW implementations.<br></p><p>I think this makes sense. Although we would need an attribute on the field as well (what John called the @copied attribute).<br></p><p>&gt; John alluded to this in the &quot;SIL address types and borrowing&quot; thread:<br>&gt; <br>&gt;&gt; I wonder if it would make more sense to make copy-on-write buffer references a move-only type, so that as long as you were just working with the raw reference (as opposed to the CoW aggregate, which would remain copyable) it wouldn&#39;t get implicitly copied anymore.  You could have mutable and immutable buffer reference types, both move-only, and there could be a consuming checkUnique operation on the immutable one that, I dunno, returned an Either of the mutable and immutable versions.<br>&gt;&gt; <br>&gt;&gt; For CoW aggregates, you&#39;d need some @copied attribute on the field to make sure that the CoW attribute was still copyable.  Within the implementation of the type, though, you would be projecting out the reference immediately, and thereafter you&#39;d be certain that you were borrowing / moving it around as appropriate.<br>&gt; <br>&gt; If &#39;copy-on-write&#39; were a trait on classes, then we could distinguish unique and nonunique references to the class. A unique reference would act like a move-only type to prevent accidental loss of uniqueness. We can also allow a copy-on-write class to have &quot;mutating&quot; methods, and only allow mutation on unique references.<br></p><p>The only way to get a unique reference would then be to use the isUnique-builtin - or to create a new buffer. This is good, because we could statically check that the programmer can only modify uniquely referenced buffers (although to get full memory safety we would probably have  to invalidate the original buffer reference between the is_unique - end_unique scope, e.g. by storing a null pointer into it).<br></p><p>Thinking about this in detail I believe we have to change how a COW is implemented. For example we could not write back the unique reference and use it afterwards:<br></p><p>if let uniqueRef = isUnique(&amp;cow.buffer) {<br>} else {<br>  uniqueRef = Buffer()<br>  cow.buffer = uniqueRef // &lt;- this would not work. It’s a copy of a unique buffer<br>}<br>uniqueRef.someData = ...<br></p><p>Instead this could be done like<br></p><p>if let uniqueRef = isUnique(&amp;cow.buffer) {<br>} else {<br>  uniqueRef = Buffer()<br>}<br>uniqueRef.someData = ...<br>cow.buffer = uniqueRef // OK, end of lifetime of uniqueRef<br></p><p>It would mean that we write back the buffer even in the unique-case, But I think this is ok.<br></p><p>For the implementation we would need two different reference types in the AST (unique and nonunique), right? Could this be just a different StorageType?<br></p><p>&gt; It seems to me like, exploring this direction, we could also come up with a way for the high-level value-semantics operations on the struct to statically indicate which methods are known to leave the value&#39;s buffers in a unique state, or which return values that are uniquely owned, which would give the optimizer more ability to avoid uniqueness checks across calls without relying on inlining and IPO.<br>&gt; <br>&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161013/67080d8f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
