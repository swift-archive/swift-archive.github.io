<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6f13bb8ea87a42e72699d1c78dc06464?s=50"></div><header><strong>[Swift 4.0] Conditional conformances via protocol extensions</strong> from <string>Manav Gabhawala</string> &lt;manav1907 at gmail.com&gt;<p>August  3, 2016 at 01:00:00pm</p></header><div class="content"><p>In the generics manifesto<br>(https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md)<br>conditional conformances via protocol extensions is under unlikely.<br></p><p>The manifesto notes:<br></p><p>&quot;This is an extremely powerful feature: is allows one to map the<br>abstractions of one domain into another domain (e.g., every Matrix is<br>a Graph). However, similar to private conformances, it puts a major<br>burden on the dynamic-casting runtime to chase down arbitrarily long<br>and potentially cyclic chains of conformances, which makes efficient<br>implementation nearly impossible.&quot;<br></p><p>Correct me if I’m completely wrong here but I think this is a super<br>useful feature and is worth talking about.<br>Firstly why its super useful if not immediately clear is cause you can<br>do neat things like:<br></p><p>extension Collection : Equatable where Element: Equatable<br></p><p>And you can even make protocols in a module that you did not write<br>conform to an arbitrary other protocol and give it a default<br>implementation.<br></p><p><br>I was wondering why this would put any more of a burden on the runtime<br>than simple inheritance of protocols. The way this could be<br>implemented is to augment the ConformanceTable for nominal types by<br>looking up its protocol extension’s inheritance clauses. I can<br>definitely see this impacting compile time but I don’t see why runtime<br>performance will be any different than simple inheritance. Further,<br>cyclic chains can be detected and broken (compiler error) during the<br>second pass of semantic analysis.<br></p><p>I had a (perhaps naïve) implementation here:<br>https://github.com/apple/swift/pull/2233 and I think now would be a<br>great time to talk about such a feature.<br></p><p>Its possible I completely overlooked something but I would like a more<br>a detailed explanation about why this isn’t possible.<br></p><p>Regards,<br>Manav Gabhawala<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Swift 4.0] Conditional conformances via protocol extensions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>August  3, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Aug 3, 2016, at 10:17 AM, Manav Gabhawala via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I was wondering why this would put any more of a burden on the runtime<br>&gt; than simple inheritance of protocols. The way this could be<br>&gt; implemented is to augment the ConformanceTable for nominal types by<br>&gt; looking up its protocol extension’s inheritance clauses. I can<br>&gt; definitely see this impacting compile time but I don’t see why runtime<br>&gt; performance will be any different than simple inheritance. Further,<br>&gt; cyclic chains can be detected and broken (compiler error) during the<br>&gt; second pass of semantic analysis.<br></p><p>My understanding—which may be incorrect, by the way—is that the issue is mainly with protocol extensions adding conformances, not specifically with those conformances being conditional, and that it specifically has to do with `is` and `as?` checks across module boundaries.<br></p><p>Suppose you have these declarations in module M:<br></p><p>	public protocol AProtocol {…}<br>	public protocol BProtocol: AProtocol {…}<br>	public protocol CProtocol {…}<br>	<br>	// Public or otherwise doesn&#39;t matter here.<br>	public struct Foo: BProtocol {…}<br></p><p>Foo essentially has a flat list of the protocols it conforms to attached to it. Notionally, you can think of that list as looking like:<br></p><p>	Foo.self.conformsTo = [BProtocol.self, AProtocol.self]<br></p><p>And when you write `foo is CProtocol`, that eventually translates into:<br></p><p>	foo.dynamicType.conformsTo.contains(CProtocol.self)<br></p><p>For a `Foo`, since the `conformsTo` list doesn&#39;t include `CProtocol.self`, it returns `false`.<br></p><p>Now imagine that you write a new module, N, and in it you say:<br></p><p>	extension Foo: CProtocol {…}<br></p><p>You have now retroactively conformed `Foo` to `CProtocol`. Swift needs to reach into module M and add `CProtocol.self` to the `Foo.self.conformsTo` list. This is perfectly doable for a concrete type—it&#39;s one flat list, after all.<br></p><p>Instead, though, imagine that module N extended `AProtocol` to add a conformance:<br></p><p>	extension AProtocol: CProtocol {…}<br></p><p>There are two ways to handle this. One is to find all types conforming to `AProtocol`, recursively, and add `CProtocol.self` to their conformance list. The other is to scrap the flat list of conformances and instead make `is` and `as?` recursively search each protocol. Either way, you have replaced a fast, flat operation with a slow, recursive one.<br></p><p>Conditional conformance adds another wrinkle to this, of course—you must not only recursively search the list, but also evaluate the condition to see if it applies in this case. But the general problem of having to replace a fast search with a slow search applies either way.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Swift 4.0] Conditional conformances via protocol extensions</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>August  4, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On 4 Aug 2016, at 03:19, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 3, 2016, at 10:17 AM, Manav Gabhawala via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I was wondering why this would put any more of a burden on the runtime<br>&gt;&gt; than simple inheritance of protocols. The way this could be<br>&gt;&gt; implemented is to augment the ConformanceTable for nominal types by<br>&gt;&gt; looking up its protocol extension’s inheritance clauses. I can<br>&gt;&gt; definitely see this impacting compile time but I don’t see why runtime<br>&gt;&gt; performance will be any different than simple inheritance. Further,<br>&gt;&gt; cyclic chains can be detected and broken (compiler error) during the<br>&gt;&gt; second pass of semantic analysis.<br>&gt; <br>&gt; My understanding—which may be incorrect, by the way—is that the issue is mainly with protocol extensions adding conformances, not specifically with those conformances being conditional, and that it specifically has to do with `is` and `as?` checks across module boundaries.<br>&gt; <br>&gt; Suppose you have these declarations in module M:<br>&gt; <br>&gt; 	public protocol AProtocol {…}<br>&gt; 	public protocol BProtocol: AProtocol {…}<br>&gt; 	public protocol CProtocol {…}<br>&gt; 	<br>&gt; 	// Public or otherwise doesn&#39;t matter here.<br>&gt; 	public struct Foo: BProtocol {…}<br>&gt; <br>&gt; Foo essentially has a flat list of the protocols it conforms to attached to it. Notionally, you can think of that list as looking like:<br>&gt; <br>&gt; 	Foo.self.conformsTo = [BProtocol.self, AProtocol.self]<br>&gt; <br>&gt; And when you write `foo is CProtocol`, that eventually translates into:<br>&gt; <br>&gt; 	foo.dynamicType.conformsTo.contains(CProtocol.self)<br>&gt; <br>&gt; For a `Foo`, since the `conformsTo` list doesn&#39;t include `CProtocol.self`, it returns `false`.<br>&gt; <br>&gt; Now imagine that you write a new module, N, and in it you say:<br>&gt; <br>&gt; 	extension Foo: CProtocol {…}<br>&gt; <br>&gt; You have now retroactively conformed `Foo` to `CProtocol`. Swift needs to reach into module M and add `CProtocol.self` to the `Foo.self.conformsTo` list. This is perfectly doable for a concrete type—it&#39;s one flat list, after all.<br>&gt; <br>&gt; Instead, though, imagine that module N extended `AProtocol` to add a conformance:<br>&gt; <br>&gt; 	extension AProtocol: CProtocol {…}<br>&gt; <br>&gt; There are two ways to handle this. One is to find all types conforming to `AProtocol`, recursively, and add `CProtocol.self` to their conformance list. The other is to scrap the flat list of conformances and instead make `is` and `as?` recursively search each protocol. Either way, you have replaced a fast, flat operation with a slow, recursive one.<br>&gt; <br>&gt; Conditional conformance adds another wrinkle to this, of course—you must not only recursively search the list, but also evaluate the condition to see if it applies in this case. But the general problem of having to replace a fast search with a slow search applies either way.<br></p><p>Great explanation! This switch from flat to recursively searched though seems like it would only occur when the extension is in an external module though; for internal modules would it not still be possible to determine the flat list for each type? In that case extending a type from another module could be either disallowed, or produce a warning to indicate the performance implication?<br></p><p>The feature would still be very useful even just for internal use after all. Also it seems useful on a relatively small number of types, and the number of external modules that need/want to do this must narrow that even further, so external extensions may be quite niche, i.e- not worth losing the feature for internal use if that is indeed easier?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Swift 4.0] Conditional conformances via protocol extensions</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>August  5, 2016 at 08:00:00pm</p></header><div class="content"><p>I&#39;m not very familiar with the runtime so forgive me – the protocols would<br>only have to be added once right? And couldn&#39;t this usually be done at<br>compile time, or does it happen when the module is linked at startup?<br></p><p>On Thu, Aug 4, 2016 at 4:36 PM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 4 Aug 2016, at 03:19, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Aug 3, 2016, at 10:17 AM, Manav Gabhawala via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I was wondering why this would put any more of a burden on the runtime<br>&gt; &gt;&gt; than simple inheritance of protocols. The way this could be<br>&gt; &gt;&gt; implemented is to augment the ConformanceTable for nominal types by<br>&gt; &gt;&gt; looking up its protocol extension’s inheritance clauses. I can<br>&gt; &gt;&gt; definitely see this impacting compile time but I don’t see why runtime<br>&gt; &gt;&gt; performance will be any different than simple inheritance. Further,<br>&gt; &gt;&gt; cyclic chains can be detected and broken (compiler error) during the<br>&gt; &gt;&gt; second pass of semantic analysis.<br>&gt; &gt;<br>&gt; &gt; My understanding—which may be incorrect, by the way—is that the issue is<br>&gt; mainly with protocol extensions adding conformances, not specifically with<br>&gt; those conformances being conditional, and that it specifically has to do<br>&gt; with `is` and `as?` checks across module boundaries.<br>&gt; &gt;<br>&gt; &gt; Suppose you have these declarations in module M:<br>&gt; &gt;<br>&gt; &gt;       public protocol AProtocol {…}<br>&gt; &gt;       public protocol BProtocol: AProtocol {…}<br>&gt; &gt;       public protocol CProtocol {…}<br>&gt; &gt;<br>&gt; &gt;       // Public or otherwise doesn&#39;t matter here.<br>&gt; &gt;       public struct Foo: BProtocol {…}<br>&gt; &gt;<br>&gt; &gt; Foo essentially has a flat list of the protocols it conforms to attached<br>&gt; to it. Notionally, you can think of that list as looking like:<br>&gt; &gt;<br>&gt; &gt;       Foo.self.conformsTo = [BProtocol.self, AProtocol.self]<br>&gt; &gt;<br>&gt; &gt; And when you write `foo is CProtocol`, that eventually translates into:<br>&gt; &gt;<br>&gt; &gt;       foo.dynamicType.conformsTo.contains(CProtocol.self)<br>&gt; &gt;<br>&gt; &gt; For a `Foo`, since the `conformsTo` list doesn&#39;t include<br>&gt; `CProtocol.self`, it returns `false`.<br>&gt; &gt;<br>&gt; &gt; Now imagine that you write a new module, N, and in it you say:<br>&gt; &gt;<br>&gt; &gt;       extension Foo: CProtocol {…}<br>&gt; &gt;<br>&gt; &gt; You have now retroactively conformed `Foo` to `CProtocol`. Swift needs<br>&gt; to reach into module M and add `CProtocol.self` to the<br>&gt; `Foo.self.conformsTo` list. This is perfectly doable for a concrete<br>&gt; type—it&#39;s one flat list, after all.<br>&gt; &gt;<br>&gt; &gt; Instead, though, imagine that module N extended `AProtocol` to add a<br>&gt; conformance:<br>&gt; &gt;<br>&gt; &gt;       extension AProtocol: CProtocol {…}<br>&gt; &gt;<br>&gt; &gt; There are two ways to handle this. One is to find all types conforming<br>&gt; to `AProtocol`, recursively, and add `CProtocol.self` to their conformance<br>&gt; list. The other is to scrap the flat list of conformances and instead make<br>&gt; `is` and `as?` recursively search each protocol. Either way, you have<br>&gt; replaced a fast, flat operation with a slow, recursive one.<br>&gt; &gt;<br>&gt; &gt; Conditional conformance adds another wrinkle to this, of course—you must<br>&gt; not only recursively search the list, but also evaluate the condition to<br>&gt; see if it applies in this case. But the general problem of having to<br>&gt; replace a fast search with a slow search applies either way.<br>&gt;<br>&gt; Great explanation! This switch from flat to recursively searched though<br>&gt; seems like it would only occur when the extension is in an external module<br>&gt; though; for internal modules would it not still be possible to determine<br>&gt; the flat list for each type? In that case extending a type from another<br>&gt; module could be either disallowed, or produce a warning to indicate the<br>&gt; performance implication?<br>&gt;<br>&gt; The feature would still be very useful even just for internal use after<br>&gt; all. Also it seems useful on a relatively small number of types, and the<br>&gt; number of external modules that need/want to do this must narrow that even<br>&gt; further, so external extensions may be quite niche, i.e- not worth losing<br>&gt; the feature for internal use if that is indeed easier?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160805/44f7fcb0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Swift 4.0] Conditional conformances via protocol extensions</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>August 11, 2016 at 10:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Aug 4, 2016, at 2:36 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On 4 Aug 2016, at 03:19, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Aug 3, 2016, at 10:17 AM, Manav Gabhawala via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was wondering why this would put any more of a burden on the runtime<br>&gt;&gt;&gt; than simple inheritance of protocols. The way this could be<br>&gt;&gt;&gt; implemented is to augment the ConformanceTable for nominal types by<br>&gt;&gt;&gt; looking up its protocol extension’s inheritance clauses. I can<br>&gt;&gt;&gt; definitely see this impacting compile time but I don’t see why runtime<br>&gt;&gt;&gt; performance will be any different than simple inheritance. Further,<br>&gt;&gt;&gt; cyclic chains can be detected and broken (compiler error) during the<br>&gt;&gt;&gt; second pass of semantic analysis.<br>&gt;&gt; <br>&gt;&gt; My understanding—which may be incorrect, by the way—is that the issue is mainly with protocol extensions adding conformances, not specifically with those conformances being conditional, and that it specifically has to do with `is` and `as?` checks across module boundaries.<br>&gt;&gt; <br>&gt;&gt; Suppose you have these declarations in module M:<br>&gt;&gt; <br>&gt;&gt;    public protocol AProtocol {…}<br>&gt;&gt;    public protocol BProtocol: AProtocol {…}<br>&gt;&gt;    public protocol CProtocol {…}<br>&gt;&gt;    <br>&gt;&gt;    // Public or otherwise doesn&#39;t matter here.<br>&gt;&gt;    public struct Foo: BProtocol {…}<br>&gt;&gt; <br>&gt;&gt; Foo essentially has a flat list of the protocols it conforms to attached to it. Notionally, you can think of that list as looking like:<br>&gt;&gt; <br>&gt;&gt;    Foo.self.conformsTo = [BProtocol.self, AProtocol.self]<br>&gt;&gt; <br>&gt;&gt; And when you write `foo is CProtocol`, that eventually translates into:<br>&gt;&gt; <br>&gt;&gt;    foo.dynamicType.conformsTo.contains(CProtocol.self)<br>&gt;&gt; <br>&gt;&gt; For a `Foo`, since the `conformsTo` list doesn&#39;t include `CProtocol.self`, it returns `false`.<br>&gt;&gt; <br>&gt;&gt; Now imagine that you write a new module, N, and in it you say:<br>&gt;&gt; <br>&gt;&gt;    extension Foo: CProtocol {…}<br>&gt;&gt; <br>&gt;&gt; You have now retroactively conformed `Foo` to `CProtocol`. Swift needs to reach into module M and add `CProtocol.self` to the `Foo.self.conformsTo` list. This is perfectly doable for a concrete type—it&#39;s one flat list, after all.<br>&gt;&gt; <br>&gt;&gt; Instead, though, imagine that module N extended `AProtocol` to add a conformance:<br>&gt;&gt; <br>&gt;&gt;    extension AProtocol: CProtocol {…}<br>&gt;&gt; <br>&gt;&gt; There are two ways to handle this. One is to find all types conforming to `AProtocol`, recursively, and add `CProtocol.self` to their conformance list. The other is to scrap the flat list of conformances and instead make `is` and `as?` recursively search each protocol. Either way, you have replaced a fast, flat operation with a slow, recursive one.<br>&gt;&gt; <br>&gt;&gt; Conditional conformance adds another wrinkle to this, of course—you must not only recursively search the list, but also evaluate the condition to see if it applies in this case. But the general problem of having to replace a fast search with a slow search applies either way.<br>&gt; <br>&gt; Great explanation! This switch from flat to recursively searched though seems like it would only occur when the extension is in an external module though; for internal modules would it not still be possible to determine the flat list for each type? In that case extending a type from another module could be either disallowed, or produce a warning to indicate the performance implication?<br>&gt; <br>&gt; The feature would still be very useful even just for internal use after all. Also it seems useful on a relatively small number of types, and the number of external modules that need/want to do this must narrow that even further, so external extensions may be quite niche, i.e- not worth losing the feature for internal use if that is indeed easier?<br></p><p>Swift doesn&#39;t really have any features that stop working across modules. We&#39;re okay with the programmer having to think more and be more explicit across module boundaries (since it is API design at that point), but it&#39;d take a very strong argument to have different runtime semantics across module boundaries. <br></p><p>FWIW, I&#39;m planning to write a complete proposal for conditional conformances and will start posting drafts once it is far enough along to be useful. It won&#39;t have support for protocols conforming to other protocols, though. <br></p><p>  - Doug<br></p><p>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160811/013c1f23/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Swift 4.0] Conditional conformances via protocol extensions</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>September 10, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Am 12.08.2016 um 04:39 schrieb Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On Aug 4, 2016, at 2:36 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On 4 Aug 2016, at 03:19, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 3, 2016, at 10:17 AM, Manav Gabhawala via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was wondering why this would put any more of a burden on the runtime<br>&gt;&gt;&gt;&gt; than simple inheritance of protocols. The way this could be<br>&gt;&gt;&gt;&gt; implemented is to augment the ConformanceTable for nominal types by<br>&gt;&gt;&gt;&gt; looking up its protocol extension’s inheritance clauses. I can<br>&gt;&gt;&gt;&gt; definitely see this impacting compile time but I don’t see why runtime<br>&gt;&gt;&gt;&gt; performance will be any different than simple inheritance. Further,<br>&gt;&gt;&gt;&gt; cyclic chains can be detected and broken (compiler error) during the<br>&gt;&gt;&gt;&gt; second pass of semantic analysis.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My understanding—which may be incorrect, by the way—is that the issue is mainly with protocol extensions adding conformances, not specifically with those conformances being conditional, and that it specifically has to do with `is` and `as?` checks across module boundaries.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Suppose you have these declarations in module M:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    public protocol AProtocol {…}<br>&gt;&gt;&gt;    public protocol BProtocol: AProtocol {…}<br>&gt;&gt;&gt;    public protocol CProtocol {…}<br>&gt;&gt;&gt;    <br>&gt;&gt;&gt;    // Public or otherwise doesn&#39;t matter here.<br>&gt;&gt;&gt;    public struct Foo: BProtocol {…}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Foo essentially has a flat list of the protocols it conforms to attached to it. Notionally, you can think of that list as looking like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Foo.self.conformsTo = [BProtocol.self, AProtocol.self]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And when you write `foo is CProtocol`, that eventually translates into:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    foo.dynamicType.conformsTo.contains(CProtocol.self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For a `Foo`, since the `conformsTo` list doesn&#39;t include `CProtocol.self`, it returns `false`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now imagine that you write a new module, N, and in it you say:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    extension Foo: CProtocol {…}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You have now retroactively conformed `Foo` to `CProtocol`. Swift needs to reach into module M and add `CProtocol.self` to the `Foo.self.conformsTo` list. This is perfectly doable for a concrete type—it&#39;s one flat list, after all.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Instead, though, imagine that module N extended `AProtocol` to add a conformance:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    extension AProtocol: CProtocol {…}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are two ways to handle this. One is to find all types conforming to `AProtocol`, recursively, and add `CProtocol.self` to their conformance list. The other is to scrap the flat list of conformances and instead make `is` and `as?` recursively search each protocol. Either way, you have replaced a fast, flat operation with a slow, recursive one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conditional conformance adds another wrinkle to this, of course—you must not only recursively search the list, but also evaluate the condition to see if it applies in this case. But the general problem of having to replace a fast search with a slow search applies either way.<br>&gt;&gt; <br>&gt;&gt; Great explanation! This switch from flat to recursively searched though seems like it would only occur when the extension is in an external module though; for internal modules would it not still be possible to determine the flat list for each type? In that case extending a type from another module could be either disallowed, or produce a warning to indicate the performance implication?<br>&gt;&gt; <br>&gt;&gt; The feature would still be very useful even just for internal use after all. Also it seems useful on a relatively small number of types, and the number of external modules that need/want to do this must narrow that even further, so external extensions may be quite niche, i.e- not worth losing the feature for internal use if that is indeed easier?<br>&gt; <br>&gt; Swift doesn&#39;t really have any features that stop working across modules. We&#39;re okay with the programmer having to think more and be more explicit across module boundaries (since it is API design at that point), but it&#39;d take a very strong argument to have different runtime semantics across module boundaries. <br>&gt; <br>&gt; FWIW, I&#39;m planning to write a complete proposal for conditional conformances and will start posting drafts once it is far enough along to be useful. It won&#39;t have support for protocols conforming to other protocols, though. <br>&gt; <br>&gt;   - Doug<br>&gt; <br></p><p>Hi Doug,<br></p><p>When can we expect your proposal?<br></p><p>Best regards<br>Maximilian<br></p><p>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160910/6ac91052/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Swift 4.0] Conditional conformances via protocol extensions</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September 10, 2016 at 02:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Sep 10, 2016, at 2:26 PM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Am 12.08.2016 um 04:39 schrieb Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 4, 2016, at 2:36 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 4 Aug 2016, at 03:19, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 3, 2016, at 10:17 AM, Manav Gabhawala via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I was wondering why this would put any more of a burden on the runtime<br>&gt;&gt;&gt;&gt;&gt; than simple inheritance of protocols. The way this could be<br>&gt;&gt;&gt;&gt;&gt; implemented is to augment the ConformanceTable for nominal types by<br>&gt;&gt;&gt;&gt;&gt; looking up its protocol extension’s inheritance clauses. I can<br>&gt;&gt;&gt;&gt;&gt; definitely see this impacting compile time but I don’t see why runtime<br>&gt;&gt;&gt;&gt;&gt; performance will be any different than simple inheritance. Further,<br>&gt;&gt;&gt;&gt;&gt; cyclic chains can be detected and broken (compiler error) during the<br>&gt;&gt;&gt;&gt;&gt; second pass of semantic analysis.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My understanding—which may be incorrect, by the way—is that the issue is mainly with protocol extensions adding conformances, not specifically with those conformances being conditional, and that it specifically has to do with `is` and `as?` checks across module boundaries.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Suppose you have these declarations in module M:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    public protocol AProtocol {…}<br>&gt;&gt;&gt;&gt;    public protocol BProtocol: AProtocol {…}<br>&gt;&gt;&gt;&gt;    public protocol CProtocol {…}<br>&gt;&gt;&gt;&gt;    <br>&gt;&gt;&gt;&gt;    // Public or otherwise doesn&#39;t matter here.<br>&gt;&gt;&gt;&gt;    public struct Foo: BProtocol {…}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Foo essentially has a flat list of the protocols it conforms to attached to it. Notionally, you can think of that list as looking like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    Foo.self.conformsTo = [BProtocol.self, AProtocol.self]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And when you write `foo is CProtocol`, that eventually translates into:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    foo.dynamicType.conformsTo.contains(CProtocol.self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For a `Foo`, since the `conformsTo` list doesn&#39;t include `CProtocol.self`, it returns `false`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now imagine that you write a new module, N, and in it you say:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    extension Foo: CProtocol {…}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You have now retroactively conformed `Foo` to `CProtocol`. Swift needs to reach into module M and add `CProtocol.self` to the `Foo.self.conformsTo` list. This is perfectly doable for a concrete type—it&#39;s one flat list, after all.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Instead, though, imagine that module N extended `AProtocol` to add a conformance:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    extension AProtocol: CProtocol {…}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are two ways to handle this. One is to find all types conforming to `AProtocol`, recursively, and add `CProtocol.self` to their conformance list. The other is to scrap the flat list of conformances and instead make `is` and `as?` recursively search each protocol. Either way, you have replaced a fast, flat operation with a slow, recursive one.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Conditional conformance adds another wrinkle to this, of course—you must not only recursively search the list, but also evaluate the condition to see if it applies in this case. But the general problem of having to replace a fast search with a slow search applies either way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Great explanation! This switch from flat to recursively searched though seems like it would only occur when the extension is in an external module though; for internal modules would it not still be possible to determine the flat list for each type? In that case extending a type from another module could be either disallowed, or produce a warning to indicate the performance implication?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The feature would still be very useful even just for internal use after all. Also it seems useful on a relatively small number of types, and the number of external modules that need/want to do this must narrow that even further, so external extensions may be quite niche, i.e- not worth losing the feature for internal use if that is indeed easier?<br>&gt;&gt; <br>&gt;&gt; Swift doesn&#39;t really have any features that stop working across modules. We&#39;re okay with the programmer having to think more and be more explicit across module boundaries (since it is API design at that point), but it&#39;d take a very strong argument to have different runtime semantics across module boundaries. <br>&gt;&gt; <br>&gt;&gt; FWIW, I&#39;m planning to write a complete proposal for conditional conformances and will start posting drafts once it is far enough along to be useful. It won&#39;t have support for protocols conforming to other protocols, though. <br>&gt;&gt; <br>&gt;&gt;   - Doug<br>&gt;&gt; <br>&gt; <br>&gt; Hi Doug,<br>&gt; <br>&gt; When can we expect your proposal?<br></p><p>Within the next few weeks, I hope. <br></p><p>  - Doug<br></p><p>&gt; <br>&gt; Best regards<br>&gt; Maximilian<br>&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160910/c3730c63/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Swift 4.0] Conditional conformances via protocol extensions</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>September 12, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Aug 11, 2016, at 9:39 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; FWIW, I&#39;m planning to write a complete proposal for conditional conformances and will start posting drafts once it is far enough along to be useful.<br></p><p>I’m looking forward to that!<br></p><p>I’ll throw a potential use case for this your way, both one of the most obvious and one of the nastiest I’ve encountered, in case it helps refine the proposal and/or clarify its limits:<br></p><p>    // No more runtime exceptions from things buried in<br>    // dictionaries! Wouldn’t it be nice?<br></p><p>    protocol JSONRepresentable { }<br></p><p>    // So far so good:<br></p><p>    extension String: JSONRepresentable { }<br></p><p>    // Hmm, extending protocols is out:<br></p><p>    extension Integer: JSONRepresentable { }<br>    extension FloatingPoint: JSONRepresentable { }<br></p><p>    // I can imagine a universe where this works:<br></p><p>    extension Optional: JSONRepresentable<br>        where Wrapped: JSONRepresentable { }<br></p><p>    // ...but this, oh dear:<br></p><p>    extension Optional.None: JSONRepresentable { }<br></p><p>    // Collection would be better but ... extending protocols again:<br></p><p>    extension Array: JSONRepresentable<br>        where Element: JSONRepresentable { }<br></p><p>    extension Dictionary: JSONRepresentable<br>        where Key == String, Value: JSONRepresentable { }<br></p><p>I imagine this is all a bridge too far for a proposal at this time — and maybe a bridge too far for any conditional protocol conformance ever — but it seems like it needs addressing.<br></p><p>&gt; It won&#39;t have support for protocols conforming to other protocols, though. <br></p><p>Curious. Why not? (I’ll happily wait for the proposal if you explain it there.)<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160912/ecc59672/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Swift 4.0] Conditional conformances via protocol extensions</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September 12, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Sep 12, 2016, at 8:14 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 11, 2016, at 9:39 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; FWIW, I&#39;m planning to write a complete proposal for conditional conformances and will start posting drafts once it is far enough along to be useful.<br>&gt; <br>&gt; I’m looking forward to that!<br>&gt; <br>&gt; I’ll throw a potential use case for this your way, both one of the most obvious and one of the nastiest I’ve encountered, in case it helps refine the proposal and/or clarify its limits:<br>&gt; <br>&gt;     // No more runtime exceptions from things buried in<br>&gt;     // dictionaries! Wouldn’t it be nice?<br>&gt; <br>&gt;     protocol JSONRepresentable { }<br>&gt; <br>&gt;     // So far so good:<br>&gt; <br>&gt;     extension String: JSONRepresentable { }<br>&gt; <br>&gt;     // Hmm, extending protocols is out:<br>&gt; <br>&gt;     extension Integer: JSONRepresentable { }<br>&gt;     extension FloatingPoint: JSONRepresentable { }<br>&gt; <br>&gt;     // I can imagine a universe where this works:<br>&gt; <br>&gt;     extension Optional: JSONRepresentable<br>&gt;         where Wrapped: JSONRepresentable { }<br></p><p>Fine so far.<br></p><p>&gt; <br>&gt;     // ...but this, oh dear:<br>&gt; <br>&gt;     extension Optional.None: JSONRepresentable { }<br></p><p>This will be ill-formed; Optional.None isn’t a type, it’s part of the value, and allowing the conformance to be present or absent based on a run-time value is a massive complication:<br></p><p><br>  func f&lt;T: JSONRepresentable&gt;(_: T) { }<br>  func g(stringOpt: String?)  { f(stringOpt) } // whether the conformance applies or not depends on the run-time value!<br></p><p><br>&gt; <br>&gt;     // Collection would be better but ... extending protocols again:<br>&gt; <br>&gt;     extension Array: JSONRepresentable<br>&gt;         where Element: JSONRepresentable { }<br>&gt; <br>&gt;     extension Dictionary: JSONRepresentable<br>&gt;         where Key == String, Value: JSONRepresentable { }<br>&gt; <br>&gt; I imagine this is all a bridge too far for a proposal at this time — and maybe a bridge too far for any conditional protocol conformance ever — but it seems like it needs addressing.<br></p><p>These last two should be fine.<br></p><p>&gt;&gt; It won&#39;t have support for protocols conforming to other protocols, though. <br>&gt; <br>&gt; Curious. Why not? (I’ll happily wait for the proposal if you explain it there.)<br></p><p>The generics manifesto has a sketch of the reason; I will elaborate in the proposal.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160912/ade64dc0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Swift 4.0] Conditional conformances via protocol extensions</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>September 12, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Sep 12, 2016, at 12:04 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Sep 12, 2016, at 8:14 AM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;     // ...but this, oh dear:<br>&gt;&gt; <br>&gt;&gt;     extension Optional.None: JSONRepresentable { }<br>&gt; <br>&gt; This will be ill-formed; Optional.None isn’t a type, it’s part of the value, and allowing the conformance to be present or absent based on a run-time value is a massive complication:<br>&gt; <br>&gt; <br>&gt;   func f&lt;T: JSONRepresentable&gt;(_: T) { }<br>&gt;   func g(stringOpt: String?)  { f(stringOpt) } // whether the conformance applies or not depends on the run-time value!<br></p><p>Got it. This is more or less what I meant by “oh dear,” but better spelled out.<br></p><p>Two thoughts pop up from your response:<br></p><p>1. I just realized that my extension Optional.None is totally unnecessary. This covers nil as well as wrapped values:<br></p><p>    extension Optional: JSONRepresentable<br>        where Wrapped: JSONRepresentable    <br></p><p>…and there’s no need to special-case nil.<br></p><p>I still fall into the trap of forgetting that in Swift, different nils can have different types. I still vaguely think of there being a single-value NilType (wrong) that’s a subtype (wrong) of all reference types (wrong). Old habits die hard!<br></p><p>2. That notwithstanding, I’ve come across a few cases where it would be useful to have individual enum cases either be different subtypes of their enclosing enum type, or conform to different protocols. I’ll post next time I hit a useful example of that situation.<br></p><p>&gt; <br>&gt;&gt;&gt; It won&#39;t have support for protocols conforming to other protocols, though. <br>&gt;&gt; <br>&gt;&gt; Curious. Why not? (I’ll happily wait for the proposal if you explain it there.)<br>&gt; <br>&gt; The generics manifesto has a sketch of the reason; I will elaborate in the proposal.<br></p><p>I await it with patient excitement. :)<br></p><p>Cheers, P<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160912/1197c9d9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
