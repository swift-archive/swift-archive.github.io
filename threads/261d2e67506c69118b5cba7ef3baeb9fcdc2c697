<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b8bf05da94075eaf54aef21d05677f77?s=50"></div><header><strong>Referencing different objects implementing a protocol where the protocol has &#39;associatedtype&#39;</strong> from <string>Palfi, Andras</string> &lt;andras.palfi at sap.com&gt;<p>September 18, 2016 at 01:00:00pm</p></header><div class="content"><p>Hi All,<br></p><p>Using protocols are quite important in case of “plugin” concept to implement delegation: allow others to implement small components which will be run in specific cases.<br>To support one component a delegate or closure is sufficient. For the delegate we can use the protocol as referenced type unless it has associated type. If it uses associated type we can still use Generics to reference the object and use protocol only for constraints.<br>Allowing more components to subscribe causes the problem that we cannot reference them:<br></p><p>·         We cannot use generics as there can be any arbitrary number and type of objects so we have to use protocols to reference them<br></p><p>·         When there is an associatedtype in the protocol it is not possible to use to reference objects<br></p><p>For example:<br>We have a generic class which holds a collection of some type of objects – the generic parameter is a type of an item.<br>This class exposes a kind of delegate (specified by a protocol) and arbitrary number of implementers can subscribe. These delegates will be called in a specific case: for example when a new item is added to the collection.<br>The defined protocol uses associatedtype since the specific type of element is unkown.<br>The problem that the code cannot compile because of the error: &quot;protocol &#39;SomeProtocol&#39; can only be used as a generic constraint because it has Self or associated type requirements&quot;<br></p><p>So we know the specific element we want to store but still cannot specify it. We cannot use generic for the ‘delegates’ as it should contain different implementations of SomeProtocol.<br></p><p><br>protocol SomeProtocol {<br>    associatedtype ElementType<br></p><p>    func someMethod(withElement: ElementType) -&gt; Void<br>}<br></p><p>class SomeProtocolImplInt : SomeProtocol {<br>    typealias ElementType = Int<br></p><p>    var sum : Int = 0<br></p><p>    func someMethod(withElement element: Int) {<br>        sum += element<br>    }<br>}<br></p><p>class Container&lt;SomeElementType&gt;  {<br>    typealias ElementType = SomeElementType<br></p><p>    var elements = Array&lt;SomeElementType&gt;()<br></p><p>    var delegates = Array&lt;SomeProtocol where SomeProtocol.ElementType==SomeElementType&gt;() // ‘where’ could solve the problem but not allowed here<br></p><p>    func subscribe&lt;D : SomeProtocol&gt;(delegate : D) where D.ElementType==SomeElementType { // would be better without generics as this generates as many methods as many different types used to call it<br>        delegates.append(delegate)<br>    }<br></p><p>    func add(element: SomeElementType) {<br></p><p>        for delegate in delegates {<br>            delegate.someMethod(withElement: element)<br>        }<br>        elements.append(element)<br>    }<br>}<br></p><p>// usage:<br>var container = Container&lt;Int&gt;()<br>let calculator = SomeProtocolImplInt()<br>container.subscribe(delegate: calculator)<br>container.add(element: 1)<br></p><p><br>Workaround:<br>Use &#39;Thunks&#39;. These are type eraser structs, which implements the same protocol. For each method they referencing (capturing) the original methods and properties of the object. So &#39;thunks&#39; are technically proxy objects.<br></p><p>struct DirtyThunk&lt;SomeElementType&gt; : SomeProtocol {<br></p><p>    private let _someMethod : (SomeElementType) -&gt; Void<br></p><p>    init&lt;D : SomeProtocol&gt;(delegate : D) where D.ElementType==SomeElementType {<br>        _someMethod = delegate.someMethod<br>    }<br></p><p>    func someMethod(withElement: SomeElementType) {<br>        _someMethod(withElement)<br>    }<br>}<br></p><p>the subscribe method will be modified:<br>func subscribe&lt;D : SomeProtocol&gt;(delegate : D) where D.ElementType==SomeElementType { // would be better without generics as this generates as many methods as many different types used to call it<br>        let thunk = DirtyThunk(delegate)<br>        delegates.append(thunk)<br>    }<br></p><p>This solution works - however we can never retrieve the original object any more as it is not referenced. The implementation of the “thunks” are also painful a bit. The methods are captured only by the name of the methods without the parameters so leads the problem if different methods have the same prefix.<br></p><p>I tried to solve using ‘Any’ to reference the delegates but then cannot cast to a proper type to call them.<br></p><p><br>Do one know any better solution?<br></p><p><br>Thanks,<br>Andras<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160918/261dc697/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Referencing different objects implementing a protocol where the protocol has &#39;associatedtype&#39;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>September 20, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Sep 18, 2016, at 6:21 AM, Palfi, Andras via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Workaround:<br>&gt; Use &#39;Thunks&#39;. These are type eraser structs, which implements the same protocol. For each method they referencing (capturing) the original methods and properties of the object. So &#39;thunks&#39; are technically proxy objects. <br>&gt; <br>&gt; struct DirtyThunk&lt;SomeElementType&gt; : SomeProtocol {<br>&gt; <br>&gt;    private let _someMethod : (SomeElementType) -&gt; Void<br>&gt; <br>&gt;    init&lt;D : SomeProtocol&gt;(delegate : D) where D.ElementType==SomeElementType {<br>&gt;        _someMethod = delegate.someMethod<br>&gt;    }<br>&gt; <br>&gt;    func someMethod(withElement: SomeElementType) {<br>&gt;        _someMethod(withElement)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; the subscribe method will be modified:<br>&gt; func subscribe&lt;D : SomeProtocol&gt;(delegate : D) where D.ElementType==SomeElementType { // would be better without generics as this generates as many methods as many different types used to call it<br>&gt;        let thunk = DirtyThunk(delegate)<br>&gt;        delegates.append(thunk)<br>&gt;    }<br>&gt; <br>&gt; This solution works - however we can never retrieve the original object any more as it is not referenced. The implementation of the “thunks” are also painful a bit. The methods are captured only by the name of the methods without the parameters so leads the problem if different methods have the same prefix.<br>&gt; <br>&gt; I tried to solve using ‘Any’ to reference the delegates but then cannot cast to a proper type to call them.<br>&gt; <br>&gt; <br>&gt; Do one know any better solution?<br></p><p>There&#39;s a more complex way to write a &quot;type-erased wrapper&quot; (the preferred Swift term for a thunk). The trick is that you use a base class which is *not* generic on the actual type, plus a derived class which *is* generic on the actual type, to hold the actual instance. For example:<br></p><p>	private class SomeProtocolBox&lt;SomeElementType&gt; {<br>		private init() {}<br>		<br>		func someMethod(withElement: SomeElementType) { fatalError() }<br>	}<br>	<br>	private class ConcreteSomeProtocolBox&lt;SomeProtocolType: SomeProtocol&gt;: SomeProtocolBox&lt;SomeProtocolType.ElementType&gt; {<br>		var value: SomeProtocolType<br>		<br>		init(_ value: SomeProtocolType) {<br>			self.value = value<br>		}<br>		<br>		override func someMethod(withElement: SomeElementType) {<br>			value.someMethod(withElement: withElement)<br>		}<br>	}<br>	<br>	public struct AnySomeProtocol&lt;SomeElementType&gt;: SomeProtocol {<br>		public typealias ElementType = SomeElementType<br>		<br>		private var box: SomeProtocolBox&lt;SomeElementType&gt;<br>		<br>		public init&lt;T: SomeProtocol&gt;(_ value: T) where T.ElementType == SomeElementType {<br>			box = ConcreteSomeProtocolBox(value)<br>		}<br>		<br>		func someMethod(withElement: SomeElementType) {<br>			box.someMethod(withElement: withElement)<br>		}<br>	}<br></p><p>With this in place, it&#39;s not difficult to support recovering the original instance as an `Any`:<br></p><p>	extension SomeProtocolBox {<br>		var base: Any { fatalError() }<br>	}<br>	extension ConcreteSomeProtocolBox {<br>		override var base: Any { return value }<br>	}<br>	extension AnySomeProtocol {<br>		var base: Any { return box.base }<br>	}<br></p><p>It&#39;s also more efficient than the closure-based solution, since it doesn&#39;t need a separate closure (and context) for each method it indirects.<br></p><p>There&#39;s some hope that eventually all of this will be unnecessary and you&#39;ll be able to use protocols with associated types in more places, possibly with some special casting syntax to make sure you&#39;re passing the proper type. No idea if or when that will actually be implemented, though.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
