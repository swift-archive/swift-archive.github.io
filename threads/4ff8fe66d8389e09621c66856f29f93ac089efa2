<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>[Review] SE-0070: Make Optional Requirements Objective-C only</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>April 25, 2016 at 08:00:00pm</p></header><div class="content"><p>Eliminating optional protocol requirements is fine by me. The proposal mentions ‘correcting’ the optional protocol requirement pattern by changing the methods to optional closure properties, but my feeling is that this ‘solution’ just acts to continue and perhaps encourage the anti-pattern established by ObjC. I think a native Swift design would be much better off using optional closure properties on the table view itself.<br></p><p>A common theme in these ObjC optional protocol requirements is the first parameter being an instance whichever class ‘requires’ the method. Yet on the rare occasion of the instance potentially having more than one value, the implementation for each instance is often so different that my first action will be to add a switch between the possible instances (which, of course, means having those components available as IBOutlet properties anyway).<br></p><p>I suggest a much better solution to optional protocol requirements in Swift is the creation of wrappers for UIKit components. These would implement the protocol requirements, and expose optional closure properties for their their public API. Making them properties makes it far clearer that the behaviour of the container will change if a value is provided, and would remove the persistent need to apply @objc to any Swift types dealing with UIKit. I understand this would be a manual task, but I just don&#39;t think there is a good automatic solution to this problem.<br></p><p>------------ Begin Message ------------ <br>Group: gmane.comp.lang.swift.evolution <br>MsgID: &lt;A57B248C-9679-450A-A09D-8C0A5E3846E8 at apple.com&gt; <br></p><p>Hello Swift community,<br></p><p>The review of &quot;SE-0070: Make Optional Requirements Objective-C only&quot; begins now and runs through May 2. The proposal is available here:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0070-optional-requirements.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>* What is your evaluation of the proposal?<br>* Is the problem being addressed significant enough to warrant a change to Swift?<br>* Does this proposal fit well with the feel and direction of Swift?<br>* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>� �<br></p><p>------------- End Message ------------- <br></p><p><br></p><p>From James F<br></p><p><br>From James F<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0070: Make Optional Requirements Objective-C only</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 25, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Apr 25, 2016, at 12:18 PM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Eliminating optional protocol requirements is fine by me. The proposal mentions ‘correcting’ the optional protocol requirement pattern by changing the methods to optional closure properties, but my feeling is that this ‘solution’ just acts to continue and perhaps encourage the anti-pattern established by ObjC. I think a native Swift design would be much better off using optional closure properties on the table view itself.<br>&gt; <br>&gt; A common theme in these ObjC optional protocol requirements is the first parameter being an instance whichever class ‘requires’ the method. Yet on the rare occasion of the instance potentially having more than one value, the implementation for each instance is often so different that my first action will be to add a switch between the possible instances (which, of course, means having those components available as IBOutlet properties anyway).<br>&gt; <br>&gt; I suggest a much better solution to optional protocol requirements in Swift is the creation of wrappers for UIKit components. These would implement the protocol requirements, and expose optional closure properties for their their public API. Making them properties makes it far clearer that the behaviour of the container will change if a value is provided, and would remove the persistent need to apply @objc to any Swift types dealing with UIKit. I understand this would be a manual task, but I just don&#39;t think there is a good automatic solution to this problem.<br></p><p>There are ~800 optional requirements in the iOS SDK and ~1000 in the OS X SDK. That too large a manual task to accomplish.<br></p><p>Also, I think the arguments in the proposal against the optional-closure-properties approach are fairly strong: it doesn’t seem like a good way to model Objective-C optional requirements.<br></p><p>	- Doug<br></p><p><br>&gt; <br>&gt; ------------ Begin Message ------------ <br>&gt; Group: gmane.comp.lang.swift.evolution <br>&gt; MsgID: &lt;A57B248C-9679-450A-A09D-8C0A5E3846E8 at apple.com&gt; <br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0070: Make Optional Requirements Objective-C only&quot; begins now and runs through May 2. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0070-optional-requirements.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; * What is your evaluation of the proposal?<br>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt; * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; � �<br>&gt; <br>&gt; ------------- End Message ------------- <br>&gt; <br>&gt; <br>&gt; <br>&gt; From James F<br>&gt; <br>&gt; <br>&gt; From James F<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>[Review] SE-0070: Make Optional Requirements Objective-C only</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>April 26, 2016 at 11:00:00am</p></header><div class="content"><p>Fair enough. Upon reflection, I think my real issue is somewhat different to what I suggested previously.<br></p><p>I wasn&#39;t intending to suggest such a thing would be practical, just that it would be a decent alternative to optional protocol requirements. The alternative given in the proposal seems to be more of a way to remove optional protocol requirements on the surface, while actually helping to make them a native feature, if you see what I mean. It&#39;s not a realistic alternative - it&#39;s a worse syntax for the exact same thing, which also comes with awful side-effects for Swift as a whole. No-one would ever seriously consider this as an alternative, yet it&#39;s listed as under the heading ‘Alternatives Considered’.<br></p><p>You say the arguments given against optional closure properties are strong, but I don&#39;t they would be nearly as relevant to the case I suggested. By making them properties of the table view, the tableView parameter would be eliminated, meaning the property names could be unique.<br></p><p>EG:<br>var numberOfRows: (inSection: Int) -&gt; Int<br>var cellForRow:: (at: NSIndexPath) -&gt; UITableViewCell<br>var moveRow: (from: NSIndexPath, to: NSIndexPath)<br></p><p>This removes the need to add the mentioned workarounds, since a function could be assigned to the closure property just as easily as an inline closure. I feel this is much more worthy of being considered as an alternative. The idea of these proposals is to document why we do things, so at least for someone wondering why we require all this @objc syntax rather than support optional protocol requirements natively, this would actually present them with a viable alternative which could be applied in their APIs.<br></p><p>Thanks for the consideration of my previous email. Sorry for being a bit pedantic, but I do feel there&#39;s something off about the proposal as it is written, for it to completely fail to provide any realistic alternative to optional protocol requirements that can be applied by future Swift developers.<br></p><p>From James F<br></p><p>&gt; On 26 Apr 2016, at 04:06, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 25, 2016, at 12:18 PM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Eliminating optional protocol requirements is fine by me. The proposal mentions ‘correcting’ the optional protocol requirement pattern by changing the methods to optional closure properties, but my feeling is that this ‘solution’ just acts to continue and perhaps encourage the anti-pattern established by ObjC. I think a native Swift design would be much better off using optional closure properties on the table view itself.<br>&gt;&gt; <br>&gt;&gt; A common theme in these ObjC optional protocol requirements is the first parameter being an instance whichever class ‘requires’ the method. Yet on the rare occasion of the instance potentially having more than one value, the implementation for each instance is often so different that my first action will be to add a switch between the possible instances (which, of course, means having those components available as IBOutlet properties anyway).<br>&gt;&gt; <br>&gt;&gt; I suggest a much better solution to optional protocol requirements in Swift is the creation of wrappers for UIKit components. These would implement the protocol requirements, and expose optional closure properties for their their public API. Making them properties makes it far clearer that the behaviour of the container will change if a value is provided, and would remove the persistent need to apply @objc to any Swift types dealing with UIKit. I understand this would be a manual task, but I just don&#39;t think there is a good automatic solution to this problem.<br>&gt; <br>&gt; There are ~800 optional requirements in the iOS SDK and ~1000 in the OS X SDK. That too large a manual task to accomplish.<br>&gt; <br>&gt; Also, I think the arguments in the proposal against the optional-closure-properties approach are fairly strong: it doesn’t seem like a good way to model Objective-C optional requirements.<br>&gt; <br>&gt;    - Doug<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; ------------ Begin Message ------------ <br>&gt;&gt; Group: gmane.comp.lang.swift.evolution <br>&gt;&gt; MsgID: &lt;A57B248C-9679-450A-A09D-8C0A5E3846E8 at apple.com&gt; <br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0070: Make Optional Requirements Objective-C only&quot; begins now and runs through May 2. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0070-optional-requirements.md<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; � �<br>&gt;&gt; <br>&gt;&gt; ------------- End Message ------------- <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; From James F<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; From James F<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0070: Make Optional Requirements Objective-C only</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 26, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 26, 2016, at 3:33 AM, James Froggatt &lt;conductator at ntlworld.com&gt; wrote:<br>&gt; <br>&gt; Fair enough. Upon reflection, I think my real issue is somewhat different to what I suggested previously.<br>&gt; <br>&gt; I wasn&#39;t intending to suggest such a thing would be practical, just that it would be a decent alternative to optional protocol requirements. The alternative given in the proposal seems to be more of a way to remove optional protocol requirements on the surface, while actually helping to make them a native feature, if you see what I mean. It&#39;s not a realistic alternative - it&#39;s a worse syntax for the exact same thing, which also comes with awful side-effects for Swift as a whole. No-one would ever seriously consider this as an alternative, yet it&#39;s listed as under the heading ‘Alternatives Considered’.<br></p><p>If you follow the swift-evolution discussion links in the proposal, you’ll note that a number of people have proposed exactly what is listed in “Alternatives Considered”. The only truly wacky idea in there is my caller-side default implementations idea, which I covered simply because it was my last stab at eliminating optional requirements before giving up and sequestering them permanently behind “@objc”.<br></p><p>&gt; <br>&gt; You say the arguments given against optional closure properties are strong, but I don&#39;t they would be nearly as relevant to the case I suggested. By making them properties of the table view, the tableView parameter would be eliminated, meaning the property names could be unique.<br>&gt; <br>&gt; EG:<br>&gt; var numberOfRows: (inSection: Int) -&gt; Int<br>&gt; var cellForRow:: (at: NSIndexPath) -&gt; UITableViewCell<br>&gt; var moveRow: (from: NSIndexPath, to: NSIndexPath)<br>&gt; <br>&gt; This removes the need to add the mentioned workarounds, since a function could be assigned to the closure property just as easily as an inline closure. I feel this is much more worthy of being considered as an alternative. The idea of these proposals is to document why we do things, so at least for someone wondering why we require all this @objc syntax rather than support optional protocol requirements natively, this would actually present them with a viable alternative which could be applied in their APIs.<br></p><p>Doing this implies creating a potentially large number of stored closure properties, which is not as storage-efficient as storing a single delegate reference. Moreover, it makes it harder to set up your customization points: instead of implementing one protocol, you’re writing assignments into some number of stored closure properties. Imaging trying to change the delegate to some other delegate temporarily: you would have to manually store each of the closures into some local structure and introduce your own, except that you can’t get them all because some new version of the platform would add new stored closure properties. Finally, Cocoa just doesn’t work like this, so you would require some massive re-architecture to get there. I don’t see how this is a better design.<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>[Review] SE-0070: Make Optional Requirements Objective-C only</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>April 27, 2016 at 01:00:00pm</p></header><div class="content"><p>Thanks again.<br></p><p>I had a look at the links in the proposal as you suggested, and I see a lot of people pointing to protocol extensions as a solution (and counter-arguments of the inability to optimise code with this method, which are left unresolved).<br></p><p>To make use of the protocol extensions solution, one would have to define the protocol, add a protocol extension which implements every function, then add an empty type which allows access to these implementations.<br>For a recommended alternative, this seems a lot of work. In a world where Swift didn&#39;t have Objective C compatibility, and this empty-type workaround to access defaults was the best option available, I&#39;d be inclined to support a proposal to add optional method requirements. It has the added optimisation and easy delegate-swapping relative to closure properties, as you mentioned, and feels less hacky than the closure-function switching suggested in the proposal.<br></p><p>The protocol extension + default type would provide a direct alternative, but it leads me to wonder what exactly we&#39;re trying to avoid by discouraging optional methods. The potential for unexpected optimisation, which seems to be the primary issue, is unsolved, since the type can check to see if the delegate is its own, default type, and proceed to ignore the method regardless. In exchange, we make things much harder for types simply wishing to have a default value when there is no registered delegate.<br></p><p>So what aspect of optional protocol requirements are we actually trying to discourage, which isn&#39;t present in protocol extensions?<br></p><p>PS. If we&#39;re concerned about overlap with protocol extensions: it seems a bit like eliminating functions from the language because they overlap with the more general concept of closures. It&#39;s a fine idea, but it seems more reasonable to find a solution that handles both cases conveniently before we start eliminating one of them.<br></p><p>From James F<br></p><p>&gt; On 26 Apr 2016, at 22:56, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 26, 2016, at 3:33 AM, James Froggatt &lt;conductator at ntlworld.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Fair enough. Upon reflection, I think my real issue is somewhat different to what I suggested previously.<br>&gt;&gt; <br>&gt;&gt; I wasn&#39;t intending to suggest such a thing would be practical, just that it would be a decent alternative to optional protocol requirements. The alternative given in the proposal seems to be more of a way to remove optional protocol requirements on the surface, while actually helping to make them a native feature, if you see what I mean. It&#39;s not a realistic alternative - it&#39;s a worse syntax for the exact same thing, which also comes with awful side-effects for Swift as a whole. No-one would ever seriously consider this as an alternative, yet it&#39;s listed as under the heading ‘Alternatives Considered’.<br>&gt; <br>&gt; If you follow the swift-evolution discussion links in the proposal, you’ll note that a number of people have proposed exactly what is listed in “Alternatives Considered”. The only truly wacky idea in there is my caller-side default implementations idea, which I covered simply because it was my last stab at eliminating optional requirements before giving up and sequestering them permanently behind “@objc”.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; You say the arguments given against optional closure properties are strong, but I don&#39;t they would be nearly as relevant to the case I suggested. By making them properties of the table view, the tableView parameter would be eliminated, meaning the property names could be unique.<br>&gt;&gt; <br>&gt;&gt; EG:<br>&gt;&gt; var numberOfRows: (inSection: Int) -&gt; Int<br>&gt;&gt; var cellForRow:: (at: NSIndexPath) -&gt; UITableViewCell<br>&gt;&gt; var moveRow: (from: NSIndexPath, to: NSIndexPath)<br>&gt;&gt; <br>&gt;&gt; This removes the need to add the mentioned workarounds, since a function could be assigned to the closure property just as easily as an inline closure. I feel this is much more worthy of being considered as an alternative. The idea of these proposals is to document why we do things, so at least for someone wondering why we require all this @objc syntax rather than support optional protocol requirements natively, this would actually present them with a viable alternative which could be applied in their APIs.<br>&gt; <br>&gt; Doing this implies creating a potentially large number of stored closure properties, which is not as storage-efficient as storing a single delegate reference. Moreover, it makes it harder to set up your customization points: instead of implementing one protocol, you’re writing assignments into some number of stored closure properties. Imaging trying to change the delegate to some other delegate temporarily: you would have to manually store each of the closures into some local structure and introduce your own, except that you can’t get them all because some new version of the platform would add new stored closure properties. Finally, Cocoa just doesn’t work like this, so you would require some massive re-architecture to get there. I don’t see how this is a better design.<br>&gt; <br>&gt;   - Doug<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Review] SE-0070: Make Optional Requirements Objective-C only</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April 28, 2016 at 12:00:00am</p></header><div class="content"><p>Sorry if this has been discussed, but have you considered dropping optional<br>entirely, making it throw, and a default implementation that throws a<br>selector not found exception?<br></p><p>This is approximately what you would expect using it in objc. I don&#39;t think<br>it has the complexity discussed in the proposals alternatives for other<br>call site issues.<br></p><p>If it throws you can call with &quot;try?&quot; to get similar functionality in most<br>cases.<br></p><p>This assumes that respondsToSelector doesn&#39;t pick up the Swift default<br>implementation.<br></p><p>On Wednesday, 27 April 2016, James Froggatt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Thanks again.<br>&gt;<br>&gt; I had a look at the links in the proposal as you suggested, and I see a<br>&gt; lot of people pointing to protocol extensions as a solution (and<br>&gt; counter-arguments of the inability to optimise code with this method, which<br>&gt; are left unresolved).<br>&gt;<br>&gt; To make use of the protocol extensions solution, one would have to define<br>&gt; the protocol, add a protocol extension which implements every function,<br>&gt; then add an empty type which allows access to these implementations.<br>&gt; For a recommended alternative, this seems a lot of work. In a world where<br>&gt; Swift didn&#39;t have Objective C compatibility, and this empty-type workaround<br>&gt; to access defaults was the best option available, I&#39;d be inclined to<br>&gt; support a proposal to add optional method requirements. It has the added<br>&gt; optimisation and easy delegate-swapping relative to closure properties, as<br>&gt; you mentioned, and feels less hacky than the closure-function switching<br>&gt; suggested in the proposal.<br>&gt;<br>&gt; The protocol extension + default type would provide a direct alternative,<br>&gt; but it leads me to wonder what exactly we&#39;re trying to avoid by<br>&gt; discouraging optional methods. The potential for unexpected optimisation,<br>&gt; which seems to be the primary issue, is unsolved, since the type can check<br>&gt; to see if the delegate is its own, default type, and proceed to ignore the<br>&gt; method regardless. In exchange, we make things much harder for types simply<br>&gt; wishing to have a default value when there is no registered delegate.<br>&gt;<br>&gt; So what aspect of optional protocol requirements are we actually trying to<br>&gt; discourage, which isn&#39;t present in protocol extensions?<br>&gt;<br>&gt; PS. If we&#39;re concerned about overlap with protocol extensions: it seems a<br>&gt; bit like eliminating functions from the language because they overlap with<br>&gt; the more general concept of closures. It&#39;s a fine idea, but it seems more<br>&gt; reasonable to find a solution that handles both cases conveniently before<br>&gt; we start eliminating one of them.<br>&gt;<br>&gt; From James F<br>&gt;<br>&gt; &gt; On 26 Apr 2016, at 22:56, Douglas Gregor &lt;dgregor at apple.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Apr 26, 2016, at 3:33 AM, James Froggatt &lt;conductator at ntlworld.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Fair enough. Upon reflection, I think my real issue is somewhat<br>&gt; different to what I suggested previously.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I wasn&#39;t intending to suggest such a thing would be practical, just<br>&gt; that it would be a decent alternative to optional protocol requirements.<br>&gt; The alternative given in the proposal seems to be more of a way to remove<br>&gt; optional protocol requirements on the surface, while actually helping to<br>&gt; make them a native feature, if you see what I mean. It&#39;s not a realistic<br>&gt; alternative - it&#39;s a worse syntax for the exact same thing, which also<br>&gt; comes with awful side-effects for Swift as a whole. No-one would ever<br>&gt; seriously consider this as an alternative, yet it&#39;s listed as under the<br>&gt; heading ‘Alternatives Considered’.<br>&gt; &gt;<br>&gt; &gt; If you follow the swift-evolution discussion links in the proposal,<br>&gt; you’ll note that a number of people have proposed exactly what is listed in<br>&gt; “Alternatives Considered”. The only truly wacky idea in there is my<br>&gt; caller-side default implementations idea, which I covered simply because it<br>&gt; was my last stab at eliminating optional requirements before giving up and<br>&gt; sequestering them permanently behind “@objc”.<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; You say the arguments given against optional closure properties are<br>&gt; strong, but I don&#39;t they would be nearly as relevant to the case I<br>&gt; suggested. By making them properties of the table view, the tableView<br>&gt; parameter would be eliminated, meaning the property names could be unique.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; EG:<br>&gt; &gt;&gt; var numberOfRows: (inSection: Int) -&gt; Int<br>&gt; &gt;&gt; var cellForRow:: (at: NSIndexPath) -&gt; UITableViewCell<br>&gt; &gt;&gt; var moveRow: (from: NSIndexPath, to: NSIndexPath)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This removes the need to add the mentioned workarounds, since a<br>&gt; function could be assigned to the closure property just as easily as an<br>&gt; inline closure. I feel this is much more worthy of being considered as an<br>&gt; alternative. The idea of these proposals is to document why we do things,<br>&gt; so at least for someone wondering why we require all this @objc syntax<br>&gt; rather than support optional protocol requirements natively, this would<br>&gt; actually present them with a viable alternative which could be applied in<br>&gt; their APIs.<br>&gt; &gt;<br>&gt; &gt; Doing this implies creating a potentially large number of stored closure<br>&gt; properties, which is not as storage-efficient as storing a single delegate<br>&gt; reference. Moreover, it makes it harder to set up your customization<br>&gt; points: instead of implementing one protocol, you’re writing assignments<br>&gt; into some number of stored closure properties. Imaging trying to change the<br>&gt; delegate to some other delegate temporarily: you would have to manually<br>&gt; store each of the closures into some local structure and introduce your<br>&gt; own, except that you can’t get them all because some new version of the<br>&gt; platform would add new stored closure properties. Finally, Cocoa just<br>&gt; doesn’t work like this, so you would require some massive re-architecture<br>&gt; to get there. I don’t see how this is a better design.<br>&gt; &gt;<br>&gt; &gt;   - Doug<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/0816d259/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>[Review] SE-0070: Make Optional Requirements Objective-C only</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>April 27, 2016 at 04:00:00pm</p></header><div class="content"><p>Interesting idea. I tried this in a playground to see what the calling syntax would be like:<br></p><p>let delegate = Optional(Delegate())<br>let default = 0<br>let value: Int = (try? delegate?.returnFive() ?? default) ?? default<br>value<br></p><p>Not quite as elegant at the call site, but it works. Sadly the rethrowing overload of ?? complicates things, I&#39;m not sure of a way to work around that directly.<br></p><p>I do like that types could potentially implement the function and do something, then throw an error rather than returning a value, which would allow them opt into using the default value. It would complicate matters if the conforming types throw multiple errors for whatever reason, though.<br></p><p>From James F<br></p><p>&gt; On 27 Apr 2016, at 15:30, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Sorry if this has been discussed, but have you considered dropping optional entirely, making it throw, and a default implementation that throws a selector not found exception?<br>&gt; <br>&gt; This is approximately what you would expect using it in objc. I don&#39;t think it has the complexity discussed in the proposals alternatives for other call site issues.<br>&gt; <br>&gt; If it throws you can call with &quot;try?&quot; to get similar functionality in most cases.<br>&gt; <br>&gt; This assumes that respondsToSelector doesn&#39;t pick up the Swift default implementation.<br>&gt; <br>&gt;&gt; On Wednesday, 27 April 2016, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Thanks again.<br>&gt;&gt; <br>&gt;&gt; I had a look at the links in the proposal as you suggested, and I see a lot of people pointing to protocol extensions as a solution (and counter-arguments of the inability to optimise code with this method, which are left unresolved).<br>&gt;&gt; <br>&gt;&gt; To make use of the protocol extensions solution, one would have to define the protocol, add a protocol extension which implements every function, then add an empty type which allows access to these implementations.<br>&gt;&gt; For a recommended alternative, this seems a lot of work. In a world where Swift didn&#39;t have Objective C compatibility, and this empty-type workaround to access defaults was the best option available, I&#39;d be inclined to support a proposal to add optional method requirements. It has the added optimisation and easy delegate-swapping relative to closure properties, as you mentioned, and feels less hacky than the closure-function switching suggested in the proposal.<br>&gt;&gt; <br>&gt;&gt; The protocol extension + default type would provide a direct alternative, but it leads me to wonder what exactly we&#39;re trying to avoid by discouraging optional methods. The potential for unexpected optimisation, which seems to be the primary issue, is unsolved, since the type can check to see if the delegate is its own, default type, and proceed to ignore the method regardless. In exchange, we make things much harder for types simply wishing to have a default value when there is no registered delegate.<br>&gt;&gt; <br>&gt;&gt; So what aspect of optional protocol requirements are we actually trying to discourage, which isn&#39;t present in protocol extensions?<br>&gt;&gt; <br>&gt;&gt; PS. If we&#39;re concerned about overlap with protocol extensions: it seems a bit like eliminating functions from the language because they overlap with the more general concept of closures. It&#39;s a fine idea, but it seems more reasonable to find a solution that handles both cases conveniently before we start eliminating one of them.<br>&gt;&gt; <br>&gt;&gt; From James F<br>&gt;&gt; <br>&gt;&gt; &gt; On 26 Apr 2016, at 22:56, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Apr 26, 2016, at 3:33 AM, James Froggatt &lt;conductator at ntlworld.com&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Fair enough. Upon reflection, I think my real issue is somewhat different to what I suggested previously.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I wasn&#39;t intending to suggest such a thing would be practical, just that it would be a decent alternative to optional protocol requirements. The alternative given in the proposal seems to be more of a way to remove optional protocol requirements on the surface, while actually helping to make them a native feature, if you see what I mean. It&#39;s not a realistic alternative - it&#39;s a worse syntax for the exact same thing, which also comes with awful side-effects for Swift as a whole. No-one would ever seriously consider this as an alternative, yet it&#39;s listed as under the heading ‘Alternatives Considered’.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; If you follow the swift-evolution discussion links in the proposal, you’ll note that a number of people have proposed exactly what is listed in “Alternatives Considered”. The only truly wacky idea in there is my caller-side default implementations idea, which I covered simply because it was my last stab at eliminating optional requirements before giving up and sequestering them permanently behind “@objc”.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; You say the arguments given against optional closure properties are strong, but I don&#39;t they would be nearly as relevant to the case I suggested. By making them properties of the table view, the tableView parameter would be eliminated, meaning the property names could be unique.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; EG:<br>&gt;&gt; &gt;&gt; var numberOfRows: (inSection: Int) -&gt; Int<br>&gt;&gt; &gt;&gt; var cellForRow:: (at: NSIndexPath) -&gt; UITableViewCell<br>&gt;&gt; &gt;&gt; var moveRow: (from: NSIndexPath, to: NSIndexPath)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; This removes the need to add the mentioned workarounds, since a function could be assigned to the closure property just as easily as an inline closure. I feel this is much more worthy of being considered as an alternative. The idea of these proposals is to document why we do things, so at least for someone wondering why we require all this @objc syntax rather than support optional protocol requirements natively, this would actually present them with a viable alternative which could be applied in their APIs.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Doing this implies creating a potentially large number of stored closure properties, which is not as storage-efficient as storing a single delegate reference. Moreover, it makes it harder to set up your customization points: instead of implementing one protocol, you’re writing assignments into some number of stored closure properties. Imaging trying to change the delegate to some other delegate temporarily: you would have to manually store each of the closures into some local structure and introduce your own, except that you can’t get them all because some new version of the platform would add new stored closure properties. Finally, Cocoa just doesn’t work like this, so you would require some massive re-architecture to get there. I don’t see how this is a better design.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   - Doug<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/a3f0b0cd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Review] SE-0070: Make Optional Requirements Objective-C only</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April 28, 2016 at 08:00:00am</p></header><div class="content"><p>Hi James,<br></p><p>I don&#39;t think it would complicate it any more than a throw normal is. You<br>can still use a do/catch, with types catches.<br></p><p>On Thursday, 28 April 2016, James Froggatt &lt;conductator at ntlworld.com&gt; wrote:<br></p><p>&gt; Interesting idea. I tried this in a playground to see what the calling<br>&gt; syntax would be like:<br>&gt;<br>&gt; let delegate = Optional(Delegate())<br>&gt; let default = 0<br>&gt; let value: Int = (try? delegate?.returnFive() ?? default) ?? default<br>&gt; value<br>&gt;<br>&gt; Not quite as elegant at the call site, but it works. Sadly the rethrowing<br>&gt; overload of ?? complicates things, I&#39;m not sure of a way to work around<br>&gt; that directly.<br>&gt;<br>&gt; I do like that types could potentially implement the function and do<br>&gt; something, then throw an error rather than returning a value, which would<br>&gt; allow them opt into using the default value. It would complicate matters if<br>&gt; the conforming types throw multiple errors for whatever reason, though.<br>&gt;<br>&gt; From James F<br>&gt;<br>&gt; On 27 Apr 2016, at 15:30, Andrew Bennett &lt;cacoyi at gmail.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;cacoyi at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Sorry if this has been discussed, but have you considered dropping<br>&gt; optional entirely, making it throw, and a default implementation that<br>&gt; throws a selector not found exception?<br>&gt;<br>&gt; This is approximately what you would expect using it in objc. I don&#39;t<br>&gt; think it has the complexity discussed in the proposals alternatives for<br>&gt; other call site issues.<br>&gt;<br>&gt; If it throws you can call with &quot;try?&quot; to get similar functionality in most<br>&gt; cases.<br>&gt;<br>&gt; This assumes that respondsToSelector doesn&#39;t pick up the Swift default<br>&gt; implementation.<br>&gt;<br>&gt; On Wednesday, 27 April 2016, James Froggatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; Thanks again.<br>&gt;&gt;<br>&gt;&gt; I had a look at the links in the proposal as you suggested, and I see a<br>&gt;&gt; lot of people pointing to protocol extensions as a solution (and<br>&gt;&gt; counter-arguments of the inability to optimise code with this method, which<br>&gt;&gt; are left unresolved).<br>&gt;&gt;<br>&gt;&gt; To make use of the protocol extensions solution, one would have to define<br>&gt;&gt; the protocol, add a protocol extension which implements every function,<br>&gt;&gt; then add an empty type which allows access to these implementations.<br>&gt;&gt; For a recommended alternative, this seems a lot of work. In a world where<br>&gt;&gt; Swift didn&#39;t have Objective C compatibility, and this empty-type workaround<br>&gt;&gt; to access defaults was the best option available, I&#39;d be inclined to<br>&gt;&gt; support a proposal to add optional method requirements. It has the added<br>&gt;&gt; optimisation and easy delegate-swapping relative to closure properties, as<br>&gt;&gt; you mentioned, and feels less hacky than the closure-function switching<br>&gt;&gt; suggested in the proposal.<br>&gt;&gt;<br>&gt;&gt; The protocol extension + default type would provide a direct alternative,<br>&gt;&gt; but it leads me to wonder what exactly we&#39;re trying to avoid by<br>&gt;&gt; discouraging optional methods. The potential for unexpected optimisation,<br>&gt;&gt; which seems to be the primary issue, is unsolved, since the type can check<br>&gt;&gt; to see if the delegate is its own, default type, and proceed to ignore the<br>&gt;&gt; method regardless. In exchange, we make things much harder for types simply<br>&gt;&gt; wishing to have a default value when there is no registered delegate.<br>&gt;&gt;<br>&gt;&gt; So what aspect of optional protocol requirements are we actually trying<br>&gt;&gt; to discourage, which isn&#39;t present in protocol extensions?<br>&gt;&gt;<br>&gt;&gt; PS. If we&#39;re concerned about overlap with protocol extensions: it seems a<br>&gt;&gt; bit like eliminating functions from the language because they overlap with<br>&gt;&gt; the more general concept of closures. It&#39;s a fine idea, but it seems more<br>&gt;&gt; reasonable to find a solution that handles both cases conveniently before<br>&gt;&gt; we start eliminating one of them.<br>&gt;&gt;<br>&gt;&gt; From James F<br>&gt;&gt;<br>&gt;&gt; &gt; On 26 Apr 2016, at 22:56, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Apr 26, 2016, at 3:33 AM, James Froggatt &lt;conductator at ntlworld.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Fair enough. Upon reflection, I think my real issue is somewhat<br>&gt;&gt; different to what I suggested previously.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I wasn&#39;t intending to suggest such a thing would be practical, just<br>&gt;&gt; that it would be a decent alternative to optional protocol requirements.<br>&gt;&gt; The alternative given in the proposal seems to be more of a way to remove<br>&gt;&gt; optional protocol requirements on the surface, while actually helping to<br>&gt;&gt; make them a native feature, if you see what I mean. It&#39;s not a realistic<br>&gt;&gt; alternative - it&#39;s a worse syntax for the exact same thing, which also<br>&gt;&gt; comes with awful side-effects for Swift as a whole. No-one would ever<br>&gt;&gt; seriously consider this as an alternative, yet it&#39;s listed as under the<br>&gt;&gt; heading ‘Alternatives Considered’.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; If you follow the swift-evolution discussion links in the proposal,<br>&gt;&gt; you’ll note that a number of people have proposed exactly what is listed in<br>&gt;&gt; “Alternatives Considered”. The only truly wacky idea in there is my<br>&gt;&gt; caller-side default implementations idea, which I covered simply because it<br>&gt;&gt; was my last stab at eliminating optional requirements before giving up and<br>&gt;&gt; sequestering them permanently behind “@objc”.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; You say the arguments given against optional closure properties are<br>&gt;&gt; strong, but I don&#39;t they would be nearly as relevant to the case I<br>&gt;&gt; suggested. By making them properties of the table view, the tableView<br>&gt;&gt; parameter would be eliminated, meaning the property names could be unique.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; EG:<br>&gt;&gt; &gt;&gt; var numberOfRows: (inSection: Int) -&gt; Int<br>&gt;&gt; &gt;&gt; var cellForRow:: (at: NSIndexPath) -&gt; UITableViewCell<br>&gt;&gt; &gt;&gt; var moveRow: (from: NSIndexPath, to: NSIndexPath)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; This removes the need to add the mentioned workarounds, since a<br>&gt;&gt; function could be assigned to the closure property just as easily as an<br>&gt;&gt; inline closure. I feel this is much more worthy of being considered as an<br>&gt;&gt; alternative. The idea of these proposals is to document why we do things,<br>&gt;&gt; so at least for someone wondering why we require all this @objc syntax<br>&gt;&gt; rather than support optional protocol requirements natively, this would<br>&gt;&gt; actually present them with a viable alternative which could be applied in<br>&gt;&gt; their APIs.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Doing this implies creating a potentially large number of stored<br>&gt;&gt; closure properties, which is not as storage-efficient as storing a single<br>&gt;&gt; delegate reference. Moreover, it makes it harder to set up your<br>&gt;&gt; customization points: instead of implementing one protocol, you’re writing<br>&gt;&gt; assignments into some number of stored closure properties. Imaging trying<br>&gt;&gt; to change the delegate to some other delegate temporarily: you would have<br>&gt;&gt; to manually store each of the closures into some local structure and<br>&gt;&gt; introduce your own, except that you can’t get them all because some new<br>&gt;&gt; version of the platform would add new stored closure properties. Finally,<br>&gt;&gt; Cocoa just doesn’t work like this, so you would require some massive<br>&gt;&gt; re-architecture to get there. I don’t see how this is a better design.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   - Doug<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/a790b13b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Review] SE-0070: Make Optional Requirements Objective-C only</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>April 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 27, 2016, at 9:30 AM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry if this has been discussed, but have you considered dropping optional entirely, making it throw, and a default implementation that throws a selector not found exception?<br>&gt; <br>&gt; This is approximately what you would expect using it in objc. I don&#39;t think it has the complexity discussed in the proposals alternatives for other call site issues.<br>&gt; <br>&gt; If it throws you can call with &quot;try?&quot; to get similar functionality in most cases.<br>&gt; <br>&gt; This assumes that respondsToSelector doesn&#39;t pick up the Swift default implementation.<br></p><p>Is there any case where you’d actually want to display a runtime error as a result of a delegate not implementing an optional method, though? Even setting aside that the method’s supposed to be optional, leaving out a needed delegate method seems more like a programmer error than a runtime error.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/13040a75/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Review] SE-0070: Make Optional Requirements Objective-C only</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April 28, 2016 at 08:00:00am</p></header><div class="content"><p>Hi Charles,<br></p><p>My initial idea just had a fatalError, without a throw. It&#39;s better IMO,<br>but less Swift-y. It&#39;s not obvious from the Swift protocol definition that<br>this could happen. I&#39;m not sure if it&#39;s possible for the extension method<br>to have @noreturn or similar on it.<br></p><p>On Thursday, 28 April 2016, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br></p><p>&gt; On Apr 27, 2016, at 9:30 AM, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Sorry if this has been discussed, but have you considered dropping<br>&gt; optional entirely, making it throw, and a default implementation that<br>&gt; throws a selector not found exception?<br>&gt;<br>&gt; This is approximately what you would expect using it in objc. I don&#39;t<br>&gt; think it has the complexity discussed in the proposals alternatives for<br>&gt; other call site issues.<br>&gt;<br>&gt; If it throws you can call with &quot;try?&quot; to get similar functionality in most<br>&gt; cases.<br>&gt;<br>&gt; This assumes that respondsToSelector doesn&#39;t pick up the Swift default<br>&gt; implementation.<br>&gt;<br>&gt;<br>&gt; Is there any case where you’d actually want to display a runtime error as<br>&gt; a result of a delegate not implementing an optional method, though? Even<br>&gt; setting aside that the method’s supposed to be optional, leaving out a<br>&gt; needed delegate method seems more like a programmer error than a runtime<br>&gt; error.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/b356bbe7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Review] SE-0070: Make Optional Requirements Objective-C only</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>April 27, 2016 at 06:00:00pm</p></header><div class="content"><p>Why would you want lack of an optional method to be a fatal error, either?<br></p><p>Charles<br></p><p>&gt; On Apr 27, 2016, at 5:29 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi Charles,<br>&gt; <br>&gt; My initial idea just had a fatalError, without a throw. It&#39;s better IMO, but less Swift-y. It&#39;s not obvious from the Swift protocol definition that this could happen. I&#39;m not sure if it&#39;s possible for the extension method to have @noreturn or similar on it.<br>&gt; <br>&gt; On Thursday, 28 April 2016, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; On Apr 27, 2016, at 9:30 AM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry if this has been discussed, but have you considered dropping optional entirely, making it throw, and a default implementation that throws a selector not found exception?<br>&gt;&gt; <br>&gt;&gt; This is approximately what you would expect using it in objc. I don&#39;t think it has the complexity discussed in the proposals alternatives for other call site issues.<br>&gt;&gt; <br>&gt;&gt; If it throws you can call with &quot;try?&quot; to get similar functionality in most cases.<br>&gt;&gt; <br>&gt;&gt; This assumes that respondsToSelector doesn&#39;t pick up the Swift default implementation.<br>&gt; <br>&gt; Is there any case where you’d actually want to display a runtime error as a result of a delegate not implementing an optional method, though? Even setting aside that the method’s supposed to be optional, leaving out a needed delegate method seems more like a programmer error than a runtime error.<br>&gt; <br>&gt; Charles<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/a7feaf3b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
