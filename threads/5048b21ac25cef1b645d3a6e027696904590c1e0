<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 24, 2016 at 12:00:00pm</p></header><div class="content"><p>on Sat Jan 23 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Dave,<br>&gt;<br>&gt; I typoed on the second and I was insufficiently clear on my point. Trying again:<br>&gt;<br>&gt; Prefer external names for the first parameter when the natural<br>&gt; semantic relationship between the parameters is stronger than their<br>&gt; relation to the operation. <br>&gt;<br>&gt; For example, the following calls use labels for the first parameter:<br>&gt;<br>&gt; login(userName: &quot;blah&quot;, password: &quot;...&quot;)<br>&gt; moveTo(x: 50.0, y: 30.0)<br>&gt;<br>&gt; This example is contrary to Swift&#39;s normal naming scheme which integrates the<br>&gt; first argument into the function or method name, for example:<br>&gt;<br>&gt; loginWithUserName(&quot;blah&quot;, password: &quot;...&quot;)<br>&gt; moveToX(50.0, y: 30.0)<br>&gt;<br>&gt; The coupling between x and y, username and password, (and yes it is a judgement call) <br>&gt; should be considered as a reason to employ an external label.<br></p><p>Yeah, I understand what you&#39;re going for, but it doesn&#39;t seem very crisp<br>to me.  Personally, I think Rob Mayoff&#39;s suggestion<br></p><p>  loginAs(me, password: mySecret)<br></p><p>is pretty awesome.  Fundamentally, the username is driving the call, and<br>the password is a piece of dependent information you have to match up to<br>it.<br></p><p>&gt; I had included the following as a counter example:<br>&gt;<br>&gt; addLineToPoint(p1, withWidth: 25.0)<br>&gt;<br>&gt; In this call, the point and width have no natural or compelling relationship and there&#39;s no reason to<br>&gt; create an external label for the first argument. This example follows the standard<br>&gt; Swift call approach.<br></p><p>Up to now, there has been no &quot;standard Swift call approach,&quot; so I don&#39;t<br>know what this means.<br></p><p>&gt; Differentiate related calls whose implementations are distinguished by their<br>&gt; parameters, as you would with initializers, using first parameter labels.<br>&gt;<br>&gt; Instead of loginWithUserName(&quot;blah&quot;, password: &quot;...&quot;) and loginWithCredential(myCredential),<br>&gt; prefer:<br>&gt;<br>&gt; login(userName: &quot;blah&quot;, password: &quot;...&quot;)<br>&gt; login(credential: myCredential)<br></p><p>So, how does this proposal improve understandability of use-sites?<br></p><p>&gt; And to reply to another point raised in-thread:<br>&gt;<br>&gt; When working with standard library calls, retain APIs even if they are<br>&gt; not sufficiently clear from a Swift design perspective rather than<br>&gt; wrapping-the-cat to provide a Swift interface that doesn&#39;t really<br>&gt; exist. (As the call is just a redirection.)<br>&gt;<br>&gt; For example, prefer<br>&gt;<br>&gt; let x = pow(2.0, 5.0)<br>&gt;<br>&gt; to<br>&gt;<br>&gt; let x = raise(2.0, toPower: 5.0)<br>&gt;<br>&gt; In this example, the two arguments for pow are not specified as this call is sourced<br>&gt; externally and follows the naming convention for math.h.<br></p><p>This idea is already captured in the guidelines; the reasons to use<br>&quot;pow(x, y)&quot; are the same as the reasons to use &quot;sin(x)&quot;.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>January 24, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 24, 2016, at 12:43 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat Jan 23 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Dave,<br>&gt;&gt; <br>&gt;&gt; I typoed on the second and I was insufficiently clear on my point. Trying again:<br>&gt;&gt; <br>&gt;&gt; Prefer external names for the first parameter when the natural<br>&gt;&gt; semantic relationship between the parameters is stronger than their<br>&gt;&gt; relation to the operation. <br>&gt;&gt; <br>&gt;&gt; For example, the following calls use labels for the first parameter:<br>&gt;&gt; <br>&gt;&gt; login(userName: &quot;blah&quot;, password: &quot;...&quot;)<br>&gt;&gt; moveTo(x: 50.0, y: 30.0)<br>&gt;&gt; <br>&gt;&gt; This example is contrary to Swift&#39;s normal naming scheme which integrates the<br>&gt;&gt; first argument into the function or method name, for example:<br>&gt;&gt; <br>&gt;&gt; loginWithUserName(&quot;blah&quot;, password: &quot;...&quot;)<br>&gt;&gt; moveToX(50.0, y: 30.0)<br>&gt;&gt; <br>&gt;&gt; The coupling between x and y, username and password, (and yes it is a judgement call) <br>&gt;&gt; should be considered as a reason to employ an external label.<br>&gt; <br>&gt; Yeah, I understand what you&#39;re going for, but it doesn&#39;t seem very crisp<br>&gt; to me.  Personally, I think Rob Mayoff&#39;s suggestion<br>&gt; <br>&gt;  loginAs(me, password: mySecret)<br>&gt; <br>&gt; is pretty awesome.  Fundamentally, the username is driving the call, and<br>&gt; the password is a piece of dependent information you have to match up to<br>&gt; it.<br>&gt; <br>&gt;&gt; I had included the following as a counter example:<br>&gt;&gt; <br>&gt;&gt; addLineToPoint(p1, withWidth: 25.0)<br>&gt;&gt; <br>&gt;&gt; In this call, the point and width have no natural or compelling relationship and there&#39;s no reason to<br>&gt;&gt; create an external label for the first argument. This example follows the standard<br>&gt;&gt; Swift call approach.<br>&gt; <br>&gt; Up to now, there has been no &quot;standard Swift call approach,&quot; so I don&#39;t<br>&gt; know what this means.<br>&gt; <br>&gt;&gt; Differentiate related calls whose implementations are distinguished by their<br>&gt;&gt; parameters, as you would with initializers, using first parameter labels.<br>&gt;&gt; <br>&gt;&gt; Instead of loginWithUserName(&quot;blah&quot;, password: &quot;...&quot;) and loginWithCredential(myCredential),<br>&gt;&gt; prefer:<br>&gt;&gt; <br>&gt;&gt; login(userName: &quot;blah&quot;, password: &quot;...&quot;)<br>&gt;&gt; login(credential: myCredential)<br>&gt; <br>&gt; So, how does this proposal improve understandability of use-sites?<br>&gt; <br>&gt;&gt; And to reply to another point raised in-thread:<br>&gt;&gt; <br>&gt;&gt; When working with standard library calls, retain APIs even if they are<br>&gt;&gt; not sufficiently clear from a Swift design perspective rather than<br>&gt;&gt; wrapping-the-cat to provide a Swift interface that doesn&#39;t really<br>&gt;&gt; exist. (As the call is just a redirection.)<br>&gt;&gt; <br>&gt;&gt; For example, prefer<br>&gt;&gt; <br>&gt;&gt; let x = pow(2.0, 5.0)<br>&gt;&gt; <br>&gt;&gt; to<br>&gt;&gt; <br>&gt;&gt; let x = raise(2.0, toPower: 5.0)<br>&gt;&gt; <br>&gt;&gt; In this example, the two arguments for pow are not specified as this call is sourced<br>&gt;&gt; externally and follows the naming convention for math.h.<br>&gt; <br>&gt; This idea is already captured in the guidelines; the reasons to use<br>&gt; &quot;pow(x, y)&quot; are the same as the reasons to use &quot;sin(x)”.<br></p><p>I’m going to actually make the argument here that `pow` would be much clearer as `raise(_:toPower:)`.<br></p><p>The main reason is that if I want to convert this to a method with mutating versions and non-mutating versions, there’s no good translation of pow.<br></p><p>pow(x, y)<br>x.pow(y) -&gt; muating<br>x.powed(y) -&gt; non-mutating<br></p><p>vs<br></p><p>raise(x, to: y)<br>x.raiseTo(y)<br>x.raisedTo(y)<br></p><p>Under the current guidelines, I’m not really sure what to do. There’s also the fact that in my estimation pow(x, y) is not as natural of a function as sin(x) for example. <br></p><p>I really just want to avoid having a global function called `pow` and a method called `raiseTo` and then have a user confused when they can’t find x.pow(y)<br></p><p>I can also see the benefit of just not providing a method version of the function, but then my API is somewhat arbitrarily split between functions that can be both global and methods, those that are just methods, and those that are just global. I would really like the guidelines to provide more information on how to design this split. <br></p><p>Tyler<br></p><p><br>&gt; <br></p><p>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Labels was Re: [swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 24, 2016 at 05:00:00pm</p></header><div class="content"><p>Again, I&#39;ve taken some time and attempted to write this up more coherently:<br></p><p>https://github.com/erica/SwiftStyle/blob/master/ArgumentLabels.md &lt;https://github.com/erica/SwiftStyle/blob/master/ArgumentLabels.md&gt;<br></p><p>I&#39;ve also updated the topic, so I can follow this more easily.<br></p><p>-- Erica<br></p><p><br>&gt; On Jan 24, 2016, at 1:43 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat Jan 23 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Dave,<br>&gt;&gt; <br>&gt;&gt; I typoed on the second and I was insufficiently clear on my point. Trying again:<br>&gt;&gt; <br>&gt;&gt; Prefer external names for the first parameter when the natural<br>&gt;&gt; semantic relationship between the parameters is stronger than their<br>&gt;&gt; relation to the operation. <br>&gt;&gt; <br>&gt;&gt; For example, the following calls use labels for the first parameter:<br>&gt;&gt; <br>&gt;&gt; login(userName: &quot;blah&quot;, password: &quot;...&quot;)<br>&gt;&gt; moveTo(x: 50.0, y: 30.0)<br>&gt;&gt; <br>&gt;&gt; This example is contrary to Swift&#39;s normal naming scheme which integrates the<br>&gt;&gt; first argument into the function or method name, for example:<br>&gt;&gt; <br>&gt;&gt; loginWithUserName(&quot;blah&quot;, password: &quot;...&quot;)<br>&gt;&gt; moveToX(50.0, y: 30.0)<br>&gt;&gt; <br>&gt;&gt; The coupling between x and y, username and password, (and yes it is a judgement call) <br>&gt;&gt; should be considered as a reason to employ an external label.<br>&gt; <br>&gt; Yeah, I understand what you&#39;re going for, but it doesn&#39;t seem very crisp<br>&gt; to me.  Personally, I think Rob Mayoff&#39;s suggestion<br>&gt; <br>&gt;  loginAs(me, password: mySecret)<br>&gt; <br>&gt; is pretty awesome.  Fundamentally, the username is driving the call, and<br>&gt; the password is a piece of dependent information you have to match up to<br>&gt; it.<br>&gt; <br>&gt;&gt; I had included the following as a counter example:<br>&gt;&gt; <br>&gt;&gt; addLineToPoint(p1, withWidth: 25.0)<br>&gt;&gt; <br>&gt;&gt; In this call, the point and width have no natural or compelling relationship and there&#39;s no reason to<br>&gt;&gt; create an external label for the first argument. This example follows the standard<br>&gt;&gt; Swift call approach.<br>&gt; <br>&gt; Up to now, there has been no &quot;standard Swift call approach,&quot; so I don&#39;t<br>&gt; know what this means.<br>&gt; <br>&gt;&gt; Differentiate related calls whose implementations are distinguished by their<br>&gt;&gt; parameters, as you would with initializers, using first parameter labels.<br>&gt;&gt; <br>&gt;&gt; Instead of loginWithUserName(&quot;blah&quot;, password: &quot;...&quot;) and loginWithCredential(myCredential),<br>&gt;&gt; prefer:<br>&gt;&gt; <br>&gt;&gt; login(userName: &quot;blah&quot;, password: &quot;...&quot;)<br>&gt;&gt; login(credential: myCredential)<br>&gt; <br>&gt; So, how does this proposal improve understandability of use-sites?<br>&gt; <br>&gt;&gt; And to reply to another point raised in-thread:<br>&gt;&gt; <br>&gt;&gt; When working with standard library calls, retain APIs even if they are<br>&gt;&gt; not sufficiently clear from a Swift design perspective rather than<br>&gt;&gt; wrapping-the-cat to provide a Swift interface that doesn&#39;t really<br>&gt;&gt; exist. (As the call is just a redirection.)<br>&gt;&gt; <br>&gt;&gt; For example, prefer<br>&gt;&gt; <br>&gt;&gt; let x = pow(2.0, 5.0)<br>&gt;&gt; <br>&gt;&gt; to<br>&gt;&gt; <br>&gt;&gt; let x = raise(2.0, toPower: 5.0)<br>&gt;&gt; <br>&gt;&gt; In this example, the two arguments for pow are not specified as this call is sourced<br>&gt;&gt; externally and follows the naming convention for math.h.<br>&gt; <br>&gt; This idea is already captured in the guidelines; the reasons to use<br>&gt; &quot;pow(x, y)&quot; are the same as the reasons to use &quot;sin(x)&quot;.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/dc9c4508/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
