<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b3b33f77a1215e7338bfea30585045c?s=50"></div><header><strong>Fixed-sized arrays</strong> from <string>Daryle Walker</string> &lt;darylew at mac.com&gt;<p>June 26, 2016 at 01:00:00am</p></header><div class="content"><p>[I’ve seen the WWDC 2016 Keynote and State of the Platforms videos.  I haven’t seen any others so I don’t spoil myself before typing my ideas down.  Apologies if this has already been covered.]<br></p><p>Is there any problem to adding fixed-sized arrays?  From what I glanced here, it’s more like no one has gotten around to it and less like the very idea is hated.<br></p><p>Obviously, the main advantages are that object storage (or pointer storage for reference types) is on the stack and that the shape (i.e. the number of extents and range for each extent) is fixed at compile time.  This type of, well, type can be used when the baggage of length changing isn’t needed  Such arrays are also a classic type since we started system-programming languages.  (I was surprised by their absence in Swift when I first read the books.)  They can be mapped to a vector processing unit’s built-ins.<br></p><p>This:<br></p><p>&gt; struct ArrayOf5&lt;T&gt; {<br>&gt; <br>&gt;     let count = 5<br>&gt; <br>&gt;     var first: T<br>&gt;     var second: T<br>&gt;     var third: T<br>&gt;     var fourth: T<br>&gt;     var fifth: T<br>&gt; <br>&gt;     init(array: [T]) {<br>&gt;         first = array[0]<br>&gt;         second = array[1]<br>&gt;         third = array[2]<br>&gt;         fourth = array[3]<br>&gt;         fifth = array[4]<br>&gt;     }<br>&gt; <br>&gt;     subscript(index: Int) -&gt; T {<br>&gt;         get {<br>&gt;             var preResult: T?<br>&gt;             switch index {<br>&gt;             case 0:<br>&gt;                 preResult = first<br>&gt;             case 1:<br>&gt;                 preResult = second<br>&gt;             case 2:<br>&gt;                 preResult = third<br>&gt;             case 3:<br>&gt;                 preResult = fourth<br>&gt;             case 4:<br>&gt;                 preResult = fifth<br>&gt;             default:<br>&gt;                 preResult = nil<br>&gt;             }<br>&gt;             return preResult!<br>&gt;         }<br>&gt; <br>&gt;         set {<br>&gt;             func doAssign(destination: UnsafeMutablePointer&lt;T&gt;) {<br>&gt;                 destination.memory = newValue<br>&gt;             }<br>&gt; <br>&gt;             switch index {<br>&gt;             case 0:<br>&gt;                 doAssign(&amp;first)<br>&gt;             case 1:<br>&gt;                 doAssign(&amp;second)<br>&gt;             case 2:<br>&gt;                 doAssign(&amp;third)<br>&gt;             case 3:<br>&gt;                 doAssign(&amp;fourth)<br>&gt;             case 4:<br>&gt;                 doAssign(&amp;fifth)<br>&gt;             default:<br>&gt;                 doAssign(nil)<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; }<br></p><p><br>shouldn’t be better supported than directly having built-in fixed-sized arrays.  (I’ve wondered if we should have a library or built-in arrays.  I’ve decided that even if we add a library, we still need the built-in.)  Although I parametrized the type, altering the shape (right now 1 dimension of 5 elements) doesn’t scale since it requires lexical change.  Internally, a built-in array type would be something like this, modulo optimizations and not having to come up with names for each element.<br></p><p>—————<br></p><p>[The following sections are my ideas about implementation; we don’t have to use them.]<br></p><p>What should array type expressions look like in code?<br></p><p>Since generics (currently) only use type-based parameters, we can’t do something C++-ish like “array&lt;T, 1, 4, 3&gt;”.  I did have a thought of “[MyType; 5]”, but that seemed too close to current arrays.  I was shocked to discover that Rust uses that syntax.  However, it’s still to bad to use now because ‘[MyType]” would mean something different that it does currently (zero-dimensional array of a single unit instead of one-dimensional array of arbitrary number of elements).<br></p><p>Since arrays are product types (I think), let’s use multiplication syntax:<br></p><p>&gt; var myArray: MyType * [6]  // This is an array of six elements, each of `MyType`<br>&gt; var myArray2: MyType * [6] * [5]  // This is an array of five elements, each a six-element array of `MyType`<br>&gt; var myArray3: MyType * [3, 4]  // This is an array of three-by-four, each element of `MyType`<br></p><p>The “[ SHAPE ]” syntax affects the type expression to its left.  An empty list is not allowed since, although array-literal syntax allows empty lists, the subscript operation does not.  Note, to keep the syntax regular, the first subscript when using “myArray2” is for five elements, i.e. “0..&lt;5”, and the second (if any) is for six, the reverse lexical order of declaration.  This is because we don’t have C’s cute “declaration equals usage” type syntax.  Also note that “myArray3” requires a single subscript call with two coordinates in it to dereference.  Supplying only one coordinate is nonsensical.  (“myArray2” is the other way when you want to dereference a “MyType” value.)<br></p><p>Of course, not using a shape expression gives you a zero-dimensional array (i.e. a regular variable) of your base type by default.  (So, it would actually be &quot;0 + extents(MyType.self)&quot; dimensions.)<br></p><p>Or we could just do it the same way C does it (i.e. “MyType[8]”), and preserve nested arrays having the same lexical order in declaration and dereference.  We could even forbid multi-dimensional arrays and just do nested single-dimensional arrays like C (and move multi-dimensionality to wrapper structs), but I feel that would be giving up on improving the abstraction.<br></p><p>——<br></p><p>What about row vs. column order?<br></p><p>If you stick with chaining one-dimensional arrays, you get only row-order, just like C (which can only do nested one-dimensional arrays).  If you use a multi-extent shape expression, you can override the order:<br></p><p>&gt; var myArray1: MyType * [3, 4] * #rank[0, 1]  // Default; row-order<br>&gt; var myArray2: MyType * [3, 4] * #rank[1, 0]  // Reversed; column-order<br>&gt; var myArray3: MyType * [3, 4, 5] * #rank[0, 2, 1]  // Scrambled<br></p><p>The array literal attached to the rank command has to contain every value in 0..&lt;count exactly once.  The position of the “0” value is the spacing with the longest span, “count - 1” is the adjacent elements level.<br></p><p>A rank command can only appear directly after a shape expression or an element type expression, and not after another rank command.  The command’s literal must have the same length as the number of extents of the corresponding shape expression.  A rank command following an element type expression, whether it’s a non-static-array type or a static-array type hidden behind a type alias, is treated as a zero-dimensional array so “#rank[]” is the only legal rank command for them.<br></p><p>The rank command does not pierce type aliases; “#rank[]” is the only valid command for them.  The alias itself can have a rank command, which affects all objects declared with that alias, and cannot be overridden.  (If the alias doesn’t have a rank command, the index storage priority is fixed to the default.)  Should a rank-stripping command be added?  Should an rank command that pierces aliases and/or overrides previous ranks be added?<br></p><p>Types that differ in number of shape commands, number of extents within corresponding commands, size of corresponding extents, index storage priorities, or element type are different types.  We should have a function that can reshape an array if the total number of the outermost non-static-array objects are the same.  (The function could reshape a non-static-array type to a static array of one element with any nesting.)<br></p><p>(If we give up on improving the abstraction compared to C, this rank order would be simulated in a wrapper struct that rearranges the indices.)<br></p><p>——<br></p><p>What about initialization?<br></p><p>I didn’t use initialization expressions before because it’s hard.  We’ll have to work on this.<br></p><p>Zero-dimensional arrays (i.e. a regular non-static-array type) are iniitalized as usual.<br></p><p>A one-dimensional static-array gets initialized like a current dynamic array.  But the syntax given below will also be accepted (with just one coordinate, of course).<br></p><p>For higher-dimensional arrays, we need something like:<br></p><p>&gt; [(0, 0, 0): myFirstValue, (2, 4, 1): mySecondValue, …]<br>&gt; [(0, 0): myFirstValue, (0, 1): mySecondValue, default: myDefaultValue]<br></p><p>and/or:<br></p><p>&gt; var myArray: MyType * [3, 4] = { return 2 * $0 + 7 * $1 }<br></p><p>(We can use “myParam1, myParam2 in” syntax for that last one too.)  Can/could we have an array expression that is part (XX, YY) and part $0/$etc formula?  Maybe with “_” and/or “case” and/or “where” to differentiate which elements get the $0/$etc and which ones get a “default:” phrase?  Maybe the _/case/where could be used within incomplete (XX, YY)-style indexing?<br></p><p>——<br></p><p>Should there be flexible-ending arrays?  Other value types?<br></p><p>Let’s say that at most one extent in a shape expression can be “any” instead of a compile-time integer expression.  Let’s restrict the “any” dimension to be the rank-0 one, using “#rank” to override if you didn’t put the “any” first.  Let’s call these flexible-ending static-arrays.<br></p><p>Flexible-ending static-arrays could be used like the “MyType[]” expression in C.  Frequently it can be used as a function parameter without having to specialize for each possible array length.  In other words, for a given static array type “MyType * […, N, …]”, it can be passed into a function parameter that is declared as “MyType * […, any, …]”.  Could there be an automatic way to pass in the value of “N”, or would we have to resort to using another function parameter or some other out-of-band information and trusting the user to synchronize correctly?<br></p><p>It should be possible to pass in different-shaped arrays to said function parameters with a reshape call, as long as the total number of elements is a multiple of the span across the “any”-ed extent.  Should such a function parameter also take a &quot;[MyInnerType]” dynamic array objects, where “MyInnerType” is what you get after stripping the outermost, “any”-ed, extent?<br></p><p>A flexible-ending struct is one with a flexible-ending type as its last stored property.  A flexible-ending enum is a enum with attributed cases and at least one case ends its tuple with a flexible-ending type.  Flexible-ending types cannot appear anywhere else as a stored property in a struct or enum.  Should we use “final” to mark a struct’s flexible ending property?  Somehow adapt this for enums too?  (Right now, “final” is only used for classes.)  Flexible-ending structs and enums can be used in function parameters too, allowing different lengths for the same parameter.  Like static-arrays, a struct or enum that matches a flexible function parameter except that its would-be flexible part is fixed can be passed through said parameter.  (It’s the same rule since all flexible struct and enums have to have a nested flexible array at their end.)<br></p><p>Besides as function parameters, a flexible-ending object can be declared inside a function/method or as a global.  I’m not sure how to do heap versions yet.  If the object is immutable (i.e. “let”), the initialization block has to cover all the elements without using $0/$etc or “default:” so the size can be determined.  I’m not sure how mutable objects are supposed to work here.  I’ll need your ideas the most here, assuming we keep this feature.  It was inspired by seeing code in Ada (discriminated record) and C (“MyType[1]” as last field in struct, then allocate with malloc) doing this.<br></p><p>Oh yeah, a flexible-ending static-array, including those that are parts of flexible-ending structs and enums, must have a inflexible base type.  (Otherwise lies madness.)<br></p><p>(If we keep this feature, maybe it should be limited to one-dimensional arrays.)<br></p><p>— <br>Daryle Walker<br>Mac, Internet, and Video Game Junkie<br>darylew AT mac DOT com <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160626/29625ba7/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Fixed-sized arrays</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>June 25, 2016 at 11:00:00pm</p></header><div class="content"><p>There have been proposals about that, revolving around creating a new tuple syntax for fixed-size arrays, like (Int x 5), and adding a subscript to them. IIRC, the sentiment was largely positive but people couldn&#39;t agree on the specific syntax.<br></p><p>I pushed a little bit for CollectionType on these, regardless of the type syntax (could have been (Int, Int, Int, Int, Int) for all I was concerned), but there were apparently important implementation challenges stemming from tuples being non-nominal types.<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009682.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009682.html&gt;<br></p><p>I would like to revive this discussion, but I&#39;m afraid that we&#39;re getting late for the Swift 3 release.<br></p><p>Félix<br></p><p>&gt; Le 25 juin 2016 à 22:13:43, Daryle Walker via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; [I’ve seen the WWDC 2016 Keynote and State of the Platforms videos.  I haven’t seen any others so I don’t spoil myself before typing my ideas down.  Apologies if this has already been covered.]<br>&gt; <br>&gt; Is there any problem to adding fixed-sized arrays?  From what I glanced here, it’s more like no one has gotten around to it and less like the very idea is hated.<br>&gt; <br>&gt; Obviously, the main advantages are that object storage (or pointer storage for reference types) is on the stack and that the shape (i.e. the number of extents and range for each extent) is fixed at compile time.  This type of, well, type can be used when the baggage of length changing isn’t needed  Such arrays are also a classic type since we started system-programming languages.  (I was surprised by their absence in Swift when I first read the books.)  They can be mapped to a vector processing unit’s built-ins.<br>&gt; <br>&gt; This:<br>&gt; <br>&gt;&gt; struct ArrayOf5&lt;T&gt; {<br>&gt;&gt; <br>&gt;&gt;     let count = 5<br>&gt;&gt; <br>&gt;&gt;     var first: T<br>&gt;&gt;     var second: T<br>&gt;&gt;     var third: T<br>&gt;&gt;     var fourth: T<br>&gt;&gt;     var fifth: T<br>&gt;&gt; <br>&gt;&gt;     init(array: [T]) {<br>&gt;&gt;         first = array[0]<br>&gt;&gt;         second = array[1]<br>&gt;&gt;         third = array[2]<br>&gt;&gt;         fourth = array[3]<br>&gt;&gt;         fifth = array[4]<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     subscript(index: Int) -&gt; T {<br>&gt;&gt;         get {<br>&gt;&gt;             var preResult: T?<br>&gt;&gt;             switch index {<br>&gt;&gt;             case 0:<br>&gt;&gt;                 preResult = first<br>&gt;&gt;             case 1:<br>&gt;&gt;                 preResult = second<br>&gt;&gt;             case 2:<br>&gt;&gt;                 preResult = third<br>&gt;&gt;             case 3:<br>&gt;&gt;                 preResult = fourth<br>&gt;&gt;             case 4:<br>&gt;&gt;                 preResult = fifth<br>&gt;&gt;             default:<br>&gt;&gt;                 preResult = nil<br>&gt;&gt;             }<br>&gt;&gt;             return preResult!<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt;         set {<br>&gt;&gt;             func doAssign(destination: UnsafeMutablePointer&lt;T&gt;) {<br>&gt;&gt;                 destination.memory = newValue<br>&gt;&gt;             }<br>&gt;&gt; <br>&gt;&gt;             switch index {<br>&gt;&gt;             case 0:<br>&gt;&gt;                 doAssign(&amp;first)<br>&gt;&gt;             case 1:<br>&gt;&gt;                 doAssign(&amp;second)<br>&gt;&gt;             case 2:<br>&gt;&gt;                 doAssign(&amp;third)<br>&gt;&gt;             case 3:<br>&gt;&gt;                 doAssign(&amp;fourth)<br>&gt;&gt;             case 4:<br>&gt;&gt;                 doAssign(&amp;fifth)<br>&gt;&gt;             default:<br>&gt;&gt;                 doAssign(nil)<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt; <br>&gt; <br>&gt; shouldn’t be better supported than directly having built-in fixed-sized arrays.  (I’ve wondered if we should have a library or built-in arrays.  I’ve decided that even if we add a library, we still need the built-in.)  Although I parametrized the type, altering the shape (right now 1 dimension of 5 elements) doesn’t scale since it requires lexical change.  Internally, a built-in array type would be something like this, modulo optimizations and not having to come up with names for each element.<br>&gt; <br>&gt; —————<br>&gt; <br>&gt; [The following sections are my ideas about implementation; we don’t have to use them.]<br>&gt; <br>&gt; What should array type expressions look like in code?<br>&gt; <br>&gt; Since generics (currently) only use type-based parameters, we can’t do something C++-ish like “array&lt;T, 1, 4, 3&gt;”.  I did have a thought of “[MyType; 5]”, but that seemed too close to current arrays.  I was shocked to discover that Rust uses that syntax.  However, it’s still to bad to use now because ‘[MyType]” would mean something different that it does currently (zero-dimensional array of a single unit instead of one-dimensional array of arbitrary number of elements).<br>&gt; <br>&gt; Since arrays are product types (I think), let’s use multiplication syntax:<br>&gt; <br>&gt;&gt; var myArray: MyType * [6]  // This is an array of six elements, each of `MyType`<br>&gt;&gt; var myArray2: MyType * [6] * [5]  // This is an array of five elements, each a six-element array of `MyType`<br>&gt;&gt; var myArray3: MyType * [3, 4]  // This is an array of three-by-four, each element of `MyType`<br>&gt; <br>&gt; The “[ SHAPE ]” syntax affects the type expression to its left.  An empty list is not allowed since, although array-literal syntax allows empty lists, the subscript operation does not.  Note, to keep the syntax regular, the first subscript when using “myArray2” is for five elements, i.e. “0..&lt;5”, and the second (if any) is for six, the reverse lexical order of declaration.  This is because we don’t have C’s cute “declaration equals usage” type syntax.  Also note that “myArray3” requires a single subscript call with two coordinates in it to dereference.  Supplying only one coordinate is nonsensical.  (“myArray2” is the other way when you want to dereference a “MyType” value.)<br>&gt; <br>&gt; Of course, not using a shape expression gives you a zero-dimensional array (i.e. a regular variable) of your base type by default.  (So, it would actually be &quot;0 + extents(MyType.self)&quot; dimensions.)<br>&gt; <br>&gt; Or we could just do it the same way C does it (i.e. “MyType[8]”), and preserve nested arrays having the same lexical order in declaration and dereference.  We could even forbid multi-dimensional arrays and just do nested single-dimensional arrays like C (and move multi-dimensionality to wrapper structs), but I feel that would be giving up on improving the abstraction.<br>&gt; <br>&gt; ——<br>&gt; <br>&gt; What about row vs. column order?<br>&gt; <br>&gt; If you stick with chaining one-dimensional arrays, you get only row-order, just like C (which can only do nested one-dimensional arrays).  If you use a multi-extent shape expression, you can override the order:<br>&gt; <br>&gt;&gt; var myArray1: MyType * [3, 4] * #rank[0, 1]  // Default; row-order<br>&gt;&gt; var myArray2: MyType * [3, 4] * #rank[1, 0]  // Reversed; column-order<br>&gt;&gt; var myArray3: MyType * [3, 4, 5] * #rank[0, 2, 1]  // Scrambled<br>&gt; <br>&gt; The array literal attached to the rank command has to contain every value in 0..&lt;count exactly once.  The position of the “0” value is the spacing with the longest span, “count - 1” is the adjacent elements level.<br>&gt; <br>&gt; A rank command can only appear directly after a shape expression or an element type expression, and not after another rank command.  The command’s literal must have the same length as the number of extents of the corresponding shape expression.  A rank command following an element type expression, whether it’s a non-static-array type or a static-array type hidden behind a type alias, is treated as a zero-dimensional array so “#rank[]” is the only legal rank command for them.<br>&gt; <br>&gt; The rank command does not pierce type aliases; “#rank[]” is the only valid command for them.  The alias itself can have a rank command, which affects all objects declared with that alias, and cannot be overridden.  (If the alias doesn’t have a rank command, the index storage priority is fixed to the default.)  Should a rank-stripping command be added?  Should an rank command that pierces aliases and/or overrides previous ranks be added?<br>&gt; <br>&gt; Types that differ in number of shape commands, number of extents within corresponding commands, size of corresponding extents, index storage priorities, or element type are different types.  We should have a function that can reshape an array if the total number of the outermost non-static-array objects are the same.  (The function could reshape a non-static-array type to a static array of one element with any nesting.)<br>&gt; <br>&gt; (If we give up on improving the abstraction compared to C, this rank order would be simulated in a wrapper struct that rearranges the indices.)<br>&gt; <br>&gt; ——<br>&gt; <br>&gt; What about initialization?<br>&gt; <br>&gt; I didn’t use initialization expressions before because it’s hard.  We’ll have to work on this.<br>&gt; <br>&gt; Zero-dimensional arrays (i.e. a regular non-static-array type) are iniitalized as usual.<br>&gt; <br>&gt; A one-dimensional static-array gets initialized like a current dynamic array.  But the syntax given below will also be accepted (with just one coordinate, of course).<br>&gt; <br>&gt; For higher-dimensional arrays, we need something like:<br>&gt; <br>&gt;&gt; [(0, 0, 0): myFirstValue, (2, 4, 1): mySecondValue, …]<br>&gt;&gt; [(0, 0): myFirstValue, (0, 1): mySecondValue, default: myDefaultValue]<br>&gt; <br>&gt; and/or:<br>&gt; <br>&gt;&gt; var myArray: MyType * [3, 4] = { return 2 * $0 + 7 * $1 }<br>&gt; <br>&gt; (We can use “myParam1, myParam2 in” syntax for that last one too.)  Can/could we have an array expression that is part (XX, YY) and part $0/$etc formula?  Maybe with “_” and/or “case” and/or “where” to differentiate which elements get the $0/$etc and which ones get a “default:” phrase?  Maybe the _/case/where could be used within incomplete (XX, YY)-style indexing?<br>&gt; <br>&gt; ——<br>&gt; <br>&gt; Should there be flexible-ending arrays?  Other value types?<br>&gt; <br>&gt; Let’s say that at most one extent in a shape expression can be “any” instead of a compile-time integer expression.  Let’s restrict the “any” dimension to be the rank-0 one, using “#rank” to override if you didn’t put the “any” first.  Let’s call these flexible-ending static-arrays.<br>&gt; <br>&gt; Flexible-ending static-arrays could be used like the “MyType[]” expression in C.  Frequently it can be used as a function parameter without having to specialize for each possible array length.  In other words, for a given static array type “MyType * […, N, …]”, it can be passed into a function parameter that is declared as “MyType * […, any, …]”.  Could there be an automatic way to pass in the value of “N”, or would we have to resort to using another function parameter or some other out-of-band information and trusting the user to synchronize correctly?<br>&gt; <br>&gt; It should be possible to pass in different-shaped arrays to said function parameters with a reshape call, as long as the total number of elements is a multiple of the span across the “any”-ed extent.  Should such a function parameter also take a &quot;[MyInnerType]” dynamic array objects, where “MyInnerType” is what you get after stripping the outermost, “any”-ed, extent?<br>&gt; <br>&gt; A flexible-ending struct is one with a flexible-ending type as its last stored property.  A flexible-ending enum is a enum with attributed cases and at least one case ends its tuple with a flexible-ending type.  Flexible-ending types cannot appear anywhere else as a stored property in a struct or enum.  Should we use “final” to mark a struct’s flexible ending property?  Somehow adapt this for enums too?  (Right now, “final” is only used for classes.)  Flexible-ending structs and enums can be used in function parameters too, allowing different lengths for the same parameter.  Like static-arrays, a struct or enum that matches a flexible function parameter except that its would-be flexible part is fixed can be passed through said parameter.  (It’s the same rule since all flexible struct and enums have to have a nested flexible array at their end.)<br>&gt; <br>&gt; Besides as function parameters, a flexible-ending object can be declared inside a function/method or as a global.  I’m not sure how to do heap versions yet.  If the object is immutable (i.e. “let”), the initialization block has to cover all the elements without using $0/$etc or “default:” so the size can be determined.  I’m not sure how mutable objects are supposed to work here.  I’ll need your ideas the most here, assuming we keep this feature.  It was inspired by seeing code in Ada (discriminated record) and C (“MyType[1]” as last field in struct, then allocate with malloc) doing this.<br>&gt; <br>&gt; Oh yeah, a flexible-ending static-array, including those that are parts of flexible-ending structs and enums, must have a inflexible base type.  (Otherwise lies madness.)<br>&gt; <br>&gt; (If we keep this feature, maybe it should be limited to one-dimensional arrays.)<br>&gt; <br>&gt; — <br>&gt; Daryle Walker<br>&gt; Mac, Internet, and Video Game Junkie<br>&gt; darylew AT mac DOT com <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160625/31901c84/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b3b33f77a1215e7338bfea30585045c?s=50"></div><header><strong>Fixed-sized arrays</strong> from <string>Daryle Walker</string> &lt;darylew at mac.com&gt;<p>July  2, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 26, 2016, at 2:20 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; There have been proposals about that, revolving around creating a new tuple syntax for fixed-size arrays, like (Int x 5), and adding a subscript to them. IIRC, the sentiment was largely positive but people couldn&#39;t agree on the specific syntax.<br>&gt; <br>&gt; I pushed a little bit for CollectionType on these, regardless of the type syntax (could have been (Int, Int, Int, Int, Int) for all I was concerned), but there were apparently important implementation challenges stemming from tuples being non-nominal types.<br>&gt; <br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009682.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009682.html&gt;<br>&gt; <br>&gt; I would like to revive this discussion, but I&#39;m afraid that we&#39;re getting late for the Swift 3 release.<br></p><p>From a quick look, the previous threads’ tuple-array quasi-equivalence would work for one-dimensional arrays, but I want to go beyond what C has and do multi-dimensional arrays too (co-equal coordinates, not just C’s nested arrays).  Of course a non-linear structure brings questions on how to visit/traverse every element; the existing sequence and collection protocols assume linearity, as well as the “for” statements that use said conforming types.<br></p><p>— <br>Daryle Walker<br>Mac, Internet, and Video Game Junkie<br>darylew AT mac DOT com <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160702/5ce5cede/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
