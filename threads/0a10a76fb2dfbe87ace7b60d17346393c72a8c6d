<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/46439321e8b5b5ba0944eef50e18c3a3?s=50"></div><header><strong>pattern matching on variable-sized data type</strong> from <string>Jean-Denis Muys</string> &lt;jdmuys at gmail.com&gt;<p>September  6, 2016 at 04:00:00pm</p></header><div class="content"><p>Hello,<br></p><p>I would like to suggest an additive evolution to Swift that might be in scope of phase 1 of Swift 4 (because it might have an impact on the ABI).<br></p><p>The idea is to extend the pattern matching abilities of Swift to enable a recursive programming style that’s very common in languages such as Lisp, ML, or Prolog on a collection that is processed as a list. By analogy to ML, Swift could do that on tuples, or on arrays, or on any similar, perhaps new, data type. This would allow the following for example:<br></p><p>func listOfDifferenceOfListElements (list: List&lt;Int&gt;) -&gt; Int {<br>    <br>    switch list {<br>    case 〘〙: {<br>        return 〘〙<br>        }<br>    case 〘 let a 〙: {<br>        return 〘 a 〙<br>        }<br>    case 〘 let a, let b ⫸ let tail 〙: {<br>        return 〘 a-b 〙 ⋙ sumDifferenceOfListElements(tail)<br>        }<br>    }<br>}<br></p><p><br>Where I deliberately used unusual Unicode characters to denote syntax that would need to be invented:<br></p><p>- 〘〙 to denote the list-like data structure. It would be old style parenthesis if we wanted that to be Swift’s tuple, or the usual bracket if it was arrays<br>- ⫸ to pattern-match the tail of the list, i.e. the list composed of any and all elements following whatever has been pattern-matched so far<br>- ⋙ to denote a list append operator.<br></p><p>If we wanted the list data-type to be tuples, this would require the ability to build longer tuples from existing ones, i.e. build (a, b, c) from a and (b, c), or from (a) and (b, c) (appending tuples). Array seems more suitable, however.<br></p><p>So this post is to assess the interest in such a feature. Also note that while I have tried to have an occasional look at this mailing list in the past, due to its overwhelming volume, I may very well have missed a similar discussion in the past. In that case, I would appreciate a pointer.<br></p><p>As someone who developed Lisp and Prolog software professionally in a rather distant past, with an ever renewed sense of wonder, I would very much love to be able to use that programming style again when it makes sense.<br></p><p>If there is interest, I would be willing to write up an evolution proposal.<br></p><p>Jean-Denis Muys<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160906/0a108c6d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/46439321e8b5b5ba0944eef50e18c3a3?s=50"></div><header><strong>pattern matching on variable-sized data type</strong> from <string>Jean-Denis Muys</string> &lt;jdmuys at gmail.com&gt;<p>September  6, 2016 at 05:00:00pm</p></header><div class="content"><p>The recursive call should obviously read<br></p><p>return 〘 a-b 〙 ⋙ listOfDifferenceOfListElements(tail)<br></p><p>Jean-Denis<br></p><p><br></p><p><br>&gt; On 06 Sep 2016, at 16:48, Jean-Denis Muys &lt;jdmuys at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hello,<br>&gt; <br>&gt; I would like to suggest an additive evolution to Swift that might be in scope of phase 1 of Swift 4 (because it might have an impact on the ABI).<br>&gt; <br>&gt; The idea is to extend the pattern matching abilities of Swift to enable a recursive programming style that’s very common in languages such as Lisp, ML, or Prolog on a collection that is processed as a list. By analogy to ML, Swift could do that on tuples, or on arrays, or on any similar, perhaps new, data type. This would allow the following for example:<br>&gt; <br>&gt; func listOfDifferenceOfListElements (list: List&lt;Int&gt;) -&gt; Int {<br>&gt;     <br>&gt;     switch list {<br>&gt;     case 〘〙: {<br>&gt;         return 〘〙<br>&gt;         }<br>&gt;     case 〘 let a 〙: {<br>&gt;         return 〘 a 〙<br>&gt;         }<br>&gt;     case 〘 let a, let b ⫸ let tail 〙: {<br>&gt;         return 〘 a-b 〙 ⋙ sumDifferenceOfListElements(tail)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Where I deliberately used unusual Unicode characters to denote syntax that would need to be invented:<br>&gt; <br>&gt; - 〘〙 to denote the list-like data structure. It would be old style parenthesis if we wanted that to be Swift’s tuple, or the usual bracket if it was arrays<br>&gt; - ⫸ to pattern-match the tail of the list, i.e. the list composed of any and all elements following whatever has been pattern-matched so far<br>&gt; - ⋙ to denote a list append operator.<br>&gt; <br>&gt; If we wanted the list data-type to be tuples, this would require the ability to build longer tuples from existing ones, i.e. build (a, b, c) from a and (b, c), or from (a) and (b, c) (appending tuples). Array seems more suitable, however.<br>&gt; <br>&gt; So this post is to assess the interest in such a feature. Also note that while I have tried to have an occasional look at this mailing list in the past, due to its overwhelming volume, I may very well have missed a similar discussion in the past. In that case, I would appreciate a pointer.<br>&gt; <br>&gt; As someone who developed Lisp and Prolog software professionally in a rather distant past, with an ever renewed sense of wonder, I would very much love to be able to use that programming style again when it makes sense.<br>&gt; <br>&gt; If there is interest, I would be willing to write up an evolution proposal.<br>&gt; <br>&gt; Jean-Denis Muys<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160906/7065f998/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>pattern matching on variable-sized data type</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>September  6, 2016 at 06:00:00pm</p></header><div class="content"><p>You can process lists using pattern matching today:<br></p><p>enum List&lt;T&gt; {<br>    case Nil<br>    indirect case Cons(T, List&lt;T&gt;)<br>}<br>let list: List&lt;Int&gt; = .Cons(2, .Cons(3, .Nil))<br>switch list {<br>    case .Nil: ...<br>    case .Cons(let x, .Nil): ...<br>    case .Cons(let x, .Cons(let y, .Nil)): ...<br>    default: handleLongList(list)<br>}<br></p><p>The thing is, such lists are not idiomatic in Swift. Pattern matching on<br>Array also kind-of works:<br></p><p>let array: Array&lt;Int&gt; = ...<br>switch array.first {<br>    case .some(let first):<br>        processHead(first)<br>        processTail(array.dropFirst())<br>    case .none:<br>        handleNil()<br>}<br></p><p>Again, it’s not the most idiomatic way to do this in Swift. Also, there is<br>no guaranteed tail-call optimization.<br></p><p>2016-09-06 17:48 GMT+03:00 Jean-Denis Muys via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>Hello,<br>&gt;<br>&gt; I would like to suggest an additive evolution to Swift that might be in<br>&gt; scope of phase 1 of Swift 4 (because it might have an impact on the ABI).<br>&gt;<br>&gt; The idea is to extend the pattern matching abilities of Swift to enable a<br>&gt; recursive programming style that’s very common in languages such as Lisp,<br>&gt; ML, or Prolog on a collection that is processed as a list. By analogy to<br>&gt; ML, Swift could do that on tuples, or on arrays, or on any similar, perhaps<br>&gt; new, data type. This would allow the following for example:<br>&gt;<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160906/786e8524/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>pattern matching on variable-sized data type</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>September  6, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Sep 6, 2016, at 7:48 AM, Jean-Denis Muys via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello,<br>&gt; <br>&gt; I would like to suggest an additive evolution to Swift that might be in scope of phase 1 of Swift 4 (because it might have an impact on the ABI).<br></p><p>This is a purely additive change, I can’t imagine how it would impact the ABI of existing code.<br></p><p>-Chris<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
