<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  4, 2016 at 04:00:00pm</p></header><div class="content"><p>on Thu Mar 03 2016, Patrick Pijnappel &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hmm I see.<br>&gt;<br>&gt; Do we have any example cases where returning nil repeatedly would require<br>&gt; extra branches or state?<br></p><p>Off the top of my head: a stream of random numbers that stops when it<br>encounters a zero.<br></p><p>&gt;<br>&gt; The generators in the standard library don&#39;t (*) – the usual pattern is<br>&gt; either of the following:<br>&gt; - 1) Check state if we&#39;re at end, if so return nil 2) get return value 3)<br>&gt; advance state. Since the state is not mutated before returning nil,<br>&gt; repeating nil is automatic.<br>&gt; - 1) Call next() on one or more wrapped generators 2) return some<br>&gt; transformation of that. If the wrapped generators repeat nil, repeating nil<br>&gt; is also automatic for the wrapper.<br>&gt;<br>&gt; If you would have a generator setup that doesn&#39;t automatically repeat nil,<br>&gt; omitting a nil-repeat check might be dangerous considering the risk other<br>&gt; code hadn&#39;t considered the case.<br>&gt;<br>&gt; (*) StrideThroughGenerator &amp; ZipGenerator have a done flag, but need these<br>&gt; even without repeating nil. JoinGenerator has an .End state but actually<br>&gt; doesn&#39;t have to – even to repeat nil.<br></p><p>What algorithms or components can be simplified by taking advantage of<br>this extra guarantee?  If the category of code that can use it is<br>broader than the category of generators that would suffer an overhead or<br>implementation complexity, it might be worth doing.<br></p><p>My intuition is that both categories are small.  <br></p><p>&gt;<br>&gt;<br>&gt; On Thu, Mar 3, 2016 at 8:12 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Wed, Mar 2, 2016 at 10:47 PM, Patrick Pijnappel via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; Situation<br>&gt;&gt; &gt; Currently GeneratorType.next() requires callers to not call next() after<br>&gt;&gt; it<br>&gt;&gt; &gt; has returned nil once, even encouraging a preconditionFailure() if this<br>&gt;&gt; is<br>&gt;&gt; &gt; violated:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   /// - Requires: `next()` has not been applied to a copy of `self`<br>&gt;&gt; &gt;   ///   since the copy was made, and no preceding call to `self.next()`<br>&gt;&gt; &gt;   ///   has returned `nil`.  Specific implementations of this protocol<br>&gt;&gt; &gt;   ///   are encouraged to respond to violations of this requirement by<br>&gt;&gt; &gt;   ///   calling `preconditionFailure(&quot;...&quot;)`.<br>&gt;&gt;<br>&gt;&gt; I&#39;d like to add more context to this discussion.  We added this<br>&gt;&gt; requirement a while ago.  [1]  The reason for introducing it was not<br>&gt;&gt; an attempt to flag bugs in client code.  Rather, we were not convinced<br>&gt;&gt; that all generators can return nil repeatedly without loss of<br>&gt;&gt; efficiency or extra storage burden.<br>&gt;&gt;<br>&gt;&gt; [1]<br>&gt;&gt; https://github.com/apple/swift/commit/304b4f33ae74a5abd09da485bbc435dfa2ade522<br>&gt;&gt; and rdar://problem/17392226<br>&gt;&gt;<br>&gt;&gt; &gt; Adds caller burden<br>&gt;&gt; &gt; To avoid breaking the requirement, the caller will not uncommonly have<br>&gt;&gt; to track extra state and branch<br>&gt;&gt;<br>&gt;&gt; I would actually say the opposite -- running a non-trivial algorithm<br>&gt;&gt; on generators is a very uncommon thing to do.  The 99% use case for<br>&gt;&gt; generators is implicit usage from the for-in loop.  This is why<br>&gt;&gt; allowing generators to be as simple as possible and pushing the<br>&gt;&gt; requirement for extra branches into non-trivial algorithms made sense<br>&gt;&gt; for us when we introduced this requirement.<br>&gt;&gt;<br>&gt;&gt; &gt; Silent corner case<br>&gt;&gt; &gt; Because basically all generators keep returning nil, it&#39;s not unlikely<br>&gt;&gt; people will write their code based on the assumption it will always return<br>&gt;&gt; nil<br>&gt;&gt;<br>&gt;&gt; This is what concerns me the most about the current rules.<br>&gt;&gt;<br>&gt;&gt; Dmitri<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  4, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; What algorithms or components can be simplified by taking advantage of<br>&gt; this extra guarantee?  If the category of code that can use it is<br>&gt; broader than the category of generators that would suffer an overhead or<br>&gt; implementation complexity, it might be worth doing.<br>&gt; <br>&gt; My intuition is that both categories are small.  <br></p><p>I do agree that both categories are probably small. But they have very different consequences:<br></p><p>* If you make the guarantee, certain rare types of generators will need a little more storage and an extra branch.<br>* If you don&#39;t make the guarantee, code which works most of the time will fail when combined with certain generators.<br></p><p>It seems like we&#39;re facing a tradeoff between a tiny efficiency gain in rare cases and predictable semantics in all cases. I&#39;m not convinced efficiency is the right choice here.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>March  5, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; What algorithms or components can be simplified by taking advantage of this<br>&gt; extra guarantee?<br></p><p><br>Any generator that somehow buffers their underlying generator (as it can&#39;t<br>tell whether it already tried to refill the buffer). For example UTF8 &amp;<br>UTF16&#39;s decode() both have 3 instead of 2 branches on ASCII input because<br>of this.<br></p><p>Off the top of my head: a stream of random numbers that stops when it<br>encounters<br>&gt; a zero.<br></p><p><br>You could generate the next random number in advance (you take a O(1) hit<br>instead of O(n)). Of course consuming more than you need is not always<br>allowed and the O(1) could outweigh the branch.<br></p><p>Overall I&#39;d say performance-wise both categories are small (though taking<br>the standard library as sample case, we have some examples of the former<br>but not the latter).<br></p><p>We&#39;d be left with the safety concern of code which fails in rare corner<br>cases.<br></p><p><br>On Sat, Mar 5, 2016 at 11:30 AM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Thu Mar 03 2016, Patrick Pijnappel &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; Hmm I see.<br>&gt; &gt;<br>&gt; &gt; Do we have any example cases where returning nil repeatedly would require<br>&gt; &gt; extra branches or state?<br>&gt;<br>&gt; Off the top of my head: a stream of random numbers that stops when it<br>&gt; encounters a zero.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; The generators in the standard library don&#39;t (*) – the usual pattern is<br>&gt; &gt; either of the following:<br>&gt; &gt; - 1) Check state if we&#39;re at end, if so return nil 2) get return value 3)<br>&gt; &gt; advance state. Since the state is not mutated before returning nil,<br>&gt; &gt; repeating nil is automatic.<br>&gt; &gt; - 1) Call next() on one or more wrapped generators 2) return some<br>&gt; &gt; transformation of that. If the wrapped generators repeat nil, repeating<br>&gt; nil<br>&gt; &gt; is also automatic for the wrapper.<br>&gt; &gt;<br>&gt; &gt; If you would have a generator setup that doesn&#39;t automatically repeat<br>&gt; nil,<br>&gt; &gt; omitting a nil-repeat check might be dangerous considering the risk other<br>&gt; &gt; code hadn&#39;t considered the case.<br>&gt; &gt;<br>&gt; &gt; (*) StrideThroughGenerator &amp; ZipGenerator have a done flag, but need<br>&gt; these<br>&gt; &gt; even without repeating nil. JoinGenerator has an .End state but actually<br>&gt; &gt; doesn&#39;t have to – even to repeat nil.<br>&gt;<br>&gt; What algorithms or components can be simplified by taking advantage of<br>&gt; this extra guarantee?  If the category of code that can use it is<br>&gt; broader than the category of generators that would suffer an overhead or<br>&gt; implementation complexity, it might be worth doing.<br>&gt;<br>&gt; My intuition is that both categories are small.<br>&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Thu, Mar 3, 2016 at 8:12 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Wed, Mar 2, 2016 at 10:47 PM, Patrick Pijnappel via swift-evolution<br>&gt; &gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt; Situation<br>&gt; &gt;&gt; &gt; Currently GeneratorType.next() requires callers to not call next()<br>&gt; after<br>&gt; &gt;&gt; it<br>&gt; &gt;&gt; &gt; has returned nil once, even encouraging a preconditionFailure() if<br>&gt; this<br>&gt; &gt;&gt; is<br>&gt; &gt;&gt; &gt; violated:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;   /// - Requires: `next()` has not been applied to a copy of `self`<br>&gt; &gt;&gt; &gt;   ///   since the copy was made, and no preceding call to<br>&gt; `self.next()`<br>&gt; &gt;&gt; &gt;   ///   has returned `nil`.  Specific implementations of this protocol<br>&gt; &gt;&gt; &gt;   ///   are encouraged to respond to violations of this requirement by<br>&gt; &gt;&gt; &gt;   ///   calling `preconditionFailure(&quot;...&quot;)`.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;d like to add more context to this discussion.  We added this<br>&gt; &gt;&gt; requirement a while ago.  [1]  The reason for introducing it was not<br>&gt; &gt;&gt; an attempt to flag bugs in client code.  Rather, we were not convinced<br>&gt; &gt;&gt; that all generators can return nil repeatedly without loss of<br>&gt; &gt;&gt; efficiency or extra storage burden.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; [1]<br>&gt; &gt;&gt;<br>&gt; https://github.com/apple/swift/commit/304b4f33ae74a5abd09da485bbc435dfa2ade522<br>&gt; &gt;&gt; and rdar://problem/17392226<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; Adds caller burden<br>&gt; &gt;&gt; &gt; To avoid breaking the requirement, the caller will not uncommonly have<br>&gt; &gt;&gt; to track extra state and branch<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I would actually say the opposite -- running a non-trivial algorithm<br>&gt; &gt;&gt; on generators is a very uncommon thing to do.  The 99% use case for<br>&gt; &gt;&gt; generators is implicit usage from the for-in loop.  This is why<br>&gt; &gt;&gt; allowing generators to be as simple as possible and pushing the<br>&gt; &gt;&gt; requirement for extra branches into non-trivial algorithms made sense<br>&gt; &gt;&gt; for us when we introduced this requirement.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; Silent corner case<br>&gt; &gt;&gt; &gt; Because basically all generators keep returning nil, it&#39;s not unlikely<br>&gt; &gt;&gt; people will write their code based on the assumption it will always<br>&gt; return<br>&gt; &gt;&gt; nil<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This is what concerns me the most about the current rules.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Dmitri<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; &gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; &gt;&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160305/4ec29c07/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
