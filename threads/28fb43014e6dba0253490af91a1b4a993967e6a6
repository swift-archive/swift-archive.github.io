<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  6, 2016 at 05:00:00pm</p></header><div class="content"><p>on Sun Jun 05 2016, Haravikk &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On 5 Jun 2016, at 19:14, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Most standard library functions that take a closure allow that<br>&gt;&gt; closure to throw (and those functions are subsequently marked with<br>&gt;&gt; rethrows). sort and sorted are exceptions to this. I couldn’t find<br>&gt;<br>&gt;&gt; this documented anywhere, but I assume this is because sorting can<br>&gt;&gt; happen in-place and it would be impossible to restore the array to<br>&gt;&gt; its original state without giving up performance. Correct me if I’m<br>&gt;&gt; wrong.<br>&gt;&gt; <br>&gt;&gt; I’d like to propose that we let sort rethrow anyways, and leave the<br>&gt;&gt; array in an intermediate state (where the elements are in an<br>&gt;&gt; arbitrary order) when an error is thrown. As long as this is<br>&gt;&gt; properly documented, this shouldn’t lead to any confusion. Best of<br>&gt;&gt; all, it would allow sorted to rethrow as well in which there is no<br>&gt;&gt; room for confusion at all because it doesn’t mutate any of the<br>&gt;&gt; user’s variables.<br>&gt;<br>&gt; This sounds reasonable; worst case with in-place sorting is that the<br>&gt; collection was sorted in one order, and is only partially sorted in a<br>&gt; new one, but the exception and your handling of it should be able to<br>&gt; account for this.<br>&gt;<br>&gt; It will require documentation to be clear that sorting methods should<br>&gt; take care not to leave anything incomplete if a closure throws; most<br>&gt; algorithms should be fine since they usually just test the closure<br>&gt; then swap two values afterwards (where necessary) so there’s nothing<br>&gt; really to interrupt, but anything that uses some kind of buffering may<br>&gt; need to be redesigned to ensure there’s a fallback to ensure no<br>&gt; elements are ever lost.<br></p><p>Ensuring that no elements are ever lost is not a particularly useful<br>goal, and not a constraint to which I would want to hold the standard<br>library.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>June  7, 2016 at 01:00:00am</p></header><div class="content"><p>Might I add that leaving an array in an arbitrary and<br>implementation-dependent state is also surprising to users as well as not<br>very useful-to the user this is nothing more than a random permutation.<br></p><p>On Mon, Jun 6, 2016 at 5:31 PM Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Sun Jun 05 2016, Haravikk &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; On 5 Jun 2016, at 19:14, Tim Vermeulen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Most standard library functions that take a closure allow that<br>&gt; &gt;&gt; closure to throw (and those functions are subsequently marked with<br>&gt; &gt;&gt; rethrows). sort and sorted are exceptions to this. I couldn’t find<br>&gt; &gt;<br>&gt; &gt;&gt; this documented anywhere, but I assume this is because sorting can<br>&gt; &gt;&gt; happen in-place and it would be impossible to restore the array to<br>&gt; &gt;&gt; its original state without giving up performance. Correct me if I’m<br>&gt; &gt;&gt; wrong.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’d like to propose that we let sort rethrow anyways, and leave the<br>&gt; &gt;&gt; array in an intermediate state (where the elements are in an<br>&gt; &gt;&gt; arbitrary order) when an error is thrown. As long as this is<br>&gt; &gt;&gt; properly documented, this shouldn’t lead to any confusion. Best of<br>&gt; &gt;&gt; all, it would allow sorted to rethrow as well in which there is no<br>&gt; &gt;&gt; room for confusion at all because it doesn’t mutate any of the<br>&gt; &gt;&gt; user’s variables.<br>&gt; &gt;<br>&gt; &gt; This sounds reasonable; worst case with in-place sorting is that the<br>&gt; &gt; collection was sorted in one order, and is only partially sorted in a<br>&gt; &gt; new one, but the exception and your handling of it should be able to<br>&gt; &gt; account for this.<br>&gt; &gt;<br>&gt; &gt; It will require documentation to be clear that sorting methods should<br>&gt; &gt; take care not to leave anything incomplete if a closure throws; most<br>&gt; &gt; algorithms should be fine since they usually just test the closure<br>&gt; &gt; then swap two values afterwards (where necessary) so there’s nothing<br>&gt; &gt; really to interrupt, but anything that uses some kind of buffering may<br>&gt; &gt; need to be redesigned to ensure there’s a fallback to ensure no<br>&gt; &gt; elements are ever lost.<br>&gt;<br>&gt; Ensuring that no elements are ever lost is not a particularly useful<br>&gt; goal, and not a constraint to which I would want to hold the standard<br>&gt; library.<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/bec1a5c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  7, 2016 at 10:00:00am</p></header><div class="content"><p>on Mon Jun 06 2016, Saagar Jha &lt;saagarjha28-AT-gmail.com&gt; wrote:<br></p><p>&gt; Might I add that leaving an array in an arbitrary and<br>&gt; implementation-dependent state is also surprising to users as well as not<br>&gt; very useful-to the user this is nothing more than a random permutation.<br></p><p>True, but the cost of being able to restore the original ordering, when<br>that restoration may not be needed at all, is prohibitive.  It&#39;s often<br>the case that the caller will be throwing away the partially-modified<br>original when an error is thrown.<br></p><p>&gt; On Mon, Jun 6, 2016 at 5:31 PM Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Sun Jun 05 2016, Haravikk &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; On 5 Jun 2016, at 19:14, Tim Vermeulen via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Most standard library functions that take a closure allow that<br>&gt;&gt; &gt;&gt; closure to throw (and those functions are subsequently marked with<br>&gt;&gt; &gt;&gt; rethrows). sort and sorted are exceptions to this. I couldn’t find<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; this documented anywhere, but I assume this is because sorting can<br>&gt;&gt; &gt;&gt; happen in-place and it would be impossible to restore the array to<br>&gt;&gt; &gt;&gt; its original state without giving up performance. Correct me if I’m<br>&gt;&gt; &gt;&gt; wrong.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I’d like to propose that we let sort rethrow anyways, and leave the<br>&gt;&gt; &gt;&gt; array in an intermediate state (where the elements are in an<br>&gt;&gt; &gt;&gt; arbitrary order) when an error is thrown. As long as this is<br>&gt;&gt; &gt;&gt; properly documented, this shouldn’t lead to any confusion. Best of<br>&gt;&gt; &gt;&gt; all, it would allow sorted to rethrow as well in which there is no<br>&gt;&gt; &gt;&gt; room for confusion at all because it doesn’t mutate any of the<br>&gt;&gt; &gt;&gt; user’s variables.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This sounds reasonable; worst case with in-place sorting is that the<br>&gt;&gt; &gt; collection was sorted in one order, and is only partially sorted in a<br>&gt;&gt; &gt; new one, but the exception and your handling of it should be able to<br>&gt;&gt; &gt; account for this.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It will require documentation to be clear that sorting methods should<br>&gt;&gt; &gt; take care not to leave anything incomplete if a closure throws; most<br>&gt;&gt; &gt; algorithms should be fine since they usually just test the closure<br>&gt;&gt; &gt; then swap two values afterwards (where necessary) so there’s nothing<br>&gt;&gt; &gt; really to interrupt, but anything that uses some kind of buffering may<br>&gt;&gt; &gt; need to be redesigned to ensure there’s a fallback to ensure no<br>&gt;&gt; &gt; elements are ever lost.<br>&gt;&gt;<br>&gt;&gt; Ensuring that no elements are ever lost is not a particularly useful<br>&gt;&gt; goal, and not a constraint to which I would want to hold the standard<br>&gt;&gt; library.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>June  7, 2016 at 05:00:00pm</p></header><div class="content"><p>Exactly. While rethrows for sort make sense, since there is no user<br>variable modification, sortInPlace either needs to revert the array (which<br>is potentially expensive) or leave it in an arbitrary state, neither of<br>which are good choices. I can’t seem to find any mutating function that<br>rethrows, and I think it’s for precisely this reason.<br></p><p>On Tue, Jun 7, 2016 at 10:20 AM Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; on Mon Jun 06 2016, Saagar Jha &lt;saagarjha28-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; Might I add that leaving an array in an arbitrary and<br>&gt; &gt; implementation-dependent state is also surprising to users as well as not<br>&gt; &gt; very useful-to the user this is nothing more than a random permutation.<br>&gt;<br>&gt; True, but the cost of being able to restore the original ordering, when<br>&gt; that restoration may not be needed at all, is prohibitive.  It&#39;s often<br>&gt; the case that the caller will be throwing away the partially-modified<br>&gt; original when an error is thrown.<br>&gt;<br>&gt; &gt; On Mon, Jun 6, 2016 at 5:31 PM Dave Abrahams via swift-evolution &lt;<br>&gt; &gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Sun Jun 05 2016, Haravikk &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; On 5 Jun 2016, at 19:14, Tim Vermeulen via swift-evolution &lt;<br>&gt; &gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; Most standard library functions that take a closure allow that<br>&gt; &gt;&gt; &gt;&gt; closure to throw (and those functions are subsequently marked with<br>&gt; &gt;&gt; &gt;&gt; rethrows). sort and sorted are exceptions to this. I couldn’t find<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt; this documented anywhere, but I assume this is because sorting can<br>&gt; &gt;&gt; &gt;&gt; happen in-place and it would be impossible to restore the array to<br>&gt; &gt;&gt; &gt;&gt; its original state without giving up performance. Correct me if I’m<br>&gt; &gt;&gt; &gt;&gt; wrong.<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; I’d like to propose that we let sort rethrow anyways, and leave the<br>&gt; &gt;&gt; &gt;&gt; array in an intermediate state (where the elements are in an<br>&gt; &gt;&gt; &gt;&gt; arbitrary order) when an error is thrown. As long as this is<br>&gt; &gt;&gt; &gt;&gt; properly documented, this shouldn’t lead to any confusion. Best of<br>&gt; &gt;&gt; &gt;&gt; all, it would allow sorted to rethrow as well in which there is no<br>&gt; &gt;&gt; &gt;&gt; room for confusion at all because it doesn’t mutate any of the<br>&gt; &gt;&gt; &gt;&gt; user’s variables.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; This sounds reasonable; worst case with in-place sorting is that the<br>&gt; &gt;&gt; &gt; collection was sorted in one order, and is only partially sorted in a<br>&gt; &gt;&gt; &gt; new one, but the exception and your handling of it should be able to<br>&gt; &gt;&gt; &gt; account for this.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; It will require documentation to be clear that sorting methods should<br>&gt; &gt;&gt; &gt; take care not to leave anything incomplete if a closure throws; most<br>&gt; &gt;&gt; &gt; algorithms should be fine since they usually just test the closure<br>&gt; &gt;&gt; &gt; then swap two values afterwards (where necessary) so there’s nothing<br>&gt; &gt;&gt; &gt; really to interrupt, but anything that uses some kind of buffering may<br>&gt; &gt;&gt; &gt; need to be redesigned to ensure there’s a fallback to ensure no<br>&gt; &gt;&gt; &gt; elements are ever lost.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Ensuring that no elements are ever lost is not a particularly useful<br>&gt; &gt;&gt; goal, and not a constraint to which I would want to hold the standard<br>&gt; &gt;&gt; library.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; Dave<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>-- <br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/f504e1d7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Marking sort and sorted with rethrows</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  7, 2016 at 11:00:00am</p></header><div class="content"><p>on Tue Jun 07 2016, Saagar Jha &lt;saagarjha28-AT-gmail.com&gt; wrote:<br></p><p>&gt; Exactly. While rethrows for sort make sense, since there is no user<br>&gt; variable modification, sortInPlace either needs to revert the array (which<br>&gt; is potentially expensive) or leave it in an arbitrary state, neither of<br>&gt; which are good choices. I can’t seem to find any mutating function that<br>&gt; rethrows, and I think it’s for precisely this reason.<br></p><p>Please trust me when I tell you that that is not the reason.<br></p><p>&gt; On Tue, Jun 7, 2016 at 10:20 AM Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Mon Jun 06 2016, Saagar Jha &lt;saagarjha28-AT-gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; Might I add that leaving an array in an arbitrary and<br>&gt;&gt; &gt; implementation-dependent state is also surprising to users as well as not<br>&gt;&gt; &gt; very useful-to the user this is nothing more than a random permutation.<br>&gt;&gt;<br>&gt;&gt; True, but the cost of being able to restore the original ordering, when<br>&gt;&gt; that restoration may not be needed at all, is prohibitive.  It&#39;s often<br>&gt;&gt; the case that the caller will be throwing away the partially-modified<br>&gt;&gt; original when an error is thrown.<br>&gt;&gt;<br>&gt;&gt; &gt; On Mon, Jun 6, 2016 at 5:31 PM Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; &gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; on Sun Jun 05 2016, Haravikk &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; On 5 Jun 2016, at 19:14, Tim Vermeulen via swift-evolution &lt;<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Most standard library functions that take a closure allow that<br>&gt;&gt; &gt;&gt; &gt;&gt; closure to throw (and those functions are subsequently marked with<br>&gt;&gt; &gt;&gt; &gt;&gt; rethrows). sort and sorted are exceptions to this. I couldn’t find<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; this documented anywhere, but I assume this is because sorting can<br>&gt;&gt; &gt;&gt; &gt;&gt; happen in-place and it would be impossible to restore the array to<br>&gt;&gt; &gt;&gt; &gt;&gt; its original state without giving up performance. Correct me if I’m<br>&gt;&gt; &gt;&gt; &gt;&gt; wrong.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; I’d like to propose that we let sort rethrow anyways, and leave the<br>&gt;&gt; &gt;&gt; &gt;&gt; array in an intermediate state (where the elements are in an<br>&gt;&gt; &gt;&gt; &gt;&gt; arbitrary order) when an error is thrown. As long as this is<br>&gt;&gt; &gt;&gt; &gt;&gt; properly documented, this shouldn’t lead to any confusion. Best of<br>&gt;&gt; &gt;&gt; &gt;&gt; all, it would allow sorted to rethrow as well in which there is no<br>&gt;&gt; &gt;&gt; &gt;&gt; room for confusion at all because it doesn’t mutate any of the<br>&gt;&gt; &gt;&gt; &gt;&gt; user’s variables.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; This sounds reasonable; worst case with in-place sorting is that the<br>&gt;&gt; &gt;&gt; &gt; collection was sorted in one order, and is only partially sorted in a<br>&gt;&gt; &gt;&gt; &gt; new one, but the exception and your handling of it should be able to<br>&gt;&gt; &gt;&gt; &gt; account for this.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; It will require documentation to be clear that sorting methods should<br>&gt;&gt; &gt;&gt; &gt; take care not to leave anything incomplete if a closure throws; most<br>&gt;&gt; &gt;&gt; &gt; algorithms should be fine since they usually just test the closure<br>&gt;&gt; &gt;&gt; &gt; then swap two values afterwards (where necessary) so there’s nothing<br>&gt;&gt; &gt;&gt; &gt; really to interrupt, but anything that uses some kind of buffering may<br>&gt;&gt; &gt;&gt; &gt; need to be redesigned to ensure there’s a fallback to ensure no<br>&gt;&gt; &gt;&gt; &gt; elements are ever lost.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Ensuring that no elements are ever lost is not a particularly useful<br>&gt;&gt; &gt;&gt; goal, and not a constraint to which I would want to hold the standard<br>&gt;&gt; &gt;&gt; library.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; Dave<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
