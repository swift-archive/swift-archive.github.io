<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dc0a379038518c23790a02ec4d17ec1e?s=50"></div><header><strong>Why not rely on existing models?</strong> from <string>Michael Chiu</string> &lt;hatsuneyuji at icloud.com&gt;<p>October 27, 2016 at 03:00:00am</p></header><div class="content"><p>I think a stand alone http parser is still necessary, simply because it is a fundamental building block for most web frameworks nowadays.<br>1. Compatibility <br>I’m not sure about other people, but when I write a web framework I will assume people who use my framework are not necessary have nginx and apache installed. And someone eventually, like I did, will probably want to build a fronted web server as well, in that case, having a standalone will make things a lot easier.<br>2. Reverse-Proxy<br>Some applications are using frontend server such nginx as a reverse-proxy server and proxy over unix domain socket (for example, node.js). In that case, even with a frontend web server, a http parser is still necessary.<br>3. Optimization<br>If someone eventually written a web framework that are subject to use within a private network only, let’s say a computational hub, and somehow they decide to use HTTP, totally rely on frontend server will make a lot of optimization impossible. <br>For example the sendfile() system call. If an application has the ability to generate http header, it can easily optimize the performance of the server when serving file-related-content by using sendfile(), or TCP_CORK + sendfile() in linux, and also a lot of TCP related optimization. This just cannot done by using a frontend server.<br>Michael <br>&gt; Le 26 oct. 2016 à 10:59, Brent Royal-Gordon &lt;brent at architechies.com &lt;https://lists.swift.org/mailman/listinfo/swift-server-dev&gt;&gt; a écrit :<br>&gt; <br>&gt; This trend seems to have started with Rails. It has a few advantages:<br>&gt; <br>&gt; 1. You can use the embedded server in development and testing. This is *way* easier than installing Apache on your development machine or CI setup and configuring it to point to your application.<br></p><p>100% agree with that<br></p><p>&gt; 2. In production, you can configure Apache or nginx to reverse proxy for the app; this configuration is almost entirely agnostic to the application itself, so you can modify the application&#39;s behavior without playing with the frontend web server.<br>&gt; <br>&gt; 3. The frontend proxy and backend web server communicate over a plain old socket, so they can run as different user accounts or even in separate VMs.<br>&gt; <br>&gt; Basically, embedding a web server and reverse proxying for it isolates the application from the frontend server and simplifies the management of both.<br></p><p>I’m not really sure this is a pros or cons. Having to run multiple processes and use sockets increase code complexity and surface for attacks. It increase the number of services started so the number of processes to watch.<br></p><p>In some scenario, this is better, in some others, this is worst.<br></p><p>As I’ve said on my first e-mail, I don’t say standalone swift HTTP server must not exist. I’ve just said it could be interesting to think about others patterns.<br></p><p>Allowing behavior like WSGI where you can use both scenario is IMHO the best solution ever, so it can fit for all needs. <br></p><p>Best regards,<br>Yoann Gini<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-server-dev/attachments/20161027/7910ff20/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a1c0c53e85b99d85108a62b4de8e3067?s=50"></div><header><strong>Why not rely on existing models?</strong> from <string>Yoann Gini</string> &lt;yoann.gini at gmail.com&gt;<p>October 27, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi<br></p><p>&gt; Le 27 oct. 2016 à 11:11, Michael Chiu via swift-server-dev &lt;swift-server-dev at swift.org&gt; a écrit :<br>&gt; <br>&gt; I think a stand alone http parser is still necessary, simply because it is a fundamental building block for most web frameworks nowadays.<br>&gt; 1. Compatibility <br>&gt; I’m not sure about other people, but when I write a web framework I will assume people who use my framework are not necessary have nginx and apache installed. And someone eventually, like I did, will probably want to build a fronted web server as well, in that case, having a standalone will make things a lot easier.<br>That’s why I advocating for a dual scenario like WSGI. In some scenario you want something autonomous.<br>&gt; 2. Reverse-Proxy<br>&gt; Some applications are using frontend server such nginx as a reverse-proxy server and proxy over unix domain socket (for example, node.js). In that case, even with a frontend web server, a http parser is still necessary.<br>From a performance point of view it might be more interesting to avoid reverse proxy behavior and use modules. It avoid increasing the number of open files, the RAM used, etc. I know it’s trendy nowadays to waste resources but swift on the server side can bring new capabilities to software developers and extend server usage on SMB market, for example.<br></p><p>If we can avoid, by design, to waste the few resources SMB has, it could be great.<br>&gt; 3. Optimization<br>&gt; If someone eventually written a web framework that are subject to use within a private network only, let’s say a computational hub, and somehow they decide to use HTTP, totally rely on frontend server will make a lot of optimization impossible. <br>&gt; For example the sendfile() system call. If an application has the ability to generate http header, it can easily optimize the performance of the server when serving file-related-content by using sendfile(), or TCP_CORK + sendfile() in linux, and also a lot of TCP related optimization. This just cannot done by using a frontend server.<br>Pretending to be able to get better static content performance than engines require a lot of self-confidence…<br></p><p>And in all this talk we&#39;re missing one major point of my initial comments: security. New HTTP parser implementation automatically means brand new security breaches and related work to find them and fix them…<br></p><p>Best regards,<br>Yoann Gini<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-server-dev/attachments/20161027/45c27c1d/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
