<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>Proposal: for loops with return values</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>January 14, 2016 at 03:00:00pm</p></header><div class="content"><p>These would be like the unrolled versions of Python’s generator expressions.<br></p><p>Examples:<br></p><p>let a:[Int] = for x in l { yield x*2 }<br></p><p>let b:[(Int,Int)] = for row in 0..&lt;m { for col in 0..&lt;n { yield (row,col) } }<br></p><p>let c:[(Int,Int)] = for row in 0..&lt;m { for col in 0..&lt;n where row+col &lt; 5 { yield (row,col) } }<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: for loops with return values</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 14, 2016 at 03:00:00pm</p></header><div class="content"><p>This has been proposed before and Chris said that it would be out of scope for Swift 3. There is definitely interest in this area though.<br></p><p>Félix<br></p><p>&gt; Le 14 janv. 2016 à 15:30:07, Amir Michail via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; These would be like the unrolled versions of Python’s generator expressions.<br>&gt; <br>&gt; Examples:<br>&gt; <br>&gt; let a:[Int] = for x in l { yield x*2 }<br>&gt; <br>&gt; let b:[(Int,Int)] = for row in 0..&lt;m { for col in 0..&lt;n { yield (row,col) } }<br>&gt; <br>&gt; let c:[(Int,Int)] = for row in 0..&lt;m { for col in 0..&lt;n where row+col &lt; 5 { yield (row,col) } }<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/b25cbfe1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Proposal: for loops with return values</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 15, 2016 at 04:00:00am</p></header><div class="content"><p>I believe this is the same as Scala’s for-comprehension….. and Scala’s for-comprehension is actually just syntactic sugar for a combination of flatMap, map and withFilter.<br></p><p>Although harder to read for many… it likely could be written similarly in Swift.  <br></p><p>i.e. <br></p><p>&gt;&gt; for row in 0..&lt;m { for col in 0..&lt;n where row+col &lt; 5 { yield (row,col) } }<br></p><p>in Scala is<br></p><p>for {<br>   row &lt;- 0 to m <br>   col &lt;- 0 to n<br>   if row+col &lt; 5<br>} yield (row, col)<br></p><p>which is actually (after the compiler is done with it):<br></p><p>(0 to m).flatMap(x =&gt; (0 to n).withFilter(y =&gt; x + y &lt; 5).map(y =&gt; (x, y)))<br></p><p>I have not tried to do it in the playground but I would expect since I believe all the functions are available in Swift.<br></p><p>Note: 0 to m // is a range in Scala<br>	withFilter is a filter which does not copy the contents of what it is filtering…. it is just applying the filter as needed when mapping.<br></p><p><br></p><p><br></p><p><br>&gt; On 2016-01-15, at 3:35:23, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This has been proposed before and Chris said that it would be out of scope for Swift 3. There is definitely interest in this area though.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 14 janv. 2016 à 15:30:07, Amir Michail via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; These would be like the unrolled versions of Python’s generator expressions.<br>&gt;&gt; <br>&gt;&gt; Examples:<br>&gt;&gt; <br>&gt;&gt; let a:[Int] = for x in l { yield x*2 }<br>&gt;&gt; <br>&gt;&gt; let b:[(Int,Int)] = for row in 0..&lt;m { for col in 0..&lt;n { yield (row,col) } }<br>&gt;&gt; <br>&gt;&gt; let c:[(Int,Int)] = for row in 0..&lt;m { for col in 0..&lt;n where row+col &lt; 5 { yield (row,col) } }<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/5eb8dfd5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: for loops with return values</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 14, 2016 at 11:00:00pm</p></header><div class="content"><p>Scala’s for-comprehensions are very powerful, precisely because they are using flatMap etc.<br>This allows using them with other types instead of collections, e.g. asynchronous calls:<br></p><p>func someAsyncCall() -&gt; Future&lt;Int&gt; { … }<br>func someOtherAsyncCall() -&gt; Future&lt;Int&gt; { … }<br></p><p>//  mixing Scala and Swift syntax here...<br>let z: Future&lt;Int&gt; = for {<br>	x &lt;- someAsyncCall()<br>	y &lt;- someOtherAsyncCall()<br>} yield (x + y)<br></p><p>The important thing for this to look nice is that there is no nesting like in your Swift example. Otherwise you get a pyramid of doom (think of more async calls).<br></p><p>Basically it is the same as Haskell’s do notation and you can do powerful things with that like the async example. Another nice example is the abstraction of Bayes’ rules presented in this blog: http://www.randomhacks.net/2007/02/22/bayes-rule-and-drug-tests/<br></p><p>-Thorsten<br></p><p><br>&gt; Am 14.01.2016 um 22:10 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I believe this is the same as Scala’s for-comprehension….. and Scala’s for-comprehension is actually just syntactic sugar for a combination of flatMap, map and withFilter.<br>&gt; <br>&gt; Although harder to read for many… it likely could be written similarly in Swift.  <br>&gt; <br>&gt; i.e. <br>&gt; <br>&gt;&gt;&gt; for row in 0..&lt;m { for col in 0..&lt;n where row+col &lt; 5 { yield (row,col) } }<br>&gt; <br>&gt; in Scala is<br>&gt; <br>&gt; for {<br>&gt;    row &lt;- 0 to m <br>&gt;    col &lt;- 0 to n<br>&gt;    if row+col &lt; 5<br>&gt; } yield (row, col)<br>&gt; <br>&gt; which is actually (after the compiler is done with it):<br>&gt; <br>&gt; (0 to m).flatMap(x =&gt; (0 to n).withFilter(y =&gt; x + y &lt; 5).map(y =&gt; (x, y)))<br>&gt; <br>&gt; I have not tried to do it in the playground but I would expect since I believe all the functions are available in Swift.<br>&gt; <br>&gt; Note: 0 to m // is a range in Scala<br>&gt; 	withFilter is a filter which does not copy the contents of what it is filtering…. it is just applying the filter as needed when mapping.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 2016-01-15, at 3:35:23, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This has been proposed before and Chris said that it would be out of scope for Swift 3. There is definitely interest in this area though.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 14 janv. 2016 à 15:30:07, Amir Michail via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These would be like the unrolled versions of Python’s generator expressions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Examples:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a:[Int] = for x in l { yield x*2 }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let b:[(Int,Int)] = for row in 0..&lt;m { for col in 0..&lt;n { yield (row,col) } }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let c:[(Int,Int)] = for row in 0..&lt;m { for col in 0..&lt;n where row+col &lt; 5 { yield (row,col) } }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/89fcec7d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Proposal: for loops with return values</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 19, 2016 at 07:00:00pm</p></header><div class="content"><p>What is the most readable/concise (balance) for writing something like the following in swift:<br></p><p>val host: Option[String] = Some(&quot;host&quot;)<br>val port: Option[Int] = Some(80)<br>val addr = for {<br>  h &lt;- host<br>  p &lt;- port<br>} yield new InetSocketAddress(h, p)<br></p><p>i.e. If either of the optionals is None then the result will be None otherwise it will be Some(inetSocketAddress).<br></p><p><br>&gt; On 2016-01-15, at 5:57:33, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; Scala’s for-comprehensions are very powerful, precisely because they are using flatMap etc.<br>&gt; This allows using them with other types instead of collections, e.g. asynchronous calls:<br>&gt; <br>&gt; func someAsyncCall() -&gt; Future&lt;Int&gt; { … }<br>&gt; func someOtherAsyncCall() -&gt; Future&lt;Int&gt; { … }<br>&gt; <br>&gt; //  mixing Scala and Swift syntax here...<br>&gt; let z: Future&lt;Int&gt; = for {<br>&gt; 	x &lt;- someAsyncCall()<br>&gt; 	y &lt;- someOtherAsyncCall()<br>&gt; } yield (x + y)<br>&gt; <br>&gt; The important thing for this to look nice is that there is no nesting like in your Swift example. Otherwise you get a pyramid of doom (think of more async calls).<br>&gt; <br>&gt; Basically it is the same as Haskell’s do notation and you can do powerful things with that like the async example. Another nice example is the abstraction of Bayes’ rules presented in this blog: http://www.randomhacks.net/2007/02/22/bayes-rule-and-drug-tests/ &lt;http://www.randomhacks.net/2007/02/22/bayes-rule-and-drug-tests/&gt;<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; Am 14.01.2016 um 22:10 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; I believe this is the same as Scala’s for-comprehension….. and Scala’s for-comprehension is actually just syntactic sugar for a combination of flatMap, map and withFilter.<br>&gt;&gt; <br>&gt;&gt; Although harder to read for many… it likely could be written similarly in Swift.  <br>&gt;&gt; <br>&gt;&gt; i.e. <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; for row in 0..&lt;m { for col in 0..&lt;n where row+col &lt; 5 { yield (row,col) } }<br>&gt;&gt; <br>&gt;&gt; in Scala is<br>&gt;&gt; <br>&gt;&gt; for {<br>&gt;&gt;    row &lt;- 0 to m <br>&gt;&gt;    col &lt;- 0 to n<br>&gt;&gt;    if row+col &lt; 5<br>&gt;&gt; } yield (row, col)<br>&gt;&gt; <br>&gt;&gt; which is actually (after the compiler is done with it):<br>&gt;&gt; <br>&gt;&gt; (0 to m).flatMap(x =&gt; (0 to n).withFilter(y =&gt; x + y &lt; 5).map(y =&gt; (x, y)))<br>&gt;&gt; <br>&gt;&gt; I have not tried to do it in the playground but I would expect since I believe all the functions are available in Swift.<br>&gt;&gt; <br>&gt;&gt; Note: 0 to m // is a range in Scala<br>&gt;&gt; 	withFilter is a filter which does not copy the contents of what it is filtering…. it is just applying the filter as needed when mapping.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 2016-01-15, at 3:35:23, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This has been proposed before and Chris said that it would be out of scope for Swift 3. There is definitely interest in this area though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 14 janv. 2016 à 15:30:07, Amir Michail via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; These would be like the unrolled versions of Python’s generator expressions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Examples:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let a:[Int] = for x in l { yield x*2 }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let b:[(Int,Int)] = for row in 0..&lt;m { for col in 0..&lt;n { yield (row,col) } }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let c:[(Int,Int)] = for row in 0..&lt;m { for col in 0..&lt;n where row+col &lt; 5 { yield (row,col) } }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/0e0b3182/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>Proposal: for loops with return values</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>January 19, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 7:26 AM, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; What is the most readable/concise (balance) for writing something like the following in swift:<br>&gt; <br>&gt; val host: Option[String] = Some(&quot;host&quot;)<br>&gt; val port: Option[Int] = Some(80)<br>&gt; val addr = for {<br>&gt;   h &lt;- host<br>&gt;   p &lt;- port<br>&gt; } yield new InetSocketAddress(h, p)<br></p><p>Wouldn’t “let/val { ...” be better than “for { ...” in this context?<br></p><p>&gt; <br>&gt; i.e. If either of the optionals is None then the result will be None otherwise it will be Some(inetSocketAddress).<br>&gt; <br>&gt; <br>&gt;&gt; On 2016-01-15, at 5:57:33, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Scala’s for-comprehensions are very powerful, precisely because they are using flatMap etc.<br>&gt;&gt; This allows using them with other types instead of collections, e.g. asynchronous calls:<br>&gt;&gt; <br>&gt;&gt; func someAsyncCall() -&gt; Future&lt;Int&gt; { … }<br>&gt;&gt; func someOtherAsyncCall() -&gt; Future&lt;Int&gt; { … }<br>&gt;&gt; <br>&gt;&gt; //  mixing Scala and Swift syntax here...<br>&gt;&gt; let z: Future&lt;Int&gt; = for {<br>&gt;&gt; 	x &lt;- someAsyncCall()<br>&gt;&gt; 	y &lt;- someOtherAsyncCall()<br>&gt;&gt; } yield (x + y)<br>&gt;&gt; <br>&gt;&gt; The important thing for this to look nice is that there is no nesting like in your Swift example. Otherwise you get a pyramid of doom (think of more async calls).<br>&gt;&gt; <br>&gt;&gt; Basically it is the same as Haskell’s do notation and you can do powerful things with that like the async example. Another nice example is the abstraction of Bayes’ rules presented in this blog: http://www.randomhacks.net/2007/02/22/bayes-rule-and-drug-tests/ &lt;http://www.randomhacks.net/2007/02/22/bayes-rule-and-drug-tests/&gt;<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 14.01.2016 um 22:10 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe this is the same as Scala’s for-comprehension….. and Scala’s for-comprehension is actually just syntactic sugar for a combination of flatMap, map and withFilter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Although harder to read for many… it likely could be written similarly in Swift.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; i.e. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; for row in 0..&lt;m { for col in 0..&lt;n where row+col &lt; 5 { yield (row,col) } }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; in Scala is<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for {<br>&gt;&gt;&gt;    row &lt;- 0 to m <br>&gt;&gt;&gt;    col &lt;- 0 to n<br>&gt;&gt;&gt;    if row+col &lt; 5<br>&gt;&gt;&gt; } yield (row, col)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which is actually (after the compiler is done with it):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (0 to m).flatMap(x =&gt; (0 to n).withFilter(y =&gt; x + y &lt; 5).map(y =&gt; (x, y)))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have not tried to do it in the playground but I would expect since I believe all the functions are available in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note: 0 to m // is a range in Scala<br>&gt;&gt;&gt; 	withFilter is a filter which does not copy the contents of what it is filtering…. it is just applying the filter as needed when mapping.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 2016-01-15, at 3:35:23, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This has been proposed before and Chris said that it would be out of scope for Swift 3. There is definitely interest in this area though.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 14 janv. 2016 à 15:30:07, Amir Michail via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; These would be like the unrolled versions of Python’s generator expressions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Examples:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let a:[Int] = for x in l { yield x*2 }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let b:[(Int,Int)] = for row in 0..&lt;m { for col in 0..&lt;n { yield (row,col) } }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let c:[(Int,Int)] = for row in 0..&lt;m { for col in 0..&lt;n where row+col &lt; 5 { yield (row,col) } }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/2a866be0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Proposal: for loops with return values</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 19, 2016 at 09:00:00pm</p></header><div class="content"><p>I don’t know - the syntax you gave me won’t run in the playground…..<br></p><p>the for-comprehension aka “list comprehension” (or in this case optional comprehension) is from Scala.<br></p><p>I was wondering if there was an easy way to state the same with optionals in Swift.<br></p><p>I hesitate to paste in my solution since there is likely a more reasonable way to chain optionals that would effectively do the same as for-comprehension of optionals in Scala (different language, different ways of approaching things).<br></p><p><br></p><p><br>&gt; On 2016-01-19, at 21:20:21, Amir Michail &lt;a.michail at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 19, 2016, at 7:26 AM, Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What is the most readable/concise (balance) for writing something like the following in swift:<br>&gt;&gt; <br>&gt;&gt; val host: Option[String] = Some(&quot;host&quot;)<br>&gt;&gt; val port: Option[Int] = Some(80)<br>&gt;&gt; val addr = for {<br>&gt;&gt;   h &lt;- host<br>&gt;&gt;   p &lt;- port<br>&gt;&gt; } yield new InetSocketAddress(h, p)<br>&gt; <br>&gt; Wouldn’t “let/val { ...” be better than “for { ...” in this context?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; i.e. If either of the optionals is None then the result will be None otherwise it will be Some(inetSocketAddress).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 2016-01-15, at 5:57:33, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Scala’s for-comprehensions are very powerful, precisely because they are using flatMap etc.<br>&gt;&gt;&gt; This allows using them with other types instead of collections, e.g. asynchronous calls:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func someAsyncCall() -&gt; Future&lt;Int&gt; { … }<br>&gt;&gt;&gt; func someOtherAsyncCall() -&gt; Future&lt;Int&gt; { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //  mixing Scala and Swift syntax here...<br>&gt;&gt;&gt; let z: Future&lt;Int&gt; = for {<br>&gt;&gt;&gt; 	x &lt;- someAsyncCall()<br>&gt;&gt;&gt; 	y &lt;- someOtherAsyncCall()<br>&gt;&gt;&gt; } yield (x + y)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The important thing for this to look nice is that there is no nesting like in your Swift example. Otherwise you get a pyramid of doom (think of more async calls).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Basically it is the same as Haskell’s do notation and you can do powerful things with that like the async example. Another nice example is the abstraction of Bayes’ rules presented in this blog: http://www.randomhacks.net/2007/02/22/bayes-rule-and-drug-tests/ &lt;http://www.randomhacks.net/2007/02/22/bayes-rule-and-drug-tests/&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 14.01.2016 um 22:10 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I believe this is the same as Scala’s for-comprehension….. and Scala’s for-comprehension is actually just syntactic sugar for a combination of flatMap, map and withFilter.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Although harder to read for many… it likely could be written similarly in Swift.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; i.e. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; for row in 0..&lt;m { for col in 0..&lt;n where row+col &lt; 5 { yield (row,col) } }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; in Scala is<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; for {<br>&gt;&gt;&gt;&gt;    row &lt;- 0 to m <br>&gt;&gt;&gt;&gt;    col &lt;- 0 to n<br>&gt;&gt;&gt;&gt;    if row+col &lt; 5<br>&gt;&gt;&gt;&gt; } yield (row, col)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which is actually (after the compiler is done with it):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (0 to m).flatMap(x =&gt; (0 to n).withFilter(y =&gt; x + y &lt; 5).map(y =&gt; (x, y)))<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have not tried to do it in the playground but I would expect since I believe all the functions are available in Swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note: 0 to m // is a range in Scala<br>&gt;&gt;&gt;&gt; 	withFilter is a filter which does not copy the contents of what it is filtering…. it is just applying the filter as needed when mapping.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 2016-01-15, at 3:35:23, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This has been proposed before and Chris said that it would be out of scope for Swift 3. There is definitely interest in this area though.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 14 janv. 2016 à 15:30:07, Amir Michail via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; These would be like the unrolled versions of Python’s generator expressions.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Examples:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let a:[Int] = for x in l { yield x*2 }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let b:[(Int,Int)] = for row in 0..&lt;m { for col in 0..&lt;n { yield (row,col) } }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let c:[(Int,Int)] = for row in 0..&lt;m { for col in 0..&lt;n where row+col &lt; 5 { yield (row,col) } }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/37a32e4b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Proposal: for loops with return values</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 19, 2016 at 10:00:00pm</p></header><div class="content"><p>i.e. the Swift way of doing things that comes to mind (equivalent) would be:<br></p><p>let host: String? = “host”<br>let port: Int? = “80”<br></p><p>let inetAddress = InetSocketAddress?<br>if let host = host, port = port {<br>  inetAddress = InetSocketAddress(host, port)<br>}<br>else {<br>  inetAddress = nil<br>}<br></p><p>Just wondering if there was a cleaner way - because to me that just looks ugly.<br></p><p>(or the map/flatmap route which would probably not be immediately understandable to some)<br></p><p><br>&gt; On 2016-01-19, at 21:20:21, Amir Michail &lt;a.michail at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 19, 2016, at 7:26 AM, Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What is the most readable/concise (balance) for writing something like the following in swift:<br>&gt;&gt; <br>&gt;&gt; val host: Option[String] = Some(&quot;host&quot;)<br>&gt;&gt; val port: Option[Int] = Some(80)<br>&gt;&gt; val addr = for {<br>&gt;&gt;   h &lt;- host<br>&gt;&gt;   p &lt;- port<br>&gt;&gt; } yield new InetSocketAddress(h, p)<br>&gt; <br>&gt; Wouldn’t “let/val { ...” be better than “for { ...” in this context?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; i.e. If either of the optionals is None then the result will be None otherwise it will be Some(inetSocketAddress).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 2016-01-15, at 5:57:33, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Scala’s for-comprehensions are very powerful, precisely because they are using flatMap etc.<br>&gt;&gt;&gt; This allows using them with other types instead of collections, e.g. asynchronous calls:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func someAsyncCall() -&gt; Future&lt;Int&gt; { … }<br>&gt;&gt;&gt; func someOtherAsyncCall() -&gt; Future&lt;Int&gt; { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //  mixing Scala and Swift syntax here...<br>&gt;&gt;&gt; let z: Future&lt;Int&gt; = for {<br>&gt;&gt;&gt; 	x &lt;- someAsyncCall()<br>&gt;&gt;&gt; 	y &lt;- someOtherAsyncCall()<br>&gt;&gt;&gt; } yield (x + y)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The important thing for this to look nice is that there is no nesting like in your Swift example. Otherwise you get a pyramid of doom (think of more async calls).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Basically it is the same as Haskell’s do notation and you can do powerful things with that like the async example. Another nice example is the abstraction of Bayes’ rules presented in this blog: http://www.randomhacks.net/2007/02/22/bayes-rule-and-drug-tests/ &lt;http://www.randomhacks.net/2007/02/22/bayes-rule-and-drug-tests/&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 14.01.2016 um 22:10 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I believe this is the same as Scala’s for-comprehension….. and Scala’s for-comprehension is actually just syntactic sugar for a combination of flatMap, map and withFilter.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Although harder to read for many… it likely could be written similarly in Swift.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; i.e. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; for row in 0..&lt;m { for col in 0..&lt;n where row+col &lt; 5 { yield (row,col) } }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; in Scala is<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; for {<br>&gt;&gt;&gt;&gt;    row &lt;- 0 to m <br>&gt;&gt;&gt;&gt;    col &lt;- 0 to n<br>&gt;&gt;&gt;&gt;    if row+col &lt; 5<br>&gt;&gt;&gt;&gt; } yield (row, col)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which is actually (after the compiler is done with it):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (0 to m).flatMap(x =&gt; (0 to n).withFilter(y =&gt; x + y &lt; 5).map(y =&gt; (x, y)))<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have not tried to do it in the playground but I would expect since I believe all the functions are available in Swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note: 0 to m // is a range in Scala<br>&gt;&gt;&gt;&gt; 	withFilter is a filter which does not copy the contents of what it is filtering…. it is just applying the filter as needed when mapping.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 2016-01-15, at 3:35:23, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This has been proposed before and Chris said that it would be out of scope for Swift 3. There is definitely interest in this area though.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 14 janv. 2016 à 15:30:07, Amir Michail via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; These would be like the unrolled versions of Python’s generator expressions.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Examples:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let a:[Int] = for x in l { yield x*2 }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let b:[(Int,Int)] = for row in 0..&lt;m { for col in 0..&lt;n { yield (row,col) } }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let c:[(Int,Int)] = for row in 0..&lt;m { for col in 0..&lt;n where row+col &lt; 5 { yield (row,col) } }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/0fbc0667/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad660220aa12f25c1c91339846be5bb2?s=50"></div><header><strong>Proposal: for loops with return values</strong> from <string>Jim Dovey</string> &lt;jimdovey at apple.com&gt;<p>January 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 7:08 AM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; i.e. the Swift way of doing things that comes to mind (equivalent) would be:<br>&gt; <br>&gt; let host: String? = “host”<br>&gt; let port: Int? = “80”<br>&gt; <br>&gt; let inetAddress = InetSocketAddress?<br>&gt; if let host = host, port = port {<br>&gt;   inetAddress = InetSocketAddress(host, port)<br>&gt; }<br>&gt; else {<br>&gt;   inetAddress = nil<br>&gt; }<br>&gt; <br>&gt; Just wondering if there was a cleaner way - because to me that just looks ugly.<br></p><p>You can always wrap it in a (nicely inline-able) function for cleanliness:<br></p><p>func makeAddr(host: String?, port: Int?) -&gt; InetSocketAddress? {<br>	guard let h = host, p = port else { return nil }<br>	return InetSocketAddress(host: h, port: p)<br>}<br></p><p>// … somewhere else …<br>let host: String? = getHost()<br>let port: Int? = getPort()<br></p><p>guard let inetAddress = makeAddr(host, port) else { throw SocketError(EADDR) }<br></p><p>Cheers,<br>-Jim<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/a4d1f682/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
