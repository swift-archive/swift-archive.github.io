<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/743ea9b8e49fa6a8390b2f4b3e1a588f?s=50"></div><header><strong>[Proposal] Built-in &quot;bridge&quot; feature</strong> from <string>Jerome ALVES</string> &lt;j.alves at me.com&gt;<p>January 21, 2016 at 12:00:00am</p></header><div class="content"><p>Hi everyone,<br></p><p>This is my first message on the mailing list and I hope I&#39;ll do everything right :)<br>I&#39;ve been through the mailing-list archive and I didn&#39;t see anything close to this proposal so I hope I didn&#39;t miss anything.<br>Introduction<br></p><p>Sometimes, there are several ways to represent the same thing. For instance NSURL and NSURLComponents are both used to deal with URLs, but according to the API you want to use you must have to make manual conversions from one type to another. My proposal is to add a built-in bridge feature into the Swift language to remove a lot of boilerplate code and increase readability.<br>Motivation<br></p><p>1. It&#39;s a really convenient pattern <br></p><p>Swift has several great solutions for types. Structs, Enums, and Protocols can do as much as Classes. You can define properties, methods, subscripts, you can extend them, etc.. This allowed developers to use some types where they weren&#39;t expected. For instance we can use an enum AppColors to define all colors used by an app, and as an enum can have properties, we can add a var color: UIColor on it to generate the associate UIColor (or NSColor)<br></p><p>Its really convenient but wherever we want to use this color, we need to call the .color property :<br>myLabel.textColor = AppColors.PrimaryLabelTextColor.color<br></p><p>We can also have a protocol ColorConvertible defined like this to simplify things :<br>protocol ColorConvertible {<br>  var color: UIColor { get }<br>}<br></p><p>Let&#39;s take a more concrete example with the open source library Alamofire (https://github.com/Alamofire/Alamofire).<br>Alamofire makes an extensive usage of this pattern to convert different types into a &quot;NSURL-compatible&quot; String or a NSURLRequest object.<br></p><p>Then the Alamofire API use only those URLStringConvertible and URLRequestConvertible protocols as method inputs.<br></p><p>It&#39;s great because at the right moment where you use the Alamofire API, no matter if you currently use a NSURL or a NSURLComponent, you can pass both as argument to the Alamofire function.<br></p><p>Moreover, you may want to use a custom type to build your URLs and validate them. This allows you to add some safety because you can use strong-typed enums as path components instead of error-prone strings.<br>And here is where this pattern is convenient : you can make your custom type (which could be a class, a struct or an enum) conforming to URLStringConvertible and use it directly as Alamofire API functions input.<br></p><p>But this is sadly limited for Alamofire API. What about all other frameworks which only take NSURL as input ?<br></p><p>Using protocols for this is counterintuitive :<br>	– protocols are especially thought to don&#39;t have to deal with a particular type right ? But what we do here ? We use it only to convert the receiver into the desired type. After the conversion, the original receiver is not even used anymore because we can do nothing with it except convert it.<br></p><p>	– we already can see different way to write these conversions,  : <br>		- var URLString: String { get }  arbitrary var name pattern<br>		- var integerValue: Int { get }  _Value var name pattern (like in NSNumber)<br>		- func toColor() -&gt; UIColor  to_() func name pattern <br></p><p>	– everytime we want to have a type conversion we need te create the associated protocol but it won&#39;t be compatible with third party libraries unless by manually write forwarding methods...<br></p><p><br>2. Swift language already makes convenient bridges between some Obj-C types and theirs Swift counterparts<br></p><p>I didn&#39;t take the time to see how it&#39;s currently implemented right now, but we already have bridging. For instance this code is valid without doing anything : <br></p><p>func doSomethingWithNumber(number: NSNumber) {<br>  //...<br>}<br></p><p>let integer: Int = 42<br>doSomethingWithNumber(integer)<br> <br>Proposed solution<br></p><p>The cleanest way I see to add this feature is by having a new bridge keyword. A bridge could be implemented either into the type implementation scope or in an extension. Bridges can also be a protocol requirement and even have a default implementation thanks to protocol extensions. In fact, bridge keyword can be used in same places than the subscript keyword.<br></p><p>Here is what it could look like for the above NSURL example (note how the bridge could return an optional if needed) :<br></p><p>extension String {<br>  bridge NSURL? {<br>    return NSURL(string: self)<br>  }<br>  <br>  bridge NSURLComponents? {<br>    return NSURLComponents(string: self)<br>  }<br>}<br></p><p>extension NSURLComponents {<br>  bridge NSURL? {<br>    return self.URL<br>  }<br>}<br></p><p>Now this is how Swift-to-Foundation bridge could be implemented with this new syntax : <br></p><p>extension NSNumber {<br>  bridge Int {<br>    return self.integerValue<br>  }<br>}<br></p><p>extension Int {<br>  bridge NSNumber {<br>    return NSNumber(integerValue: self)<br>  }<br>}<br></p><p>Then, as soon a bridge is defined from a type A to a type B, anywhere an API expects to have a type B, we could pass a type A instead :<br></p><p>enum AppColors {<br>  case PrimaryTextColor<br>  case SecondaryTextColor<br>  <br>  bridge UIColor {<br>    switch self {<br>    case .PrimaryTextColor:<br>      return UIColor.blackColor()<br>    case .SecondaryTextColor:<br>      return UIColor.grayColor()<br>    }<br>  }<br>}<br></p><p>...<br></p><p>let cell = UITableViewCell(style: .Value1, reuseIdentifier: &quot;MyCell&quot;)<br>cell.textLabel?.textColor = .PrimaryTextColor<br>cell.detailTextLabel?.textColor = .SecondaryTextColor<br></p><p>We could also imagine that bridges support error throwing : <br></p><p>extension String {<br>  enum ColorBridgeError: ErrorType {<br>    case ColorNameNotSupported<br>  }<br>  bridge throws UIColor {<br>    switch self {<br>    case &quot;red&quot;:<br>      return UIColor.redColor()<br>    case &quot;blue&quot;:<br>      return UIColor.blueColor()<br>    default:<br>      throw ColorBridgeError.ColorNameNotSupported<br>    }<br>  }<br>}<br></p><p>...<br></p><p>do {<br>  cell.textLabel?.textColor = try self.colorNameTextField.text<br>  self.errorLabel.text = nil<br>}<br>catch String.ColorBridgeError.ColorNameNotSupported {<br>  self.errorLabel.text = &quot;This color name is invalid :(&quot;<br>}<br></p><p>This implementation is of course one of many implementations possible and I&#39;m really open to suggestions. For instance I already can see one trade-off of this implementation : for the String -&gt; NSURL? bridge, why NSURL(string: self) would be chosen over NSURL(fileURLWithPath: self) ? <br></p><p>We could also image than bridge are &quot;chainable&quot; (but maybe it could affect compilation times ?). For instance <br></p><p>extension A {<br>  bridge B {<br>    return B(withA: self)<br>  }<br>}<br></p><p>extension B {<br>  bridge C {<br>    return C(withB: self)<br>  }<br>}<br></p><p>func doSomethingWithC(anyC: C) {<br>  //...<br>}<br></p><p>let a = A()<br>doSomethingWithC(a) // Compiler could implicitly bridge `a` to type `B`, then bridge the result to type `C`<br></p><p>But this is optional for the feature, we could imagine to explicitly need to implement a bridge from A to C.<br></p><p><br></p><p><br>Well, I think that&#39;s all for now. I hope it was not too long to read and it was well explained. I&#39;m of course open to all suggestions, questions, enhancements, etc...<br></p><p>I would also be happy to have technical details about possible implementations as I&#39;m not an expert at all in compiler design. I really don&#39;t know how this feature could affect the compiler and any insight here will be welcome.<br></p><p>Thanks for reading.<br></p><p>Cheers,<br></p><p>Jérôme Alves<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/0c610270/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Built-in &quot;bridge&quot; feature</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 20, 2016 at 03:00:00pm</p></header><div class="content"><p>I could be wrong, but I believe that implicit type conversion, in general, causes problems (which is why ImplicitlyUnwrappedOptionals are handled with “compiler magic” as opposed to a general language feature). How would you feel about reusing the as keyword?<br>let a = A()<br>doSomethingWithC(a as C) // Compiler could check if there are explicit bridging functions, and fallback to as’s current meaning if not<br></p><p>Either way, though, I’d love a short-hand way to convert between types.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 20, 2016, at 15:27, Jerome ALVES via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; This is my first message on the mailing list and I hope I&#39;ll do everything right :)<br>&gt; I&#39;ve been through the mailing-list archive and I didn&#39;t see anything close to this proposal so I hope I didn&#39;t miss anything.<br>&gt; Introduction<br>&gt; <br>&gt; Sometimes, there are several ways to represent the same thing. For instance NSURL and NSURLComponents are both used to deal with URLs, but according to the API you want to use you must have to make manual conversions from one type to another. My proposal is to add a built-in bridge feature into the Swift language to remove a lot of boilerplate code and increase readability.<br>&gt; Motivation<br>&gt; <br>&gt; 1. It&#39;s a really convenient pattern <br>&gt; <br>&gt; Swift has several great solutions for types. Structs, Enums, and Protocols can do as much as Classes. You can define properties, methods, subscripts, you can extend them, etc.. This allowed developers to use some types where they weren&#39;t expected. For instance we can use an enum AppColors to define all colors used by an app, and as an enum can have properties, we can add a var color: UIColor on it to generate the associate UIColor (or NSColor)<br>&gt; <br>&gt; Its really convenient but wherever we want to use this color, we need to call the .color property :<br>&gt; myLabel.textColor = AppColors.PrimaryLabelTextColor.color<br>&gt; <br>&gt; We can also have a protocol ColorConvertible defined like this to simplify things :<br>&gt; protocol ColorConvertible {<br>&gt;   var color: UIColor { get }<br>&gt; }<br>&gt; <br>&gt; Let&#39;s take a more concrete example with the open source library Alamofire (https://github.com/Alamofire/Alamofire &lt;https://github.com/Alamofire/Alamofire&gt;).<br>&gt; Alamofire makes an extensive usage of this pattern to convert different types into a &quot;NSURL-compatible&quot; String or a NSURLRequest object.<br>&gt; <br>&gt; Then the Alamofire API use only those URLStringConvertible and URLRequestConvertible protocols as method inputs.<br>&gt; <br>&gt; It&#39;s great because at the right moment where you use the Alamofire API, no matter if you currently use a NSURL or a NSURLComponent, you can pass both as argument to the Alamofire function.<br>&gt; <br>&gt; Moreover, you may want to use a custom type to build your URLs and validate them. This allows you to add some safety because you can use strong-typed enums as path components instead of error-prone strings.<br>&gt; And here is where this pattern is convenient : you can make your custom type (which could be a class, a struct or an enum) conforming to URLStringConvertible and use it directly as Alamofire API functions input.<br>&gt; <br>&gt; But this is sadly limited for Alamofire API. What about all other frameworks which only take NSURL as input ?<br>&gt; <br>&gt; Using protocols for this is counterintuitive :<br>&gt; 	– protocols are especially thought to don&#39;t have to deal with a particular type right ? But what we do here ? We use it only to convert the receiver into the desired type. After the conversion, the original receiver is not even used anymore because we can do nothing with it except convert it.<br>&gt; <br>&gt; 	– we already can see different way to write these conversions,  : <br>&gt; 		- var URLString: String { get }  arbitrary var name pattern<br>&gt; 		- var integerValue: Int { get }  _Value var name pattern (like in NSNumber)<br>&gt; 		- func toColor() -&gt; UIColor  to_() func name pattern <br>&gt; <br>&gt; 	– everytime we want to have a type conversion we need te create the associated protocol but it won&#39;t be compatible with third party libraries unless by manually write forwarding methods...<br>&gt; <br>&gt; <br>&gt; 2. Swift language already makes convenient bridges between some Obj-C types and theirs Swift counterparts<br>&gt; <br>&gt; I didn&#39;t take the time to see how it&#39;s currently implemented right now, but we already have bridging. For instance this code is valid without doing anything : <br>&gt; <br>&gt; func doSomethingWithNumber(number: NSNumber) {<br>&gt;   //...<br>&gt; }<br>&gt; <br>&gt; let integer: Int = 42<br>&gt; doSomethingWithNumber(integer)<br>&gt;  <br>&gt; Proposed solution<br>&gt; <br>&gt; The cleanest way I see to add this feature is by having a new bridge keyword. A bridge could be implemented either into the type implementation scope or in an extension. Bridges can also be a protocol requirement and even have a default implementation thanks to protocol extensions. In fact, bridge keyword can be used in same places than the subscript keyword.<br>&gt; <br>&gt; Here is what it could look like for the above NSURL example (note how the bridge could return an optional if needed) :<br>&gt; <br>&gt; extension String {<br>&gt;   bridge NSURL? {<br>&gt;     return NSURL(string: self)<br>&gt;   }<br>&gt;   <br>&gt;   bridge NSURLComponents? {<br>&gt;     return NSURLComponents(string: self)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; extension NSURLComponents {<br>&gt;   bridge NSURL? {<br>&gt;     return self.URL<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Now this is how Swift-to-Foundation bridge could be implemented with this new syntax : <br>&gt; <br>&gt; extension NSNumber {<br>&gt;   bridge Int {<br>&gt;     return self.integerValue<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; extension Int {<br>&gt;   bridge NSNumber {<br>&gt;     return NSNumber(integerValue: self)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Then, as soon a bridge is defined from a type A to a type B, anywhere an API expects to have a type B, we could pass a type A instead :<br>&gt; <br>&gt; enum AppColors {<br>&gt;   case PrimaryTextColor<br>&gt;   case SecondaryTextColor<br>&gt;   <br>&gt;   bridge UIColor {<br>&gt;     switch self {<br>&gt;     case .PrimaryTextColor:<br>&gt;       return UIColor.blackColor()<br>&gt;     case .SecondaryTextColor:<br>&gt;       return UIColor.grayColor()<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; ...<br>&gt; <br>&gt; let cell = UITableViewCell(style: .Value1, reuseIdentifier: &quot;MyCell&quot;)<br>&gt; cell.textLabel?.textColor = .PrimaryTextColor<br>&gt; cell.detailTextLabel?.textColor = .SecondaryTextColor<br>&gt; <br>&gt; We could also imagine that bridges support error throwing : <br>&gt; <br>&gt; extension String {<br>&gt;   enum ColorBridgeError: ErrorType {<br>&gt;     case ColorNameNotSupported<br>&gt;   }<br>&gt;   bridge throws UIColor {<br>&gt;     switch self {<br>&gt;     case &quot;red&quot;:<br>&gt;       return UIColor.redColor()<br>&gt;     case &quot;blue&quot;:<br>&gt;       return UIColor.blueColor()<br>&gt;     default:<br>&gt;       throw ColorBridgeError.ColorNameNotSupported<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; ...<br>&gt; <br>&gt; do {<br>&gt;   cell.textLabel?.textColor = try self.colorNameTextField.text<br>&gt;   self.errorLabel.text = nil<br>&gt; }<br>&gt; catch String.ColorBridgeError.ColorNameNotSupported {<br>&gt;   self.errorLabel.text = &quot;This color name is invalid :(&quot;<br>&gt; }<br>&gt; <br>&gt; This implementation is of course one of many implementations possible and I&#39;m really open to suggestions. For instance I already can see one trade-off of this implementation : for the String -&gt; NSURL? bridge, why NSURL(string: self) would be chosen over NSURL(fileURLWithPath: self) ? <br>&gt; <br>&gt; We could also image than bridge are &quot;chainable&quot; (but maybe it could affect compilation times ?). For instance <br>&gt; <br>&gt; extension A {<br>&gt;   bridge B {<br>&gt;     return B(withA: self)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; extension B {<br>&gt;   bridge C {<br>&gt;     return C(withB: self)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; func doSomethingWithC(anyC: C) {<br>&gt;   //...<br>&gt; }<br>&gt; <br>&gt; let a = A()<br>&gt; doSomethingWithC(a) // Compiler could implicitly bridge `a` to type `B`, then bridge the result to type `C`<br>&gt; <br>&gt; But this is optional for the feature, we could imagine to explicitly need to implement a bridge from A to C.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Well, I think that&#39;s all for now. I hope it was not too long to read and it was well explained. I&#39;m of course open to all suggestions, questions, enhancements, etc...<br>&gt; <br>&gt; I would also be happy to have technical details about possible implementations as I&#39;m not an expert at all in compiler design. I really don&#39;t know how this feature could affect the compiler and any insight here will be welcome.<br>&gt; <br>&gt; Thanks for reading.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Jérôme Alves<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/57da393b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/743ea9b8e49fa6a8390b2f4b3e1a588f?s=50"></div><header><strong>[Proposal] Built-in &quot;bridge&quot; feature</strong> from <string>Jerome ALVES</string> &lt;j.alves at me.com&gt;<p>January 21, 2016 at 12:00:00am</p></header><div class="content"><p>I&#39;m not sure, do you suggest to always use the &quot;as&quot; keyword, or only in case where we want to move from &quot;A&quot; to &quot;C&quot; passing by &quot;B&quot; ?<br></p><p>In fact,I feel right about always needing to use the &quot;as&quot; keyword. It&#39;s true that this kind of feature could be too magical and cause some issues. Having to explicitly cast to bridged type could be a good compromise between readability and safety.<br></p><p><br>&gt; Le 21 janv. 2016 à 00:37, davesweeris at mac.com a écrit :<br>&gt; <br>&gt; I could be wrong, but I believe that implicit type conversion, in general, causes problems (which is why ImplicitlyUnwrappedOptionals are handled with “compiler magic” as opposed to a general language feature). How would you feel about reusing the as keyword?<br>&gt; let a = A()<br>&gt; doSomethingWithC(a as C) // Compiler could check if there are explicit bridging functions, and fallback to as’s current meaning if not<br>&gt; <br>&gt; Either way, though, I’d love a short-hand way to convert between types.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 15:27, Jerome ALVES via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi everyone,<br>&gt;&gt; <br>&gt;&gt; This is my first message on the mailing list and I hope I&#39;ll do everything right :)<br>&gt;&gt; I&#39;ve been through the mailing-list archive and I didn&#39;t see anything close to this proposal so I hope I didn&#39;t miss anything.<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Sometimes, there are several ways to represent the same thing. For instance NSURL and NSURLComponents are both used to deal with URLs, but according to the API you want to use you must have to make manual conversions from one type to another. My proposal is to add a built-in bridge feature into the Swift language to remove a lot of boilerplate code and increase readability.<br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; 1. It&#39;s a really convenient pattern <br>&gt;&gt; <br>&gt;&gt; Swift has several great solutions for types. Structs, Enums, and Protocols can do as much as Classes. You can define properties, methods, subscripts, you can extend them, etc.. This allowed developers to use some types where they weren&#39;t expected. For instance we can use an enum AppColors to define all colors used by an app, and as an enum can have properties, we can add a var color: UIColor on it to generate the associate UIColor (or NSColor)<br>&gt;&gt; <br>&gt;&gt; Its really convenient but wherever we want to use this color, we need to call the .color property :<br>&gt;&gt; myLabel.textColor = AppColors.PrimaryLabelTextColor.color<br>&gt;&gt; <br>&gt;&gt; We can also have a protocol ColorConvertible defined like this to simplify things :<br>&gt;&gt; protocol ColorConvertible {<br>&gt;&gt;   var color: UIColor { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Let&#39;s take a more concrete example with the open source library Alamofire (https://github.com/Alamofire/Alamofire &lt;https://github.com/Alamofire/Alamofire&gt;).<br>&gt;&gt; Alamofire makes an extensive usage of this pattern to convert different types into a &quot;NSURL-compatible&quot; String or a NSURLRequest object.<br>&gt;&gt; <br>&gt;&gt; Then the Alamofire API use only those URLStringConvertible and URLRequestConvertible protocols as method inputs.<br>&gt;&gt; <br>&gt;&gt; It&#39;s great because at the right moment where you use the Alamofire API, no matter if you currently use a NSURL or a NSURLComponent, you can pass both as argument to the Alamofire function.<br>&gt;&gt; <br>&gt;&gt; Moreover, you may want to use a custom type to build your URLs and validate them. This allows you to add some safety because you can use strong-typed enums as path components instead of error-prone strings.<br>&gt;&gt; And here is where this pattern is convenient : you can make your custom type (which could be a class, a struct or an enum) conforming to URLStringConvertible and use it directly as Alamofire API functions input.<br>&gt;&gt; <br>&gt;&gt; But this is sadly limited for Alamofire API. What about all other frameworks which only take NSURL as input ?<br>&gt;&gt; <br>&gt;&gt; Using protocols for this is counterintuitive :<br>&gt;&gt; 	– protocols are especially thought to don&#39;t have to deal with a particular type right ? But what we do here ? We use it only to convert the receiver into the desired type. After the conversion, the original receiver is not even used anymore because we can do nothing with it except convert it.<br>&gt;&gt; <br>&gt;&gt; 	– we already can see different way to write these conversions,  : <br>&gt;&gt; 		- var URLString: String { get }  arbitrary var name pattern<br>&gt;&gt; 		- var integerValue: Int { get }  _Value var name pattern (like in NSNumber)<br>&gt;&gt; 		- func toColor() -&gt; UIColor  to_() func name pattern <br>&gt;&gt; <br>&gt;&gt; 	– everytime we want to have a type conversion we need te create the associated protocol but it won&#39;t be compatible with third party libraries unless by manually write forwarding methods...<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 2. Swift language already makes convenient bridges between some Obj-C types and theirs Swift counterparts<br>&gt;&gt; <br>&gt;&gt; I didn&#39;t take the time to see how it&#39;s currently implemented right now, but we already have bridging. For instance this code is valid without doing anything : <br>&gt;&gt; <br>&gt;&gt; func doSomethingWithNumber(number: NSNumber) {<br>&gt;&gt;   //...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let integer: Int = 42<br>&gt;&gt; doSomethingWithNumber(integer)<br>&gt;&gt;  <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; The cleanest way I see to add this feature is by having a new bridge keyword. A bridge could be implemented either into the type implementation scope or in an extension. Bridges can also be a protocol requirement and even have a default implementation thanks to protocol extensions. In fact, bridge keyword can be used in same places than the subscript keyword.<br>&gt;&gt; <br>&gt;&gt; Here is what it could look like for the above NSURL example (note how the bridge could return an optional if needed) :<br>&gt;&gt; <br>&gt;&gt; extension String {<br>&gt;&gt;   bridge NSURL? {<br>&gt;&gt;     return NSURL(string: self)<br>&gt;&gt;   }<br>&gt;&gt;   <br>&gt;&gt;   bridge NSURLComponents? {<br>&gt;&gt;     return NSURLComponents(string: self)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension NSURLComponents {<br>&gt;&gt;   bridge NSURL? {<br>&gt;&gt;     return self.URL<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Now this is how Swift-to-Foundation bridge could be implemented with this new syntax : <br>&gt;&gt; <br>&gt;&gt; extension NSNumber {<br>&gt;&gt;   bridge Int {<br>&gt;&gt;     return self.integerValue<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Int {<br>&gt;&gt;   bridge NSNumber {<br>&gt;&gt;     return NSNumber(integerValue: self)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Then, as soon a bridge is defined from a type A to a type B, anywhere an API expects to have a type B, we could pass a type A instead :<br>&gt;&gt; <br>&gt;&gt; enum AppColors {<br>&gt;&gt;   case PrimaryTextColor<br>&gt;&gt;   case SecondaryTextColor<br>&gt;&gt;   <br>&gt;&gt;   bridge UIColor {<br>&gt;&gt;     switch self {<br>&gt;&gt;     case .PrimaryTextColor:<br>&gt;&gt;       return UIColor.blackColor()<br>&gt;&gt;     case .SecondaryTextColor:<br>&gt;&gt;       return UIColor.grayColor()<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; ...<br>&gt;&gt; <br>&gt;&gt; let cell = UITableViewCell(style: .Value1, reuseIdentifier: &quot;MyCell&quot;)<br>&gt;&gt; cell.textLabel?.textColor = .PrimaryTextColor<br>&gt;&gt; cell.detailTextLabel?.textColor = .SecondaryTextColor<br>&gt;&gt; <br>&gt;&gt; We could also imagine that bridges support error throwing : <br>&gt;&gt; <br>&gt;&gt; extension String {<br>&gt;&gt;   enum ColorBridgeError: ErrorType {<br>&gt;&gt;     case ColorNameNotSupported<br>&gt;&gt;   }<br>&gt;&gt;   bridge throws UIColor {<br>&gt;&gt;     switch self {<br>&gt;&gt;     case &quot;red&quot;:<br>&gt;&gt;       return UIColor.redColor()<br>&gt;&gt;     case &quot;blue&quot;:<br>&gt;&gt;       return UIColor.blueColor()<br>&gt;&gt;     default:<br>&gt;&gt;       throw ColorBridgeError.ColorNameNotSupported<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; ...<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;   cell.textLabel?.textColor = try self.colorNameTextField.text<br>&gt;&gt;   self.errorLabel.text = nil<br>&gt;&gt; }<br>&gt;&gt; catch String.ColorBridgeError.ColorNameNotSupported {<br>&gt;&gt;   self.errorLabel.text = &quot;This color name is invalid :(&quot;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This implementation is of course one of many implementations possible and I&#39;m really open to suggestions. For instance I already can see one trade-off of this implementation : for the String -&gt; NSURL? bridge, why NSURL(string: self) would be chosen over NSURL(fileURLWithPath: self) ? <br>&gt;&gt; <br>&gt;&gt; We could also image than bridge are &quot;chainable&quot; (but maybe it could affect compilation times ?). For instance <br>&gt;&gt; <br>&gt;&gt; extension A {<br>&gt;&gt;   bridge B {<br>&gt;&gt;     return B(withA: self)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension B {<br>&gt;&gt;   bridge C {<br>&gt;&gt;     return C(withB: self)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func doSomethingWithC(anyC: C) {<br>&gt;&gt;   //...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let a = A()<br>&gt;&gt; doSomethingWithC(a) // Compiler could implicitly bridge `a` to type `B`, then bridge the result to type `C`<br>&gt;&gt; <br>&gt;&gt; But this is optional for the feature, we could imagine to explicitly need to implement a bridge from A to C.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Well, I think that&#39;s all for now. I hope it was not too long to read and it was well explained. I&#39;m of course open to all suggestions, questions, enhancements, etc...<br>&gt;&gt; <br>&gt;&gt; I would also be happy to have technical details about possible implementations as I&#39;m not an expert at all in compiler design. I really don&#39;t know how this feature could affect the compiler and any insight here will be welcome.<br>&gt;&gt; <br>&gt;&gt; Thanks for reading.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; Jérôme Alves<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/8baf048b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Built-in &quot;bridge&quot; feature</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 20, 2016 at 04:00:00pm</p></header><div class="content"><p>I was thinking A as C would tell the compiler to try A bridge C, and failing that, look through the types to which A *can* bridge to see if any of them can bridge to C, and so on… Having thought about it more, though, that’s a horrible idea. It’d be way too easy to have some *very* subtle side effects if you bridge YourAwesomeType between a couple of types that were previously bridged by some other path (a change in rounding behavior comes to mind). This is especially true since there’s nothing preventing the bridges from being “lossy”… imagine “bridging” 0.0001 to YourAwesomeType (which stores it as an Int) before then bridging to some other type, where previously 0.0001 would’ve gotten there via some path that *didn’t* round it to an Int along the way.<br></p><p>Yeah, probably stick with having to be explicit about *how* you intend A to bridge to C, if it can’t just do it directly<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 20, 2016, at 15:49, Jerome ALVES &lt;j.alves at me.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m not sure, do you suggest to always use the &quot;as&quot; keyword, or only in case where we want to move from &quot;A&quot; to &quot;C&quot; passing by &quot;B&quot; ?<br>&gt; <br>&gt; In fact,I feel right about always needing to use the &quot;as&quot; keyword. It&#39;s true that this kind of feature could be too magical and cause some issues. Having to explicitly cast to bridged type could be a good compromise between readability and safety.<br>&gt; <br>&gt; <br>&gt;&gt; Le 21 janv. 2016 à 00:37, davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I could be wrong, but I believe that implicit type conversion, in general, causes problems (which is why ImplicitlyUnwrappedOptionals are handled with “compiler magic” as opposed to a general language feature). How would you feel about reusing the as keyword?<br>&gt;&gt; let a = A()<br>&gt;&gt; doSomethingWithC(a as C) // Compiler could check if there are explicit bridging functions, and fallback to as’s current meaning if not<br>&gt;&gt; <br>&gt;&gt; Either way, though, I’d love a short-hand way to convert between types.<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 20, 2016, at 15:27, Jerome ALVES via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi everyone,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is my first message on the mailing list and I hope I&#39;ll do everything right :)<br>&gt;&gt;&gt; I&#39;ve been through the mailing-list archive and I didn&#39;t see anything close to this proposal so I hope I didn&#39;t miss anything.<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sometimes, there are several ways to represent the same thing. For instance NSURL and NSURLComponents are both used to deal with URLs, but according to the API you want to use you must have to make manual conversions from one type to another. My proposal is to add a built-in bridge feature into the Swift language to remove a lot of boilerplate code and increase readability.<br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. It&#39;s a really convenient pattern <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift has several great solutions for types. Structs, Enums, and Protocols can do as much as Classes. You can define properties, methods, subscripts, you can extend them, etc.. This allowed developers to use some types where they weren&#39;t expected. For instance we can use an enum AppColors to define all colors used by an app, and as an enum can have properties, we can add a var color: UIColor on it to generate the associate UIColor (or NSColor)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Its really convenient but wherever we want to use this color, we need to call the .color property :<br>&gt;&gt;&gt; myLabel.textColor = AppColors.PrimaryLabelTextColor.color<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We can also have a protocol ColorConvertible defined like this to simplify things :<br>&gt;&gt;&gt; protocol ColorConvertible {<br>&gt;&gt;&gt;   var color: UIColor { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let&#39;s take a more concrete example with the open source library Alamofire (https://github.com/Alamofire/Alamofire &lt;https://github.com/Alamofire/Alamofire&gt;).<br>&gt;&gt;&gt; Alamofire makes an extensive usage of this pattern to convert different types into a &quot;NSURL-compatible&quot; String or a NSURLRequest object.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then the Alamofire API use only those URLStringConvertible and URLRequestConvertible protocols as method inputs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s great because at the right moment where you use the Alamofire API, no matter if you currently use a NSURL or a NSURLComponent, you can pass both as argument to the Alamofire function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Moreover, you may want to use a custom type to build your URLs and validate them. This allows you to add some safety because you can use strong-typed enums as path components instead of error-prone strings.<br>&gt;&gt;&gt; And here is where this pattern is convenient : you can make your custom type (which could be a class, a struct or an enum) conforming to URLStringConvertible and use it directly as Alamofire API functions input.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But this is sadly limited for Alamofire API. What about all other frameworks which only take NSURL as input ?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using protocols for this is counterintuitive :<br>&gt;&gt;&gt; 	– protocols are especially thought to don&#39;t have to deal with a particular type right ? But what we do here ? We use it only to convert the receiver into the desired type. After the conversion, the original receiver is not even used anymore because we can do nothing with it except convert it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	– we already can see different way to write these conversions,  : <br>&gt;&gt;&gt; 		- var URLString: String { get }  arbitrary var name pattern<br>&gt;&gt;&gt; 		- var integerValue: Int { get }  _Value var name pattern (like in NSNumber)<br>&gt;&gt;&gt; 		- func toColor() -&gt; UIColor  to_() func name pattern <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	– everytime we want to have a type conversion we need te create the associated protocol but it won&#39;t be compatible with third party libraries unless by manually write forwarding methods...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Swift language already makes convenient bridges between some Obj-C types and theirs Swift counterparts<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I didn&#39;t take the time to see how it&#39;s currently implemented right now, but we already have bridging. For instance this code is valid without doing anything : <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomethingWithNumber(number: NSNumber) {<br>&gt;&gt;&gt;   //...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let integer: Int = 42<br>&gt;&gt;&gt; doSomethingWithNumber(integer)<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The cleanest way I see to add this feature is by having a new bridge keyword. A bridge could be implemented either into the type implementation scope or in an extension. Bridges can also be a protocol requirement and even have a default implementation thanks to protocol extensions. In fact, bridge keyword can be used in same places than the subscript keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is what it could look like for the above NSURL example (note how the bridge could return an optional if needed) :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension String {<br>&gt;&gt;&gt;   bridge NSURL? {<br>&gt;&gt;&gt;     return NSURL(string: self)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   bridge NSURLComponents? {<br>&gt;&gt;&gt;     return NSURLComponents(string: self)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension NSURLComponents {<br>&gt;&gt;&gt;   bridge NSURL? {<br>&gt;&gt;&gt;     return self.URL<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now this is how Swift-to-Foundation bridge could be implemented with this new syntax : <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension NSNumber {<br>&gt;&gt;&gt;   bridge Int {<br>&gt;&gt;&gt;     return self.integerValue<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Int {<br>&gt;&gt;&gt;   bridge NSNumber {<br>&gt;&gt;&gt;     return NSNumber(integerValue: self)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then, as soon a bridge is defined from a type A to a type B, anywhere an API expects to have a type B, we could pass a type A instead :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum AppColors {<br>&gt;&gt;&gt;   case PrimaryTextColor<br>&gt;&gt;&gt;   case SecondaryTextColor<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   bridge UIColor {<br>&gt;&gt;&gt;     switch self {<br>&gt;&gt;&gt;     case .PrimaryTextColor:<br>&gt;&gt;&gt;       return UIColor.blackColor()<br>&gt;&gt;&gt;     case .SecondaryTextColor:<br>&gt;&gt;&gt;       return UIColor.grayColor()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let cell = UITableViewCell(style: .Value1, reuseIdentifier: &quot;MyCell&quot;)<br>&gt;&gt;&gt; cell.textLabel?.textColor = .PrimaryTextColor<br>&gt;&gt;&gt; cell.detailTextLabel?.textColor = .SecondaryTextColor<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We could also imagine that bridges support error throwing : <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension String {<br>&gt;&gt;&gt;   enum ColorBridgeError: ErrorType {<br>&gt;&gt;&gt;     case ColorNameNotSupported<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   bridge throws UIColor {<br>&gt;&gt;&gt;     switch self {<br>&gt;&gt;&gt;     case &quot;red&quot;:<br>&gt;&gt;&gt;       return UIColor.redColor()<br>&gt;&gt;&gt;     case &quot;blue&quot;:<br>&gt;&gt;&gt;       return UIColor.blueColor()<br>&gt;&gt;&gt;     default:<br>&gt;&gt;&gt;       throw ColorBridgeError.ColorNameNotSupported<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; do {<br>&gt;&gt;&gt;   cell.textLabel?.textColor = try self.colorNameTextField.text<br>&gt;&gt;&gt;   self.errorLabel.text = nil<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; catch String.ColorBridgeError.ColorNameNotSupported {<br>&gt;&gt;&gt;   self.errorLabel.text = &quot;This color name is invalid :(&quot;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This implementation is of course one of many implementations possible and I&#39;m really open to suggestions. For instance I already can see one trade-off of this implementation : for the String -&gt; NSURL? bridge, why NSURL(string: self) would be chosen over NSURL(fileURLWithPath: self) ? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We could also image than bridge are &quot;chainable&quot; (but maybe it could affect compilation times ?). For instance <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt;   bridge B {<br>&gt;&gt;&gt;     return B(withA: self)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension B {<br>&gt;&gt;&gt;   bridge C {<br>&gt;&gt;&gt;     return C(withB: self)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomethingWithC(anyC: C) {<br>&gt;&gt;&gt;   //...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = A()<br>&gt;&gt;&gt; doSomethingWithC(a) // Compiler could implicitly bridge `a` to type `B`, then bridge the result to type `C`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But this is optional for the feature, we could imagine to explicitly need to implement a bridge from A to C.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, I think that&#39;s all for now. I hope it was not too long to read and it was well explained. I&#39;m of course open to all suggestions, questions, enhancements, etc...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would also be happy to have technical details about possible implementations as I&#39;m not an expert at all in compiler design. I really don&#39;t know how this feature could affect the compiler and any insight here will be welcome.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for reading.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jérôme Alves<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/c210468b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>[Proposal] Built-in &quot;bridge&quot; feature</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>January 21, 2016 at 06:00:00am</p></header><div class="content"><p>IIRC there was syntax to do this in Swift 1.0 which latter got removed from<br>the language.<br>This sort of feature enables some cool patterns. I remember an example<br>where some sort of Synchronized&lt;T&gt; object could be passed to a function<br>expecting a T using this feature. However I can also see how implicit<br>conversions can make code hard to read, and maybe they also cause<br>complexity in the compiler (where suddenly every expression could<br>potentially be evaluated as another type)<br>On Wed, Jan 20, 2016 at 4:28 PM Dave via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I was thinking A as C would tell the compiler to try A bridge C, and<br>&gt; failing that, look through the types to which A *can* bridge to see if any<br>&gt; of them can bridge to C, and so on… Having thought about it more, though,<br>&gt; that’s a horrible idea. It’d be way too easy to have some *very* subtle<br>&gt; side effects if you bridge YourAwesomeType between a couple of types that<br>&gt; were previously bridged by some other path (a change in rounding behavior<br>&gt; comes to mind). This is especially true since there’s nothing preventing<br>&gt; the bridges from being “lossy”… imagine “bridging” 0.0001<br>&gt; to YourAwesomeType (which stores it as an Int) before then bridging to some<br>&gt; other type, where previously 0.0001 would’ve gotten there via some path<br>&gt; that *didn’t* round it to an Int along the way.<br>&gt;<br>&gt; Yeah, probably stick with having to be explicit about *how* you intend A<br>&gt; to bridge to C, if it can’t just do it directly<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>&gt; On Jan 20, 2016, at 15:49, Jerome ALVES &lt;j.alves at me.com&gt; wrote:<br>&gt;<br>&gt; I&#39;m not sure, do you suggest to always use the &quot;as&quot; keyword, or only in<br>&gt; case where we want to move from &quot;A&quot; to &quot;C&quot; passing by &quot;B&quot; ?<br>&gt;<br>&gt; In fact,I feel right about always needing to use the &quot;as&quot; keyword. It&#39;s<br>&gt; true that this kind of feature could be too magical and cause some issues.<br>&gt; Having to explicitly cast to bridged type could be a good compromise<br>&gt; between readability and safety.<br>&gt;<br>&gt;<br>&gt; Le 21 janv. 2016 à 00:37, davesweeris at mac.com a écrit :<br>&gt;<br>&gt; I could be wrong, but I believe that implicit type conversion, in general,<br>&gt; causes problems (which is why ImplicitlyUnwrappedOptionals are handled with<br>&gt; “compiler magic” as opposed to a general language feature). How would you<br>&gt; feel about reusing the as keyword?<br>&gt; let a = A()<br>&gt; doSomethingWithC(a as C) // Compiler could check if there are explicit<br>&gt; bridging functions, and fallback to as’s current meaning if not<br>&gt;<br>&gt; Either way, though, I’d love a short-hand way to convert between types.<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>&gt; On Jan 20, 2016, at 15:27, Jerome ALVES via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi everyone,<br>&gt;<br>&gt; This is my first message on the mailing list and I hope I&#39;ll do everything<br>&gt; right :)<br>&gt; I&#39;ve been through the mailing-list archive and I didn&#39;t see anything close<br>&gt; to this proposal so I hope I didn&#39;t miss anything.<br>&gt; Introduction<br>&gt; Sometimes, there are several ways to represent the same thing. For<br>&gt; instance NSURL and NSURLComponents are both used to deal with URLs, but<br>&gt; according to the API you want to use you must have to make manual<br>&gt; conversions from one type to another. My proposal is to add a built-in<br>&gt; bridge feature into the Swift language to remove a lot of boilerplate code<br>&gt; and increase readability.<br>&gt; Motivation<br>&gt; *1. It&#39;s a really convenient pattern *<br>&gt;<br>&gt; Swift has several great solutions for types. Structs, Enums, and Protocols<br>&gt; can do as much as Classes. You can define properties, methods, subscripts,<br>&gt; you can extend them, etc.. This allowed developers to use some types where<br>&gt; they weren&#39;t expected. For instance we can use an enum AppColors to<br>&gt; define all colors used by an app, and as an enum can have properties, we<br>&gt; can add a var color: UIColor on it to generate the associate UIColor (or<br>&gt; NSColor)<br>&gt;<br>&gt; Its really convenient but wherever we want to use this color, we need to<br>&gt; call the .color property :<br>&gt; myLabel.textColor = AppColors.PrimaryLabelTextColor.color<br>&gt;<br>&gt; We can also have a protocol ColorConvertible defined like this to<br>&gt; simplify things :<br>&gt; protocol ColorConvertible {<br>&gt;   var color: UIColor { get }<br>&gt; }<br>&gt;<br>&gt; Let&#39;s take a more concrete example with the open source library Alamofire (<br>&gt; https://github.com/Alamofire/Alamofire).<br>&gt; Alamofire makes an extensive usage of this pattern to convert different<br>&gt; types into a *&quot;*NSURL*-compatible&quot; String* or a NSURLRequest object.<br>&gt;<br>&gt; Then the Alamofire API use only those URLStringConvertible and<br>&gt; URLRequestConvertible protocols as method inputs.<br>&gt;<br>&gt; It&#39;s great because at the right moment where you use the Alamofire API, no<br>&gt; matter if you currently use a NSURL or a NSURLComponent, you can pass<br>&gt; both as argument to the Alamofire function.<br>&gt;<br>&gt; Moreover, you may want to use a custom type to build your URLs and<br>&gt; validate them. This allows you to add some safety because you can use<br>&gt; strong-typed enums as path components instead of error-prone strings.<br>&gt; And here is where this pattern is convenient : you can make your custom<br>&gt; type (which could be a class, a struct or an enum) conforming to<br>&gt; URLStringConvertible and use it directly as Alamofire API functions input.<br>&gt;<br>&gt; But this is sadly limited for Alamofire API. What about all other<br>&gt; frameworks which only take NSURL as input ?<br>&gt;<br>&gt; Using protocols for this is counterintuitive :<br>&gt; – protocols are especially thought to don&#39;t have to deal with a particular<br>&gt; type right ? But what we do here ? We use it only to convert the receiver<br>&gt; into the desired type. After the conversion, the original receiver is not<br>&gt; even used anymore because we can do nothing with it except convert it.<br>&gt;<br>&gt; – we already can see different way to write these conversions,  :<br>&gt; - var URLString: String { get }  arbitrary var name pattern<br>&gt; - var integerValue: Int { get }  _Value var name pattern (like in NSNumber<br>&gt; )<br>&gt; - func toColor() -&gt; UIColor  to_() func name pattern<br>&gt;<br>&gt; – everytime we want to have a type conversion we need te create the<br>&gt; associated protocol but it won&#39;t be compatible with third party libraries<br>&gt; unless by manually write forwarding methods...<br>&gt;<br>&gt;<br>&gt; *2. Swift language already makes convenient bridges between some Obj-C<br>&gt; types and theirs Swift counterparts*<br>&gt;<br>&gt; I didn&#39;t take the time to see how it&#39;s currently implemented right now,<br>&gt; but we already have bridging. For instance this code is valid without doing<br>&gt; anything :<br>&gt;<br>&gt; func doSomethingWithNumber(number: NSNumber) {<br>&gt;   //...<br>&gt; }<br>&gt;<br>&gt; let integer: Int = 42<br>&gt; doSomethingWithNumber(integer)<br>&gt;<br>&gt; Proposed solution<br>&gt; The cleanest way I see to add this feature is by having a new bridge keyword.<br>&gt; A bridge could be implemented either into the type implementation scope or<br>&gt; in an extension. Bridges can also be a protocol requirement and even have a<br>&gt; default implementation thanks to protocol extensions. In fact, bridge keyword<br>&gt; can be used in same places than the subscript keyword.<br>&gt;<br>&gt; Here is what it could look like for the above NSURL example (note how the<br>&gt; bridge could return an optional if needed) :<br>&gt;<br>&gt; extension String {<br>&gt;   bridge NSURL? {<br>&gt;     return NSURL(string: self)<br>&gt;   }<br>&gt;<br>&gt;   bridge NSURLComponents? {<br>&gt;     return NSURLComponents(string: self)<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; extension NSURLComponents {<br>&gt;   bridge NSURL? {<br>&gt;     return self.URL<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; Now this is how Swift-to-Foundation bridge could be implemented with this<br>&gt; new syntax :<br>&gt;<br>&gt; extension NSNumber {<br>&gt;   bridge Int {<br>&gt;     return self.integerValue<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; extension Int {<br>&gt;   bridge NSNumber {<br>&gt;     return NSNumber(integerValue: self)<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; Then, as soon a bridge is defined from a type A to a type B, anywhere an<br>&gt; API expects to have a type B, we could pass a type A instead :<br>&gt;<br>&gt; enum AppColors {<br>&gt;   case PrimaryTextColor<br>&gt;   case SecondaryTextColor<br>&gt;<br>&gt;   bridge UIColor {<br>&gt;     switch self {<br>&gt;     case .PrimaryTextColor:<br>&gt;       return UIColor.blackColor()<br>&gt;     case .SecondaryTextColor:<br>&gt;       return UIColor.grayColor()<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; ...<br>&gt;<br>&gt; let cell = UITableViewCell(style: .Value1, reuseIdentifier: &quot;MyCell&quot;)<br>&gt; cell.textLabel?.textColor = .PrimaryTextColor<br>&gt; cell.detailTextLabel?.textColor = .SecondaryTextColor<br>&gt;<br>&gt; We could also imagine that bridges support error throwing :<br>&gt;<br>&gt; extension String {<br>&gt;   enum ColorBridgeError: ErrorType {<br>&gt;     case ColorNameNotSupported<br>&gt;   }<br>&gt;   bridge throws UIColor {<br>&gt;     switch self {<br>&gt;     case &quot;red&quot;:<br>&gt;       return UIColor.redColor()<br>&gt;     case &quot;blue&quot;:<br>&gt;       return UIColor.blueColor()<br>&gt;     default:<br>&gt;       throw ColorBridgeError.ColorNameNotSupported<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; ...<br>&gt;<br>&gt; do {<br>&gt;   cell.textLabel?.textColor = try self.colorNameTextField.text<br>&gt;   self.errorLabel.text = nil<br>&gt; }<br>&gt; catch String.ColorBridgeError.ColorNameNotSupported {<br>&gt;   self.errorLabel.text = &quot;This color name is invalid :(&quot;<br>&gt; }<br>&gt;<br>&gt; This implementation is of course one of many implementations possible and<br>&gt; I&#39;m really open to suggestions. For instance I already can see one<br>&gt; trade-off of this implementation : for the String -&gt; NSURL? bridge, why<br>&gt; NSURL(string: self) would be chosen over NSURL(fileURLWithPath: self) ?<br>&gt;<br>&gt; We could also image than bridge are &quot;chainable&quot; (but maybe it could affect<br>&gt; compilation times ?). For instance<br>&gt;<br>&gt; extension A {<br>&gt;   bridge B {<br>&gt;     return B(withA: self)<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; extension B {<br>&gt;   bridge C {<br>&gt;     return C(withB: self)<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; func doSomethingWithC(anyC: C) {<br>&gt;   //...<br>&gt; }<br>&gt;<br>&gt; let a = A()<br>&gt; doSomethingWithC(a) // Compiler could implicitly bridge `a` to type `B`,<br>&gt; then bridge the result to type `C`<br>&gt;<br>&gt; But this is optional for the feature, we could imagine to explicitly need<br>&gt; to implement a bridge from A to C.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; Well, I think that&#39;s all for now. I hope it was not too long to read and<br>&gt; it was well explained. I&#39;m of course open to all suggestions, questions,<br>&gt; enhancements, etc...<br>&gt;<br>&gt; I would also be happy to have technical details about possible<br>&gt; implementations as I&#39;m not an expert at all in compiler design. I really<br>&gt; don&#39;t know how this feature could affect the compiler and any insight here<br>&gt; will be welcome.<br>&gt;<br>&gt; Thanks for reading.<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; Jérôme Alves<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/0cd5a8b9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal] Built-in &quot;bridge&quot; feature</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 20, 2016 at 11:00:00pm</p></header><div class="content"><p>I don&#39;t really like this feature; I see it as one of those &quot;more brevity in<br>exchange for less clarity&quot; features that are an anti-goal of the project.<br>If a bug is caused by a type conversion, I want to be able to narrow the<br>offending conversion to an explicit call, not have to guess at which point<br>the compiler decided to insert a conversion, which conversion was inserted,<br>or whether one of my dependencies might be exporting a conversion I wasn&#39;t<br>aware of.<br></p><p>There was also a thread some time ago where one of the developers stated<br>that adding general implicit conversions to Swift would make building a<br>performant type checker impossible, but I can&#39;t find it.<br></p><p>One major exception I can think of is QoL issues when working with numbers<br>and arithmetic, for example automatically widening integers, but there&#39;s a<br>separate project working on redesigning that aspect of the language.<br></p><p>Best,<br>Austin<br></p><p><br></p><p>On Wed, Jan 20, 2016 at 10:58 PM, Javier Soto via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; IIRC there was syntax to do this in Swift 1.0 which latter got removed<br>&gt; from the language.<br>&gt; This sort of feature enables some cool patterns. I remember an example<br>&gt; where some sort of Synchronized&lt;T&gt; object could be passed to a function<br>&gt; expecting a T using this feature. However I can also see how implicit<br>&gt; conversions can make code hard to read, and maybe they also cause<br>&gt; complexity in the compiler (where suddenly every expression could<br>&gt; potentially be evaluated as another type)<br>&gt;<br>&gt; On Wed, Jan 20, 2016 at 4:28 PM Dave via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I was thinking A as C would tell the compiler to try A bridge C, and<br>&gt;&gt; failing that, look through the types to which A *can* bridge to see if any<br>&gt;&gt; of them can bridge to C, and so on… Having thought about it more, though,<br>&gt;&gt; that’s a horrible idea. It’d be way too easy to have some *very* subtle<br>&gt;&gt; side effects if you bridge YourAwesomeType between a couple of types that<br>&gt;&gt; were previously bridged by some other path (a change in rounding behavior<br>&gt;&gt; comes to mind). This is especially true since there’s nothing preventing<br>&gt;&gt; the bridges from being “lossy”… imagine “bridging” 0.0001<br>&gt;&gt; to YourAwesomeType (which stores it as an Int) before then bridging to some<br>&gt;&gt; other type, where previously 0.0001 would’ve gotten there via some path<br>&gt;&gt; that *didn’t* round it to an Int along the way.<br>&gt;&gt;<br>&gt;&gt; Yeah, probably stick with having to be explicit about *how* you intend A<br>&gt;&gt; to bridge to C, if it can’t just do it directly<br>&gt;&gt;<br>&gt;&gt; - Dave Sweeris<br>&gt;&gt;<br>&gt;&gt; On Jan 20, 2016, at 15:49, Jerome ALVES &lt;j.alves at me.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I&#39;m not sure, do you suggest to always use the &quot;as&quot; keyword, or only in<br>&gt;&gt; case where we want to move from &quot;A&quot; to &quot;C&quot; passing by &quot;B&quot; ?<br>&gt;&gt;<br>&gt;&gt; In fact,I feel right about always needing to use the &quot;as&quot; keyword. It&#39;s<br>&gt;&gt; true that this kind of feature could be too magical and cause some issues.<br>&gt;&gt; Having to explicitly cast to bridged type could be a good compromise<br>&gt;&gt; between readability and safety.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Le 21 janv. 2016 à 00:37, davesweeris at mac.com a écrit :<br>&gt;&gt;<br>&gt;&gt; I could be wrong, but I believe that implicit type conversion, in<br>&gt;&gt; general, causes problems (which is why ImplicitlyUnwrappedOptionals are<br>&gt;&gt; handled with “compiler magic” as opposed to a general language feature).<br>&gt;&gt; How would you feel about reusing the as keyword?<br>&gt;&gt; let a = A()<br>&gt;&gt; doSomethingWithC(a as C) // Compiler could check if there are explicit<br>&gt;&gt; bridging functions, and fallback to as’s current meaning if not<br>&gt;&gt;<br>&gt;&gt; Either way, though, I’d love a short-hand way to convert between types.<br>&gt;&gt;<br>&gt;&gt; - Dave Sweeris<br>&gt;&gt;<br>&gt;&gt; On Jan 20, 2016, at 15:27, Jerome ALVES via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi everyone,<br>&gt;&gt;<br>&gt;&gt; This is my first message on the mailing list and I hope I&#39;ll do<br>&gt;&gt; everything right :)<br>&gt;&gt; I&#39;ve been through the mailing-list archive and I didn&#39;t see anything<br>&gt;&gt; close to this proposal so I hope I didn&#39;t miss anything.<br>&gt;&gt; Introduction<br>&gt;&gt; Sometimes, there are several ways to represent the same thing. For<br>&gt;&gt; instance NSURL and NSURLComponents are both used to deal with URLs, but<br>&gt;&gt; according to the API you want to use you must have to make manual<br>&gt;&gt; conversions from one type to another. My proposal is to add a built-in<br>&gt;&gt; bridge feature into the Swift language to remove a lot of boilerplate code<br>&gt;&gt; and increase readability.<br>&gt;&gt; Motivation<br>&gt;&gt; *1. It&#39;s a really convenient pattern *<br>&gt;&gt;<br>&gt;&gt; Swift has several great solutions for types. Structs, Enums, and<br>&gt;&gt; Protocols can do as much as Classes. You can define properties, methods,<br>&gt;&gt; subscripts, you can extend them, etc.. This allowed developers to use some<br>&gt;&gt; types where they weren&#39;t expected. For instance we can use an enum<br>&gt;&gt; AppColors to define all colors used by an app, and as an enum can have<br>&gt;&gt; properties, we can add a var color: UIColor on it to generate the<br>&gt;&gt; associate UIColor (or NSColor)<br>&gt;&gt;<br>&gt;&gt; Its really convenient but wherever we want to use this color, we need to<br>&gt;&gt; call the .color property :<br>&gt;&gt; myLabel.textColor = AppColors.PrimaryLabelTextColor.color<br>&gt;&gt;<br>&gt;&gt; We can also have a protocol ColorConvertible defined like this to<br>&gt;&gt; simplify things :<br>&gt;&gt; protocol ColorConvertible {<br>&gt;&gt;   var color: UIColor { get }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Let&#39;s take a more concrete example with the open source library Alamofire<br>&gt;&gt; (https://github.com/Alamofire/Alamofire).<br>&gt;&gt; Alamofire makes an extensive usage of this pattern to convert different<br>&gt;&gt; types into a *&quot;*NSURL*-compatible&quot; String* or a NSURLRequest object.<br>&gt;&gt;<br>&gt;&gt; Then the Alamofire API use only those URLStringConvertible and<br>&gt;&gt; URLRequestConvertible protocols as method inputs.<br>&gt;&gt;<br>&gt;&gt; It&#39;s great because at the right moment where you use the Alamofire API,<br>&gt;&gt; no matter if you currently use a NSURL or a NSURLComponent, you can pass<br>&gt;&gt; both as argument to the Alamofire function.<br>&gt;&gt;<br>&gt;&gt; Moreover, you may want to use a custom type to build your URLs and<br>&gt;&gt; validate them. This allows you to add some safety because you can use<br>&gt;&gt; strong-typed enums as path components instead of error-prone strings.<br>&gt;&gt; And here is where this pattern is convenient : you can make your custom<br>&gt;&gt; type (which could be a class, a struct or an enum) conforming to<br>&gt;&gt; URLStringConvertible and use it directly as Alamofire API functions<br>&gt;&gt; input.<br>&gt;&gt;<br>&gt;&gt; But this is sadly limited for Alamofire API. What about all other<br>&gt;&gt; frameworks which only take NSURL as input ?<br>&gt;&gt;<br>&gt;&gt; Using protocols for this is counterintuitive :<br>&gt;&gt; – protocols are especially thought to don&#39;t have to deal with a<br>&gt;&gt; particular type right ? But what we do here ? We use it only to convert the<br>&gt;&gt; receiver into the desired type. After the conversion, the original receiver<br>&gt;&gt; is not even used anymore because we can do nothing with it except convert<br>&gt;&gt; it.<br>&gt;&gt;<br>&gt;&gt; – we already can see different way to write these conversions,  :<br>&gt;&gt; - var URLString: String { get }  arbitrary var name pattern<br>&gt;&gt; - var integerValue: Int { get }  _Value var name pattern (like in<br>&gt;&gt; NSNumber)<br>&gt;&gt; - func toColor() -&gt; UIColor  to_() func name pattern<br>&gt;&gt;<br>&gt;&gt; – everytime we want to have a type conversion we need te create the<br>&gt;&gt; associated protocol but it won&#39;t be compatible with third party libraries<br>&gt;&gt; unless by manually write forwarding methods...<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *2. Swift language already makes convenient bridges between some Obj-C<br>&gt;&gt; types and theirs Swift counterparts*<br>&gt;&gt;<br>&gt;&gt; I didn&#39;t take the time to see how it&#39;s currently implemented right now,<br>&gt;&gt; but we already have bridging. For instance this code is valid without doing<br>&gt;&gt; anything :<br>&gt;&gt;<br>&gt;&gt; func doSomethingWithNumber(number: NSNumber) {<br>&gt;&gt;   //...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let integer: Int = 42<br>&gt;&gt; doSomethingWithNumber(integer)<br>&gt;&gt;<br>&gt;&gt; Proposed solution<br>&gt;&gt; The cleanest way I see to add this feature is by having a new bridge keyword.<br>&gt;&gt; A bridge could be implemented either into the type implementation scope or<br>&gt;&gt; in an extension. Bridges can also be a protocol requirement and even have a<br>&gt;&gt; default implementation thanks to protocol extensions. In fact, bridge keyword<br>&gt;&gt; can be used in same places than the subscript keyword.<br>&gt;&gt;<br>&gt;&gt; Here is what it could look like for the above NSURL example (note how the<br>&gt;&gt; bridge could return an optional if needed) :<br>&gt;&gt;<br>&gt;&gt; extension String {<br>&gt;&gt;   bridge NSURL? {<br>&gt;&gt;     return NSURL(string: self)<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   bridge NSURLComponents? {<br>&gt;&gt;     return NSURLComponents(string: self)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension NSURLComponents {<br>&gt;&gt;   bridge NSURL? {<br>&gt;&gt;     return self.URL<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Now this is how Swift-to-Foundation bridge could be implemented with this<br>&gt;&gt; new syntax :<br>&gt;&gt;<br>&gt;&gt; extension NSNumber {<br>&gt;&gt;   bridge Int {<br>&gt;&gt;     return self.integerValue<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension Int {<br>&gt;&gt;   bridge NSNumber {<br>&gt;&gt;     return NSNumber(integerValue: self)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Then, as soon a bridge is defined from a type A to a type B, anywhere an<br>&gt;&gt; API expects to have a type B, we could pass a type A instead :<br>&gt;&gt;<br>&gt;&gt; enum AppColors {<br>&gt;&gt;   case PrimaryTextColor<br>&gt;&gt;   case SecondaryTextColor<br>&gt;&gt;<br>&gt;&gt;   bridge UIColor {<br>&gt;&gt;     switch self {<br>&gt;&gt;     case .PrimaryTextColor:<br>&gt;&gt;       return UIColor.blackColor()<br>&gt;&gt;     case .SecondaryTextColor:<br>&gt;&gt;       return UIColor.grayColor()<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; ...<br>&gt;&gt;<br>&gt;&gt; let cell = UITableViewCell(style: .Value1, reuseIdentifier: &quot;MyCell&quot;)<br>&gt;&gt; cell.textLabel?.textColor = .PrimaryTextColor<br>&gt;&gt; cell.detailTextLabel?.textColor = .SecondaryTextColor<br>&gt;&gt;<br>&gt;&gt; We could also imagine that bridges support error throwing :<br>&gt;&gt;<br>&gt;&gt; extension String {<br>&gt;&gt;   enum ColorBridgeError: ErrorType {<br>&gt;&gt;     case ColorNameNotSupported<br>&gt;&gt;   }<br>&gt;&gt;   bridge throws UIColor {<br>&gt;&gt;     switch self {<br>&gt;&gt;     case &quot;red&quot;:<br>&gt;&gt;       return UIColor.redColor()<br>&gt;&gt;     case &quot;blue&quot;:<br>&gt;&gt;       return UIColor.blueColor()<br>&gt;&gt;     default:<br>&gt;&gt;       throw ColorBridgeError.ColorNameNotSupported<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; ...<br>&gt;&gt;<br>&gt;&gt; do {<br>&gt;&gt;   cell.textLabel?.textColor = try self.colorNameTextField.text<br>&gt;&gt;   self.errorLabel.text = nil<br>&gt;&gt; }<br>&gt;&gt; catch String.ColorBridgeError.ColorNameNotSupported {<br>&gt;&gt;   self.errorLabel.text = &quot;This color name is invalid :(&quot;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This implementation is of course one of many implementations possible and<br>&gt;&gt; I&#39;m really open to suggestions. For instance I already can see one<br>&gt;&gt; trade-off of this implementation : for the String -&gt; NSURL? bridge, why<br>&gt;&gt; NSURL(string: self) would be chosen over NSURL(fileURLWithPath: self) ?<br>&gt;&gt;<br>&gt;&gt; We could also image than bridge are &quot;chainable&quot; (but maybe it could<br>&gt;&gt; affect compilation times ?). For instance<br>&gt;&gt;<br>&gt;&gt; extension A {<br>&gt;&gt;   bridge B {<br>&gt;&gt;     return B(withA: self)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension B {<br>&gt;&gt;   bridge C {<br>&gt;&gt;     return C(withB: self)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; func doSomethingWithC(anyC: C) {<br>&gt;&gt;   //...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let a = A()<br>&gt;&gt; doSomethingWithC(a) // Compiler could implicitly bridge `a` to type `B`,<br>&gt;&gt; then bridge the result to type `C`<br>&gt;&gt;<br>&gt;&gt; But this is optional for the feature, we could imagine to explicitly need<br>&gt;&gt; to implement a bridge from A to C.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Well, I think that&#39;s all for now. I hope it was not too long to read and<br>&gt;&gt; it was well explained. I&#39;m of course open to all suggestions, questions,<br>&gt;&gt; enhancements, etc...<br>&gt;&gt;<br>&gt;&gt; I would also be happy to have technical details about possible<br>&gt;&gt; implementations as I&#39;m not an expert at all in compiler design. I really<br>&gt;&gt; don&#39;t know how this feature could affect the compiler and any insight here<br>&gt;&gt; will be welcome.<br>&gt;&gt;<br>&gt;&gt; Thanks for reading.<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt;<br>&gt;&gt; Jérôme Alves<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; --<br>&gt; Javier Soto<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/1700f3d0/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/743ea9b8e49fa6a8390b2f4b3e1a588f?s=50"></div><header><strong>[Proposal] Built-in &quot;bridge&quot; feature</strong> from <string>Jerome ALVES</string> &lt;j.alves at me.com&gt;<p>January 21, 2016 at 04:00:00pm</p></header><div class="content"><p>Well, If you think about it, this bridge feature how I presented it here does nothing more than what we can do today. Like error handling in Swift 2, it&#39;s just a syntactic sugar to standardize a commonly used pattern. Moreover if we decide to don&#39;t allow implicit conversion but only explicit conversions with the &quot;as&quot; keyword, we have a feature which increase clarity. <br></p><p>Don&#39;t you find that in... <br></p><p>func doSomethingWith(url: NSURL) {<br>    ... <br>}<br></p><p>let urlString = &quot;http://swift.org&quot;<br></p><p>... this syntax :<br>doSomethingWith(urlString as! NSURL) // we use as! instead of as because this bridge returns a NSURL? instead of NSURL<br></p><p>... is more clear than this syntax :<br>doSomethingWith(urlString.toURL()!)<br></p><p>Moreover, the IDE can bring some useful features here : We can make a cmd + click on the &quot;as&quot; keyword to jump right into the bridge implementation, or a option + click to see the doc associated to it.<br></p><p><br>- Jérôme<br></p><p>&gt; Le 21 janv. 2016 à 08:35, Austin Zheng &lt;austinzheng at gmail.com&gt; a écrit :<br>&gt; <br>&gt; I don&#39;t really like this feature; I see it as one of those &quot;more brevity in exchange for less clarity&quot; features that are an anti-goal of the project. If a bug is caused by a type conversion, I want to be able to narrow the offending conversion to an explicit call, not have to guess at which point the compiler decided to insert a conversion, which conversion was inserted, or whether one of my dependencies might be exporting a conversion I wasn&#39;t aware of.<br>&gt; <br>&gt; There was also a thread some time ago where one of the developers stated that adding general implicit conversions to Swift would make building a performant type checker impossible, but I can&#39;t find it.<br>&gt; <br>&gt; One major exception I can think of is QoL issues when working with numbers and arithmetic, for example automatically widening integers, but there&#39;s a separate project working on redesigning that aspect of the language.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Wed, Jan 20, 2016 at 10:58 PM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; IIRC there was syntax to do this in Swift 1.0 which latter got removed from the language.<br>&gt; This sort of feature enables some cool patterns. I remember an example where some sort of Synchronized&lt;T&gt; object could be passed to a function expecting a T using this feature. However I can also see how implicit conversions can make code hard to read, and maybe they also cause complexity in the compiler (where suddenly every expression could potentially be evaluated as another type)<br>&gt; <br>&gt; On Wed, Jan 20, 2016 at 4:28 PM Dave via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I was thinking A as C would tell the compiler to try A bridge C, and failing that, look through the types to which A *can* bridge to see if any of them can bridge to C, and so on… Having thought about it more, though, that’s a horrible idea. It’d be way too easy to have some *very* subtle side effects if you bridge YourAwesomeType between a couple of types that were previously bridged by some other path (a change in rounding behavior comes to mind). This is especially true since there’s nothing preventing the bridges from being “lossy”… imagine “bridging” 0.0001 to YourAwesomeType (which stores it as an Int) before then bridging to some other type, where previously 0.0001 would’ve gotten there via some path that *didn’t* round it to an Int along the way.<br>&gt; <br>&gt; Yeah, probably stick with having to be explicit about *how* you intend A to bridge to C, if it can’t just do it directly<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 15:49, Jerome ALVES &lt;j.alves at me.com &lt;mailto:j.alves at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure, do you suggest to always use the &quot;as&quot; keyword, or only in case where we want to move from &quot;A&quot; to &quot;C&quot; passing by &quot;B&quot; ?<br>&gt;&gt; <br>&gt;&gt; In fact,I feel right about always needing to use the &quot;as&quot; keyword. It&#39;s true that this kind of feature could be too magical and cause some issues. Having to explicitly cast to bridged type could be a good compromise between readability and safety.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 21 janv. 2016 à 00:37, davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I could be wrong, but I believe that implicit type conversion, in general, causes problems (which is why ImplicitlyUnwrappedOptionals are handled with “compiler magic” as opposed to a general language feature). How would you feel about reusing the as keyword?<br>&gt;&gt;&gt; let a = A()<br>&gt;&gt;&gt; doSomethingWithC(a as C) // Compiler could check if there are explicit bridging functions, and fallback to as’s current meaning if not<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Either way, though, I’d love a short-hand way to convert between types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 20, 2016, at 15:27, Jerome ALVES via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi everyone,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is my first message on the mailing list and I hope I&#39;ll do everything right :)<br>&gt;&gt;&gt;&gt; I&#39;ve been through the mailing-list archive and I didn&#39;t see anything close to this proposal so I hope I didn&#39;t miss anything.<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sometimes, there are several ways to represent the same thing. For instance NSURL and NSURLComponents are both used to deal with URLs, but according to the API you want to use you must have to make manual conversions from one type to another. My proposal is to add a built-in bridge feature into the Swift language to remove a lot of boilerplate code and increase readability.<br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. It&#39;s a really convenient pattern <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift has several great solutions for types. Structs, Enums, and Protocols can do as much as Classes. You can define properties, methods, subscripts, you can extend them, etc.. This allowed developers to use some types where they weren&#39;t expected. For instance we can use an enum AppColors to define all colors used by an app, and as an enum can have properties, we can add a var color: UIColor on it to generate the associate UIColor (or NSColor)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Its really convenient but wherever we want to use this color, we need to call the .color property :<br>&gt;&gt;&gt;&gt; myLabel.textColor = AppColors.PrimaryLabelTextColor.color<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We can also have a protocol ColorConvertible defined like this to simplify things :<br>&gt;&gt;&gt;&gt; protocol ColorConvertible {<br>&gt;&gt;&gt;&gt;   var color: UIColor { get }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let&#39;s take a more concrete example with the open source library Alamofire (https://github.com/Alamofire/Alamofire &lt;https://github.com/Alamofire/Alamofire&gt;).<br>&gt;&gt;&gt;&gt; Alamofire makes an extensive usage of this pattern to convert different types into a &quot;NSURL-compatible&quot; String or a NSURLRequest object.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Then the Alamofire API use only those URLStringConvertible and URLRequestConvertible protocols as method inputs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s great because at the right moment where you use the Alamofire API, no matter if you currently use a NSURL or a NSURLComponent, you can pass both as argument to the Alamofire function.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Moreover, you may want to use a custom type to build your URLs and validate them. This allows you to add some safety because you can use strong-typed enums as path components instead of error-prone strings.<br>&gt;&gt;&gt;&gt; And here is where this pattern is convenient : you can make your custom type (which could be a class, a struct or an enum) conforming to URLStringConvertible and use it directly as Alamofire API functions input.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But this is sadly limited for Alamofire API. What about all other frameworks which only take NSURL as input ?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Using protocols for this is counterintuitive :<br>&gt;&gt;&gt;&gt; 	– protocols are especially thought to don&#39;t have to deal with a particular type right ? But what we do here ? We use it only to convert the receiver into the desired type. After the conversion, the original receiver is not even used anymore because we can do nothing with it except convert it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	– we already can see different way to write these conversions,  : <br>&gt;&gt;&gt;&gt; 		- var URLString: String { get }  arbitrary var name pattern<br>&gt;&gt;&gt;&gt; 		- var integerValue: Int { get }  _Value var name pattern (like in NSNumber)<br>&gt;&gt;&gt;&gt; 		- func toColor() -&gt; UIColor  to_() func name pattern <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	– everytime we want to have a type conversion we need te create the associated protocol but it won&#39;t be compatible with third party libraries unless by manually write forwarding methods...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Swift language already makes convenient bridges between some Obj-C types and theirs Swift counterparts<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I didn&#39;t take the time to see how it&#39;s currently implemented right now, but we already have bridging. For instance this code is valid without doing anything : <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func doSomethingWithNumber(number: NSNumber) {<br>&gt;&gt;&gt;&gt;   //...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let integer: Int = 42<br>&gt;&gt;&gt;&gt; doSomethingWithNumber(integer)<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The cleanest way I see to add this feature is by having a new bridge keyword. A bridge could be implemented either into the type implementation scope or in an extension. Bridges can also be a protocol requirement and even have a default implementation thanks to protocol extensions. In fact, bridge keyword can be used in same places than the subscript keyword.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here is what it could look like for the above NSURL example (note how the bridge could return an optional if needed) :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension String {<br>&gt;&gt;&gt;&gt;   bridge NSURL? {<br>&gt;&gt;&gt;&gt;     return NSURL(string: self)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;   bridge NSURLComponents? {<br>&gt;&gt;&gt;&gt;     return NSURLComponents(string: self)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension NSURLComponents {<br>&gt;&gt;&gt;&gt;   bridge NSURL? {<br>&gt;&gt;&gt;&gt;     return self.URL<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now this is how Swift-to-Foundation bridge could be implemented with this new syntax : <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension NSNumber {<br>&gt;&gt;&gt;&gt;   bridge Int {<br>&gt;&gt;&gt;&gt;     return self.integerValue<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Int {<br>&gt;&gt;&gt;&gt;   bridge NSNumber {<br>&gt;&gt;&gt;&gt;     return NSNumber(integerValue: self)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Then, as soon a bridge is defined from a type A to a type B, anywhere an API expects to have a type B, we could pass a type A instead :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum AppColors {<br>&gt;&gt;&gt;&gt;   case PrimaryTextColor<br>&gt;&gt;&gt;&gt;   case SecondaryTextColor<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;   bridge UIColor {<br>&gt;&gt;&gt;&gt;     switch self {<br>&gt;&gt;&gt;&gt;     case .PrimaryTextColor:<br>&gt;&gt;&gt;&gt;       return UIColor.blackColor()<br>&gt;&gt;&gt;&gt;     case .SecondaryTextColor:<br>&gt;&gt;&gt;&gt;       return UIColor.grayColor()<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let cell = UITableViewCell(style: .Value1, reuseIdentifier: &quot;MyCell&quot;)<br>&gt;&gt;&gt;&gt; cell.textLabel?.textColor = .PrimaryTextColor<br>&gt;&gt;&gt;&gt; cell.detailTextLabel?.textColor = .SecondaryTextColor<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We could also imagine that bridges support error throwing : <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension String {<br>&gt;&gt;&gt;&gt;   enum ColorBridgeError: ErrorType {<br>&gt;&gt;&gt;&gt;     case ColorNameNotSupported<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   bridge throws UIColor {<br>&gt;&gt;&gt;&gt;     switch self {<br>&gt;&gt;&gt;&gt;     case &quot;red&quot;:<br>&gt;&gt;&gt;&gt;       return UIColor.redColor()<br>&gt;&gt;&gt;&gt;     case &quot;blue&quot;:<br>&gt;&gt;&gt;&gt;       return UIColor.blueColor()<br>&gt;&gt;&gt;&gt;     default:<br>&gt;&gt;&gt;&gt;       throw ColorBridgeError.ColorNameNotSupported<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; do {<br>&gt;&gt;&gt;&gt;   cell.textLabel?.textColor = try self.colorNameTextField.text<br>&gt;&gt;&gt;&gt;   self.errorLabel.text = nil<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; catch String.ColorBridgeError.ColorNameNotSupported {<br>&gt;&gt;&gt;&gt;   self.errorLabel.text = &quot;This color name is invalid :(&quot;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This implementation is of course one of many implementations possible and I&#39;m really open to suggestions. For instance I already can see one trade-off of this implementation : for the String -&gt; NSURL? bridge, why NSURL(string: self) would be chosen over NSURL(fileURLWithPath: self) ? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We could also image than bridge are &quot;chainable&quot; (but maybe it could affect compilation times ?). For instance <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt;&gt;   bridge B {<br>&gt;&gt;&gt;&gt;     return B(withA: self)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension B {<br>&gt;&gt;&gt;&gt;   bridge C {<br>&gt;&gt;&gt;&gt;     return C(withB: self)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func doSomethingWithC(anyC: C) {<br>&gt;&gt;&gt;&gt;   //...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let a = A()<br>&gt;&gt;&gt;&gt; doSomethingWithC(a) // Compiler could implicitly bridge `a` to type `B`, then bridge the result to type `C`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But this is optional for the feature, we could imagine to explicitly need to implement a bridge from A to C.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Well, I think that&#39;s all for now. I hope it was not too long to read and it was well explained. I&#39;m of course open to all suggestions, questions, enhancements, etc...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would also be happy to have technical details about possible implementations as I&#39;m not an expert at all in compiler design. I really don&#39;t know how this feature could affect the compiler and any insight here will be welcome.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks for reading.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jérôme Alves<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -- <br>&gt; Javier Soto <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/cb4a27cd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal] Built-in &quot;bridge&quot; feature</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 21, 2016 at 09:00:00am</p></header><div class="content"><p>I wouldn&#39;t be opposed to this if the &#39;as&#39; was required (or there were some other syntax that prevented it from being implicit).<br></p><p>There are a few more questions that come up, but they have more to do with the specifics of the implementation:<br></p><p>- How would the compiler use the syntax to distinguish between different valid conversions (you briefly mentioned this)? What about conversions that you import from a different module? Would it be too limiting to restrict this to conversions that are defined in the same module (+ any in the stdlib)?<br>- How would the &#39;as&#39; syntax (or even the non-&#39;as&#39; syntax) work with generic types? For example, Javi mentioned a possibly useful conversion from T --&gt; Synchronized&lt;T&gt;. (Side note - might this be a use case for higher-kinded types?)<br></p><p>Best,<br>Austin<br></p><p>&gt; On Jan 21, 2016, at 7:05 AM, Jerome ALVES &lt;j.alves at me.com&gt; wrote:<br>&gt; <br>&gt; Well, If you think about it, this bridge feature how I presented it here does nothing more than what we can do today. Like error handling in Swift 2, it&#39;s just a syntactic sugar to standardize a commonly used pattern. Moreover if we decide to don&#39;t allow implicit conversion but only explicit conversions with the &quot;as&quot; keyword, we have a feature which increase clarity. <br>&gt; <br>&gt; Don&#39;t you find that in... <br>&gt; <br>&gt; func doSomethingWith(url: NSURL) {<br>&gt;     ... <br>&gt; }<br>&gt; <br>&gt; let urlString = &quot;http://swift.org &lt;http://swift.org/&gt;&quot;<br>&gt; <br>&gt; ... this syntax :<br>&gt; doSomethingWith(urlString as! NSURL) // we use as! instead of as because this bridge returns a NSURL? instead of NSURL<br>&gt; <br>&gt; ... is more clear than this syntax :<br>&gt; doSomethingWith(urlString.toURL()!)<br>&gt; <br>&gt; Moreover, the IDE can bring some useful features here : We can make a cmd + click on the &quot;as&quot; keyword to jump right into the bridge implementation, or a option + click to see the doc associated to it.<br>&gt; <br>&gt; <br>&gt; - Jérôme<br>&gt; <br>&gt;&gt; Le 21 janv. 2016 à 08:35, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I don&#39;t really like this feature; I see it as one of those &quot;more brevity in exchange for less clarity&quot; features that are an anti-goal of the project. If a bug is caused by a type conversion, I want to be able to narrow the offending conversion to an explicit call, not have to guess at which point the compiler decided to insert a conversion, which conversion was inserted, or whether one of my dependencies might be exporting a conversion I wasn&#39;t aware of.<br>&gt;&gt; <br>&gt;&gt; There was also a thread some time ago where one of the developers stated that adding general implicit conversions to Swift would make building a performant type checker impossible, but I can&#39;t find it.<br>&gt;&gt; <br>&gt;&gt; One major exception I can think of is QoL issues when working with numbers and arithmetic, for example automatically widening integers, but there&#39;s a separate project working on redesigning that aspect of the language.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Jan 20, 2016 at 10:58 PM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; IIRC there was syntax to do this in Swift 1.0 which latter got removed from the language.<br>&gt;&gt; This sort of feature enables some cool patterns. I remember an example where some sort of Synchronized&lt;T&gt; object could be passed to a function expecting a T using this feature. However I can also see how implicit conversions can make code hard to read, and maybe they also cause complexity in the compiler (where suddenly every expression could potentially be evaluated as another type)<br>&gt;&gt; <br>&gt;&gt; On Wed, Jan 20, 2016 at 4:28 PM Dave via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I was thinking A as C would tell the compiler to try A bridge C, and failing that, look through the types to which A *can* bridge to see if any of them can bridge to C, and so on… Having thought about it more, though, that’s a horrible idea. It’d be way too easy to have some *very* subtle side effects if you bridge YourAwesomeType between a couple of types that were previously bridged by some other path (a change in rounding behavior comes to mind). This is especially true since there’s nothing preventing the bridges from being “lossy”… imagine “bridging” 0.0001 to YourAwesomeType (which stores it as an Int) before then bridging to some other type, where previously 0.0001 would’ve gotten there via some path that *didn’t* round it to an Int along the way.<br>&gt;&gt; <br>&gt;&gt; Yeah, probably stick with having to be explicit about *how* you intend A to bridge to C, if it can’t just do it directly<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 20, 2016, at 15:49, Jerome ALVES &lt;j.alves at me.com &lt;mailto:j.alves at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure, do you suggest to always use the &quot;as&quot; keyword, or only in case where we want to move from &quot;A&quot; to &quot;C&quot; passing by &quot;B&quot; ?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In fact,I feel right about always needing to use the &quot;as&quot; keyword. It&#39;s true that this kind of feature could be too magical and cause some issues. Having to explicitly cast to bridged type could be a good compromise between readability and safety.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 21 janv. 2016 à 00:37, davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I could be wrong, but I believe that implicit type conversion, in general, causes problems (which is why ImplicitlyUnwrappedOptionals are handled with “compiler magic” as opposed to a general language feature). How would you feel about reusing the as keyword?<br>&gt;&gt;&gt;&gt; let a = A()<br>&gt;&gt;&gt;&gt; doSomethingWithC(a as C) // Compiler could check if there are explicit bridging functions, and fallback to as’s current meaning if not<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Either way, though, I’d love a short-hand way to convert between types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 20, 2016, at 15:27, Jerome ALVES via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi everyone,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is my first message on the mailing list and I hope I&#39;ll do everything right :)<br>&gt;&gt;&gt;&gt;&gt; I&#39;ve been through the mailing-list archive and I didn&#39;t see anything close to this proposal so I hope I didn&#39;t miss anything.<br>&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sometimes, there are several ways to represent the same thing. For instance NSURL and NSURLComponents are both used to deal with URLs, but according to the API you want to use you must have to make manual conversions from one type to another. My proposal is to add a built-in bridge feature into the Swift language to remove a lot of boilerplate code and increase readability.<br>&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. It&#39;s a really convenient pattern <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift has several great solutions for types. Structs, Enums, and Protocols can do as much as Classes. You can define properties, methods, subscripts, you can extend them, etc.. This allowed developers to use some types where they weren&#39;t expected. For instance we can use an enum AppColors to define all colors used by an app, and as an enum can have properties, we can add a var color: UIColor on it to generate the associate UIColor (or NSColor)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Its really convenient but wherever we want to use this color, we need to call the .color property :<br>&gt;&gt;&gt;&gt;&gt; myLabel.textColor = AppColors.PrimaryLabelTextColor.color<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We can also have a protocol ColorConvertible defined like this to simplify things :<br>&gt;&gt;&gt;&gt;&gt; protocol ColorConvertible {<br>&gt;&gt;&gt;&gt;&gt;   var color: UIColor { get }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let&#39;s take a more concrete example with the open source library Alamofire (https://github.com/Alamofire/Alamofire &lt;https://github.com/Alamofire/Alamofire&gt;).<br>&gt;&gt;&gt;&gt;&gt; Alamofire makes an extensive usage of this pattern to convert different types into a &quot;NSURL-compatible&quot; String or a NSURLRequest object.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Then the Alamofire API use only those URLStringConvertible and URLRequestConvertible protocols as method inputs.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It&#39;s great because at the right moment where you use the Alamofire API, no matter if you currently use a NSURL or a NSURLComponent, you can pass both as argument to the Alamofire function.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Moreover, you may want to use a custom type to build your URLs and validate them. This allows you to add some safety because you can use strong-typed enums as path components instead of error-prone strings.<br>&gt;&gt;&gt;&gt;&gt; And here is where this pattern is convenient : you can make your custom type (which could be a class, a struct or an enum) conforming to URLStringConvertible and use it directly as Alamofire API functions input.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But this is sadly limited for Alamofire API. What about all other frameworks which only take NSURL as input ?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Using protocols for this is counterintuitive :<br>&gt;&gt;&gt;&gt;&gt; 	– protocols are especially thought to don&#39;t have to deal with a particular type right ? But what we do here ? We use it only to convert the receiver into the desired type. After the conversion, the original receiver is not even used anymore because we can do nothing with it except convert it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	– we already can see different way to write these conversions,  : <br>&gt;&gt;&gt;&gt;&gt; 		- var URLString: String { get }  arbitrary var name pattern<br>&gt;&gt;&gt;&gt;&gt; 		- var integerValue: Int { get }  _Value var name pattern (like in NSNumber)<br>&gt;&gt;&gt;&gt;&gt; 		- func toColor() -&gt; UIColor  to_() func name pattern <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	– everytime we want to have a type conversion we need te create the associated protocol but it won&#39;t be compatible with third party libraries unless by manually write forwarding methods...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. Swift language already makes convenient bridges between some Obj-C types and theirs Swift counterparts<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I didn&#39;t take the time to see how it&#39;s currently implemented right now, but we already have bridging. For instance this code is valid without doing anything : <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func doSomethingWithNumber(number: NSNumber) {<br>&gt;&gt;&gt;&gt;&gt;   //...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let integer: Int = 42<br>&gt;&gt;&gt;&gt;&gt; doSomethingWithNumber(integer)<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The cleanest way I see to add this feature is by having a new bridge keyword. A bridge could be implemented either into the type implementation scope or in an extension. Bridges can also be a protocol requirement and even have a default implementation thanks to protocol extensions. In fact, bridge keyword can be used in same places than the subscript keyword.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here is what it could look like for the above NSURL example (note how the bridge could return an optional if needed) :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension String {<br>&gt;&gt;&gt;&gt;&gt;   bridge NSURL? {<br>&gt;&gt;&gt;&gt;&gt;     return NSURL(string: self)<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;   bridge NSURLComponents? {<br>&gt;&gt;&gt;&gt;&gt;     return NSURLComponents(string: self)<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension NSURLComponents {<br>&gt;&gt;&gt;&gt;&gt;   bridge NSURL? {<br>&gt;&gt;&gt;&gt;&gt;     return self.URL<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now this is how Swift-to-Foundation bridge could be implemented with this new syntax : <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension NSNumber {<br>&gt;&gt;&gt;&gt;&gt;   bridge Int {<br>&gt;&gt;&gt;&gt;&gt;     return self.integerValue<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension Int {<br>&gt;&gt;&gt;&gt;&gt;   bridge NSNumber {<br>&gt;&gt;&gt;&gt;&gt;     return NSNumber(integerValue: self)<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Then, as soon a bridge is defined from a type A to a type B, anywhere an API expects to have a type B, we could pass a type A instead :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; enum AppColors {<br>&gt;&gt;&gt;&gt;&gt;   case PrimaryTextColor<br>&gt;&gt;&gt;&gt;&gt;   case SecondaryTextColor<br>&gt;&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;&gt;   bridge UIColor {<br>&gt;&gt;&gt;&gt;&gt;     switch self {<br>&gt;&gt;&gt;&gt;&gt;     case .PrimaryTextColor:<br>&gt;&gt;&gt;&gt;&gt;       return UIColor.blackColor()<br>&gt;&gt;&gt;&gt;&gt;     case .SecondaryTextColor:<br>&gt;&gt;&gt;&gt;&gt;       return UIColor.grayColor()<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let cell = UITableViewCell(style: .Value1, reuseIdentifier: &quot;MyCell&quot;)<br>&gt;&gt;&gt;&gt;&gt; cell.textLabel?.textColor = .PrimaryTextColor<br>&gt;&gt;&gt;&gt;&gt; cell.detailTextLabel?.textColor = .SecondaryTextColor<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We could also imagine that bridges support error throwing : <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension String {<br>&gt;&gt;&gt;&gt;&gt;   enum ColorBridgeError: ErrorType {<br>&gt;&gt;&gt;&gt;&gt;     case ColorNameNotSupported<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   bridge throws UIColor {<br>&gt;&gt;&gt;&gt;&gt;     switch self {<br>&gt;&gt;&gt;&gt;&gt;     case &quot;red&quot;:<br>&gt;&gt;&gt;&gt;&gt;       return UIColor.redColor()<br>&gt;&gt;&gt;&gt;&gt;     case &quot;blue&quot;:<br>&gt;&gt;&gt;&gt;&gt;       return UIColor.blueColor()<br>&gt;&gt;&gt;&gt;&gt;     default:<br>&gt;&gt;&gt;&gt;&gt;       throw ColorBridgeError.ColorNameNotSupported<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; do {<br>&gt;&gt;&gt;&gt;&gt;   cell.textLabel?.textColor = try self.colorNameTextField.text<br>&gt;&gt;&gt;&gt;&gt;   self.errorLabel.text = nil<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; catch String.ColorBridgeError.ColorNameNotSupported {<br>&gt;&gt;&gt;&gt;&gt;   self.errorLabel.text = &quot;This color name is invalid :(&quot;<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This implementation is of course one of many implementations possible and I&#39;m really open to suggestions. For instance I already can see one trade-off of this implementation : for the String -&gt; NSURL? bridge, why NSURL(string: self) would be chosen over NSURL(fileURLWithPath: self) ? <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We could also image than bridge are &quot;chainable&quot; (but maybe it could affect compilation times ?). For instance <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt;&gt;&gt;   bridge B {<br>&gt;&gt;&gt;&gt;&gt;     return B(withA: self)<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension B {<br>&gt;&gt;&gt;&gt;&gt;   bridge C {<br>&gt;&gt;&gt;&gt;&gt;     return C(withB: self)<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func doSomethingWithC(anyC: C) {<br>&gt;&gt;&gt;&gt;&gt;   //...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let a = A()<br>&gt;&gt;&gt;&gt;&gt; doSomethingWithC(a) // Compiler could implicitly bridge `a` to type `B`, then bridge the result to type `C`<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But this is optional for the feature, we could imagine to explicitly need to implement a bridge from A to C.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Well, I think that&#39;s all for now. I hope it was not too long to read and it was well explained. I&#39;m of course open to all suggestions, questions, enhancements, etc...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would also be happy to have technical details about possible implementations as I&#39;m not an expert at all in compiler design. I really don&#39;t know how this feature could affect the compiler and any insight here will be welcome.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks for reading.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Jérôme Alves<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; -- <br>&gt;&gt; Javier Soto <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/66c6611d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
