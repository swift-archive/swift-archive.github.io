<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f79a7909dfca0088f4fdc01f109f497e?s=50"></div><header><strong>problems with simple binary-trees program</strong> from <string>Isaac Gouy</string> &lt;igouy2 at yahoo.com&gt;<p>December 19, 2015 at 06:00:00pm</p></header><div class="content"><p>This simple binary-trees program seems to cause problems for Swift on Ubuntu 15.10<br></p><p><br>http://benchmarksgame.alioth.debian.org/u64q/program.php?test=binarytrees&amp;lang=swift&amp;id=1<br></p><p>Any suggestions what the problem might be?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7321934b88ca8da079d7b89926501a9c?s=50"></div><header><strong>problems with simple binary-trees program</strong> from <string>David Turnbull</string> &lt;dturnbull at gmail.com&gt;<p>December 19, 2015 at 02:00:00pm</p></header><div class="content"><p>Winners of this test have pooled memory (apr_pools) and tail recursion.<br></p><p>Here&#39;s a version that&#39;s 5X faster:<br>https://gist.github.com/AE9RB/ce29eacb5f2214f401af<br></p><p>-david (https://github.com/AE9RB/SwiftGL)<br></p><p>On Sat, Dec 19, 2015 at 10:34 AM, Isaac Gouy via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; This simple binary-trees program seems to cause problems for Swift on<br>&gt; Ubuntu 15.10<br>&gt;<br>&gt;<br>&gt; http://benchmarksgame.alioth.debian.org/u64q/program.php?test=binarytrees&amp;lang=swift&amp;id=1<br>&gt;<br>&gt; Any suggestions what the problem might be?<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151219/b34544d5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f79a7909dfca0088f4fdc01f109f497e?s=50"></div><header><strong>problems with simple binary-trees program</strong> from <string>Isaac Gouy</string> &lt;igouy2 at yahoo.com&gt;<p>December 20, 2015 at 07:00:00am</p></header><div class="content"><p>On Saturday, December 19, 2015 2:39 PM, David Turnbull &lt;dturnbull at gmail.com&gt; wrote:<br></p><p>&gt;Here&#39;s a version that&#39;s 5X faster:<br>&gt;https://gist.github.com/AE9RB/ce29eacb5f2214f401af<br></p><p><br>fwiw your 5X faster version also exceeds the one hour time-out.<br></p><p>n=12 5.034secs<br>n=16 1308.819secs<br>n=20 &gt;3605.874secs<br></p><p><br>Compare with these n=20 measurements --<br></p><p><br>http://benchmarksgame.alioth.debian.org/u64q/performance.php?test=binarytrees<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f79a7909dfca0088f4fdc01f109f497e?s=50"></div><header><strong>problems with simple binary-trees program</strong> from <string>Isaac Gouy</string> &lt;igouy2 at yahoo.com&gt;<p>December 20, 2015 at 07:00:00am</p></header><div class="content"><p>On Saturday, December 19, 2015 2:39 PM, David Turnbull &lt;dturnbull at gmail.com&gt; wrote:<br></p><p>&gt;Winners of this test have pooled memory (apr_pools) and tail recursion.<br></p><p><br>A simple Swift program that completed the workloads within an hour time-out would be an incredible improvement :-)<br></p><p>Instead of looking at the &quot;Winners&quot; compare with the TypeScript program<br></p><p>http://benchmarksgame.alioth.debian.org/u64q/program.php?test=binarytrees⟨=typescript&amp;id=2<br></p><p>Why does a Swift transliteration of that program perform so slowly?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>problems with simple binary-trees program</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>December 20, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On 20 Dec 2015, at 08:48, Isaac Gouy via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; On Saturday, December 19, 2015 2:39 PM, David Turnbull &lt;dturnbull at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; Winners of this test have pooled memory (apr_pools) and tail recursion.<br>&gt; <br>&gt; <br>&gt; A simple Swift program that completed the workloads within an hour time-out would be an incredible improvement :-)<br>&gt; <br>&gt; Instead of looking at the &quot;Winners&quot; compare with the TypeScript program<br>&gt; <br>&gt; http://benchmarksgame.alioth.debian.org/u64q/program.php?test=binarytrees⟨=typescript&amp;id=2<br>&gt; <br>&gt; Why does a Swift transliteration of that program perform so slowly?<br></p><p>In one word: ARC.<br>This is pretty much a worst case example for ARC and the execution time is basically just ARC overhead.<br></p><p>To make this faster you&#39;d have to improve on this.<br>The &quot;simplest&quot; solution would be to simply use UnsafePointers instead of classes or indirect enums.<br>Basically just rewrite a C example in Swift; not pretty but it should also perform very much like C then.<br></p><p>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>- Janosch<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d145b9824a2bfc8aa2f3297f3a555e6?s=50"></div><header><strong>problems with simple binary-trees program</strong> from <string>Pascal Urban</string> &lt;mail at pscl.de&gt;<p>December 20, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; A simple Swift program that completed the workloads within an hour time-out would be an incredible improvement :-)<br>&gt; <br>&gt; Instead of looking at the &quot;Winners&quot; compare with the TypeScript program<br>&gt; <br>&gt; http://benchmarksgame.alioth.debian.org/u64q/program.php?test=binarytrees⟨=typescript&amp;id=2<br>&gt; <br>&gt; Why does a Swift transliteration of that program perform so slowly?<br>&gt; <br></p><p><br>Both of these implementations are slow because they always create binary trees with a depth of maxDepth instead of, well, the correct depth.<br>Changing the following lines (and the respective lines in David&#39;s implementation) leads to a more reasonable runtime:<br></p><p>check += bottomUpTree(i,maxDepth).check()<br>check += bottomUpTree(-i,maxDepth).check()<br></p><p>to<br></p><p>check += bottomUpTree(i,depth).check()<br>check += bottomUpTree(-i,depth).check()<br></p><p>On my MacBook (i5, 2.6GHz) I get:<br></p><p>n=20<br>David: ~16 - 17s<br>Isaac: ~120 - 126s<br></p><p>Because all of the winners are doing it:<br>Here is a quickly thrown together parallel version of David&#39;s implementation using libdispatch (contains also the fixes from above):<br>https://gist.github.com/psclde/8244c4350b1d4fd1b24b<br></p><p>This version takes about 7 - 8s for n=20.<br></p><p>But libdispatch is currently not working on Linux so it&#39;s not really relevant for the benchmark.<br></p><p>Pascal<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f79a7909dfca0088f4fdc01f109f497e?s=50"></div><header><strong>problems with simple binary-trees program</strong> from <string>Isaac Gouy</string> &lt;igouy2 at yahoo.com&gt;<p>December 20, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Sunday, December 20, 2015 9:58 AM, Pascal Urban &lt;mail at pscl.de&gt; wrote:<br></p><p>...<br>&gt; Both of these implementations are slow because they always create binary trees <br></p><p>&gt; with a depth of maxDepth instead of, well, the correct depth.<br></p><p>Thank you!<br></p><p>As always, I suspected I&#39;d made a dumb mistake - but just wasn&#39;t seeing it.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76959c1cb253ea11176e5656274e0eed?s=50"></div><header><strong>problems with simple binary-trees program</strong> from <string>Maurus Kühne</string> &lt;mauruskuehne at icloud.com&gt;<p>December 20, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On 20.12.2015, at 19:08, Isaac Gouy via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Sunday, December 20, 2015 9:58 AM, Pascal Urban &lt;mail at pscl.de&gt; wrote:<br>&gt; <br>&gt; ...<br>&gt;&gt; Both of these implementations are slow because they always create binary trees <br>&gt; <br>&gt;&gt; with a depth of maxDepth instead of, well, the correct depth.<br>&gt; <br>&gt; Thank you!<br>&gt; <br>&gt; As always, I suspected I&#39;d made a dumb mistake - but just wasn&#39;t seeing it.<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p><br>I was able to speed up David’s solution by almost 50% by changing the method checkTree from this:<br></p><p>func checkTree(t: Array&lt;TreeNodeItem&gt;, _ i: Int) -&gt; Int<br></p><p>to this:<br></p><p>func checkTree(inout t: Array&lt;TreeNodeItem&gt;, _ i: Int) -&gt; Int<br></p><p>It completes in about ~10s instead of ~20s on my 2.66GHz i5 iMac for n=20. <br>This also works together with Pascal’s libdispatch solution. In this case it completes in ~5s.<br>Here is the modified version: https://gist.github.com/mauruskuehne/633789417c2357a6bb93 &lt;https://gist.github.com/mauruskuehne/633789417c2357a6bb93&gt;<br></p><p>Could somebody explain to me why this is the case? I know what the inout keyword does, but I don’t understand why it makes the code faster in this case?<br></p><p>Maurus<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151220/8231cb67/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d145b9824a2bfc8aa2f3297f3a555e6?s=50"></div><header><strong>problems with simple binary-trees program</strong> from <string>Pascal Urban</string> &lt;mail at pscl.de&gt;<p>December 22, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On 20.12.2015, at 19:54, Maurus Kühne via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>…<br>&gt; I was able to speed up David’s solution by almost 50% by changing the method checkTree from this:<br>&gt; <br>&gt; func checkTree(t: Array&lt;TreeNodeItem&gt;, _ i: Int) -&gt; Int<br>&gt; <br>&gt; to this:<br>&gt; <br>&gt; func checkTree(inout t: Array&lt;TreeNodeItem&gt;, _ i: Int) -&gt; Int<br>&gt; <br>&gt; It completes in about ~10s instead of ~20s on my 2.66GHz i5 iMac for n=20. <br>&gt; This also works together with Pascal’s libdispatch solution. In this case it completes in ~5s.<br>&gt; Here is the modified version: https://gist.github.com/mauruskuehne/633789417c2357a6bb93 &lt;https://gist.github.com/mauruskuehne/633789417c2357a6bb93&gt;<br>&gt; <br>&gt; Could somebody explain to me why this is the case? I know what the inout keyword does, but I don’t understand why it makes the code faster in this case?<br>&gt; <br>&gt; Maurus<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p><br>Like Janosch said: ARC overhead<br></p><p>So here is whats happening:<br>A function reference parameter gets retained before calling the function and then released within the called function (generally), so the function is taking ownership of the parameter. [1]<br>If a parameter is marked with the inout keyword the function does not take ownership of the reference parameter, so no retains and releases. [2]<br></p><p>Given how often checkTree is called the retains and releases of the array get quiet expensive.<br>You can see this quiet nicely while profiling these functions in Instruments using the time profiler.<br></p><p>I think normally this shouldn&#39;t be a problem, but because of the recursion the compiler is not able to optimize the retain and release calls.<br></p><p>Another solution could be some kind of wrapper struct/class which has the array as a property and checkTree as a method.<br>This way checkTree would only access the property and additional retains/releases would not be necessary.<br></p><p>[1] https://github.com/apple/swift/blob/master/docs/SIL.rst#reference-counts<br>[2] https://github.com/apple/swift/blob/master/docs/SIL.rst#inout-arguments<br></p><p><br>&gt; On 20.12.2015, at 17:12, Janosch Hildebrand via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Basically just rewrite a C example in Swift; not pretty but it should also perform very much like C then.<br></p><p><br>Someone has done this and is now in second place:<br>http://benchmarksgame.alioth.debian.org/u64q/program.php?test=binarytrees&amp;lang=swift&amp;id=5<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151222/ed167030/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>problems with simple binary-trees program</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>December 22, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 2:31 PM, Pascal Urban via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 20.12.2015, at 19:54, Maurus Kühne via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt; …<br>&gt;&gt; I was able to speed up David’s solution by almost 50% by changing the method checkTree from this:<br>&gt;&gt; <br>&gt;&gt; func checkTree(t: Array&lt;TreeNodeItem&gt;, _ i: Int) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; to this:<br>&gt;&gt; <br>&gt;&gt; func checkTree(inout t: Array&lt;TreeNodeItem&gt;, _ i: Int) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; It completes in about ~10s instead of ~20s on my 2.66GHz i5 iMac for n=20. <br>&gt;&gt; This also works together with Pascal’s libdispatch solution. In this case it completes in ~5s.<br>&gt;&gt; Here is the modified version: https://gist.github.com/mauruskuehne/633789417c2357a6bb93 &lt;https://gist.github.com/mauruskuehne/633789417c2357a6bb93&gt;<br>&gt;&gt; <br>&gt;&gt; Could somebody explain to me why this is the case? I know what the inout keyword does, but I don’t understand why it makes the code faster in this case?<br>&gt;&gt; <br>&gt;&gt; Maurus<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt; <br>&gt; <br>&gt; Like Janosch said: ARC overhead<br>&gt; <br>&gt; So here is whats happening:<br>&gt; A function reference parameter gets retained before calling the function and then released within the called function (generally), so the function is taking ownership of the parameter. [1]<br>&gt; If a parameter is marked with the inout keyword the function does not take ownership of the reference parameter, so no retains and releases. [2]<br>&gt; <br>&gt; Given how often checkTree is called the retains and releases of the array get quiet expensive.<br>&gt; You can see this quiet nicely while profiling these functions in Instruments using the time profiler.<br>&gt; <br>&gt; I think normally this shouldn&#39;t be a problem, but because of the recursion the compiler is not able to optimize the retain and release calls.<br></p><p>This is not true. We can hit this case. It requires further work in the ARC optimizer. We some time ago actually did have the functionality to hit this case, but I had to disable it b/c of some correctness issues.<br></p><p>File a bug with this test case and assign to me.<br></p><p>Michael<br></p><p>&gt; <br>&gt; Another solution could be some kind of wrapper struct/class which has the array as a property and checkTree as a method.<br>&gt; This way checkTree would only access the property and additional retains/releases would not be necessary.<br>&gt; <br>&gt; [1] https://github.com/apple/swift/blob/master/docs/SIL.rst#reference-counts &lt;https://github.com/apple/swift/blob/master/docs/SIL.rst#reference-counts&gt;<br>&gt; [2] https://github.com/apple/swift/blob/master/docs/SIL.rst#inout-arguments &lt;https://github.com/apple/swift/blob/master/docs/SIL.rst#inout-arguments&gt;<br>&gt; <br>&gt; <br>&gt;&gt; On 20.12.2015, at 17:12, Janosch Hildebrand via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Basically just rewrite a C example in Swift; not pretty but it should also perform very much like C then.<br>&gt; <br>&gt; <br>&gt; Someone has done this and is now in second place:<br>&gt; http://benchmarksgame.alioth.debian.org/u64q/program.php?test=binarytrees&amp;lang=swift&amp;id=5 &lt;http://benchmarksgame.alioth.debian.org/u64q/program.php?test=binarytrees&amp;lang=swift&amp;id=5&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151222/d127c655/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d145b9824a2bfc8aa2f3297f3a555e6?s=50"></div><header><strong>problems with simple binary-trees program</strong> from <string>Pascal Urban</string> &lt;mail at pscl.de&gt;<p>December 23, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On 22.12.2015, at 21:40, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 2:31 PM, Pascal Urban via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 20.12.2015, at 19:54, Maurus Kühne via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; …<br>&gt;&gt;&gt; I was able to speed up David’s solution by almost 50% by changing the method checkTree from this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func checkTree(t: Array&lt;TreeNodeItem&gt;, _ i: Int) -&gt; Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; to this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func checkTree(inout t: Array&lt;TreeNodeItem&gt;, _ i: Int) -&gt; Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It completes in about ~10s instead of ~20s on my 2.66GHz i5 iMac for n=20. <br>&gt;&gt;&gt; This also works together with Pascal’s libdispatch solution. In this case it completes in ~5s.<br>&gt;&gt;&gt; Here is the modified version: https://gist.github.com/mauruskuehne/633789417c2357a6bb93 &lt;https://gist.github.com/mauruskuehne/633789417c2357a6bb93&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Could somebody explain to me why this is the case? I know what the inout keyword does, but I don’t understand why it makes the code faster in this case?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maurus<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Like Janosch said: ARC overhead<br>&gt;&gt; <br>&gt;&gt; So here is whats happening:<br>&gt;&gt; A function reference parameter gets retained before calling the function and then released within the called function (generally), so the function is taking ownership of the parameter. [1]<br>&gt;&gt; If a parameter is marked with the inout keyword the function does not take ownership of the reference parameter, so no retains and releases. [2]<br>&gt;&gt; <br>&gt;&gt; Given how often checkTree is called the retains and releases of the array get quiet expensive.<br>&gt;&gt; You can see this quiet nicely while profiling these functions in Instruments using the time profiler.<br>&gt;&gt; <br>&gt;&gt; I think normally this shouldn&#39;t be a problem, but because of the recursion the compiler is not able to optimize the retain and release calls.<br>&gt; <br>&gt; This is not true. We can hit this case. It requires further work in the ARC optimizer. We some time ago actually did have the functionality to hit this case, but I had to disable it b/c of some correctness issues.<br>&gt; <br>&gt; File a bug with this test case and assign to me.<br></p><p>Nice. I figured that this would be optimized in the future.<br>Filed as SR-356 with a simplified test case.<br></p><p>&gt; Michael<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Another solution could be some kind of wrapper struct/class which has the array as a property and checkTree as a method.<br>&gt;&gt; This way checkTree would only access the property and additional retains/releases would not be necessary.<br>&gt;&gt; <br>&gt;&gt; [1] https://github.com/apple/swift/blob/master/docs/SIL.rst#reference-counts &lt;https://github.com/apple/swift/blob/master/docs/SIL.rst#reference-counts&gt;<br>&gt;&gt; [2] https://github.com/apple/swift/blob/master/docs/SIL.rst#inout-arguments &lt;https://github.com/apple/swift/blob/master/docs/SIL.rst#inout-arguments&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 20.12.2015, at 17:12, Janosch Hildebrand via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Basically just rewrite a C example in Swift; not pretty but it should also perform very much like C then.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Someone has done this and is now in second place:<br>&gt;&gt; http://benchmarksgame.alioth.debian.org/u64q/program.php?test=binarytrees&amp;lang=swift&amp;id=5 &lt;http://benchmarksgame.alioth.debian.org/u64q/program.php?test=binarytrees&amp;lang=swift&amp;id=5&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151223/fc1fc33e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>problems with simple binary-trees program</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 11:32 AM, Pascal Urban &lt;mail at pscl.de&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 22.12.2015, at 21:40, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 22, 2015, at 2:31 PM, Pascal Urban via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 20.12.2015, at 19:54, Maurus Kühne via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt; I was able to speed up David’s solution by almost 50% by changing the method checkTree from this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func checkTree(t: Array&lt;TreeNodeItem&gt;, _ i: Int) -&gt; Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; to this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func checkTree(inout t: Array&lt;TreeNodeItem&gt;, _ i: Int) -&gt; Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It completes in about ~10s instead of ~20s on my 2.66GHz i5 iMac for n=20. <br>&gt;&gt;&gt;&gt; This also works together with Pascal’s libdispatch solution. In this case it completes in ~5s.<br>&gt;&gt;&gt;&gt; Here is the modified version: https://gist.github.com/mauruskuehne/633789417c2357a6bb93 &lt;https://gist.github.com/mauruskuehne/633789417c2357a6bb93&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Could somebody explain to me why this is the case? I know what the inout keyword does, but I don’t understand why it makes the code faster in this case?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Maurus<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Like Janosch said: ARC overhead<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So here is whats happening:<br>&gt;&gt;&gt; A function reference parameter gets retained before calling the function and then released within the called function (generally), so the function is taking ownership of the parameter. [1]<br>&gt;&gt;&gt; If a parameter is marked with the inout keyword the function does not take ownership of the reference parameter, so no retains and releases. [2]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given how often checkTree is called the retains and releases of the array get quiet expensive.<br>&gt;&gt;&gt; You can see this quiet nicely while profiling these functions in Instruments using the time profiler.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think normally this shouldn&#39;t be a problem, but because of the recursion the compiler is not able to optimize the retain and release calls.<br>&gt;&gt; <br>&gt;&gt; This is not true. We can hit this case. It requires further work in the ARC optimizer. We some time ago actually did have the functionality to hit this case, but I had to disable it b/c of some correctness issues.<br>&gt;&gt; <br>&gt;&gt; File a bug with this test case and assign to me.<br>&gt; <br>&gt; Nice. I figured that this would be optimized in the future.<br>&gt; Filed as SR-356 with a simplified test case.<br>&gt; <br></p><p>Thanks!<br></p><p>Michael<br></p><p>&gt;&gt; Michael<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another solution could be some kind of wrapper struct/class which has the array as a property and checkTree as a method.<br>&gt;&gt;&gt; This way checkTree would only access the property and additional retains/releases would not be necessary.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [1] https://github.com/apple/swift/blob/master/docs/SIL.rst#reference-counts &lt;https://github.com/apple/swift/blob/master/docs/SIL.rst#reference-counts&gt;<br>&gt;&gt;&gt; [2] https://github.com/apple/swift/blob/master/docs/SIL.rst#inout-arguments &lt;https://github.com/apple/swift/blob/master/docs/SIL.rst#inout-arguments&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 20.12.2015, at 17:12, Janosch Hildebrand via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Basically just rewrite a C example in Swift; not pretty but it should also perform very much like C then.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Someone has done this and is now in second place:<br>&gt;&gt;&gt; http://benchmarksgame.alioth.debian.org/u64q/program.php?test=binarytrees&amp;lang=swift&amp;id=5 &lt;http://benchmarksgame.alioth.debian.org/u64q/program.php?test=binarytrees&amp;lang=swift&amp;id=5&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151223/d1be1e09/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
