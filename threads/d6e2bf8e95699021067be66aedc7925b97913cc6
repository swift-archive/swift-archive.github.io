<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>C Macros and Variadic functions</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>January  5, 2016 at 02:00:00pm</p></header><div class="content"><p>I&#39;m beginning to try to port some of my existing C code over to Swift<br>(you have no idea how excited that makes me). Unfortunately, I&#39;ve hit a<br>stumbling block.<br></p><p>When interacting with some of the system/hardware interfaces in Linux it<br>sometimes (often?) becomes necessary to interact with I/O Control<br>(ioctl). This introduces two complexities that at least appear to me as<br>needing resolution.<br></p><p>The first is C macros. A lot ioctl interfaces use headers which define<br>macros that are specific ioctl request operations. These macros<br>typically take the form of `_IO`, `_IOR` or `_IOW` (there are more but<br>this should give you a picture). These values are typically bound to a<br>specific kernel version and thus are subject to change. I point that out<br>because obviously one could just calculate the value and hard-code it<br>into the Swift source (which is what I plan to do in the short term) but<br>this isn&#39;t really a portable solution across kernels. The question is<br>what, if anything, is planned around this?<br></p><p>The second is variadic C functions. In my case I went ahead and<br>calculated the result of a C macro and hard coded it into a Swift<br>variable (e.g., `let DMX_SET_BUFFER_SIZE: CUnsignedInt = 28461`). This<br>was so I could send it to an ioctl call (e.g., `ioctl(fileReference!,<br>DMX_SET_BUFFER_SIZE, DVBDVR.DVR_BUFFER_SIZE)`). Unfortunately, this died<br>in the compiler with `error: &#39;ioctl&#39; is unavailable: Variadic function<br>is unavailable`. The interesting part of the compiler error was this<br>though `SwiftGlibc.ioctl:2:13: note: &#39;ioctl&#39; has been explicitly marked<br>unavailable here`. This seems to imply that it _could_ be on and it just<br>isn&#39;t. I searched around a bit and found a few PRs [1] [2] [3] that seem<br>to indicate that Swift does support variadic C functions. Is there a<br>reason why ioctl is not?<br></p><p>Sorry if this has been asked or addressed before but I&#39;m at a loss as to<br>how to search these mailing lists.<br></p><p>[1] https://github.com/apple/swift/pull/196<br>[2] https://github.com/apple/swift/pull/413<br>[3] https://github.com/apple/swift-evolution/pull/38<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3cc60df2d77f658efe8b66631a58b2fd?s=50"></div><header><strong>C Macros and Variadic functions</strong> from <string>Xi Ge</string> &lt;xi_ge at apple.com&gt;<p>January  5, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 11:54 AM, Ryan Lovelett via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m beginning to try to port some of my existing C code over to Swift<br>&gt; (you have no idea how excited that makes me). Unfortunately, I&#39;ve hit a<br>&gt; stumbling block.<br>&gt; <br>&gt; When interacting with some of the system/hardware interfaces in Linux it<br>&gt; sometimes (often?) becomes necessary to interact with I/O Control<br>&gt; (ioctl). This introduces two complexities that at least appear to me as<br>&gt; needing resolution.<br>&gt; <br>&gt; The first is C macros. A lot ioctl interfaces use headers which define<br>&gt; macros that are specific ioctl request operations. These macros<br>&gt; typically take the form of `_IO`, `_IOR` or `_IOW` (there are more but<br>&gt; this should give you a picture). These values are typically bound to a<br>&gt; specific kernel version and thus are subject to change. I point that out<br>&gt; because obviously one could just calculate the value and hard-code it<br>&gt; into the Swift source (which is what I plan to do in the short term) but<br>&gt; this isn&#39;t really a portable solution across kernels. The question is<br>&gt; what, if anything, is planned around this?<br>&gt; <br>&gt; The second is variadic C functions. In my case I went ahead and<br>&gt; calculated the result of a C macro and hard coded it into a Swift<br>&gt; variable (e.g., `let DMX_SET_BUFFER_SIZE: CUnsignedInt = 28461`). This<br>&gt; was so I could send it to an ioctl call (e.g., `ioctl(fileReference!,<br>&gt; DMX_SET_BUFFER_SIZE, DVBDVR.DVR_BUFFER_SIZE)`). Unfortunately, this died<br>&gt; in the compiler with `error: &#39;ioctl&#39; is unavailable: Variadic function<br>&gt; is unavailable`. The interesting part of the compiler error was this<br>&gt; though `SwiftGlibc.ioctl:2:13: note: &#39;ioctl&#39; has been explicitly marked<br>&gt; unavailable here`. This seems to imply that it _could_ be on and it just<br>&gt; isn&#39;t. I searched around a bit and found a few PRs [1] [2] [3] that seem<br>&gt; to indicate that Swift does support variadic C functions. Is there a<br>&gt; reason why ioctl is not?<br></p><p>Though generally unavailable as variadic C functions (Jordan might be the better person to explain why), <br>we still have other reasons to import them as unavailable functions instead of ignoring them. One example is for printing<br>the complete interface of the underlying Clang module. This message does NOT imply the variadic function is available<br>in certain circumstances. Do you any suggestions about better error message?<br></p><p><br>&gt; <br>&gt; Sorry if this has been asked or addressed before but I&#39;m at a loss as to<br>&gt; how to search these mailing lists.<br>&gt; <br>&gt; [1] https://github.com/apple/swift/pull/196<br>&gt; [2] https://github.com/apple/swift/pull/413<br>&gt; [3] https://github.com/apple/swift-evolution/pull/38<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>C Macros and Variadic functions</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>January  5, 2016 at 03:00:00pm</p></header><div class="content"><p>Response inline:<br></p><p>On Tue, Jan 5, 2016, at 03:12 PM, Xi Ge wrote:<br>&gt; <br>&gt; &gt; On Jan 5, 2016, at 11:54 AM, Ryan Lovelett via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; I&#39;m beginning to try to port some of my existing C code over to Swift<br>&gt; &gt; (you have no idea how excited that makes me). Unfortunately, I&#39;ve hit a<br>&gt; &gt; stumbling block.<br>&gt; &gt; <br>&gt; &gt; When interacting with some of the system/hardware interfaces in Linux it<br>&gt; &gt; sometimes (often?) becomes necessary to interact with I/O Control<br>&gt; &gt; (ioctl). This introduces two complexities that at least appear to me as<br>&gt; &gt; needing resolution.<br>&gt; &gt; <br>&gt; &gt; The first is C macros. A lot ioctl interfaces use headers which define<br>&gt; &gt; macros that are specific ioctl request operations. These macros<br>&gt; &gt; typically take the form of `_IO`, `_IOR` or `_IOW` (there are more but<br>&gt; &gt; this should give you a picture). These values are typically bound to a<br>&gt; &gt; specific kernel version and thus are subject to change. I point that out<br>&gt; &gt; because obviously one could just calculate the value and hard-code it<br>&gt; &gt; into the Swift source (which is what I plan to do in the short term) but<br>&gt; &gt; this isn&#39;t really a portable solution across kernels. The question is<br>&gt; &gt; what, if anything, is planned around this?<br>&gt; &gt; <br>&gt; &gt; The second is variadic C functions. In my case I went ahead and<br>&gt; &gt; calculated the result of a C macro and hard coded it into a Swift<br>&gt; &gt; variable (e.g., `let DMX_SET_BUFFER_SIZE: CUnsignedInt = 28461`). This<br>&gt; &gt; was so I could send it to an ioctl call (e.g., `ioctl(fileReference!,<br>&gt; &gt; DMX_SET_BUFFER_SIZE, DVBDVR.DVR_BUFFER_SIZE)`). Unfortunately, this died<br>&gt; &gt; in the compiler with `error: &#39;ioctl&#39; is unavailable: Variadic function<br>&gt; &gt; is unavailable`. The interesting part of the compiler error was this<br>&gt; &gt; though `SwiftGlibc.ioctl:2:13: note: &#39;ioctl&#39; has been explicitly marked<br>&gt; &gt; unavailable here`. This seems to imply that it _could_ be on and it just<br>&gt; &gt; isn&#39;t. I searched around a bit and found a few PRs [1] [2] [3] that seem<br>&gt; &gt; to indicate that Swift does support variadic C functions. Is there a<br>&gt; &gt; reason why ioctl is not?<br>&gt; <br>&gt; Though generally unavailable as variadic C functions (Jordan might be the<br>&gt; better person to explain why), <br>&gt; we still have other reasons to import them as unavailable functions<br>&gt; instead of ignoring them. One example is for printing<br>&gt; the complete interface of the underlying Clang module. This message does<br>&gt; NOT imply the variadic function is available<br>&gt; in certain circumstances. Do you any suggestions about better error<br>&gt; message?<br>&gt; <br></p><p>Not exactly the take-away that I was expecting to my question. That<br>having been said, the part that made my feel like it _could_ and wasn&#39;t<br>was the note. What is the point of the note, if not to say, &quot;Hey we know<br>this is a variadic function and that&#39;s why we&#39;ve disabled it.&quot;? Which to<br>me implicitly says this could be enabled in the future just, for<br>whatever reason, not right now. Therefore, my recommendation would be<br>just to drop the note. The compiler error was enough to say variadic C<br>functions are unavailable.<br>&gt; <br>&gt; &gt; <br>&gt; &gt; Sorry if this has been asked or addressed before but I&#39;m at a loss as to<br>&gt; &gt; how to search these mailing lists.<br>&gt; &gt; <br>&gt; &gt; [1] https://github.com/apple/swift/pull/196<br>&gt; &gt; [2] https://github.com/apple/swift/pull/413<br>&gt; &gt; [3] https://github.com/apple/swift-evolution/pull/38<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-dev mailing list<br>&gt; &gt; swift-dev at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br></p><p>Just to be clear though the intent of my question was not to quibble<br>with compiler error messages. My real question is how are we meant to do<br>systems programming with Swift on Linux if we cannot call ioctl?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f6cba1dba694e74dc891489a2a4d921?s=50"></div><header><strong>C Macros and Variadic functions</strong> from <string>Kate Stone</string> &lt;katherine_stone at apple.com&gt;<p>January  5, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 12:32 PM, Ryan Lovelett via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Just to be clear though the intent of my question was not to quibble<br>&gt; with compiler error messages. My real question is how are we meant to do<br>&gt; systems programming with Swift on Linux if we cannot call ioctl?<br></p><p>In the absence of an automatic mechanism for importing the definition of variadic functions you can still define your own prototypes and bind them to the system implementation.  For example, this declaration:<br></p><p>@_silgen_name(&quot;ioctl&quot;) func ioctl(fildes: CInt, request: UInt64, result: UnsafePointer&lt;Int&gt;) -&gt; Int<br></p><p>… gives you a non-variadic interface to ioctl that you can use for invocations that conform to this specific convention.  You can define as many overloads as you wish, and so long as you’re cautious about which one you’re using for a given request you should be able to make progress.<br></p><p>The same basic strategy can be applied to any variadic functional interfaces.  Ideally you’d want to hide this implementation detail behind a more Swift-friendly API where the request type is implied to create a more type-safe interface.<br></p><p>Kate Stone k8stone at apple.com &lt;mailto:k8stone at apple.com&gt;<br> Xcode Low Level Tools<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160105/1eef0161/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>C Macros and Variadic functions</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>January  5, 2016 at 09:00:00pm</p></header><div class="content"><p>First off thanks for the help.<br></p><p>No doubt I&#39;m doing something wrong. I wish I could help debug my own<br>problem but I don&#39;t really get what @_silgen_name does. That seems like<br>black magic to me.<br></p><p>That compiled though now it won&#39;t link. I&#39;ve put the code up as a<br>Gist here[1].<br></p><p>$ swift build Linking Executable:  .build/debug/CastableLive /home/ryan/Source/castable-<br>live/.build/debug/CastableLive.o/main.swift.o: In function<br>`_TFC12CastableLive6DVBDVRcfT7adapterSi6numberSi_GSqS0__&#39;: /home/ryan/Source/castable-<br>live/main.swift:40: undefined reference to `ioctl&#39; /usr/bin/ld: /home/ryan/Source/castable-<br>live/.build/debug/CastableLive: hidden symbol `ioctl&#39; isn&#39;t defined<br>/usr/bin/ld: final link failed: Bad value clang-3.7: error: linker<br>command failed with exit code 1 (use -v to see invocation) &lt;unknown&gt;:0:<br>error: link command failed with exit code 1 (use -v to see invocation)<br>&lt;unknown&gt;:0: error: build had 1 command failures error: exit(1): [&quot;/usr/bin/swift-build-<br>tool&quot;, &quot;-f&quot;, &quot;/home/ryan/Source/castable-<br>live/.build/debug/CastableLive.o/llbuild.yaml&quot;]<br></p><p>On Tue, Jan 5, 2016, at 04:57 PM, Kate Stone wrote:<br>&gt;&gt; On Jan 5, 2016, at 12:32 PM, Ryan Lovelett via swift-dev &lt;swift-<br>&gt;&gt; dev at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Just to be clear though the intent of my question was not to quibble<br>&gt;&gt; with compiler error messages. My real question is how are we meant to<br>&gt;&gt; do systems programming with Swift on Linux if we cannot call ioctl?<br>&gt; In the absence of an automatic mechanism for importing the definition<br>&gt; of variadic functions you can still define your own prototypes and<br>&gt; bind them to the system implementation.  For example, this<br>&gt; declaration:<br>&gt;<br>&gt; @_silgen_name(&quot;ioctl&quot;) func ioctl(fildes: CInt, request: UInt64,<br>&gt; result: UnsafePointer&lt;Int&gt;) -&gt; Int<br>&gt;<br>&gt; … gives you a non-variadic interface to ioctl that you can use for<br>&gt; invocations that conform to this specific convention.  You can define<br>&gt; as many overloads as you wish, and so long as you’re cautious about<br>&gt; which one you’re using for a given request you should be able to make<br>&gt; progress.<br>&gt;<br>&gt; The same basic strategy can be applied to any variadic functional<br>&gt; interfaces.  Ideally you’d want to hide this implementation detail<br>&gt; behind a more Swift-friendly API where the request type is implied to<br>&gt; create a more type-safe interface.<br>&gt;<br>&gt; Kate Stonek8stone at apple.com  Xcode Low Level Tools<br>&gt;<br></p><p><br></p><p>Links:<br></p><p>  1. https://gist.github.com/anonymous/4861aba2280251fe57c6<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160105/2f4a38bd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>C Macros and Variadic functions</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 1:57 PM, Kate Stone via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 5, 2016, at 12:32 PM, Ryan Lovelett via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Just to be clear though the intent of my question was not to quibble<br>&gt;&gt; with compiler error messages. My real question is how are we meant to do<br>&gt;&gt; systems programming with Swift on Linux if we cannot call ioctl?<br>&gt; <br>&gt; In the absence of an automatic mechanism for importing the definition of variadic functions you can still define your own prototypes and bind them to the system implementation.  For example, this declaration:<br>&gt; <br>&gt; @_silgen_name(&quot;ioctl&quot;) func ioctl(fildes: CInt, request: UInt64, result: UnsafePointer&lt;Int&gt;) -&gt; Int<br>&gt; <br>&gt; … gives you a non-variadic interface to ioctl that you can use for invocations that conform to this specific convention.  You can define as many overloads as you wish, and so long as you’re cautious about which one you’re using for a given request you should be able to make progress.<br>&gt; <br>&gt; The same basic strategy can be applied to any variadic functional interfaces.  Ideally you’d want to hide this implementation detail behind a more Swift-friendly API where the request type is implied to create a more type-safe interface.<br></p><p>Don&#39;t do this. User code never has any business using underscored attributes. @_silgen_name produces an external reference to a Swift function, with Swift&#39;s calling convention.  It cannot be safely used to refer to C functions, especially not variadic ones, since the convention for variadics in C is also different from non-variadic C functions. For variadic functions, you should write non-variadic wrappers in C (which can be static inline, to avoid wrapping overhead in production builds) and import them as Clang modules. See how open and fcntl are exported by the Darwin and Glibc overlays for an example.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160106/994e4e0d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f6cba1dba694e74dc891489a2a4d921?s=50"></div><header><strong>C Macros and Variadic functions</strong> from <string>Kate Stone</string> &lt;katherine_stone at apple.com&gt;<p>January  6, 2016 at 11:00:00am</p></header><div class="content"><p>Apologies for the poor guidance.  I had success with this path much earlier in Swift’s evolution and I’m clearly not up to date on the latest recommendations.  Joe’s approach is definitely the right way to go.<br></p><p>Kate Stone k8stone at apple.com &lt;mailto:k8stone at apple.com&gt;<br> Xcode Low Level Tools<br></p><p>&gt; On Jan 6, 2016, at 11:18 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 5, 2016, at 1:57 PM, Kate Stone via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 5, 2016, at 12:32 PM, Ryan Lovelett via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just to be clear though the intent of my question was not to quibble<br>&gt;&gt;&gt; with compiler error messages. My real question is how are we meant to do<br>&gt;&gt;&gt; systems programming with Swift on Linux if we cannot call ioctl?<br>&gt;&gt; <br>&gt;&gt; In the absence of an automatic mechanism for importing the definition of variadic functions you can still define your own prototypes and bind them to the system implementation.  For example, this declaration:<br>&gt;&gt; <br>&gt;&gt; @_silgen_name(&quot;ioctl&quot;) func ioctl(fildes: CInt, request: UInt64, result: UnsafePointer&lt;Int&gt;) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; … gives you a non-variadic interface to ioctl that you can use for invocations that conform to this specific convention.  You can define as many overloads as you wish, and so long as you’re cautious about which one you’re using for a given request you should be able to make progress.<br>&gt;&gt; <br>&gt;&gt; The same basic strategy can be applied to any variadic functional interfaces.  Ideally you’d want to hide this implementation detail behind a more Swift-friendly API where the request type is implied to create a more type-safe interface.<br>&gt; <br>&gt; Don&#39;t do this. User code never has any business using underscored attributes. @_silgen_name produces an external reference to a Swift function, with Swift&#39;s calling convention.  It cannot be safely used to refer to C functions, especially not variadic ones, since the convention for variadics in C is also different from non-variadic C functions. For variadic functions, you should write non-variadic wrappers in C (which can be static inline, to avoid wrapping overhead in production builds) and import them as Clang modules. See how open and fcntl are exported by the Darwin and Glibc overlays for an example.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160106/7a9d49dd/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dc0180c1b9aff52f5d42a1ca6bd1f184?s=50"></div><header><strong>C Macros and Variadic functions</strong> from <string>Thomas Catterall</string> &lt;me at swizzlr.co&gt;<p>January  6, 2016 at 07:00:00pm</p></header><div class="content"><p>It seems to me that an interesting tool in the swift toolchain would be one that could generate implementations of methods in circumstances like this, using, for instance, CPP macros as hints for function prototypes. Then again, I might be entirely wrong and I&#39;d be happy to be corrected!<br></p><p>Tom<br></p><p>Sent from my iPhone<br></p><p>&gt; On 5 Jan 2016, at 16:57, Kate Stone &lt;katherine_stone at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 5, 2016, at 12:32 PM, Ryan Lovelett via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Just to be clear though the intent of my question was not to quibble<br>&gt;&gt; with compiler error messages. My real question is how are we meant to do<br>&gt;&gt; systems programming with Swift on Linux if we cannot call ioctl?<br>&gt; <br>&gt; In the absence of an automatic mechanism for importing the definition of variadic functions you can still define your own prototypes and bind them to the system implementation.  For example, this declaration:<br>&gt; <br>&gt; @_silgen_name(&quot;ioctl&quot;) func ioctl(fildes: CInt, request: UInt64, result: UnsafePointer&lt;Int&gt;) -&gt; Int<br>&gt; <br>&gt; … gives you a non-variadic interface to ioctl that you can use for invocations that conform to this specific convention.  You can define as many overloads as you wish, and so long as you’re cautious about which one you’re using for a given request you should be able to make progress.<br>&gt; <br>&gt; The same basic strategy can be applied to any variadic functional interfaces.  Ideally you’d want to hide this implementation detail behind a more Swift-friendly API where the request type is implied to create a more type-safe interface.<br>&gt; <br>&gt; Kate Stone k8stone at apple.com<br>&gt;  Xcode Low Level Tools<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160106/da85a2e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>C Macros and Variadic functions</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 13, 2016 at 10:00:00am</p></header><div class="content"><p>Hi, all. I&#39;ll try to shed some light on both macros and variadic functions.<br></p><p>Macros are the easy ones. Obviously, a macro like this can&#39;t be imported as a function:<br></p><p>#define UNIQUE_NAME(prefix) prefix##__COUNTER__<br></p><p>But here&#39;s a trickier one:<br></p><p>#define NAME(windowStruct) windowStruct.attrs-&gt;name<br></p><p>In this case, there&#39;s probably a pair of structs in mind, one with an &#39;attrs&#39; field, and one with a &#39;name&#39; field. But the compiler can&#39;t know that just from the macro. In fact, the macro may be intended for use over many structs, all with an &#39;attrs&#39; field (much like C++ templates). Swift can&#39;t express this.<br></p><p>We&#39;d definitely be glad to improve our handling of macros that are unambiguous, but importing all macros is not a goal we can ever reach. In most cases, the best workaround is to write a static inline C function that just calls through to the macro.<br></p><p>---<br></p><p>Okay, C variadics. The main problem with C variadics is that they&#39;re antithetical to Swift&#39;s idea of memory safety. I mean, sure, calling any C function means you&#39;re stepping outside Swift&#39;s safety, but at least the call is well-typed, and if you&#39;re trafficking in UnsafePointer, the function says so (and you probably had to make or get one at the call site). With a variadic function, you can pass total garbage and not be aware of it, and the function will just crash.<br></p><p>A practical problem with C variadics is that they&#39;re at odds with Swift&#39;s variadics model. Swift variadics, like C# or Java, specify a particular type for all of the variadic arguments—they&#39;re all Strings, or Ints, or AnyObjects. C variadics, on the other hand, allow a mix of types, and they&#39;re all passed differently. Now, we can certainly do this—we do have Clang, after all—but it&#39;s Yet Another Difference between Swift and C that people might have to think about. (For variadics with null sentinels &lt;https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-g_t_0040code_007bsentinel_007d-function-attribute-3219&gt;, does the compiler insert the sentinel? Does it check whether one of the values is nil? What if it&#39;s alternating value-key pairs &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSDictionary_Class/index.html#//apple_ref/occ/instm/NSDictionary/initWithObjectsAndKeys:&gt;?)<br></p><p>That&#39;s mostly it. They&#39;re even less safe than the rest of C, and they make things more complicated in Swift. As of Swift 2.2 we do at least import them as unavailable instead of missing entirely, so you get a reasonable error message (as Ryan noticed). It&#39;s a lot easier to do that than to actually implement it, though; we basically fake it with a Swift variadic function that has the same signature.<br></p><p>We do import the &#39;va_list&#39; type, and there&#39;s a helper in the standard library, &#39;withVaList&#39;, to safely build a va_list that you can pass to a C function. That&#39;s mostly intended for providing a Swift variadic interface that calls through to the underlying implementation. (It&#39;s very platform-specific code.) If a function doesn&#39;t have a va_list variant, however, Joe&#39;s right that the only correct workaround today is, again, a static inline C function. (If you look at the particular pull requests Ryan called out, you&#39;ll see they all shim to a C function to do exactly this.)<br></p><p><br>I hope this clears up some of the issues in both areas. They&#39;re not happy answers, and like everything there&#39;s probably room for improvement, but they are areas with enough complexity that we&#39;d need to be careful about changing them.<br></p><p>Jordan<br></p><p><br>&gt; On Jan 6, 2016, at 16:28 , Thomas Catterall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; It seems to me that an interesting tool in the swift toolchain would be one that could generate implementations of methods in circumstances like this, using, for instance, CPP macros as hints for function prototypes. Then again, I might be entirely wrong and I&#39;d be happy to be corrected!<br>&gt; <br>&gt; Tom<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On 5 Jan 2016, at 16:57, Kate Stone &lt;katherine_stone at apple.com &lt;mailto:katherine_stone at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jan 5, 2016, at 12:32 PM, Ryan Lovelett via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just to be clear though the intent of my question was not to quibble<br>&gt;&gt;&gt; with compiler error messages. My real question is how are we meant to do<br>&gt;&gt;&gt; systems programming with Swift on Linux if we cannot call ioctl?<br>&gt;&gt; <br>&gt;&gt; In the absence of an automatic mechanism for importing the definition of variadic functions you can still define your own prototypes and bind them to the system implementation.  For example, this declaration:<br>&gt;&gt; <br>&gt;&gt; @_silgen_name(&quot;ioctl&quot;) func ioctl(fildes: CInt, request: UInt64, result: UnsafePointer&lt;Int&gt;) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; … gives you a non-variadic interface to ioctl that you can use for invocations that conform to this specific convention.  You can define as many overloads as you wish, and so long as you’re cautious about which one you’re using for a given request you should be able to make progress.<br>&gt;&gt; <br>&gt;&gt; The same basic strategy can be applied to any variadic functional interfaces.  Ideally you’d want to hide this implementation detail behind a more Swift-friendly API where the request type is implied to create a more type-safe interface.<br>&gt;&gt; <br>&gt;&gt; Kate Stone k8stone at apple.com &lt;mailto:k8stone at apple.com&gt;<br>&gt;&gt;  Xcode Low Level Tools<br>&gt;&gt; <br>&gt;  _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160113/f766926c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
