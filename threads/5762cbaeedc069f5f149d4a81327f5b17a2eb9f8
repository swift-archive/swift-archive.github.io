<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 25, 2016 at 07:00:00pm</p></header><div class="content"><p>Am 25. Februar 2016 um 02:27 schrieb Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br></p><p>&gt;&gt; Unfortunately, the protocol does not cover all of the cases where a developer might want to specify an interface to be implemented by another entity.<br>&gt;&gt; <br>&gt;&gt; For example, consider the class, which allows the creation of an inheritance hierarchy. Often, a class in a hierarchy exists merely to provide a common implementation to subclasses. Such classes aren&#39;t ever intended to be instantiated directly; only subclasses will be instantiated.<br>&gt;&gt; <br>&gt;&gt; To illustrate the point, imagine a view controller class that:<br>&gt;&gt; <br>&gt;&gt;        • Places an animating UIActivityIndicatorView onscreen<br>&gt;&gt;    • Performs some operation to retrieve some text<br>&gt;&gt;  • Puts the text in a UITextView and places it onscreen<br>&gt;&gt;        • Hides the UIActivityIndicatorView<br>&gt;&gt; Now imagine you had many cases in your application where you could benefit from such a view controller, and each case differed only in the operation required to retrieve the text (represented by Step 2 above).<br>&gt;&gt; <br>&gt;&gt; Ideally, you would be able to achieve this by declaring the interface for a function without needing to specify an implementation, the same way you would with a protocol:<br>&gt;&gt; <br>&gt;&gt; func retrieveText() -&gt; String<br>&gt;&gt; In other languages, such as C++, this concept exists in the form of an abstract class. However, Swift does not support this, so developers are forced to provide useless implementations such as:<br>&gt;&gt; <br>&gt;&gt; func retrieveText() -&gt; String<br>&gt;&gt; <br>&gt;&gt; {<br>&gt;&gt; fatalError(<br>&gt;&gt; &quot;Subclasses must implement retrieveText()&quot;<br>&gt;&gt; )<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The idea here is that subclasses should always provide a retrieveText() implementation, and therefore the call to fatalError() should never be hit.<br>&gt;&gt; <br>&gt;&gt; This has a few significant downsides:<br>&gt;&gt; <br>&gt;&gt;  • It forces the developer to write code that should never be executed under normal conditions. This seems like a waste.<br>&gt;&gt; <br>&gt;&gt;      • Because a default implementation is provided--the one that calls fatalError()--the compiler has no way of knowing that the subclasses are supposed to provide an implementation, too.<br>&gt;&gt; <br>&gt;&gt;      • If a subclass implementor forgets to provide a retrieveText() function, the error will not be caught until runtime, and not until a user navigates to the affected portion of the application. This may not occur until the application has shipped.<br>&gt; <br>&gt; That&#39;s one alternative, yes. Others include:<br>&gt; <br>&gt; 1. Having a delegate provide the `retrieveText()` method.<br>&gt; <br>&gt; 2. Having a closure property implement the `retrieveText()` method.<br></p><p><br>Sorry, but I fail to understand your argument here. Both of these require implementing the abstract method and thereby filling in the concrete behavior, e.g.<br></p><p>func retrieveText() -&gt; String {<br>        return delegate.retrieveTextFor(self) // or whatever<br>}<br></p><p>Or do you mean, that you would already require a delegate when defining the base class?<br></p><p><br>&gt; <br>&gt; 3. Declaring a protocol `ActivityViewControlling` that requires `retrieveText()` and adding the other logic in an `extension ActivityViewControlling where Self: UIViewController`.<br>&gt; <br>&gt; I think that 1 or 2 are usually the best way to handle something like this,<br></p><p>I disagree. While delegates (and a closure property is just a delegate as well) are great for dynamically providing a specific behavior (Strategy Pattern) I don’t think using a delegate is the right thing to do for statically providing the behavior. That’s what abstract classes and abstract methods/properties are for.<br></p><p>Example:<br>When writing a generic graph traversal of a certain kind I can abstract the collection to be used for vertices that have been discovered and wait to be visited. Using a queue I get breadth first traversal while using a stack I get depth first traversal. Modeling that collection as abstract property I can then subclass both kinds of traversal easily fixing the type of the collection statically. It would not make sense to plugin a collection dynamically IMO as I want to have strongly typed BFSTraversal and DFSTraversal implementations in my model.<br></p><p><br></p><p>&gt; but let&#39;s explore 3 for a minute, because that&#39;s a place where Swift could probably be improved.<br>&gt; <br>&gt; Currently, Swift allows you to constrain a protocol to only class types:<br>&gt; <br>&gt;        protocol ActivityViewControlling: class {<br>&gt;          func retrieveText() -&gt; String<br>&gt;        }<br>&gt;      extension ActivityViewControlling where Self: UIViewController {<br>&gt;            ...<br>&gt;  }<br>&gt;  class MyActivityViewController: UIViewController, ActivityViewControlling {<br>&gt;          func retrieveText() -&gt; String { ... }<br>&gt;        }<br>&gt; <br>&gt; But when you do that, Swift permits you to use any class type, which is a bit weird semantically—ActivityViewControlling can be applied to any class, but it&#39;s really only meant to be applied to subclasses of UIViewController. An ActivityViewControlling type which isn&#39;t a view controller is kind of meaningless.<br>&gt; <br>&gt;        // Why can I do this?<br>&gt;      class PossibleButUseless: ActivityViewControlling {<br>&gt;          func retrieveText() -&gt; String { ... }<br>&gt;        }<br>&gt; <br>&gt; Suppose instead we allow a protocol to require that the conforming class inherit from another class. We could then omit the `where` clause and possibly even make the inheritance itself implicit in conforming to the protocol:<br>&gt; <br>&gt;      protocol ActivityViewControlling: UIViewController {<br>&gt;            func retrieveText() -&gt; String<br>&gt;        }<br>&gt;      extension ActivityViewControlling {<br>&gt;          ...<br>&gt;  }<br>&gt;  class MyActivityViewController: ActivityViewControlling {<br>&gt;      func retrieveText() -&gt; String { ... }<br>&gt;        }<br>&gt; <br>&gt; This would also relieve some of the pressure on us to support class-plus-protocol typed variables. In many of these cases, *all* types conforming to the protocol should be subclasses of a particular class, but there&#39;s no way to express that in the type system. Subclass-only protocols would correct that shortcoming.<br>&gt; <br>&gt; Subclass-only protocols would cover most, if not all, of the use cases of abstract classes, but I think they would be a less dramatic change to Swift, because protocols are already types which can&#39;t be instantiated and impose requirements on their subtypes. I therefore believe they would be a better, more Swift-like approach to the problem abstract classes are trying to solve.<br></p><p><br>I am wondering: on one hand you try to push all type information into protocols but on the other hand you want protocols to be able to derive from the implicit type (or protocol) defined by a class. <br></p><p>Extending your line of thought I’ve been thinking whether classes maybe should only represent implementation hierarchies, defining only „protected“ type, whereas public types can only be defined by protocols? This would allow separating both namespaces and solve the problem of having protocols named „Foo“ and classes named „FooImpl“.<br></p><p>-Thorsten<br> <br></p><p> <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
