<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Default implementation for protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 31, 2016 at 11:00:00am</p></header><div class="content"><p>Proposal<br>=======<br>Allow protocols to define a default implementation, e.g.:<br></p><p>  protocol Complex {<br>    default var re: Double = 0<br>    default var im: Double = 0<br>    var mag: Double { return sqrt(re * re + im * im) }<br>    // ...<br>  }<br></p><p>Which gets translated to:<br></p><p>  protocol Complex {<br>    var re: Double { get,  set }<br>    var im: Double { get, set }<br>    var mag: Double { get }<br>    // ...<br>  }<br></p><p>  extension Complex {<br>    var mag: Double { return sqrt(re * re + im * im) }<br>    // ...<br>  }<br></p><p>  struct _DefaultComplex: Complex { // Some private name<br>    var re: Double = 0<br>    var im: Double = 0<br>    // ...<br>  }<br></p><p>In use:<br></p><p>  let complex = Complex()<br></p><p>Gets translated into:<br></p><p>  let complex = _DefaultComplex()<br></p><p><br>Motivation<br>========<br>  1. You often have a default implementation for a protocol, much like a<br>function argument might have a default value. Therefore this proposal adds<br>convenience by saving boilerplate.<br>  2. It is difficult to name a protocol if there is a natural default<br>implementation. For example the natural name for the protocol that all<br>integral types inherited from is Integer, but that is also the natural name<br>for the default implementation. This tension between protocol and default<br>implementation name leads to strange naming conventions like IntegerType<br>for the protocol; we already know it is a type (it is a protocol after<br>all!). This is just a form of Hungarian notation; most people find<br>Hungarian obfuscates the code rather than clarifying.<br></p><p><br>Details<br>=====<br>  1. Change protocols so that protocol methods are dynamically dispatched,<br>when overridden in an extension.<br>  2. Change protocols so that all implementations and overrides of a<br>protocol method require the override keyword.<br>  3. Allow protocols to directly specify an implementation as well as via<br>an extension, also see point 1 and note dynamic dispatch.<br>  4. Allow via the default keyword protocols to define properties<br>(including stored), initialisers, and functions that are part of the<br>default implementation of the protocol but not the protocol itself.<br>  5. In the case of a default stored property the<br>  6. Allow the protocol name to be used to call the initialiser and in such<br>cases use the default implementation.<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/f5226a8b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Default implementation for protocols</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 30, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 30, 2016, at 4:48 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Proposal<br>&gt; =======<br>&gt; Allow protocols to define a default implementation, e.g.:<br>&gt; <br>&gt;   protocol Complex {<br>&gt;     default var re: Double = 0<br>&gt;     default var im: Double = 0<br>&gt;     var mag: Double { return sqrt(re * re + im * im) }<br>&gt;     // ...<br>&gt;   }<br></p><p>Hi Howard,<br></p><p>This is a desired feature, but a surprising amount of implementation effort blocks “just doing it”.  We hope that this will happen in Swift 3, but we’ll see how things work out with the other generics system improvements.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Default implementation for protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 31, 2016 at 05:00:00pm</p></header><div class="content"><p>Thanks for the feedback.<br></p><p>On Sunday, 31 January 2016, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 30, 2016, at 4:48 PM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Proposal<br>&gt; &gt; =======<br>&gt; &gt; Allow protocols to define a default implementation, e.g.:<br>&gt; &gt;<br>&gt; &gt;   protocol Complex {<br>&gt; &gt;     default var re: Double = 0<br>&gt; &gt;     default var im: Double = 0<br>&gt; &gt;     var mag: Double { return sqrt(re * re + im * im) }<br>&gt; &gt;     // ...<br>&gt; &gt;   }<br>&gt;<br>&gt; Hi Howard,<br>&gt;<br>&gt; This is a desired feature, but a surprising amount of implementation<br>&gt; effort blocks “just doing it”.  We hope that this will happen in Swift 3,<br>&gt; but we’ll see how things work out with the other generics system<br>&gt; improvements.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/991fd547/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Default implementation for protocols</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>January 31, 2016 at 09:00:00pm</p></header><div class="content"><p>See inline<br></p><p>&gt; Am 31.01.2016 um 01:48 schrieb Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Proposal<br>&gt; =======<br>&gt; Allow protocols to define a default implementation, e.g.:<br>&gt; <br>&gt;   protocol Complex {<br>&gt;     default var re: Double = 0<br>&gt;     default var im: Double = 0<br>&gt;     var mag: Double { return sqrt(re * re + im * im) }<br>&gt;     // ...<br>&gt;   }<br></p><p>Shouldn&#39;t there be a &quot;default&quot; before &quot;var mag: Double ...&quot;?<br></p><p>&gt; <br>&gt; Which gets translated to:<br>&gt; <br>&gt;   protocol Complex {<br>&gt;     var re: Double { get,  set }<br>&gt;     var im: Double { get, set }<br>&gt;     var mag: Double { get }<br>&gt;     // ...<br>&gt;   }<br>&gt; <br>&gt;   extension Complex {<br>&gt;     var mag: Double { return sqrt(re * re + im * im) }<br>&gt;     // ...<br>&gt;   }<br>&gt; <br>&gt;   struct _DefaultComplex: Complex { // Some private name<br>&gt;     var re: Double = 0<br>&gt;     var im: Double = 0<br>&gt;     // ...<br>&gt;   }<br>&gt; <br>&gt; In use:<br>&gt; <br>&gt;   let complex = Complex()<br>&gt; <br>&gt; Gets translated into:<br>&gt; <br>&gt;   let complex = _DefaultComplex()<br>&gt; <br>&gt; <br>&gt; Motivation<br>&gt; ========<br>&gt;   1. You often have a default implementation for a protocol, much like a function argument might have a default value. Therefore this proposal adds convenience by saving boilerplate.<br>&gt;   2. It is difficult to name a protocol if there is a natural default implementation. For example the natural name for the protocol that all integral types inherited from is Integer, but that is also the natural name for the default implementation. This tension between protocol and default implementation name leads to strange naming conventions like IntegerType for the protocol; we already know it is a type (it is a protocol after all!). This is just a form of Hungarian notation; most people find Hungarian obfuscates the code rather than clarifying.<br>&gt; <br>&gt; <br>&gt; Details<br>&gt; =====<br>&gt;   1. Change protocols so that protocol methods are dynamically dispatched, when overridden in an extension.<br></p><p>That should probably be a separate proposal to make the current one more incremental.<br></p><p>&gt;   2. Change protocols so that all implementations and overrides of a protocol method require the override keyword.<br></p><p>I would definitely love to see something like an override keyword. Although there could be confusion with method overrides in classes. Currently I&#39;m fine with &quot;override&quot;.<br></p><p>&gt;   3. Allow protocols to directly specify an implementation as well as via an extension, also see point 1 and note dynamic dispatch.<br></p><p>I like the separation between &quot;required signatures&quot; and default implementations. The protocol body shouldn&#39;t be cluttered with implementations. Extensions also group default implementations for different type constraints.<br></p><p>&gt;   4. Allow via the default keyword protocols to define properties (including stored), initialisers, and functions that are part of the default implementation of the protocol but not the protocol itself.<br></p><p>I&#39;m skeptical about stored properties in protocols (multiple inheritance =&gt; diamond problem).<br></p><p>A &quot;default&quot; keyword would definitely help to distinguish between properties/methods with default implementations and the ones without them.<br></p><p>&gt;   5. In the case of a default stored property the <br></p><p>... ? :)<br></p><p>&gt;   6. Allow the protocol name to be used to call the initialiser and in such cases use the default implementation.<br>&gt; <br></p><p>What will happen if not all requirements are fulfilled by default implementations? Also consider multiple inheritance.<br>Should there be an &quot;init&quot; which takes the remaining properties?<br></p><p>This reminds me of the &quot;memberwise init&quot; proposal...<br></p><p><br>Best regards<br>- Maximilian<br></p><p>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/36c2e3ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Default implementation for protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February  1, 2016 at 02:00:00pm</p></header><div class="content"><p>Inline below.<br></p><p>On 1 February 2016 at 07:53, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt;<br>wrote:<br></p><p>&gt; See inline<br>&gt;<br>&gt; Am 31.01.2016 um 01:48 schrieb Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; Proposal<br>&gt; =======<br>&gt; Allow protocols to define a default implementation, e.g.:<br>&gt;<br>&gt;   protocol Complex {<br>&gt;     default var re: Double = 0<br>&gt;     default var im: Double = 0<br>&gt;     var mag: Double { return sqrt(re * re + im * im) }<br>&gt;     // ...<br>&gt;   }<br>&gt;<br>&gt;<br>&gt; Shouldn&#39;t there be a &quot;default&quot; before &quot;var mag: Double ...&quot;?<br>&gt;<br></p><p>No. It gets translated into a protocol member and an extension to the<br>protocol. In the proposal, if default was put infant of the line then it<br>wouldn&#39;t appear in the protocol nor the extension, just in the default<br>struct.<br></p><p>     Which gets translated to:<br>&gt;<br>&gt;<br>&gt;   protocol Complex {<br>&gt;     var re: Double { get,  set }<br>&gt;     var im: Double { get, set }<br>&gt;     var mag: Double { get }<br>&gt;     // ...<br>&gt;   }<br>&gt;<br>&gt;   extension Complex {<br>&gt;     var mag: Double { return sqrt(re * re + im * im) }<br>&gt;     // ...<br>&gt;   }<br>&gt;<br>&gt;   struct _DefaultComplex: Complex { // Some private name<br>&gt;     var re: Double = 0<br>&gt;     var im: Double = 0<br>&gt;     // ...<br>&gt;   }<br>&gt;<br>&gt; In use:<br>&gt;<br>&gt;   let complex = Complex()<br>&gt;<br>&gt; Gets translated into:<br>&gt;<br>&gt;   let complex = _DefaultComplex()<br>&gt;<br>&gt;<br>&gt; Motivation<br>&gt; ========<br>&gt;   1. You often have a default implementation for a protocol, much like a<br>&gt; function argument might have a default value. Therefore this proposal adds<br>&gt; convenience by saving boilerplate.<br>&gt;   2. It is difficult to name a protocol if there is a natural default<br>&gt; implementation. For example the natural name for the protocol that all<br>&gt; integral types inherited from is Integer, but that is also the natural name<br>&gt; for the default implementation. This tension between protocol and default<br>&gt; implementation name leads to strange naming conventions like IntegerType<br>&gt; for the protocol; we already know it is a type (it is a protocol after<br>&gt; all!). This is just a form of Hungarian notation; most people find<br>&gt; Hungarian obfuscates the code rather than clarifying.<br>&gt;<br>&gt;<br>&gt; Details<br>&gt; =====<br>&gt;   1. Change protocols so that protocol methods are dynamically dispatched,<br>&gt; when overridden in an extension.<br>&gt;<br>&gt;<br>&gt; That should probably be a separate proposal to make the current one more<br>&gt; incremental.<br>&gt;<br></p><p>Yes. There has been discussion of this in another thread. This proposal<br>would build on the previous one and I should have just referenced that<br>proposal.<br></p><p><br>&gt;<br>&gt;   2. Change protocols so that all implementations and overrides of a<br>&gt; protocol method require the override keyword.<br>&gt;<br>&gt;<br>&gt; I would definitely love to see something *like* an override keyword.<br>&gt; Although there could be confusion with method overrides in classes.<br>&gt; Currently I&#39;m fine with &quot;override&quot;.<br>&gt;<br></p><p>Java, Scala, use override in both contacts - no problems.<br></p><p>&gt;<br>&gt;   3. Allow protocols to directly specify an implementation as well as via<br>&gt; an extension, also see point 1 and note dynamic dispatch.<br>&gt;<br>&gt;<br>&gt; I like the separation between &quot;required signatures&quot; and default<br>&gt; implementations. The protocol body shouldn&#39;t be cluttered with<br>&gt; implementations. Extensions also group default implementations for<br>&gt; different type constraints.<br>&gt;<br></p><p>Not taking that away. However it is quite a lot of boiler plate for a small<br>class and as acknowledged by Chris Lattner already on the things to do<br>list.<br></p><p>&gt;<br>&gt;   4. Allow via the default keyword protocols to define properties<br>&gt; (including stored), initialisers, and functions that are part of the<br>&gt; default implementation of the protocol but not the protocol itself.<br>&gt;<br>&gt;<br>&gt; I&#39;m skeptical about stored properties in protocols (multiple inheritance<br>&gt; =&gt; diamond problem).<br>&gt;<br></p><p>No stored property in the protocol, just getter and setters. The actual<br>stored property is only in the struct.<br></p><p>&gt;<br>&gt; A &quot;default&quot; keyword would definitely help to distinguish between properties/methods<br>&gt; with default implementations and the ones without them.<br>&gt;<br></p><p>Yes default is necessary to distinguish the two uses.<br></p><p>&gt;<br>&gt;   5. In the case of a default stored property the<br>&gt;<br>&gt;<br>&gt; ... ? :)<br>&gt;<br></p><p>Oops. Meant to say:  5. In the case of a default stored property the<br>protocol has the appropriate calculated property, nothing is added to the<br>extension, and the struct has the actual stored property.<br></p><p>&gt;<br>&gt;   6. Allow the protocol name to be used to call the initialiser and in<br>&gt; such cases use the default implementation.<br>&gt;<br>&gt;<br>&gt; What will happen if not all requirements are fulfilled by default<br>&gt; implementations? Also consider multiple inheritance.<br>&gt; Should there be an &quot;init&quot; which takes the remaining properties?<br>&gt;<br></p><p>A. If the default implementation does not fulfil all the requirements then<br>it is an error, just like a struct has to fulfil all the requirements.<br></p><p>B. It only has multiple inheritance of protocols, like Swift already has.<br>The default is a struct, therefore both final and can only inherit from<br>protocols.<br></p><p>C. You need to write default inits as necessary to make a valid protocol.<br>For example if you have a private stored property then it won&#39;t be in the<br>protocol but in the struct and all the inits will need to ensure it is<br>initialised, just like normal.<br></p><p>&gt;<br>&gt; This reminds me of the &quot;memberwise init&quot; proposal...<br>&gt;<br></p><p>Not sure I follow your thinking on this.<br></p><p>&gt;<br>&gt;<br>&gt; Best regards<br>&gt; - Maximilian<br>&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/71228c3f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
