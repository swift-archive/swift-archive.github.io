<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d569462ac92d4619342b1c5ff305043?s=50"></div><header><strong>Union instead of Optional</strong> from <string>frogcjn at 163.com</string> &lt;frogcjn at 163.com&gt;<p>May 15, 2016 at 10:00:00am</p></header><div class="content"><p>It’s kind of same idea of TypeScipt 2, at 46:21 in this video.<br></p><p>https://channel9.msdn.com/Events/Build/2016/B881 &lt;https://channel9.msdn.com/Events/Build/2016/B881&gt;<br></p><p><br></p><p><br>&gt; <br>&gt; 2016-2-16 GMT+8 14:36:28<br>&gt; Hi all,<br>&gt; <br>&gt; I think the best way to solve the either problem is to separate it from generic. <br>&gt; Optional and Either shouldn’t work the same way of generic type. <br>&gt; It’s just a represent of multiple type in one location.<br>&gt; <br>&gt; Using an old friend, Union in C.<br>&gt; union {<br>&gt; 	case firstType<br>&gt; 	case secondType<br>&gt; }<br>&gt; <br>&gt; This is the final solution for the sub typing problem of optional.<br>&gt; <br>&gt; A  == union(A,A)<br>&gt; union(A,B) == union(B,A)<br>&gt; B == union(B,B)<br>&gt; <br>&gt; B is subtype of union(A,B)<br>&gt; A is subtype of union(A,B)<br>&gt; union(A,B,C) is subtype of union(A,B,C,D,…)<br>&gt; <br>&gt; suppose <br>&gt; a is subclass of A<br>&gt; b is subclass of B, then<br>&gt; 	union(a,B) is subtype of union(A,B)<br>&gt; 	union(A,b) is subtype of union(A,B)<br>&gt; 	union(a,b) is subtype of union(a,B)<br>&gt; 	union(a,b) is subtype of union(A,b)<br>&gt; <br>&gt; union can have as many case as possible. e.g., union(A,B,C,D,…)<br>&gt; <br>&gt; So the Optional&lt;UITableView&gt; should be union(UITableView, None)<br>&gt; and Optional&lt;MyTableVIew&gt; should be union(MyTableView, None), which is subclass of union(UITableView, None)<br>&gt; <br>&gt; This is a final rational solution. I think.<br>&gt; <br>&gt; -Jiannan<br>&gt; <br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160515/c30ba800/attachment-0001.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: ???? 2016-05-15 10.20.36.png<br>Type: image/png<br>Size: 110214 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160515/c30ba800/attachment-0001.png&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Union instead of Optional</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 15, 2016 at 09:00:00am</p></header><div class="content"><p>Enums with associated types in Swift are the equivalent of unions, even if they don’t have the name. I don’t see what your proposal is trying to solve?<br></p><p>&gt; On 15 May 2016, at 04:33, Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; It’s kind of same idea of TypeScipt 2, at 46:21 in this video.<br>&gt; <br>&gt; https://channel9.msdn.com/Events/Build/2016/B881 &lt;https://channel9.msdn.com/Events/Build/2016/B881&gt;<br>&gt; <br>&gt; &lt;屏幕快照 2016-05-15 10.20.36.png&gt;<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; 2016-2-16 GMT+8 14:36:28<br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I think the best way to solve the either problem is to separate it from generic. <br>&gt;&gt; Optional and Either shouldn’t work the same way of generic type. <br>&gt;&gt; It’s just a represent of multiple type in one location.<br>&gt;&gt; <br>&gt;&gt; Using an old friend, Union in C.<br>&gt;&gt; union {<br>&gt;&gt; 	case firstType<br>&gt;&gt; 	case secondType<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This is the final solution for the sub typing problem of optional.<br>&gt;&gt; <br>&gt;&gt; A  == union(A,A)<br>&gt;&gt; union(A,B) == union(B,A)<br>&gt;&gt; B == union(B,B)<br>&gt;&gt; <br>&gt;&gt; B is subtype of union(A,B)<br>&gt;&gt; A is subtype of union(A,B)<br>&gt;&gt; union(A,B,C) is subtype of union(A,B,C,D,…)<br>&gt;&gt; <br>&gt;&gt; suppose <br>&gt;&gt; a is subclass of A<br>&gt;&gt; b is subclass of B, then<br>&gt;&gt; 	union(a,B) is subtype of union(A,B)<br>&gt;&gt; 	union(A,b) is subtype of union(A,B)<br>&gt;&gt; 	union(a,b) is subtype of union(a,B)<br>&gt;&gt; 	union(a,b) is subtype of union(A,b)<br>&gt;&gt; <br>&gt;&gt; union can have as many case as possible. e.g., union(A,B,C,D,…)<br>&gt;&gt; <br>&gt;&gt; So the Optional&lt;UITableView&gt; should be union(UITableView, None)<br>&gt;&gt; and Optional&lt;MyTableVIew&gt; should be union(MyTableView, None), which is subclass of union(UITableView, None)<br>&gt;&gt; <br>&gt;&gt; This is a final rational solution. I think.<br>&gt;&gt; <br>&gt;&gt; -Jiannan<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160515/1379ee92/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Union instead of Optional</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 15, 2016 at 12:00:00am</p></header><div class="content"><p>In addition, not everything in Swift can be modeled in terms of inheritance relationships.<br></p><p>I&#39;m a little curious as to why union types keep on coming up, when enums can do everything they can and much more (methods, constraints on generic types, conformance to protocols).<br></p><p>Austin<br></p><p>&gt; On May 15, 2016, at 12:19 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Enums with associated types in Swift are the equivalent of unions, even if they don’t have the name. I don’t see what your proposal is trying to solve?<br>&gt; <br>&gt;&gt; On 15 May 2016, at 04:33, Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It’s kind of same idea of TypeScipt 2, at 46:21 in this video.<br>&gt;&gt; <br>&gt;&gt; https://channel9.msdn.com/Events/Build/2016/B881 &lt;https://channel9.msdn.com/Events/Build/2016/B881&gt;<br>&gt;&gt; <br>&gt;&gt; &lt;屏幕快照 2016-05-15 10.20.36.png&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016-2-16 GMT+8 14:36:28<br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the best way to solve the either problem is to separate it from generic. <br>&gt;&gt;&gt; Optional and Either shouldn’t work the same way of generic type. <br>&gt;&gt;&gt; It’s just a represent of multiple type in one location.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using an old friend, Union in C.<br>&gt;&gt;&gt; union {<br>&gt;&gt;&gt; 	case firstType<br>&gt;&gt;&gt; 	case secondType<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is the final solution for the sub typing problem of optional.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A  == union(A,A)<br>&gt;&gt;&gt; union(A,B) == union(B,A)<br>&gt;&gt;&gt; B == union(B,B)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; B is subtype of union(A,B)<br>&gt;&gt;&gt; A is subtype of union(A,B)<br>&gt;&gt;&gt; union(A,B,C) is subtype of union(A,B,C,D,…)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; suppose <br>&gt;&gt;&gt; a is subclass of A<br>&gt;&gt;&gt; b is subclass of B, then<br>&gt;&gt;&gt; 	union(a,B) is subtype of union(A,B)<br>&gt;&gt;&gt; 	union(A,b) is subtype of union(A,B)<br>&gt;&gt;&gt; 	union(a,b) is subtype of union(a,B)<br>&gt;&gt;&gt; 	union(a,b) is subtype of union(A,b)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; union can have as many case as possible. e.g., union(A,B,C,D,…)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So the Optional&lt;UITableView&gt; should be union(UITableView, None)<br>&gt;&gt;&gt; and Optional&lt;MyTableVIew&gt; should be union(MyTableView, None), which is subclass of union(UITableView, None)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a final rational solution. I think.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Jiannan<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160515/4060a520/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Union instead of Optional</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>May 15, 2016 at 01:00:00pm</p></header><div class="content"><p>I don&#39;t know if there has been any internal discussion about using union-types instead of enums, but afaics, there are no obvious downsides for that approach.<br></p><p>&gt; I&#39;m a little curious as to why union types keep on coming up, when enums can do everything they can and much more (methods, constraints on generic types, conformance to protocols).<br>Are there any strong reasons why those features would not be possible with union types?<br></p><p>There has been a discussion started because it is a little bit cumbersome to create enum-properties (and methods).<br>With unions, there would be no need for all those switch-statements, and would be possible to configure cases in a central location.<br>There has also been a proposal for &quot;anonymous enums&quot;, which could be modeled with unions in a very elegant way.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160515/3a284752/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Union instead of Optional</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 16, 2016 at 11:00:00am</p></header><div class="content"><p>Yes, enums are like explicit named type unions whereas ad hoc type unions can be useful exactly because they are ad hoc.<br>It is kind of like named functions vs. anonymous functions. Both have their place.<br></p><p>Ceylon makes tremendous use of union and intersection types. While they don’t have enums in the Swift sense they have something very similar, so they certainly make use of both approaches, too. Like I said both have their place and introducing type unions shouldn’t replace enums (unless we should discover that type unions can do all that enums do, e.g. with extensions it might even be possible to add methods to type unions in Swift).<br></p><p>-Thorsten<br></p><p><br>&gt; Am 15.05.2016 um 13:07 schrieb Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I don&#39;t know if there has been any internal discussion about using union-types instead of enums, but afaics, there are no obvious downsides for that approach.<br>&gt; <br>&gt;&gt; I&#39;m a little curious as to why union types keep on coming up, when enums can do everything they can and much more (methods, constraints on generic types, conformance to protocols).<br>&gt; Are there any strong reasons why those features would not be possible with union types?<br>&gt; <br>&gt; There has been a discussion started because it is a little bit cumbersome to create enum-properties (and methods).<br>&gt; With unions, there would be no need for all those switch-statements, and would be possible to configure cases in a central location.<br>&gt; There has also been a proposal for &quot;anonymous enums&quot;, which could be modeled with unions in a very elegant way.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/ea56f916/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Union instead of Optional</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 16, 2016 at 03:00:00am</p></header><div class="content"><p>Precisely. To me unions are to enums with associated type the same way tuples are to structs. One is named, has well-defined semantics, can conform to protocols, can have complex internal structure, can have methods, etc. The other is ad-hoc and lightweight, easy to define at the site of use, best suited for simple purposes, has special syntax to support it. <br></p><p>Even if we can extend tuples in the future, though, I wouldn&#39;t want structs to go away. When exceeding some level of complexity structs are just more explicit than tuples, and therefore easier to understand.<br></p><p>Finally, please note that Ceylon is a pervasively object-oriented language with a single root superclass. Neither of those is true for Swift, which chooses to solve a lot of problems in a different (and I would argue, superior) way. So solutions that might work well in Ceylon might not be suited for Swift, at least not without modification, and vice versa. The core team could certainly have chosen to model Swift&#39;s type system after that of e.g. Scala, but they chose not to, and I think they did so for good reason.<br></p><p>Austin<br></p><p><br>&gt; On May 16, 2016, at 2:58 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; Yes, enums are like explicit named type unions whereas ad hoc type unions can be useful exactly because they are ad hoc.<br>&gt; It is kind of like named functions vs. anonymous functions. Both have their place.<br>&gt; <br>&gt; Ceylon makes tremendous use of union and intersection types. While they don’t have enums in the Swift sense they have something very similar, so they certainly make use of both approaches, too. Like I said both have their place and introducing type unions shouldn’t replace enums (unless we should discover that type unions can do all that enums do, e.g. with extensions it might even be possible to add methods to type unions in Swift).<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; Am 15.05.2016 um 13:07 schrieb Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know if there has been any internal discussion about using union-types instead of enums, but afaics, there are no obvious downsides for that approach.<br>&gt;&gt; <br>&gt;&gt;&gt; I&#39;m a little curious as to why union types keep on coming up, when enums can do everything they can and much more (methods, constraints on generic types, conformance to protocols).<br>&gt;&gt; Are there any strong reasons why those features would not be possible with union types?<br>&gt;&gt; <br>&gt;&gt; There has been a discussion started because it is a little bit cumbersome to create enum-properties (and methods).<br>&gt;&gt; With unions, there would be no need for all those switch-statements, and would be possible to configure cases in a central location.<br>&gt;&gt; There has also been a proposal for &quot;anonymous enums&quot;, which could be modeled with unions in a very elegant way.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/2a2256e9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Union instead of Optional</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>May 16, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Precisely. To me unions are to enums with associated type the same way tuples are to structs.<br>Me too — and I think it would be beautiful if it could be modeled that way, so that there is always a pair of a named and an anonymous variant for functions (closures), types (structs) and enums (yet to come). <br></p><p>&gt; One is named, has well-defined semantics, can conform to protocols, can have complex internal structure, can have methods, etc. The other is ad-hoc and lightweight, easy to define at the site of use, best suited for simple purposes, has special syntax to support it. <br>That also true for closures, yet I&#39;m very happy how flexible regular methods can be used as blocks.<br></p><p>&gt; Even if we can extend tuples in the future, though, I wouldn&#39;t want structs to go away. When exceeding some level of complexity structs are just more explicit than tuples, and therefore easier to understand.<br>I don&#39;t think something as fundamental as structs should ever be removed, but imho it would be great to see some unification of concepts…<br></p><p>struct Point: Tuple&lt;x: Float, y: Float&gt; {<br>	// methods...<br>	// &quot;inheritance for structs&quot;-poposal delayed until Swift 4 ;-)<br>}<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>Union instead of Optional</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May 16, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Am 16.05.2016 um 12:07 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Precisely. To me unions are to enums with associated type the same way tuples are to structs. One is named, has well-defined semantics, can conform to protocols, can have complex internal structure, can have methods, etc. The other is ad-hoc and lightweight, easy to define at the site of use, best suited for simple purposes, has special syntax to support it. <br>&gt; <br>&gt; Even if we can extend tuples in the future, though, I wouldn&#39;t want structs to go away. When exceeding some level of complexity structs are just more explicit than tuples, and therefore easier to understand.<br>&gt; <br>&gt; Finally, please note that Ceylon is a pervasively object-oriented language with a single root superclass. Neither of those is true for Swift, which chooses to solve a lot of problems in a different (and I would argue, superior) way. So solutions that might work well in Ceylon might not be suited for Swift, at least not without modification, and vice versa. The core team could certainly have chosen to model Swift&#39;s type system after that of e.g. Scala, but they chose not to, and I think they did so for good reason.<br></p><p>Swift has a root class, it is called SwiftObject and it&#39;s visible from Objective-C ;) Just thinking about it.. it makes sense: the whole reference-counting-stuff has to live somewhere in the object, and there has to be some kind of isa-pointer to allow for subclassing (and Objective-C interoperability). So there is some common behavior regarding all classes defined from Swift (they all implement retain, release, autorelease, isEqual:, class, respondsToSelector:, the whole NSObject-protocol...) =&gt; what I want to express: Java has a root-class, C++ has no root class - that&#39;s uncontested; but Swift is somewhere in-between IMHO.<br></p><p>And for enums and unions.. I think they are different. enums are &quot;sum-types&quot; and unions are... well... &quot;union-types&quot;, when you think of data types as sets. E.g. if A, B are data types (sets), then an enum that can be either anA(A) or aB(B) can be thought of as the set A+B (and if A \intersect B \not\eq \emptyset, you can think of this as (0,A)\union (1,B) ). A union B is not the same. In C, the unions are not even safe, because they are not discriminated in any way. In Swift they make an isomorphic set if A and B are disjoint. If A=String and B=Int, A `enum` B is isomorphic to A `union` B (sorry for abusing Haskell syntax :-/ ). But if A=Iterable&lt;String&gt; and B=Array&lt;String&gt;, they are not the same, because now A is a superset of B. So A `enum` B is a strict superset of A `union` B (== A). I can already imagine weird bugs coming to the surface from this distinction, all of which can be solved by disallowing union types altogether.<br></p><p>Therefore I think that unions are not worth the trouble at all. And they are even possible right now: Instead of writing<br></p><p>    union MyUnion { Int, String }<br>    // or typealias MyUnion = (Int | String) // ?<br></p><p>you&#39;d have to write<br></p><p>    protocol MyUnion {}<br>    extension Int: MyUnion {}<br>    extension String: MyUnion {}<br></p><p>The two definitions are basically equivalent, and the second is already valid Swift.<br></p><p>I have used unions a few times in C though, e.g. for converting from void* to int or stuff like that, at a time when I didn&#39;t know about reinterpret_cast (Swift: unsafeBitcast) yet. The few occasions where they are use in the C standard library, they are always discriminated, like a union between a struct(int type, float foo, ...) and another struct(int type, char bar[20], ...) where the type parameter is in both values and can be used to distinguish them. In Swift they are always distinguishable because of runtime type information (except for the case described above), so you can as well just use an enum and make that information obvious. To unpack the information you can use `if let` when dealing with a union, and you can use `if case` or `switch` when dealing with an enum. I don&#39;t see how unions would be more convenient to be worth the trouble. Swift unions would be like (C unions + RTTI (runtime type information)), with RTTI replacing the discriminator element of enums, except when the types overlap. So I doubt that anyone will find a decent (realistic!) use-case that is not just as easily (and conveniently) implemented using enums. I think I just proved that there is no such use case ;) The best way to convince me otherwise would be to provide a realistic piece of example code.<br></p><p>Regards,<br>Michael<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Union instead of Optional</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 16, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 16.05.2016 um 17:29 schrieb Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; Am 16.05.2016 um 12:07 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Precisely. To me unions are to enums with associated type the same way tuples are to structs. One is named, has well-defined semantics, can conform to protocols, can have complex internal structure, can have methods, etc. The other is ad-hoc and lightweight, easy to define at the site of use, best suited for simple purposes, has special syntax to support it. <br>&gt;&gt; <br>&gt;&gt; Even if we can extend tuples in the future, though, I wouldn&#39;t want structs to go away. When exceeding some level of complexity structs are just more explicit than tuples, and therefore easier to understand.<br>&gt;&gt; <br>&gt;&gt; Finally, please note that Ceylon is a pervasively object-oriented language with a single root superclass. Neither of those is true for Swift, which chooses to solve a lot of problems in a different (and I would argue, superior) way. So solutions that might work well in Ceylon might not be suited for Swift, at least not without modification, and vice versa. The core team could certainly have chosen to model Swift&#39;s type system after that of e.g. Scala, but they chose not to, and I think they did so for good reason.<br>&gt; <br>&gt; Swift has a root class, it is called SwiftObject and it&#39;s visible from Objective-C ;) Just thinking about it.. it makes sense: the whole reference-counting-stuff has to live somewhere in the object, and there has to be some kind of isa-pointer to allow for subclassing (and Objective-C interoperability). So there is some common behavior regarding all classes defined from Swift (they all implement retain, release, autorelease, isEqual:, class, respondsToSelector:, the whole NSObject-protocol...) =&gt; what I want to express: Java has a root-class, C++ has no root class - that&#39;s uncontested; but Swift is somewhere in-between IMHO.<br>&gt; <br>&gt; And for enums and unions.. I think they are different. enums are &quot;sum-types&quot; and unions are... well... &quot;union-types&quot;, when you think of data types as sets. E.g. if A, B are data types (sets), then an enum that can be either anA(A) or aB(B) can be thought of as the set A+B (and if A \intersect B \not\eq \emptyset, you can think of this as (0,A)\union (1,B) ). A union B is not the same. In C, the unions are not even safe, because they are not discriminated in any way. In Swift they make an isomorphic set if A and B are disjoint. If A=String and B=Int, A `enum` B is isomorphic to A `union` B (sorry for abusing Haskell syntax :-/ ). But if A=Iterable&lt;String&gt; and B=Array&lt;String&gt;, they are not the same, because now A is a superset of B. So A `enum` B is a strict superset of A `union` B (== A). I can already imagine weird bugs coming to the surface from this distinction, all of which can be solved by disallowing union types altogether.<br></p><p>Ceylon’s type system handles these things nicely. Iterable&lt;String&gt; | Array&lt;String&gt; would reduce to Iterable&lt;String&gt;, for example, and when switching over union types the type checker knows when types are not disjoint (disallowing the switch) or whether the switch is exhaustive.<br></p><p>For more details, see http://ceylon-lang.org/documentation/1.2/tour/types/<br></p><p>&gt; <br>&gt; Therefore I think that unions are not worth the trouble at all. And they are even possible right now: Instead of writing<br>&gt; <br>&gt;    union MyUnion { Int, String }<br>&gt;    // or typealias MyUnion = (Int | String) // ?<br>&gt; <br>&gt; you&#39;d have to write<br>&gt; <br>&gt;    protocol MyUnion {}<br>&gt;    extension Int: MyUnion {}<br>&gt;    extension String: MyUnion {}<br>&gt; <br>&gt; The two definitions are basically equivalent, and the second is already valid Swift.<br></p><p>Alas, that is only possible for explicit named unions but the power of type unions lies in their „ad hoc“-ness, e.g. in generic unions like<br></p><p>func union&lt;T, U&gt;(a: Set&lt;T&gt;, b: Set&lt;U&gt;) -&gt; Set&lt;T | U&gt; { … } 	// Note: all examples in hypothetically extended Swift syntax instead of Ceylon syntax<br></p><p>extension Dictionary {<br>	func getOrDefault&lt;Default&gt;(default: Default) -&gt; Value | Default	// in the general simple case Default == Value, which results in Value | Default == Value<br>}<br></p><p>Ceylon models the concept of empty and non-empty streams by defining<br></p><p>protocol Iterable {<br>	associatedtype Element<br>	associatedtype Absent : Null = Null 	// Null is the type containing a single value null (= nil in Swift); Ceylon’s optionals are just type unions T? == T | Null<br>	<br>	var first: Absent | Element { get }<br>	var rest: Iterable where Iterable.Element == Element, Iterable.Absent == Null<br></p><p>	// Produces a non-empty stream with a given initial element, followed by the elements of this stream, in the order in which they occur in this stream.<br>	func follow(head: Other) -&gt; Iterable where Iterable.Element == Element | Other, Iterable.Absent = Nothing<br>	…<br>}<br></p><p>This means that<br>	Iterable // with the default Absent = Null<br>can be empty, whereas<br>	Iterable where Absent == Nothing<br>cannot be empty because Nothing is the bottom type (the intersection of all types) with no elements, i.e. the union Nothing | Element == Element and therefore `first` always answers an element!<br></p><p>An example for intersection types in Ceylon (which requires that optionals are modeled as type union T | Null where Null is not a subtype of Any):<br></p><p>protocol Collection {<br>	func coalesced() -&gt; [Value &amp; Any] // answer an array containing all non nil elements<br>}<br></p><p>Just some examples demonstrating a bit of the beauty of type unions and type intersections if baked into the language and embraced by the standard library.<br></p><p>-Thorsten<br></p><p>&gt; <br>&gt; I have used unions a few times in C though, e.g. for converting from void* to int or stuff like that, at a time when I didn&#39;t know about reinterpret_cast (Swift: unsafeBitcast) yet. The few occasions where they are use in the C standard library, they are always discriminated, like a union between a struct(int type, float foo, ...) and another struct(int type, char bar[20], ...) where the type parameter is in both values and can be used to distinguish them. In Swift they are always distinguishable because of runtime type information (except for the case described above), so you can as well just use an enum and make that information obvious. To unpack the information you can use `if let` when dealing with a union, and you can use `if case` or `switch` when dealing with an enum. I don&#39;t see how unions would be more convenient to be worth the trouble. Swift unions would be like (C unions + RTTI (runtime type information)), with RTTI replacing the discriminator element of enums, except when the types overlap. So I doubt that anyone will find a decent (realistic!) use-case that is not just as easily (and conveniently) implemented using enums. I think I just proved that there is no such use case ;) The best way to convince me otherwise would be to provide a realistic piece of example code.<br>&gt; <br>&gt; Regards,<br>&gt; Michael<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d569462ac92d4619342b1c5ff305043?s=50"></div><header><strong>Union instead of Optional</strong> from <string>frogcjn at 163.com</string> &lt;frogcjn at 163.com&gt;<p>May 15, 2016 at 05:00:00pm</p></header><div class="content"><p>Optional should be implement by union concept s instead of using generic.<br></p><p>Enum cannot be easily used to represent many types until you name all of them. <br></p><p>Both generic and enum solution cannot build a strong relation between optional type and its original type, for example, an Integer type has no reparation with Optional&lt;Int&gt;, until the compiler make a special case for Optional&lt;T&gt; to automatically unwrap or wrap for this.<br></p><p>&gt; 在 2016年5月15日，15:19，David Hart &lt;david at hartbit.com&gt; 写道：<br>&gt; <br>&gt; Enums with associated types in Swift are the equivalent of unions, even if they don’t have the name. I don’t see what your proposal is trying to solve?<br>&gt; <br>&gt;&gt; On 15 May 2016, at 04:33, Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It’s kind of same idea of TypeScipt 2, at 46:21 in this video.<br>&gt;&gt; <br>&gt;&gt; https://channel9.msdn.com/Events/Build/2016/B881<br>&gt;&gt; <br>&gt;&gt; &lt;屏幕快照 2016-05-15 10.20.36.png&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016-2-16 GMT+8 14:36:28<br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the best way to solve the either problem is to separate it from generic. <br>&gt;&gt;&gt; Optional and Either shouldn’t work the same way of generic type. <br>&gt;&gt;&gt; It’s just a represent of multiple type in one location.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using an old friend, Union in C.<br>&gt;&gt;&gt; union {<br>&gt;&gt;&gt; 	case firstType<br>&gt;&gt;&gt; 	case secondType<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is the final solution for the sub typing problem of optional.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A  == union(A,A)<br>&gt;&gt;&gt; union(A,B) == union(B,A)<br>&gt;&gt;&gt; B == union(B,B)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; B is subtype of union(A,B)<br>&gt;&gt;&gt; A is subtype of union(A,B)<br>&gt;&gt;&gt; union(A,B,C) is subtype of union(A,B,C,D,…)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; suppose <br>&gt;&gt;&gt; a is subclass of A<br>&gt;&gt;&gt; b is subclass of B, then<br>&gt;&gt;&gt; 	union(a,B) is subtype of union(A,B)<br>&gt;&gt;&gt; 	union(A,b) is subtype of union(A,B)<br>&gt;&gt;&gt; 	union(a,b) is subtype of union(a,B)<br>&gt;&gt;&gt; 	union(a,b) is subtype of union(A,b)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; union can have as many case as possible. e.g., union(A,B,C,D,…)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So the Optional&lt;UITableView&gt; should be union(UITableView, None)<br>&gt;&gt;&gt; and Optional&lt;MyTableVIew&gt; should be union(MyTableView, None), which is subclass of union(UITableView, None)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a final rational solution. I think.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Jiannan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160515/034be313/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Union instead of Optional</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 16, 2016 at 12:00:00pm</p></header><div class="content"><p>Optional a could be implemented with both enumerated and unions with this<br>proposal but there should be an Undefined type whose only possible value is<br>nil. It would make no sense but you could declare a function argument or<br>return or even a property whose type is Undefined too. And this would lead<br>to otherwise unnecessary code.<br></p><p>I do agree with the idea of unions but I don&#39;t believe optionals would be<br>better implemented with it,<br></p><p>On Saturday, 14 May 2016, Cao Jiannan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; It’s kind of same idea of TypeScipt 2, at 46:21 in this video.<br>&gt;<br>&gt; https://channel9.msdn.com/Events/Build/2016/B881<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; 2016-2-16 GMT+8 14:36:28<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; I think the best way to solve the either problem is to separate it from<br>&gt; generic.<br>&gt; Optional and Either shouldn’t work the same way of generic type.<br>&gt; It’s just a represent of multiple type in one location.<br>&gt;<br>&gt; Using an old friend, Union in C.<br>&gt; union {<br>&gt; case firstType<br>&gt; case secondType<br>&gt; }<br>&gt;<br>&gt; This is the final solution for the sub typing problem of optional.<br>&gt;<br>&gt;<br>&gt; A  == union(A,A)<br>&gt; union(A,B) == union(B,A)<br>&gt; B == union(B,B)<br>&gt;<br>&gt; B is subtype of union(A,B)<br>&gt; A is subtype of union(A,B)<br>&gt;<br>&gt; union(A,B,C) is subtype of union(A,B,C,D,…)<br>&gt;<br>&gt;<br>&gt; suppose<br>&gt; a is subclass of A<br>&gt; b is subclass of B, then<br>&gt; union(a,B) is subtype of union(A,B)<br>&gt; union(A,b) is subtype of union(A,B)<br>&gt; union(a,b) is subtype of union(a,B)<br>&gt; union(a,b) is subtype of union(A,b)<br>&gt;<br>&gt; union can have as many case as possible. e.g., union(A,B,C,D,…)<br>&gt;<br>&gt; So the Optional&lt;UITableView&gt; should be union(UITableView, None)<br>&gt; and Optional&lt;MyTableVIew&gt; should be union(MyTableView, None), which is<br>&gt; subclass of union(UITableView, None)<br>&gt;<br>&gt; This is a final rational solution. I think.<br>&gt;<br>&gt; -Jiannan<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>- Leonardo<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/023848ae/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: 屏幕快照 2016-05-15 10.20.36.png<br>Type: image/png<br>Size: 110214 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/023848ae/attachment.png&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Union instead of Optional</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 16, 2016 at 09:00:00am</p></header><div class="content"><p>Unlike sum types, such as Swift enums, unions don&#39;t have parametricity, because (T \union Nil) \union Nil == T \union Nil. This means that things like collections containing Optionals don&#39;t just work, since it becomes impossible for operations like &#39;find&#39; to distinguish &#39;nil&#39; as a value in the container from &#39;nil&#39; as a &quot;not found&quot; result. Languages without sum types tend to compensate by growing multiple &quot;nil&quot;-like values—ObjC has NSNull, Javascript has undefined and null, VB has Null, Nothing, *and* None, and so on.<br></p><p>-Joe<br></p><p>&gt; On May 14, 2016, at 7:33 PM, Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; It’s kind of same idea of TypeScipt 2, at 46:21 in this video.<br>&gt; <br>&gt; https://channel9.msdn.com/Events/Build/2016/B881<br>&gt; <br>&gt; &lt;屏幕快照 2016-05-15 10.20.36.png&gt;<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; 2016-2-16 GMT+8 14:36:28<br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I think the best way to solve the either problem is to separate it from generic. <br>&gt;&gt; Optional and Either shouldn’t work the same way of generic type. <br>&gt;&gt; It’s just a represent of multiple type in one location.<br>&gt;&gt; <br>&gt;&gt; Using an old friend, Union in C.<br>&gt;&gt; union {<br>&gt;&gt; 	case firstType<br>&gt;&gt; 	case secondType<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This is the final solution for the sub typing problem of optional.<br>&gt;&gt; <br>&gt;&gt; A  == union(A,A)<br>&gt;&gt; union(A,B) == union(B,A)<br>&gt;&gt; B == union(B,B)<br>&gt;&gt; <br>&gt;&gt; B is subtype of union(A,B)<br>&gt;&gt; A is subtype of union(A,B)<br>&gt;&gt; union(A,B,C) is subtype of union(A,B,C,D,…)<br>&gt;&gt; <br>&gt;&gt; suppose <br>&gt;&gt; a is subclass of A<br>&gt;&gt; b is subclass of B, then<br>&gt;&gt; 	union(a,B) is subtype of union(A,B)<br>&gt;&gt; 	union(A,b) is subtype of union(A,B)<br>&gt;&gt; 	union(a,b) is subtype of union(a,B)<br>&gt;&gt; 	union(a,b) is subtype of union(A,b)<br>&gt;&gt; <br>&gt;&gt; union can have as many case as possible. e.g., union(A,B,C,D,…)<br>&gt;&gt; <br>&gt;&gt; So the Optional&lt;UITableView&gt; should be union(UITableView, None)<br>&gt;&gt; and Optional&lt;MyTableVIew&gt; should be union(MyTableView, None), which is subclass of union(UITableView, None)<br>&gt;&gt; <br>&gt;&gt; This is a final rational solution. I think.<br>&gt;&gt; <br>&gt;&gt; -Jiannan<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
