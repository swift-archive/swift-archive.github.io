<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8da0cba30fa0e47cf4fb26ebb968e552?s=50"></div><header><strong>IOKit and USB devices with swift 3</strong> from <string>Jérôme Duquennoy</string> &lt;jerome+swift at duquennoy.fr&gt;<p>September 23, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi swift community,<br></p><p>I am trying to access an USB device in a swift project, with quite limited knowledge of IOKit and not a log of experience using unsafe pointers with swift.<br></p><p>My goal is to create a class that will listen to connections and disconnections of a device matching a productID and vendorID.<br>What I have done up to now is extensively based on that documentation (not swift oriented) :<br>https://developer.apple.com/library/content/documentation/DeviceDrivers/Conceptual/USBBook/USBDeviceInterfaces/USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIEIEII &lt;https://developer.apple.com/library/content/documentation/DeviceDrivers/Conceptual/USBBook/USBDeviceInterfaces/USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIEIEII&gt;<br> <br>The result of my tests and trial can be found here : http://pastebin.com/rSqdFMwH &lt;http://pastebin.com/rSqdFMwH&gt;<br>(sorry for the pastebin link, but the code is almost 300 lines, which is quite a lot for a mail)<br></p><p>This code compiles on Xcode 8, and the callbacks on plugging and unplugging the device works fine.<br>But it systematically crashes with an EXC_BAD_ACCESS on the first use of the IOUSBDeviceInterface when a device is detected (on line 143, when trying to open the device).<br></p><p>I guess to have such an error, I must be messing badly with the UnsaveMutablePointer.<br></p><p>Would anyone master IOKit and swift enough to spot my mistake ?<br>You can test it by executing that  code in a sample project :<br></p><p>try USBDevice(vendorId: 0x04d8, productId: 0xf372)<br></p><p>where vendorId and productId should match one of your connected devices.<br></p><p>Also, there are very few exemples of swift code dealing with IOKit and USB, I would be glad to contribute by publishing that code if I can have it working !<br></p><p>Thanks for your help !<br></p><p>Jerome<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160923/90de6de3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2bc666e29724cd3bdf46b6cbbe4a07bb?s=50"></div><header><strong>IOKit and USB devices with swift 3</strong> from <string>Quinn &quot;The Eskimo!&quot;</string> &lt;eskimo1 at apple.com&gt;<p>September 26, 2016 at 10:00:00am</p></header><div class="content"><p>On 23 Sep 2016, at 17:46, Jérôme Duquennoy via swift-users &lt;swift-users at swift.org&gt; wrote:<br></p><p>&gt; I am trying to access an USB device in a swift project, with quite limited knowledge of IOKit and not a [lot] of experience using unsafe pointers with swift.<br></p><p>Oh, fun times!<br></p><p>First things first, you don’t need IOMasterPort; use kIOMasterPortDefault instead.<br></p><p>Second, IOServiceMatching won’t return nil unless you run out of memory; you can just ignore that possibility.<br></p><p>Next, unless you absolutely have to, I’d avoid getting between IOServiceMatching and IOServiceAddMatchingNotification.  These two have unusual memory management behaviour (IOServiceMatching returns a +1 reference and IOServiceAddMatchingNotification consumes that reference).  It looks like the current SDK has the right annotations for this but it’s still easy to run into trouble.<br></p><p>IO_OBJECT_NULL rather than 0.<br></p><p>There’s two parts to your overall problem:<br></p><p>A. discovering devices<br></p><p>B. talking to devices<br></p><p>I’d separate these so you can debug them independently.  Specifically, you can test B from a single matching service (IOServiceGetMatchingService) without having to deal with A at all.  You can then generalise that to a list (using IOServiceGetMatchingServices) before moving on to tackle A.<br></p><p>As to your actual crash, you seem to be missing a level of indirection in `getDeviceInterface(forPluginInterface:)`.  Consider this code:<br></p><p>200   private func getDeviceInterface(forPluginInterface pluginInterfacePtrP…<br>201     var deviceInterfaceRawPtr: UnsafeMutableRawPointer? = nil<br>202  <br>203     let deviceInterfaceResult = pluginInterfacePtrPtr.pointee?.pointee.Q…<br>204  <br>205  <br>206     if (deviceInterfaceResult != kIOReturnSuccess) || (deviceInterfaceRa…<br>207       throw Error(&quot;Could not get device interface for plugin interface&quot;)…<br>208     }<br>209  <br>210     return deviceInterfaceRawPtr!.assumingMemoryBound(to: IOUSBDeviceInt…<br>211   }<br></p><p>Expand line 210…211 to this:<br></p><p>210   let res = deviceInterfaceRawPtr!.assumingMemoryBound(to: IOUSBDevice…<br>211   return res<br>212 }<br></p><p>and set a breakpoint on 211.  At the breakpoint `res` is gibberish.<br></p><p>(lldb) p res.pointee<br>(IOUSBDeviceInterface) $R1 = {<br>  _reserved = (_rawValue = 0x000000010916ea48 IOUSBDeviceClass::sUSBDevice…<br>  QueryInterface = 0x0000610000101830 -&gt; 0x000000010916e250 IOUSBLib`vtabl…<br>  AddRef = 0x0000880300008703<br>  Release = nil<br>  …<br>}<br></p><p>Hint: the `Release` property should never be nil (-:<br></p><p>You need to add a level of indirection:<br></p><p>210   let res = deviceInterfaceRawPtr!.assumingMemoryBound(to: <br>        UnsafeMutablePointer&lt;IOUSBDeviceInterface&gt;.self<br>      )<br>211   return res.pointee<br>212 }<br></p><p>at which point your breakpoint on 211 which show sensible results:<br></p><p>(lldb) p res.pointee.pointee<br>(IOUSBDeviceInterface) $R1 = {<br>  _reserved = nil<br>  QueryInterface = 0x000000010a349cc0 IOUSBLib`IOUSBIUnknown::genericQueryInterface(void*, CFUUIDBytes, void**)<br>  AddRef = 0x000000010a349cd2 IOUSBLib`IOUSBIUnknown::genericAddRef(void*)<br>  Release = 0x000000010a349ce2 IOUSBLib`IOUSBIUnknown::genericRelease(void*)<br>  …<br>}<br></p><p>You can see this when you look at the equivalent code in C.  For example, this line:<br></p><p>kr = (*privateDataRef-&gt;deviceInterface)-&gt;GetLocationID(privateDataRef-&gt;deviceInterface, &amp;locationID);<br></p><p>from the USBPrivateDataSample.<br></p><p>&lt;https://developer.apple.com/library/content/samplecode/USBPrivateDataSample/Listings/USBPrivateDataSample_c.html&gt;<br></p><p>`privateDataRef` is indirected once with the `*` and again with the `-&gt;` (in C, `foo-&gt;bar` expands to `(*foo).bar`.<br></p><p>I recommend that you take a leaf out of the C’s book here and store the double indirected value.  That is, have `getDeviceInterface(forPluginInterface:)` return `UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;IOUSBDeviceInterface&gt;&gt;` rather than `UnsafeMutablePointer&lt;IOUSBDeviceInterface&gt;`.<br></p><p>                   *                   *                   *<br></p><p>This is all super unpleasant and I wish I had time to write up more detailed instructions.  Hopefully this will get you unblocked.<br></p><p>Share and Enjoy<br>--<br>Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2bc666e29724cd3bdf46b6cbbe4a07bb?s=50"></div><header><strong>IOKit and USB devices with swift 3</strong> from <string>Quinn &quot;The Eskimo!&quot;</string> &lt;eskimo1 at apple.com&gt;<p>September 26, 2016 at 11:00:00am</p></header><div class="content"><p>On 26 Sep 2016, at 10:48, Quinn The Eskimo! via swift-users &lt;swift-users at swift.org&gt; wrote:<br></p><p>&gt; Next, unless you absolutely have to, I’d avoid getting between IOServiceMatching and IOServiceAddMatchingNotification.  These two have unusual memory management behaviour (IOServiceMatching returns a +1 reference and IOServiceAddMatchingNotification consumes that reference).  It looks like the current SDK has the right annotations for this but it’s still easy to run into trouble.<br></p><p>And, and if you do get between these two it’s probably easiest to work in ‘CFDictionary space’ rather than try to treat this stuff as a Swift dictionary.  This will help:<br></p><p>func CFDictionarySetValue(_ dict: CFMutableDictionary, _ key: String, _ valueObj: AnyObject) {<br>    let keyObj = key as NSString<br>    withExtendedLifetime(keyObj) {<br>        CFDictionarySetValue(dict, Unmanaged.passUnretained(keyObj).toOpaque(), Unmanaged.passUnretained(valueObj).toOpaque())<br>    }<br>}<br></p><p>Share and Enjoy<br>--<br>Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
