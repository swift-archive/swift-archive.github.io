<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f9c95b0463cf51d7b12cca427e706118?s=50"></div><header><strong>Is &#39;self&#39; retained instead of member-function?</strong> from <string>bishal ghimire</string> &lt;bishal.ghimire at gmail.com&gt;<p>February 14, 2016 at 12:00:00pm</p></header><div class="content"><p>Swift book has very good examples and well documented on it - <br></p><p>“myFunction { print(self.title) }                    // strong capture<br>myFunction { [weak self] in print(self!.title) }    // weak capture<br>myFunction { [unowned self] in print(self.title) }  // unowned capture”<br></p><p>Excerpt From: Apple Inc. “The Swift Programming Language (Swift 2.2 Prerelease).” iBooks. https://itun.es/us/k5SW7.l<br></p><p>Another example <br></p><p>“lazy var someClosure: (Int, String) -&gt; String = {<br>    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in<br>    // closure body goes here<br>}”<br></p><p>“Weak and Unowned References<br>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.<br></p><p>Conversely, define a capture as a weak reference when the captured reference may become nil at some point in the future. Weak references are always of an optional type, and automatically become nil when the instance they reference is deallocated. This enables you to check for their existence within the closure’s body.<br></p><p>NOTE<br></p><p>If the captured reference will never become nil, it should always be captured as an unowned reference, rather than a weak reference.<br></p><p>An unowned reference is the appropriate capture method to use to resolve the strong reference cycle in the HTMLElement example from earlier. Here’s how you write the HTMLElement class to avoid the cycle:<br></p><p>class HTMLElement {<br>    <br>    let name: String<br>    let text: String?<br>    <br>    lazy var asHTML: Void -&gt; String = {<br>        [unowned self] in<br>        if let text = self.text {<br>            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;<br>        } else {<br>            return &quot;&lt;\(self.name) /&gt;&quot;<br>        }<br>    }<br>    <br>    init(name: String, text: String? = nil) {<br>        self.name = name<br>        self.text = text<br>    }<br>    <br>    deinit {<br>        print(&quot;\(name) is being deinitialized&quot;)<br>    }<br>    <br>}<br>This implementation of HTMLElement is identical to the ”<br>“        } else {<br>            return &quot;&lt;\(self.name) /&gt;&quot;<br>        }<br>    }<br>    <br>    init(name: String, text: String? = nil) {<br>        self.name = name<br>        self.text = text<br>    }<br>    <br>    deinit {<br>        print(&quot;\(name) is being deinitialized&quot;)<br>    }<br>    <br>}<br>This implementation of HTMLElement is identical to the previous implementation, apart from the addition of a capture list within the asHTML closure. In this case, the capture list is [unowned self], which means “capture self as an unowned reference rather than a strong reference”.<br></p><p>You can create and print an HTMLElement instance as before:<br></p><p>var paragraph: HTMLElement? = HTMLElement(name: &quot;p&quot;, text: &quot;hello, world&quot;)<br>print(paragraph!.asHTML())<br>// Prints &quot;&lt;p&gt;hello, world&lt;/p&gt;&quot;<br>Here’s how the references look with the capture list in place:<br></p><p>“This time, the capture of self by the closure is an unowned reference, and does not keep a strong hold on the HTMLElement instance it has captured. If you set the strong reference from the paragraph variable to nil, the HTMLElement instance is deallocated, as can be seen from the printing of its deinitializer message in the example below:<br></p><p>paragraph = nil<br>// Prints &quot;p is being deinitialized&quot;<br>For more information about capture lists, see Capture Lists.”<br></p><p>Excerpt From: Apple Inc. “The Swift Programming Language (Swift 2.2 Prerelease).” iBooks. https://itun.es/us/k5SW7.l<br></p><p><br>Excerpt From: Apple Inc. “The Swift Programming Language (Swift 2.2 Prerelease).” iBooks. https://itun.es/us/k5SW7.l<br></p><p>&gt; Yeah, &#39;self&#39; is always a strong reference if it isn&#39;t overridden by a capture list declaration, as are all arguments.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; &gt; On Feb 10, 2016, at 12:33 PM, Daniel Tartaglia via swift-users&lt;swift-users at swift.org&gt;wrote:<br>&gt; &gt; <br>&gt; &gt; In the code below, I’m confused as to wether ‘self’ is owned, unowned or retained inside the ‘bar()’ function. I was assuming that it would always be retained, but I am wondering if that’s correct… Especially the ‘unownedThunk’ example… I don’t recall anything in the Swift book explicitly answering this question.<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; class Foo {<br>&gt; &gt; <br>&gt; &gt; init() {<br>&gt; &gt; ownedThunk = {<br>&gt; &gt; self.bar()<br>&gt; &gt; }<br>&gt; &gt; unownedThunk = { [unowned self] in<br>&gt; &gt; self.bar()<br>&gt; &gt; }<br>&gt; &gt; weakThunk = { [weak self] in<br>&gt; &gt; self?.bar()<br>&gt; &gt; }<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; func bar() {<br>&gt; &gt; // is &#39;self&#39; owned/unowned/weak? here?<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; private var ownedThunk: () -&gt;Void = { }<br>&gt; &gt; private var unownedThunk: () -&gt;Void = { }<br>&gt; &gt; private var weakThunk: () -&gt;Void = { }<br>&gt; &gt; <br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-users mailing list<br>&gt; &gt; swift-users at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br>&gt; <br>&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
