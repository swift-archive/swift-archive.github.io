<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 18, 2016 at 03:00:00pm</p></header><div class="content"><p>on Fri Apr 15 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;&gt; Are there potential conforming types which aren&#39;t Comparable?<br>&gt;&gt; <br>&gt;&gt; Not at present, but I expect there to be in the future.  Modular integers and complex numbers come to mind as the most obvious examples.<br>&gt;<br>&gt; Ooh, those are great examples. That is definitely the right decision, then.<br>&gt;<br>&gt; (One thing I&#39;ve been vaguely concerned with is dimensional analysis. A<br>&gt; strong type system opens up the possibility of marking numbers with<br>&gt; units, or at least dimensions, so that the type system can catch when<br>&gt; you try to pass a Second&lt;Pound&lt;T&gt;&gt; to a call that&#39;s expecting a<br>&gt; Second&lt;Newton&lt;T&gt;&gt;. Doing this properly requires more freedom in the<br>&gt; multiplication and division operators&#39; parameters and return<br>&gt; values—but of course, it also requires higher-kinded types to<br>&gt; construct the right return values, so it&#39;s out of reach for Swift 3<br>&gt; anyway.)<br>&gt;<br>&gt;&gt;&gt;&gt; /// NaN `payloads`.  `FloatingPoint` types should either treat inadmissible<br>&gt;&gt;&gt;&gt; /// payloads as zero, or mask them to create an admissible payload.<br>&gt;&gt;&gt;&gt; static func nan(payload payload: RawSignificand, signaling: Bool) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This seems unusually tolerant of bad inputs. Should this instead be<br>&gt;&gt;&gt; a precondition, and have an (elidable in unchecked mode) trap if<br>&gt;&gt;&gt; it&#39;s violated?<br>&gt;&gt; <br>&gt;&gt; I don’t think that it’s a particularly useful error to detect,<br>&gt;<br>&gt; Maybe it&#39;s just my lack of knowledge, but I feel like, if you are<br>&gt; calling this method, you probably care about getting that payload into<br>&gt; the resulting NaN. Otherwise you would be using the `nan`<br>&gt; property. (There is no `signalingNan` property, but there could be.)<br>&gt;<br>&gt; What do people use NaN payloads for? Are there a lot of cases where<br>&gt; the payload is a nice-to-have, but it&#39;s okay to destroy or even mangle<br>&gt; it?<br></p><p>Another option: trap the precondition violation only in debug builds.<br></p><p>&gt;&gt; and different floating point types may differ greatly in what<br>&gt;&gt; payloads they support (if any), because they might choose to reserve<br>&gt;&gt; those encodings for other purposes.<br>&gt;<br>&gt; If the data you can actually get into a NaN varies so much from one<br>&gt; type to another, is this API a useful one to offer on the protocol? Is<br>&gt; it something you can reliably use on &quot;any floating-point type&quot; without<br>&gt; knowing which type it is?<br>&gt;<br>&gt; (It also now occurs to me that this might be better off as an initializer: `init(nanWithPayload:signaling:)`.)<br>&gt;<br>&gt;&gt;&gt; Reading these, I find the use of &quot;least&quot; a little bit misleading—it seems like they should be negative.<br>&gt;&gt; <br>&gt;&gt; Magnitudes are strictly positive.  In fairness, that may not be immediately obvious to all readers.<br>&gt;<br>&gt; It does make sense now that you&#39;ve said so! It might be a good doc comment note, though.<br>&gt;<br>&gt;&gt;&gt; 	static var positiveNormals: ClosedRange&lt;Self&gt; { get }<br>&gt;&gt;&gt; 	static var positiveSubnormals: ClosedRange&lt;Self&gt; { get }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	Double.positiveNormals.upperBound		// DBL_MAX<br>&gt;&gt;&gt; 	Double.positiveNormals.lowerBound		// DBL_MIN<br>&gt;&gt;&gt; 	Double.positiveSubnormals.upperBound	// Self.positiveNormals.lowerBound.nextDown<br>&gt;&gt;&gt; 	Double.positiveSubnormals.lowerBound	// 0.nextUp<br>&gt;&gt; <br>&gt;&gt; This seems wildly over-engineered to me personally.  Every language<br>&gt;&gt; I surveyed provides (a subset of) these quantities as simple scalar<br>&gt;&gt; values.<br>&gt;<br>&gt; Well, I am rather prone to wild over-engineering. :^)<br>&gt;<br>&gt; One place where a range like FloatingPoint.positives would be useful is in random number generation. Suppose you have:<br>&gt;<br>&gt; 	protocol Randomizer {<br>&gt; 		…<br>&gt; 		mutating func choice&lt;T: FloatingPoint&gt;(from choices: ClosedRange&lt;T&gt;) -&gt; T<br>&gt; 		…<br>&gt; 	}<br>&gt;<br>&gt; Which lets you say:<br>&gt;<br>&gt; 	rng.choice(from: 0...1)<br>&gt;<br>&gt; It would then be nice to say something like:<br>&gt;<br>&gt; 	rng.choice(from: Double.positives)<br>&gt; 	rng.choice(from: Float.finites)<br>&gt; 	// etc.<br>&gt;<br>&gt; Of course, the set of ranges useful for that purpose is probably different from these more technical things, so that might not be the best design anyway.<br>&gt;<br>&gt;&gt;&gt;&gt; public protocol FloatingPoint: SignedArithmetic, Comparable {<br>&gt;&gt;&gt;&gt; func isLess(than other: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt; func totalOrder(with other: Self) -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift 2&#39;s Comparable demands a strict total order. However, the<br>&gt;&gt;&gt; documentation here seems to imply that totalOrder is *not* what you<br>&gt;&gt;&gt; get from the &lt; operator. Is something getting reshuffled here?<br>&gt;&gt; <br>&gt;&gt; The Swift 2 Comparable documentation is probably overly specific.<br>&gt;&gt; The requirement should really be something like a strict total order<br>&gt;&gt; on non-exceptional values.<br>&gt;<br>&gt; Okay.<br>&gt;<br>&gt; (While I was waiting for your reply, I was thinking about a rework of<br>&gt; `Comparable` which had a sort-oriented `totalOrder(_:)` as a<br>&gt; requirement and `isLess(_:)`, `isGreater(_:)`, et. al. which defaulted<br>&gt; to using `totalOrder(_:)`, but could be overridden for types like<br>&gt; FloatingPoint with exceptional values. I should just wait for answers<br>&gt; sometimes.)<br></p><p>We&#39;re still interested in doing something like that.<br></p><p>&gt;<br>&gt;<br>&gt;&gt;&gt; Also, since `init(_:)` is lossy and `init(exactly:)` is not,<br>&gt;&gt;&gt; shouldn&#39;t their names technically be switched? Or perhaps<br>&gt;&gt;&gt; `init(_:)` should be exact and trapping, `init(exactly:)` should be<br>&gt;&gt;&gt; failable, and `init(closest:)` should always return something or<br>&gt;&gt;&gt; other?<br>&gt;&gt; <br>&gt;&gt; That would be a large change in the existing behavior, since we only<br>&gt;&gt; have the (potentially lossy) init(_:) today.  It would also be<br>&gt;&gt; something of a surprise to users of C family languages.  That’s not<br>&gt;&gt; to say that it’s necessarily wrong, but it would break a lot of<br>&gt;&gt; people’s code an expectations, and I was trying to make this<br>&gt;&gt; proposal fairly benign, with a focus on adding missing features.<br>&gt;<br>&gt; Sure, but it&#39;s also a surprise when integers don&#39;t roundtrip through<br>&gt; floats. (See: every JSON-based API which had to add an &quot;id_str&quot; field<br>&gt; when their ID numbers got too big.) I&#39;m not entirely certain it&#39;s the<br>&gt; right move—you&#39;re right that people with a C background wouldn&#39;t<br>&gt; expect it—but silently doing the wrong thing is a bit suspicious in<br>&gt; Swift.<br></p><p>-- <br>Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
