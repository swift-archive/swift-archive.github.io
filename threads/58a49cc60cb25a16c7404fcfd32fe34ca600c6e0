<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 22, 2016 at 01:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of SE-0006 &quot;Apply API Guidelines to the Standard Library&quot; begins now and runs through January 31, 2016. The proposal is available here:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md<br>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br></p><p>Proposal link:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md<br>Reply text<br></p><p>Other replies<br> &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>What is your evaluation of the proposal?<br>Is the problem being addressed significant enough to warrant a change to Swift?<br>Does this proposal fit well with the feel and direction of Swift?<br>If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>More information about the Swift evolution process is available at<br></p><p>https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>Thank you,<br></p><p>-Doug Gregor<br></p><p>Review Manager<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160122/58a4c6e0/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January 22, 2016 at 03:00:00pm</p></header><div class="content"><p>Really quickly, I think this is a mistake:<br></p><p>SequenceType.minElement() =&gt; .min(), .maxElement() =&gt; .max().<br> extension Sequence {<br>-  public func minElement(<br>+  public func minElement(<br>     @noescape isOrderedBefore: (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>   ) rethrows -&gt; Iterator.Element?<br></p><p>-  public func maxElement(<br>+  public func maxElement(<br>     @noescape isOrderedBefore: (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>   ) rethrows -&gt; Iterator.Element?<br> }<br></p><p> extension Sequence where Iterator.Element : Comparable {<br>-  public func minElement() -&gt; Iterator.Element?<br>+  public func minElement() -&gt; Iterator.Element?<br></p><p>-  public func maxElement() -&gt; Iterator.Element?<br>+  public func maxElement() -&gt; Iterator.Element?<br> }<br>…shouldn’t those diffs have them changed to be `min()` and `max()`?<br></p><p>&gt; On Jan 22, 2016, at 3:02 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0006 &quot;Apply API Guidelines to the Standard Library&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/cc306318/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 22, 2016 at 04:00:00pm</p></header><div class="content"><p>On Fri, Jan 22, 2016 at 1:27 PM, plx via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Really quickly, I think this is a mistake:<br>&gt;<br>&gt; SequenceType.minElement() =&gt; .min(), .maxElement() =&gt; .max().<br>&gt;<br>&gt;  extension Sequence {<br>&gt; -  public func minElement(<br>&gt; +  public func minElement(<br>&gt;      @noescape isOrderedBefore: (Iterator.Element, Iterator.Element) throws<br>&gt; -&gt; Bool<br>&gt;    ) rethrows -&gt; Iterator.Element?<br></p><p>Thanks, fixed!<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 22, 2016 at 07:00:00pm</p></header><div class="content"><p>- MutableSliceable was removed. Use CollectionType where SubSequence :<br>   MutableCollectionType instead.<br></p><p><br>With the new protocol names, this bullet should be the following in both<br>places:<br></p><p><br>   - MutableSliceable was removed. Use Collection where SubSequence :<br>   MutableCollection instead.<br></p><p><br>On Fri, Jan 22, 2016 at 4:02 PM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of SE-0006 &quot;Apply API Guidelines to the Standard Library&quot;<br>&gt; begins now and runs through January 31, 2016. The proposal is available<br>&gt; here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at the<br>&gt; top of the message:<br>&gt;<br>&gt; Proposal link:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md<br>&gt;<br>&gt; Reply text<br>&gt;<br>&gt; Other replies<br>&gt;<br>&gt; &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt; goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt;    - What is your evaluation of the proposal?<br>&gt;    - Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;    - Does this proposal fit well with the feel and direction of Swift?<br>&gt;    - If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;    - How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Doug Gregor<br>&gt;<br>&gt; Review Manager<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/734d86b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 22, 2016 at 04:00:00pm</p></header><div class="content"><p>On Fri, Jan 22, 2016 at 4:14 PM, Trent Nadeau via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; MutableSliceable was removed. Use CollectionType where SubSequence :<br>&gt; MutableCollectionType instead.<br>&gt;<br>&gt;<br>&gt; With the new protocol names, this bullet should be the following in both<br>&gt; places:<br>&gt;<br>&gt; MutableSliceable was removed. Use Collection where SubSequence :<br>&gt; MutableCollection instead.<br></p><p>Thank you, fixed that!<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>January 23, 2016 at 12:00:00am</p></header><div class="content"><p>Proposal link:<br></p><p>&lt;https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md&gt;<br></p><p>The `Sequence.split` methods both have a `maxSplits: Int = Int.max` parameter, but this parameter is unlabelled (i.e. a local-only name) in one of the methods. This is more obvious when looking at the documentation [1], which doesn&#39;t follow the Swift convention for local/external parameter names.<br></p><p>[1]: &lt;https://developer.apple.com/library/ios/documentation/Swift/Reference/Swift_SequenceType_Protocol/&gt;<br></p><p>Also, the naming convention proposed by David Owens II in the &quot;named parameters&quot; thread [2] would allow for default parameter values to be added later. For example, see the `SequenceType.joinWithSeparator` methods.<br></p><p>[2]: &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007234.html&gt;<br></p><p>-- Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>January 23, 2016 at 12:00:00am</p></header><div class="content"><p>Hello,<br></p><p>I disagree with the following change to UnsafeMutablePointer:<br>-  public static func alloc(num: Int) -&gt; UnsafeMutablePointer&lt;Pointee&gt;<br>+  public init(allocatingCapacity count: Int)<br></p><p>This would make it the only constructor in any of OpaquePointer, UnsafePointer, UnsafeMutablePointer and UnsafeReference to have the side-effect of allocating memory. All the others are relatively cheap transformations on pointer values, and get used a lot for typecasting. An allocating constructor would be less locatable among such uses of typecasting-via-constructor. The memory-allocating static method has the merit of sticking out, and pairs nicely with the necessary deallocation call, like the malloc/free pair.<br></p><p>Cheers,<br>Guillaume Lessard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Evolving UnsafeMutablePointer.alloc (was Re: [Review] SE-0006 Apply API Guidelines to the Standard Library)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 23, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 11:31 PM, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello,<br>&gt; <br>&gt; I disagree with the following change to UnsafeMutablePointer:<br>&gt; -  public static func alloc(num: Int) -&gt; UnsafeMutablePointer&lt;Pointee&gt;<br>&gt; +  public init(allocatingCapacity count: Int)<br>&gt; <br>&gt; This would make it the only constructor in any of OpaquePointer, UnsafePointer, UnsafeMutablePointer and UnsafeReference to have the side-effect of allocating memory. All the others are relatively cheap transformations on pointer values, and get used a lot for typecasting. An allocating constructor would be less locatable among such uses of typecasting-via-constructor. The memory-allocating static method has the merit of sticking out, and pairs nicely with the necessary deallocation call, like the malloc/free pair.<br></p><p>This all probably deserves a separate discussion from the overall umbrella proposal. Another thing to consider here is whether the logic to allocate an array of values really belongs on UnsafeMutablePointer—it seems like a better fit for UnsafeMutableBufferPointer, whose whole job is to reference an array of objects in memory. Currently, you need to allocate the memory using UnsafeMutablePointer.alloc, then immediately wrap it in a BufferPointer with the same count, which is a bit awkward.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Evolving UnsafeMutablePointer.alloc (was Re: [Review] SE-0006 Apply API Guidelines to the Standard Library)</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January 23, 2016 at 02:00:00pm</p></header><div class="content"><p>I agree that the need to immediately wrap in a BufferPointer is awkward.<br>I&#39;ve been consistently thrown by the fact that we specify how many items to<br>allocate on the &#39;single&#39; pointers, though.<br></p><p>On Sat, Jan 23, 2016 at 1:08 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 22, 2016, at 11:31 PM, Guillaume Lessard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello,<br>&gt; &gt;<br>&gt; &gt; I disagree with the following change to UnsafeMutablePointer:<br>&gt; &gt; -  public static func alloc(num: Int) -&gt; UnsafeMutablePointer&lt;Pointee&gt;<br>&gt; &gt; +  public init(allocatingCapacity count: Int)<br>&gt; &gt;<br>&gt; &gt; This would make it the only constructor in any of OpaquePointer,<br>&gt; UnsafePointer, UnsafeMutablePointer and UnsafeReference to have the<br>&gt; side-effect of allocating memory. All the others are relatively cheap<br>&gt; transformations on pointer values, and get used a lot for typecasting. An<br>&gt; allocating constructor would be less locatable among such uses of<br>&gt; typecasting-via-constructor. The memory-allocating static method has the<br>&gt; merit of sticking out, and pairs nicely with the necessary deallocation<br>&gt; call, like the malloc/free pair.<br>&gt;<br>&gt; This all probably deserves a separate discussion from the overall umbrella<br>&gt; proposal. Another thing to consider here is whether the logic to allocate<br>&gt; an array of values really belongs on UnsafeMutablePointer—it seems like a<br>&gt; better fit for UnsafeMutableBufferPointer, whose whole job is to reference<br>&gt; an array of objects in memory. Currently, you need to allocate the memory<br>&gt; using UnsafeMutablePointer.alloc, then immediately wrap it in a<br>&gt; BufferPointer with the same count, which is a bit awkward.<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/76d7011e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Evolving UnsafeMutablePointer.alloc (was Re: [Review] SE-0006 Apply API Guidelines to the Standard Library)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 23, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 11:38 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; I agree that the need to immediately wrap in a BufferPointer is awkward. I&#39;ve been consistently thrown by the fact that we specify how many items to allocate on the &#39;single&#39; pointers, though.<br></p><p>Definitely. It would make sense to me if UnsafeMutablePointer&#39;s allocation and deallocation APIs worked only for single values, and UnsafeMutableBufferPointer provided similar APIs to allocate and deallocate arrays.<br></p><p>Another thing that might be handy on both types is a `withAllocation { }` function for scoped allocations, which would dealloc for you at block exit (and maybe optionally destroy first).<br></p><p>-Joe<br></p><p>&gt; <br>&gt; On Sat, Jan 23, 2016 at 1:08 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Jan 22, 2016, at 11:31 PM, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello,<br>&gt; &gt;<br>&gt; &gt; I disagree with the following change to UnsafeMutablePointer:<br>&gt; &gt; -  public static func alloc(num: Int) -&gt; UnsafeMutablePointer&lt;Pointee&gt;<br>&gt; &gt; +  public init(allocatingCapacity count: Int)<br>&gt; &gt;<br>&gt; &gt; This would make it the only constructor in any of OpaquePointer, UnsafePointer, UnsafeMutablePointer and UnsafeReference to have the side-effect of allocating memory. All the others are relatively cheap transformations on pointer values, and get used a lot for typecasting. An allocating constructor would be less locatable among such uses of typecasting-via-constructor. The memory-allocating static method has the merit of sticking out, and pairs nicely with the necessary deallocation call, like the malloc/free pair.<br>&gt; <br>&gt; This all probably deserves a separate discussion from the overall umbrella proposal. Another thing to consider here is whether the logic to allocate an array of values really belongs on UnsafeMutablePointer—it seems like a better fit for UnsafeMutableBufferPointer, whose whole job is to reference an array of objects in memory. Currently, you need to allocate the memory using UnsafeMutablePointer.alloc, then immediately wrap it in a BufferPointer with the same count, which is a bit awkward.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/d90b8d2c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Evolving UnsafeMutablePointer.alloc (was Re: [Review] SE-0006 Apply API Guidelines to the Standard Library)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 23, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 11:56 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 23, 2016, at 11:38 AM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree that the need to immediately wrap in a BufferPointer is awkward. I&#39;ve been consistently thrown by the fact that we specify how many items to allocate on the &#39;single&#39; pointers, though.<br>&gt; <br>&gt; Definitely. It would make sense to me if UnsafeMutablePointer&#39;s allocation and deallocation APIs worked only for single values, and UnsafeMutableBufferPointer provided similar APIs to allocate and deallocate arrays.<br></p><p>I agree, that makes a lot of sense.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/d2449d97/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 23, 2016 at 12:00:00am</p></header><div class="content"><p>Proposal link:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md<br></p><p>&gt; What is your evaluation of the proposal?<br></p><p>I believe the Unmanaged -&gt; UnsafeReference / OpaquePointer changes are too<br>large to be part of this proposal; they should be reviewed separately.<br>There was some discussion about this in a thread last month. Particularly,<br>I&#39;m concerned that there is still a gap between UnsafePointer&lt;Void&gt; and<br>OpaquePointer APIs. I submitted a related proposal, SE-0017, which was<br>never scheduled for review:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0017-convert-unmanaged-to-use-unsafepointer.md<br></p><p>I&#39;m also a little concerned about Integer, SignedInteger, and<br>UnsignedInteger, which are protocols but might look like concrete integer<br>types to the reader. My first thought is that &quot;Integral&quot; would be better<br>for this, but it doesn&#39;t match the &quot;noun or capability&quot; note in the API<br>design guidelines.<br></p><p>Otherwise, I&#39;m generally fine with the proposed changes.<br></p><p><br>&gt; Is the problem being addressed significant enough to warrant a change to<br>Swift?<br></p><p>Yes; consistency is important.<br></p><p><br>&gt; Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes, by definition.<br></p><p><br>&gt; How much effort did you put into your review? A glance, a quick reading,<br>or an in-depth study?<br></p><p>Fairly in-depth.<br></p><p>Jacob<br></p><p>On Fri, Jan 22, 2016 at 1:02 PM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of SE-0006 &quot;Apply API Guidelines to the Standard Library&quot;<br>&gt; begins now and runs through January 31, 2016. The proposal is available<br>&gt; here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at the<br>&gt; top of the message:<br>&gt;<br>&gt; Proposal link:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md<br>&gt;<br>&gt; Reply text<br>&gt;<br>&gt; Other replies<br>&gt;<br>&gt; &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt; goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt;    - What is your evaluation of the proposal?<br>&gt;    - Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;    - Does this proposal fit well with the feel and direction of Swift?<br>&gt;    - If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;    - How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Doug Gregor<br>&gt;<br>&gt; Review Manager<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/3439a6fb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6c95cd06f79f91eaf9f58e4f1c50a25a?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Ondrej Barina</string> &lt;obarina at gmail.com&gt;<p>January 23, 2016 at 11:00:00am</p></header><div class="content"><p>+1 for proposal<br>Ondrej<br></p><p>On Sat, Jan 23, 2016 at 9:59 AM, Jacob Bandes-Storch via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Proposal link:<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md<br>&gt;<br>&gt; &gt; What is your evaluation of the proposal?<br>&gt;<br>&gt; I believe the Unmanaged -&gt; UnsafeReference / OpaquePointer changes are too<br>&gt; large to be part of this proposal; they should be reviewed separately.<br>&gt; There was some discussion about this in a thread last month. Particularly,<br>&gt; I&#39;m concerned that there is still a gap between UnsafePointer&lt;Void&gt; and<br>&gt; OpaquePointer APIs. I submitted a related proposal, SE-0017, which was<br>&gt; never scheduled for review:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0017-convert-unmanaged-to-use-unsafepointer.md<br>&gt;<br>&gt; I&#39;m also a little concerned about Integer, SignedInteger, and<br>&gt; UnsignedInteger, which are protocols but might look like concrete integer<br>&gt; types to the reader. My first thought is that &quot;Integral&quot; would be better<br>&gt; for this, but it doesn&#39;t match the &quot;noun or capability&quot; note in the API<br>&gt; design guidelines.<br>&gt;<br>&gt; Otherwise, I&#39;m generally fine with the proposed changes.<br>&gt;<br>&gt;<br>&gt; &gt; Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt;<br>&gt; Yes; consistency is important.<br>&gt;<br>&gt;<br>&gt; &gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; Yes, by definition.<br>&gt;<br>&gt;<br>&gt; &gt; How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?<br>&gt;<br>&gt; Fairly in-depth.<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; On Fri, Jan 22, 2016 at 1:02 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hello Swift community,<br>&gt;&gt;<br>&gt;&gt; The review of SE-0006 &quot;Apply API Guidelines to the Standard Library&quot;<br>&gt;&gt; begins now and runs through January 31, 2016. The proposal is available<br>&gt;&gt; here:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md<br>&gt;&gt;<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt; review manager. When replying, please try to keep the proposal link at the<br>&gt;&gt; top of the message:<br>&gt;&gt;<br>&gt;&gt; Proposal link:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md<br>&gt;&gt;<br>&gt;&gt; Reply text<br>&gt;&gt;<br>&gt;&gt; Other replies<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt;&gt; goes into a review?<br>&gt;&gt;<br>&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt; through constructive criticism and, eventually, determine the direction of<br>&gt;&gt; Swift. When writing your review, here are some questions you might want to<br>&gt;&gt; answer in your review:<br>&gt;&gt;<br>&gt;&gt;    - What is your evaluation of the proposal?<br>&gt;&gt;    - Is the problem being addressed significant enough to warrant a<br>&gt;&gt;    change to Swift?<br>&gt;&gt;    - Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;    - If you have used other languages or libraries with a similar<br>&gt;&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;&gt;    - How much effort did you put into your review? A glance, a quick<br>&gt;&gt;    reading, or an in-depth study?<br>&gt;&gt;<br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt;<br>&gt;&gt; -Doug Gregor<br>&gt;&gt;<br>&gt;&gt; Review Manager<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/5cec3cb7/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>January 25, 2016 at 04:00:00pm</p></header><div class="content"><p>Hello all,<br></p><p>Just like with SE-0005 &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007658.html&gt;, I’m overwhelmingly for this proposal. The Guidelines, as a whole do a great job at making Swift APIs more consistent and clearer, and applying them to the Swift stdlib is an important first step.<br></p><p>* * *<br></p><p>Nitpicks, criticisms and suggestions:<br></p><p>== precondition was renamed to require ==<br></p><p>This might be confusing to newcomers, as many languages use the word `require` as a keyword for what we&#39;d call `import`. Although a bit more technical, `precondition` is unambiguous and still easily understandable. I feel like `required` does more damage than good.<br></p><p>== Removed Type from protocol names ==<br></p><p>Perhaps I’ve missed some discussion about this and I don’t see the context, but I’m not sure this is a positive change.<br></p><p>I fear this might be confusing in practice, at least in some contexts. For example, there&#39;s nothing signifying that &quot;Boolean&quot; or &quot;Integer&quot; are protocols and not actual types. Same with “Sequence”, “OptionSet”, etc. Perhaps it doesn&#39;t matter because everyone will naturally go for `Bool`, `Int`, and `Array` anyway. But I can imagine a lot of confusion if someone tried that anyway, or perhaps saw that in the autocompletion, or the standard library browser (with no intention of using the protocol).<br></p><p>I’m all for removing unnecessary noise and verbosity, but I think I would err on explicitness side here. It seemed like the -able/-Type convention did a good job disambiguating types you can actually instantiate from protocols, with very little “verbosity cost”.<br></p><p>== sort() =&gt; sorted(), sortInPlace() =&gt; sort() etc ==<br></p><p>I’m torn on this.<br></p><p>Frankly, I find both the “foo/fooInPlace” and “bar/barred” conventions awkward. Both seem weird. “InPlace” isn’t something I recall seeing anywhere else in API naming, and seems a bizarre way of signifying mutability. “-ed” doesn’t work with all words, so you sometimes have to go with “-ing”, or give up and cry. And then you have inconsistency that “-InPlace” doesn’t seem to have. Also, -ed/-ing can sometimes be difficult to write, especially for non-natives because of the “last letter is doubled” rule for some words.<br></p><p>But my biggest problem with this change is that IMHO we should encourage to use the transforming (non-mutating) variants by default. One way to achieve this as an API designer and slightly push people towards doing what’s considered best practice is to make the preferable variant easier to type. This might be a subtle change, but I think it matters. Before, if you really wanted to mutate something in place, you had to do that extra little bit of work typing “sortInPlace”, whereas what would be preferable most of the time had a simpler, shorter form: “sort” and would appear earlier in autocomplete.<br></p><p>== -ings in argument names ==<br></p><p>I’ve noticed these few tweaks in naming:<br></p><p>&gt; -  mutating func removeAll(keepCapacity keepCapacity: Bool = false)<br>&gt; +  mutating func removeAll(keepingCapacity keepingCapacity: Bool = false)<br>&gt; <br>&gt;  public func transcode&lt;...&gt;(...<br>&gt; -  stopOnError: Bool<br>&gt; +  stoppingOnError: Bool<br>&gt;  ) -&gt; Bool<br>&gt; <br>&gt;  +  public init(allocatingCapacity count: Int)<br></p><p>I&#39;m against this change. While I&#39;m not fully convinced of the -ed/-ing rule for methods and properties, it does an important job by conveying the non-mutating semantics of a symbol described. In case of argument names, this rationale no longer applies.<br></p><p>The only reason to write &quot;stoppingOnError&quot; instead of &quot;stopOnError&quot; is to make method invocations sound more like real English sentences. This is the conventional Objective-C thinking the Guidelines largely step back from. In my opinion, this is futile and provides no readability benefits in this context. Method invocations are _not_ sentences. It&#39;s not English, it&#39;s code. And while making method names blatantly gramatically incorrect doesn&#39;t help readability, neither does forcing `-ing` endings to all boolean function arguments.<br></p><p>The only thing it does is it adds a few extra characters, an extra word ending the reader has to parse and understand. I know that it&#39;s a non-goal to make Swift code as terse as possible, and I&#39;m not arguing for that. But the Guidelines seem to agree that adding extra verbosity _without a good reason_ is a bad thing. Because every extra word and symbol in code just adds to the cognitive load of the reader. And when it doesn&#39;t serve a purpose, it just decreases the signal-to-noise ratio.<br></p><p>Plus, as mentioned before, `-ed/-ing` can be tricky to spell for non-natives. This might not be a big deal, but given that this change provides no benefits, it&#39;s one more tiny thing you have to be careful not to get wrong when writing Swift.<br></p><p>And it&#39;s unnecessary:<br></p><p>   removeAll(keepCapacity: true)<br>   transcode(foo, bar, stopOnError: true)<br></p><p>Are just as clear and readable as:<br></p><p>   removeAll(keepingCapacity: true)<br>   transcode(foo, bar, stoppingOnError: true)<br></p><p>And the former isn&#39;t gramatically incorrect, because this isn&#39;t a sentence.<br></p><p>Apologies for nitpicking on this tiniest possible detail. I just care a lot that we don&#39;t create a precedent of trying to make everything sound like English unnecessarily and add verbosity bit by bit.<br></p><p>* * *<br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>Yes, and yes, with small details still worth reconsidering.<br></p><p>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I’ve read the whole proposal, as well as the related proposals, and read the thread for this review.<br></p><p>Cross-linking to my SE-0005 review: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007658.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007658.html&gt;<br></p><p>Thanks,<br>— Radek<br></p><p>&gt; On 22 Jan 2016, at 22:02, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0006 &quot;Apply API Guidelines to the Standard Library&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/c4536fc0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January 26, 2016 at 08:00:00am</p></header><div class="content"><p>I agree with all of the small criticisms mentioned below by Radoslaw except for the renaming of precondition() to require(). I think it is an improvement that it describes an action now, just like assert().<br></p><p>Count me among those who liked the ‘Type’ suffix for protocols though.<br></p><p>—CK<br></p><p>&gt; On Jan 25, 2016, at 7:40 AM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello all,<br>&gt; <br>&gt; Just like with SE-0005 &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007658.html&gt;, I’m overwhelmingly for this proposal. The Guidelines, as a whole do a great job at making Swift APIs more consistent and clearer, and applying them to the Swift stdlib is an important first step.<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; Nitpicks, criticisms and suggestions:<br>&gt; <br>&gt; == precondition was renamed to require ==<br>&gt; <br>&gt; This might be confusing to newcomers, as many languages use the word `require` as a keyword for what we&#39;d call `import`. Although a bit more technical, `precondition` is unambiguous and still easily understandable. I feel like `required` does more damage than good.<br>&gt; <br>&gt; == Removed Type from protocol names ==<br>&gt; <br>&gt; Perhaps I’ve missed some discussion about this and I don’t see the context, but I’m not sure this is a positive change.<br>&gt; <br>&gt; I fear this might be confusing in practice, at least in some contexts. For example, there&#39;s nothing signifying that &quot;Boolean&quot; or &quot;Integer&quot; are protocols and not actual types. Same with “Sequence”, “OptionSet”, etc. Perhaps it doesn&#39;t matter because everyone will naturally go for `Bool`, `Int`, and `Array` anyway. But I can imagine a lot of confusion if someone tried that anyway, or perhaps saw that in the autocompletion, or the standard library browser (with no intention of using the protocol).<br>&gt; <br>&gt; I’m all for removing unnecessary noise and verbosity, but I think I would err on explicitness side here. It seemed like the -able/-Type convention did a good job disambiguating types you can actually instantiate from protocols, with very little “verbosity cost”.<br>&gt; <br>&gt; == sort() =&gt; sorted(), sortInPlace() =&gt; sort() etc ==<br>&gt; <br>&gt; I’m torn on this.<br>&gt; <br>&gt; Frankly, I find both the “foo/fooInPlace” and “bar/barred” conventions awkward. Both seem weird. “InPlace” isn’t something I recall seeing anywhere else in API naming, and seems a bizarre way of signifying mutability. “-ed” doesn’t work with all words, so you sometimes have to go with “-ing”, or give up and cry. And then you have inconsistency that “-InPlace” doesn’t seem to have. Also, -ed/-ing can sometimes be difficult to write, especially for non-natives because of the “last letter is doubled” rule for some words.<br>&gt; <br>&gt; But my biggest problem with this change is that IMHO we should encourage to use the transforming (non-mutating) variants by default. One way to achieve this as an API designer and slightly push people towards doing what’s considered best practice is to make the preferable variant easier to type. This might be a subtle change, but I think it matters. Before, if you really wanted to mutate something in place, you had to do that extra little bit of work typing “sortInPlace”, whereas what would be preferable most of the time had a simpler, shorter form: “sort” and would appear earlier in autocomplete.<br>&gt; <br>&gt; == -ings in argument names ==<br>&gt; <br>&gt; I’ve noticed these few tweaks in naming:<br>&gt; <br>&gt;&gt; -  mutating func removeAll(keepCapacity keepCapacity: Bool = false)<br>&gt;&gt; +  mutating func removeAll(keepingCapacity keepingCapacity: Bool = false)<br>&gt;&gt; <br>&gt;&gt;  public func transcode&lt;...&gt;(...<br>&gt;&gt; -  stopOnError: Bool<br>&gt;&gt; +  stoppingOnError: Bool<br>&gt;&gt;  ) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt;  +  public init(allocatingCapacity count: Int)<br>&gt; <br>&gt; I&#39;m against this change. While I&#39;m not fully convinced of the -ed/-ing rule for methods and properties, it does an important job by conveying the non-mutating semantics of a symbol described. In case of argument names, this rationale no longer applies.<br>&gt; <br>&gt; The only reason to write &quot;stoppingOnError&quot; instead of &quot;stopOnError&quot; is to make method invocations sound more like real English sentences. This is the conventional Objective-C thinking the Guidelines largely step back from. In my opinion, this is futile and provides no readability benefits in this context. Method invocations are _not_ sentences. It&#39;s not English, it&#39;s code. And while making method names blatantly gramatically incorrect doesn&#39;t help readability, neither does forcing `-ing` endings to all boolean function arguments.<br>&gt; <br>&gt; The only thing it does is it adds a few extra characters, an extra word ending the reader has to parse and understand. I know that it&#39;s a non-goal to make Swift code as terse as possible, and I&#39;m not arguing for that. But the Guidelines seem to agree that adding extra verbosity _without a good reason_ is a bad thing. Because every extra word and symbol in code just adds to the cognitive load of the reader. And when it doesn&#39;t serve a purpose, it just decreases the signal-to-noise ratio.<br>&gt; <br>&gt; Plus, as mentioned before, `-ed/-ing` can be tricky to spell for non-natives. This might not be a big deal, but given that this change provides no benefits, it&#39;s one more tiny thing you have to be careful not to get wrong when writing Swift.<br>&gt; <br>&gt; And it&#39;s unnecessary:<br>&gt; <br>&gt;    removeAll(keepCapacity: true)<br>&gt;    transcode(foo, bar, stopOnError: true)<br>&gt; <br>&gt; Are just as clear and readable as:<br>&gt; <br>&gt;    removeAll(keepingCapacity: true)<br>&gt;    transcode(foo, bar, stoppingOnError: true)<br>&gt; <br>&gt; And the former isn&#39;t gramatically incorrect, because this isn&#39;t a sentence.<br>&gt; <br>&gt; Apologies for nitpicking on this tiniest possible detail. I just care a lot that we don&#39;t create a precedent of trying to make everything sound like English unnecessarily and add verbosity bit by bit.<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; Yes, and yes, with small details still worth reconsidering.<br>&gt; <br>&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I’ve read the whole proposal, as well as the related proposals, and read the thread for this review.<br>&gt; <br>&gt; Cross-linking to my SE-0005 review: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007658.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007658.html&gt;<br>&gt; <br>&gt; Thanks,<br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 22 Jan 2016, at 22:02, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of SE-0006 &quot;Apply API Guidelines to the Standard Library&quot; begins now and runs through January 31, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md&gt;<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt;&gt; <br>&gt;&gt; Proposal link:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md&gt;<br>&gt;&gt; Reply text<br>&gt;&gt; <br>&gt;&gt; Other replies<br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Doug Gregor<br>&gt;&gt; <br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/c2304ccd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Count me among those who liked the ‘Type’ suffix for protocols though.<br></p><p>I wonder if we can&#39;t change it to a -`like` suffix. Applying that to 2.1 stdlib gives you:<br></p><p>AnyCollectionlike<br>BidirectionalIndexlike<br>BitwiseOperationslike<br>Booleanlike<br>CVarArglike<br>Collectionlike<br>Errorlike<br>FloatingPointlike<br>ForwardIndexlike<br>Generatorlike<br>IntegerArithmeticlike<br>Integerlike<br>Intervallike<br>LazyCollectionlike<br>LazySequencelike<br>MirrorPathlike<br>MutableCollectionlike<br>OptionSetlike<br>OutputStreamlike<br>RandomAccessIndexlike<br>RangeReplaceableCollectionlike<br>ReverseIndexlike<br>Sequencelike<br>SetAlgebralike<br>SignedIntegerlike<br>SignedNumberlike<br>UnicodeCodeclike<br>UnsignedIntegerlike<br></p><p>Not all of these are perfect, but in some cases that&#39;s because they should arguably be -able protocols (BitwiseOperationsType -&gt; BitwiseOperable).<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/78dda0d326b6c8eff7c2679f55346a7f?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Alex Migicovsky</string> &lt;migi at apple.com&gt;<p>January 29, 2016 at 06:00:00pm</p></header><div class="content"><p>IMO the ‘like’ suffix makes it sound like the conforming type to Collectionlike is like a Collection, but not exactly a Collection. Maybe there’s another suffix that works but I don’t think this one conveys the right information.<br></p><p>- Alex<br></p><p>&gt; On Jan 29, 2016, at 6:43 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Count me among those who liked the ‘Type’ suffix for protocols though.<br>&gt; <br>&gt; I wonder if we can&#39;t change it to a -`like` suffix. Applying that to 2.1 stdlib gives you:<br>&gt; <br>&gt; AnyCollectionlike<br>&gt; BidirectionalIndexlike<br>&gt; BitwiseOperationslike<br>&gt; Booleanlike<br>&gt; CVarArglike<br>&gt; Collectionlike<br>&gt; Errorlike<br>&gt; FloatingPointlike<br>&gt; ForwardIndexlike<br>&gt; Generatorlike<br>&gt; IntegerArithmeticlike<br>&gt; Integerlike<br>&gt; Intervallike<br>&gt; LazyCollectionlike<br>&gt; LazySequencelike<br>&gt; MirrorPathlike<br>&gt; MutableCollectionlike<br>&gt; OptionSetlike<br>&gt; OutputStreamlike<br>&gt; RandomAccessIndexlike<br>&gt; RangeReplaceableCollectionlike<br>&gt; ReverseIndexlike<br>&gt; Sequencelike<br>&gt; SetAlgebralike<br>&gt; SignedIntegerlike<br>&gt; SignedNumberlike<br>&gt; UnicodeCodeclike<br>&gt; UnsignedIntegerlike<br>&gt; <br>&gt; Not all of these are perfect, but in some cases that&#39;s because they should arguably be -able protocols (BitwiseOperationsType -&gt; BitwiseOperable).<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/4dac1fcb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>January 30, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 30 Jan 2016, at 02:47, Alex Migicovsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; IMO the ‘like’ suffix makes it sound like the conforming type to Collectionlike is like a Collection, but not exactly a Collection.<br></p><p>and isn&#39;t this the point of protocols? To decouple the behaviour you expose/the contract you make from what you actually are/how you are implemented?<br></p><p>&gt; Maybe there’s another suffix that works but I don’t think this one conveys the right information.<br>&gt; <br>&gt; - Alex<br>&gt; <br>&gt;&gt;&gt; On Jan 29, 2016, at 6:43 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Count me among those who liked the ‘Type’ suffix for protocols though.<br>&gt;&gt; <br>&gt;&gt; I wonder if we can&#39;t change it to a -`like` suffix. Applying that to 2.1 stdlib gives you:<br>&gt;&gt; <br>&gt;&gt; AnyCollectionlike<br>&gt;&gt; BidirectionalIndexlike<br>&gt;&gt; BitwiseOperationslike<br>&gt;&gt; Booleanlike<br>&gt;&gt; CVarArglike<br>&gt;&gt; Collectionlike<br>&gt;&gt; Errorlike<br>&gt;&gt; FloatingPointlike<br>&gt;&gt; ForwardIndexlike<br>&gt;&gt; Generatorlike<br>&gt;&gt; IntegerArithmeticlike<br>&gt;&gt; Integerlike<br>&gt;&gt; Intervallike<br>&gt;&gt; LazyCollectionlike<br>&gt;&gt; LazySequencelike<br>&gt;&gt; MirrorPathlike<br>&gt;&gt; MutableCollectionlike<br>&gt;&gt; OptionSetlike<br>&gt;&gt; OutputStreamlike<br>&gt;&gt; RandomAccessIndexlike<br>&gt;&gt; RangeReplaceableCollectionlike<br>&gt;&gt; ReverseIndexlike<br>&gt;&gt; Sequencelike<br>&gt;&gt; SetAlgebralike<br>&gt;&gt; SignedIntegerlike<br>&gt;&gt; SignedNumberlike<br>&gt;&gt; UnicodeCodeclike<br>&gt;&gt; UnsignedIntegerlike<br>&gt;&gt; <br>&gt;&gt; Not all of these are perfect, but in some cases that&#39;s because they should arguably be -able protocols (BitwiseOperationsType -&gt; BitwiseOperable).<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/f7f5561d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>January 30, 2016 at 09:00:00am</p></header><div class="content"><p>I still don’t see why we need a suffix at all, what is unclear about the CollectionType protocol simply being called Collection instead? It’s declared as a protocol after all, so there’s no risk of someone accidentally instantiating one.<br></p><p>&gt; On 30 Jan 2016, at 02:47, Alex Migicovsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; IMO the ‘like’ suffix makes it sound like the conforming type to Collectionlike is like a Collection, but not exactly a Collection. Maybe there’s another suffix that works but I don’t think this one conveys the right information.<br>&gt; <br>&gt; - Alex<br>&gt; <br>&gt;&gt; On Jan 29, 2016, at 6:43 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Count me among those who liked the ‘Type’ suffix for protocols though.<br>&gt;&gt; <br>&gt;&gt; I wonder if we can&#39;t change it to a -`like` suffix. Applying that to 2.1 stdlib gives you:<br>&gt;&gt; <br>&gt;&gt; AnyCollectionlike<br>&gt;&gt; BidirectionalIndexlike<br>&gt;&gt; BitwiseOperationslike<br>&gt;&gt; Booleanlike<br>&gt;&gt; CVarArglike<br>&gt;&gt; Collectionlike<br>&gt;&gt; Errorlike<br>&gt;&gt; FloatingPointlike<br>&gt;&gt; ForwardIndexlike<br>&gt;&gt; Generatorlike<br>&gt;&gt; IntegerArithmeticlike<br>&gt;&gt; Integerlike<br>&gt;&gt; Intervallike<br>&gt;&gt; LazyCollectionlike<br>&gt;&gt; LazySequencelike<br>&gt;&gt; MirrorPathlike<br>&gt;&gt; MutableCollectionlike<br>&gt;&gt; OptionSetlike<br>&gt;&gt; OutputStreamlike<br>&gt;&gt; RandomAccessIndexlike<br>&gt;&gt; RangeReplaceableCollectionlike<br>&gt;&gt; ReverseIndexlike<br>&gt;&gt; Sequencelike<br>&gt;&gt; SetAlgebralike<br>&gt;&gt; SignedIntegerlike<br>&gt;&gt; SignedNumberlike<br>&gt;&gt; UnicodeCodeclike<br>&gt;&gt; UnsignedIntegerlike<br>&gt;&gt; <br>&gt;&gt; Not all of these are perfect, but in some cases that&#39;s because they should arguably be -able protocols (BitwiseOperationsType -&gt; BitwiseOperable).<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/8ecf06e8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>January 30, 2016 at 09:00:00am</p></header><div class="content"><p>I never liked the practice of having classes and protocols with the same name, like NSObject, although legal and maybe very reasonable at times. A protocol should express what it is, a contract.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 30 Jan 2016, at 09:48, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I still don’t see why we need a suffix at all, what is unclear about the CollectionType protocol simply being called Collection instead? It’s declared as a protocol after all, so there’s no risk of someone accidentally instantiating one.<br>&gt; <br>&gt;&gt; On 30 Jan 2016, at 02:47, Alex Migicovsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; IMO the ‘like’ suffix makes it sound like the conforming type to Collectionlike is like a Collection, but not exactly a Collection. Maybe there’s another suffix that works but I don’t think this one conveys the right information.<br>&gt;&gt; <br>&gt;&gt; - Alex<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 29, 2016, at 6:43 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Count me among those who liked the ‘Type’ suffix for protocols though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wonder if we can&#39;t change it to a -`like` suffix. Applying that to 2.1 stdlib gives you:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; AnyCollectionlike<br>&gt;&gt;&gt; BidirectionalIndexlike<br>&gt;&gt;&gt; BitwiseOperationslike<br>&gt;&gt;&gt; Booleanlike<br>&gt;&gt;&gt; CVarArglike<br>&gt;&gt;&gt; Collectionlike<br>&gt;&gt;&gt; Errorlike<br>&gt;&gt;&gt; FloatingPointlike<br>&gt;&gt;&gt; ForwardIndexlike<br>&gt;&gt;&gt; Generatorlike<br>&gt;&gt;&gt; IntegerArithmeticlike<br>&gt;&gt;&gt; Integerlike<br>&gt;&gt;&gt; Intervallike<br>&gt;&gt;&gt; LazyCollectionlike<br>&gt;&gt;&gt; LazySequencelike<br>&gt;&gt;&gt; MirrorPathlike<br>&gt;&gt;&gt; MutableCollectionlike<br>&gt;&gt;&gt; OptionSetlike<br>&gt;&gt;&gt; OutputStreamlike<br>&gt;&gt;&gt; RandomAccessIndexlike<br>&gt;&gt;&gt; RangeReplaceableCollectionlike<br>&gt;&gt;&gt; ReverseIndexlike<br>&gt;&gt;&gt; Sequencelike<br>&gt;&gt;&gt; SetAlgebralike<br>&gt;&gt;&gt; SignedIntegerlike<br>&gt;&gt;&gt; SignedNumberlike<br>&gt;&gt;&gt; UnicodeCodeclike<br>&gt;&gt;&gt; UnsignedIntegerlike<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not all of these are perfect, but in some cases that&#39;s because they should arguably be -able protocols (BitwiseOperationsType -&gt; BitwiseOperable).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/8085201a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 30, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; I still don’t see why we need a suffix at all, what is unclear about the CollectionType protocol simply being called Collection instead?<br></p><p>They&#39;re attractive nuisances. Someone wants an integer type, sees Integer, tries to use it, and suddenly they&#39;re getting weird errors about Self and associated object requirements. Or they want a boolean variable, see Boolean, and suddenly their one-bit value is wrapped in a 40-byte protocol witness. Nobody is going to mistake Integerlike or Booleanlike for a concrete type and use it accidentally.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>January 30, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 30 Jan 2016, at 09:53, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I still don’t see why we need a suffix at all, what is unclear about the CollectionType protocol simply being called Collection instead?<br>&gt; <br>&gt; They&#39;re attractive nuisances. Someone wants an integer type, sees Integer, tries to use it, and suddenly they&#39;re getting weird errors about Self and associated object requirements. Or they want a boolean variable, see Boolean, and suddenly their one-bit value is wrapped in a 40-byte protocol witness. Nobody is going to mistake Integerlike or Booleanlike for a concrete type and use it accidentally.<br></p><p>The first example (errors about Self) is more a problem with the error being confusing to new users, first time I encountered that was a real head-scratcher as I was trying to use a protocol as a type for a variable (which is still a problem with Swift really, since some can be used and others can’t). Anyway, the fact is that it returns an error; while the error may currently be hostile to new users, that’s its own problem IMO.<br></p><p>I’m also not sure what you mean about the overhead on BooleanType being misused as Boolean? It can’t be instantiated directly, and with that specific example I’ve never seen code that doesn’t use true/false directly anyway (or some comparison like someInt != 0). Bool doesn’t really have initialisers that need to be used much.<br></p><p>I suppose if we do have to have a suffix though then I would also prefer Like over Type; Type to me isn’t a good fit as not every protocol can be used as a type (due to aforementioned Self restrictions), whereas describing it as like something is essentially what a protocol does, as a struct could theoretically be IntegerLike without being backed by an integer at all.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 26, 2016 at 11:00:00pm</p></header><div class="content"><p>Same here… I like -Type for protocols that can only be used a generic constraint, and -able/-ible for protocols that can be “concrete” types.<br></p><p>&gt; On Jan 25, 2016, at 07:40, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; == Removed Type from protocol names ==<br>&gt; <br>&gt; Perhaps I’ve missed some discussion about this and I don’t see the context, but I’m not sure this is a positive change.<br>&gt; <br>&gt; I fear this might be confusing in practice, at least in some contexts. For example, there&#39;s nothing signifying that &quot;Boolean&quot; or &quot;Integer&quot; are protocols and not actual types. Same with “Sequence”, “OptionSet”, etc. Perhaps it doesn&#39;t matter because everyone will naturally go for `Bool`, `Int`, and `Array` anyway. But I can imagine a lot of confusion if someone tried that anyway, or perhaps saw that in the autocompletion, or the standard library browser (with no intention of using the protocol).<br>&gt; <br>&gt; I’m all for removing unnecessary noise and verbosity, but I think I would err on explicitness side here. It seemed like the -able/-Type convention did a good job disambiguating types you can actually instantiate from protocols, with very little “verbosity cost”.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>January 30, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 25, 2016, at 07:40, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It seemed like the -able/-Type convention did a good job disambiguating types you can actually instantiate from protocols, with very little “verbosity cost”.<br></p><p>I think this argument is outweighed by the benefit of making it easier to name things.  I always found the decision about whether to suffix things with “-Type&quot; to be a point of confusion, and I’m glad to see it being removed.  As far as disambiguating instantiatable types from protocols, this seems like something that could be handled by the IDE, for example, it could put a strike-through line on the auto-complete options that you can’t use as types in the given context.<br></p><p>Matt<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>February  1, 2016 at 10:00:00pm</p></header><div class="content"><p>I&#39;m generally in favor of the proposed changes. I&#39;ll just note some minor points and disagreements:<br></p><p><br>* Like I mentioned in my SE-0023 review, I would be OK with keeping the &quot;Type&quot; suffix for protocols but have no strong preference.<br></p><p>* I&#39;m in favor of keeping `precondition()`. `require()` might be easier to grasp at first but personally I really came to like `precondition()`.<br>It fells both precise and I prefer the passive `precondition()` to the active `require()` for this case. To me it fits the primary meaning better; stating an API contract. The fact that the condition is actively checked is secondary to that.<br></p><p>* I also agree with Radosław in that I prefer `removeAll(keepCapacity: Bool)` to `removeAll(keepingCapacity: Bool)`.<br></p><p>* What is the rationale for moving `unsafeUnwrap` into Optional but not `unsafeAddressOf` into AnyObject? I can certainly see the safety argument against moving it but I don&#39;t see how that would apply to `unsafeAddressOf` but not `unsafeUnwrap`?<br></p><p>* `EnumeratedSequence` and `Repeated` feel weird to me. They make sense given the API guidelines and the previous `EnumerateSequence` and `Repeat` were a bit clunky as well but these somehow feel a bit worse... That might be wholly subjective though and I don&#39;t really have a good suggestion. The only thing that came to mind was `EnumerationSequence` and `Repetition` but I&#39;m not overly fond of those either especially not to the point of deviating from the norm...<br></p><p>* This is not a disagreement but I&#39;d be interested in hearing the reasons for replacing Generator(Type) with Iterator(Protocol) if someone finds the time. I can speculate of course but it&#39;s probably easier for someone to give me a short summary :-)<br></p><p>* Typo: <br>&gt; +  public func take() -&gt; Memory // Should be Pointee<br></p><p><br></p><p>- Janosch<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/fc72f5b4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February  1, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; What is the rationale for moving `unsafeUnwrap` into Optional but not `unsafeAddressOf` into AnyObject?<br></p><p>For one thing, because AnyObject has no methods and the compiler prevents it from being extended. Of course, as far as I can tell that limitation is unprincipled.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Review] SE-0006 Apply API Guidelines to the Standard Library</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>February  5, 2016 at 08:00:00pm</p></header><div class="content"><p>Proposal link:<br></p><p>&lt;https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md&gt;<br></p><p>&gt; precondition was renamed to require.<br></p><p>In the Standard Library, &quot;- Requires:&quot; appears in documentation comments more often than &quot;- Precondition:&quot; or &quot;- Postcondition:&quot;, so renaming the function makes sense.<br></p><p>However, I think the Xcode Markup Formatting Reference should be updated to reflect this usage. The current description is:<br></p><p>&gt; Use the field to add requirements such as frameworks for using the symbol.<br>&gt; <br>&gt; /**<br>&gt; An example of using the requires field<br>&gt; <br>&gt; - requires: Contacts framework<br>&gt; - requires: OS X version 10.11 or better<br>&gt; */<br></p><p>&lt;https://developer.apple.com/library/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/Requires.html&gt;<br></p><p>-- Ben<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
