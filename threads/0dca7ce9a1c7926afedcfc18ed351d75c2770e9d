<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 17, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi folks,<br></p><p>I&#39;ve drafted a proposal to add a CaseEnumerable protocol, which will derive<br>a static variable &quot;cases&quot; for enum types. Feedback is welcome, especially<br>for refining the proposal before I submit a formal PR.<br></p><p>The draft is here; full text below.<br>https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md<br></p><p><br>Derived Collection of Enum Cases<br></p><p>   - Proposal: SE-NNNN<br>   &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-derived-collection-of-enum-cases.md&gt;<br>   - Author(s): Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;<br>   - Status: *Awaiting review*<br>   - Review manager: TBD<br></p><p>&lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#introduction&gt;<br>Introduction<br></p><p>It is a truth universally acknowledged, that a programmer in possession of<br>an enum with many cases, must eventually be in want of dynamic enumeration<br>over them.<br></p><p>This topic has come up three times on the swift-evolution mailing list so<br>far:<br></p><p>   - List of all Enum values (for simple enums)<br>   &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001233.html&gt;<br>(December<br>   8, 2015)<br>   - Proposal: Enum &#39;count&#39; functionality<br>   &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/003819.html&gt;<br>(December<br>   21, 2015)<br>   - Draft Proposal: count property for enum types<br>   &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006853.html&gt;<br>(January<br>   17, 2016)<br></p><p>Enumerating enumerations in Swift is also a popular topic on Stack Overflow:<br></p><p>   - How to enumerate an enum with String type?<br>   &lt;http://stackoverflow.com/questions/24007461/how-to-enumerate-an-enum-with-string-type&gt;<br>(June<br>   3, 2014; question score 131)<br>   - How do I get the count of a Swift enum?<br>   &lt;http://stackoverflow.com/questions/27094878/how-do-i-get-the-count-of-a-swift-enum&gt;<br>(November<br>   23, 2014; question score 37)<br></p><p>&lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#motivation&gt;<br>Motivation<br></p><p>Simple enums are finite, and their values are statically known to the<br>compiler, yet working with them programmatically is challenging. It is<br>often desirable to iterate over all possible cases of an enum, or to know<br>the number of cases (or maximum valid rawValue).<br></p><p>Currently, however, there is no built-in reflection or enumeration support.<br>Users must resort to manually listing out cases in order to iterate over<br>them:<br></p><p>enum Attribute {<br>    case Date, Name, Author<br>}func valueForAttribute(attr: Attribute) -&gt; String { ‚Ä¶from elsewhere‚Ä¶ }<br>// Cases must be listed explicitly:<br>[Attribute.Date, .Name, .Author].map{ valueForAttribute($0)<br>}.joinWithSeparator(&quot;\n&quot;)<br></p><p>For RawRepresentable enums, users have often relied on iterating over the<br>known (or assumed) allowable raw values:<br></p><p>*Annotated excerpt from Nate Cook&#39;s post, Loopy, Random Ideas for Extending<br>&quot;enum&quot; &lt;http://natecook.com/blog/2014/10/loopy-random-enum-ideas/&gt; (October<br>2014):*<br></p><p>enum Reindeer: Int {<br>    case Dasher, Dancer, Prancer, Vixen, Comet, Cupid, Donner,<br>Blitzen, Rudolph<br>}extension Reindeer {<br>    static var allCases: [Reindeer] {<br>        var cur = 0<br>        return Array(<br>            GeneratorOf&lt;Reindeer&gt; {<br>                return Reindeer(rawValue: cur++)<br>            }<br>        )<br>    }<br>    static var caseCount: Int {<br>        var max: Int = 0<br>        while let _ = self(rawValue: ++max) {}<br>        return max<br>    }<br>    static func randomCase() -&gt; Reindeer {<br>        // everybody do the Int/UInt32 shuffle!<br>        let randomValue = Int(arc4random_uniform(UInt32(caseCount)))<br>        return self(rawValue: randomValue)!<br>    }<br>}<br></p><p>There are many problems with these existing techniques:<br></p><p>   - They are ad-hoc and can&#39;t benefit every enum type without duplicated<br>   and code.<br>   - They are not standardized across codebases, nor provided automatically<br>   by libraries such as Foundation and {App,UI}Kit.<br>   - They are sometimes prone to bugs when enum cases are added, but the<br>   user forgets to update a hard-coded static collection of cases.<br></p><p>&lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#precedent-in-other-languages&gt;Precedent<br>in other languages<br></p><p>   -<br></p><p>   Rust does not seem to have a solution for this problem.<br>   -<br></p><p>   C#&#39;s Enum has several methods<br>   &lt;https://msdn.microsoft.com/en-us/library/system.enum_methods.aspx&gt;<br>available<br>   for reflection, including GetValues() and GetNames().<br>   -<br></p><p>   Java implicitly declares<br>   &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt; a<br>   static values() function, returning an array of enum values, and<br>valueOf(String<br>   name) which takes a String and returns the enum value with the<br>   corresponding name (or throws an exception). More examples here<br>   &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt;.<br>   -<br></p><p>   The Template Haskell extension to Haskell provides a function reify which<br>   extracts info about types<br>   &lt;http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#t:Info&gt;,<br>   including their constructors.<br></p><p>&lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#proposed-solution&gt;Proposed<br>solution<br></p><p>Introduce a CaseEnumerable protocol. Conforming to CaseEnumerable will<br>automagically derive a static var cases, whose type is a CollectionType of<br>all the enum&#39;s values.<br></p><p>Like ErrorType, the CaseEnumerable protocol will not have any user-visible<br>requirements; merely adding the conformance is enough to enable case<br>enumeration.<br></p><p>enum Ma { case È©¨, Âêó, Â¶à, Á†Å, È™Ç, üêé, üê¥ }<br>extension Ma: CaseEnumerable {}<br></p><p>Ma.cases         // returns some CollectionType whose Generator.Element is Ma<br>Ma.cases.count   // returns 7Array(Ma.cases)  // returns [Ma.È©¨, .Âêó,<br>.Â¶à, .Á†Å, .È™Ç, .üêé, .üê¥]<br></p><p>Conformances can even be added for enums which are defined in other modules:<br></p><p>extension NSTextAlignment: CaseEnumerable {}<br>Array(NSTextAlignment.cases)  // returns [NSTextAlignment.Left,<br>.Right, .Center, .Justified, .Natural]<br></p><p>&lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#detailed-design&gt;Detailed<br>design<br></p><p>Enum cases are enumerated in the order they appear in the source code.<br></p><p>The cases collection does not necessitate Œ©(number of cases) static<br>storage. For integer-backed enums, only the range(s) of valid rawValues<br>need to be stored, and the enum construction can happen dynamically.<br></p><p>Attempting to derive CaseEnumerable for a non-enum type will result in a<br>compiler error.<br></p><p>Attempting to derive CaseEnumerable for an enum with associated values will<br>result in a compiler error.<br>&lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#possible-variations&gt;Possible<br>variations<br></p><p>I&#39;d like us to discuss these, but they should be folded into either *Proposed<br>solution* or *Future directions* before the proposal is submitted for<br>review.<br></p><p>   -<br></p><p>   For enums with raw values, a static rawValues property (a collection of<br>   RawValue rather than the enum type itself) could also be synthesized.<br>   -<br></p><p>   CaseEnumerable could have a user-visible declaration requiring static<br>   var cases, which would allow users to add conformances for custom non-<br>   enum types.<br>   - In this case, adding a conformance for a non-enum type would not be a<br>      compiler error, it would just require an explicit implementation<br>of static<br>      var cases, since the compiler wouldn&#39;t synthesize it.<br>      - This would probably require cases to be AnySequence&lt;Self&gt;, or to<br>      introduce an AnyCollection, since we aren&#39;t able to say associatedtype<br>      CaseCollection: CollectionType where CaseCollection.Generator.Element ==<br>      Self.<br>   -<br></p><p>   It would be nice to have a way of supporting this for OptionSetType<br>   structs. I would recommend that cases for an OptionSetType should<br>   include only the already-declared static properties (not all possible<br>   combinations of them). However, I&#39;m not sure it fits into this proposal.<br></p><p>&lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#impact-on-existing-code&gt;Impact<br>on existing code<br></p><p>This proposal only adds functionality, so existing code will not be<br>affected. (The identifier CaseEnumerable doesn&#39;t make any significant<br>appearances in Google and GitHub searches.)<br>&lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#alternatives-considered&gt;Alternatives<br>considered<br></p><p>The community has not raised any solutions that differ significantly from<br>this proposal, except for solutions which provide strictly *more*<br>functionality.<br>These are covered in the next section, *Future directions*.<br></p><p>An alternative is to *not* implement this feature. The cons of this are<br>discussed in the *Motivation* section above.<br></p><p>The functionality could also be provided entirely through the<br>Mirror/reflection APIs, but this would result in much more obscure and<br>confusing usage patterns.<br>&lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#future-directions&gt;Future<br>directions<br></p><p>Many people would be happy to see even more functionality than what&#39;s<br>proposed here. I&#39;m keeping this proposal intentionally limited, but I hope<br>the community can continue discussing the topic to flesh out more features.<br></p><p>Here are some starting points, which are *not* part of this proposal:<br></p><p>   -<br></p><p>   Support for enum case *names*. It would be useful to get case names even<br>   for enums which have integer rawValues. This could be part of the existing<br>   reflection APIs, or it could take the form of derived implementations of<br>   StringLiteralConvertible/CustomStringConvertible.<br>   -<br></p><p>   Support for enums with associated values.<br>   -<br></p><p>      When all associated values are themselves CaseEnumerable, this could<br>      happen automatically:<br></p><p>      enum Suit: CaseEnumerable { case Spades, Hearts, Diamonds, Clubs<br>}enum Rank: Int, CaseEnumerable {<br>          case Ace = 1, Two, Three, Four, Five, Six<br>          case Seven, Eight, Nine, Ten, Jack, Queen, King<br>      }enum Card {<br>          case Joker<br>          case Value(Rank, Suit)<br>      }<br>      // This now works, and generates all possible card types (Joker,<br>Value(Ace, Spades), ...)extension Card: CaseEnumerable {}<br></p><p>      -<br></p><p>      If associated values aren&#39;t CaseEnumerable, but all cases are<br>      homogeneous, the cases collection could vend functions of<br>AssociatedValueType<br>      -&gt; EnumType:<br></p><p>      enum LogMessage { case Error(String), Warning(String),<br>Info(String) }extension LogMessage: CaseEnumerable {}<br></p><p>      LogMessage.cases  // elements are (String) -&gt; LogMessage<br></p><p>      -<br></p><p>      If Swift had anonymous sum types like A | B | C, then E.cases could<br>      vend elements of type A-&gt;E | B-&gt;E | C-&gt;E.<br></p><p>      enum Expr { case Apply(Expr, Expr), Tuple(Expr, Expr),<br>Literal(Int) }extension Value: CaseEnumerable {}<br>      // This example is pretty contrived, but illustrates the<br>functionality.let fortyTwos = Expr.cases.map {<br>         // $0 is of type `Int -&gt; Expr | (Expr, Expr) -&gt; Expr`<br>         switch $0 {<br>         case let lit as Int -&gt; Expr:  // handles .Literal<br>             return lit(42)<br>         case let bin as (Expr, Expr) -&gt; Expr:  // handles .Apply and .Tuple<br>             return bin(.Literal(42), .Literal(42))<br>         // all cases are covered<br>         }<br>      }<br></p><p>      -<br></p><p>   Support for generic enums.<br>   -<br></p><p>      CaseEnumerable could be conditionally supported depending on the<br>      generic argument(s). A great example would be Optional:<br></p><p>      enum MyEnum: CaseEnumerable {}extension Optional: CaseEnumerable<br>where Wrapped: CaseEnumerable {}<br>      // Optional&lt;MyEnum&gt;.cases effectively contains `MyEnum.cases + [.None]`<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160117/0dca0e9d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 17, 2016 at 05:00:00pm</p></header><div class="content"><p>Here&#39;s a better link that tracks my branch:<br>https://github.com/jtbandes/swift-evolution/blob/case-enumerable/proposals/0000-derived-collection-of-enum-cases.md<br></p><p>On Sun, Jan 17, 2016 at 3:44 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>wrote:<br></p><p>&gt; Hi folks,<br>&gt;<br>&gt; I&#39;ve drafted a proposal to add a CaseEnumerable protocol, which will<br>&gt; derive a static variable &quot;cases&quot; for enum types. Feedback is welcome,<br>&gt; especially for refining the proposal before I submit a formal PR.<br>&gt;<br>&gt; The draft is here; full text below.<br>&gt; https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md<br>&gt;<br>&gt;<br>&gt; Derived Collection of Enum Cases<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-derived-collection-of-enum-cases.md&gt;<br>&gt;    - Author(s): Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;<br>&gt;    - Status: *Awaiting review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; It is a truth universally acknowledged, that a programmer in possession of<br>&gt; an enum with many cases, must eventually be in want of dynamic enumeration<br>&gt; over them.<br>&gt;<br>&gt; This topic has come up three times on the swift-evolution mailing list so<br>&gt; far:<br>&gt;<br>&gt;    - List of all Enum values (for simple enums)<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001233.html&gt; (December<br>&gt;    8, 2015)<br>&gt;    - Proposal: Enum &#39;count&#39; functionality<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/003819.html&gt; (December<br>&gt;    21, 2015)<br>&gt;    - Draft Proposal: count property for enum types<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006853.html&gt; (January<br>&gt;    17, 2016)<br>&gt;<br>&gt; Enumerating enumerations in Swift is also a popular topic on Stack<br>&gt; Overflow:<br>&gt;<br>&gt;    - How to enumerate an enum with String type?<br>&gt;    &lt;http://stackoverflow.com/questions/24007461/how-to-enumerate-an-enum-with-string-type&gt; (June<br>&gt;    3, 2014; question score 131)<br>&gt;    - How do I get the count of a Swift enum?<br>&gt;    &lt;http://stackoverflow.com/questions/27094878/how-do-i-get-the-count-of-a-swift-enum&gt; (November<br>&gt;    23, 2014; question score 37)<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Simple enums are finite, and their values are statically known to the<br>&gt; compiler, yet working with them programmatically is challenging. It is<br>&gt; often desirable to iterate over all possible cases of an enum, or to know<br>&gt; the number of cases (or maximum valid rawValue).<br>&gt;<br>&gt; Currently, however, there is no built-in reflection or enumeration<br>&gt; support. Users must resort to manually listing out cases in order to<br>&gt; iterate over them:<br>&gt;<br>&gt; enum Attribute {<br>&gt;     case Date, Name, Author<br>&gt; }func valueForAttribute(attr: Attribute) -&gt; String { ‚Ä¶from elsewhere‚Ä¶ }<br>&gt; // Cases must be listed explicitly:<br>&gt; [Attribute.Date, .Name, .Author].map{ valueForAttribute($0) }.joinWithSeparator(&quot;\n&quot;)<br>&gt;<br>&gt; For RawRepresentable enums, users have often relied on iterating over the<br>&gt; known (or assumed) allowable raw values:<br>&gt;<br>&gt; *Annotated excerpt from Nate Cook&#39;s post, Loopy, Random Ideas for<br>&gt; Extending &quot;enum&quot;<br>&gt; &lt;http://natecook.com/blog/2014/10/loopy-random-enum-ideas/&gt; (October 2014):*<br>&gt;<br>&gt; enum Reindeer: Int {<br>&gt;     case Dasher, Dancer, Prancer, Vixen, Comet, Cupid, Donner, Blitzen, Rudolph<br>&gt; }extension Reindeer {<br>&gt;     static var allCases: [Reindeer] {<br>&gt;         var cur = 0<br>&gt;         return Array(<br>&gt;             GeneratorOf&lt;Reindeer&gt; {<br>&gt;                 return Reindeer(rawValue: cur++)<br>&gt;             }<br>&gt;         )<br>&gt;     }<br>&gt;     static var caseCount: Int {<br>&gt;         var max: Int = 0<br>&gt;         while let _ = self(rawValue: ++max) {}<br>&gt;         return max<br>&gt;     }<br>&gt;     static func randomCase() -&gt; Reindeer {<br>&gt;         // everybody do the Int/UInt32 shuffle!<br>&gt;         let randomValue = Int(arc4random_uniform(UInt32(caseCount)))<br>&gt;         return self(rawValue: randomValue)!<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; There are many problems with these existing techniques:<br>&gt;<br>&gt;    - They are ad-hoc and can&#39;t benefit every enum type without duplicated<br>&gt;    and code.<br>&gt;    - They are not standardized across codebases, nor provided<br>&gt;    automatically by libraries such as Foundation and {App,UI}Kit.<br>&gt;    - They are sometimes prone to bugs when enum cases are added, but the<br>&gt;    user forgets to update a hard-coded static collection of cases.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#precedent-in-other-languages&gt;Precedent<br>&gt; in other languages<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Rust does not seem to have a solution for this problem.<br>&gt;    -<br>&gt;<br>&gt;    C#&#39;s Enum has several methods<br>&gt;    &lt;https://msdn.microsoft.com/en-us/library/system.enum_methods.aspx&gt; available<br>&gt;    for reflection, including GetValues() and GetNames().<br>&gt;    -<br>&gt;<br>&gt;    Java implicitly declares<br>&gt;    &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt; a<br>&gt;    static values() function, returning an array of enum values, and valueOf(String<br>&gt;    name) which takes a String and returns the enum value with the<br>&gt;    corresponding name (or throws an exception). More examples here<br>&gt;    &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt;<br>&gt;    .<br>&gt;    -<br>&gt;<br>&gt;    The Template Haskell extension to Haskell provides a function reify which<br>&gt;    extracts info about types<br>&gt;    &lt;http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#t:Info&gt;,<br>&gt;    including their constructors.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; Introduce a CaseEnumerable protocol. Conforming to CaseEnumerable will<br>&gt; automagically derive a static var cases, whose type is a CollectionType<br>&gt; of all the enum&#39;s values.<br>&gt;<br>&gt; Like ErrorType, the CaseEnumerable protocol will not have any<br>&gt; user-visible requirements; merely adding the conformance is enough to<br>&gt; enable case enumeration.<br>&gt;<br>&gt; enum Ma { case È©¨, Âêó, Â¶à, Á†Å, È™Ç, üêé, üê¥ }<br>&gt; extension Ma: CaseEnumerable {}<br>&gt;<br>&gt; Ma.cases         // returns some CollectionType whose Generator.Element is Ma<br>&gt; Ma.cases.count   // returns 7Array(Ma.cases)  // returns [Ma.È©¨, .Âêó, .Â¶à, .Á†Å, .È™Ç, .üêé, .üê¥]<br>&gt;<br>&gt; Conformances can even be added for enums which are defined in other<br>&gt; modules:<br>&gt;<br>&gt; extension NSTextAlignment: CaseEnumerable {}<br>&gt; Array(NSTextAlignment.cases)  // returns [NSTextAlignment.Left, .Right, .Center, .Justified, .Natural]<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; Enum cases are enumerated in the order they appear in the source code.<br>&gt;<br>&gt; The cases collection does not necessitate Œ©(number of cases) static<br>&gt; storage. For integer-backed enums, only the range(s) of valid rawValues<br>&gt; need to be stored, and the enum construction can happen dynamically.<br>&gt;<br>&gt; Attempting to derive CaseEnumerable for a non-enum type will result in a<br>&gt; compiler error.<br>&gt;<br>&gt; Attempting to derive CaseEnumerable for an enum with associated values<br>&gt; will result in a compiler error.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#possible-variations&gt;Possible<br>&gt; variations<br>&gt;<br>&gt; I&#39;d like us to discuss these, but they should be folded into either *Proposed<br>&gt; solution* or *Future directions* before the proposal is submitted for<br>&gt; review.<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    For enums with raw values, a static rawValues property (a collection<br>&gt;    of RawValue rather than the enum type itself) could also be<br>&gt;    synthesized.<br>&gt;    -<br>&gt;<br>&gt;    CaseEnumerable could have a user-visible declaration requiring static<br>&gt;    var cases, which would allow users to add conformances for custom non-<br>&gt;    enum types.<br>&gt;    - In this case, adding a conformance for a non-enum type would not be<br>&gt;       a compiler error, it would just require an explicit implementation of static<br>&gt;       var cases, since the compiler wouldn&#39;t synthesize it.<br>&gt;       - This would probably require cases to be AnySequence&lt;Self&gt;, or to<br>&gt;       introduce an AnyCollection, since we aren&#39;t able to say associatedtype<br>&gt;       CaseCollection: CollectionType where CaseCollection.Generator.Element ==<br>&gt;       Self.<br>&gt;    -<br>&gt;<br>&gt;    It would be nice to have a way of supporting this for OptionSetType<br>&gt;    structs. I would recommend that cases for an OptionSetType should<br>&gt;    include only the already-declared static properties (not all possible<br>&gt;    combinations of them). However, I&#39;m not sure it fits into this proposal.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; This proposal only adds functionality, so existing code will not be<br>&gt; affected. (The identifier CaseEnumerable doesn&#39;t make any significant<br>&gt; appearances in Google and GitHub searches.)<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt; The community has not raised any solutions that differ significantly from<br>&gt; this proposal, except for solutions which provide strictly *more* functionality.<br>&gt; These are covered in the next section, *Future directions*.<br>&gt;<br>&gt; An alternative is to *not* implement this feature. The cons of this are<br>&gt; discussed in the *Motivation* section above.<br>&gt;<br>&gt; The functionality could also be provided entirely through the<br>&gt; Mirror/reflection APIs, but this would result in much more obscure and<br>&gt; confusing usage patterns.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#future-directions&gt;Future<br>&gt; directions<br>&gt;<br>&gt; Many people would be happy to see even more functionality than what&#39;s<br>&gt; proposed here. I&#39;m keeping this proposal intentionally limited, but I hope<br>&gt; the community can continue discussing the topic to flesh out more features.<br>&gt;<br>&gt; Here are some starting points, which are *not* part of this proposal:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Support for enum case *names*. It would be useful to get case names<br>&gt;    even for enums which have integer rawValues. This could be part of the<br>&gt;    existing reflection APIs, or it could take the form of derived<br>&gt;    implementations of StringLiteralConvertible/CustomStringConvertible.<br>&gt;    -<br>&gt;<br>&gt;    Support for enums with associated values.<br>&gt;    -<br>&gt;<br>&gt;       When all associated values are themselves CaseEnumerable, this<br>&gt;       could happen automatically:<br>&gt;<br>&gt;       enum Suit: CaseEnumerable { case Spades, Hearts, Diamonds, Clubs }enum Rank: Int, CaseEnumerable {<br>&gt;           case Ace = 1, Two, Three, Four, Five, Six<br>&gt;           case Seven, Eight, Nine, Ten, Jack, Queen, King<br>&gt;       }enum Card {<br>&gt;           case Joker<br>&gt;           case Value(Rank, Suit)<br>&gt;       }<br>&gt;       // This now works, and generates all possible card types (Joker, Value(Ace, Spades), ...)extension Card: CaseEnumerable {}<br>&gt;<br>&gt;       -<br>&gt;<br>&gt;       If associated values aren&#39;t CaseEnumerable, but all cases are<br>&gt;       homogeneous, the cases collection could vend functions of AssociatedValueType<br>&gt;       -&gt; EnumType:<br>&gt;<br>&gt;       enum LogMessage { case Error(String), Warning(String), Info(String) }extension LogMessage: CaseEnumerable {}<br>&gt;<br>&gt;       LogMessage.cases  // elements are (String) -&gt; LogMessage<br>&gt;<br>&gt;       -<br>&gt;<br>&gt;       If Swift had anonymous sum types like A | B | C, then E.cases could<br>&gt;       vend elements of type A-&gt;E | B-&gt;E | C-&gt;E.<br>&gt;<br>&gt;       enum Expr { case Apply(Expr, Expr), Tuple(Expr, Expr), Literal(Int) }extension Value: CaseEnumerable {}<br>&gt;       // This example is pretty contrived, but illustrates the functionality.let fortyTwos = Expr.cases.map {<br>&gt;          // $0 is of type `Int -&gt; Expr | (Expr, Expr) -&gt; Expr`<br>&gt;          switch $0 {<br>&gt;          case let lit as Int -&gt; Expr:  // handles .Literal<br>&gt;              return lit(42)<br>&gt;          case let bin as (Expr, Expr) -&gt; Expr:  // handles .Apply and .Tuple<br>&gt;              return bin(.Literal(42), .Literal(42))<br>&gt;          // all cases are covered<br>&gt;          }<br>&gt;       }<br>&gt;<br>&gt;       -<br>&gt;<br>&gt;    Support for generic enums.<br>&gt;    -<br>&gt;<br>&gt;       CaseEnumerable could be conditionally supported depending on the<br>&gt;       generic argument(s). A great example would be Optional:<br>&gt;<br>&gt;       enum MyEnum: CaseEnumerable {}extension Optional: CaseEnumerable where Wrapped: CaseEnumerable {}<br>&gt;       // Optional&lt;MyEnum&gt;.cases effectively contains `MyEnum.cases + [.None]`<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160117/0b886f49/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 17, 2016 at 08:00:00pm</p></header><div class="content"><p>Big +1.<br></p><p>I think the proposed solution is plenty for a first implementation. The<br>rest of the possible variations can be added later in a backward-compatible<br>way.<br></p><p>I&#39;m not sure if the rawValues property is useful enough as you can loop<br>through the cases (or use map) and get the rawValue for each. Is there a<br>use case for needing all of the raw values where you don&#39;t also need the<br>actual cases at some point?<br></p><p>On Sun, Jan 17, 2016 at 8:06 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Here&#39;s a better link that tracks my branch:<br>&gt;<br>&gt; https://github.com/jtbandes/swift-evolution/blob/case-enumerable/proposals/0000-derived-collection-of-enum-cases.md<br>&gt;<br>&gt; On Sun, Jan 17, 2016 at 3:44 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Hi folks,<br>&gt;&gt;<br>&gt;&gt; I&#39;ve drafted a proposal to add a CaseEnumerable protocol, which will<br>&gt;&gt; derive a static variable &quot;cases&quot; for enum types. Feedback is welcome,<br>&gt;&gt; especially for refining the proposal before I submit a formal PR.<br>&gt;&gt;<br>&gt;&gt; The draft is here; full text below.<br>&gt;&gt; https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Derived Collection of Enum Cases<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-derived-collection-of-enum-cases.md&gt;<br>&gt;&gt;    - Author(s): Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;<br>&gt;&gt;    - Status: *Awaiting review*<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#introduction&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; It is a truth universally acknowledged, that a programmer in possession<br>&gt;&gt; of an enum with many cases, must eventually be in want of dynamic<br>&gt;&gt; enumeration over them.<br>&gt;&gt;<br>&gt;&gt; This topic has come up three times on the swift-evolution mailing list so<br>&gt;&gt; far:<br>&gt;&gt;<br>&gt;&gt;    - List of all Enum values (for simple enums)<br>&gt;&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001233.html&gt; (December<br>&gt;&gt;    8, 2015)<br>&gt;&gt;    - Proposal: Enum &#39;count&#39; functionality<br>&gt;&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/003819.html&gt; (December<br>&gt;&gt;    21, 2015)<br>&gt;&gt;    - Draft Proposal: count property for enum types<br>&gt;&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006853.html&gt; (January<br>&gt;&gt;    17, 2016)<br>&gt;&gt;<br>&gt;&gt; Enumerating enumerations in Swift is also a popular topic on Stack<br>&gt;&gt; Overflow:<br>&gt;&gt;<br>&gt;&gt;    - How to enumerate an enum with String type?<br>&gt;&gt;    &lt;http://stackoverflow.com/questions/24007461/how-to-enumerate-an-enum-with-string-type&gt; (June<br>&gt;&gt;    3, 2014; question score 131)<br>&gt;&gt;    - How do I get the count of a Swift enum?<br>&gt;&gt;    &lt;http://stackoverflow.com/questions/27094878/how-do-i-get-the-count-of-a-swift-enum&gt; (November<br>&gt;&gt;    23, 2014; question score 37)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; Simple enums are finite, and their values are statically known to the<br>&gt;&gt; compiler, yet working with them programmatically is challenging. It is<br>&gt;&gt; often desirable to iterate over all possible cases of an enum, or to know<br>&gt;&gt; the number of cases (or maximum valid rawValue).<br>&gt;&gt;<br>&gt;&gt; Currently, however, there is no built-in reflection or enumeration<br>&gt;&gt; support. Users must resort to manually listing out cases in order to<br>&gt;&gt; iterate over them:<br>&gt;&gt;<br>&gt;&gt; enum Attribute {<br>&gt;&gt;     case Date, Name, Author<br>&gt;&gt; }func valueForAttribute(attr: Attribute) -&gt; String { ‚Ä¶from elsewhere‚Ä¶ }<br>&gt;&gt; // Cases must be listed explicitly:<br>&gt;&gt; [Attribute.Date, .Name, .Author].map{ valueForAttribute($0) }.joinWithSeparator(&quot;\n&quot;)<br>&gt;&gt;<br>&gt;&gt; For RawRepresentable enums, users have often relied on iterating over the<br>&gt;&gt; known (or assumed) allowable raw values:<br>&gt;&gt;<br>&gt;&gt; *Annotated excerpt from Nate Cook&#39;s post, Loopy, Random Ideas for<br>&gt;&gt; Extending &quot;enum&quot;<br>&gt;&gt; &lt;http://natecook.com/blog/2014/10/loopy-random-enum-ideas/&gt; (October 2014):*<br>&gt;&gt;<br>&gt;&gt; enum Reindeer: Int {<br>&gt;&gt;     case Dasher, Dancer, Prancer, Vixen, Comet, Cupid, Donner, Blitzen, Rudolph<br>&gt;&gt; }extension Reindeer {<br>&gt;&gt;     static var allCases: [Reindeer] {<br>&gt;&gt;         var cur = 0<br>&gt;&gt;         return Array(<br>&gt;&gt;             GeneratorOf&lt;Reindeer&gt; {<br>&gt;&gt;                 return Reindeer(rawValue: cur++)<br>&gt;&gt;             }<br>&gt;&gt;         )<br>&gt;&gt;     }<br>&gt;&gt;     static var caseCount: Int {<br>&gt;&gt;         var max: Int = 0<br>&gt;&gt;         while let _ = self(rawValue: ++max) {}<br>&gt;&gt;         return max<br>&gt;&gt;     }<br>&gt;&gt;     static func randomCase() -&gt; Reindeer {<br>&gt;&gt;         // everybody do the Int/UInt32 shuffle!<br>&gt;&gt;         let randomValue = Int(arc4random_uniform(UInt32(caseCount)))<br>&gt;&gt;         return self(rawValue: randomValue)!<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; There are many problems with these existing techniques:<br>&gt;&gt;<br>&gt;&gt;    - They are ad-hoc and can&#39;t benefit every enum type without<br>&gt;&gt;    duplicated and code.<br>&gt;&gt;    - They are not standardized across codebases, nor provided<br>&gt;&gt;    automatically by libraries such as Foundation and {App,UI}Kit.<br>&gt;&gt;    - They are sometimes prone to bugs when enum cases are added, but the<br>&gt;&gt;    user forgets to update a hard-coded static collection of cases.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#precedent-in-other-languages&gt;Precedent<br>&gt;&gt; in other languages<br>&gt;&gt;<br>&gt;&gt;    -<br>&gt;&gt;<br>&gt;&gt;    Rust does not seem to have a solution for this problem.<br>&gt;&gt;    -<br>&gt;&gt;<br>&gt;&gt;    C#&#39;s Enum has several methods<br>&gt;&gt;    &lt;https://msdn.microsoft.com/en-us/library/system.enum_methods.aspx&gt; available<br>&gt;&gt;    for reflection, including GetValues() and GetNames().<br>&gt;&gt;    -<br>&gt;&gt;<br>&gt;&gt;    Java implicitly declares<br>&gt;&gt;    &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt; a<br>&gt;&gt;    static values() function, returning an array of enum values, and valueOf(String<br>&gt;&gt;    name) which takes a String and returns the enum value with the<br>&gt;&gt;    corresponding name (or throws an exception). More examples here<br>&gt;&gt;    &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt;<br>&gt;&gt;    .<br>&gt;&gt;    -<br>&gt;&gt;<br>&gt;&gt;    The Template Haskell extension to Haskell provides a function reify which<br>&gt;&gt;    extracts info about types<br>&gt;&gt;    &lt;http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#t:Info&gt;,<br>&gt;&gt;    including their constructors.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#proposed-solution&gt;Proposed<br>&gt;&gt; solution<br>&gt;&gt;<br>&gt;&gt; Introduce a CaseEnumerable protocol. Conforming to CaseEnumerable will<br>&gt;&gt; automagically derive a static var cases, whose type is a CollectionType<br>&gt;&gt; of all the enum&#39;s values.<br>&gt;&gt;<br>&gt;&gt; Like ErrorType, the CaseEnumerable protocol will not have any<br>&gt;&gt; user-visible requirements; merely adding the conformance is enough to<br>&gt;&gt; enable case enumeration.<br>&gt;&gt;<br>&gt;&gt; enum Ma { case È©¨, Âêó, Â¶à, Á†Å, È™Ç, üêé, üê¥ }<br>&gt;&gt; extension Ma: CaseEnumerable {}<br>&gt;&gt;<br>&gt;&gt; Ma.cases         // returns some CollectionType whose Generator.Element is Ma<br>&gt;&gt; Ma.cases.count   // returns 7Array(Ma.cases)  // returns [Ma.È©¨, .Âêó, .Â¶à, .Á†Å, .È™Ç, .üêé, .üê¥]<br>&gt;&gt;<br>&gt;&gt; Conformances can even be added for enums which are defined in other<br>&gt;&gt; modules:<br>&gt;&gt;<br>&gt;&gt; extension NSTextAlignment: CaseEnumerable {}<br>&gt;&gt; Array(NSTextAlignment.cases)  // returns [NSTextAlignment.Left, .Right, .Center, .Justified, .Natural]<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#detailed-design&gt;Detailed<br>&gt;&gt; design<br>&gt;&gt;<br>&gt;&gt; Enum cases are enumerated in the order they appear in the source code.<br>&gt;&gt;<br>&gt;&gt; The cases collection does not necessitate Œ©(number of cases) static<br>&gt;&gt; storage. For integer-backed enums, only the range(s) of valid rawValues<br>&gt;&gt; need to be stored, and the enum construction can happen dynamically.<br>&gt;&gt;<br>&gt;&gt; Attempting to derive CaseEnumerable for a non-enum type will result in a<br>&gt;&gt; compiler error.<br>&gt;&gt;<br>&gt;&gt; Attempting to derive CaseEnumerable for an enum with associated values<br>&gt;&gt; will result in a compiler error.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#possible-variations&gt;Possible<br>&gt;&gt; variations<br>&gt;&gt;<br>&gt;&gt; I&#39;d like us to discuss these, but they should be folded into either *Proposed<br>&gt;&gt; solution* or *Future directions* before the proposal is submitted for<br>&gt;&gt; review.<br>&gt;&gt;<br>&gt;&gt;    -<br>&gt;&gt;<br>&gt;&gt;    For enums with raw values, a static rawValues property (a collection<br>&gt;&gt;    of RawValue rather than the enum type itself) could also be<br>&gt;&gt;    synthesized.<br>&gt;&gt;    -<br>&gt;&gt;<br>&gt;&gt;    CaseEnumerable could have a user-visible declaration requiring static<br>&gt;&gt;    var cases, which would allow users to add conformances for custom non-<br>&gt;&gt;    enum types.<br>&gt;&gt;    - In this case, adding a conformance for a non-enum type would not be<br>&gt;&gt;       a compiler error, it would just require an explicit implementation of static<br>&gt;&gt;       var cases, since the compiler wouldn&#39;t synthesize it.<br>&gt;&gt;       - This would probably require cases to be AnySequence&lt;Self&gt;, or to<br>&gt;&gt;       introduce an AnyCollection, since we aren&#39;t able to say associatedtype<br>&gt;&gt;       CaseCollection: CollectionType where CaseCollection.Generator.Element ==<br>&gt;&gt;       Self.<br>&gt;&gt;    -<br>&gt;&gt;<br>&gt;&gt;    It would be nice to have a way of supporting this for OptionSetType<br>&gt;&gt;    structs. I would recommend that cases for an OptionSetType should<br>&gt;&gt;    include only the already-declared static properties (not all possible<br>&gt;&gt;    combinations of them). However, I&#39;m not sure it fits into this proposal.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#impact-on-existing-code&gt;Impact<br>&gt;&gt; on existing code<br>&gt;&gt;<br>&gt;&gt; This proposal only adds functionality, so existing code will not be<br>&gt;&gt; affected. (The identifier CaseEnumerable doesn&#39;t make any significant<br>&gt;&gt; appearances in Google and GitHub searches.)<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#alternatives-considered&gt;Alternatives<br>&gt;&gt; considered<br>&gt;&gt;<br>&gt;&gt; The community has not raised any solutions that differ significantly from<br>&gt;&gt; this proposal, except for solutions which provide strictly *more* functionality.<br>&gt;&gt; These are covered in the next section, *Future directions*.<br>&gt;&gt;<br>&gt;&gt; An alternative is to *not* implement this feature. The cons of this are<br>&gt;&gt; discussed in the *Motivation* section above.<br>&gt;&gt;<br>&gt;&gt; The functionality could also be provided entirely through the<br>&gt;&gt; Mirror/reflection APIs, but this would result in much more obscure and<br>&gt;&gt; confusing usage patterns.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#future-directions&gt;Future<br>&gt;&gt; directions<br>&gt;&gt;<br>&gt;&gt; Many people would be happy to see even more functionality than what&#39;s<br>&gt;&gt; proposed here. I&#39;m keeping this proposal intentionally limited, but I hope<br>&gt;&gt; the community can continue discussing the topic to flesh out more features.<br>&gt;&gt;<br>&gt;&gt; Here are some starting points, which are *not* part of this proposal:<br>&gt;&gt;<br>&gt;&gt;    -<br>&gt;&gt;<br>&gt;&gt;    Support for enum case *names*. It would be useful to get case names<br>&gt;&gt;    even for enums which have integer rawValues. This could be part of the<br>&gt;&gt;    existing reflection APIs, or it could take the form of derived<br>&gt;&gt;    implementations of StringLiteralConvertible/CustomStringConvertible.<br>&gt;&gt;    -<br>&gt;&gt;<br>&gt;&gt;    Support for enums with associated values.<br>&gt;&gt;    -<br>&gt;&gt;<br>&gt;&gt;       When all associated values are themselves CaseEnumerable, this<br>&gt;&gt;       could happen automatically:<br>&gt;&gt;<br>&gt;&gt;       enum Suit: CaseEnumerable { case Spades, Hearts, Diamonds, Clubs }enum Rank: Int, CaseEnumerable {<br>&gt;&gt;           case Ace = 1, Two, Three, Four, Five, Six<br>&gt;&gt;           case Seven, Eight, Nine, Ten, Jack, Queen, King<br>&gt;&gt;       }enum Card {<br>&gt;&gt;           case Joker<br>&gt;&gt;           case Value(Rank, Suit)<br>&gt;&gt;       }<br>&gt;&gt;       // This now works, and generates all possible card types (Joker, Value(Ace, Spades), ...)extension Card: CaseEnumerable {}<br>&gt;&gt;<br>&gt;&gt;       -<br>&gt;&gt;<br>&gt;&gt;       If associated values aren&#39;t CaseEnumerable, but all cases are<br>&gt;&gt;       homogeneous, the cases collection could vend functions of AssociatedValueType<br>&gt;&gt;       -&gt; EnumType:<br>&gt;&gt;<br>&gt;&gt;       enum LogMessage { case Error(String), Warning(String), Info(String) }extension LogMessage: CaseEnumerable {}<br>&gt;&gt;<br>&gt;&gt;       LogMessage.cases  // elements are (String) -&gt; LogMessage<br>&gt;&gt;<br>&gt;&gt;       -<br>&gt;&gt;<br>&gt;&gt;       If Swift had anonymous sum types like A | B | C, then E.cases could<br>&gt;&gt;       vend elements of type A-&gt;E | B-&gt;E | C-&gt;E.<br>&gt;&gt;<br>&gt;&gt;       enum Expr { case Apply(Expr, Expr), Tuple(Expr, Expr), Literal(Int) }extension Value: CaseEnumerable {}<br>&gt;&gt;       // This example is pretty contrived, but illustrates the functionality.let fortyTwos = Expr.cases.map {<br>&gt;&gt;          // $0 is of type `Int -&gt; Expr | (Expr, Expr) -&gt; Expr`<br>&gt;&gt;          switch $0 {<br>&gt;&gt;          case let lit as Int -&gt; Expr:  // handles .Literal<br>&gt;&gt;              return lit(42)<br>&gt;&gt;          case let bin as (Expr, Expr) -&gt; Expr:  // handles .Apply and .Tuple<br>&gt;&gt;              return bin(.Literal(42), .Literal(42))<br>&gt;&gt;          // all cases are covered<br>&gt;&gt;          }<br>&gt;&gt;       }<br>&gt;&gt;<br>&gt;&gt;       -<br>&gt;&gt;<br>&gt;&gt;    Support for generic enums.<br>&gt;&gt;    -<br>&gt;&gt;<br>&gt;&gt;       CaseEnumerable could be conditionally supported depending on the<br>&gt;&gt;       generic argument(s). A great example would be Optional:<br>&gt;&gt;<br>&gt;&gt;       enum MyEnum: CaseEnumerable {}extension Optional: CaseEnumerable where Wrapped: CaseEnumerable {}<br>&gt;&gt;       // Optional&lt;MyEnum&gt;.cases effectively contains `MyEnum.cases + [.None]`<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160117/b7b5b893/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 20, 2016 at 10:00:00am</p></header><div class="content"><p>Big +1 from me for the proposal including the variations.<br></p><p>-Thorsten <br></p><p>&gt; Am 18.01.2016 um 02:06 schrieb Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Here&#39;s a better link that tracks my branch:<br>&gt; https://github.com/jtbandes/swift-evolution/blob/case-enumerable/proposals/0000-derived-collection-of-enum-cases.md<br>&gt; <br>&gt;&gt; On Sun, Jan 17, 2016 at 3:44 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt; Hi folks,<br>&gt;&gt; <br>&gt;&gt; I&#39;ve drafted a proposal to add a CaseEnumerable protocol, which will derive a static variable &quot;cases&quot; for enum types. Feedback is welcome, especially for refining the proposal before I submit a formal PR.<br>&gt;&gt; <br>&gt;&gt; The draft is here; full text below. https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Derived Collection of Enum Cases<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt; Author(s): Jacob Bandes-Storch<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; It is a truth universally acknowledged, that a programmer in possession of an enum with many cases, must eventually be in want of dynamic enumeration over them.<br>&gt;&gt; <br>&gt;&gt; This topic has come up three times on the swift-evolution mailing list so far:<br>&gt;&gt; <br>&gt;&gt; List of all Enum values (for simple enums) (December 8, 2015)<br>&gt;&gt; Proposal: Enum &#39;count&#39; functionality (December 21, 2015)<br>&gt;&gt; Draft Proposal: count property for enum types (January 17, 2016)<br>&gt;&gt; Enumerating enumerations in Swift is also a popular topic on Stack Overflow:<br>&gt;&gt; <br>&gt;&gt; How to enumerate an enum with String type? (June 3, 2014; question score 131)<br>&gt;&gt; How do I get the count of a Swift enum? (November 23, 2014; question score 37)<br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Simple enums are finite, and their values are statically known to the compiler, yet working with them programmatically is challenging. It is often desirable to iterate over all possible cases of an enum, or to know the number of cases (or maximum valid rawValue).<br>&gt;&gt; <br>&gt;&gt; Currently, however, there is no built-in reflection or enumeration support. Users must resort to manually listing out cases in order to iterate over them:<br>&gt;&gt; <br>&gt;&gt; enum Attribute {<br>&gt;&gt;     case Date, Name, Author<br>&gt;&gt; }<br>&gt;&gt; func valueForAttribute(attr: Attribute) -&gt; String { ‚Ä¶from elsewhere‚Ä¶ }<br>&gt;&gt; <br>&gt;&gt; // Cases must be listed explicitly:<br>&gt;&gt; [Attribute.Date, .Name, .Author].map{ valueForAttribute($0) }.joinWithSeparator(&quot;\n&quot;)<br>&gt;&gt; For RawRepresentable enums, users have often relied on iterating over the known (or assumed) allowable raw values:<br>&gt;&gt; <br>&gt;&gt; Annotated excerpt from Nate Cook&#39;s post, Loopy, Random Ideas for Extending &quot;enum&quot; (October 2014):<br>&gt;&gt; <br>&gt;&gt; enum Reindeer: Int {<br>&gt;&gt;     case Dasher, Dancer, Prancer, Vixen, Comet, Cupid, Donner, Blitzen, Rudolph  <br>&gt;&gt; }<br>&gt;&gt; extension Reindeer {<br>&gt;&gt;     static var allCases: [Reindeer] {<br>&gt;&gt;         var cur = 0<br>&gt;&gt;         return Array(<br>&gt;&gt;             GeneratorOf&lt;Reindeer&gt; {<br>&gt;&gt;                 return Reindeer(rawValue: cur++)<br>&gt;&gt;             }<br>&gt;&gt;         )<br>&gt;&gt;     }<br>&gt;&gt;     static var caseCount: Int {<br>&gt;&gt;         var max: Int = 0<br>&gt;&gt;         while let _ = self(rawValue: ++max) {}<br>&gt;&gt;         return max<br>&gt;&gt;     }<br>&gt;&gt;     static func randomCase() -&gt; Reindeer {<br>&gt;&gt;         // everybody do the Int/UInt32 shuffle!<br>&gt;&gt;         let randomValue = Int(arc4random_uniform(UInt32(caseCount)))<br>&gt;&gt;         return self(rawValue: randomValue)!<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; There are many problems with these existing techniques:<br>&gt;&gt; <br>&gt;&gt; They are ad-hoc and can&#39;t benefit every enum type without duplicated and code.<br>&gt;&gt; They are not standardized across codebases, nor provided automatically by libraries such as Foundation and {App,UI}Kit.<br>&gt;&gt; They are sometimes prone to bugs when enum cases are added, but the user forgets to update a hard-coded static collection of cases.<br>&gt;&gt; Precedent in other languages<br>&gt;&gt; <br>&gt;&gt; Rust does not seem to have a solution for this problem.<br>&gt;&gt; <br>&gt;&gt; C#&#39;s Enum has several methods available for reflection, including GetValues() and GetNames().<br>&gt;&gt; <br>&gt;&gt; Java implicitly declares a static values() function, returning an array of enum values, and valueOf(String name) which takes a String and returns the enum value with the corresponding name (or throws an exception). More examples here.<br>&gt;&gt; <br>&gt;&gt; The Template Haskell extension to Haskell provides a function reify which extracts info about types, including their constructors.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; Introduce a CaseEnumerable protocol. Conforming to CaseEnumerable will automagically derive a static var cases, whose type is a CollectionType of all the enum&#39;s values.<br>&gt;&gt; <br>&gt;&gt; Like ErrorType, the CaseEnumerable protocol will not have any user-visible requirements; merely adding the conformance is enough to enable case enumeration.<br>&gt;&gt; <br>&gt;&gt; enum Ma { case È©¨, Âêó, Â¶à, Á†Å, È™Ç, üêé, üê¥ }<br>&gt;&gt; <br>&gt;&gt; extension Ma: CaseEnumerable {}<br>&gt;&gt; <br>&gt;&gt; Ma.cases         // returns some CollectionType whose Generator.Element is Ma<br>&gt;&gt; Ma.cases.count   // returns 7<br>&gt;&gt; Array(Ma.cases)  // returns [Ma.È©¨, .Âêó, .Â¶à, .Á†Å, .È™Ç, .üêé, .üê¥]<br>&gt;&gt; Conformances can even be added for enums which are defined in other modules:<br>&gt;&gt; <br>&gt;&gt; extension NSTextAlignment: CaseEnumerable {}<br>&gt;&gt; <br>&gt;&gt; Array(NSTextAlignment.cases)  // returns [NSTextAlignment.Left, .Right, .Center, .Justified, .Natural]<br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; Enum cases are enumerated in the order they appear in the source code.<br>&gt;&gt; <br>&gt;&gt; The cases collection does not necessitate Œ©(number of cases) static storage. For integer-backed enums, only the range(s) of valid rawValues need to be stored, and the enum construction can happen dynamically.<br>&gt;&gt; <br>&gt;&gt; Attempting to derive CaseEnumerable for a non-enum type will result in a compiler error.<br>&gt;&gt; <br>&gt;&gt; Attempting to derive CaseEnumerable for an enum with associated values will result in a compiler error.<br>&gt;&gt; <br>&gt;&gt; Possible variations<br>&gt;&gt; <br>&gt;&gt; I&#39;d like us to discuss these, but they should be folded into either Proposed solution or Future directions before the proposal is submitted for review.<br>&gt;&gt; <br>&gt;&gt; For enums with raw values, a static rawValues property (a collection of RawValue rather than the enum type itself) could also be synthesized.<br>&gt;&gt; <br>&gt;&gt; CaseEnumerable could have a user-visible declaration requiring static var cases, which would allow users to add conformances for custom non-enum types.<br>&gt;&gt; <br>&gt;&gt; In this case, adding a conformance for a non-enum type would not be a compiler error, it would just require an explicit implementation of static var cases, since the compiler wouldn&#39;t synthesize it.<br>&gt;&gt; This would probably require cases to be AnySequence&lt;Self&gt;, or to introduce an AnyCollection, since we aren&#39;t able to say associatedtype CaseCollection: CollectionType where CaseCollection.Generator.Element == Self.<br>&gt;&gt; It would be nice to have a way of supporting this for OptionSetType structs. I would recommend that cases for an OptionSetType should include only the already-declared static properties (not all possible combinations of them). However, I&#39;m not sure it fits into this proposal.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This proposal only adds functionality, so existing code will not be affected. (The identifier CaseEnumerable doesn&#39;t make any significant appearances in Google and GitHub searches.)<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The community has not raised any solutions that differ significantly from this proposal, except for solutions which provide strictly more functionality. These are covered in the next section, Future directions.<br>&gt;&gt; <br>&gt;&gt; An alternative is to not implement this feature. The cons of this are discussed in the Motivation section above.<br>&gt;&gt; <br>&gt;&gt; The functionality could also be provided entirely through the Mirror/reflection APIs, but this would result in much more obscure and confusing usage patterns.<br>&gt;&gt; <br>&gt;&gt; Future directions<br>&gt;&gt; <br>&gt;&gt; Many people would be happy to see even more functionality than what&#39;s proposed here. I&#39;m keeping this proposal intentionally limited, but I hope the community can continue discussing the topic to flesh out more features.<br>&gt;&gt; <br>&gt;&gt; Here are some starting points, which are not part of this proposal:<br>&gt;&gt; <br>&gt;&gt; Support for enum case names. It would be useful to get case names even for enums which have integer rawValues. This could be part of the existing reflection APIs, or it could take the form of derived implementations of StringLiteralConvertible/CustomStringConvertible.<br>&gt;&gt; <br>&gt;&gt; Support for enums with associated values.<br>&gt;&gt; <br>&gt;&gt; When all associated values are themselves CaseEnumerable, this could happen automatically:<br>&gt;&gt; <br>&gt;&gt; enum Suit: CaseEnumerable { case Spades, Hearts, Diamonds, Clubs }<br>&gt;&gt; enum Rank: Int, CaseEnumerable {<br>&gt;&gt;     case Ace = 1, Two, Three, Four, Five, Six<br>&gt;&gt;     case Seven, Eight, Nine, Ten, Jack, Queen, King<br>&gt;&gt; }<br>&gt;&gt; enum Card {<br>&gt;&gt;     case Joker<br>&gt;&gt;     case Value(Rank, Suit)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // This now works, and generates all possible card types (Joker, Value(Ace, Spades), ...)<br>&gt;&gt; extension Card: CaseEnumerable {}<br>&gt;&gt; If associated values aren&#39;t CaseEnumerable, but all cases are homogeneous, the cases collection could vend functions of AssociatedValueType -&gt; EnumType:<br>&gt;&gt; <br>&gt;&gt; enum LogMessage { case Error(String), Warning(String), Info(String) }<br>&gt;&gt; extension LogMessage: CaseEnumerable {}<br>&gt;&gt; <br>&gt;&gt; LogMessage.cases  // elements are (String) -&gt; LogMessage<br>&gt;&gt; If Swift had anonymous sum types like A | B | C, then E.cases could vend elements of type A-&gt;E | B-&gt;E | C-&gt;E.<br>&gt;&gt; <br>&gt;&gt; enum Expr { case Apply(Expr, Expr), Tuple(Expr, Expr), Literal(Int) }<br>&gt;&gt; extension Value: CaseEnumerable {}<br>&gt;&gt; <br>&gt;&gt; // This example is pretty contrived, but illustrates the functionality.<br>&gt;&gt; let fortyTwos = Expr.cases.map {<br>&gt;&gt;    // $0 is of type `Int -&gt; Expr | (Expr, Expr) -&gt; Expr`<br>&gt;&gt;    switch $0 {<br>&gt;&gt;    case let lit as Int -&gt; Expr:  // handles .Literal<br>&gt;&gt;        return lit(42)<br>&gt;&gt;    case let bin as (Expr, Expr) -&gt; Expr:  // handles .Apply and .Tuple<br>&gt;&gt;        return bin(.Literal(42), .Literal(42))<br>&gt;&gt;    // all cases are covered<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; Support for generic enums.<br>&gt;&gt; <br>&gt;&gt; CaseEnumerable could be conditionally supported depending on the generic argument(s). A great example would be Optional:<br>&gt;&gt; <br>&gt;&gt; enum MyEnum: CaseEnumerable {}<br>&gt;&gt; extension Optional: CaseEnumerable where Wrapped: CaseEnumerable {}<br>&gt;&gt; <br>&gt;&gt; // Optional&lt;MyEnum&gt;.cases effectively contains `MyEnum.cases + [.None]`<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/a5a19870/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>January 18, 2016 at 12:00:00pm</p></header><div class="content"><p>While this isn‚Äôt in review yet, massive +1 from me. Good first implementation, and very welcome functionality.<br></p><p>Personally, I‚Äôm actually dealing with the difficulties of counts and enumerating enums in Obj-C and this is a pain in the neck. It‚Äôs not difficult, but it‚Äôs prone to breakage when someone alters code.<br></p><p>This would be a vast improvement.<br></p><p><br>&gt; On 18 Jan 2016, at 10:44 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi folks,<br>&gt; <br>&gt; I&#39;ve drafted a proposal to add a CaseEnumerable protocol, which will derive a static variable &quot;cases&quot; for enum types. Feedback is welcome, especially for refining the proposal before I submit a formal PR.<br>&gt; <br>&gt; The draft is here; full text below. https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md&gt;<br>&gt; <br>&gt; <br>&gt; Derived Collection of Enum Cases<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-derived-collection-of-enum-cases.md&gt;<br>&gt; Author(s): Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#introduction&gt;Introduction<br>&gt; <br>&gt; It is a truth universally acknowledged, that a programmer in possession of an enum with many cases, must eventually be in want of dynamic enumeration over them.<br>&gt; <br>&gt; This topic has come up three times on the swift-evolution mailing list so far:<br>&gt; <br>&gt; List of all Enum values (for simple enums) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001233.html&gt; (December 8, 2015)<br>&gt; Proposal: Enum &#39;count&#39; functionality &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/003819.html&gt; (December 21, 2015)<br>&gt; Draft Proposal: count property for enum types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006853.html&gt; (January 17, 2016)<br>&gt; Enumerating enumerations in Swift is also a popular topic on Stack Overflow:<br>&gt; <br>&gt; How to enumerate an enum with String type? &lt;http://stackoverflow.com/questions/24007461/how-to-enumerate-an-enum-with-string-type&gt; (June 3, 2014; question score 131)<br>&gt; How do I get the count of a Swift enum? &lt;http://stackoverflow.com/questions/27094878/how-do-i-get-the-count-of-a-swift-enum&gt; (November 23, 2014; question score 37)<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#motivation&gt;Motivation<br>&gt; <br>&gt; Simple enums are finite, and their values are statically known to the compiler, yet working with them programmatically is challenging. It is often desirable to iterate over all possible cases of an enum, or to know the number of cases (or maximum valid rawValue).<br>&gt; <br>&gt; Currently, however, there is no built-in reflection or enumeration support. Users must resort to manually listing out cases in order to iterate over them:<br>&gt; <br>&gt; enum Attribute {<br>&gt;     case Date, Name, Author<br>&gt; }<br>&gt; func valueForAttribute(attr: Attribute) -&gt; String { ‚Ä¶from elsewhere‚Ä¶ }<br>&gt; <br>&gt; // Cases must be listed explicitly:<br>&gt; [Attribute.Date, .Name, .Author].map{ valueForAttribute($0) }.joinWithSeparator(&quot;\n&quot;)<br>&gt; For RawRepresentable enums, users have often relied on iterating over the known (or assumed) allowable raw values:<br>&gt; <br>&gt; Annotated excerpt from Nate Cook&#39;s post, Loopy, Random Ideas for Extending &quot;enum&quot; &lt;http://natecook.com/blog/2014/10/loopy-random-enum-ideas/&gt; (October 2014):<br>&gt; <br>&gt; enum Reindeer: Int {<br>&gt;     case Dasher, Dancer, Prancer, Vixen, Comet, Cupid, Donner, Blitzen, Rudolph  <br>&gt; }<br>&gt; extension Reindeer {<br>&gt;     static var allCases: [Reindeer] {<br>&gt;         var cur = 0<br>&gt;         return Array(<br>&gt;             GeneratorOf&lt;Reindeer&gt; {<br>&gt;                 return Reindeer(rawValue: cur++)<br>&gt;             }<br>&gt;         )<br>&gt;     }<br>&gt;     static var caseCount: Int {<br>&gt;         var max: Int = 0<br>&gt;         while let _ = self(rawValue: ++max) {}<br>&gt;         return max<br>&gt;     }<br>&gt;     static func randomCase() -&gt; Reindeer {<br>&gt;         // everybody do the Int/UInt32 shuffle!<br>&gt;         let randomValue = Int(arc4random_uniform(UInt32(caseCount)))<br>&gt;         return self(rawValue: randomValue)!<br>&gt;     }<br>&gt; }<br>&gt; There are many problems with these existing techniques:<br>&gt; <br>&gt; They are ad-hoc and can&#39;t benefit every enum type without duplicated and code.<br>&gt; They are not standardized across codebases, nor provided automatically by libraries such as Foundation and {App,UI}Kit.<br>&gt; They are sometimes prone to bugs when enum cases are added, but the user forgets to update a hard-coded static collection of cases.<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#precedent-in-other-languages&gt;Precedent in other languages<br>&gt; <br>&gt; Rust does not seem to have a solution for this problem.<br>&gt; <br>&gt; C#&#39;s Enum has several methods &lt;https://msdn.microsoft.com/en-us/library/system.enum_methods.aspx&gt; available for reflection, including GetValues() and GetNames().<br>&gt; <br>&gt; Java implicitly declares &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt; a static values() function, returning an array of enum values, and valueOf(String name) which takes a String and returns the enum value with the corresponding name (or throws an exception). More examples here &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt;.<br>&gt; <br>&gt; The Template Haskell extension to Haskell provides a function reify which extracts info about types &lt;http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#t:Info&gt;, including their constructors.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; Introduce a CaseEnumerable protocol. Conforming to CaseEnumerable will automagically derive a static var cases, whose type is a CollectionType of all the enum&#39;s values.<br>&gt; <br>&gt; Like ErrorType, the CaseEnumerable protocol will not have any user-visible requirements; merely adding the conformance is enough to enable case enumeration.<br>&gt; <br>&gt; enum Ma { case È©¨, Âêó, Â¶à, Á†Å, È™Ç, üêé, üê¥ }<br>&gt; <br>&gt; extension Ma: CaseEnumerable {}<br>&gt; <br>&gt; Ma.cases         // returns some CollectionType whose Generator.Element is Ma<br>&gt; Ma.cases.count   // returns 7<br>&gt; Array(Ma.cases)  // returns [Ma.È©¨, .Âêó, .Â¶à, .Á†Å, .È™Ç, .üêé, .üê¥]<br>&gt; Conformances can even be added for enums which are defined in other modules:<br>&gt; <br>&gt; extension NSTextAlignment: CaseEnumerable {}<br>&gt; <br>&gt; Array(NSTextAlignment.cases)  // returns [NSTextAlignment.Left, .Right, .Center, .Justified, .Natural]<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; Enum cases are enumerated in the order they appear in the source code.<br>&gt; <br>&gt; The cases collection does not necessitate Œ©(number of cases) static storage. For integer-backed enums, only the range(s) of valid rawValues need to be stored, and the enum construction can happen dynamically.<br>&gt; <br>&gt; Attempting to derive CaseEnumerable for a non-enum type will result in a compiler error.<br>&gt; <br>&gt; Attempting to derive CaseEnumerable for an enum with associated values will result in a compiler error.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#possible-variations&gt;Possible variations<br>&gt; <br>&gt; I&#39;d like us to discuss these, but they should be folded into either Proposed solution or Future directions before the proposal is submitted for review.<br>&gt; <br>&gt; For enums with raw values, a static rawValues property (a collection of RawValue rather than the enum type itself) could also be synthesized.<br>&gt; <br>&gt; CaseEnumerable could have a user-visible declaration requiring static var cases, which would allow users to add conformances for custom non-enum types.<br>&gt; <br>&gt; In this case, adding a conformance for a non-enum type would not be a compiler error, it would just require an explicit implementation of static var cases, since the compiler wouldn&#39;t synthesize it.<br>&gt; This would probably require cases to be AnySequence&lt;Self&gt;, or to introduce an AnyCollection, since we aren&#39;t able to say associatedtype CaseCollection: CollectionType where CaseCollection.Generator.Element == Self.<br>&gt; It would be nice to have a way of supporting this for OptionSetType structs. I would recommend that cases for an OptionSetType should include only the already-declared static properties (not all possible combinations of them). However, I&#39;m not sure it fits into this proposal.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This proposal only adds functionality, so existing code will not be affected. (The identifier CaseEnumerable doesn&#39;t make any significant appearances in Google and GitHub searches.)<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; The community has not raised any solutions that differ significantly from this proposal, except for solutions which provide strictly more functionality. These are covered in the next section, Future directions.<br>&gt; <br>&gt; An alternative is to not implement this feature. The cons of this are discussed in the Motivation section above.<br>&gt; <br>&gt; The functionality could also be provided entirely through the Mirror/reflection APIs, but this would result in much more obscure and confusing usage patterns.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#future-directions&gt;Future directions<br>&gt; <br>&gt; Many people would be happy to see even more functionality than what&#39;s proposed here. I&#39;m keeping this proposal intentionally limited, but I hope the community can continue discussing the topic to flesh out more features.<br>&gt; <br>&gt; Here are some starting points, which are not part of this proposal:<br>&gt; <br>&gt; Support for enum case names. It would be useful to get case names even for enums which have integer rawValues. This could be part of the existing reflection APIs, or it could take the form of derived implementations of StringLiteralConvertible/CustomStringConvertible.<br>&gt; <br>&gt; Support for enums with associated values.<br>&gt; <br>&gt; When all associated values are themselves CaseEnumerable, this could happen automatically:<br>&gt; <br>&gt; enum Suit: CaseEnumerable { case Spades, Hearts, Diamonds, Clubs }<br>&gt; enum Rank: Int, CaseEnumerable {<br>&gt;     case Ace = 1, Two, Three, Four, Five, Six<br>&gt;     case Seven, Eight, Nine, Ten, Jack, Queen, King<br>&gt; }<br>&gt; enum Card {<br>&gt;     case Joker<br>&gt;     case Value(Rank, Suit)<br>&gt; }<br>&gt; <br>&gt; // This now works, and generates all possible card types (Joker, Value(Ace, Spades), ...)<br>&gt; extension Card: CaseEnumerable {}<br>&gt; If associated values aren&#39;t CaseEnumerable, but all cases are homogeneous, the cases collection could vend functions of AssociatedValueType -&gt; EnumType:<br>&gt; <br>&gt; enum LogMessage { case Error(String), Warning(String), Info(String) }<br>&gt; extension LogMessage: CaseEnumerable {}<br>&gt; <br>&gt; LogMessage.cases  // elements are (String) -&gt; LogMessage<br>&gt; If Swift had anonymous sum types like A | B | C, then E.cases could vend elements of type A-&gt;E | B-&gt;E | C-&gt;E.<br>&gt; <br>&gt; enum Expr { case Apply(Expr, Expr), Tuple(Expr, Expr), Literal(Int) }<br>&gt; extension Value: CaseEnumerable {}<br>&gt; <br>&gt; // This example is pretty contrived, but illustrates the functionality.<br>&gt; let fortyTwos = Expr.cases.map {<br>&gt;    // $0 is of type `Int -&gt; Expr | (Expr, Expr) -&gt; Expr`<br>&gt;    switch $0 {<br>&gt;    case let lit as Int -&gt; Expr:  // handles .Literal<br>&gt;        return lit(42)<br>&gt;    case let bin as (Expr, Expr) -&gt; Expr:  // handles .Apply and .Tuple<br>&gt;        return bin(.Literal(42), .Literal(42))<br>&gt;    // all cases are covered<br>&gt;    }<br>&gt; }<br>&gt; Support for generic enums.<br>&gt; <br>&gt; CaseEnumerable could be conditionally supported depending on the generic argument(s). A great example would be Optional:<br>&gt; <br>&gt; enum MyEnum: CaseEnumerable {}<br>&gt; extension Optional: CaseEnumerable where Wrapped: CaseEnumerable {}<br>&gt; <br>&gt; // Optional&lt;MyEnum&gt;.cases effectively contains `MyEnum.cases + [.None]`<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/4107d4f6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 17, 2016 at 06:00:00pm</p></header><div class="content"><p>On Sun, Jan 17, 2016 at 5:56 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br></p><p>&gt; While this isn‚Äôt in review yet, massive +1 from me. Good first<br>&gt; implementation, and very welcome functionality.<br>&gt;<br>&gt; Personally, I‚Äôm actually dealing with the difficulties of counts and<br>&gt; enumerating enums in Obj-C and this is a pain in the neck. It‚Äôs not<br>&gt; difficult, but it‚Äôs prone to breakage when someone alters code.<br>&gt;<br></p><p>If you&#39;re willing to share, I think it would help to have more examples of<br>what problems people are trying to solve.<br></p><p>Jacob<br></p><p><br>&gt;<br>&gt; This would be a vast improvement.<br>&gt;<br>&gt;<br>&gt; On 18 Jan 2016, at 10:44 AM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi folks,<br>&gt;<br>&gt; I&#39;ve drafted a proposal to add a CaseEnumerable protocol, which will<br>&gt; derive a static variable &quot;cases&quot; for enum types. Feedback is welcome,<br>&gt; especially for refining the proposal before I submit a formal PR.<br>&gt;<br>&gt; The draft is here; full text below.<br>&gt; https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md<br>&gt;<br>&gt;<br>&gt; Derived Collection of Enum Cases<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-derived-collection-of-enum-cases.md&gt;<br>&gt;    - Author(s): Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;<br>&gt;    - Status: *Awaiting review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; It is a truth universally acknowledged, that a programmer in possession of<br>&gt; an enum with many cases, must eventually be in want of dynamic enumeration<br>&gt; over them.<br>&gt;<br>&gt; This topic has come up three times on the swift-evolution mailing list so<br>&gt; far:<br>&gt;<br>&gt;    - List of all Enum values (for simple enums)<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001233.html&gt; (December<br>&gt;    8, 2015)<br>&gt;    - Proposal: Enum &#39;count&#39; functionality<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/003819.html&gt; (December<br>&gt;    21, 2015)<br>&gt;    - Draft Proposal: count property for enum types<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006853.html&gt; (January<br>&gt;    17, 2016)<br>&gt;<br>&gt; Enumerating enumerations in Swift is also a popular topic on Stack<br>&gt; Overflow:<br>&gt;<br>&gt;    - How to enumerate an enum with String type?<br>&gt;    &lt;http://stackoverflow.com/questions/24007461/how-to-enumerate-an-enum-with-string-type&gt; (June<br>&gt;    3, 2014; question score 131)<br>&gt;    - How do I get the count of a Swift enum?<br>&gt;    &lt;http://stackoverflow.com/questions/27094878/how-do-i-get-the-count-of-a-swift-enum&gt; (November<br>&gt;    23, 2014; question score 37)<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Simple enums are finite, and their values are statically known to the<br>&gt; compiler, yet working with them programmatically is challenging. It is<br>&gt; often desirable to iterate over all possible cases of an enum, or to know<br>&gt; the number of cases (or maximum valid rawValue).<br>&gt;<br>&gt; Currently, however, there is no built-in reflection or enumeration<br>&gt; support. Users must resort to manually listing out cases in order to<br>&gt; iterate over them:<br>&gt;<br>&gt; enum Attribute {<br>&gt;     case Date, Name, Author<br>&gt; }func valueForAttribute(attr: Attribute) -&gt; String { ‚Ä¶from elsewhere‚Ä¶ }<br>&gt; // Cases must be listed explicitly:<br>&gt; [Attribute.Date, .Name, .Author].map{ valueForAttribute($0) }.joinWithSeparator(&quot;\n&quot;)<br>&gt;<br>&gt; For RawRepresentable enums, users have often relied on iterating over the<br>&gt; known (or assumed) allowable raw values:<br>&gt;<br>&gt; *Annotated excerpt from Nate Cook&#39;s post, Loopy, Random Ideas for<br>&gt; Extending &quot;enum&quot;<br>&gt; &lt;http://natecook.com/blog/2014/10/loopy-random-enum-ideas/&gt; (October 2014):*<br>&gt;<br>&gt; enum Reindeer: Int {<br>&gt;     case Dasher, Dancer, Prancer, Vixen, Comet, Cupid, Donner, Blitzen, Rudolph<br>&gt; }extension Reindeer {<br>&gt;     static var allCases: [Reindeer] {<br>&gt;         var cur = 0<br>&gt;         return Array(<br>&gt;             GeneratorOf&lt;Reindeer&gt; {<br>&gt;                 return Reindeer(rawValue: cur++)<br>&gt;             }<br>&gt;         )<br>&gt;     }<br>&gt;     static var caseCount: Int {<br>&gt;         var max: Int = 0<br>&gt;         while let _ = self(rawValue: ++max) {}<br>&gt;         return max<br>&gt;     }<br>&gt;     static func randomCase() -&gt; Reindeer {<br>&gt;         // everybody do the Int/UInt32 shuffle!<br>&gt;         let randomValue = Int(arc4random_uniform(UInt32(caseCount)))<br>&gt;         return self(rawValue: randomValue)!<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; There are many problems with these existing techniques:<br>&gt;<br>&gt;    - They are ad-hoc and can&#39;t benefit every enum type without duplicated<br>&gt;    and code.<br>&gt;    - They are not standardized across codebases, nor provided<br>&gt;    automatically by libraries such as Foundation and {App,UI}Kit.<br>&gt;    - They are sometimes prone to bugs when enum cases are added, but the<br>&gt;    user forgets to update a hard-coded static collection of cases.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#precedent-in-other-languages&gt;Precedent<br>&gt; in other languages<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Rust does not seem to have a solution for this problem.<br>&gt;    -<br>&gt;<br>&gt;    C#&#39;s Enum has several methods<br>&gt;    &lt;https://msdn.microsoft.com/en-us/library/system.enum_methods.aspx&gt; available<br>&gt;    for reflection, including GetValues() and GetNames().<br>&gt;    -<br>&gt;<br>&gt;    Java implicitly declares<br>&gt;    &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt; a<br>&gt;    static values() function, returning an array of enum values, and valueOf(String<br>&gt;    name) which takes a String and returns the enum value with the<br>&gt;    corresponding name (or throws an exception). More examples here<br>&gt;    &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt;<br>&gt;    .<br>&gt;    -<br>&gt;<br>&gt;    The Template Haskell extension to Haskell provides a function reify which<br>&gt;    extracts info about types<br>&gt;    &lt;http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#t:Info&gt;,<br>&gt;    including their constructors.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; Introduce a CaseEnumerable protocol. Conforming to CaseEnumerable will<br>&gt; automagically derive a static var cases, whose type is a CollectionType<br>&gt; of all the enum&#39;s values.<br>&gt;<br>&gt; Like ErrorType, the CaseEnumerable protocol will not have any<br>&gt; user-visible requirements; merely adding the conformance is enough to<br>&gt; enable case enumeration.<br>&gt;<br>&gt; enum Ma { case È©¨, Âêó, Â¶à, Á†Å, È™Ç, üêé, üê¥ }<br>&gt; extension Ma: CaseEnumerable {}<br>&gt;<br>&gt; Ma.cases         // returns some CollectionType whose Generator.Element is Ma<br>&gt; Ma.cases.count   // returns 7Array(Ma.cases)  // returns [Ma.È©¨, .Âêó, .Â¶à, .Á†Å, .È™Ç, .üêé, .üê¥]<br>&gt;<br>&gt; Conformances can even be added for enums which are defined in other<br>&gt; modules:<br>&gt;<br>&gt; extension NSTextAlignment: CaseEnumerable {}<br>&gt; Array(NSTextAlignment.cases)  // returns [NSTextAlignment.Left, .Right, .Center, .Justified, .Natural]<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; Enum cases are enumerated in the order they appear in the source code.<br>&gt;<br>&gt; The cases collection does not necessitate Œ©(number of cases) static<br>&gt; storage. For integer-backed enums, only the range(s) of valid rawValues<br>&gt; need to be stored, and the enum construction can happen dynamically.<br>&gt;<br>&gt; Attempting to derive CaseEnumerable for a non-enum type will result in a<br>&gt; compiler error.<br>&gt;<br>&gt; Attempting to derive CaseEnumerable for an enum with associated values<br>&gt; will result in a compiler error.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#possible-variations&gt;Possible<br>&gt; variations<br>&gt;<br>&gt; I&#39;d like us to discuss these, but they should be folded into either *Proposed<br>&gt; solution* or *Future directions* before the proposal is submitted for<br>&gt; review.<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    For enums with raw values, a static rawValues property (a collection<br>&gt;    of RawValue rather than the enum type itself) could also be<br>&gt;    synthesized.<br>&gt;    -<br>&gt;<br>&gt;    CaseEnumerable could have a user-visible declaration requiring static<br>&gt;    var cases, which would allow users to add conformances for custom non-<br>&gt;    enum types.<br>&gt;    - In this case, adding a conformance for a non-enum type would not be<br>&gt;       a compiler error, it would just require an explicit implementation of static<br>&gt;       var cases, since the compiler wouldn&#39;t synthesize it.<br>&gt;       - This would probably require cases to be AnySequence&lt;Self&gt;, or to<br>&gt;       introduce an AnyCollection, since we aren&#39;t able to say associatedtype<br>&gt;       CaseCollection: CollectionType where CaseCollection.Generator.Element ==<br>&gt;       Self.<br>&gt;    -<br>&gt;<br>&gt;    It would be nice to have a way of supporting this for OptionSetType<br>&gt;    structs. I would recommend that cases for an OptionSetType should<br>&gt;    include only the already-declared static properties (not all possible<br>&gt;    combinations of them). However, I&#39;m not sure it fits into this proposal.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; This proposal only adds functionality, so existing code will not be<br>&gt; affected. (The identifier CaseEnumerable doesn&#39;t make any significant<br>&gt; appearances in Google and GitHub searches.)<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt; The community has not raised any solutions that differ significantly from<br>&gt; this proposal, except for solutions which provide strictly *more* functionality.<br>&gt; These are covered in the next section, *Future directions*.<br>&gt;<br>&gt; An alternative is to *not* implement this feature. The cons of this are<br>&gt; discussed in the *Motivation* section above.<br>&gt;<br>&gt; The functionality could also be provided entirely through the<br>&gt; Mirror/reflection APIs, but this would result in much more obscure and<br>&gt; confusing usage patterns.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#future-directions&gt;Future<br>&gt; directions<br>&gt;<br>&gt; Many people would be happy to see even more functionality than what&#39;s<br>&gt; proposed here. I&#39;m keeping this proposal intentionally limited, but I hope<br>&gt; the community can continue discussing the topic to flesh out more features.<br>&gt;<br>&gt; Here are some starting points, which are *not* part of this proposal:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Support for enum case *names*. It would be useful to get case names<br>&gt;    even for enums which have integer rawValues. This could be part of the<br>&gt;    existing reflection APIs, or it could take the form of derived<br>&gt;    implementations of StringLiteralConvertible/CustomStringConvertible.<br>&gt;    -<br>&gt;<br>&gt;    Support for enums with associated values.<br>&gt;    -<br>&gt;<br>&gt;       When all associated values are themselves CaseEnumerable, this<br>&gt;       could happen automatically:<br>&gt;<br>&gt;       enum Suit: CaseEnumerable { case Spades, Hearts, Diamonds, Clubs }enum Rank: Int, CaseEnumerable {<br>&gt;           case Ace = 1, Two, Three, Four, Five, Six<br>&gt;           case Seven, Eight, Nine, Ten, Jack, Queen, King<br>&gt;       }enum Card {<br>&gt;           case Joker<br>&gt;           case Value(Rank, Suit)<br>&gt;       }<br>&gt;       // This now works, and generates all possible card types (Joker, Value(Ace, Spades), ...)extension Card: CaseEnumerable {}<br>&gt;<br>&gt;       -<br>&gt;<br>&gt;       If associated values aren&#39;t CaseEnumerable, but all cases are<br>&gt;       homogeneous, the cases collection could vend functions of AssociatedValueType<br>&gt;       -&gt; EnumType:<br>&gt;<br>&gt;       enum LogMessage { case Error(String), Warning(String), Info(String) }extension LogMessage: CaseEnumerable {}<br>&gt;<br>&gt;       LogMessage.cases  // elements are (String) -&gt; LogMessage<br>&gt;<br>&gt;       -<br>&gt;<br>&gt;       If Swift had anonymous sum types like A | B | C, then E.cases could<br>&gt;       vend elements of type A-&gt;E | B-&gt;E | C-&gt;E.<br>&gt;<br>&gt;       enum Expr { case Apply(Expr, Expr), Tuple(Expr, Expr), Literal(Int) }extension Value: CaseEnumerable {}<br>&gt;       // This example is pretty contrived, but illustrates the functionality.let fortyTwos = Expr.cases.map {<br>&gt;          // $0 is of type `Int -&gt; Expr | (Expr, Expr) -&gt; Expr`<br>&gt;          switch $0 {<br>&gt;          case let lit as Int -&gt; Expr:  // handles .Literal<br>&gt;              return lit(42)<br>&gt;          case let bin as (Expr, Expr) -&gt; Expr:  // handles .Apply and .Tuple<br>&gt;              return bin(.Literal(42), .Literal(42))<br>&gt;          // all cases are covered<br>&gt;          }<br>&gt;       }<br>&gt;<br>&gt;       -<br>&gt;<br>&gt;    Support for generic enums.<br>&gt;    -<br>&gt;<br>&gt;       CaseEnumerable could be conditionally supported depending on the<br>&gt;       generic argument(s). A great example would be Optional:<br>&gt;<br>&gt;       enum MyEnum: CaseEnumerable {}extension Optional: CaseEnumerable where Wrapped: CaseEnumerable {}<br>&gt;       // Optional&lt;MyEnum&gt;.cases effectively contains `MyEnum.cases + [.None]`<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160117/db13a7e2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>January 18, 2016 at 01:00:00pm</p></header><div class="content"><p>In this case, I have a standard NS_ENUM with a series of cases. I require to create an NSArray by enumerating through the cases and adding an object per case.<br></p><p>To do so, I either assume what the last case is in the enum and perform a for loop, or I add a final item in the for loop e.g. ‚ÄúEGSectionEnum_Count‚Äù, and then enumerate to it.<br></p><p>This is fragile as the moment anyone adds a case beyond the final item, the code becomes incorrect. If I add the EGSectionEnum_Count item, I am exposing an invalid value. Also, it assumes that the enum NSInteger values are continuous increasing by +1. Where someone specifically defines a value for the item, the entire for loop enumerating through fails.<br></p><p>By allowing direct enumeration by case, we avoid assuming values for each item and therefore code fragility, we avoid exposing a count of the items as a separate enum value which should not exist, and we avoid the reliance on Integer based enums, as these previous methods would not work on Swift‚Äôs string- and other- type based enums.<br></p><p><br>&gt; On 18 Jan 2016, at 1:01 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Sun, Jan 17, 2016 at 5:56 PM, Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt; While this isn‚Äôt in review yet, massive +1 from me. Good first implementation, and very welcome functionality.<br>&gt; <br>&gt; Personally, I‚Äôm actually dealing with the difficulties of counts and enumerating enums in Obj-C and this is a pain in the neck. It‚Äôs not difficult, but it‚Äôs prone to breakage when someone alters code.<br>&gt; <br>&gt; If you&#39;re willing to share, I think it would help to have more examples of what problems people are trying to solve.<br>&gt; <br>&gt; Jacob<br>&gt;  <br>&gt; <br>&gt; This would be a vast improvement.<br>&gt; <br>&gt; <br>&gt;&gt; On 18 Jan 2016, at 10:44 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi folks,<br>&gt;&gt; <br>&gt;&gt; I&#39;ve drafted a proposal to add a CaseEnumerable protocol, which will derive a static variable &quot;cases&quot; for enum types. Feedback is welcome, especially for refining the proposal before I submit a formal PR.<br>&gt;&gt; <br>&gt;&gt; The draft is here; full text below. https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Derived Collection of Enum Cases<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-derived-collection-of-enum-cases.md&gt;<br>&gt;&gt; Author(s): Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; It is a truth universally acknowledged, that a programmer in possession of an enum with many cases, must eventually be in want of dynamic enumeration over them.<br>&gt;&gt; <br>&gt;&gt; This topic has come up three times on the swift-evolution mailing list so far:<br>&gt;&gt; <br>&gt;&gt; List of all Enum values (for simple enums) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001233.html&gt; (December 8, 2015)<br>&gt;&gt; Proposal: Enum &#39;count&#39; functionality &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/003819.html&gt; (December 21, 2015)<br>&gt;&gt; Draft Proposal: count property for enum types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006853.html&gt; (January 17, 2016)<br>&gt;&gt; Enumerating enumerations in Swift is also a popular topic on Stack Overflow:<br>&gt;&gt; <br>&gt;&gt; How to enumerate an enum with String type? &lt;http://stackoverflow.com/questions/24007461/how-to-enumerate-an-enum-with-string-type&gt; (June 3, 2014; question score 131)<br>&gt;&gt; How do I get the count of a Swift enum? &lt;http://stackoverflow.com/questions/27094878/how-do-i-get-the-count-of-a-swift-enum&gt; (November 23, 2014; question score 37)<br>&gt;&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; Simple enums are finite, and their values are statically known to the compiler, yet working with them programmatically is challenging. It is often desirable to iterate over all possible cases of an enum, or to know the number of cases (or maximum valid rawValue).<br>&gt;&gt; <br>&gt;&gt; Currently, however, there is no built-in reflection or enumeration support. Users must resort to manually listing out cases in order to iterate over them:<br>&gt;&gt; <br>&gt;&gt; enum Attribute {<br>&gt;&gt;     case Date, Name, Author<br>&gt;&gt; }<br>&gt;&gt; func valueForAttribute(attr: Attribute) -&gt; String { ‚Ä¶from elsewhere‚Ä¶ }<br>&gt;&gt; <br>&gt;&gt; // Cases must be listed explicitly:<br>&gt;&gt; [Attribute.Date, .Name, .Author].map{ valueForAttribute($0) }.joinWithSeparator(&quot;\n&quot;)<br>&gt;&gt; For RawRepresentable enums, users have often relied on iterating over the known (or assumed) allowable raw values:<br>&gt;&gt; <br>&gt;&gt; Annotated excerpt from Nate Cook&#39;s post, Loopy, Random Ideas for Extending &quot;enum&quot; &lt;http://natecook.com/blog/2014/10/loopy-random-enum-ideas/&gt; (October 2014):<br>&gt;&gt; <br>&gt;&gt; enum Reindeer: Int {<br>&gt;&gt;     case Dasher, Dancer, Prancer, Vixen, Comet, Cupid, Donner, Blitzen, Rudolph  <br>&gt;&gt; }<br>&gt;&gt; extension Reindeer {<br>&gt;&gt;     static var allCases: [Reindeer] {<br>&gt;&gt;         var cur = 0<br>&gt;&gt;         return Array(<br>&gt;&gt;             GeneratorOf&lt;Reindeer&gt; {<br>&gt;&gt;                 return Reindeer(rawValue: cur++)<br>&gt;&gt;             }<br>&gt;&gt;         )<br>&gt;&gt;     }<br>&gt;&gt;     static var caseCount: Int {<br>&gt;&gt;         var max: Int = 0<br>&gt;&gt;         while let _ = self(rawValue: ++max) {}<br>&gt;&gt;         return max<br>&gt;&gt;     }<br>&gt;&gt;     static func randomCase() -&gt; Reindeer {<br>&gt;&gt;         // everybody do the Int/UInt32 shuffle!<br>&gt;&gt;         let randomValue = Int(arc4random_uniform(UInt32(caseCount)))<br>&gt;&gt;         return self(rawValue: randomValue)!<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; There are many problems with these existing techniques:<br>&gt;&gt; <br>&gt;&gt; They are ad-hoc and can&#39;t benefit every enum type without duplicated and code.<br>&gt;&gt; They are not standardized across codebases, nor provided automatically by libraries such as Foundation and {App,UI}Kit.<br>&gt;&gt; They are sometimes prone to bugs when enum cases are added, but the user forgets to update a hard-coded static collection of cases.<br>&gt;&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#precedent-in-other-languages&gt;Precedent in other languages<br>&gt;&gt; <br>&gt;&gt; Rust does not seem to have a solution for this problem.<br>&gt;&gt; <br>&gt;&gt; C#&#39;s Enum has several methods &lt;https://msdn.microsoft.com/en-us/library/system.enum_methods.aspx&gt; available for reflection, including GetValues() and GetNames().<br>&gt;&gt; <br>&gt;&gt; Java implicitly declares &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt; a static values() function, returning an array of enum values, and valueOf(String name) which takes a String and returns the enum value with the corresponding name (or throws an exception). More examples here &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt;.<br>&gt;&gt; <br>&gt;&gt; The Template Haskell extension to Haskell provides a function reify which extracts info about types &lt;http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#t:Info&gt;, including their constructors.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; Introduce a CaseEnumerable protocol. Conforming to CaseEnumerable will automagically derive a static var cases, whose type is a CollectionType of all the enum&#39;s values.<br>&gt;&gt; <br>&gt;&gt; Like ErrorType, the CaseEnumerable protocol will not have any user-visible requirements; merely adding the conformance is enough to enable case enumeration.<br>&gt;&gt; <br>&gt;&gt; enum Ma { case È©¨, Âêó, Â¶à, Á†Å, È™Ç, üêé, üê¥ }<br>&gt;&gt; <br>&gt;&gt; extension Ma: CaseEnumerable {}<br>&gt;&gt; <br>&gt;&gt; Ma.cases         // returns some CollectionType whose Generator.Element is Ma<br>&gt;&gt; Ma.cases.count   // returns 7<br>&gt;&gt; Array(Ma.cases)  // returns [Ma.È©¨, .Âêó, .Â¶à, .Á†Å, .È™Ç, .üêé, .üê¥]<br>&gt;&gt; Conformances can even be added for enums which are defined in other modules:<br>&gt;&gt; <br>&gt;&gt; extension NSTextAlignment: CaseEnumerable {}<br>&gt;&gt; <br>&gt;&gt; Array(NSTextAlignment.cases)  // returns [NSTextAlignment.Left, .Right, .Center, .Justified, .Natural]<br>&gt;&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; Enum cases are enumerated in the order they appear in the source code.<br>&gt;&gt; <br>&gt;&gt; The cases collection does not necessitate Œ©(number of cases) static storage. For integer-backed enums, only the range(s) of valid rawValues need to be stored, and the enum construction can happen dynamically.<br>&gt;&gt; <br>&gt;&gt; Attempting to derive CaseEnumerable for a non-enum type will result in a compiler error.<br>&gt;&gt; <br>&gt;&gt; Attempting to derive CaseEnumerable for an enum with associated values will result in a compiler error.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#possible-variations&gt;Possible variations<br>&gt;&gt; <br>&gt;&gt; I&#39;d like us to discuss these, but they should be folded into either Proposed solution or Future directions before the proposal is submitted for review.<br>&gt;&gt; <br>&gt;&gt; For enums with raw values, a static rawValues property (a collection of RawValue rather than the enum type itself) could also be synthesized.<br>&gt;&gt; <br>&gt;&gt; CaseEnumerable could have a user-visible declaration requiring static var cases, which would allow users to add conformances for custom non-enum types.<br>&gt;&gt; <br>&gt;&gt; In this case, adding a conformance for a non-enum type would not be a compiler error, it would just require an explicit implementation of static var cases, since the compiler wouldn&#39;t synthesize it.<br>&gt;&gt; This would probably require cases to be AnySequence&lt;Self&gt;, or to introduce an AnyCollection, since we aren&#39;t able to say associatedtype CaseCollection: CollectionType where CaseCollection.Generator.Element == Self.<br>&gt;&gt; It would be nice to have a way of supporting this for OptionSetType structs. I would recommend that cases for an OptionSetType should include only the already-declared static properties (not all possible combinations of them). However, I&#39;m not sure it fits into this proposal.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This proposal only adds functionality, so existing code will not be affected. (The identifier CaseEnumerable doesn&#39;t make any significant appearances in Google and GitHub searches.)<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The community has not raised any solutions that differ significantly from this proposal, except for solutions which provide strictly more functionality. These are covered in the next section, Future directions.<br>&gt;&gt; <br>&gt;&gt; An alternative is to not implement this feature. The cons of this are discussed in the Motivation section above.<br>&gt;&gt; <br>&gt;&gt; The functionality could also be provided entirely through the Mirror/reflection APIs, but this would result in much more obscure and confusing usage patterns.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#future-directions&gt;Future directions<br>&gt;&gt; <br>&gt;&gt; Many people would be happy to see even more functionality than what&#39;s proposed here. I&#39;m keeping this proposal intentionally limited, but I hope the community can continue discussing the topic to flesh out more features.<br>&gt;&gt; <br>&gt;&gt; Here are some starting points, which are not part of this proposal:<br>&gt;&gt; <br>&gt;&gt; Support for enum case names. It would be useful to get case names even for enums which have integer rawValues. This could be part of the existing reflection APIs, or it could take the form of derived implementations of StringLiteralConvertible/CustomStringConvertible.<br>&gt;&gt; <br>&gt;&gt; Support for enums with associated values.<br>&gt;&gt; <br>&gt;&gt; When all associated values are themselves CaseEnumerable, this could happen automatically:<br>&gt;&gt; <br>&gt;&gt; enum Suit: CaseEnumerable { case Spades, Hearts, Diamonds, Clubs }<br>&gt;&gt; enum Rank: Int, CaseEnumerable {<br>&gt;&gt;     case Ace = 1, Two, Three, Four, Five, Six<br>&gt;&gt;     case Seven, Eight, Nine, Ten, Jack, Queen, King<br>&gt;&gt; }<br>&gt;&gt; enum Card {<br>&gt;&gt;     case Joker<br>&gt;&gt;     case Value(Rank, Suit)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // This now works, and generates all possible card types (Joker, Value(Ace, Spades), ...)<br>&gt;&gt; extension Card: CaseEnumerable {}<br>&gt;&gt; If associated values aren&#39;t CaseEnumerable, but all cases are homogeneous, the cases collection could vend functions of AssociatedValueType -&gt; EnumType:<br>&gt;&gt; <br>&gt;&gt; enum LogMessage { case Error(String), Warning(String), Info(String) }<br>&gt;&gt; extension LogMessage: CaseEnumerable {}<br>&gt;&gt; <br>&gt;&gt; LogMessage.cases  // elements are (String) -&gt; LogMessage<br>&gt;&gt; If Swift had anonymous sum types like A | B | C, then E.cases could vend elements of type A-&gt;E | B-&gt;E | C-&gt;E.<br>&gt;&gt; <br>&gt;&gt; enum Expr { case Apply(Expr, Expr), Tuple(Expr, Expr), Literal(Int) }<br>&gt;&gt; extension Value: CaseEnumerable {}<br>&gt;&gt; <br>&gt;&gt; // This example is pretty contrived, but illustrates the functionality.<br>&gt;&gt; let fortyTwos = Expr.cases.map {<br>&gt;&gt;    // $0 is of type `Int -&gt; Expr | (Expr, Expr) -&gt; Expr`<br>&gt;&gt;    switch $0 {<br>&gt;&gt;    case let lit as Int -&gt; Expr:  // handles .Literal<br>&gt;&gt;        return lit(42)<br>&gt;&gt;    case let bin as (Expr, Expr) -&gt; Expr:  // handles .Apply and .Tuple<br>&gt;&gt;        return bin(.Literal(42), .Literal(42))<br>&gt;&gt;    // all cases are covered<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; Support for generic enums.<br>&gt;&gt; <br>&gt;&gt; CaseEnumerable could be conditionally supported depending on the generic argument(s). A great example would be Optional:<br>&gt;&gt; <br>&gt;&gt; enum MyEnum: CaseEnumerable {}<br>&gt;&gt; extension Optional: CaseEnumerable where Wrapped: CaseEnumerable {}<br>&gt;&gt; <br>&gt;&gt; // Optional&lt;MyEnum&gt;.cases effectively contains `MyEnum.cases + [.None]`<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/f7e26816/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce6825f55ba05353e3652d8989b6137?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Will Entriken</string> &lt;fulldecent at gmail.com&gt;<p>January 17, 2016 at 09:00:00pm</p></header><div class="content"><p>I do like the prospect of being able to get a list of enumerations. Also, I<br>can attest to how painful this has been, I think you have cited my question<br>on SO. In English, it is disturbing to find that an enumeration (&quot;enum&quot;) is<br>not enumerable.<br></p><p>If there is an enum which is not enumerable, a lesser distinction would be<br>whether it is countable. This allows you to use Card.count() which may also<br>useful.<br></p><p>I was surprised that È∫ª was missing from your list.<br></p><p><br></p><p>On Sun, Jan 17, 2016 at 6:44 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi folks,<br>&gt;<br>&gt; I&#39;ve drafted a proposal to add a CaseEnumerable protocol, which will<br>&gt; derive a static variable &quot;cases&quot; for enum types. Feedback is welcome,<br>&gt; especially for refining the proposal before I submit a formal PR.<br>&gt;<br>&gt; The draft is here; full text below.<br>&gt; https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md<br>&gt;<br>&gt;<br>&gt; Derived Collection of Enum Cases<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-derived-collection-of-enum-cases.md&gt;<br>&gt;    - Author(s): Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;<br>&gt;    - Status: *Awaiting review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; It is a truth universally acknowledged, that a programmer in possession of<br>&gt; an enum with many cases, must eventually be in want of dynamic enumeration<br>&gt; over them.<br>&gt;<br>&gt; This topic has come up three times on the swift-evolution mailing list so<br>&gt; far:<br>&gt;<br>&gt;    - List of all Enum values (for simple enums)<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001233.html&gt; (December<br>&gt;    8, 2015)<br>&gt;    - Proposal: Enum &#39;count&#39; functionality<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/003819.html&gt; (December<br>&gt;    21, 2015)<br>&gt;    - Draft Proposal: count property for enum types<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006853.html&gt; (January<br>&gt;    17, 2016)<br>&gt;<br>&gt; Enumerating enumerations in Swift is also a popular topic on Stack<br>&gt; Overflow:<br>&gt;<br>&gt;    - How to enumerate an enum with String type?<br>&gt;    &lt;http://stackoverflow.com/questions/24007461/how-to-enumerate-an-enum-with-string-type&gt; (June<br>&gt;    3, 2014; question score 131)<br>&gt;    - How do I get the count of a Swift enum?<br>&gt;    &lt;http://stackoverflow.com/questions/27094878/how-do-i-get-the-count-of-a-swift-enum&gt; (November<br>&gt;    23, 2014; question score 37)<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Simple enums are finite, and their values are statically known to the<br>&gt; compiler, yet working with them programmatically is challenging. It is<br>&gt; often desirable to iterate over all possible cases of an enum, or to know<br>&gt; the number of cases (or maximum valid rawValue).<br>&gt;<br>&gt; Currently, however, there is no built-in reflection or enumeration<br>&gt; support. Users must resort to manually listing out cases in order to<br>&gt; iterate over them:<br>&gt;<br>&gt; enum Attribute {<br>&gt;     case Date, Name, Author<br>&gt; }func valueForAttribute(attr: Attribute) -&gt; String { ‚Ä¶from elsewhere‚Ä¶ }<br>&gt; // Cases must be listed explicitly:<br>&gt; [Attribute.Date, .Name, .Author].map{ valueForAttribute($0) }.joinWithSeparator(&quot;\n&quot;)<br>&gt;<br>&gt; For RawRepresentable enums, users have often relied on iterating over the<br>&gt; known (or assumed) allowable raw values:<br>&gt;<br>&gt; *Annotated excerpt from Nate Cook&#39;s post, Loopy, Random Ideas for<br>&gt; Extending &quot;enum&quot;<br>&gt; &lt;http://natecook.com/blog/2014/10/loopy-random-enum-ideas/&gt; (October 2014):*<br>&gt;<br>&gt; enum Reindeer: Int {<br>&gt;     case Dasher, Dancer, Prancer, Vixen, Comet, Cupid, Donner, Blitzen, Rudolph<br>&gt; }extension Reindeer {<br>&gt;     static var allCases: [Reindeer] {<br>&gt;         var cur = 0<br>&gt;         return Array(<br>&gt;             GeneratorOf&lt;Reindeer&gt; {<br>&gt;                 return Reindeer(rawValue: cur++)<br>&gt;             }<br>&gt;         )<br>&gt;     }<br>&gt;     static var caseCount: Int {<br>&gt;         var max: Int = 0<br>&gt;         while let _ = self(rawValue: ++max) {}<br>&gt;         return max<br>&gt;     }<br>&gt;     static func randomCase() -&gt; Reindeer {<br>&gt;         // everybody do the Int/UInt32 shuffle!<br>&gt;         let randomValue = Int(arc4random_uniform(UInt32(caseCount)))<br>&gt;         return self(rawValue: randomValue)!<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; There are many problems with these existing techniques:<br>&gt;<br>&gt;    - They are ad-hoc and can&#39;t benefit every enum type without duplicated<br>&gt;    and code.<br>&gt;    - They are not standardized across codebases, nor provided<br>&gt;    automatically by libraries such as Foundation and {App,UI}Kit.<br>&gt;    - They are sometimes prone to bugs when enum cases are added, but the<br>&gt;    user forgets to update a hard-coded static collection of cases.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#precedent-in-other-languages&gt;Precedent<br>&gt; in other languages<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Rust does not seem to have a solution for this problem.<br>&gt;    -<br>&gt;<br>&gt;    C#&#39;s Enum has several methods<br>&gt;    &lt;https://msdn.microsoft.com/en-us/library/system.enum_methods.aspx&gt; available<br>&gt;    for reflection, including GetValues() and GetNames().<br>&gt;    -<br>&gt;<br>&gt;    Java implicitly declares<br>&gt;    &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt; a<br>&gt;    static values() function, returning an array of enum values, and valueOf(String<br>&gt;    name) which takes a String and returns the enum value with the<br>&gt;    corresponding name (or throws an exception). More examples here<br>&gt;    &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt;<br>&gt;    .<br>&gt;    -<br>&gt;<br>&gt;    The Template Haskell extension to Haskell provides a function reify which<br>&gt;    extracts info about types<br>&gt;    &lt;http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#t:Info&gt;,<br>&gt;    including their constructors.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; Introduce a CaseEnumerable protocol. Conforming to CaseEnumerable will<br>&gt; automagically derive a static var cases, whose type is a CollectionType<br>&gt; of all the enum&#39;s values.<br>&gt;<br>&gt; Like ErrorType, the CaseEnumerable protocol will not have any<br>&gt; user-visible requirements; merely adding the conformance is enough to<br>&gt; enable case enumeration.<br>&gt;<br>&gt; enum Ma { case È©¨, Âêó, Â¶à, Á†Å, È™Ç, üêé, üê¥ }<br>&gt; extension Ma: CaseEnumerable {}<br>&gt;<br>&gt; Ma.cases         // returns some CollectionType whose Generator.Element is Ma<br>&gt; Ma.cases.count   // returns 7Array(Ma.cases)  // returns [Ma.È©¨, .Âêó, .Â¶à, .Á†Å, .È™Ç, .üêé, .üê¥]<br>&gt;<br>&gt; Conformances can even be added for enums which are defined in other<br>&gt; modules:<br>&gt;<br>&gt; extension NSTextAlignment: CaseEnumerable {}<br>&gt; Array(NSTextAlignment.cases)  // returns [NSTextAlignment.Left, .Right, .Center, .Justified, .Natural]<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; Enum cases are enumerated in the order they appear in the source code.<br>&gt;<br>&gt; The cases collection does not necessitate Œ©(number of cases) static<br>&gt; storage. For integer-backed enums, only the range(s) of valid rawValues<br>&gt; need to be stored, and the enum construction can happen dynamically.<br>&gt;<br>&gt; Attempting to derive CaseEnumerable for a non-enum type will result in a<br>&gt; compiler error.<br>&gt;<br>&gt; Attempting to derive CaseEnumerable for an enum with associated values<br>&gt; will result in a compiler error.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#possible-variations&gt;Possible<br>&gt; variations<br>&gt;<br>&gt; I&#39;d like us to discuss these, but they should be folded into either *Proposed<br>&gt; solution* or *Future directions* before the proposal is submitted for<br>&gt; review.<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    For enums with raw values, a static rawValues property (a collection<br>&gt;    of RawValue rather than the enum type itself) could also be<br>&gt;    synthesized.<br>&gt;    -<br>&gt;<br>&gt;    CaseEnumerable could have a user-visible declaration requiring static<br>&gt;    var cases, which would allow users to add conformances for custom non-<br>&gt;    enum types.<br>&gt;    - In this case, adding a conformance for a non-enum type would not be<br>&gt;       a compiler error, it would just require an explicit implementation of static<br>&gt;       var cases, since the compiler wouldn&#39;t synthesize it.<br>&gt;       - This would probably require cases to be AnySequence&lt;Self&gt;, or to<br>&gt;       introduce an AnyCollection, since we aren&#39;t able to say associatedtype<br>&gt;       CaseCollection: CollectionType where CaseCollection.Generator.Element ==<br>&gt;       Self.<br>&gt;    -<br>&gt;<br>&gt;    It would be nice to have a way of supporting this for OptionSetType<br>&gt;    structs. I would recommend that cases for an OptionSetType should<br>&gt;    include only the already-declared static properties (not all possible<br>&gt;    combinations of them). However, I&#39;m not sure it fits into this proposal.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; This proposal only adds functionality, so existing code will not be<br>&gt; affected. (The identifier CaseEnumerable doesn&#39;t make any significant<br>&gt; appearances in Google and GitHub searches.)<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt; The community has not raised any solutions that differ significantly from<br>&gt; this proposal, except for solutions which provide strictly *more* functionality.<br>&gt; These are covered in the next section, *Future directions*.<br>&gt;<br>&gt; An alternative is to *not* implement this feature. The cons of this are<br>&gt; discussed in the *Motivation* section above.<br>&gt;<br>&gt; The functionality could also be provided entirely through the<br>&gt; Mirror/reflection APIs, but this would result in much more obscure and<br>&gt; confusing usage patterns.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#future-directions&gt;Future<br>&gt; directions<br>&gt;<br>&gt; Many people would be happy to see even more functionality than what&#39;s<br>&gt; proposed here. I&#39;m keeping this proposal intentionally limited, but I hope<br>&gt; the community can continue discussing the topic to flesh out more features.<br>&gt;<br>&gt; Here are some starting points, which are *not* part of this proposal:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Support for enum case *names*. It would be useful to get case names<br>&gt;    even for enums which have integer rawValues. This could be part of the<br>&gt;    existing reflection APIs, or it could take the form of derived<br>&gt;    implementations of StringLiteralConvertible/CustomStringConvertible.<br>&gt;    -<br>&gt;<br>&gt;    Support for enums with associated values.<br>&gt;    -<br>&gt;<br>&gt;       When all associated values are themselves CaseEnumerable, this<br>&gt;       could happen automatically:<br>&gt;<br>&gt;       enum Suit: CaseEnumerable { case Spades, Hearts, Diamonds, Clubs }enum Rank: Int, CaseEnumerable {<br>&gt;           case Ace = 1, Two, Three, Four, Five, Six<br>&gt;           case Seven, Eight, Nine, Ten, Jack, Queen, King<br>&gt;       }enum Card {<br>&gt;           case Joker<br>&gt;           case Value(Rank, Suit)<br>&gt;       }<br>&gt;       // This now works, and generates all possible card types (Joker, Value(Ace, Spades), ...)extension Card: CaseEnumerable {}<br>&gt;<br>&gt;       -<br>&gt;<br>&gt;       If associated values aren&#39;t CaseEnumerable, but all cases are<br>&gt;       homogeneous, the cases collection could vend functions of AssociatedValueType<br>&gt;       -&gt; EnumType:<br>&gt;<br>&gt;       enum LogMessage { case Error(String), Warning(String), Info(String) }extension LogMessage: CaseEnumerable {}<br>&gt;<br>&gt;       LogMessage.cases  // elements are (String) -&gt; LogMessage<br>&gt;<br>&gt;       -<br>&gt;<br>&gt;       If Swift had anonymous sum types like A | B | C, then E.cases could<br>&gt;       vend elements of type A-&gt;E | B-&gt;E | C-&gt;E.<br>&gt;<br>&gt;       enum Expr { case Apply(Expr, Expr), Tuple(Expr, Expr), Literal(Int) }extension Value: CaseEnumerable {}<br>&gt;       // This example is pretty contrived, but illustrates the functionality.let fortyTwos = Expr.cases.map {<br>&gt;          // $0 is of type `Int -&gt; Expr | (Expr, Expr) -&gt; Expr`<br>&gt;          switch $0 {<br>&gt;          case let lit as Int -&gt; Expr:  // handles .Literal<br>&gt;              return lit(42)<br>&gt;          case let bin as (Expr, Expr) -&gt; Expr:  // handles .Apply and .Tuple<br>&gt;              return bin(.Literal(42), .Literal(42))<br>&gt;          // all cases are covered<br>&gt;          }<br>&gt;       }<br>&gt;<br>&gt;       -<br>&gt;<br>&gt;    Support for generic enums.<br>&gt;    -<br>&gt;<br>&gt;       CaseEnumerable could be conditionally supported depending on the<br>&gt;       generic argument(s). A great example would be Optional:<br>&gt;<br>&gt;       enum MyEnum: CaseEnumerable {}extension Optional: CaseEnumerable where Wrapped: CaseEnumerable {}<br>&gt;       // Optional&lt;MyEnum&gt;.cases effectively contains `MyEnum.cases + [.None]`<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160117/70ab8a42/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 19, 2016 at 11:00:00am</p></header><div class="content"><p>+1 from me. Minor changes I would suggest are:<br></p><p> 1. All enums implicitly implement `CaseEnumerable`, so that you do not<br>have to remember to add it.<br> 2. That `CaseEnumerable` has exploit static members `cases` and<br>`caseFromName`. So that `CaseEnumerable` can be useful outside of `enum`<br>constructs. In Java the equivalent of `caseFromName` has proved beneficial.<br> 3. That `cases` is a `Set&lt;String&gt;`, i.e. a more specific collection.<br></p><p>On Monday, 18 January 2016, Jacob Bandes-Storch via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi folks,<br>&gt;<br>&gt; I&#39;ve drafted a proposal to add a CaseEnumerable protocol, which will<br>&gt; derive a static variable &quot;cases&quot; for enum types. Feedback is welcome,<br>&gt; especially for refining the proposal before I submit a formal PR.<br>&gt;<br>&gt; The draft is here; full text below.<br>&gt; https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md<br>&gt;<br>&gt;<br>&gt; Derived Collection of Enum Cases<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-derived-collection-of-enum-cases.md&gt;<br>&gt;    - Author(s): Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;<br>&gt;    - Status: *Awaiting review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; It is a truth universally acknowledged, that a programmer in possession of<br>&gt; an enum with many cases, must eventually be in want of dynamic enumeration<br>&gt; over them.<br>&gt;<br>&gt; This topic has come up three times on the swift-evolution mailing list so<br>&gt; far:<br>&gt;<br>&gt;    - List of all Enum values (for simple enums)<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001233.html&gt; (December<br>&gt;    8, 2015)<br>&gt;    - Proposal: Enum &#39;count&#39; functionality<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/003819.html&gt; (December<br>&gt;    21, 2015)<br>&gt;    - Draft Proposal: count property for enum types<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006853.html&gt; (January<br>&gt;    17, 2016)<br>&gt;<br>&gt; Enumerating enumerations in Swift is also a popular topic on Stack<br>&gt; Overflow:<br>&gt;<br>&gt;    - How to enumerate an enum with String type?<br>&gt;    &lt;http://stackoverflow.com/questions/24007461/how-to-enumerate-an-enum-with-string-type&gt; (June<br>&gt;    3, 2014; question score 131)<br>&gt;    - How do I get the count of a Swift enum?<br>&gt;    &lt;http://stackoverflow.com/questions/27094878/how-do-i-get-the-count-of-a-swift-enum&gt; (November<br>&gt;    23, 2014; question score 37)<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Simple enums are finite, and their values are statically known to the<br>&gt; compiler, yet working with them programmatically is challenging. It is<br>&gt; often desirable to iterate over all possible cases of an enum, or to know<br>&gt; the number of cases (or maximum valid rawValue).<br>&gt;<br>&gt; Currently, however, there is no built-in reflection or enumeration<br>&gt; support. Users must resort to manually listing out cases in order to<br>&gt; iterate over them:<br>&gt;<br>&gt; enum Attribute {<br>&gt;     case Date, Name, Author<br>&gt; }func valueForAttribute(attr: Attribute) -&gt; String { ‚Ä¶from elsewhere‚Ä¶ }<br>&gt; // Cases must be listed explicitly:<br>&gt; [Attribute.Date, .Name, .Author].map{ valueForAttribute($0) }.joinWithSeparator(&quot;\n&quot;)<br>&gt;<br>&gt; For RawRepresentable enums, users have often relied on iterating over the<br>&gt; known (or assumed) allowable raw values:<br>&gt;<br>&gt; *Annotated excerpt from Nate Cook&#39;s post, Loopy, Random Ideas for<br>&gt; Extending &quot;enum&quot;<br>&gt; &lt;http://natecook.com/blog/2014/10/loopy-random-enum-ideas/&gt; (October 2014):*<br>&gt;<br>&gt; enum Reindeer: Int {<br>&gt;     case Dasher, Dancer, Prancer, Vixen, Comet, Cupid, Donner, Blitzen, Rudolph<br>&gt; }extension Reindeer {<br>&gt;     static var allCases: [Reindeer] {<br>&gt;         var cur = 0<br>&gt;         return Array(<br>&gt;             GeneratorOf&lt;Reindeer&gt; {<br>&gt;                 return Reindeer(rawValue: cur++)<br>&gt;             }<br>&gt;         )<br>&gt;     }<br>&gt;     static var caseCount: Int {<br>&gt;         var max: Int = 0<br>&gt;         while let _ = self(rawValue: ++max) {}<br>&gt;         return max<br>&gt;     }<br>&gt;     static func randomCase() -&gt; Reindeer {<br>&gt;         // everybody do the Int/UInt32 shuffle!<br>&gt;         let randomValue = Int(arc4random_uniform(UInt32(caseCount)))<br>&gt;         return self(rawValue: randomValue)!<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; There are many problems with these existing techniques:<br>&gt;<br>&gt;    - They are ad-hoc and can&#39;t benefit every enum type without duplicated<br>&gt;    and code.<br>&gt;    - They are not standardized across codebases, nor provided<br>&gt;    automatically by libraries such as Foundation and {App,UI}Kit.<br>&gt;    - They are sometimes prone to bugs when enum cases are added, but the<br>&gt;    user forgets to update a hard-coded static collection of cases.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#precedent-in-other-languages&gt;Precedent<br>&gt; in other languages<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Rust does not seem to have a solution for this problem.<br>&gt;    -<br>&gt;<br>&gt;    C#&#39;s Enum has several methods<br>&gt;    &lt;https://msdn.microsoft.com/en-us/library/system.enum_methods.aspx&gt; available<br>&gt;    for reflection, including GetValues() and GetNames().<br>&gt;    -<br>&gt;<br>&gt;    Java implicitly declares<br>&gt;    &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt; a<br>&gt;    static values() function, returning an array of enum values, and valueOf(String<br>&gt;    name) which takes a String and returns the enum value with the<br>&gt;    corresponding name (or throws an exception). More examples here<br>&gt;    &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt;<br>&gt;    .<br>&gt;    -<br>&gt;<br>&gt;    The Template Haskell extension to Haskell provides a function reify which<br>&gt;    extracts info about types<br>&gt;    &lt;http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#t:Info&gt;,<br>&gt;    including their constructors.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; Introduce a CaseEnumerable protocol. Conforming to CaseEnumerable will<br>&gt; automagically derive a static var cases, whose type is a CollectionType<br>&gt; of all the enum&#39;s values.<br>&gt;<br>&gt; Like ErrorType, the CaseEnumerable protocol will not have any<br>&gt; user-visible requirements; merely adding the conformance is enough to<br>&gt; enable case enumeration.<br>&gt;<br>&gt; enum Ma { case È©¨, Âêó, Â¶à, Á†Å, È™Ç, üêé, üê¥ }<br>&gt; extension Ma: CaseEnumerable {}<br>&gt;<br>&gt; Ma.cases         // returns some CollectionType whose Generator.Element is Ma<br>&gt; Ma.cases.count   // returns 7Array(Ma.cases)  // returns [Ma.È©¨, .Âêó, .Â¶à, .Á†Å, .È™Ç, .üêé, .üê¥]<br>&gt;<br>&gt; Conformances can even be added for enums which are defined in other<br>&gt; modules:<br>&gt;<br>&gt; extension NSTextAlignment: CaseEnumerable {}<br>&gt; Array(NSTextAlignment.cases)  // returns [NSTextAlignment.Left, .Right, .Center, .Justified, .Natural]<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; Enum cases are enumerated in the order they appear in the source code.<br>&gt;<br>&gt; The cases collection does not necessitate Œ©(number of cases) static<br>&gt; storage. For integer-backed enums, only the range(s) of valid rawValues<br>&gt; need to be stored, and the enum construction can happen dynamically.<br>&gt;<br>&gt; Attempting to derive CaseEnumerable for a non-enum type will result in a<br>&gt; compiler error.<br>&gt;<br>&gt; Attempting to derive CaseEnumerable for an enum with associated values<br>&gt; will result in a compiler error.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#possible-variations&gt;Possible<br>&gt; variations<br>&gt;<br>&gt; I&#39;d like us to discuss these, but they should be folded into either *Proposed<br>&gt; solution* or *Future directions* before the proposal is submitted for<br>&gt; review.<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    For enums with raw values, a static rawValues property (a collection<br>&gt;    of RawValue rather than the enum type itself) could also be<br>&gt;    synthesized.<br>&gt;    -<br>&gt;<br>&gt;    CaseEnumerable could have a user-visible declaration requiring static<br>&gt;    var cases, which would allow users to add conformances for custom non-<br>&gt;    enum types.<br>&gt;    - In this case, adding a conformance for a non-enum type would not be<br>&gt;       a compiler error, it would just require an explicit implementation of static<br>&gt;       var cases, since the compiler wouldn&#39;t synthesize it.<br>&gt;       - This would probably require cases to be AnySequence&lt;Self&gt;, or to<br>&gt;       introduce an AnyCollection, since we aren&#39;t able to say associatedtype<br>&gt;       CaseCollection: CollectionType where CaseCollection.Generator.Element ==<br>&gt;       Self.<br>&gt;    -<br>&gt;<br>&gt;    It would be nice to have a way of supporting this for OptionSetType<br>&gt;    structs. I would recommend that cases for an OptionSetType should<br>&gt;    include only the already-declared static properties (not all possible<br>&gt;    combinations of them). However, I&#39;m not sure it fits into this proposal.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; This proposal only adds functionality, so existing code will not be<br>&gt; affected. (The identifier CaseEnumerable doesn&#39;t make any significant<br>&gt; appearances in Google and GitHub searches.)<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt; The community has not raised any solutions that differ significantly from<br>&gt; this proposal, except for solutions which provide strictly *more* functionality.<br>&gt; These are covered in the next section, *Future directions*.<br>&gt;<br>&gt; An alternative is to *not* implement this feature. The cons of this are<br>&gt; discussed in the *Motivation* section above.<br>&gt;<br>&gt; The functionality could also be provided entirely through the<br>&gt; Mirror/reflection APIs, but this would result in much more obscure and<br>&gt; confusing usage patterns.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#future-directions&gt;Future<br>&gt; directions<br>&gt;<br>&gt; Many people would be happy to see even more functionality than what&#39;s<br>&gt; proposed here. I&#39;m keeping this proposal intentionally limited, but I hope<br>&gt; the community can continue discussing the topic to flesh out more features.<br>&gt;<br>&gt; Here are some starting points, which are *not* part of this proposal:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Support for enum case *names*. It would be useful to get case names<br>&gt;    even for enums which have integer rawValues. This could be part of the<br>&gt;    existing reflection APIs, or it could take the form of derived<br>&gt;    implementations of StringLiteralConvertible/CustomStringConvertible.<br>&gt;    -<br>&gt;<br>&gt;    Support for enums with associated values.<br>&gt;    -<br>&gt;<br>&gt;       When all associated values are themselves CaseEnumerable, this<br>&gt;       could happen automatically:<br>&gt;<br>&gt;       enum Suit: CaseEnumerable { case Spades, Hearts, Diamonds, Clubs }enum Rank: Int, CaseEnumerable {<br>&gt;           case Ace = 1, Two, Three, Four, Five, Six<br>&gt;           case Seven, Eight, Nine, Ten, Jack, Queen, King<br>&gt;       }enum Card {<br>&gt;           case Joker<br>&gt;           case Value(Rank, Suit)<br>&gt;       }<br>&gt;       // This now works, and generates all possible card types (Joker, Value(Ace, Spades), ...)extension Card: CaseEnumerable {}<br>&gt;<br>&gt;       -<br>&gt;<br>&gt;       If associated values aren&#39;t CaseEnumerable, but all cases are<br>&gt;       homogeneous, the cases collection could vend functions of AssociatedValueType<br>&gt;       -&gt; EnumType:<br>&gt;<br>&gt;       enum LogMessage { case Error(String), Warning(String), Info(String) }extension LogMessage: CaseEnumerable {}<br>&gt;<br>&gt;       LogMessage.cases  // elements are (String) -&gt; LogMessage<br>&gt;<br>&gt;       -<br>&gt;<br>&gt;       If Swift had anonymous sum types like A | B | C, then E.cases could<br>&gt;       vend elements of type A-&gt;E | B-&gt;E | C-&gt;E.<br>&gt;<br>&gt;       enum Expr { case Apply(Expr, Expr), Tuple(Expr, Expr), Literal(Int) }extension Value: CaseEnumerable {}<br>&gt;       // This example is pretty contrived, but illustrates the functionality.let fortyTwos = Expr.cases.map {<br>&gt;          // $0 is of type `Int -&gt; Expr | (Expr, Expr) -&gt; Expr`<br>&gt;          switch $0 {<br>&gt;          case let lit as Int -&gt; Expr:  // handles .Literal<br>&gt;              return lit(42)<br>&gt;          case let bin as (Expr, Expr) -&gt; Expr:  // handles .Apply and .Tuple<br>&gt;              return bin(.Literal(42), .Literal(42))<br>&gt;          // all cases are covered<br>&gt;          }<br>&gt;       }<br>&gt;<br>&gt;       -<br>&gt;<br>&gt;    Support for generic enums.<br>&gt;    -<br>&gt;<br>&gt;       CaseEnumerable could be conditionally supported depending on the<br>&gt;       generic argument(s). A great example would be Optional:<br>&gt;<br>&gt;       enum MyEnum: CaseEnumerable {}extension Optional: CaseEnumerable where Wrapped: CaseEnumerable {}<br>&gt;       // Optional&lt;MyEnum&gt;.cases effectively contains `MyEnum.cases + [.None]`<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/9fd37b48/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5c9df42e3c293e3cdb5f3e1b34d44ef9?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Step C</string> &lt;schristopher at bignerdranch.com&gt;<p>January 18, 2016 at 11:00:00pm</p></header><div class="content"><p>Happy to see this proposal. Comments inline.<br></p><p>&gt; On Jan 18, 2016, at 7:21 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 from me. Minor changes I would suggest are:<br>&gt; <br>&gt;  1. All enums implicitly implement `CaseEnumerable`, so that you do not have to remember to add it.<br></p><p>I think explicit is better, particularly since this could have resilience implications. Changing the order of cases (or properties) can break your API, which is not true for plain enums currently. Though this means extensions that add conformance could still be fragile. Another option would be to require all cases to explicitly be listed again, but with compiler support to make sure the list is complete. That may be too verbose though. <br></p><p>&gt;  2. That `CaseEnumerable` has exploit static members `cases` and `caseFromName`. So that `CaseEnumerable` can be useful outside of `enum` constructs. In Java the equivalent of `caseFromName` has proved beneficial. <br></p><p>`caseFromName` takes a String?<br>&gt;  3. That `cases` is a `Set&lt;String&gt;`, i.e. a more specific collection.<br>&gt; <br>&gt;&gt; On Monday, 18 January 2016, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hi folks,<br>&gt;&gt; <br>&gt;&gt; I&#39;ve drafted a proposal to add a CaseEnumerable protocol, which will derive a static variable &quot;cases&quot; for enum types. Feedback is welcome, especially for refining the proposal before I submit a formal PR.<br>&gt;&gt; <br>&gt;&gt; The draft is here; full text below. https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Derived Collection of Enum Cases<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/0dbc66b3/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 18, 2016 at 07:00:00pm</p></header><div class="content"><p>The functionality proposed is reasonable, but I&#39;d suggest more generic, less enum-centric names, since this is reasonable functionality for any finite type to provide.<br></p><p>-Joe<br></p><p>&gt; On Jan 17, 2016, at 3:44 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi folks,<br>&gt; <br>&gt; I&#39;ve drafted a proposal to add a CaseEnumerable protocol, which will derive a static variable &quot;cases&quot; for enum types. Feedback is welcome, especially for refining the proposal before I submit a formal PR.<br>&gt; <br>&gt; The draft is here; full text below. https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md&gt;<br>&gt; <br>&gt; <br>&gt; Derived Collection of Enum Cases<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-derived-collection-of-enum-cases.md&gt;<br>&gt; Author(s): Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#introduction&gt;Introduction<br>&gt; <br>&gt; It is a truth universally acknowledged, that a programmer in possession of an enum with many cases, must eventually be in want of dynamic enumeration over them.<br>&gt; <br>&gt; This topic has come up three times on the swift-evolution mailing list so far:<br>&gt; <br>&gt; List of all Enum values (for simple enums) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001233.html&gt; (December 8, 2015)<br>&gt; Proposal: Enum &#39;count&#39; functionality &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/003819.html&gt; (December 21, 2015)<br>&gt; Draft Proposal: count property for enum types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006853.html&gt; (January 17, 2016)<br>&gt; Enumerating enumerations in Swift is also a popular topic on Stack Overflow:<br>&gt; <br>&gt; How to enumerate an enum with String type? &lt;http://stackoverflow.com/questions/24007461/how-to-enumerate-an-enum-with-string-type&gt; (June 3, 2014; question score 131)<br>&gt; How do I get the count of a Swift enum? &lt;http://stackoverflow.com/questions/27094878/how-do-i-get-the-count-of-a-swift-enum&gt; (November 23, 2014; question score 37)<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#motivation&gt;Motivation<br>&gt; <br>&gt; Simple enums are finite, and their values are statically known to the compiler, yet working with them programmatically is challenging. It is often desirable to iterate over all possible cases of an enum, or to know the number of cases (or maximum valid rawValue).<br>&gt; <br>&gt; Currently, however, there is no built-in reflection or enumeration support. Users must resort to manually listing out cases in order to iterate over them:<br>&gt; <br>&gt; enum Attribute {<br>&gt;     case Date, Name, Author<br>&gt; }<br>&gt; func valueForAttribute(attr: Attribute) -&gt; String { ‚Ä¶from elsewhere‚Ä¶ }<br>&gt; <br>&gt; // Cases must be listed explicitly:<br>&gt; [Attribute.Date, .Name, .Author].map{ valueForAttribute($0) }.joinWithSeparator(&quot;\n&quot;)<br>&gt; For RawRepresentable enums, users have often relied on iterating over the known (or assumed) allowable raw values:<br>&gt; <br>&gt; Annotated excerpt from Nate Cook&#39;s post, Loopy, Random Ideas for Extending &quot;enum&quot; &lt;http://natecook.com/blog/2014/10/loopy-random-enum-ideas/&gt; (October 2014):<br>&gt; <br>&gt; enum Reindeer: Int {<br>&gt;     case Dasher, Dancer, Prancer, Vixen, Comet, Cupid, Donner, Blitzen, Rudolph  <br>&gt; }<br>&gt; extension Reindeer {<br>&gt;     static var allCases: [Reindeer] {<br>&gt;         var cur = 0<br>&gt;         return Array(<br>&gt;             GeneratorOf&lt;Reindeer&gt; {<br>&gt;                 return Reindeer(rawValue: cur++)<br>&gt;             }<br>&gt;         )<br>&gt;     }<br>&gt;     static var caseCount: Int {<br>&gt;         var max: Int = 0<br>&gt;         while let _ = self(rawValue: ++max) {}<br>&gt;         return max<br>&gt;     }<br>&gt;     static func randomCase() -&gt; Reindeer {<br>&gt;         // everybody do the Int/UInt32 shuffle!<br>&gt;         let randomValue = Int(arc4random_uniform(UInt32(caseCount)))<br>&gt;         return self(rawValue: randomValue)!<br>&gt;     }<br>&gt; }<br>&gt; There are many problems with these existing techniques:<br>&gt; <br>&gt; They are ad-hoc and can&#39;t benefit every enum type without duplicated and code.<br>&gt; They are not standardized across codebases, nor provided automatically by libraries such as Foundation and {App,UI}Kit.<br>&gt; They are sometimes prone to bugs when enum cases are added, but the user forgets to update a hard-coded static collection of cases.<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#precedent-in-other-languages&gt;Precedent in other languages<br>&gt; <br>&gt; Rust does not seem to have a solution for this problem.<br>&gt; <br>&gt; C#&#39;s Enum has several methods &lt;https://msdn.microsoft.com/en-us/library/system.enum_methods.aspx&gt; available for reflection, including GetValues() and GetNames().<br>&gt; <br>&gt; Java implicitly declares &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt; a static values() function, returning an array of enum values, and valueOf(String name) which takes a String and returns the enum value with the corresponding name (or throws an exception). More examples here &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt;.<br>&gt; <br>&gt; The Template Haskell extension to Haskell provides a function reify which extracts info about types &lt;http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#t:Info&gt;, including their constructors.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; Introduce a CaseEnumerable protocol. Conforming to CaseEnumerable will automagically derive a static var cases, whose type is a CollectionType of all the enum&#39;s values.<br>&gt; <br>&gt; Like ErrorType, the CaseEnumerable protocol will not have any user-visible requirements; merely adding the conformance is enough to enable case enumeration.<br>&gt; <br>&gt; enum Ma { case È©¨, Âêó, Â¶à, Á†Å, È™Ç, üêé, üê¥ }<br>&gt; <br>&gt; extension Ma: CaseEnumerable {}<br>&gt; <br>&gt; Ma.cases         // returns some CollectionType whose Generator.Element is Ma<br>&gt; Ma.cases.count   // returns 7<br>&gt; Array(Ma.cases)  // returns [Ma.È©¨, .Âêó, .Â¶à, .Á†Å, .È™Ç, .üêé, .üê¥]<br>&gt; Conformances can even be added for enums which are defined in other modules:<br>&gt; <br>&gt; extension NSTextAlignment: CaseEnumerable {}<br>&gt; <br>&gt; Array(NSTextAlignment.cases)  // returns [NSTextAlignment.Left, .Right, .Center, .Justified, .Natural]<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; Enum cases are enumerated in the order they appear in the source code.<br>&gt; <br>&gt; The cases collection does not necessitate Œ©(number of cases) static storage. For integer-backed enums, only the range(s) of valid rawValues need to be stored, and the enum construction can happen dynamically.<br>&gt; <br>&gt; Attempting to derive CaseEnumerable for a non-enum type will result in a compiler error.<br>&gt; <br>&gt; Attempting to derive CaseEnumerable for an enum with associated values will result in a compiler error.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#possible-variations&gt;Possible variations<br>&gt; <br>&gt; I&#39;d like us to discuss these, but they should be folded into either Proposed solution or Future directions before the proposal is submitted for review.<br>&gt; <br>&gt; For enums with raw values, a static rawValues property (a collection of RawValue rather than the enum type itself) could also be synthesized.<br>&gt; <br>&gt; CaseEnumerable could have a user-visible declaration requiring static var cases, which would allow users to add conformances for custom non-enum types.<br>&gt; <br>&gt; In this case, adding a conformance for a non-enum type would not be a compiler error, it would just require an explicit implementation of static var cases, since the compiler wouldn&#39;t synthesize it.<br>&gt; This would probably require cases to be AnySequence&lt;Self&gt;, or to introduce an AnyCollection, since we aren&#39;t able to say associatedtype CaseCollection: CollectionType where CaseCollection.Generator.Element == Self.<br>&gt; It would be nice to have a way of supporting this for OptionSetType structs. I would recommend that cases for an OptionSetType should include only the already-declared static properties (not all possible combinations of them). However, I&#39;m not sure it fits into this proposal.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This proposal only adds functionality, so existing code will not be affected. (The identifier CaseEnumerable doesn&#39;t make any significant appearances in Google and GitHub searches.)<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; The community has not raised any solutions that differ significantly from this proposal, except for solutions which provide strictly more functionality. These are covered in the next section, Future directions.<br>&gt; <br>&gt; An alternative is to not implement this feature. The cons of this are discussed in the Motivation section above.<br>&gt; <br>&gt; The functionality could also be provided entirely through the Mirror/reflection APIs, but this would result in much more obscure and confusing usage patterns.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#future-directions&gt;Future directions<br>&gt; <br>&gt; Many people would be happy to see even more functionality than what&#39;s proposed here. I&#39;m keeping this proposal intentionally limited, but I hope the community can continue discussing the topic to flesh out more features.<br>&gt; <br>&gt; Here are some starting points, which are not part of this proposal:<br>&gt; <br>&gt; Support for enum case names. It would be useful to get case names even for enums which have integer rawValues. This could be part of the existing reflection APIs, or it could take the form of derived implementations of StringLiteralConvertible/CustomStringConvertible.<br>&gt; <br>&gt; Support for enums with associated values.<br>&gt; <br>&gt; When all associated values are themselves CaseEnumerable, this could happen automatically:<br>&gt; <br>&gt; enum Suit: CaseEnumerable { case Spades, Hearts, Diamonds, Clubs }<br>&gt; enum Rank: Int, CaseEnumerable {<br>&gt;     case Ace = 1, Two, Three, Four, Five, Six<br>&gt;     case Seven, Eight, Nine, Ten, Jack, Queen, King<br>&gt; }<br>&gt; enum Card {<br>&gt;     case Joker<br>&gt;     case Value(Rank, Suit)<br>&gt; }<br>&gt; <br>&gt; // This now works, and generates all possible card types (Joker, Value(Ace, Spades), ...)<br>&gt; extension Card: CaseEnumerable {}<br>&gt; If associated values aren&#39;t CaseEnumerable, but all cases are homogeneous, the cases collection could vend functions of AssociatedValueType -&gt; EnumType:<br>&gt; <br>&gt; enum LogMessage { case Error(String), Warning(String), Info(String) }<br>&gt; extension LogMessage: CaseEnumerable {}<br>&gt; <br>&gt; LogMessage.cases  // elements are (String) -&gt; LogMessage<br>&gt; If Swift had anonymous sum types like A | B | C, then E.cases could vend elements of type A-&gt;E | B-&gt;E | C-&gt;E.<br>&gt; <br>&gt; enum Expr { case Apply(Expr, Expr), Tuple(Expr, Expr), Literal(Int) }<br>&gt; extension Value: CaseEnumerable {}<br>&gt; <br>&gt; // This example is pretty contrived, but illustrates the functionality.<br>&gt; let fortyTwos = Expr.cases.map {<br>&gt;    // $0 is of type `Int -&gt; Expr | (Expr, Expr) -&gt; Expr`<br>&gt;    switch $0 {<br>&gt;    case let lit as Int -&gt; Expr:  // handles .Literal<br>&gt;        return lit(42)<br>&gt;    case let bin as (Expr, Expr) -&gt; Expr:  // handles .Apply and .Tuple<br>&gt;        return bin(.Literal(42), .Literal(42))<br>&gt;    // all cases are covered<br>&gt;    }<br>&gt; }<br>&gt; Support for generic enums.<br>&gt; <br>&gt; CaseEnumerable could be conditionally supported depending on the generic argument(s). A great example would be Optional:<br>&gt; <br>&gt; enum MyEnum: CaseEnumerable {}<br>&gt; extension Optional: CaseEnumerable where Wrapped: CaseEnumerable {}<br>&gt; <br>&gt; // Optional&lt;MyEnum&gt;.cases effectively contains `MyEnum.cases + [.None]`<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/919b1f42/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5af07e950f10c7c1df1c44bed055c1eb?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Daniel Steinberg</string> &lt;daniel at dimsumthinking.com&gt;<p>January 19, 2016 at 09:00:00am</p></header><div class="content"><p>+1 to the proposal and this comment.<br></p><p><br></p><p><br>&gt; On Jan 18, 2016, at 10:46 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The functionality proposed is reasonable, but I&#39;d suggest more generic, less enum-centric names, since this is reasonable functionality for any finite type to provide.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Jan 17, 2016, at 3:44 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi folks,<br>&gt;&gt; <br>&gt;&gt; I&#39;ve drafted a proposal to add a CaseEnumerable protocol, which will derive a static variable &quot;cases&quot; for enum types. Feedback is welcome, especially for refining the proposal before I submit a formal PR.<br>&gt;&gt; <br>&gt;&gt; The draft is here; full text below. https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Derived Collection of Enum Cases<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-derived-collection-of-enum-cases.md&gt;<br>&gt;&gt; Author(s): Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; It is a truth universally acknowledged, that a programmer in possession of an enum with many cases, must eventually be in want of dynamic enumeration over them.<br>&gt;&gt; <br>&gt;&gt; This topic has come up three times on the swift-evolution mailing list so far:<br>&gt;&gt; <br>&gt;&gt; List of all Enum values (for simple enums) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001233.html&gt; (December 8, 2015)<br>&gt;&gt; Proposal: Enum &#39;count&#39; functionality &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/003819.html&gt; (December 21, 2015)<br>&gt;&gt; Draft Proposal: count property for enum types &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006853.html&gt; (January 17, 2016)<br>&gt;&gt; Enumerating enumerations in Swift is also a popular topic on Stack Overflow:<br>&gt;&gt; <br>&gt;&gt; How to enumerate an enum with String type? &lt;http://stackoverflow.com/questions/24007461/how-to-enumerate-an-enum-with-string-type&gt; (June 3, 2014; question score 131)<br>&gt;&gt; How do I get the count of a Swift enum? &lt;http://stackoverflow.com/questions/27094878/how-do-i-get-the-count-of-a-swift-enum&gt; (November 23, 2014; question score 37)<br>&gt;&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; Simple enums are finite, and their values are statically known to the compiler, yet working with them programmatically is challenging. It is often desirable to iterate over all possible cases of an enum, or to know the number of cases (or maximum valid rawValue).<br>&gt;&gt; <br>&gt;&gt; Currently, however, there is no built-in reflection or enumeration support. Users must resort to manually listing out cases in order to iterate over them:<br>&gt;&gt; <br>&gt;&gt; enum Attribute {<br>&gt;&gt;     case Date, Name, Author<br>&gt;&gt; }<br>&gt;&gt; func valueForAttribute(attr: Attribute) -&gt; String { ‚Ä¶from elsewhere‚Ä¶ }<br>&gt;&gt; <br>&gt;&gt; // Cases must be listed explicitly:<br>&gt;&gt; [Attribute.Date, .Name, .Author].map{ valueForAttribute($0) }.joinWithSeparator(&quot;\n&quot;)<br>&gt;&gt; For RawRepresentable enums, users have often relied on iterating over the known (or assumed) allowable raw values:<br>&gt;&gt; <br>&gt;&gt; Annotated excerpt from Nate Cook&#39;s post, Loopy, Random Ideas for Extending &quot;enum&quot; &lt;http://natecook.com/blog/2014/10/loopy-random-enum-ideas/&gt; (October 2014):<br>&gt;&gt; <br>&gt;&gt; enum Reindeer: Int {<br>&gt;&gt;     case Dasher, Dancer, Prancer, Vixen, Comet, Cupid, Donner, Blitzen, Rudolph  <br>&gt;&gt; }<br>&gt;&gt; extension Reindeer {<br>&gt;&gt;     static var allCases: [Reindeer] {<br>&gt;&gt;         var cur = 0<br>&gt;&gt;         return Array(<br>&gt;&gt;             GeneratorOf&lt;Reindeer&gt; {<br>&gt;&gt;                 return Reindeer(rawValue: cur++)<br>&gt;&gt;             }<br>&gt;&gt;         )<br>&gt;&gt;     }<br>&gt;&gt;     static var caseCount: Int {<br>&gt;&gt;         var max: Int = 0<br>&gt;&gt;         while let _ = self(rawValue: ++max) {}<br>&gt;&gt;         return max<br>&gt;&gt;     }<br>&gt;&gt;     static func randomCase() -&gt; Reindeer {<br>&gt;&gt;         // everybody do the Int/UInt32 shuffle!<br>&gt;&gt;         let randomValue = Int(arc4random_uniform(UInt32(caseCount)))<br>&gt;&gt;         return self(rawValue: randomValue)!<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; There are many problems with these existing techniques:<br>&gt;&gt; <br>&gt;&gt; They are ad-hoc and can&#39;t benefit every enum type without duplicated and code.<br>&gt;&gt; They are not standardized across codebases, nor provided automatically by libraries such as Foundation and {App,UI}Kit.<br>&gt;&gt; They are sometimes prone to bugs when enum cases are added, but the user forgets to update a hard-coded static collection of cases.<br>&gt;&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#precedent-in-other-languages&gt;Precedent in other languages<br>&gt;&gt; <br>&gt;&gt; Rust does not seem to have a solution for this problem.<br>&gt;&gt; <br>&gt;&gt; C#&#39;s Enum has several methods &lt;https://msdn.microsoft.com/en-us/library/system.enum_methods.aspx&gt; available for reflection, including GetValues() and GetNames().<br>&gt;&gt; <br>&gt;&gt; Java implicitly declares &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt; a static values() function, returning an array of enum values, and valueOf(String name) which takes a String and returns the enum value with the corresponding name (or throws an exception). More examples here &lt;http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9.3&gt;.<br>&gt;&gt; <br>&gt;&gt; The Template Haskell extension to Haskell provides a function reify which extracts info about types &lt;http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#t:Info&gt;, including their constructors.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; Introduce a CaseEnumerable protocol. Conforming to CaseEnumerable will automagically derive a static var cases, whose type is a CollectionType of all the enum&#39;s values.<br>&gt;&gt; <br>&gt;&gt; Like ErrorType, the CaseEnumerable protocol will not have any user-visible requirements; merely adding the conformance is enough to enable case enumeration.<br>&gt;&gt; <br>&gt;&gt; enum Ma { case È©¨, Âêó, Â¶à, Á†Å, È™Ç, üêé, üê¥ }<br>&gt;&gt; <br>&gt;&gt; extension Ma: CaseEnumerable {}<br>&gt;&gt; <br>&gt;&gt; Ma.cases         // returns some CollectionType whose Generator.Element is Ma<br>&gt;&gt; Ma.cases.count   // returns 7<br>&gt;&gt; Array(Ma.cases)  // returns [Ma.È©¨, .Âêó, .Â¶à, .Á†Å, .È™Ç, .üêé, .üê¥]<br>&gt;&gt; Conformances can even be added for enums which are defined in other modules:<br>&gt;&gt; <br>&gt;&gt; extension NSTextAlignment: CaseEnumerable {}<br>&gt;&gt; <br>&gt;&gt; Array(NSTextAlignment.cases)  // returns [NSTextAlignment.Left, .Right, .Center, .Justified, .Natural]<br>&gt;&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; Enum cases are enumerated in the order they appear in the source code.<br>&gt;&gt; <br>&gt;&gt; The cases collection does not necessitate Œ©(number of cases) static storage. For integer-backed enums, only the range(s) of valid rawValues need to be stored, and the enum construction can happen dynamically.<br>&gt;&gt; <br>&gt;&gt; Attempting to derive CaseEnumerable for a non-enum type will result in a compiler error.<br>&gt;&gt; <br>&gt;&gt; Attempting to derive CaseEnumerable for an enum with associated values will result in a compiler error.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#possible-variations&gt;Possible variations<br>&gt;&gt; <br>&gt;&gt; I&#39;d like us to discuss these, but they should be folded into either Proposed solution or Future directions before the proposal is submitted for review.<br>&gt;&gt; <br>&gt;&gt; For enums with raw values, a static rawValues property (a collection of RawValue rather than the enum type itself) could also be synthesized.<br>&gt;&gt; <br>&gt;&gt; CaseEnumerable could have a user-visible declaration requiring static var cases, which would allow users to add conformances for custom non-enum types.<br>&gt;&gt; <br>&gt;&gt; In this case, adding a conformance for a non-enum type would not be a compiler error, it would just require an explicit implementation of static var cases, since the compiler wouldn&#39;t synthesize it.<br>&gt;&gt; This would probably require cases to be AnySequence&lt;Self&gt;, or to introduce an AnyCollection, since we aren&#39;t able to say associatedtype CaseCollection: CollectionType where CaseCollection.Generator.Element == Self.<br>&gt;&gt; It would be nice to have a way of supporting this for OptionSetType structs. I would recommend that cases for an OptionSetType should include only the already-declared static properties (not all possible combinations of them). However, I&#39;m not sure it fits into this proposal.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This proposal only adds functionality, so existing code will not be affected. (The identifier CaseEnumerable doesn&#39;t make any significant appearances in Google and GitHub searches.)<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The community has not raised any solutions that differ significantly from this proposal, except for solutions which provide strictly more functionality. These are covered in the next section, Future directions.<br>&gt;&gt; <br>&gt;&gt; An alternative is to not implement this feature. The cons of this are discussed in the Motivation section above.<br>&gt;&gt; <br>&gt;&gt; The functionality could also be provided entirely through the Mirror/reflection APIs, but this would result in much more obscure and confusing usage patterns.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md#future-directions&gt;Future directions<br>&gt;&gt; <br>&gt;&gt; Many people would be happy to see even more functionality than what&#39;s proposed here. I&#39;m keeping this proposal intentionally limited, but I hope the community can continue discussing the topic to flesh out more features.<br>&gt;&gt; <br>&gt;&gt; Here are some starting points, which are not part of this proposal:<br>&gt;&gt; <br>&gt;&gt; Support for enum case names. It would be useful to get case names even for enums which have integer rawValues. This could be part of the existing reflection APIs, or it could take the form of derived implementations of StringLiteralConvertible/CustomStringConvertible.<br>&gt;&gt; <br>&gt;&gt; Support for enums with associated values.<br>&gt;&gt; <br>&gt;&gt; When all associated values are themselves CaseEnumerable, this could happen automatically:<br>&gt;&gt; <br>&gt;&gt; enum Suit: CaseEnumerable { case Spades, Hearts, Diamonds, Clubs }<br>&gt;&gt; enum Rank: Int, CaseEnumerable {<br>&gt;&gt;     case Ace = 1, Two, Three, Four, Five, Six<br>&gt;&gt;     case Seven, Eight, Nine, Ten, Jack, Queen, King<br>&gt;&gt; }<br>&gt;&gt; enum Card {<br>&gt;&gt;     case Joker<br>&gt;&gt;     case Value(Rank, Suit)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // This now works, and generates all possible card types (Joker, Value(Ace, Spades), ...)<br>&gt;&gt; extension Card: CaseEnumerable {}<br>&gt;&gt; If associated values aren&#39;t CaseEnumerable, but all cases are homogeneous, the cases collection could vend functions of AssociatedValueType -&gt; EnumType:<br>&gt;&gt; <br>&gt;&gt; enum LogMessage { case Error(String), Warning(String), Info(String) }<br>&gt;&gt; extension LogMessage: CaseEnumerable {}<br>&gt;&gt; <br>&gt;&gt; LogMessage.cases  // elements are (String) -&gt; LogMessage<br>&gt;&gt; If Swift had anonymous sum types like A | B | C, then E.cases could vend elements of type A-&gt;E | B-&gt;E | C-&gt;E.<br>&gt;&gt; <br>&gt;&gt; enum Expr { case Apply(Expr, Expr), Tuple(Expr, Expr), Literal(Int) }<br>&gt;&gt; extension Value: CaseEnumerable {}<br>&gt;&gt; <br>&gt;&gt; // This example is pretty contrived, but illustrates the functionality.<br>&gt;&gt; let fortyTwos = Expr.cases.map {<br>&gt;&gt;    // $0 is of type `Int -&gt; Expr | (Expr, Expr) -&gt; Expr`<br>&gt;&gt;    switch $0 {<br>&gt;&gt;    case let lit as Int -&gt; Expr:  // handles .Literal<br>&gt;&gt;        return lit(42)<br>&gt;&gt;    case let bin as (Expr, Expr) -&gt; Expr:  // handles .Apply and .Tuple<br>&gt;&gt;        return bin(.Literal(42), .Literal(42))<br>&gt;&gt;    // all cases are covered<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; Support for generic enums.<br>&gt;&gt; <br>&gt;&gt; CaseEnumerable could be conditionally supported depending on the generic argument(s). A great example would be Optional:<br>&gt;&gt; <br>&gt;&gt; enum MyEnum: CaseEnumerable {}<br>&gt;&gt; extension Optional: CaseEnumerable where Wrapped: CaseEnumerable {}<br>&gt;&gt; <br>&gt;&gt; // Optional&lt;MyEnum&gt;.cases effectively contains `MyEnum.cases + [.None]`<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/f7991c7a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 18, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; I&#39;ve drafted a proposal to add a CaseEnumerable protocol, which will derive a static variable &quot;cases&quot; for enum types. Feedback is welcome, especially for refining the proposal before I submit a formal PR.<br></p><p>Thank you Jacob‚Äîthis is a wonderful starting point. A few thoughts:<br></p><p>&gt; It is a truth universally acknowledged, that a programmer in possession of an enum with many cases, must eventually be in want of dynamic enumeration over them.<br></p><p>Just wanted to note this really started the proposal off with some panache!<br></p><p>&gt; Introduce a CaseEnumerable protocol. Conforming to CaseEnumerable will automagically derive a static var cases, whose type is a CollectionType of all the enum&#39;s values.<br>&gt; <br>&gt; Like ErrorType, the CaseEnumerable protocol will not have any user-visible requirements; merely adding the conformance is enough to enable case enumeration.<br></p><p>I discuss these below.<br></p><p>&gt; Conformances can even be added for enums which are defined in other modules:<br>&gt; <br>&gt; extension NSTextAlignment: CaseEnumerable {}<br>&gt; <br>&gt; Array(NSTextAlignment.cases)  // returns [NSTextAlignment.Left, .Right, .Center, .Justified, .Natural]<br></p><p>That&#39;s a pretty cool use case!<br></p><p>&gt; Attempting to derive CaseEnumerable for a non-enum type will result in a compiler error.<br>&gt; <br>&gt; Attempting to derive CaseEnumerable for an enum with associated values will result in a compiler error.<br></p><p>Again, see below.<br></p><p>&gt; 	‚Ä¢ For enums with raw values, a static rawValues property (a collection of RawValue rather than the enum type itself) could also be synthesized.<br></p><p>I don&#39;t think this is really necessary; it&#39;s exactly equivalent to `cases.map { $0.rawValue }`. (And I think if you&#39;re only going to have one, `cases` is definitely more important than `rawValues`.)<br></p><p>&gt; 	‚Ä¢ CaseEnumerable could have a user-visible declaration requiring static var cases, which would allow users to add conformances for custom non-enum types.<br></p><p>I think this is an excellent idea. As Joe points out, this would imply that the protocol and property should have names which don&#39;t include the word &quot;case&quot;. (Renaming is also a good idea because if the property is `cases`, you&#39;ll be tempted to say `for case in Foo.cases`, but `for case` will be misparsed.)<br></p><p>Simply start the discussion, I suggest this definition:<br></p><p>	/// Any type which can only take on one of a limited, easily enumerable list of values may <br>	/// conform to FiniteType to make that list easy to access. For certain simple types,<br>	/// Swift will automatically generate an implementation of `values`.<br>	protocol FiniteType {<br>		/// A collection containing all possible values of this type.<br>		/// <br>		/// Invariant: T.values.contains(valueOfTypeT) for any valueOfTypeT. In other words, `values` <br>		/// must be truly exhaustive.<br>		static var values: ...<br>	}<br></p><p>&gt; 		‚Ä¢ This would probably require cases to be AnySequence&lt;Self&gt;, or to introduce an AnyCollection, since we aren&#39;t able to say associatedtype CaseCollection: CollectionType where CaseCollection.Generator.Element == Self.<br></p><p>Ouch, that&#39;s an ugly limitation. Is this going to change in Swift 3?<br></p><p>&gt; 	‚Ä¢ It would be nice to have a way of supporting this for OptionSetType structs. I would recommend that cases for an OptionSetType should include only the already-declared static properties (not all possible combinations of them). However, I&#39;m not sure it fits into this proposal.<br></p><p>Theoretically, `cases` on an OptionSetType should return all combinations of options, so I think we&#39;d need something different there.<br></p><p>&gt; 	‚Ä¢ Support for enum case names. It would be useful to get case names even for enums which have integer rawValues. This could be part of the existing reflection APIs, or it could take the form of derived implementations of StringLiteralConvertible/CustomStringConvertible.<br></p><p>I very strongly believe this is a job for reflection, not for our case mechanism. (So, I agree with you.)<br></p><p>&gt; 		‚Ä¢ When all associated values are themselves CaseEnumerable, this could happen automatically:<br></p><p>Since I think I was the first to suggest this, of course I think it should be included, but I agree it can wait. If `CaseEnumerable` becomes an ordinary protocol which sometimes has an automatically-generated implementation, this basically just becomes a more sophisticated auto-generator that can be used in additional situations.<br></p><p>&gt; 		‚Ä¢ If Swift had anonymous sum types like A | B | C, then E.cases could vend elements of type A-&gt;E | B-&gt;E | C-&gt;E.<br></p><p>This would be a nice feature at some point, but I think it ought to go by a different name.<br></p><p>&gt; 		‚Ä¢ CaseEnumerable could be conditionally supported depending on the generic argument(s). A great example would be Optional:<br></p><p>This is basically just the conditional conformance feature which I *believe* is already planned, plus the enumerable-associated-values feature. I like it a lot.<br></p><p>(Although it would be more accurate to say that `Optional&lt;MyEnum&gt;.cases` contains `MyEnum.cases.map(.Some) + [.None]`.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 18, 2016 at 11:00:00pm</p></header><div class="content"><p>Thanks for the feedback, Brent! Responses inline:<br></p><p>On Mon, Jan 18, 2016 at 9:17 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br>&gt;<br>&gt; &gt;       ‚Ä¢ CaseEnumerable could have a user-visible declaration requiring<br>&gt; static var cases, which would allow users to add conformances for custom<br>&gt; non-enum types.<br>&gt;<br>&gt; I think this is an excellent idea. As Joe points out, this would imply<br>&gt; that the protocol and property should have names which don&#39;t include the<br>&gt; word &quot;case&quot;. (Renaming is also a good idea because if the property is<br>&gt; `cases`, you&#39;ll be tempted to say `for case in Foo.cases`, but `for case`<br>&gt; will be misparsed.)<br>&gt;<br>&gt; Simply start the discussion, I suggest this definition:<br>&gt;<br>&gt;         /// Any type which can only take on one of a limited, easily<br>&gt; enumerable list of values may<br>&gt;         /// conform to FiniteType to make that list easy to access. For<br>&gt; certain simple types,<br>&gt;         /// Swift will automatically generate an implementation of<br>&gt; `values`.<br>&gt;         protocol FiniteType {<br>&gt;                 /// A collection containing all possible values of this<br>&gt; type.<br>&gt;                 ///<br>&gt;                 /// Invariant: T.values.contains(valueOfTypeT) for any<br>&gt; valueOfTypeT. In other words, `values`<br>&gt;                 /// must be truly exhaustive.<br>&gt;                 static var values: ...<br>&gt;         }<br>&gt;<br></p><p>OK, I can see the argument here. I was worried about making this proposal<br>so broad that it wouldn&#39;t be seriously considered, but I agree that<br>choosing more general names will open it up to future expansion.<br></p><p>Here are some more name ideas:<br></p><p>- CaseEnumerable (in the proposal draft)<br>- T.cases (in the proposal draft)<br>- T.allCases<br>- FiniteType (as you suggested)<br>- FiniteValueType<br>- ValueEnumerable<br>- T.values<br>- T.allValues<br></p><p>Thoughts? More suggestions? I think I like ValueEnumerable.<br></p><p><br>&gt;               ‚Ä¢ This would probably require cases to be<br>&gt; AnySequence&lt;Self&gt;, or to introduce an AnyCollection, since we aren&#39;t able<br>&gt; to say associatedtype CaseCollection: CollectionType where<br>&gt; CaseCollection.Generator.Element == Self.<br>&gt;<br>&gt; Ouch, that&#39;s an ugly limitation. Is this going to change in Swift 3?<br>&gt;<br></p><p>I can&#39;t speak to that. You might want to search the list to see if you can<br>find what&#39;s been said about the plan for Swift 3 generics so far.<br></p><p><br>&gt; &gt;       ‚Ä¢ It would be nice to have a way of supporting this for<br>&gt; OptionSetType structs. I would recommend that cases for an OptionSetType<br>&gt; should include only the already-declared static properties (not all<br>&gt; possible combinations of them). However, I&#39;m not sure it fits into this<br>&gt; proposal.<br>&gt;<br>&gt; Theoretically, `cases` on an OptionSetType should return all combinations<br>&gt; of options, so I think we&#39;d need something different there.<br>&gt;<br></p><p>As a user, I&#39;d really love to be able to enumerate the individual &quot;bits&quot; of<br>an OptionSetType, such as all the NSWindow styleMask types: Borderless,<br>Titled, etc.  .cases or .values seems to be a natural place to return<br>those, but I guess you&#39;re right that these wouldn&#39;t really encompass<br>*all* possible<br>cases/values, so maybe it doesn&#39;t fit as well as I&#39;d hope.<br></p><p>Is it too crazy to suggest synthesizing a collection of all the *static<br>members* of a type which are of type Self? This would cover enum cases and<br>OptionSetType fields.<br></p><p><br>&gt;<br>&gt; &gt;       ‚Ä¢ Support for enum case names. It would be useful to get case<br>&gt; names even for enums which have integer rawValues. This could be part of<br>&gt; the existing reflection APIs, or it could take the form of derived<br>&gt; implementations of StringLiteralConvertible/CustomStringConvertible.<br>&gt;<br>&gt; I very strongly believe this is a job for reflection, not for our case<br>&gt; mechanism. (So, I agree with you.)<br>&gt;<br></p><p>Playing devil&#39;s advocate: if handling names are a job for reflection, why<br>isn&#39;t getting all cases/values also a job for reflection?<br></p><p>Jacob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/3017bf1b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January 20, 2016 at 07:00:00am</p></header><div class="content"><p>proposal +1<br></p><p>I was originally thinking T.allCases. When reading trough. <br></p><p>valueEnumerable could work trying to think something shorter and easier to read. <br></p><p>This is short and easy to understand and could be used in other contexts:<br>T.allValues<br></p><p><br></p><p><br>&gt; On Jan 18, 2016, at 11:15 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; OK, I can see the argument here. I was worried about making this proposal so broad that it wouldn&#39;t be seriously considered, but I agree that choosing more general names will open it up to future expansion.<br>&gt; <br>&gt; Here are some more name ideas:<br>&gt; <br>&gt; - CaseEnumerable (in the proposal draft)<br>&gt; - T.cases (in the proposal draft)<br>&gt; - T.allCases<br>&gt; - FiniteType (as you suggested)<br>&gt; - FiniteValueType<br>&gt; - ValueEnumerable<br>&gt; - T.values<br>&gt; - T.allValues<br>&gt; <br>&gt; Thoughts? More suggestions? I think I like ValueEnumerable.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/4ab42ad4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e860a1e0d21a7ae5467aacfe1d9c6a78?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Denis Nikitenko</string> &lt;d.nikitenko at icloud.com&gt;<p>January 20, 2016 at 11:00:00am</p></header><div class="content"><p>For the protocol name, I rather like FiniteType (or FiniteValueType), since I find it to be more general and future-proof.  ValueEnumerable would also work, though.  <br></p><p>My preference for the static var would be T.values or T.allValues - we want to get all values of the finite type T.<br></p><p>Definitely a +1 on the overall proposal.<br></p><p><br></p><p>&gt;&gt; On Jan 18, 2016, at 11:15 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; OK, I can see the argument here. I was worried about making this proposal so broad that it wouldn&#39;t be seriously considered, but I agree that choosing more general names will open it up to future expansion.<br>&gt;&gt; <br>&gt;&gt; Here are some more name ideas:<br>&gt;&gt; <br>&gt;&gt; - CaseEnumerable (in the proposal draft)<br>&gt;&gt; - T.cases (in the proposal draft)<br>&gt;&gt; - T.allCases<br>&gt;&gt; - FiniteType (as you suggested)<br>&gt;&gt; - FiniteValueType<br>&gt;&gt; - ValueEnumerable<br>&gt;&gt; - T.values<br>&gt;&gt; - T.allValues<br>&gt;&gt; <br>&gt;&gt; Thoughts? More suggestions? I think I like ValueEnumerable.<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 20, 2016 at 09:00:00am</p></header><div class="content"><p>I&#39;ve been thinking about naming a bit. I&#39;m worried that &quot;values&quot; /<br>&quot;allValues&quot; won&#39;t make sense if this feature eventually goes in the<br>direction of returning type constructors. For enums with associated types,<br>the cases may actually be *functions* taking the associated type and<br>returning the enum type. (There&#39;s an example under &quot;Future directions&quot; in<br>the proposal). Calling these &quot;values&quot; seems strange to me, but calling them<br>&quot;cases&quot; makes sense.<br></p><p>Even though the &quot;case&quot; *keyword* is mostly used with enums, I think the<br>actual English *word* &quot;case&quot; applies pretty well when thinking about any<br>type, not just enums. It refers to a member of the type. T.cases or<br>T.allCases are all the cases of valid instances/members of the type.<br></p><p>&quot;FiniteType&quot; is technically accurate, but to me it doesn&#39;t evoke &quot;this<br>protocol allows you to enumerate the type&#39;s values&quot;. I&#39;m leaning toward the<br>names that end in -Enumerable.<br></p><p>Unless someone has a compelling argument otherwise, I may leave the naming<br>as-is in the proposal, and let the core team bikeshed it to their liking :)<br></p><p>On Wed, Jan 20, 2016 at 8:45 AM, Denis Nikitenko &lt;d.nikitenko at icloud.com&gt;<br>wrote:<br></p><p>&gt; For the protocol name, I rather like FiniteType (or FiniteValueType),<br>&gt; since I find it to be more general and future-proof.  ValueEnumerable would<br>&gt; also work, though.<br>&gt;<br>&gt; My preference for the static var would be T.values or T.allValues - we<br>&gt; want to get all values of the finite type T.<br>&gt;<br>&gt; Definitely a +1 on the overall proposal.<br>&gt;<br>&gt;<br>&gt;<br>&gt; &gt;&gt; On Jan 18, 2016, at 11:15 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; OK, I can see the argument here. I was worried about making this<br>&gt; proposal so broad that it wouldn&#39;t be seriously considered, but I agree<br>&gt; that choosing more general names will open it up to future expansion.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Here are some more name ideas:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - CaseEnumerable (in the proposal draft)<br>&gt; &gt;&gt; - T.cases (in the proposal draft)<br>&gt; &gt;&gt; - T.allCases<br>&gt; &gt;&gt; - FiniteType (as you suggested)<br>&gt; &gt;&gt; - FiniteValueType<br>&gt; &gt;&gt; - ValueEnumerable<br>&gt; &gt;&gt; - T.values<br>&gt; &gt;&gt; - T.allValues<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thoughts? More suggestions? I think I like ValueEnumerable.<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/5a31934c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e860a1e0d21a7ae5467aacfe1d9c6a78?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Denis Nikitenko</string> &lt;d.nikitenko at icloud.com&gt;<p>January 20, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 12:01 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; I&#39;ve been thinking about naming a bit. I&#39;m worried that &quot;values&quot; / &quot;allValues&quot; won&#39;t make sense if this feature eventually goes in the direction of returning type constructors. For enums with associated types, the cases may actually be functions taking the associated type and returning the enum type. (There&#39;s an example under &quot;Future directions&quot; in the proposal). Calling these &quot;values&quot; seems strange to me, but calling them &quot;cases&quot; makes sense.<br>&gt; <br></p><p>As I was writing my previous post, I was also thinking of more abstract names that would evoke the notion of enumerating elements in a set, e.g. T.enumeration or T.enumerate().<br></p><p>However, I think I prefer this idea of outsourcing the bikeshedding. ;)<br></p><p><br>&gt; Even though the &quot;case&quot; keyword is mostly used with enums, I think the actual English word &quot;case&quot; applies pretty well when thinking about any type, not just enums. It refers to a member of the type. T.cases or T.allCases are all the cases of valid instances/members of the type.<br>&gt; <br>&gt; &quot;FiniteType&quot; is technically accurate, but to me it doesn&#39;t evoke &quot;this protocol allows you to enumerate the type&#39;s values&quot;. I&#39;m leaning toward the names that end in -Enumerable.<br>&gt; <br>&gt; Unless someone has a compelling argument otherwise, I may leave the naming as-is in the proposal, and let the core team bikeshed it to their liking :)<br>&gt; <br>&gt; On Wed, Jan 20, 2016 at 8:45 AM, Denis Nikitenko &lt;d.nikitenko at icloud.com&gt; wrote:<br>&gt; For the protocol name, I rather like FiniteType (or FiniteValueType), since I find it to be more general and future-proof.  ValueEnumerable would also work, though.<br>&gt; <br>&gt; My preference for the static var would be T.values or T.allValues - we want to get all values of the finite type T.<br>&gt; <br>&gt; Definitely a +1 on the overall proposal.<br>&gt; <br>&gt; <br>&gt; <br>&gt; &gt;&gt; On Jan 18, 2016, at 11:15 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; OK, I can see the argument here. I was worried about making this proposal so broad that it wouldn&#39;t be seriously considered, but I agree that choosing more general names will open it up to future expansion.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Here are some more name ideas:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - CaseEnumerable (in the proposal draft)<br>&gt; &gt;&gt; - T.cases (in the proposal draft)<br>&gt; &gt;&gt; - T.allCases<br>&gt; &gt;&gt; - FiniteType (as you suggested)<br>&gt; &gt;&gt; - FiniteValueType<br>&gt; &gt;&gt; - ValueEnumerable<br>&gt; &gt;&gt; - T.values<br>&gt; &gt;&gt; - T.allValues<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thoughts? More suggestions? I think I like ValueEnumerable.<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 9:01 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve been thinking about naming a bit. I&#39;m worried that &quot;values&quot; / &quot;allValues&quot; won&#39;t make sense if this feature eventually goes in the direction of returning type constructors. For enums with associated types, the cases may actually be functions taking the associated type and returning the enum type. (There&#39;s an example under &quot;Future directions&quot; in the proposal). Calling these &quot;values&quot; seems strange to me, but calling them &quot;cases&quot; makes sense.<br></p><p>That seems like a fairly specialized use case to me. I&#39;d expect the default behavior for enums with associated values to enumerate all possible values of each case (whose associated values would themselves need to be ValueEnumerable), not the case constructors themselves. That&#39;s more generally useful when using associated values to categorize constants.<br></p><p>-Joe<br></p><p>&gt; Even though the &quot;case&quot; keyword is mostly used with enums, I think the actual English word &quot;case&quot; applies pretty well when thinking about any type, not just enums. It refers to a member of the type. T.cases or T.allCases are all the cases of valid instances/members of the type.<br>&gt; <br>&gt; &quot;FiniteType&quot; is technically accurate, but to me it doesn&#39;t evoke &quot;this protocol allows you to enumerate the type&#39;s values&quot;. I&#39;m leaning toward the names that end in -Enumerable.<br>&gt; <br>&gt; Unless someone has a compelling argument otherwise, I may leave the naming as-is in the proposal, and let the core team bikeshed it to their liking :)<br>&gt; <br>&gt; On Wed, Jan 20, 2016 at 8:45 AM, Denis Nikitenko &lt;d.nikitenko at icloud.com &lt;mailto:d.nikitenko at icloud.com&gt;&gt; wrote:<br>&gt; For the protocol name, I rather like FiniteType (or FiniteValueType), since I find it to be more general and future-proof.  ValueEnumerable would also work, though.<br>&gt; <br>&gt; My preference for the static var would be T.values or T.allValues - we want to get all values of the finite type T.<br>&gt; <br>&gt; Definitely a +1 on the overall proposal.<br>&gt; <br>&gt; <br>&gt; <br>&gt; &gt;&gt; On Jan 18, 2016, at 11:15 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; OK, I can see the argument here. I was worried about making this proposal so broad that it wouldn&#39;t be seriously considered, but I agree that choosing more general names will open it up to future expansion.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Here are some more name ideas:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - CaseEnumerable (in the proposal draft)<br>&gt; &gt;&gt; - T.cases (in the proposal draft)<br>&gt; &gt;&gt; - T.allCases<br>&gt; &gt;&gt; - FiniteType (as you suggested)<br>&gt; &gt;&gt; - FiniteValueType<br>&gt; &gt;&gt; - ValueEnumerable<br>&gt; &gt;&gt; - T.values<br>&gt; &gt;&gt; - T.allValues<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thoughts? More suggestions? I think I like ValueEnumerable.<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/796e2dcc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 20, 2016 at 03:00:00pm</p></header><div class="content"><p>If the associated values are all enums themselves, that&#39;s great. What if your enum is an error type, and the associated values are all strings with maybe diagnostic info or time stamps or something?<br></p><p>If Swift‚Äôs stdlib had a protocol (either `Initable` or `HasDefaultValue`, as used below), and the language had better support for generic tuple processing:<br>Tuples automatically conform to any protocol to which all its members conform.<br>Mapping over a tuple‚Äôs member‚Äôs types: let x = (Int, String, Double).map { $0.init() } // returns (Int.init(), String.init(), Double.init())<br>Mapping over a tuple‚Äôs members: let x = (0, ‚Äú‚Äù, 0.0).map { $0.hashValue } // returns (0.hashValue, ‚Äú‚Äù.hashValue, 0.0.hashValue)<br>Subscripting tuple‚Äôs: (0, ‚Äú‚Äù, 0.0)[0] <br>The ability to append/appendElements to tuples, such that if T = (Int, Int), U = (Double, Double), then ().appendElements(T,U).append(NSFileManager) would equal (Int, Int, Double, Double, NSFileManager) <br>Then I think we‚Äôd only need a couple more features:<br>An implicit typealias in enums, which is a tuple of all the cases‚Äô associated value‚Äôs type<br>The ability to restrict a protocol to only be conformable by enums, like we can already do with classes<br></p><p>and I think we‚Äôd get all this for free with a couple protocols:<br></p><p>protocol Initable { init() }<br>protocol HasDefaultValue {<br>    typealias DefaultValue<br>    static var defaultValue: DefaultValue {get}<br>}<br>extension HasDefaultValue where Self: Initable, DefaultValue == Self {<br>    static var defaultValue: DefaultValue { return Self.init() } // can be overridden if not appropriate<br>}<br>protocol FiniteEnumerable : enum, HasDefaultValue {<br>    typealias AssociatedValues // A tuple of the associated type for each case<br>    typealias DefaultValue<br>    static var defaultValues: DefaultValue {get}<br>    static var cases: [Self] {get}<br>}<br></p><p>extension FiniteEnumerable {<br>    static var count: Int { return Int(Mirror(reflecting: self.defaultValues).children.count) }<br>}<br>extension FiniteEnumerable where AssociatedValues: HasDefaultValue, DefaultValue == AssociatedValues.DefaultValue {<br>    static var defaultValues: DefaultValue { return AssociatedValues.defaultValue }<br>}<br>extension FiniteEnumerable where AssociatedValues: FiniteEnumerable, DefaultValue == [Self] {<br>    static var defaultValues: DefaultValue {<br>        var allCases = ()<br>        for i in 0 ..&lt; Self.cases.count {<br>            for assocValue in AssociatedValues.cases[i] {<br>                allCases.append(theCase(assocValue)) // FWIW, this line and the ‚ÄúFiniteEnumerable : enum‚Äù parts are the only two errors Xcode can find.<br>            }<br>        }<br>        return allCases<br>    } // Over<br>}<br></p><p>Hmm‚Ä¶ I may have gotten `defaultValues` and `cases` switched around in there. But the point is that they all could be added through protocol extensions, which have the advantage of:<br>1) provides default declarations<br>2) that are overridable if you don‚Äôt like them<br>3) it‚Äôll throw a compile-time nonconformance error if there‚Äôs a hole in the protocol extensions<br>4) less magic.<br></p><p>- Dave Sweeris<br></p><p>On Jan 20, 2016, at 10:04, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>&gt; <br>&gt;&gt; On Jan 20, 2016, at 9:01 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve been thinking about naming a bit. I&#39;m worried that &quot;values&quot; / &quot;allValues&quot; won&#39;t make sense if this feature eventually goes in the direction of returning type constructors. For enums with associated types, the cases may actually be functions taking the associated type and returning the enum type. (There&#39;s an example under &quot;Future directions&quot; in the proposal). Calling these &quot;values&quot; seems strange to me, but calling them &quot;cases&quot; makes sense.<br>&gt; <br>&gt; That seems like a fairly specialized use case to me. I&#39;d expect the default behavior for enums with associated values to enumerate all possible values of each case (whose associated values would themselves need to be ValueEnumerable), not the case constructors themselves. That&#39;s more generally useful when using associated values to categorize constants.<br>&gt; <br>&gt; -Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/d1267957/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 20, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 3:13 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt; If the associated values are all enums themselves, that&#39;s great. What if your enum is an error type, and the associated values are all strings with maybe diagnostic info or time stamps or something?<br></p><p>Then I don&#39;t even know what you would use CaseEnumerable for. Do you have a more concrete use case in mind?<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 20, 2016 at 03:00:00pm</p></header><div class="content"><p>Off the top of my head?<br>enum NumClassification {<br>	case None(Int)<br>	case Even(Int)<br>	case Odd(Int)<br>	case Prime(Int)<br>	case Negative(Int)<br>	case Positive(Int) //Always gotta end on a positive note :-)<br>}<br></p><p>Although I must admit, if there‚Äôs a purpose to CaseEnumerable (or whatever it‚Äôs being called now) beyond just automatically getting a static cases:[Self] and labels:[String], I‚Äôve missed the memo about it.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 20, 2016, at 15:18, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 3:13 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If the associated values are all enums themselves, that&#39;s great. What if your enum is an error type, and the associated values are all strings with maybe diagnostic info or time stamps or something?<br>&gt; <br>&gt; Then I don&#39;t even know what you would use CaseEnumerable for. Do you have a more concrete use case in mind?<br>&gt; <br>&gt; -Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 20, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 3:24 PM, davesweeris at mac.com wrote:<br>&gt; <br>&gt; Off the top of my head?<br>&gt; enum NumClassification {<br>&gt; 	case None(Int)<br>&gt; 	case Even(Int)<br>&gt; 	case Odd(Int)<br>&gt; 	case Prime(Int)<br>&gt; 	case Negative(Int)<br>&gt; 	case Positive(Int) //Always gotta end on a positive note :-)<br>&gt; }<br>&gt; <br>&gt; Although I must admit, if there‚Äôs a purpose to CaseEnumerable (or whatever it‚Äôs being called now) beyond just automatically getting a static cases:[Self] and labels:[String], I‚Äôve missed the memo about it.<br></p><p>That&#39;s the extent of it, as I see it. Asking for the collection of case constructors seems like a different thing to me‚Äîyou&#39;re getting a [(Payload) -&gt; Self] rather than a [Self] collection.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 15:18, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 20, 2016, at 3:13 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the associated values are all enums themselves, that&#39;s great. What if your enum is an error type, and the associated values are all strings with maybe diagnostic info or time stamps or something?<br>&gt;&gt; <br>&gt;&gt; Then I don&#39;t even know what you would use CaseEnumerable for. Do you have a more concrete use case in mind?<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 20, 2016 at 03:00:00pm</p></header><div class="content"><p>Oh, ok. I must‚Äôve misread something then.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 20, 2016, at 15:25, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 3:24 PM, davesweeris at mac.com wrote:<br>&gt;&gt; <br>&gt;&gt; Off the top of my head?<br>&gt;&gt; enum NumClassification {<br>&gt;&gt; 	case None(Int)<br>&gt;&gt; 	case Even(Int)<br>&gt;&gt; 	case Odd(Int)<br>&gt;&gt; 	case Prime(Int)<br>&gt;&gt; 	case Negative(Int)<br>&gt;&gt; 	case Positive(Int) //Always gotta end on a positive note :-)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Although I must admit, if there‚Äôs a purpose to CaseEnumerable (or whatever it‚Äôs being called now) beyond just automatically getting a static cases:[Self] and labels:[String], I‚Äôve missed the memo about it.<br>&gt; <br>&gt; That&#39;s the extent of it, as I see it. Asking for the collection of case constructors seems like a different thing to me‚Äîyou&#39;re getting a [(Payload) -&gt; Self] rather than a [Self] collection.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 20, 2016, at 15:18, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 20, 2016, at 3:13 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If the associated values are all enums themselves, that&#39;s great. What if your enum is an error type, and the associated values are all strings with maybe diagnostic info or time stamps or something?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then I don&#39;t even know what you would use CaseEnumerable for. Do you have a more concrete use case in mind?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 20, 2016 at 09:00:00pm</p></header><div class="content"><p>Proposal revised &amp; submitted:<br></p><p>https://github.com/apple/swift-evolution/pull/114<br></p><p>Jacob<br></p><p>On Wed, Jan 20, 2016 at 3:28 PM, &lt;davesweeris at mac.com&gt; wrote:<br></p><p>&gt; Oh, ok. I must‚Äôve misread something then.<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>&gt; &gt; On Jan 20, 2016, at 15:25, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jan 20, 2016, at 3:24 PM, davesweeris at mac.com wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Off the top of my head?<br>&gt; &gt;&gt; enum NumClassification {<br>&gt; &gt;&gt;      case None(Int)<br>&gt; &gt;&gt;      case Even(Int)<br>&gt; &gt;&gt;      case Odd(Int)<br>&gt; &gt;&gt;      case Prime(Int)<br>&gt; &gt;&gt;      case Negative(Int)<br>&gt; &gt;&gt;      case Positive(Int) //Always gotta end on a positive note :-)<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Although I must admit, if there‚Äôs a purpose to CaseEnumerable (or<br>&gt; whatever it‚Äôs being called now) beyond just automatically getting a static<br>&gt; cases:[Self] and labels:[String], I‚Äôve missed the memo about it.<br>&gt; &gt;<br>&gt; &gt; That&#39;s the extent of it, as I see it. Asking for the collection of case<br>&gt; constructors seems like a different thing to me‚Äîyou&#39;re getting a [(Payload)<br>&gt; -&gt; Self] rather than a [Self] collection.<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - Dave Sweeris<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Jan 20, 2016, at 15:18, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Jan 20, 2016, at 3:13 PM, David Sweeris &lt;davesweeris at mac.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; If the associated values are all enums themselves, that&#39;s great. What<br>&gt; if your enum is an error type, and the associated values are all strings<br>&gt; with maybe diagnostic info or time stamps or something?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Then I don&#39;t even know what you would use CaseEnumerable for. Do you<br>&gt; have a more concrete use case in mind?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; -Joe<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/11b52517/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1696913cf1335685a75e63e11b459ae3?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Sune Foldager</string> &lt;cyano at me.com&gt;<p>January 19, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 18 Jan 2016, at 00:44, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Introduce a CaseEnumerable protocol. Conforming to CaseEnumerable will automagically derive a static var cases, whose type is a CollectionType of all the enum&#39;s values.<br></p><p>Hm, I don‚Äôt think I like that. Are there other examples of magic protocols in Swift?<br></p><p>-Sune<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/c265b8ac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 19, 2016 at 10:00:00am</p></header><div class="content"><p>Yes: ErrorType.<br></p><p>On Tue, Jan 19, 2016 at 10:21 AM, Sune Foldager &lt;cyano at me.com&gt; wrote:<br></p><p>&gt;<br>&gt; On 18 Jan 2016, at 00:44, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Introduce a CaseEnumerable protocol. Conforming to CaseEnumerable will<br>&gt; automagically derive a static var cases, whose type is a CollectionType<br>&gt; of all the enum&#39;s values.<br>&gt;<br>&gt;<br>&gt; Hm, I don‚Äôt think I like that. Are there other examples of magic protocols<br>&gt; in Swift?<br>&gt;<br>&gt; -Sune<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/75db41f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 19, 2016 at 12:00:00pm</p></header><div class="content"><p>ErrorType‚Äôs magic is only for Objective-C interoperability, and only exposed by diving into compiler implementation-level protocols.<br></p><p>This seems like a case where some syntax consistency is needed between ‚Äòcode generation‚Äô proposals (such as member wise initializers). If there was guidance on what an eventual macro system syntax could look like, this could be taken into account as well.<br></p><p>-DW<br></p><p>&gt; On Jan 19, 2016, at 11:36 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yes: ErrorType.<br>&gt; On Tue, Jan 19, 2016 at 10:21 AM, Sune Foldager &lt;cyano at me.com &lt;mailto:cyano at me.com&gt;&gt; wrote:<br>&gt; <br>&gt; Hm, I don‚Äôt think I like that. Are there other examples of magic protocols in Swift?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/baacaf16/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 19, 2016 at 11:00:00am</p></header><div class="content"><p>I think it would make sense for the syntax to be explicit that something is<br>being derived by the compiler. Haskell uses &quot;deriving&quot;<br>&lt;http://book.realworldhaskell.org/read/using-typeclasses.html#typeclasses.auto.derivation&gt;<br>for this. I&#39;m not sure what it should look like in Swift (suggestions<br>welcome), and I&#39;m also not sure if it&#39;s worth figuring that out for the<br>first version of this feature, or whether we&#39;d be better off making that<br>change later.<br></p><p>Jacob<br></p><p>On Tue, Jan 19, 2016 at 11:37 AM, David Waite &lt;david at alkaline-solutions.com&gt;<br>wrote:<br></p><p>&gt; ErrorType‚Äôs magic is only for Objective-C interoperability, and only<br>&gt; exposed by diving into compiler implementation-level protocols.<br>&gt;<br>&gt; This seems like a case where some syntax consistency is needed between<br>&gt; ‚Äòcode generation‚Äô proposals (such as member wise initializers). If there<br>&gt; was guidance on what an eventual macro system syntax could look like, this<br>&gt; could be taken into account as well.<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; On Jan 19, 2016, at 11:36 AM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Yes: ErrorType.<br>&gt;<br>&gt; On Tue, Jan 19, 2016 at 10:21 AM, Sune Foldager &lt;cyano at me.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hm, I don‚Äôt think I like that. Are there other examples of magic<br>&gt;&gt;&gt; protocols in Swift?<br>&gt;&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/b6d7e349/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 19, 2016 at 12:00:00pm</p></header><div class="content"><p>The compiler implicitly derives T: Equatable for enums without associated values, and IMO it&#39;d be reasonable to extend this to other types and/or other protocols.<br></p><p>-Joe<br></p><p>&gt; On Jan 19, 2016, at 11:37 AM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; ErrorType‚Äôs magic is only for Objective-C interoperability, and only exposed by diving into compiler implementation-level protocols.<br>&gt; <br>&gt; This seems like a case where some syntax consistency is needed between ‚Äòcode generation‚Äô proposals (such as member wise initializers). If there was guidance on what an eventual macro system syntax could look like, this could be taken into account as well.<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Jan 19, 2016, at 11:36 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yes: ErrorType.<br>&gt;&gt; On Tue, Jan 19, 2016 at 10:21 AM, Sune Foldager &lt;cyano at me.com &lt;mailto:cyano at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hm, I don‚Äôt think I like that. Are there other examples of magic protocols in Swift?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/c3da20cc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 19, 2016 at 12:00:00pm</p></header><div class="content"><p>Would you agree that it makes sense to:<br></p><p>1. Automatically derive CaseEnumerable (or ValueEnumerable or whatever we<br>choose) for Swift enums without associated values;<br>2. Still allow &quot;extension Foo: CaseEnumerable {}&quot; to add it to enums<br>imported from (Obj-)C headers?<br></p><p>Or is it OK as-is, or is it worth pursuing some kind of &quot;deriving&quot; syntax?<br></p><p>Jacob Bandes-Storch<br></p><p>On Tue, Jan 19, 2016 at 12:17 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt; The compiler implicitly derives T: Equatable for enums without associated<br>&gt; values, and IMO it&#39;d be reasonable to extend this to other types and/or<br>&gt; other protocols.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; On Jan 19, 2016, at 11:37 AM, David Waite via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; ErrorType‚Äôs magic is only for Objective-C interoperability, and only<br>&gt; exposed by diving into compiler implementation-level protocols.<br>&gt;<br>&gt; This seems like a case where some syntax consistency is needed between<br>&gt; ‚Äòcode generation‚Äô proposals (such as member wise initializers). If there<br>&gt; was guidance on what an eventual macro system syntax could look like, this<br>&gt; could be taken into account as well.<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; On Jan 19, 2016, at 11:36 AM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Yes: ErrorType.<br>&gt;<br>&gt; On Tue, Jan 19, 2016 at 10:21 AM, Sune Foldager &lt;cyano at me.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hm, I don‚Äôt think I like that. Are there other examples of magic<br>&gt;&gt;&gt; protocols in Swift?<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/4ed63156/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 19, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 12:20 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Would you agree that it makes sense to:<br>&gt; <br>&gt; 1. Automatically derive CaseEnumerable (or ValueEnumerable or whatever we choose) for Swift enums without associated values;<br></p><p> I think you&#39;d want to opt in, by declaring &#39;enum Foo: CaseEnumerable {}&#39;, since providing this conformance makes some implicit promises not every type may want to publicly commit to.<br></p><p>&gt; 2. Still allow &quot;extension Foo: CaseEnumerable {}&quot; to add it to enums imported from (Obj-)C headers?<br>&gt; <br>&gt; Or is it OK as-is, or is it worth pursuing some kind of &quot;deriving&quot; syntax?<br></p><p>This is just my opinion, but I think declaring a conformance ought to be enough. You could imagine the compiler-synthesized implementation being provided by a protocol extension with sufficiently advanced language features from the future to implement the default behavior.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 19, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 1:54 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 19, 2016, at 12:20 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Would you agree that it makes sense to:<br>&gt;&gt; <br>&gt;&gt; 1. Automatically derive CaseEnumerable (or ValueEnumerable or whatever we choose) for Swift enums without associated values;<br>&gt; <br>&gt; I think you&#39;d want to opt in, by declaring &#39;enum Foo: CaseEnumerable {}&#39;, since providing this conformance makes some implicit promises not every type may want to publicly commit to.<br></p><p>+1<br></p><p><br>&gt; <br>&gt;&gt; 2. Still allow &quot;extension Foo: CaseEnumerable {}&quot; to add it to enums imported from (Obj-)C headers?<br>&gt;&gt; <br>&gt;&gt; Or is it OK as-is, or is it worth pursuing some kind of &quot;deriving&quot; syntax?<br>&gt; <br>&gt; This is just my opinion, but I think declaring a conformance ought to be enough. You could imagine the compiler-synthesized implementation being provided by a protocol extension with sufficiently advanced language features from the future to implement the default behavior.<br></p><p>Also +1<br></p><p>:)<br></p><p>-- E, who believes in the sufficiently advanced language features from the future<br></p><p><br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 19, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 6:05 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 19, 2016, at 1:54 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is just my opinion, but I think declaring a conformance ought to be enough. You could imagine the compiler-synthesized implementation being provided by a protocol extension with sufficiently advanced language features from the future to implement the default behavior.<br>&gt; <br>&gt; Also +1<br>&gt; <br>&gt; :)<br>&gt; <br>&gt; -- E, who believes in the sufficiently advanced language features from the future<br></p><p>As long as they aren‚Äôt trying to kill my parents or myself for a bug I wrote in the source code for Skynet, I‚Äôm fine.<br></p><p>More seriously, I think of this sort of thing as being a default implementation of a protocol via an extension, just using internal language implementation features.<br></p><p>-DW<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 21, 2016 at 02:00:00pm</p></header><div class="content"><p>Attributes would be an option as well ‚Äî but even if they are imho the natural choice, I think I would prefer a &quot;protocol with synthesized default behavior&quot;.<br></p><p>&gt;&gt; Introduce a CaseEnumerable protocol. Conforming to CaseEnumerable will automagically derive a static var cases, whose type is a CollectionType of all the enum&#39;s values.<br>&gt; <br>&gt; Hm, I don‚Äôt think I like that. Are there other examples of magic protocols in Swift?<br></p><p><br>Same opinion ‚Äî if a protocol is the way to go, it shouldn&#39;t receive more special treatment than necessary:<br>Every type should be allowed to conform to the protocol, and enums could work like Joe suggests<br>&gt; This is just my opinion, but I think declaring a conformance ought to be enough. You could imagine the compiler-synthesized implementation being provided by a protocol extension with sufficiently advanced language features from the future to implement the default behavior.<br></p><p>There might be even situations where it could make sense to have &quot;cases&quot; that are generated at runtime (at least a can&#39;t see a reason to forbid it).<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/fb757fc9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7411024ff3fb3fdbb0624c41b72a1b92?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Alan Skipp</string> &lt;al_skipp at icloud.com&gt;<p>January 19, 2016 at 06:00:00pm</p></header><div class="content"><p>What do you think of the idea of enums acquiring successor() and predecessor() functions and the ability to use them in Ranges?<br></p><p>enum Char { case A, B, C, D, E, F }<br></p><p>let a = Char.A<br>a.successor() // Char.B<br></p><p>(Char.A ... Char.D) // Range Char.A -&gt; Char.D<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 19, 2016 at 07:00:00pm</p></header><div class="content"><p>I am NOT saying ‚Äúhere‚Äôs the answer‚Äù, but I put something up on my github that does some of this: https://github.com/TheOtherDave/EnumEnhancer<br></p><p>Again, not saying that‚Äôs how we should do it or anything, but if anyone thinks it‚Äôd be useful until the ‚Äúofficial‚Äù enhancements come out, help yourself. There‚Äôll still be boilerplate, but it makes some attempt to keep things correct.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 17, 2016, at 15:44, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi folks,<br>&gt; <br>&gt; I&#39;ve drafted a proposal to add a CaseEnumerable protocol, which will derive a static variable &quot;cases&quot; for enum types. Feedback is welcome, especially for refining the proposal before I submit a formal PR.<br>&gt; <br>&gt; The draft is here; full text below. https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md &lt;https://github.com/jtbandes/swift-evolution/blob/977a9923fd551491623b6bfd398d5859488fe1ae/proposals/0000-derived-collection-of-enum-cases.md&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/40ca6c53/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>January 20, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; Support for enum case names. It would be useful to get case names even for enums which have integer rawValues. This could be part of the existing reflection APIs, or it could take the form of derived implementations of StringLiteralConvertible/CustomStringConvertible.<br>&gt; <br>&gt; <br></p><p>I‚Äôd love to see reflection move to an opt-in model, with a compiler flag enabling reflection for all types in a module, and a protocol to opt-in conditionally otherwise.<br>&gt; Support for enums with associated values.<br>&gt; <br>&gt; <br></p><p>This seems tricky to use statically in the general case, as you see below. Do you have any good examples in mind? It seems that case enumeration only really makes sense for types with a finite number of elements, and not when you have associated values.<br></p><p>Perhaps it should only work if the associated values are themselves enums, and they can be enumerated recursively? But even that seems overkill, and something that people should implement themselves if they need it.<br></p><p>&gt; If Swift had anonymous sum types like A | B | C, then E.cases could vend elements of type A-&gt;E | B-&gt;E | C-&gt;E.<br>&gt; <br>&gt; <br></p><p>As part of write reflection, it would make sense to expose constructor functions [Any -&gt; E?] that perform a dynamic type check, failing with nil.<br></p><p>Imagine if you could reflect an enum of type T, and get an array of [EnumCase&lt;T&gt;]:<br></p><p>enum EnumCase&lt;T&gt; {<br>	// constructor makes a value: Payload -&gt; T<br>	// projection tests a value, returning payload if its that case, or nil: T -&gt; Payload?<br>	// type is the runtime type of the payload<br>	case PayloadCase(name: String, constructor: Any -&gt; T, projection: T -&gt; Any?, type: Any.Type)<br>	case EmptyCase(name: String, value: T)<br>}<br></p><p>Then you can get representative values of all cases by mapping over this array, returning the ‚Äòvalue‚Äô element of an EmptyCase.<br></p><p><br>&gt; enum Expr { case Apply(Expr, Expr), Tuple(Expr, Expr), Literal(Int) }<br>&gt; extension Value: CaseEnumerable {}<br>&gt; <br>&gt; // This example is pretty contrived, but illustrates the functionality.<br>&gt; let fortyTwos = Expr.cases.map {<br>&gt;    // $0 is of type `Int -&gt; Expr | (Expr, Expr) -&gt; Expr`<br>&gt;    switch $0 {<br>&gt;    case let lit as Int -&gt; Expr:  // handles .Literal<br>&gt;        return lit(42)<br>&gt;    case let bin as (Expr, Expr) -&gt; Expr:  // handles .Apply and .Tuple<br>&gt;        return bin(.Literal(42), .Literal(42))<br>&gt;    // all cases are covered<br>&gt;    }<br>&gt; }<br></p><p>I think in this example program, it would make more sense to define these data types:<br></p><p>enum BinaryExprKind { cae Apply, Tuple }<br>enum Expr { case Binary(Kind, Expr, Expr), Literal(Int) }<br></p><p>You can still enumerate the cases of BinaryExprKind dynamically, but destructuring Expr requires a switch.<br>&gt; Support for generic enums.<br>&gt; <br>&gt; CaseEnumerable could be conditionally supported depending on the generic argument(s). A great example would be Optional:<br>&gt; <br>&gt; enum MyEnum: CaseEnumerable {}<br>&gt; extension Optional: CaseEnumerable where Wrapped: CaseEnumerable {}<br>&gt; <br>&gt; // Optional&lt;MyEnum&gt;.cases effectively contains `MyEnum.cases + [.None]`<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/b0b5ba32/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/289e63405066acfc02feee3b7abf39bb?s=50"></div><header><strong>Pre-proposal: CaseEnumerable protocol (derived collection of enum cases)</strong> from <string>Zef Houssney</string> &lt;zefmail at gmail.com&gt;<p>January 21, 2016 at 07:00:00am</p></header><div class="content"><p>Regarding support for enums with associated values, I‚Äôd like to argue for the idea of returning the constructors along side the instances of simple enum cases.<br></p><p>I find that it‚Äôs common to have enums that have mostly simple cases, but a couple with associated values that provide more dynamic customization. I would hate to be unable to include the cases with associated values in order to get conformance for this feature. Here‚Äôs an example of something like that. The concept is that you have an enum that defines a number of built-in color schemes, but provides a mechanism for users to dynamically create their own color schemes:<br></p><p>https://gist.github.com/zef/c6069ed4ed11e41661bf<br></p><p>I have other real-world ideas for where this would be useful too. This is a contrived example that is simplified such that it would be just as easy to implement the result without the constructor being included in the list of cases (or allValues), but there are use-cases for where there are multiple cases with the same constructor signature where it would be valuable for them to be included.<br></p><p><br>Joe Groff said:<br></p><p>&gt; Asking for the collection of case constructors seems like a different thing to me‚Äîyou&#39;re getting a [(Payload) -&gt; Self] rather than a [Self] collection.<br></p><p><br>I agree that this is kind of a problem, but I find this a better tradeoff than the alternatives, which as I see them are:<br></p><p>1. Don‚Äôt support enums with disparate constructor signatures at all (currently proposed ‚Äî compiler error for these)<br>2. Allow conformance for all enums, but omit all cases that have associated values (more useful than the proposed solution, but confusing and not ideal)<br>3. A combination of 1 and 2, where some cases with associated values can potentially have multiple cases included, or none at all (confusing and potentially annoying to work around if it‚Äôs not what you want)<br></p><p>Omitting the values and getting back a collection of [Self] would be easy enough anyway: MyEnum.cases.flatMap { $0 as? MyEnum }<br></p><p><br>Here‚Äôs what I like about this approach:<br></p><p>- This would allow all enums be able to conform, not just ones where every case has the same type.<br>- The array consists of a 1-to-1 mapping regardless of the type of case. This could be very valuable and powerful compared to some of the other ideas that could omit or have multiple entries for a single case.<br>- As a base implementation, all the other ideas for how to deal with cases with associated values can be implemented on top of this foundation by developers, whereas the other approaches are somewhat more limiting and would not cover the use case I have above.<br></p><p><br>Downsides I can see to this approach:<br></p><p>- For enums that have disparate constructor signatures, [Any] would have to be the return value of cases, which doesn‚Äôt seem ideal because the cases array would always require some kind of manual manipulation to be useful. Would it even be possible for cases to return the [EnumType] for simple enums but [Any] for more complex ones? Is there a better type than [Any] that could be used?<br></p><p>- There isn‚Äôt currently a way in the type system to know what case you are working based on the constructor. For instance say two cases both have a constructor of (String), you can‚Äôt determine which case you are working on until you call the constructor to instantiate the case. This could be done by looking at the index of the constructor in the cases array, but that is brittle and messy. If there was a way to determine that more dynamically, this would be more powerful and easier to use.<br></p><p><br>FYI, some of this content is taken from a post where I wrote about this, but it was just before Christmas and didn‚Äôt really get any feedback: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004289.html<br></p><p><br></p><p><br>&gt; On Jan 20, 2016, at 10:40 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Support for enum case names. It would be useful to get case names even for enums which have integer rawValues. This could be part of the existing reflection APIs, or it could take the form of derived implementations of StringLiteralConvertible/CustomStringConvertible.<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; I‚Äôd love to see reflection move to an opt-in model, with a compiler flag enabling reflection for all types in a module, and a protocol to opt-in conditionally otherwise.<br>&gt;&gt; Support for enums with associated values.<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; This seems tricky to use statically in the general case, as you see below. Do you have any good examples in mind? It seems that case enumeration only really makes sense for types with a finite number of elements, and not when you have associated values.<br>&gt; <br>&gt; Perhaps it should only work if the associated values are themselves enums, and they can be enumerated recursively? But even that seems overkill, and something that people should implement themselves if they need it.<br>&gt; <br>&gt;&gt; If Swift had anonymous sum types like A | B | C, then E.cases could vend elements of type A-&gt;E | B-&gt;E | C-&gt;E.<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; As part of write reflection, it would make sense to expose constructor functions [Any -&gt; E?] that perform a dynamic type check, failing with nil.<br>&gt; <br>&gt; Imagine if you could reflect an enum of type T, and get an array of [EnumCase&lt;T&gt;]:<br>&gt; <br>&gt; enum EnumCase&lt;T&gt; {<br>&gt; 	// constructor makes a value: Payload -&gt; T<br>&gt; 	// projection tests a value, returning payload if its that case, or nil: T -&gt; Payload?<br>&gt; 	// type is the runtime type of the payload<br>&gt; 	case PayloadCase(name: String, constructor: Any -&gt; T, projection: T -&gt; Any?, type: Any.Type)<br>&gt; 	case EmptyCase(name: String, value: T)<br>&gt; }<br>&gt; <br>&gt; Then you can get representative values of all cases by mapping over this array, returning the ‚Äòvalue‚Äô element of an EmptyCase.<br>&gt; <br>&gt; <br>&gt;&gt; enum Expr { case Apply(Expr, Expr), Tuple(Expr, Expr), Literal(Int) }<br>&gt;&gt; extension Value: CaseEnumerable {}<br>&gt;&gt; <br>&gt;&gt; // This example is pretty contrived, but illustrates the functionality.<br>&gt;&gt; let fortyTwos = Expr.cases.map {<br>&gt;&gt;    // $0 is of type `Int -&gt; Expr | (Expr, Expr) -&gt; Expr`<br>&gt;&gt;    switch $0 {<br>&gt;&gt;    case let lit as Int -&gt; Expr:  // handles .Literal<br>&gt;&gt;        return lit(42)<br>&gt;&gt;    case let bin as (Expr, Expr) -&gt; Expr:  // handles .Apply and .Tuple<br>&gt;&gt;        return bin(.Literal(42), .Literal(42))<br>&gt;&gt;    // all cases are covered<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt; <br>&gt; I think in this example program, it would make more sense to define these data types:<br>&gt; <br>&gt; enum BinaryExprKind { cae Apply, Tuple }<br>&gt; enum Expr { case Binary(Kind, Expr, Expr), Literal(Int) }<br>&gt; <br>&gt; You can still enumerate the cases of BinaryExprKind dynamically, but destructuring Expr requires a switch.<br>&gt;&gt; Support for generic enums.<br>&gt;&gt; <br>&gt;&gt; CaseEnumerable could be conditionally supported depending on the generic argument(s). A great example would be Optional:<br>&gt;&gt; <br>&gt;&gt; enum MyEnum: CaseEnumerable {}<br>&gt;&gt; extension Optional: CaseEnumerable where Wrapped: CaseEnumerable {}<br>&gt;&gt; <br>&gt;&gt; // Optional&lt;MyEnum&gt;.cases effectively contains `MyEnum.cases + [.None]`<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/a74d1c08/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
