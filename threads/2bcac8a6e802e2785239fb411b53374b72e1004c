<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Protected access level / multiple	class/struct/protocol APIs</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 31, 2016 at 06:00:00am</p></header><div class="content"><p>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/2bca004c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Protected access level / multiple class/struct/protocol APIs</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 31, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Mar 30, 2016, at 11:31 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Am 31. März 2016 um 05:15 schrieb Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt;&gt; The problem with protected is that it provides virtually no protection at all; you can trivially expose it in a derived class<br>&gt;&gt; <br>&gt;&gt; +<br>&gt;&gt; <br>&gt;&gt;&gt; Extensions further dilute the enforceability of &quot;protected&quot;, since anyone would be able to use an extension to dump methods into a class&#39;s namespace and access its supposedly-protected bits.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t understand the need to protect against exposing something deliberately. We don&#39;t have a goal of restricting other developers, we&#39;re only saving them from accidental mistakes.<br>&gt; <br>&gt; Totally agree, access control is not intended to be protection against hacking. If a derived class wants to expose something then that is absolutely fine as long as it makes sense for the derived class.<br></p><p>My point is that &quot;protected&quot; *isn&#39;t* access control. If we added it, it would have to be as an independent modifier. Private/internal/public fundamentally affect semantics—private and internal code is only accessible within a module, so we have full knowledge of their use sites at compile time and can be more permissive with extensions, implicit constructors, and other features. Public API can be used by arbitrary unknown external code so requires additional restrictions to ensure that the interface remains stable. &quot;Only usable by subclasses&quot; is an orthogonal axis to this—if a method is only usable by external subclasses, it requires all of the same restrictions as public code. If a method is only usable by subclasses within the module, it can behave like a private or internal method.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; <br>&gt;&gt;&gt; If a method was marked private in the base class, then it is very likely that the name of the method, the design of its argument list and its return value did not go through the same detailed design review as if the method would have been meant to be part of the class’ interface from the start. So it’s rather unlikely that increasing the visibility in an override is good idea and in the spirit of the original writer of the private method.<br>&gt;&gt; <br>&gt;&gt; The design review and whether something is a good idea is left as a responsibility for those subclasses that choose to expose methods. The intentions of the original class author don&#39;t override the intentions of the subclass author.<br>&gt; <br>&gt; Exactly.<br>&gt; <br>&gt; -Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Protected access level / multiple class/struct/protocol APIs</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 31, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 31.03.2016 um 17:51 schrieb Joe Groff &lt;jgroff at apple.com&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 30, 2016, at 11:31 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Am 31. März 2016 um 05:15 schrieb Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; The problem with protected is that it provides virtually no protection at all; you can trivially expose it in a derived class<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Extensions further dilute the enforceability of &quot;protected&quot;, since anyone would be able to use an extension to dump methods into a class&#39;s namespace and access its supposedly-protected bits.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t understand the need to protect against exposing something deliberately. We don&#39;t have a goal of restricting other developers, we&#39;re only saving them from accidental mistakes.<br>&gt;&gt; <br>&gt;&gt; Totally agree, access control is not intended to be protection against hacking. If a derived class wants to expose something then that is absolutely fine as long as it makes sense for the derived class.<br>&gt; <br>&gt; My point is that &quot;protected&quot; *isn&#39;t* access control. If we added it, it would have to be as an independent modifier. Private/internal/public fundamentally affect semantics—private and internal code is only accessible within a module, so we have full knowledge of their use sites at compile time and can be more permissive with extensions, implicit constructors, and other features. Public API can be used by arbitrary unknown external code so requires additional restrictions to ensure that the interface remains stable. &quot;Only usable by subclasses&quot; is an orthogonal axis to this—if a method is only usable by external subclasses, it requires all of the same restrictions as public code. If a method is only usable by subclasses within the module, it can behave like a private or internal method.<br></p><p>Ah, now I understand what you mean! Thanks for clarifying!<br>I agree that this has to be taken into account when defining what „protected“ means and how it interacts with other parts of the language.<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; If a method was marked private in the base class, then it is very likely that the name of the method, the design of its argument list and its return value did not go through the same detailed design review as if the method would have been meant to be part of the class’ interface from the start. So it’s rather unlikely that increasing the visibility in an override is good idea and in the spirit of the original writer of the private method.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The design review and whether something is a good idea is left as a responsibility for those subclasses that choose to expose methods. The intentions of the original class author don&#39;t override the intentions of the subclass author.<br>&gt;&gt; <br>&gt;&gt; Exactly.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/60832c05/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Protected access level / multiple class/struct/protocol APIs</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>April  3, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt;&gt; My point is that &quot;protected&quot; *isn&#39;t* access control. If we added it, it would have to be as an independent modifier. Private/internal/public fundamentally affect semantics—private and internal code is only accessible within a module, so we have full knowledge of their use sites at compile time and can be more permissive with extensions, implicit constructors, and other features. Public API can be used by arbitrary unknown external code so requires additional restrictions to ensure that the interface remains stable. &quot;Only usable by subclasses&quot; is an orthogonal axis to this—if a method is only usable by external subclasses, it requires all of the same restrictions as public code. If a method is only usable by subclasses within the module, it can behave like a private or internal method.<br></p><p>Okay. So you see it as “public subclassonly”, leaving space for “internal subclassonly” (which makes sense, although not as important in practice).<br></p><p>I can agree with that, let&#39;s consider it a new strawman.<br></p><p>I wonder, though, if you guys have additional, fresh ideas on the underlying problem. We&#39;re not really limiting to subclasses here — we&#39;re limiting to “extenders” aka “service providers”, and those don&#39;t necessarily take a form of a subclass. I&#39;ve listed some examples in my strawman: an implementation of a protocol, an extension of a class/protocol.<br></p><p>Are there any novel and fresh ideas that would take care of all that in a straightforward and uncomplicated way?<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160403/8bed1828/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Protected access level / multiple class/struct/protocol APIs</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>April 28, 2016 at 07:00:00pm</p></header><div class="content"><p>Let me bump this thread. How do we move forward?<br></p><p>Here&#39;s an interface of another Swift class I&#39;ve just made (slowly rewriting my Obj-C components to Swift here):<br></p><p>public class SoloContainerViewController: UIViewController {<br></p><p>    private var _contentViewController: UIViewController?<br></p><p>    public var contentViewController: UIViewController?  // delegates to setContentViewController:animated:completion:<br></p><p>    public init(contentViewController: UIViewController?) { ... }<br></p><p>    public required init?(coder aDecoder: NSCoder) { ... }<br></p><p>    public override func viewDidLoad() { ... }<br></p><p>    public func setContentViewController(contentViewController: UIViewController?, animated: Bool, completion completionBlock: dispatch_block_t?) { ... }<br></p><p>    public /*protected*/ func transition(fromView oldView: UIView?, toView newView: UIView?, animated: Bool, completion completionBlock: (finished: Bool) -&gt; Void) { ... }<br></p><p>    public /*protected*/ func willTransitionToContentViewController(newViewController: UIViewController?) { ... }<br></p><p>    public /*protected*/ func didTransitionFromContentViewController(oldViewController: UIViewController?) { ... }<br></p><p>}<br></p><p>This is madness, we have to do SOMETHING!<br></p><p>This class is designed to be subclassed, with a bunch of hooks that subclasses may be interested in. Most of the reusable views and view controllers that I make look like this.<br></p><p>Even when I use delegates, I still forward delegate calls through overridable protected methods, based on my long history of subclassing UIScrollView (and other controls) and wishing that the subclass had access to the delegate methods.<br></p><p>Nobody outside of the class should be interested in those protected methods; they are not safe to call, they&#39;re override points.<br></p><p>And I often have to pick very telling method names, so that I don&#39;t end up accidentally calling one of those methods from outside. Sometimes that&#39;s fairly hard, like when there&#39;s a public save(), a private saveNow() and a protected saveContent().<br></p><p><br>Our best consensus the last time was:<br></p><p>&gt;&gt;&gt; My point is that &quot;protected&quot; *isn&#39;t* access control. If we added it, it would have to be as an independent modifier.<br>&gt; <br>&gt; Okay. So you see it as “public subclassonly”, leaving space for “internal subclassonly” (which makes sense, although not as important in practice).<br>&gt; <br>&gt; I can agree with that, let&#39;s consider it a new strawman.<br></p><p><br>So how do we move forward?<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/781fe69d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
