<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Proposal] Add .order() family of methods to Collection</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>April 11, 2016 at 09:00:00am</p></header><div class="content"><p>Swift standard library already offers a useful set of sort() functions. However, it is also often useful to know how the collection should be rearranged in order to become sorted. For example, R defines the order() function which returns a permutation of collection indexes which rearrange the collection in an order. I suggest to add similar functionality to the Swift Collections E.g.:<br></p><p>var out = []<br>for i in collection.order({$0 &lt; $1}) { out.append(collection[i]) }<br>// out is now sorted collection<br></p><p>Knowing the sort order is useful in many applications where the data cannot or should not be rearranged and yet some information about the ordering is helpful, e.g. for traversing the collection in a specific way. It is also helpful for maintaining multiple ordering relations associated with the same collection. <br></p><p>The implementation should be fairly straightforward. E.g. here is an extension method I use:<br></p><p>extension CollectionType {<br>    func order(@noescape isOrderedBefore: (Self.Generator.Element, Self.Generator.Element) -&gt; Bool) -&gt; [Self.Index] {<br>        return indices.sort({ isOrderedBefore(self[$0], self[$1]) })<br>    }<br>}<br></p><p>Best, <br></p><p> Taras<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/db7c3ae8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>[Proposal] Add .order() family of methods to Collection</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April 11, 2016 at 07:00:00pm</p></header><div class="content"><p>Hi Taras,<br></p><p>&gt; On 11 Apr 2016, at 08:48, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The implementation should be fairly straightforward. E.g. here is an extension method I use:<br>&gt; <br>&gt; extension CollectionType {<br>&gt;     func order(@noescape isOrderedBefore: (Self.Generator.Element, Self.Generator.Element) -&gt; Bool) -&gt; [Self.Index] {<br>&gt;         return indices.sort({ isOrderedBefore(self[$0], self[$1]) })<br>&gt;     }<br>&gt; }<br></p><p>Just a side note that you could also:<br></p><p>extension SequenceType {<br>	func order(@noescape isOrderedBefore: (Generator.Element, Generator.Element) -&gt; Bool) -&gt; [Int] {<br>		return enumerate().sort{ isOrderedBefore($0.1, $1.1) }.map{ $0.0 }<br>	}<br>}<br></p><p>(0...3).reverse().order(&lt;) // [3, 2, 1, 0]<br></p><p>This way you can `order` all sequences, and it is more efficient as you don’t fetch elements by index inside the `isOrderedBefore`. (You could also *not* `map` at the end and return all the elements along with their original indexes.)<br></p><p>milos<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/cf697ce4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Proposal] Add .order() family of methods to Collection</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>April 11, 2016 at 08:00:00pm</p></header><div class="content"><p>Hi, <br></p><p>I think it depends on how expensive the indexed access is on the collection. I use it primarily on arrays, where self[i] essentially boils down to a pointer dereference, so I expect the generated code to be very efficient. Your version might be faster for collection with expensive element access, but it should be slower for arrays and the like, as it involves additional intermediate structure allocations and copies. <br></p><p>— Taras<br></p><p><br>&gt; Just a side note that you could also:<br>&gt; <br>&gt; extension SequenceType {<br>&gt; 	func order(@noescape isOrderedBefore: (Generator.Element, Generator.Element) -&gt; Bool) -&gt; [Int] {<br>&gt; 		return enumerate().sort{ isOrderedBefore($0.1, $1.1) }.map{ $0.0 }<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; (0...3).reverse().order(&lt;) // [3, 2, 1, 0]<br>&gt; <br>&gt; This way you can `order` all sequences, and it is more efficient as you don’t fetch elements by index inside the `isOrderedBefore`. (You could also *not* `map` at the end and return all the elements along with their original indexes.)<br>&gt; <br>&gt; milos<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/2a3d8510/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>[Proposal] Add .order() family of methods to Collection</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April 11, 2016 at 08:00:00pm</p></header><div class="content"><p>Hi Taras,<br></p><p>&gt; On 11 Apr 2016, at 19:38, Taras Zakharko &lt;taras.zakharko at uzh.ch &lt;mailto:taras.zakharko at uzh.ch&gt;&gt; wrote:<br>&gt; <br>&gt; Your version might be faster for collection with expensive element access, but it should be slower for arrays and the like, as it involves additional intermediate structure allocations and copies.<br></p><p>No, not really. The cost of my enumeration and mapping is linear so they add nothing to the sorting order of complexity. Your two subscript calls inside the predicate, however, definitely do. In other words, your implementation will not be faster under any circumstances and it will in fact grow nonlinearly slower compared to the enumeration approach as the length of array increases…<br></p><p>milos<br></p><p>(My message appear to have bounced: I’m sorry if I end up sending multiple copies!)<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/62f6060e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
