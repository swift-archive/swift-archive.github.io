<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September 26, 2016 at 05:00:00pm</p></header><div class="content"><p>Conditional conformances<br></p><p>Proposal: SE-NNNN &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/NNNN-conditional-conformances.md&gt;<br>Author: Doug Gregor &lt;https://github.com/DougGregor&gt;<br>Review Manager: TBD<br>Status: Awaiting review<br>During the review process, add the following fields as needed:<br></p><p>Decision Notes: Rationale &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;, Additional Commentary &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>Bugs: SR-NNNN &lt;https://bugs.swift.org/browse/SR-NNNN&gt;, SR-MMMM &lt;https://bugs.swift.org/browse/SR-MMMM&gt;<br>Previous Revision: 1 &lt;https://github.com/apple/swift-evolution/blob/...commit-ID.../proposals/NNNN-filename.md&gt;<br>Previous Proposal: SE-XXXX &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/XXXX-filename.md&gt;<br> &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#introduction&gt;Introduction<br></p><p>Conditional conformances express the notion that a generic type will conform to a particular protocol only when it&#39;s type arguments meet certain requirements. For example, the Array collection can implement the Equatable protocol only when its elements are themselves Equatable, which can be expressed via the following conditional conformance on Equatable:<br></p><p>extension Array: Equatable where Element: Equatable {<br>  static func ==(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { ... }<br>}<br>This feature is part of the generics manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-&gt; because it&#39;s something that fits naturally into the generics model and is expected to have a high impact on the Swift standard library.<br></p><p>Swift-evolution thread: TBD: Discussion thread topic for that proposal &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br> &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#motivation&gt;Motivation<br></p><p>Conditional conformances address a hole in the composability of the generics system. Continuing the Array example from above, it&#39;s always been the case that one could use the == operator on two arrays of Equatable type, e.g., [Int]() == [Int]() would succeed. However, it doesn&#39;t compose: arrays of arrays of Equatable types cannot be compared (e.g.,[Int] &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals&gt;== [Int] &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals&gt;will fail to compile) because, even though there is an==for arrays of Equatabletype, the arrays themselves are neverEquatable`.<br></p><p>Conditional conformances are particularly powerful when building generic adapter types, which are intended to reflect the capabilities of their type arguments. For example, consider the &quot;lazy&quot; functionality of the Swift standard library&#39;s collections: using the lazy member of a sequence produces a lazy adapter that conforms to the Sequence protocol, while using the lazy member of a collection produces a lazy adapter that conforms to the Collection protocol. In Swift 3, the only way to model this is with different types. For example, the Swift standard library has four similar generic types to handle a lazy collection: LazySequence, LazyCollection, LazyBidirectionalCollection, and LazyRandomAccessCollection. The Swift standard library uses overloading of the lazy property to decide among these:<br></p><p>extension Sequence {<br>  var lazy: LazySequence&lt;Self&gt; { ... }<br>}<br></p><p>extension Collection {<br>  var lazy: LazyCollection&lt;Self&gt; { ... }<br>}<br></p><p>extension BidirectionalCollection {<br>  var lazy: LazyBidirectionalCollection&lt;Self&gt; { ... }<br>}<br></p><p>extension RandomAccessCollection {<br>  var lazy: LazyRandomAccessCollection&lt;Self&gt; { ... }<br>}<br>This approach causes an enormous amount of repetition, and doesn&#39;t scale well because each more-capable type has to re-implement (or somehow forward the implementation of) all of the APIs of the less-capable versions. With conditional conformances, one can provide a single generic wrapper type whose basic requirements meet the lowest common denominator (e.g., Sequence), but which scale their capabilities with their type argument (e.g., the LazySequence conforms to Collection when the type argument does, and so on).<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#proposed-solution&gt;Proposed solution<br></p><p>In a nutshell, the proposed solution is to allow a constrained extension of a struct, enum, or class to declare protocol conformances. No additional syntax is necessary for this change, because it already exists in the grammar; rather, this proposal removes the limitation that results in the following error:<br></p><p>t.swift:1:1: error: extension of type &#39;Array&#39; with constraints cannot have an inheritance clause<br>extension Array: Equatable where Element: Equatable { }<br>^                ~~~~~~~~~<br>Conditional conformances can only be used when the additional requirements of the constrained extension are satisfied. For example, given the aforementioned Array conformance to Equatable:<br></p><p>func f&lt;T: Equatable&gt;(_: T) { ... }<br></p><p>struct NotEquatable { }<br></p><p>func test(a1: [Int], a2: [NotEquatable]) {<br>  f(a1)    // okay: [Int] conforms to Equatable because Int conforms to Equatable<br>  f(a2)    // error: [NotEquatable] does not conform to Equatable because NotEquatable has no conformance to Equatable<br>}<br>Conditional conformances also have a run-time aspect, because a dynamic check for a protocol conformance might rely on the evaluation of the extra requirements needed to successfully use a conditional conformance. For example:<br></p><p>protocol P {<br>  func doSomething()<br>}<br></p><p>struct S: P {<br>  func doSomething() { print(&quot;S&quot;) }<br>}<br></p><p>// Array conforms to P if it&#39;s element type conforms to P<br>extension Array: P where Element: P {<br>  func doSomething() {<br>    for value in self {<br>      value.doSomething()<br>    }<br>  }<br>}<br></p><p>// Dynamically query and use conformance to P.<br>func doSomethingIfP(_ value: Any) {<br>  if let p = value as? P {<br>    p.doSomething()<br>  } else {<br>    print(&quot;Not a P&quot;)<br>  }<br>}<br></p><p>doSomethingIfP([S(), S(), S()]) // prints &quot;S&quot; three times<br>doSomethingIfP([1, 2, 3])       // prints &quot;Not a P&quot;<br>The if-let in doSomethingIfP(_:) dynamically queries whether the type stored in value conforms to the protocol P. In the case of an Array, that conformance is conditional, which requires another dynamic lookup to determine whether the element type conforms to P: in the first call to doSomethingIfP(_:), the lookup finds the conformance of S to P. In the second case, there is no conformance of Int to P, so the conditional conformance cannot be used. The desire for this dynamic behavior motivates some of the design decisions in this proposal.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#detailed-design&gt;Detailed design<br></p><p>Most of the semantics of conditional conformances are obvious. However, there are a number of issues (mostly involving multiple conformances) that require more in-depth design.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#disallow-overlapping-conformances&gt;Disallow overlapping conformances<br></p><p>With conditional conformances, it is possible to express that a given generic type can conform to the same protocol in two different ways, depending on the capabilities of its type arguments. For example:<br></p><p>struct SomeWrapper&lt;Wrapped&gt; {<br>  let wrapped: Wrapped<br>}<br></p><p>protocol HasIdentity {<br>  static func ===(lhs: Self, rhs: Self) -&gt; Bool<br>}<br></p><p>extension SomeWrapper: Equatable where Wrapped: Equatable {<br>  static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>    return lhs.wrapped == rhs.wrapped<br>  }<br>}<br></p><p>extension SomeWrapper: Equatable where Wrapped: HasIdentity {<br>  static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>    return lhs.wrapped === rhs.wrapped<br>  }<br>}<br>Note that, for an arbitrary type T, there are four potential answers to the question of whether SomeWrapper&lt;T&gt; conforms to Equatable:<br></p><p>No, it does not conform because T is neither Equatable nor HasIdentity.<br>Yes, it conforms via the first extension of SomeWrapper because T conforms to Equatable.<br>Yes, it conforms via the second extension of SomeWrapper because T conforms to HasIdentity.<br>Ambiguity, because T conforms to both Equatable and HasIdentity.<br>It is due to the possibility of #4 occurring that we refer to the two conditional conformances in the example as overlapping. There are designs that would allow one to address the ambiguity, for example, by writing a third conditional conformance that addresses #4:<br></p><p>// Possible tie-breaker conformance<br>extension SomeWrapper: Equatable where Wrapped: Equatable &amp; HasIdentity, {<br>  static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>    return lhs.wrapped == rhs.wrapped<br>  }<br>}<br>The design is consistent, because this third conditional conformance is more specialized the either of the first two conditional conformances, meaning that its requirements are a strict superset of the requirements of those two conditional conformances. However, there are a few downsides to such a system:<br></p><p>To address all possible ambiguities, one has to write a conditional conformance for every plausible combination of overlapping requirements. To statically resolve all ambiguities, one must also cover nonsensical combinations where the two requirements are mutually exclusive (or invent a way to state mutual-exclusivity).<br>It is no longer possible to uniquely say what is required to make a generic type conform to a protocol, because there might be several unrelated possibilities. This makes reasoning about the whole system more complex, because it admits divergent interfaces for the same generic type based on their type arguments. At its extreme, this invites the kind of cleverness we&#39;ve seen in the C++ community with template metaprogramming, which is something Swift has sought to avoid.<br>All of the disambiguation machinery required at compile time (e.g., to determine whether one conditional conformance is more specialized than another to order them) also needs to implements in the run-time, as part of the dynamic casting machinery. One must also address the possibility of ambiguities occurring at run-time. This is both a sharp increase in the complexity of the system and a potential run-time performance hazard.<br>For these reasons, this proposal bans overlapping conformances entirely. While the resulting system is less flexible than one that allowed overlapping conformances, the gain in simplicity in this potentially-confusing area is well worth the cost. Moreover, this ban follows with existing Swift rules regarding multiple conformances, which prohibit the same type from conforming to the same protocol in two different ways:<br></p><p>protocol P { }<br></p><p>struct S : P { }<br>extension S : P { } // error: S already conforms to P<br> &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#implied-conditional-conformances&gt;Implied conditional conformances<br></p><p>Stating conformance to a protocol implicitly states conformances to any of the protocols that it inherits. This is the case in Swift today, although most developers likely don&#39;t realize the rules it follows. For example:<br></p><p>protocol P { }<br>protocol Q : P { }<br>protocol R : P { }<br></p><p>struct X1 { }<br>struct X2 { }<br>struct X3 { }<br></p><p>extension X1: Q { }  // implies conformance to P<br></p><p>extension X2: Q { }  // would imply conformance to P, but...<br>extension X2: P { }  // explicitly-stated conformance to P &quot;wins&quot;<br></p><p>extension X3: Q { }  // implies conformance to P<br>extension X3: R { }  // also implies conformance to P<br>                     // one will &quot;win&quot;; which is unspecified<br>With conditional conformances, the question of which extension &quot;wins&quot; the implied conformance begins to matter, because the extensions might have different constraints on them. For example:<br></p><p>struct X4&lt;T&gt; { }<br></p><p>extension X4: Q where T: Q { }  // implies conformance to P<br>extension X4: R where T: R { }  // error: implies overlapping conformance to P<br>Both of these constrained extensions imply a conformance to P, but the actual P implied conformances to P are overlapping and, therefore, result in an error.<br></p><p>However, in cases where there is a reasonable ordering between the two constrained extensions (i.e., one is more specialized than the other), the less specialized constrained extension should &quot;win&quot; the implied conformance. Continuing the example from above:<br></p><p>protocol S: R { }<br></p><p>struct X5&lt;T&gt; { }<br></p><p>extension X5: R where T: R { }  // &quot;wins&quot; implied conformance to P, because<br>extension X5: S where T: S { }  // the extension where &quot;T: S&quot; is more specialized<br>                                // than the one where &quot;T: R&quot;<br>Thus, the rule for placing implied conformances is to pick the least specialized extension that implies the conformance. If there is more than one such extension, then either:<br></p><p>All such extensions are not constrained extensions (i.e., they have no requirements beyond what the type requires), in which case Swift can continue to choose arbitrarily among the extensions, or<br>All such extensions are constrained extensions, in which case the program is ill-formed due to the ambiguity. The developer can explicitly specify conformance to the protocol to disambiguate. <br> &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#overloading-across-constrained-extensions&gt;Overloading across constrained extensions<br></p><p>One particularly important aspect of the placement rule for implied conformances is that it affects which declarations are used to satisfy a particular requirement. For example:<br></p><p>protocol P {<br>  func f()<br>}<br></p><p>protocol Q: P { }<br>protocol R: Q { }<br></p><p>struct X1&lt;T&gt; { }<br></p><p>extension X1: Q where T: Q {           // note: implied conformance to P here<br>  func f() {<br>    // #1: basic implementation of &#39;f()&#39;<br>  }<br>}<br></p><p>extension X1: R where T: R {<br>  func f() {<br>    // #2: superfast implementation of f() using some knowledge of &#39;R&#39;<br>  }<br>}<br></p><p>struct X2: R {<br>  func f() { }<br>}<br></p><p>(X1&lt;X2&gt;() as P).f() // calls #1, which was used to satisfy the requirement for &#39;f&#39;<br>X1&lt;X2&gt;().f()        // calls #2, which is preferred by overload resolution<br>Effectively, when satisfying a protocol requirement, one can only choose from members of the type that are guaranteed to available within the extension with which the conformance is associated. In this case, the conformance to P is placed on the first extension of X1, so the only f() that can be considered is the f() within that extension: the f() in the second extension won&#39;t necessarily always be available, because T may not conform to R. Hence, the call that treats an X1&lt;X2&gt;as a P gets the first implementation of X1.f(). When using the concrete type X1&lt;X2&gt;, where X2 conforms to R, both X.f() implementations are visible... and the second is more specialized.<br></p><p>Technically, this issue is no different from surprises where (e.g.) a member added to a concrete type in a different module won&#39;t affect an existing protocol conformance. The existing ideas to mediate these problems---warning for nearly-matching functions when they are declared in concrete types, for example---will likely be sufficient to help surprised users. That said, this proposal may increase the likelihood of such problems showing up.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#source-compatibility&gt;Source compatibility<br></p><p>&gt;From the language perspective, conditional conformances are purely additive. They introduce no new syntax, but instead provide semantics for existing syntax---an extension that both declares a protocol conformance and has a where clause---whose use currently results in a type checker failure. That said, this is a feature that is expected to be widely adopted within the Swift standard library, which may indirectly affect source compatibility.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#effect-on-abi-stability&gt;Effect on ABI Stability<br></p><p>As noted above, there are a number of places where the standard library is expected to adopt this feature, which fall into two classes:<br></p><p>Improve composability: the example in the introduction &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/Introduction&gt; made Array conform to Equatable when its element type does; there are many places in the Swift standard library that could benefit from this form of conditional conformance, particularly so that collections and other types that contain values (e.g., Optional) can compose better with generic algorithms. Most of these changes won&#39;t be ABI- or source-breaking, because they&#39;re additive.<br>Eliminating repetition: the lazy wrappers described in the motivation &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/motivation&gt; section could be collapsed into a single wrapper with several conditional conformances. A similar refactoring could also be applied to the range abstractions and slice types in the standard library, making the library itself simpler and smaller. All of these changes are potentially source-breaking and ABI-breaking, because they would remove types that could be used in Swift 3 code. However, there are mitigations: generic typealiases could provide source compatibility to Swift 3 clients, and the ABI-breaking aspect is only relevant if conditional conformances and the standard library changes they imply aren&#39;t part of Swift 4.<br>Aside from the standard library, conditional conformances have an impact on the Swift runtime, which will require specific support to handle dynamic casting. If that runtime support is not available once ABI stability has been declared, then introducing conditional conformances in a later language version either means the feature cannot be deployed backward or that it would provide only more limited, static behavior when used on older runtimes. Hence, there is significant motivation for doing this feature as part of Swift 4. Even if we waited to introduce conditional conformances, we would want to include a hook in the runtime to allow them to be implemented later, to avoid future backward-compatibility issues.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#alternatives-considered&gt;Alternatives considered<br></p><p>The most common request related to conditional conformances is to allow a (constrained) protocol extension to declare conformance to a protocol. For example:<br></p><p>extension Collection: Equatable where Iterator.Element: Equatable {<br>  static func ==(lhs: Self, rhs: Self) -&gt; Bool {<br>    // ...<br>  }<br>}<br>This protocol extension will make any Collection of Equatable elements Equatable, which is a powerful feature that could be put to good use. Introducing conditional conformances for protocol extensions would exacerbate the problem of overlapping conformances, because it would be unreasonable to say that the existence of the above protocol extension means that no type that conforms to Collection could declare its own conformance to Equatable, conditional or otherwise.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160926/45a7e74b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>September 26, 2016 at 08:00:00pm</p></header><div class="content"><p>+1.  I have one purely bureaucratic concern that I couldn&#39;t quite find answers to on a read through:<br></p><p>Orphan instances and more generally cross-module uniqueness of instances are not mentioned.  What&#39;s the policy here?  Are we locally unique with respect to imported modules or globally unique with respect to all importable modules?<br></p><p>~Robert Widmann<br></p><p>2016/09/26 20:18、Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; Conditional conformances<br>&gt; Proposal: SE-NNNN<br>&gt; Author: Doug Gregor<br>&gt; Review Manager: TBD<br>&gt; Status: Awaiting review<br>&gt; During the review process, add the following fields as needed:<br>&gt; <br>&gt; Decision Notes: Rationale, Additional Commentary<br>&gt; Bugs: SR-NNNN, SR-MMMM<br>&gt; Previous Revision: 1<br>&gt; Previous Proposal: SE-XXXX<br>&gt; Introduction<br>&gt; <br>&gt; Conditional conformances express the notion that a generic type will conform to a particular protocol only when it&#39;s type arguments meet certain requirements. For example, the Array collection can implement the Equatable protocol only when its elements are themselves Equatable, which can be expressed via the following conditional conformance on Equatable:<br>&gt; <br>&gt; extension Array: Equatable where Element: Equatable {<br>&gt;   static func ==(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { ... }<br>&gt; }<br>&gt; This feature is part of the generics manifesto because it&#39;s something that fits naturally into the generics model and is expected to have a high impact on the Swift standard library.<br>&gt; <br>&gt; Swift-evolution thread: TBD: Discussion thread topic for that proposal<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Conditional conformances address a hole in the composability of the generics system. Continuing the Array example from above, it&#39;s always been the case that one could use the == operator on two arrays of Equatable type, e.g., [Int]() == [Int]() would succeed. However, it doesn&#39;t compose: arrays of arrays of Equatable types cannot be compared (e.g.,[Int]== [Int]will fail to compile) because, even though there is an==for arrays of Equatabletype, the arrays themselves are neverEquatable`.<br>&gt; <br>&gt; Conditional conformances are particularly powerful when building generic adapter types, which are intended to reflect the capabilities of their type arguments. For example, consider the &quot;lazy&quot; functionality of the Swift standard library&#39;s collections: using the lazy member of a sequence produces a lazy adapter that conforms to the Sequence protocol, while using the lazy member of a collection produces a lazy adapter that conforms to the Collection protocol. In Swift 3, the only way to model this is with different types. For example, the Swift standard library has four similar generic types to handle a lazy collection: LazySequence, LazyCollection, LazyBidirectionalCollection, and LazyRandomAccessCollection. The Swift standard library uses overloading of the lazy property to decide among these:<br>&gt; <br>&gt; extension Sequence {<br>&gt;   var lazy: LazySequence&lt;Self&gt; { ... }<br>&gt; }<br>&gt; <br>&gt; extension Collection {<br>&gt;   var lazy: LazyCollection&lt;Self&gt; { ... }<br>&gt; }<br>&gt; <br>&gt; extension BidirectionalCollection {<br>&gt;   var lazy: LazyBidirectionalCollection&lt;Self&gt; { ... }<br>&gt; }<br>&gt; <br>&gt; extension RandomAccessCollection {<br>&gt;   var lazy: LazyRandomAccessCollection&lt;Self&gt; { ... }<br>&gt; }<br>&gt; This approach causes an enormous amount of repetition, and doesn&#39;t scale well because each more-capable type has to re-implement (or somehow forward the implementation of) all of the APIs of the less-capable versions. With conditional conformances, one can provide a single generic wrapper type whose basic requirements meet the lowest common denominator (e.g., Sequence), but which scale their capabilities with their type argument (e.g., the LazySequence conforms to Collection when the type argument does, and so on).<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; In a nutshell, the proposed solution is to allow a constrained extension of a struct, enum, or class to declare protocol conformances. No additional syntax is necessary for this change, because it already exists in the grammar; rather, this proposal removes the limitation that results in the following error:<br>&gt; <br>&gt; t.swift:1:1: error: extension of type &#39;Array&#39; with constraints cannot have an inheritance clause<br>&gt; extension Array: Equatable where Element: Equatable { }<br>&gt; ^                ~~~~~~~~~<br>&gt; Conditional conformances can only be used when the additional requirements of the constrained extension are satisfied. For example, given the aforementioned Array conformance to Equatable:<br>&gt; <br>&gt; func f&lt;T: Equatable&gt;(_: T) { ... }<br>&gt; <br>&gt; struct NotEquatable { }<br>&gt; <br>&gt; func test(a1: [Int], a2: [NotEquatable]) {<br>&gt;   f(a1)    // okay: [Int] conforms to Equatable because Int conforms to Equatable<br>&gt;   f(a2)    // error: [NotEquatable] does not conform to Equatable because NotEquatable has no conformance to Equatable<br>&gt; }<br>&gt; Conditional conformances also have a run-time aspect, because a dynamic check for a protocol conformance might rely on the evaluation of the extra requirements needed to successfully use a conditional conformance. For example:<br>&gt; <br>&gt; protocol P {<br>&gt;   func doSomething()<br>&gt; }<br>&gt; <br>&gt; struct S: P {<br>&gt;   func doSomething() { print(&quot;S&quot;) }<br>&gt; }<br>&gt; <br>&gt; // Array conforms to P if it&#39;s element type conforms to P<br>&gt; extension Array: P where Element: P {<br>&gt;   func doSomething() {<br>&gt;     for value in self {<br>&gt;       value.doSomething()<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; // Dynamically query and use conformance to P.<br>&gt; func doSomethingIfP(_ value: Any) {<br>&gt;   if let p = value as? P {<br>&gt;     p.doSomething()<br>&gt;   } else {<br>&gt;     print(&quot;Not a P&quot;)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; doSomethingIfP([S(), S(), S()]) // prints &quot;S&quot; three times<br>&gt; doSomethingIfP([1, 2, 3])       // prints &quot;Not a P&quot;<br>&gt; The if-let in doSomethingIfP(_:) dynamically queries whether the type stored in value conforms to the protocol P. In the case of an Array, that conformance is conditional, which requires another dynamic lookup to determine whether the element type conforms to P: in the first call to doSomethingIfP(_:), the lookup finds the conformance of S to P. In the second case, there is no conformance of Int to P, so the conditional conformance cannot be used. The desire for this dynamic behavior motivates some of the design decisions in this proposal.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; Most of the semantics of conditional conformances are obvious. However, there are a number of issues (mostly involving multiple conformances) that require more in-depth design.<br>&gt; <br>&gt; Disallow overlapping conformances<br>&gt; <br>&gt; With conditional conformances, it is possible to express that a given generic type can conform to the same protocol in two different ways, depending on the capabilities of its type arguments. For example:<br>&gt; <br>&gt; struct SomeWrapper&lt;Wrapped&gt; {<br>&gt;   let wrapped: Wrapped<br>&gt; }<br>&gt; <br>&gt; protocol HasIdentity {<br>&gt;   static func ===(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; extension SomeWrapper: Equatable where Wrapped: Equatable {<br>&gt;   static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>&gt;     return lhs.wrapped == rhs.wrapped<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; extension SomeWrapper: Equatable where Wrapped: HasIdentity {<br>&gt;   static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>&gt;     return lhs.wrapped === rhs.wrapped<br>&gt;   }<br>&gt; }<br>&gt; Note that, for an arbitrary type T, there are four potential answers to the question of whether SomeWrapper&lt;T&gt; conforms to Equatable:<br>&gt; <br>&gt; No, it does not conform because T is neither Equatable nor HasIdentity.<br>&gt; Yes, it conforms via the first extension of SomeWrapper because T conforms to Equatable.<br>&gt; Yes, it conforms via the second extension of SomeWrapper because T conforms to HasIdentity.<br>&gt; Ambiguity, because T conforms to both Equatable and HasIdentity.<br>&gt; It is due to the possibility of #4 occurring that we refer to the two conditional conformances in the example as overlapping. There are designs that would allow one to address the ambiguity, for example, by writing a third conditional conformance that addresses #4:<br>&gt; <br>&gt; // Possible tie-breaker conformance<br>&gt; extension SomeWrapper: Equatable where Wrapped: Equatable &amp; HasIdentity, {<br>&gt;   static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>&gt;     return lhs.wrapped == rhs.wrapped<br>&gt;   }<br>&gt; }<br>&gt; The design is consistent, because this third conditional conformance is more specialized the either of the first two conditional conformances, meaning that its requirements are a strict superset of the requirements of those two conditional conformances. However, there are a few downsides to such a system:<br>&gt; <br>&gt; To address all possible ambiguities, one has to write a conditional conformance for every plausible combination of overlapping requirements. To statically resolve all ambiguities, one must also cover nonsensical combinations where the two requirements are mutually exclusive (or invent a way to state mutual-exclusivity).<br>&gt; It is no longer possible to uniquely say what is required to make a generic type conform to a protocol, because there might be several unrelated possibilities. This makes reasoning about the whole system more complex, because it admits divergent interfaces for the same generic type based on their type arguments. At its extreme, this invites the kind of cleverness we&#39;ve seen in the C++ community with template metaprogramming, which is something Swift has sought to avoid.<br>&gt; All of the disambiguation machinery required at compile time (e.g., to determine whether one conditional conformance is more specialized than another to order them) also needs to implements in the run-time, as part of the dynamic casting machinery. One must also address the possibility of ambiguities occurring at run-time. This is both a sharp increase in the complexity of the system and a potential run-time performance hazard.<br>&gt; For these reasons, this proposal bans overlapping conformances entirely. While the resulting system is less flexible than one that allowed overlapping conformances, the gain in simplicity in this potentially-confusing area is well worth the cost. Moreover, this ban follows with existing Swift rules regarding multiple conformances, which prohibit the same type from conforming to the same protocol in two different ways:<br>&gt; <br>&gt; protocol P { }<br>&gt; <br>&gt; struct S : P { }<br>&gt; extension S : P { } // error: S already conforms to P<br>&gt; Implied conditional conformances<br>&gt; <br>&gt; Stating conformance to a protocol implicitly states conformances to any of the protocols that it inherits. This is the case in Swift today, although most developers likely don&#39;t realize the rules it follows. For example:<br>&gt; <br>&gt; protocol P { }<br>&gt; protocol Q : P { }<br>&gt; protocol R : P { }<br>&gt; <br>&gt; struct X1 { }<br>&gt; struct X2 { }<br>&gt; struct X3 { }<br>&gt; <br>&gt; extension X1: Q { }  // implies conformance to P<br>&gt; <br>&gt; extension X2: Q { }  // would imply conformance to P, but...<br>&gt; extension X2: P { }  // explicitly-stated conformance to P &quot;wins&quot;<br>&gt; <br>&gt; extension X3: Q { }  // implies conformance to P<br>&gt; extension X3: R { }  // also implies conformance to P<br>&gt;                      // one will &quot;win&quot;; which is unspecified<br>&gt; With conditional conformances, the question of which extension &quot;wins&quot; the implied conformance begins to matter, because the extensions might have different constraints on them. For example:<br>&gt; <br>&gt; struct X4&lt;T&gt; { }<br>&gt; <br>&gt; extension X4: Q where T: Q { }  // implies conformance to P<br>&gt; extension X4: R where T: R { }  // error: implies overlapping conformance to P<br>&gt; Both of these constrained extensions imply a conformance to P, but the actual P implied conformances to P are overlapping and, therefore, result in an error.<br>&gt; <br>&gt; However, in cases where there is a reasonable ordering between the two constrained extensions (i.e., one is more specialized than the other), the less specialized constrained extension should &quot;win&quot; the implied conformance. Continuing the example from above:<br>&gt; <br>&gt; protocol S: R { }<br>&gt; <br>&gt; struct X5&lt;T&gt; { }<br>&gt; <br>&gt; extension X5: R where T: R { }  // &quot;wins&quot; implied conformance to P, because<br>&gt; extension X5: S where T: S { }  // the extension where &quot;T: S&quot; is more specialized<br>&gt;                                 // than the one where &quot;T: R&quot;<br>&gt; Thus, the rule for placing implied conformances is to pick the least specialized extension that implies the conformance. If there is more than one such extension, then either:<br>&gt; <br>&gt; All such extensions are not constrained extensions (i.e., they have no requirements beyond what the type requires), in which case Swift can continue to choose arbitrarily among the extensions, or<br>&gt; All such extensions are constrained extensions, in which case the program is ill-formed due to the ambiguity. The developer can explicitly specify conformance to the protocol to disambiguate. <br>&gt; Overloading across constrained extensions<br>&gt; <br>&gt; One particularly important aspect of the placement rule for implied conformances is that it affects which declarations are used to satisfy a particular requirement. For example:<br>&gt; <br>&gt; protocol P {<br>&gt;   func f()<br>&gt; }<br>&gt; <br>&gt; protocol Q: P { }<br>&gt; protocol R: Q { }<br>&gt; <br>&gt; struct X1&lt;T&gt; { }<br>&gt; <br>&gt; extension X1: Q where T: Q {           // note: implied conformance to P here<br>&gt;   func f() {<br>&gt;     // #1: basic implementation of &#39;f()&#39;<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; extension X1: R where T: R {<br>&gt;   func f() {<br>&gt;     // #2: superfast implementation of f() using some knowledge of &#39;R&#39;<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; struct X2: R {<br>&gt;   func f() { }<br>&gt; }<br>&gt; <br>&gt; (X1&lt;X2&gt;() as P).f() // calls #1, which was used to satisfy the requirement for &#39;f&#39;<br>&gt; X1&lt;X2&gt;().f()        // calls #2, which is preferred by overload resolution<br>&gt; Effectively, when satisfying a protocol requirement, one can only choose from members of the type that are guaranteed to available within the extension with which the conformance is associated. In this case, the conformance to P is placed on the first extension of X1, so the only f() that can be considered is the f() within that extension: the f() in the second extension won&#39;t necessarily always be available, because T may not conform to R. Hence, the call that treats an X1&lt;X2&gt;as a P gets the first implementation of X1.f(). When using the concrete type X1&lt;X2&gt;, where X2 conforms to R, both X.f() implementations are visible... and the second is more specialized.<br>&gt; <br>&gt; Technically, this issue is no different from surprises where (e.g.) a member added to a concrete type in a different module won&#39;t affect an existing protocol conformance. The existing ideas to mediate these problems---warning for nearly-matching functions when they are declared in concrete types, for example---will likely be sufficient to help surprised users. That said, this proposal may increase the likelihood of such problems showing up.<br>&gt; <br>&gt; Source compatibility<br>&gt; <br>&gt; From the language perspective, conditional conformances are purely additive. They introduce no new syntax, but instead provide semantics for existing syntax---an extension that both declares a protocol conformance and has a where clause---whose use currently results in a type checker failure. That said, this is a feature that is expected to be widely adopted within the Swift standard library, which may indirectly affect source compatibility.<br>&gt; <br>&gt; Effect on ABI Stability<br>&gt; <br>&gt; As noted above, there are a number of places where the standard library is expected to adopt this feature, which fall into two classes:<br>&gt; <br>&gt; Improve composability: the example in the introduction made Array conform to Equatable when its element type does; there are many places in the Swift standard library that could benefit from this form of conditional conformance, particularly so that collections and other types that contain values (e.g., Optional) can compose better with generic algorithms. Most of these changes won&#39;t be ABI- or source-breaking, because they&#39;re additive.<br>&gt; Eliminating repetition: the lazy wrappers described in the motivation section could be collapsed into a single wrapper with several conditional conformances. A similar refactoring could also be applied to the range abstractions and slice types in the standard library, making the library itself simpler and smaller. All of these changes are potentially source-breaking and ABI-breaking, because they would remove types that could be used in Swift 3 code. However, there are mitigations: generic typealiases could provide source compatibility to Swift 3 clients, and the ABI-breaking aspect is only relevant if conditional conformances and the standard library changes they imply aren&#39;t part of Swift 4.<br>&gt; Aside from the standard library, conditional conformances have an impact on the Swift runtime, which will require specific support to handle dynamic casting. If that runtime support is not available once ABI stability has been declared, then introducing conditional conformances in a later language version either means the feature cannot be deployed backward or that it would provide only more limited, static behavior when used on older runtimes. Hence, there is significant motivation for doing this feature as part of Swift 4. Even if we waited to introduce conditional conformances, we would want to include a hook in the runtime to allow them to be implemented later, to avoid future backward-compatibility issues.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; The most common request related to conditional conformances is to allow a (constrained) protocol extension to declare conformance to a protocol. For example:<br>&gt; <br>&gt; extension Collection: Equatable where Iterator.Element: Equatable {<br>&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;     // ...<br>&gt;   }<br>&gt; }<br>&gt; This protocol extension will make any Collection of Equatable elements Equatable, which is a powerful feature that could be put to good use. Introducing conditional conformances for protocol extensions would exacerbate the problem of overlapping conformances, because it would be unreasonable to say that the existence of the above protocol extension means that no type that conforms to Collection could declare its own conformance to Equatable, conditional or otherwise.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160926/3c5c2d85/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>September 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Sep 26, 2016, at 5:37 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1.  I have one purely bureaucratic concern that I couldn&#39;t quite find answers to on a read through:<br>&gt; <br>&gt; Orphan instances and more generally cross-module uniqueness of instances are not mentioned.  What&#39;s the policy here?  Are we locally unique with respect to imported modules or globally unique with respect to all importable modules?<br></p><p>We fundamentally can&#39;t guarantee cross-module uniqueness of instances, since we allow arbitrary post-hoc conformance. For the most part, we don&#39;t have to, since most operations that require a protocol conformance are able to statically select one at compile-time, and the conformance becomes an implicit part of the parameterization of any generic functions or types that require it. The main problem overlapping conformances pose is for dynamic casts, since the &#39;x as? P&#39; operation has no static context by which to pick a conformance if there are multiple possibilities for the dynamic type of x to conform to P.<br></p><p>-Joe<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Sep 26, 2016, at 5:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; +1.  I have one purely bureaucratic concern that I couldn&#39;t quite find answers to on a read through:<br>&gt; <br>&gt; Orphan instances<br></p><p>Not sure what you mean by “orphan instances”?<br></p><p>&gt; and more generally cross-module uniqueness of instances are not mentioned.  What&#39;s the policy here?  Are we locally unique with respect to imported modules or globally unique with respect to all importable modules?<br></p><p>Yeah, this is a painfully underspecified area of Swift’s generics system. The compiler diagnoses redundant conformances when it sees both conformances, but that’s not enough to guarantee global uniqueness. The runtime effectively depends on global uniqueness, and there are no mechanisms in the language or runtime to disambiguate if the non-unique conformances occur.<br></p><p>We’re not in an ideal state, although I don’t think the conditional conformances proposal is the place to try to fix it. Personally, I think we should codify the globally-unique model and provide some level of safety in the runtime to detect (lazily) when there is a run-time conflict. It’s probably worthy of a proposal, although it would be an odd sort of proposal—mostly about describing the model and the trade-offs (no private conformances, potential for run-time oddities if a conflict does occur, etc.) vs. allowing multiple conformances to co-exist (dynamic-casting complexity, the need for a disambiguation mechanism, etc.). At most, we could make it clearer in source code when you’re doing something that *could* cause a runtime conflict. For example, writing a conformance in the module that defines the type or the module that defines the protocol is guaranteed to be okay (modulo resilience!), but a retroactive conformance in a third model is potentially unsafe and might be worthy of some kind of attribute.<br></p><p>Anyway, some random thoughts on this issue are in the generics manifesto:<br></p><p>	https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#private-conformances<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/09/26 20:18、Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; Conditional conformances<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/NNNN-conditional-conformances.md&gt;<br>&gt;&gt; Author: Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt; Review Manager: TBD<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; During the review process, add the following fields as needed:<br>&gt;&gt; <br>&gt;&gt; Decision Notes: Rationale &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;, Additional Commentary &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;&gt; Bugs: SR-NNNN &lt;https://bugs.swift.org/browse/SR-NNNN&gt;, SR-MMMM &lt;https://bugs.swift.org/browse/SR-MMMM&gt;<br>&gt;&gt; Previous Revision: 1 &lt;https://github.com/apple/swift-evolution/blob/...commit-ID.../proposals/NNNN-filename.md&gt;<br>&gt;&gt; Previous Proposal: SE-XXXX &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/XXXX-filename.md&gt;<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#introduction&gt;[snip[<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160927/f613a348/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>September 27, 2016 at 05:00:00pm</p></header><div class="content"><p>Great job thinking this all through (as usual), and I’ll be very happy to have Optional and Array become Equatable. Here’s some of my thoughts on the library evolution aspect of this:<br></p><p>- Removing a conditional conformance isn’t allowed, obviously.<br>- Adding a conditional conformance is just like adding an unconditional conformance—it needs availability info.<br>- It would be nice™ if making a conditional conformance more general was allowed. Since the plan doesn&#39;t allow overlapping conformances, I think this is actually implementable: just don’t put the constraints in the symbol name. I don’t know how to represent the backwards-deploying aspects of this right now, so it probably makes sense to forbid it today, but I think it would be nice if the implementation left the door open.<br></p><p>On that note, what happens here?<br></p><p>// Module Lib<br>public protocol Base {}<br>public protocol Sub: Base {}<br>public protocol Special: Sub {}<br></p><p>public struct Impl&lt;T&gt; {}<br>extension Impl: Special where T: Special {}<br></p><p><br>// Module Client<br>import Lib<br></p><p>extension Impl: Sub where T: Sub {}<br></p><p>I think this gets rejected because Impl already has a conformance to Sub—the extension in Client, despite being less specialized, shows up too late to actually declare this conformance “better”. Is that correct?<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160927/ee3a63f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>September 28, 2016 at 12:00:00pm</p></header><div class="content"><p>I find the limitation of non-intersection of conditional conformance<br>reqirements quite limiting. Can it be lifted in case there are no<br>overloaded functions between extensions?<br></p><p>protocol A { func foo() }<br>protocol B { func bar() }<br></p><p>extension Array: A where Element: A {<br>    func foo() { return self.first!.foo() }<br>}<br>extension Array: B where Element: B {<br>    func bar() { return self.first!.bar() }<br>}<br></p><p>let arr: Array&lt;T&gt;<br>arr.foo()<br></p><p>What is ambiguous here? When we see arr.foo(), we know it&#39;s from Array: A<br>extension, regardless of T, and we just have to check the requirement of<br>that extension.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/584d3aee/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September 28, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Sep 28, 2016, at 2:55 AM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt; <br>&gt; I find the limitation of non-intersection of conditional conformance reqirements quite limiting. Can it be lifted in case there are no overloaded functions between extensions?<br>&gt; <br>&gt; protocol A { func foo() }<br>&gt; protocol B { func bar() }<br>&gt; <br>&gt; extension Array: A where Element: A {<br>&gt;     func foo() { return self.first!.foo() }<br>&gt; }<br>&gt; extension Array: B where Element: B {<br>&gt;     func bar() { return self.first!.bar() }<br>&gt; }<br>&gt; <br>&gt; let arr: Array&lt;T&gt;<br>&gt; arr.foo()<br>&gt; <br>&gt; What is ambiguous here?<br></p><p>Nothing. These conformances are not overlapping, because A and B are independent protocols. The first extension declares a conditional conformance to A, the second declares a conditional conformance to B.<br></p><p>	- Doug<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September 28, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Sep 27, 2016, at 5:06 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Great job thinking this all through (as usual), and I’ll be very happy to have Optional and Array become Equatable. Here’s some of my thoughts on the library evolution aspect of this:<br>&gt; <br>&gt; - Removing a conditional conformance isn’t allowed, obviously.<br>&gt; - Adding a conditional conformance is just like adding an unconditional conformance—it needs availability info.<br></p><p>Right. The main wrinkle I see here is that, when you add a conditional conformance, you will effectively end up with overlapping conformances when running an old application against a new library. Do you want me to capture these cases in the proposal in a section on “Resilience” or “Library Evolution”, like I’ve tried to capture the effect on ABI Stability? (I think that makes sense)<br></p><p>&gt; - It would be nice™ if making a conditional conformance more general was allowed. Since the plan doesn&#39;t allow overlapping conformances, I think this is actually implementable: just don’t put the constraints in the symbol name. I don’t know how to represent the backwards-deploying aspects of this right now, so it probably makes sense to forbid it today, but I think it would be nice if the implementation left the door open.<br></p><p>Yeah. It’s a different set of witness tables that one would need to gather to use the conditional conformance in the newer version of the library vs. in an older version of a library. That’s okay if we leave the witness-table-gathering to the runtime, but not so great if we statically provide the witness tables.<br></p><p><br>&gt; On that note, what happens here?<br>&gt; <br>&gt; // Module Lib<br>&gt; public protocol Base {}<br>&gt; public protocol Sub: Base {}<br>&gt; public protocol Special: Sub {}<br>&gt; <br>&gt; public struct Impl&lt;T&gt; {}<br>&gt; extension Impl: Special where T: Special {}<br>&gt; <br>&gt; <br>&gt; // Module Client<br>&gt; import Lib<br>&gt; <br>&gt; extension Impl: Sub where T: Sub {}<br>&gt; <br>&gt; I think this gets rejected because Impl already has a conformance to Sub—the extension in Client, despite being less specialized, shows up too late to actually declare this conformance “better”. Is that correct?<br></p><p>Correct. Impl has a conformance to ‘Sub’ in Lib; Client cannot declare a new one, because it overlaps.  Had all of this code been in one module, it would be well-formed, because the implied conformance to ’Sub’ in the first extension would lose to the explicit conformance to Sub in the second (less-specialized) extension.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/41985c11/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>September 28, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On 28 Sep 2016, at 17:51, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 27, 2016, at 5:06 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Great job thinking this all through (as usual), and I’ll be very happy to have Optional and Array become Equatable. Here’s some of my thoughts on the library evolution aspect of this:<br>&gt;&gt; <br>&gt;&gt; - Removing a conditional conformance isn’t allowed, obviously.<br>&gt;&gt; - Adding a conditional conformance is just like adding an unconditional conformance—it needs availability info.<br>&gt; <br>&gt; Right. The main wrinkle I see here is that, when you add a conditional conformance, you will effectively end up with overlapping conformances when running an old application against a new library. Do you want me to capture these cases in the proposal in a section on “Resilience” or “Library Evolution”, like I’ve tried to capture the effect on ABI Stability? (I think that makes sense)<br>&gt; <br>&gt;&gt; - It would be nice™ if making a conditional conformance more general was allowed. Since the plan doesn&#39;t allow overlapping conformances, I think this is actually implementable: just don’t put the constraints in the symbol name. I don’t know how to represent the backwards-deploying aspects of this right now, so it probably makes sense to forbid it today, but I think it would be nice if the implementation left the door open.<br>&gt; <br>&gt; Yeah. It’s a different set of witness tables that one would need to gather to use the conditional conformance in the newer version of the library vs. in an older version of a library. That’s okay if we leave the witness-table-gathering to the runtime, but not so great if we statically provide the witness tables.<br>&gt; <br></p><p>Would this be a case in which the win by having this feature and letting the runtime gather the witness tables offset the losses from doing his operations at runtime? I would like to think that in cases like this there is at least the option to opt for more flexibility.<br></p><p>&gt; <br>&gt;&gt; On that note, what happens here?<br>&gt;&gt; <br>&gt;&gt; // Module Lib<br>&gt;&gt; public protocol Base {}<br>&gt;&gt; public protocol Sub: Base {}<br>&gt;&gt; public protocol Special: Sub {}<br>&gt;&gt; <br>&gt;&gt; public struct Impl&lt;T&gt; {}<br>&gt;&gt; extension Impl: Special where T: Special {}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // Module Client<br>&gt;&gt; import Lib<br>&gt;&gt; <br>&gt;&gt; extension Impl: Sub where T: Sub {}<br>&gt;&gt; <br>&gt;&gt; I think this gets rejected because Impl already has a conformance to Sub—the extension in Client, despite being less specialized, shows up too late to actually declare this conformance “better”. Is that correct?<br>&gt; <br>&gt; Correct. Impl has a conformance to ‘Sub’ in Lib; Client cannot declare a new one, because it overlaps.  Had all of this code been in one module, it would be well-formed, because the implied conformance to ’Sub’ in the first extension would lose to the explicit conformance to Sub in the second (less-specialized) extension.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/8bb5eaa0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September 28, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Sep 28, 2016, at 11:40 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On 28 Sep 2016, at 17:51, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 27, 2016, at 5:06 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Great job thinking this all through (as usual), and I’ll be very happy to have Optional and Array become Equatable. Here’s some of my thoughts on the library evolution aspect of this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Removing a conditional conformance isn’t allowed, obviously.<br>&gt;&gt;&gt; - Adding a conditional conformance is just like adding an unconditional conformance—it needs availability info.<br>&gt;&gt; <br>&gt;&gt; Right. The main wrinkle I see here is that, when you add a conditional conformance, you will effectively end up with overlapping conformances when running an old application against a new library. Do you want me to capture these cases in the proposal in a section on “Resilience” or “Library Evolution”, like I’ve tried to capture the effect on ABI Stability? (I think that makes sense)<br>&gt;&gt; <br>&gt;&gt;&gt; - It would be nice™ if making a conditional conformance more general was allowed. Since the plan doesn&#39;t allow overlapping conformances, I think this is actually implementable: just don’t put the constraints in the symbol name. I don’t know how to represent the backwards-deploying aspects of this right now, so it probably makes sense to forbid it today, but I think it would be nice if the implementation left the door open.<br>&gt;&gt; <br>&gt;&gt; Yeah. It’s a different set of witness tables that one would need to gather to use the conditional conformance in the newer version of the library vs. in an older version of a library. That’s okay if we leave the witness-table-gathering to the runtime, but not so great if we statically provide the witness tables.<br>&gt;&gt; <br>&gt; <br>&gt; Would this be a case in which the win by having this feature and letting the runtime gather the witness tables offset the losses from doing his operations at runtime? I would like to think that in cases like this there is at least the option to opt for more flexibility.<br></p><p><br>I’m sure we can find a reasonable solution to this that doesn’t incur a significant runtime penalty, e.g., by teaching the runtime conformance specialization machinery to handle a “redirecting” specialization that maps from the requirements of the older (more specialized) version to the requirements of the newer (less specialized) version.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/2139c5e6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>September 28, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On 28 Sep 2016, at 19:45, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 28, 2016, at 11:40 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 28 Sep 2016, at 17:51, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sep 27, 2016, at 5:06 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Great job thinking this all through (as usual), and I’ll be very happy to have Optional and Array become Equatable. Here’s some of my thoughts on the library evolution aspect of this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Removing a conditional conformance isn’t allowed, obviously.<br>&gt;&gt;&gt;&gt; - Adding a conditional conformance is just like adding an unconditional conformance—it needs availability info.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right. The main wrinkle I see here is that, when you add a conditional conformance, you will effectively end up with overlapping conformances when running an old application against a new library. Do you want me to capture these cases in the proposal in a section on “Resilience” or “Library Evolution”, like I’ve tried to capture the effect on ABI Stability? (I think that makes sense)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - It would be nice™ if making a conditional conformance more general was allowed. Since the plan doesn&#39;t allow overlapping conformances, I think this is actually implementable: just don’t put the constraints in the symbol name. I don’t know how to represent the backwards-deploying aspects of this right now, so it probably makes sense to forbid it today, but I think it would be nice if the implementation left the door open.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah. It’s a different set of witness tables that one would need to gather to use the conditional conformance in the newer version of the library vs. in an older version of a library. That’s okay if we leave the witness-table-gathering to the runtime, but not so great if we statically provide the witness tables.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Would this be a case in which the win by having this feature and letting the runtime gather the witness tables offset the losses from doing his operations at runtime? I would like to think that in cases like this there is at least the option to opt for more flexibility.<br>&gt; <br>&gt; <br>&gt; I’m sure we can find a reasonable solution to this that doesn’t incur a significant runtime penalty, e.g., by teaching the runtime conformance specialization machinery to handle a “redirecting” specialization that maps from the requirements of the older (more specialized) version to the requirements of the newer (less specialized) version.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br></p><p>Very glad to hear that Doug :).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/e84b4c97/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>September 28, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Sep 28, 2016, at 9:51, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 27, 2016, at 5:06 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Great job thinking this all through (as usual), and I’ll be very happy to have Optional and Array become Equatable. Here’s some of my thoughts on the library evolution aspect of this:<br>&gt;&gt; <br>&gt;&gt; - Removing a conditional conformance isn’t allowed, obviously.<br>&gt;&gt; - Adding a conditional conformance is just like adding an unconditional conformance—it needs availability info.<br>&gt; <br>&gt; Right. The main wrinkle I see here is that, when you add a conditional conformance, you will effectively end up with overlapping conformances when running an old application against a new library. Do you want me to capture these cases in the proposal in a section on “Resilience” or “Library Evolution”, like I’ve tried to capture the effect on ABI Stability? (I think that makes sense)<br></p><p>Sure, yes please. (I think the main point is that the &quot;conditional&quot; doesn&#39;t make a difference here.)<br></p><p><br>&gt; <br>&gt;&gt; - It would be nice™ if making a conditional conformance more general was allowed. Since the plan doesn&#39;t allow overlapping conformances, I think this is actually implementable: just don’t put the constraints in the symbol name. I don’t know how to represent the backwards-deploying aspects of this right now, so it probably makes sense to forbid it today, but I think it would be nice if the implementation left the door open.<br>&gt; <br>&gt; Yeah. It’s a different set of witness tables that one would need to gather to use the conditional conformance in the newer version of the library vs. in an older version of a library. That’s okay if we leave the witness-table-gathering to the runtime, but not so great if we statically provide the witness tables.<br></p><p>This confuses me. Why aren&#39;t we just using the minimal (unconditional) conformance representation, and then pulling the associated type witness tables out dynamically? Is that significantly more expensive? (Am I just missing something?)<br></p><p><br>&gt; <br>&gt; <br>&gt;&gt; On that note, what happens here?<br>&gt;&gt; <br>&gt;&gt; // Module Lib<br>&gt;&gt; public protocol Base {}<br>&gt;&gt; public protocol Sub: Base {}<br>&gt;&gt; public protocol Special: Sub {}<br>&gt;&gt; <br>&gt;&gt; public struct Impl&lt;T&gt; {}<br>&gt;&gt; extension Impl: Special where T: Special {}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // Module Client<br>&gt;&gt; import Lib<br>&gt;&gt; <br>&gt;&gt; extension Impl: Sub where T: Sub {}<br>&gt;&gt; <br>&gt;&gt; I think this gets rejected because Impl already has a conformance to Sub—the extension in Client, despite being less specialized, shows up too late to actually declare this conformance “better”. Is that correct?<br>&gt; <br>&gt; Correct. Impl has a conformance to ‘Sub’ in Lib; Client cannot declare a new one, because it overlaps.  Had all of this code been in one module, it would be well-formed, because the implied conformance to ’Sub’ in the first extension would lose to the explicit conformance to Sub in the second (less-specialized) extension.<br></p><p>Thanks!<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/996cc3d0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September 28, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Sep 28, 2016, at 1:23 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 28, 2016, at 9:51, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 27, 2016, at 5:06 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Great job thinking this all through (as usual), and I’ll be very happy to have Optional and Array become Equatable. Here’s some of my thoughts on the library evolution aspect of this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Removing a conditional conformance isn’t allowed, obviously.<br>&gt;&gt;&gt; - Adding a conditional conformance is just like adding an unconditional conformance—it needs availability info.<br>&gt;&gt; <br>&gt;&gt; Right. The main wrinkle I see here is that, when you add a conditional conformance, you will effectively end up with overlapping conformances when running an old application against a new library. Do you want me to capture these cases in the proposal in a section on “Resilience” or “Library Evolution”, like I’ve tried to capture the effect on ABI Stability? (I think that makes sense)<br>&gt; <br>&gt; Sure, yes please. (I think the main point is that the &quot;conditional&quot; doesn&#39;t make a difference here.)<br></p><p>Done in the updated form of this proposal.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; - It would be nice™ if making a conditional conformance more general was allowed. Since the plan doesn&#39;t allow overlapping conformances, I think this is actually implementable: just don’t put the constraints in the symbol name. I don’t know how to represent the backwards-deploying aspects of this right now, so it probably makes sense to forbid it today, but I think it would be nice if the implementation left the door open.<br>&gt;&gt; <br>&gt;&gt; Yeah. It’s a different set of witness tables that one would need to gather to use the conditional conformance in the newer version of the library vs. in an older version of a library. That’s okay if we leave the witness-table-gathering to the runtime, but not so great if we statically provide the witness tables.<br>&gt; <br>&gt; This confuses me. Why aren&#39;t we just using the minimal (unconditional) conformance representation, and then pulling the associated type witness tables out dynamically? Is that significantly more expensive? (Am I just missing something?)<br></p><p>Dynamically looking up witness tables isn’t cheap. Still, we’ll find the right tradeoff here.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/262f9016/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>September 28, 2016 at 03:00:00pm</p></header><div class="content"><p>It’s good to see this starting to happen!<br></p><p>Is the decision on &quot;no-overlapping-conformances” something that’s seen-as set in stone permanently, set in stone for the near future, or perhaps at least somewhat open to reconsideration at the present moment?<br></p><p>&gt; On Sep 26, 2016, at 7:18 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Conditional conformances<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/NNNN-conditional-conformances.md&gt;<br>&gt; Author: Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt; Review Manager: TBD<br>&gt; Status: Awaiting review<br>&gt; During the review process, add the following fields as needed:<br>&gt; <br>&gt; Decision Notes: Rationale &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;, Additional Commentary &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt; Bugs: SR-NNNN &lt;https://bugs.swift.org/browse/SR-NNNN&gt;, SR-MMMM &lt;https://bugs.swift.org/browse/SR-MMMM&gt;<br>&gt; Previous Revision: 1 &lt;https://github.com/apple/swift-evolution/blob/...commit-ID.../proposals/NNNN-filename.md&gt;<br>&gt; Previous Proposal: SE-XXXX &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/XXXX-filename.md&gt;<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#introduction&gt;Introduction<br>&gt; <br>&gt; Conditional conformances express the notion that a generic type will conform to a particular protocol only when it&#39;s type arguments meet certain requirements. For example, the Array collection can implement the Equatable protocol only when its elements are themselves Equatable, which can be expressed via the following conditional conformance on Equatable:<br>&gt; <br>&gt; extension Array: Equatable where Element: Equatable {<br>&gt;   static func ==(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { ... }<br>&gt; }<br>&gt; This feature is part of the generics manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-&gt; because it&#39;s something that fits naturally into the generics model and is expected to have a high impact on the Swift standard library.<br>&gt; <br>&gt; Swift-evolution thread: TBD: Discussion thread topic for that proposal &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#motivation&gt;Motivation<br>&gt; <br>&gt; Conditional conformances address a hole in the composability of the generics system. Continuing the Array example from above, it&#39;s always been the case that one could use the == operator on two arrays of Equatable type, e.g., [Int]() == [Int]() would succeed. However, it doesn&#39;t compose: arrays of arrays of Equatable types cannot be compared (e.g.,[Int] &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals&gt;== [Int] &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals&gt;will fail to compile) because, even though there is an==for arrays of Equatabletype, the arrays themselves are neverEquatable`.<br>&gt; <br>&gt; Conditional conformances are particularly powerful when building generic adapter types, which are intended to reflect the capabilities of their type arguments. For example, consider the &quot;lazy&quot; functionality of the Swift standard library&#39;s collections: using the lazy member of a sequence produces a lazy adapter that conforms to the Sequence protocol, while using the lazy member of a collection produces a lazy adapter that conforms to the Collection protocol. In Swift 3, the only way to model this is with different types. For example, the Swift standard library has four similar generic types to handle a lazy collection: LazySequence, LazyCollection, LazyBidirectionalCollection, and LazyRandomAccessCollection. The Swift standard library uses overloading of the lazy property to decide among these:<br>&gt; <br>&gt; extension Sequence {<br>&gt;   var lazy: LazySequence&lt;Self&gt; { ... }<br>&gt; }<br>&gt; <br>&gt; extension Collection {<br>&gt;   var lazy: LazyCollection&lt;Self&gt; { ... }<br>&gt; }<br>&gt; <br>&gt; extension BidirectionalCollection {<br>&gt;   var lazy: LazyBidirectionalCollection&lt;Self&gt; { ... }<br>&gt; }<br>&gt; <br>&gt; extension RandomAccessCollection {<br>&gt;   var lazy: LazyRandomAccessCollection&lt;Self&gt; { ... }<br>&gt; }<br>&gt; This approach causes an enormous amount of repetition, and doesn&#39;t scale well because each more-capable type has to re-implement (or somehow forward the implementation of) all of the APIs of the less-capable versions. With conditional conformances, one can provide a single generic wrapper type whose basic requirements meet the lowest common denominator (e.g., Sequence), but which scale their capabilities with their type argument (e.g., the LazySequence conforms to Collection when the type argument does, and so on).<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; In a nutshell, the proposed solution is to allow a constrained extension of a struct, enum, or class to declare protocol conformances. No additional syntax is necessary for this change, because it already exists in the grammar; rather, this proposal removes the limitation that results in the following error:<br>&gt; <br>&gt; t.swift:1:1: error: extension of type &#39;Array&#39; with constraints cannot have an inheritance clause<br>&gt; extension Array: Equatable where Element: Equatable { }<br>&gt; ^                ~~~~~~~~~<br>&gt; Conditional conformances can only be used when the additional requirements of the constrained extension are satisfied. For example, given the aforementioned Array conformance to Equatable:<br>&gt; <br>&gt; func f&lt;T: Equatable&gt;(_: T) { ... }<br>&gt; <br>&gt; struct NotEquatable { }<br>&gt; <br>&gt; func test(a1: [Int], a2: [NotEquatable]) {<br>&gt;   f(a1)    // okay: [Int] conforms to Equatable because Int conforms to Equatable<br>&gt;   f(a2)    // error: [NotEquatable] does not conform to Equatable because NotEquatable has no conformance to Equatable<br>&gt; }<br>&gt; Conditional conformances also have a run-time aspect, because a dynamic check for a protocol conformance might rely on the evaluation of the extra requirements needed to successfully use a conditional conformance. For example:<br>&gt; <br>&gt; protocol P {<br>&gt;   func doSomething()<br>&gt; }<br>&gt; <br>&gt; struct S: P {<br>&gt;   func doSomething() { print(&quot;S&quot;) }<br>&gt; }<br>&gt; <br>&gt; // Array conforms to P if it&#39;s element type conforms to P<br>&gt; extension Array: P where Element: P {<br>&gt;   func doSomething() {<br>&gt;     for value in self {<br>&gt;       value.doSomething()<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; // Dynamically query and use conformance to P.<br>&gt; func doSomethingIfP(_ value: Any) {<br>&gt;   if let p = value as? P {<br>&gt;     p.doSomething()<br>&gt;   } else {<br>&gt;     print(&quot;Not a P&quot;)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; doSomethingIfP([S(), S(), S()]) // prints &quot;S&quot; three times<br>&gt; doSomethingIfP([1, 2, 3])       // prints &quot;Not a P&quot;<br>&gt; The if-let in doSomethingIfP(_:) dynamically queries whether the type stored in value conforms to the protocol P. In the case of an Array, that conformance is conditional, which requires another dynamic lookup to determine whether the element type conforms to P: in the first call to doSomethingIfP(_:), the lookup finds the conformance of S to P. In the second case, there is no conformance of Int to P, so the conditional conformance cannot be used. The desire for this dynamic behavior motivates some of the design decisions in this proposal.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#detailed-design&gt;Detailed design<br>&gt; <br>&gt; Most of the semantics of conditional conformances are obvious. However, there are a number of issues (mostly involving multiple conformances) that require more in-depth design.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#disallow-overlapping-conformances&gt;Disallow overlapping conformances<br>&gt; <br>&gt; With conditional conformances, it is possible to express that a given generic type can conform to the same protocol in two different ways, depending on the capabilities of its type arguments. For example:<br>&gt; <br>&gt; struct SomeWrapper&lt;Wrapped&gt; {<br>&gt;   let wrapped: Wrapped<br>&gt; }<br>&gt; <br>&gt; protocol HasIdentity {<br>&gt;   static func ===(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; extension SomeWrapper: Equatable where Wrapped: Equatable {<br>&gt;   static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>&gt;     return lhs.wrapped == rhs.wrapped<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; extension SomeWrapper: Equatable where Wrapped: HasIdentity {<br>&gt;   static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>&gt;     return lhs.wrapped === rhs.wrapped<br>&gt;   }<br>&gt; }<br>&gt; Note that, for an arbitrary type T, there are four potential answers to the question of whether SomeWrapper&lt;T&gt; conforms to Equatable:<br>&gt; <br>&gt; No, it does not conform because T is neither Equatable nor HasIdentity.<br>&gt; Yes, it conforms via the first extension of SomeWrapper because T conforms to Equatable.<br>&gt; Yes, it conforms via the second extension of SomeWrapper because T conforms to HasIdentity.<br>&gt; Ambiguity, because T conforms to both Equatable and HasIdentity.<br>&gt; It is due to the possibility of #4 occurring that we refer to the two conditional conformances in the example as overlapping. There are designs that would allow one to address the ambiguity, for example, by writing a third conditional conformance that addresses #4:<br>&gt; <br>&gt; // Possible tie-breaker conformance<br>&gt; extension SomeWrapper: Equatable where Wrapped: Equatable &amp; HasIdentity, {<br>&gt;   static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>&gt;     return lhs.wrapped == rhs.wrapped<br>&gt;   }<br>&gt; }<br>&gt; The design is consistent, because this third conditional conformance is more specialized the either of the first two conditional conformances, meaning that its requirements are a strict superset of the requirements of those two conditional conformances. However, there are a few downsides to such a system:<br>&gt; <br>&gt; To address all possible ambiguities, one has to write a conditional conformance for every plausible combination of overlapping requirements. To statically resolve all ambiguities, one must also cover nonsensical combinations where the two requirements are mutually exclusive (or invent a way to state mutual-exclusivity).<br>&gt; It is no longer possible to uniquely say what is required to make a generic type conform to a protocol, because there might be several unrelated possibilities. This makes reasoning about the whole system more complex, because it admits divergent interfaces for the same generic type based on their type arguments. At its extreme, this invites the kind of cleverness we&#39;ve seen in the C++ community with template metaprogramming, which is something Swift has sought to avoid.<br>&gt; All of the disambiguation machinery required at compile time (e.g., to determine whether one conditional conformance is more specialized than another to order them) also needs to implements in the run-time, as part of the dynamic casting machinery. One must also address the possibility of ambiguities occurring at run-time. This is both a sharp increase in the complexity of the system and a potential run-time performance hazard.<br>&gt; For these reasons, this proposal bans overlapping conformances entirely. While the resulting system is less flexible than one that allowed overlapping conformances, the gain in simplicity in this potentially-confusing area is well worth the cost. Moreover, this ban follows with existing Swift rules regarding multiple conformances, which prohibit the same type from conforming to the same protocol in two different ways:<br>&gt; <br>&gt; protocol P { }<br>&gt; <br>&gt; struct S : P { }<br>&gt; extension S : P { } // error: S already conforms to P<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#implied-conditional-conformances&gt;Implied conditional conformances<br>&gt; <br>&gt; Stating conformance to a protocol implicitly states conformances to any of the protocols that it inherits. This is the case in Swift today, although most developers likely don&#39;t realize the rules it follows. For example:<br>&gt; <br>&gt; protocol P { }<br>&gt; protocol Q : P { }<br>&gt; protocol R : P { }<br>&gt; <br>&gt; struct X1 { }<br>&gt; struct X2 { }<br>&gt; struct X3 { }<br>&gt; <br>&gt; extension X1: Q { }  // implies conformance to P<br>&gt; <br>&gt; extension X2: Q { }  // would imply conformance to P, but...<br>&gt; extension X2: P { }  // explicitly-stated conformance to P &quot;wins&quot;<br>&gt; <br>&gt; extension X3: Q { }  // implies conformance to P<br>&gt; extension X3: R { }  // also implies conformance to P<br>&gt;                      // one will &quot;win&quot;; which is unspecified<br>&gt; With conditional conformances, the question of which extension &quot;wins&quot; the implied conformance begins to matter, because the extensions might have different constraints on them. For example:<br>&gt; <br>&gt; struct X4&lt;T&gt; { }<br>&gt; <br>&gt; extension X4: Q where T: Q { }  // implies conformance to P<br>&gt; extension X4: R where T: R { }  // error: implies overlapping conformance to P<br>&gt; Both of these constrained extensions imply a conformance to P, but the actual P implied conformances to P are overlapping and, therefore, result in an error.<br>&gt; <br>&gt; However, in cases where there is a reasonable ordering between the two constrained extensions (i.e., one is more specialized than the other), the less specialized constrained extension should &quot;win&quot; the implied conformance. Continuing the example from above:<br>&gt; <br>&gt; protocol S: R { }<br>&gt; <br>&gt; struct X5&lt;T&gt; { }<br>&gt; <br>&gt; extension X5: R where T: R { }  // &quot;wins&quot; implied conformance to P, because<br>&gt; extension X5: S where T: S { }  // the extension where &quot;T: S&quot; is more specialized<br>&gt;                                 // than the one where &quot;T: R&quot;<br>&gt; Thus, the rule for placing implied conformances is to pick the least specialized extension that implies the conformance. If there is more than one such extension, then either:<br>&gt; <br>&gt; All such extensions are not constrained extensions (i.e., they have no requirements beyond what the type requires), in which case Swift can continue to choose arbitrarily among the extensions, or<br>&gt; All such extensions are constrained extensions, in which case the program is ill-formed due to the ambiguity. The developer can explicitly specify conformance to the protocol to disambiguate. <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#overloading-across-constrained-extensions&gt;Overloading across constrained extensions<br>&gt; <br>&gt; One particularly important aspect of the placement rule for implied conformances is that it affects which declarations are used to satisfy a particular requirement. For example:<br>&gt; <br>&gt; protocol P {<br>&gt;   func f()<br>&gt; }<br>&gt; <br>&gt; protocol Q: P { }<br>&gt; protocol R: Q { }<br>&gt; <br>&gt; struct X1&lt;T&gt; { }<br>&gt; <br>&gt; extension X1: Q where T: Q {           // note: implied conformance to P here<br>&gt;   func f() {<br>&gt;     // #1: basic implementation of &#39;f()&#39;<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; extension X1: R where T: R {<br>&gt;   func f() {<br>&gt;     // #2: superfast implementation of f() using some knowledge of &#39;R&#39;<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; struct X2: R {<br>&gt;   func f() { }<br>&gt; }<br>&gt; <br>&gt; (X1&lt;X2&gt;() as P).f() // calls #1, which was used to satisfy the requirement for &#39;f&#39;<br>&gt; X1&lt;X2&gt;().f()        // calls #2, which is preferred by overload resolution<br>&gt; Effectively, when satisfying a protocol requirement, one can only choose from members of the type that are guaranteed to available within the extension with which the conformance is associated. In this case, the conformance to P is placed on the first extension of X1, so the only f() that can be considered is the f() within that extension: the f() in the second extension won&#39;t necessarily always be available, because T may not conform to R. Hence, the call that treats an X1&lt;X2&gt;as a P gets the first implementation of X1.f(). When using the concrete type X1&lt;X2&gt;, where X2 conforms to R, both X.f() implementations are visible... and the second is more specialized.<br>&gt; <br>&gt; Technically, this issue is no different from surprises where (e.g.) a member added to a concrete type in a different module won&#39;t affect an existing protocol conformance. The existing ideas to mediate these problems---warning for nearly-matching functions when they are declared in concrete types, for example---will likely be sufficient to help surprised users. That said, this proposal may increase the likelihood of such problems showing up.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#source-compatibility&gt;Source compatibility<br>&gt; <br>&gt; From the language perspective, conditional conformances are purely additive. They introduce no new syntax, but instead provide semantics for existing syntax---an extension that both declares a protocol conformance and has a where clause---whose use currently results in a type checker failure. That said, this is a feature that is expected to be widely adopted within the Swift standard library, which may indirectly affect source compatibility.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#effect-on-abi-stability&gt;Effect on ABI Stability<br>&gt; <br>&gt; As noted above, there are a number of places where the standard library is expected to adopt this feature, which fall into two classes:<br>&gt; <br>&gt; Improve composability: the example in the introduction &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/Introduction&gt; made Array conform to Equatable when its element type does; there are many places in the Swift standard library that could benefit from this form of conditional conformance, particularly so that collections and other types that contain values (e.g., Optional) can compose better with generic algorithms. Most of these changes won&#39;t be ABI- or source-breaking, because they&#39;re additive.<br>&gt; Eliminating repetition: the lazy wrappers described in the motivation &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/motivation&gt; section could be collapsed into a single wrapper with several conditional conformances. A similar refactoring could also be applied to the range abstractions and slice types in the standard library, making the library itself simpler and smaller. All of these changes are potentially source-breaking and ABI-breaking, because they would remove types that could be used in Swift 3 code. However, there are mitigations: generic typealiases could provide source compatibility to Swift 3 clients, and the ABI-breaking aspect is only relevant if conditional conformances and the standard library changes they imply aren&#39;t part of Swift 4.<br>&gt; Aside from the standard library, conditional conformances have an impact on the Swift runtime, which will require specific support to handle dynamic casting. If that runtime support is not available once ABI stability has been declared, then introducing conditional conformances in a later language version either means the feature cannot be deployed backward or that it would provide only more limited, static behavior when used on older runtimes. Hence, there is significant motivation for doing this feature as part of Swift 4. Even if we waited to introduce conditional conformances, we would want to include a hook in the runtime to allow them to be implemented later, to avoid future backward-compatibility issues.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; The most common request related to conditional conformances is to allow a (constrained) protocol extension to declare conformance to a protocol. For example:<br>&gt; <br>&gt; extension Collection: Equatable where Iterator.Element: Equatable {<br>&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;     // ...<br>&gt;   }<br>&gt; }<br>&gt; This protocol extension will make any Collection of Equatable elements Equatable, which is a powerful feature that could be put to good use. Introducing conditional conformances for protocol extensions would exacerbate the problem of overlapping conformances, because it would be unreasonable to say that the existence of the above protocol extension means that no type that conforms to Collection could declare its own conformance to Equatable, conditional or otherwise.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/f6c58f57/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September 28, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Sep 28, 2016, at 1:28 PM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It’s good to see this starting to happen!<br>&gt; <br>&gt; Is the decision on &quot;no-overlapping-conformances” something that’s seen-as set in stone permanently, set in stone for the near future, or perhaps at least somewhat open to reconsideration at the present moment?<br></p><p>There hasn’t been a decision per se, so it that sense it’s open to reconsideration.<br></p><p>I have a strong *personal* bias against overlapping conformances, because I feel that the amount of complexity that they introduce into the language and its implementation far outweigh any benefits. Additionally, they enable use cases (e.g., static metaprogramming-ish tricks) that I feel would be actively harmful to the Swift language’s understandability. Generics systems can get very complicated very quickly, so any extension needs to be strongly motivated by use cases to matter to all or most Swift developers.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt;&gt; On Sep 26, 2016, at 7:18 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Conditional conformances<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/NNNN-conditional-conformances.md&gt;<br>&gt;&gt; Author: Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt; Review Manager: TBD<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; During the review process, add the following fields as needed:<br>&gt;&gt; <br>&gt;&gt; Decision Notes: Rationale &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;, Additional Commentary &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;&gt; Bugs: SR-NNNN &lt;https://bugs.swift.org/browse/SR-NNNN&gt;, SR-MMMM &lt;https://bugs.swift.org/browse/SR-MMMM&gt;<br>&gt;&gt; Previous Revision: 1 &lt;https://github.com/apple/swift-evolution/blob/...commit-ID.../proposals/NNNN-filename.md&gt;<br>&gt;&gt; Previous Proposal: SE-XXXX &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/XXXX-filename.md&gt;<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; Conditional conformances express the notion that a generic type will conform to a particular protocol only when it&#39;s type arguments meet certain requirements. For example, the Array collection can implement the Equatable protocol only when its elements are themselves Equatable, which can be expressed via the following conditional conformance on Equatable:<br>&gt;&gt; <br>&gt;&gt; extension Array: Equatable where Element: Equatable {<br>&gt;&gt;   static func ==(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { ... }<br>&gt;&gt; }<br>&gt;&gt; This feature is part of the generics manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-&gt; because it&#39;s something that fits naturally into the generics model and is expected to have a high impact on the Swift standard library.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: TBD: Discussion thread topic for that proposal &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; Conditional conformances address a hole in the composability of the generics system. Continuing the Array example from above, it&#39;s always been the case that one could use the == operator on two arrays of Equatable type, e.g., [Int]() == [Int]() would succeed. However, it doesn&#39;t compose: arrays of arrays of Equatable types cannot be compared (e.g.,[Int] &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals&gt;== [Int] &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals&gt;will fail to compile) because, even though there is an==for arrays of Equatabletype, the arrays themselves are neverEquatable`.<br>&gt;&gt; <br>&gt;&gt; Conditional conformances are particularly powerful when building generic adapter types, which are intended to reflect the capabilities of their type arguments. For example, consider the &quot;lazy&quot; functionality of the Swift standard library&#39;s collections: using the lazy member of a sequence produces a lazy adapter that conforms to the Sequence protocol, while using the lazy member of a collection produces a lazy adapter that conforms to the Collection protocol. In Swift 3, the only way to model this is with different types. For example, the Swift standard library has four similar generic types to handle a lazy collection: LazySequence, LazyCollection, LazyBidirectionalCollection, and LazyRandomAccessCollection. The Swift standard library uses overloading of the lazy property to decide among these:<br>&gt;&gt; <br>&gt;&gt; extension Sequence {<br>&gt;&gt;   var lazy: LazySequence&lt;Self&gt; { ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Collection {<br>&gt;&gt;   var lazy: LazyCollection&lt;Self&gt; { ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension BidirectionalCollection {<br>&gt;&gt;   var lazy: LazyBidirectionalCollection&lt;Self&gt; { ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension RandomAccessCollection {<br>&gt;&gt;   var lazy: LazyRandomAccessCollection&lt;Self&gt; { ... }<br>&gt;&gt; }<br>&gt;&gt; This approach causes an enormous amount of repetition, and doesn&#39;t scale well because each more-capable type has to re-implement (or somehow forward the implementation of) all of the APIs of the less-capable versions. With conditional conformances, one can provide a single generic wrapper type whose basic requirements meet the lowest common denominator (e.g., Sequence), but which scale their capabilities with their type argument (e.g., the LazySequence conforms to Collection when the type argument does, and so on).<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; In a nutshell, the proposed solution is to allow a constrained extension of a struct, enum, or class to declare protocol conformances. No additional syntax is necessary for this change, because it already exists in the grammar; rather, this proposal removes the limitation that results in the following error:<br>&gt;&gt; <br>&gt;&gt; t.swift:1:1: error: extension of type &#39;Array&#39; with constraints cannot have an inheritance clause<br>&gt;&gt; extension Array: Equatable where Element: Equatable { }<br>&gt;&gt; ^                ~~~~~~~~~<br>&gt;&gt; Conditional conformances can only be used when the additional requirements of the constrained extension are satisfied. For example, given the aforementioned Array conformance to Equatable:<br>&gt;&gt; <br>&gt;&gt; func f&lt;T: Equatable&gt;(_: T) { ... }<br>&gt;&gt; <br>&gt;&gt; struct NotEquatable { }<br>&gt;&gt; <br>&gt;&gt; func test(a1: [Int], a2: [NotEquatable]) {<br>&gt;&gt;   f(a1)    // okay: [Int] conforms to Equatable because Int conforms to Equatable<br>&gt;&gt;   f(a2)    // error: [NotEquatable] does not conform to Equatable because NotEquatable has no conformance to Equatable<br>&gt;&gt; }<br>&gt;&gt; Conditional conformances also have a run-time aspect, because a dynamic check for a protocol conformance might rely on the evaluation of the extra requirements needed to successfully use a conditional conformance. For example:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   func doSomething()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: P {<br>&gt;&gt;   func doSomething() { print(&quot;S&quot;) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Array conforms to P if it&#39;s element type conforms to P<br>&gt;&gt; extension Array: P where Element: P {<br>&gt;&gt;   func doSomething() {<br>&gt;&gt;     for value in self {<br>&gt;&gt;       value.doSomething()<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Dynamically query and use conformance to P.<br>&gt;&gt; func doSomethingIfP(_ value: Any) {<br>&gt;&gt;   if let p = value as? P {<br>&gt;&gt;     p.doSomething()<br>&gt;&gt;   } else {<br>&gt;&gt;     print(&quot;Not a P&quot;)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; doSomethingIfP([S(), S(), S()]) // prints &quot;S&quot; three times<br>&gt;&gt; doSomethingIfP([1, 2, 3])       // prints &quot;Not a P&quot;<br>&gt;&gt; The if-let in doSomethingIfP(_:) dynamically queries whether the type stored in value conforms to the protocol P. In the case of an Array, that conformance is conditional, which requires another dynamic lookup to determine whether the element type conforms to P: in the first call to doSomethingIfP(_:), the lookup finds the conformance of S to P. In the second case, there is no conformance of Int to P, so the conditional conformance cannot be used. The desire for this dynamic behavior motivates some of the design decisions in this proposal.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; Most of the semantics of conditional conformances are obvious. However, there are a number of issues (mostly involving multiple conformances) that require more in-depth design.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#disallow-overlapping-conformances&gt;Disallow overlapping conformances<br>&gt;&gt; <br>&gt;&gt; With conditional conformances, it is possible to express that a given generic type can conform to the same protocol in two different ways, depending on the capabilities of its type arguments. For example:<br>&gt;&gt; <br>&gt;&gt; struct SomeWrapper&lt;Wrapped&gt; {<br>&gt;&gt;   let wrapped: Wrapped<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol HasIdentity {<br>&gt;&gt;   static func ===(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension SomeWrapper: Equatable where Wrapped: Equatable {<br>&gt;&gt;   static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>&gt;&gt;     return lhs.wrapped == rhs.wrapped<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension SomeWrapper: Equatable where Wrapped: HasIdentity {<br>&gt;&gt;   static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>&gt;&gt;     return lhs.wrapped === rhs.wrapped<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; Note that, for an arbitrary type T, there are four potential answers to the question of whether SomeWrapper&lt;T&gt; conforms to Equatable:<br>&gt;&gt; <br>&gt;&gt; No, it does not conform because T is neither Equatable nor HasIdentity.<br>&gt;&gt; Yes, it conforms via the first extension of SomeWrapper because T conforms to Equatable.<br>&gt;&gt; Yes, it conforms via the second extension of SomeWrapper because T conforms to HasIdentity.<br>&gt;&gt; Ambiguity, because T conforms to both Equatable and HasIdentity.<br>&gt;&gt; It is due to the possibility of #4 occurring that we refer to the two conditional conformances in the example as overlapping. There are designs that would allow one to address the ambiguity, for example, by writing a third conditional conformance that addresses #4:<br>&gt;&gt; <br>&gt;&gt; // Possible tie-breaker conformance<br>&gt;&gt; extension SomeWrapper: Equatable where Wrapped: Equatable &amp; HasIdentity, {<br>&gt;&gt;   static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>&gt;&gt;     return lhs.wrapped == rhs.wrapped<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; The design is consistent, because this third conditional conformance is more specialized the either of the first two conditional conformances, meaning that its requirements are a strict superset of the requirements of those two conditional conformances. However, there are a few downsides to such a system:<br>&gt;&gt; <br>&gt;&gt; To address all possible ambiguities, one has to write a conditional conformance for every plausible combination of overlapping requirements. To statically resolve all ambiguities, one must also cover nonsensical combinations where the two requirements are mutually exclusive (or invent a way to state mutual-exclusivity).<br>&gt;&gt; It is no longer possible to uniquely say what is required to make a generic type conform to a protocol, because there might be several unrelated possibilities. This makes reasoning about the whole system more complex, because it admits divergent interfaces for the same generic type based on their type arguments. At its extreme, this invites the kind of cleverness we&#39;ve seen in the C++ community with template metaprogramming, which is something Swift has sought to avoid.<br>&gt;&gt; All of the disambiguation machinery required at compile time (e.g., to determine whether one conditional conformance is more specialized than another to order them) also needs to implements in the run-time, as part of the dynamic casting machinery. One must also address the possibility of ambiguities occurring at run-time. This is both a sharp increase in the complexity of the system and a potential run-time performance hazard.<br>&gt;&gt; For these reasons, this proposal bans overlapping conformances entirely. While the resulting system is less flexible than one that allowed overlapping conformances, the gain in simplicity in this potentially-confusing area is well worth the cost. Moreover, this ban follows with existing Swift rules regarding multiple conformances, which prohibit the same type from conforming to the same protocol in two different ways:<br>&gt;&gt; <br>&gt;&gt; protocol P { }<br>&gt;&gt; <br>&gt;&gt; struct S : P { }<br>&gt;&gt; extension S : P { } // error: S already conforms to P<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#implied-conditional-conformances&gt;Implied conditional conformances<br>&gt;&gt; <br>&gt;&gt; Stating conformance to a protocol implicitly states conformances to any of the protocols that it inherits. This is the case in Swift today, although most developers likely don&#39;t realize the rules it follows. For example:<br>&gt;&gt; <br>&gt;&gt; protocol P { }<br>&gt;&gt; protocol Q : P { }<br>&gt;&gt; protocol R : P { }<br>&gt;&gt; <br>&gt;&gt; struct X1 { }<br>&gt;&gt; struct X2 { }<br>&gt;&gt; struct X3 { }<br>&gt;&gt; <br>&gt;&gt; extension X1: Q { }  // implies conformance to P<br>&gt;&gt; <br>&gt;&gt; extension X2: Q { }  // would imply conformance to P, but...<br>&gt;&gt; extension X2: P { }  // explicitly-stated conformance to P &quot;wins&quot;<br>&gt;&gt; <br>&gt;&gt; extension X3: Q { }  // implies conformance to P<br>&gt;&gt; extension X3: R { }  // also implies conformance to P<br>&gt;&gt;                      // one will &quot;win&quot;; which is unspecified<br>&gt;&gt; With conditional conformances, the question of which extension &quot;wins&quot; the implied conformance begins to matter, because the extensions might have different constraints on them. For example:<br>&gt;&gt; <br>&gt;&gt; struct X4&lt;T&gt; { }<br>&gt;&gt; <br>&gt;&gt; extension X4: Q where T: Q { }  // implies conformance to P<br>&gt;&gt; extension X4: R where T: R { }  // error: implies overlapping conformance to P<br>&gt;&gt; Both of these constrained extensions imply a conformance to P, but the actual P implied conformances to P are overlapping and, therefore, result in an error.<br>&gt;&gt; <br>&gt;&gt; However, in cases where there is a reasonable ordering between the two constrained extensions (i.e., one is more specialized than the other), the less specialized constrained extension should &quot;win&quot; the implied conformance. Continuing the example from above:<br>&gt;&gt; <br>&gt;&gt; protocol S: R { }<br>&gt;&gt; <br>&gt;&gt; struct X5&lt;T&gt; { }<br>&gt;&gt; <br>&gt;&gt; extension X5: R where T: R { }  // &quot;wins&quot; implied conformance to P, because<br>&gt;&gt; extension X5: S where T: S { }  // the extension where &quot;T: S&quot; is more specialized<br>&gt;&gt;                                 // than the one where &quot;T: R&quot;<br>&gt;&gt; Thus, the rule for placing implied conformances is to pick the least specialized extension that implies the conformance. If there is more than one such extension, then either:<br>&gt;&gt; <br>&gt;&gt; All such extensions are not constrained extensions (i.e., they have no requirements beyond what the type requires), in which case Swift can continue to choose arbitrarily among the extensions, or<br>&gt;&gt; All such extensions are constrained extensions, in which case the program is ill-formed due to the ambiguity. The developer can explicitly specify conformance to the protocol to disambiguate. <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#overloading-across-constrained-extensions&gt;Overloading across constrained extensions<br>&gt;&gt; <br>&gt;&gt; One particularly important aspect of the placement rule for implied conformances is that it affects which declarations are used to satisfy a particular requirement. For example:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   func f()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol Q: P { }<br>&gt;&gt; protocol R: Q { }<br>&gt;&gt; <br>&gt;&gt; struct X1&lt;T&gt; { }<br>&gt;&gt; <br>&gt;&gt; extension X1: Q where T: Q {           // note: implied conformance to P here<br>&gt;&gt;   func f() {<br>&gt;&gt;     // #1: basic implementation of &#39;f()&#39;<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension X1: R where T: R {<br>&gt;&gt;   func f() {<br>&gt;&gt;     // #2: superfast implementation of f() using some knowledge of &#39;R&#39;<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct X2: R {<br>&gt;&gt;   func f() { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; (X1&lt;X2&gt;() as P).f() // calls #1, which was used to satisfy the requirement for &#39;f&#39;<br>&gt;&gt; X1&lt;X2&gt;().f()        // calls #2, which is preferred by overload resolution<br>&gt;&gt; Effectively, when satisfying a protocol requirement, one can only choose from members of the type that are guaranteed to available within the extension with which the conformance is associated. In this case, the conformance to P is placed on the first extension of X1, so the only f() that can be considered is the f() within that extension: the f() in the second extension won&#39;t necessarily always be available, because T may not conform to R. Hence, the call that treats an X1&lt;X2&gt;as a P gets the first implementation of X1.f(). When using the concrete type X1&lt;X2&gt;, where X2 conforms to R, both X.f() implementations are visible... and the second is more specialized.<br>&gt;&gt; <br>&gt;&gt; Technically, this issue is no different from surprises where (e.g.) a member added to a concrete type in a different module won&#39;t affect an existing protocol conformance. The existing ideas to mediate these problems---warning for nearly-matching functions when they are declared in concrete types, for example---will likely be sufficient to help surprised users. That said, this proposal may increase the likelihood of such problems showing up.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#source-compatibility&gt;Source compatibility<br>&gt;&gt; <br>&gt;&gt; From the language perspective, conditional conformances are purely additive. They introduce no new syntax, but instead provide semantics for existing syntax---an extension that both declares a protocol conformance and has a where clause---whose use currently results in a type checker failure. That said, this is a feature that is expected to be widely adopted within the Swift standard library, which may indirectly affect source compatibility.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#effect-on-abi-stability&gt;Effect on ABI Stability<br>&gt;&gt; <br>&gt;&gt; As noted above, there are a number of places where the standard library is expected to adopt this feature, which fall into two classes:<br>&gt;&gt; <br>&gt;&gt; Improve composability: the example in the introduction &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/Introduction&gt; made Array conform to Equatable when its element type does; there are many places in the Swift standard library that could benefit from this form of conditional conformance, particularly so that collections and other types that contain values (e.g., Optional) can compose better with generic algorithms. Most of these changes won&#39;t be ABI- or source-breaking, because they&#39;re additive.<br>&gt;&gt; Eliminating repetition: the lazy wrappers described in the motivation &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/motivation&gt; section could be collapsed into a single wrapper with several conditional conformances. A similar refactoring could also be applied to the range abstractions and slice types in the standard library, making the library itself simpler and smaller. All of these changes are potentially source-breaking and ABI-breaking, because they would remove types that could be used in Swift 3 code. However, there are mitigations: generic typealiases could provide source compatibility to Swift 3 clients, and the ABI-breaking aspect is only relevant if conditional conformances and the standard library changes they imply aren&#39;t part of Swift 4.<br>&gt;&gt; Aside from the standard library, conditional conformances have an impact on the Swift runtime, which will require specific support to handle dynamic casting. If that runtime support is not available once ABI stability has been declared, then introducing conditional conformances in a later language version either means the feature cannot be deployed backward or that it would provide only more limited, static behavior when used on older runtimes. Hence, there is significant motivation for doing this feature as part of Swift 4. Even if we waited to introduce conditional conformances, we would want to include a hook in the runtime to allow them to be implemented later, to avoid future backward-compatibility issues.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The most common request related to conditional conformances is to allow a (constrained) protocol extension to declare conformance to a protocol. For example:<br>&gt;&gt; <br>&gt;&gt; extension Collection: Equatable where Iterator.Element: Equatable {<br>&gt;&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;     // ...<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; This protocol extension will make any Collection of Equatable elements Equatable, which is a powerful feature that could be put to good use. Introducing conditional conformances for protocol extensions would exacerbate the problem of overlapping conformances, because it would be unreasonable to say that the existence of the above protocol extension means that no type that conforms to Collection could declare its own conformance to Equatable, conditional or otherwise.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/c89751b7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>September 28, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt;&gt; Is the decision on &quot;no-overlapping-conformances” something that’s seen-as set in stone permanently, set in stone for the near future, or perhaps at least somewhat open to reconsideration at the present moment?<br>&gt; <br>&gt; There hasn’t been a decision per se, so it that sense it’s open to reconsideration.<br>&gt; <br>&gt; I have a strong *personal* bias against overlapping conformances, because I feel that the amount of complexity that they introduce into the language and its implementation far outweigh any benefits.<br></p><p>I would like a bit further clarification on what the prohibition of overlapping conformances implies.  For example, consider this modification of your example in a Swift that allows for same type constraints in extensions.  Would this be allowed?  There would be two different conformances to Foo for SomeWrapper, but they would never “overlap” (i.e. both be candidates for the same concrete type).<br>struct SomeWrapper&lt;Wrapped&gt; {<br>  let wrapped: Wrapped<br>}<br></p><p>protocol Foo {<br>associatedtype Bar<br>  func bar() -&gt; Bar<br>}<br></p><p>extension SomeWrapper: Equatable where Wrapped == String {<br>  func bar() -&gt; String {<br>    return “Hello&quot;<br>  }<br>}<br></p><p>extension SomeWrapper: Equatable where Wrapped == Int {<br>  func bar() -&gt; Int {<br>    return 0<br>  }<br>}<br>Secondarily, I understand the reason for letting the “least specific” candidate conformance win (it is the most general).  But I wonder if this might leave performance on the table in some cases where a more specific implementation could use knowledge of the more specific details to implement the members more efficiently.  Using the example in your proposal, what if knowing `T` conforms to `S`, not just `R` allows `X5` to provide a more efficient implementation of the members of `P` and `R`?  If so, it seems unfortunate to leave that performance on the table.  Is this a valid concern?  Or is it unlikely to come up often enough in practice to matter?<br></p><p>&gt; Additionally, they enable use cases (e.g., static metaprogramming-ish tricks) that I feel would be actively harmful to the Swift language’s understandability. Generics systems can get very complicated very quickly, so any extension needs to be strongly motivated by use cases to matter to all or most Swift developers.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 26, 2016, at 7:18 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conditional conformances<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/NNNN-conditional-conformances.md&gt;<br>&gt;&gt;&gt; Author: Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt; Review Manager: TBD<br>&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt; During the review process, add the following fields as needed:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Decision Notes: Rationale &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;, Additional Commentary &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;&gt;&gt; Bugs: SR-NNNN &lt;https://bugs.swift.org/browse/SR-NNNN&gt;, SR-MMMM &lt;https://bugs.swift.org/browse/SR-MMMM&gt;<br>&gt;&gt;&gt; Previous Revision: 1 &lt;https://github.com/apple/swift-evolution/blob/...commit-ID.../proposals/NNNN-filename.md&gt;<br>&gt;&gt;&gt; Previous Proposal: SE-XXXX &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/XXXX-filename.md&gt;<br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conditional conformances express the notion that a generic type will conform to a particular protocol only when it&#39;s type arguments meet certain requirements. For example, the Array collection can implement the Equatable protocol only when its elements are themselves Equatable, which can be expressed via the following conditional conformance on Equatable:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Array: Equatable where Element: Equatable {<br>&gt;&gt;&gt;   static func ==(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; This feature is part of the generics manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-&gt; because it&#39;s something that fits naturally into the generics model and is expected to have a high impact on the Swift standard library.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: TBD: Discussion thread topic for that proposal &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conditional conformances address a hole in the composability of the generics system. Continuing the Array example from above, it&#39;s always been the case that one could use the == operator on two arrays of Equatable type, e.g., [Int]() == [Int]() would succeed. However, it doesn&#39;t compose: arrays of arrays of Equatable types cannot be compared (e.g.,[Int] &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals&gt;== [Int] &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals&gt;will fail to compile) because, even though there is an==for arrays of Equatabletype, the arrays themselves are neverEquatable`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conditional conformances are particularly powerful when building generic adapter types, which are intended to reflect the capabilities of their type arguments. For example, consider the &quot;lazy&quot; functionality of the Swift standard library&#39;s collections: using the lazy member of a sequence produces a lazy adapter that conforms to the Sequence protocol, while using the lazy member of a collection produces a lazy adapter that conforms to the Collection protocol. In Swift 3, the only way to model this is with different types. For example, the Swift standard library has four similar generic types to handle a lazy collection: LazySequence, LazyCollection, LazyBidirectionalCollection, and LazyRandomAccessCollection. The Swift standard library uses overloading of the lazy property to decide among these:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Sequence {<br>&gt;&gt;&gt;   var lazy: LazySequence&lt;Self&gt; { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Collection {<br>&gt;&gt;&gt;   var lazy: LazyCollection&lt;Self&gt; { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension BidirectionalCollection {<br>&gt;&gt;&gt;   var lazy: LazyBidirectionalCollection&lt;Self&gt; { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension RandomAccessCollection {<br>&gt;&gt;&gt;   var lazy: LazyRandomAccessCollection&lt;Self&gt; { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; This approach causes an enormous amount of repetition, and doesn&#39;t scale well because each more-capable type has to re-implement (or somehow forward the implementation of) all of the APIs of the less-capable versions. With conditional conformances, one can provide a single generic wrapper type whose basic requirements meet the lowest common denominator (e.g., Sequence), but which scale their capabilities with their type argument (e.g., the LazySequence conforms to Collection when the type argument does, and so on).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In a nutshell, the proposed solution is to allow a constrained extension of a struct, enum, or class to declare protocol conformances. No additional syntax is necessary for this change, because it already exists in the grammar; rather, this proposal removes the limitation that results in the following error:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; t.swift:1:1: error: extension of type &#39;Array&#39; with constraints cannot have an inheritance clause<br>&gt;&gt;&gt; extension Array: Equatable where Element: Equatable { }<br>&gt;&gt;&gt; ^                ~~~~~~~~~<br>&gt;&gt;&gt; Conditional conformances can only be used when the additional requirements of the constrained extension are satisfied. For example, given the aforementioned Array conformance to Equatable:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f&lt;T: Equatable&gt;(_: T) { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct NotEquatable { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func test(a1: [Int], a2: [NotEquatable]) {<br>&gt;&gt;&gt;   f(a1)    // okay: [Int] conforms to Equatable because Int conforms to Equatable<br>&gt;&gt;&gt;   f(a2)    // error: [NotEquatable] does not conform to Equatable because NotEquatable has no conformance to Equatable<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Conditional conformances also have a run-time aspect, because a dynamic check for a protocol conformance might rely on the evaluation of the extra requirements needed to successfully use a conditional conformance. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;   func doSomething()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S: P {<br>&gt;&gt;&gt;   func doSomething() { print(&quot;S&quot;) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Array conforms to P if it&#39;s element type conforms to P<br>&gt;&gt;&gt; extension Array: P where Element: P {<br>&gt;&gt;&gt;   func doSomething() {<br>&gt;&gt;&gt;     for value in self {<br>&gt;&gt;&gt;       value.doSomething()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Dynamically query and use conformance to P.<br>&gt;&gt;&gt; func doSomethingIfP(_ value: Any) {<br>&gt;&gt;&gt;   if let p = value as? P {<br>&gt;&gt;&gt;     p.doSomething()<br>&gt;&gt;&gt;   } else {<br>&gt;&gt;&gt;     print(&quot;Not a P&quot;)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; doSomethingIfP([S(), S(), S()]) // prints &quot;S&quot; three times<br>&gt;&gt;&gt; doSomethingIfP([1, 2, 3])       // prints &quot;Not a P&quot;<br>&gt;&gt;&gt; The if-let in doSomethingIfP(_:) dynamically queries whether the type stored in value conforms to the protocol P. In the case of an Array, that conformance is conditional, which requires another dynamic lookup to determine whether the element type conforms to P: in the first call to doSomethingIfP(_:), the lookup finds the conformance of S to P. In the second case, there is no conformance of Int to P, so the conditional conformance cannot be used. The desire for this dynamic behavior motivates some of the design decisions in this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#detailed-design&gt;Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Most of the semantics of conditional conformances are obvious. However, there are a number of issues (mostly involving multiple conformances) that require more in-depth design.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#disallow-overlapping-conformances&gt;Disallow overlapping conformances<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With conditional conformances, it is possible to express that a given generic type can conform to the same protocol in two different ways, depending on the capabilities of its type arguments. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct SomeWrapper&lt;Wrapped&gt; {<br>&gt;&gt;&gt;   let wrapped: Wrapped<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol HasIdentity {<br>&gt;&gt;&gt;   static func ===(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension SomeWrapper: Equatable where Wrapped: Equatable {<br>&gt;&gt;&gt;   static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>&gt;&gt;&gt;     return lhs.wrapped == rhs.wrapped<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension SomeWrapper: Equatable where Wrapped: HasIdentity {<br>&gt;&gt;&gt;   static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>&gt;&gt;&gt;     return lhs.wrapped === rhs.wrapped<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Note that, for an arbitrary type T, there are four potential answers to the question of whether SomeWrapper&lt;T&gt; conforms to Equatable:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, it does not conform because T is neither Equatable nor HasIdentity.<br>&gt;&gt;&gt; Yes, it conforms via the first extension of SomeWrapper because T conforms to Equatable.<br>&gt;&gt;&gt; Yes, it conforms via the second extension of SomeWrapper because T conforms to HasIdentity.<br>&gt;&gt;&gt; Ambiguity, because T conforms to both Equatable and HasIdentity.<br>&gt;&gt;&gt; It is due to the possibility of #4 occurring that we refer to the two conditional conformances in the example as overlapping. There are designs that would allow one to address the ambiguity, for example, by writing a third conditional conformance that addresses #4:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Possible tie-breaker conformance<br>&gt;&gt;&gt; extension SomeWrapper: Equatable where Wrapped: Equatable &amp; HasIdentity, {<br>&gt;&gt;&gt;   static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>&gt;&gt;&gt;     return lhs.wrapped == rhs.wrapped<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; The design is consistent, because this third conditional conformance is more specialized the either of the first two conditional conformances, meaning that its requirements are a strict superset of the requirements of those two conditional conformances. However, there are a few downsides to such a system:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To address all possible ambiguities, one has to write a conditional conformance for every plausible combination of overlapping requirements. To statically resolve all ambiguities, one must also cover nonsensical combinations where the two requirements are mutually exclusive (or invent a way to state mutual-exclusivity).<br>&gt;&gt;&gt; It is no longer possible to uniquely say what is required to make a generic type conform to a protocol, because there might be several unrelated possibilities. This makes reasoning about the whole system more complex, because it admits divergent interfaces for the same generic type based on their type arguments. At its extreme, this invites the kind of cleverness we&#39;ve seen in the C++ community with template metaprogramming, which is something Swift has sought to avoid.<br>&gt;&gt;&gt; All of the disambiguation machinery required at compile time (e.g., to determine whether one conditional conformance is more specialized than another to order them) also needs to implements in the run-time, as part of the dynamic casting machinery. One must also address the possibility of ambiguities occurring at run-time. This is both a sharp increase in the complexity of the system and a potential run-time performance hazard.<br>&gt;&gt;&gt; For these reasons, this proposal bans overlapping conformances entirely. While the resulting system is less flexible than one that allowed overlapping conformances, the gain in simplicity in this potentially-confusing area is well worth the cost. Moreover, this ban follows with existing Swift rules regarding multiple conformances, which prohibit the same type from conforming to the same protocol in two different ways:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S : P { }<br>&gt;&gt;&gt; extension S : P { } // error: S already conforms to P<br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#implied-conditional-conformances&gt;Implied conditional conformances<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Stating conformance to a protocol implicitly states conformances to any of the protocols that it inherits. This is the case in Swift today, although most developers likely don&#39;t realize the rules it follows. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P { }<br>&gt;&gt;&gt; protocol Q : P { }<br>&gt;&gt;&gt; protocol R : P { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X1 { }<br>&gt;&gt;&gt; struct X2 { }<br>&gt;&gt;&gt; struct X3 { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X1: Q { }  // implies conformance to P<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X2: Q { }  // would imply conformance to P, but...<br>&gt;&gt;&gt; extension X2: P { }  // explicitly-stated conformance to P &quot;wins&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X3: Q { }  // implies conformance to P<br>&gt;&gt;&gt; extension X3: R { }  // also implies conformance to P<br>&gt;&gt;&gt;                      // one will &quot;win&quot;; which is unspecified<br>&gt;&gt;&gt; With conditional conformances, the question of which extension &quot;wins&quot; the implied conformance begins to matter, because the extensions might have different constraints on them. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X4&lt;T&gt; { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X4: Q where T: Q { }  // implies conformance to P<br>&gt;&gt;&gt; extension X4: R where T: R { }  // error: implies overlapping conformance to P<br>&gt;&gt;&gt; Both of these constrained extensions imply a conformance to P, but the actual P implied conformances to P are overlapping and, therefore, result in an error.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, in cases where there is a reasonable ordering between the two constrained extensions (i.e., one is more specialized than the other), the less specialized constrained extension should &quot;win&quot; the implied conformance. Continuing the example from above:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol S: R { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X5&lt;T&gt; { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X5: R where T: R { }  // &quot;wins&quot; implied conformance to P, because<br>&gt;&gt;&gt; extension X5: S where T: S { }  // the extension where &quot;T: S&quot; is more specialized<br>&gt;&gt;&gt;                                 // than the one where &quot;T: R&quot;<br>&gt;&gt;&gt; Thus, the rule for placing implied conformances is to pick the least specialized extension that implies the conformance. If there is more than one such extension, then either:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; All such extensions are not constrained extensions (i.e., they have no requirements beyond what the type requires), in which case Swift can continue to choose arbitrarily among the extensions, or<br>&gt;&gt;&gt; All such extensions are constrained extensions, in which case the program is ill-formed due to the ambiguity. The developer can explicitly specify conformance to the protocol to disambiguate. <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#overloading-across-constrained-extensions&gt;Overloading across constrained extensions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One particularly important aspect of the placement rule for implied conformances is that it affects which declarations are used to satisfy a particular requirement. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;   func f()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Q: P { }<br>&gt;&gt;&gt; protocol R: Q { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X1&lt;T&gt; { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X1: Q where T: Q {           // note: implied conformance to P here<br>&gt;&gt;&gt;   func f() {<br>&gt;&gt;&gt;     // #1: basic implementation of &#39;f()&#39;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X1: R where T: R {<br>&gt;&gt;&gt;   func f() {<br>&gt;&gt;&gt;     // #2: superfast implementation of f() using some knowledge of &#39;R&#39;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X2: R {<br>&gt;&gt;&gt;   func f() { }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (X1&lt;X2&gt;() as P).f() // calls #1, which was used to satisfy the requirement for &#39;f&#39;<br>&gt;&gt;&gt; X1&lt;X2&gt;().f()        // calls #2, which is preferred by overload resolution<br>&gt;&gt;&gt; Effectively, when satisfying a protocol requirement, one can only choose from members of the type that are guaranteed to available within the extension with which the conformance is associated. In this case, the conformance to P is placed on the first extension of X1, so the only f() that can be considered is the f() within that extension: the f() in the second extension won&#39;t necessarily always be available, because T may not conform to R. Hence, the call that treats an X1&lt;X2&gt;as a P gets the first implementation of X1.f(). When using the concrete type X1&lt;X2&gt;, where X2 conforms to R, both X.f() implementations are visible... and the second is more specialized.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Technically, this issue is no different from surprises where (e.g.) a member added to a concrete type in a different module won&#39;t affect an existing protocol conformance. The existing ideas to mediate these problems---warning for nearly-matching functions when they are declared in concrete types, for example---will likely be sufficient to help surprised users. That said, this proposal may increase the likelihood of such problems showing up.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#source-compatibility&gt;Source compatibility<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From the language perspective, conditional conformances are purely additive. They introduce no new syntax, but instead provide semantics for existing syntax---an extension that both declares a protocol conformance and has a where clause---whose use currently results in a type checker failure. That said, this is a feature that is expected to be widely adopted within the Swift standard library, which may indirectly affect source compatibility.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#effect-on-abi-stability&gt;Effect on ABI Stability<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As noted above, there are a number of places where the standard library is expected to adopt this feature, which fall into two classes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Improve composability: the example in the introduction &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/Introduction&gt; made Array conform to Equatable when its element type does; there are many places in the Swift standard library that could benefit from this form of conditional conformance, particularly so that collections and other types that contain values (e.g., Optional) can compose better with generic algorithms. Most of these changes won&#39;t be ABI- or source-breaking, because they&#39;re additive.<br>&gt;&gt;&gt; Eliminating repetition: the lazy wrappers described in the motivation &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/motivation&gt; section could be collapsed into a single wrapper with several conditional conformances. A similar refactoring could also be applied to the range abstractions and slice types in the standard library, making the library itself simpler and smaller. All of these changes are potentially source-breaking and ABI-breaking, because they would remove types that could be used in Swift 3 code. However, there are mitigations: generic typealiases could provide source compatibility to Swift 3 clients, and the ABI-breaking aspect is only relevant if conditional conformances and the standard library changes they imply aren&#39;t part of Swift 4.<br>&gt;&gt;&gt; Aside from the standard library, conditional conformances have an impact on the Swift runtime, which will require specific support to handle dynamic casting. If that runtime support is not available once ABI stability has been declared, then introducing conditional conformances in a later language version either means the feature cannot be deployed backward or that it would provide only more limited, static behavior when used on older runtimes. Hence, there is significant motivation for doing this feature as part of Swift 4. Even if we waited to introduce conditional conformances, we would want to include a hook in the runtime to allow them to be implemented later, to avoid future backward-compatibility issues.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The most common request related to conditional conformances is to allow a (constrained) protocol extension to declare conformance to a protocol. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Collection: Equatable where Iterator.Element: Equatable {<br>&gt;&gt;&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;     // ...<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; This protocol extension will make any Collection of Equatable elements Equatable, which is a powerful feature that could be put to good use. Introducing conditional conformances for protocol extensions would exacerbate the problem of overlapping conformances, because it would be unreasonable to say that the existence of the above protocol extension means that no type that conforms to Collection could declare its own conformance to Equatable, conditional or otherwise.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/e6844c1d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September 29, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Sep 28, 2016, at 4:30 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Is the decision on &quot;no-overlapping-conformances” something that’s seen-as set in stone permanently, set in stone for the near future, or perhaps at least somewhat open to reconsideration at the present moment?<br>&gt;&gt; <br>&gt;&gt; There hasn’t been a decision per se, so it that sense it’s open to reconsideration.<br>&gt;&gt; <br>&gt;&gt; I have a strong *personal* bias against overlapping conformances, because I feel that the amount of complexity that they introduce into the language and its implementation far outweigh any benefits.<br>&gt; <br>&gt; I would like a bit further clarification on what the prohibition of overlapping conformances implies.<br></p><p>I think I presented it poorly in the proposal, and will see if I can find a clearer exposition (for posterity, if not soon enough to aid the review).<br></p><p>&gt;  For example, consider this modification of your example in a Swift that allows for same type constraints in extensions.  Would this be allowed?<br></p><p>Short answer: no. Longer answer below.<br></p><p>&gt;  There would be two different conformances to Foo for SomeWrapper, but they would never “overlap” (i.e. both be candidates for the same concrete type).<br>&gt; struct SomeWrapper&lt;Wrapped&gt; {<br>&gt;   let wrapped: Wrapped<br>&gt; }<br>&gt; <br>&gt; protocol Foo {<br>&gt; associatedtype Bar<br>&gt;   func bar() -&gt; Bar<br>&gt; }<br>&gt; <br>&gt; extension SomeWrapper: Equatable where Wrapped == String {<br>&gt;   func bar() -&gt; String {<br>&gt;     return “Hello&quot;<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; extension SomeWrapper: Equatable where Wrapped == Int {<br>&gt;   func bar() -&gt; Int {<br>&gt;     return 0<br>&gt;   }<br>&gt; }<br>This is a case where we *could* determine that the two conformances will never overlap, because we can statically determine that trying to satisfy the requirements of both extensions at the same time results in a conflict—Wrapped cannot be both equal to an Int and a String. However, I think it’s a bad idea to allow these two conformances, for a couple of reasons:<br></p><p>(1) It’s going to immediately feature-creep as developers want to be able to treat more kinds of extensions as non-overlapping, e.g., calling two protocols mutually-exclusive (Russ’s example), or introducing some kind of negative constraint (‘Wrapper: !Foo’) to arbitrarily break overlaps. <br>(2) The issues I mentioned to Russ about the type checker having to treat these as disjunctions, which can lead us into yet more exponential behavior.<br>(3) I don’t think it’s good design; if you’re going to write an extension to make type X conform to protocol P, you should do so in the most general way that is reasonable for X and P—not pick the one-off case you need this moment. This way, when you do hit two ways in which X conforms to P, the compile complains and nudges you to factor the conformance into something more reusable and non-overlapping.<br></p><p><br>&gt; Secondarily, I understand the reason for letting the “least specific” candidate conformance win (it is the most general).  But I wonder if this might leave performance on the table in some cases where a more specific implementation could use knowledge of the more specific details to implement the members more efficiently.  Using the example in your proposal, what if knowing `T` conforms to `S`, not just `R` allows `X5` to provide a more efficient implementation of the members of `P` and `R`?  If so, it seems unfortunate to leave that performance on the table.  Is this a valid concern?  Or is it unlikely to come up often enough in practice to matter?<br></p><p>It’s a valid concern, and I’m sure it does come up in practice. Let’s create a small, self-contained example:<br></p><p>protocol P {<br>  func f()<br>}<br></p><p>protocol Q: P { }<br></p><p>struct X&lt;T&gt; { let t: T}<br></p><p>extension X: P where T: P {<br>  func f() {<br>    /* general but slow */<br>  }<br>}<br></p><p>extension X where T: Q {<br>  func f() {<br>    /* fast because it takes advantage of T: Q */<br>  }<br>}<br></p><p>struct IsQ : Q { }<br></p><p>func generic&lt;U: P&gt;(_ value: u) {<br>  value.f()<br>}<br></p><p>generic(X&lt;IsQ&gt;())<br></p><p>We’d like for the call to “value.f()” to get the fast version of f() from the second extension, but the proposal doesn’t do that: the conformance to P is “locked in” to the first extension.<br></p><p>If we assume that we can see all of the potential implementations of “f” to which we might want to dispatch, we could implement some dynamic scheme that tries to pick the most specialized one. Of course, as with overlapping conformances in general, this selection process could result in ambiguities.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160929/542adb46/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>September 30, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Sep 30, 2016, at 1:23 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 28, 2016, at 4:30 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Is the decision on &quot;no-overlapping-conformances” something that’s seen-as set in stone permanently, set in stone for the near future, or perhaps at least somewhat open to reconsideration at the present moment?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There hasn’t been a decision per se, so it that sense it’s open to reconsideration.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have a strong *personal* bias against overlapping conformances, because I feel that the amount of complexity that they introduce into the language and its implementation far outweigh any benefits.<br>&gt;&gt; <br>&gt;&gt; I would like a bit further clarification on what the prohibition of overlapping conformances implies.<br>&gt; <br>&gt; I think I presented it poorly in the proposal, and will see if I can find a clearer exposition (for posterity, if not soon enough to aid the review).<br>&gt; <br>&gt;&gt;  For example, consider this modification of your example in a Swift that allows for same type constraints in extensions.  Would this be allowed?<br>&gt; <br>&gt; Short answer: no. Longer answer below.<br>&gt; <br>&gt;&gt;  There would be two different conformances to Foo for SomeWrapper, but they would never “overlap” (i.e. both be candidates for the same concrete type).<br>&gt;&gt; struct SomeWrapper&lt;Wrapped&gt; {<br>&gt;&gt;   let wrapped: Wrapped<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol Foo {<br>&gt;&gt; associatedtype Bar<br>&gt;&gt;   func bar() -&gt; Bar<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension SomeWrapper: Foo where Wrapped == String {<br>&gt;&gt;   func bar() -&gt; String {<br>&gt;&gt;     return “Hello&quot;<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension SomeWrapper: Foo where Wrapped == Int {<br>&gt;&gt;   func bar() -&gt; Int {<br>&gt;&gt;     return 0<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt; This is a case where we *could* determine that the two conformances will never overlap, because we can statically determine that trying to satisfy the requirements of both extensions at the same time results in a conflict—Wrapped cannot be both equal to an Int and a String. However, I think it’s a bad idea to allow these two conformances, for a couple of reasons:<br>&gt; <br>&gt; (1) It’s going to immediately feature-creep as developers want to be able to treat more kinds of extensions as non-overlapping, e.g., calling two protocols mutually-exclusive (Russ’s example), or introducing some kind of negative constraint (‘Wrapper: !Foo’) to arbitrarily break overlaps. <br></p><p>Sure, we probably would see requests like this.  The fundamental issue here IMO is that type systems are great until they don’t let you express something that is relatively obvious conceptually, such as the above example.  This if ok as long as there is an alternative available that isn’t clearly worse (as in more boilerplate-y, less expressive, etc) and it is easily assimilated by the community using the language.  But it becomes very frustrating when that isn’t the case.  I’m not sure how often we will fall into the latter bucket because of this restriction but it seems likely to happen from time to time.<br></p><p>&gt; (2) The issues I mentioned to Russ about the type checker having to treat these as disjunctions, which can lead us into yet more exponential behavior.<br></p><p>Does Dave’s idea of not treating SomeWrapper itself as a type help at all here?  That is how I also conceptualize things.  SomeWrapper is a “type constructor” and SomeWrapper&lt;MyConcreteType&gt; is a type.<br></p><p>&gt; (3) I don’t think it’s good design; if you’re going to write an extension to make type X conform to protocol P, you should do so in the most general way that is reasonable for X and P—not pick the one-off case you need this moment. This way, when you do hit two ways in which X conforms to P, the compile complains and nudges you to factor the conformance into something more reusable and non-overlapping.<br></p><p>I agree with this in principle.  However, sometimes a more performant implementation might be possible with more type information (as discussed below).  It may also be the case that sometimes the general implementation is more difficult to write than is worth it for the current application.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; Secondarily, I understand the reason for letting the “least specific” candidate conformance win (it is the most general).  But I wonder if this might leave performance on the table in some cases where a more specific implementation could use knowledge of the more specific details to implement the members more efficiently.  Using the example in your proposal, what if knowing `T` conforms to `S`, not just `R` allows `X5` to provide a more efficient implementation of the members of `P` and `R`?  If so, it seems unfortunate to leave that performance on the table.  Is this a valid concern?  Or is it unlikely to come up often enough in practice to matter?<br>&gt; <br>&gt; It’s a valid concern, and I’m sure it does come up in practice. Let’s create a small, self-contained example:<br>&gt; <br>&gt; protocol P {<br>&gt;   func f()<br>&gt; }<br>&gt; <br>&gt; protocol Q: P { }<br>&gt; <br>&gt; struct X&lt;T&gt; { let t: T}<br>&gt; <br>&gt; extension X: P where T: P {<br>&gt;   func f() {<br>&gt;     /* general but slow */<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; extension X where T: Q {<br>&gt;   func f() {<br>&gt;     /* fast because it takes advantage of T: Q */<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; struct IsQ : Q { }<br>&gt; <br>&gt; func generic&lt;U: P&gt;(_ value: u) {<br>&gt;   value.f()<br>&gt; }<br>&gt; <br>&gt; generic(X&lt;IsQ&gt;())<br>&gt; <br>&gt; We’d like for the call to “value.f()” to get the fast version of f() from the second extension, but the proposal doesn’t do that: the conformance to P is “locked in” to the first extension.<br>&gt; <br>&gt; If we assume that we can see all of the potential implementations of “f” to which we might want to dispatch, we could implement some dynamic scheme that tries to pick the most specialized one. Of course, as with overlapping conformances in general, this selection process could result in ambiguities.<br></p><p>This is what I suspected.  I’ll defer to Dave A on how big a concern this is, but it seems to me like a bit of a slippery slope towards sub-optimal performance.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160930/a8b02fc4/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>September 30, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Sep 28, 2016, at 5:53 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 28, 2016, at 1:28 PM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It’s good to see this starting to happen!<br>&gt;&gt; <br>&gt;&gt; Is the decision on &quot;no-overlapping-conformances” something that’s seen-as set in stone permanently, set in stone for the near future, or perhaps at least somewhat open to reconsideration at the present moment?<br>&gt; <br>&gt; There hasn’t been a decision per se, so it that sense it’s open to reconsideration.<br></p><p>I see. A related question: if overlapping conditional conformances are disallowed in Swift 4, would e.g. ABI concerns make it infeasible to relax that restriction in future Swift (5, 6, X, etc.)? <br></p><p>FWIW my overall 2c is that the right move right now is to leave out overlapping conformances due to the complexity…as long as doing so now doesn’t realistically mean never being able to relax that restriction at some later date. I realize it’s always *possible* to relax it, so to try and be even clearer I really mean “possible to relax it without having to compromise on things like ABI-stability (etc.)”.<br></p><p>Also FWIW my suspicion is that in the absence of overlapping conformances some real pain points will be discovered—and those points *could* be addressed via overlapping conformances—but I also suspect that the majority of these pain points will also be addressable via some simpler mechanism (a constrained form of overlapping, macros, easy wrapper synthesis, etc.).<br></p><p>Thus I’m in favor of banning conditional conformances for now unless doing so now would be the same as doing so “forever”, so to speak.<br></p><p>&gt; I have a strong *personal* bias against overlapping conformances, because I feel that the amount of complexity that they introduce into the language and its implementation far outweigh any benefits. Additionally, they enable use cases (e.g., static metaprogramming-ish tricks) that I feel would be actively harmful to the Swift language’s understandability. Generics systems can get very complicated very quickly, so any extension needs to be strongly motivated by use cases to matter to all or most Swift developers.<br></p><p>This is purely anecdotal but I had a lot of utility code laying around that I’d marked with notes like `// TODO: revisit once conditional conformances are available`.<br></p><p>When I was leaving those notes I was expecting to need overlapping conformances often, but I reviewed them *before* replying and I actually haven’t found an example where having overlapping conformances is both (1) a significant win and also (2) a win in a way that’d be of broad, general interest.<br></p><p>- 80% have no real need for overlapping conditional conformances<br>- 15% might have “elegance gains” but nothing practically-significant<br>- 5% would *probably* see real gains but are likely not of broad interest<br></p><p>…which wasn’t what I was expecting, but leaves me a lot more comfortable without overlapping conformances for now than I was in the abstract.<br></p><p>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 26, 2016, at 7:18 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conditional conformances<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/NNNN-conditional-conformances.md&gt;<br>&gt;&gt;&gt; Author: Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt; Review Manager: TBD<br>&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt; During the review process, add the following fields as needed:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Decision Notes: Rationale &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;, Additional Commentary &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;&gt;&gt; Bugs: SR-NNNN &lt;https://bugs.swift.org/browse/SR-NNNN&gt;, SR-MMMM &lt;https://bugs.swift.org/browse/SR-MMMM&gt;<br>&gt;&gt;&gt; Previous Revision: 1 &lt;https://github.com/apple/swift-evolution/blob/...commit-ID.../proposals/NNNN-filename.md&gt;<br>&gt;&gt;&gt; Previous Proposal: SE-XXXX &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/XXXX-filename.md&gt;<br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conditional conformances express the notion that a generic type will conform to a particular protocol only when it&#39;s type arguments meet certain requirements. For example, the Array collection can implement the Equatable protocol only when its elements are themselves Equatable, which can be expressed via the following conditional conformance on Equatable:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Array: Equatable where Element: Equatable {<br>&gt;&gt;&gt;   static func ==(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; This feature is part of the generics manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-&gt; because it&#39;s something that fits naturally into the generics model and is expected to have a high impact on the Swift standard library.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: TBD: Discussion thread topic for that proposal &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conditional conformances address a hole in the composability of the generics system. Continuing the Array example from above, it&#39;s always been the case that one could use the == operator on two arrays of Equatable type, e.g., [Int]() == [Int]() would succeed. However, it doesn&#39;t compose: arrays of arrays of Equatable types cannot be compared (e.g.,[Int] &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals&gt;== [Int] &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals&gt;will fail to compile) because, even though there is an==for arrays of Equatabletype, the arrays themselves are neverEquatable`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conditional conformances are particularly powerful when building generic adapter types, which are intended to reflect the capabilities of their type arguments. For example, consider the &quot;lazy&quot; functionality of the Swift standard library&#39;s collections: using the lazy member of a sequence produces a lazy adapter that conforms to the Sequence protocol, while using the lazy member of a collection produces a lazy adapter that conforms to the Collection protocol. In Swift 3, the only way to model this is with different types. For example, the Swift standard library has four similar generic types to handle a lazy collection: LazySequence, LazyCollection, LazyBidirectionalCollection, and LazyRandomAccessCollection. The Swift standard library uses overloading of the lazy property to decide among these:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Sequence {<br>&gt;&gt;&gt;   var lazy: LazySequence&lt;Self&gt; { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Collection {<br>&gt;&gt;&gt;   var lazy: LazyCollection&lt;Self&gt; { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension BidirectionalCollection {<br>&gt;&gt;&gt;   var lazy: LazyBidirectionalCollection&lt;Self&gt; { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension RandomAccessCollection {<br>&gt;&gt;&gt;   var lazy: LazyRandomAccessCollection&lt;Self&gt; { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; This approach causes an enormous amount of repetition, and doesn&#39;t scale well because each more-capable type has to re-implement (or somehow forward the implementation of) all of the APIs of the less-capable versions. With conditional conformances, one can provide a single generic wrapper type whose basic requirements meet the lowest common denominator (e.g., Sequence), but which scale their capabilities with their type argument (e.g., the LazySequence conforms to Collection when the type argument does, and so on).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In a nutshell, the proposed solution is to allow a constrained extension of a struct, enum, or class to declare protocol conformances. No additional syntax is necessary for this change, because it already exists in the grammar; rather, this proposal removes the limitation that results in the following error:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; t.swift:1:1: error: extension of type &#39;Array&#39; with constraints cannot have an inheritance clause<br>&gt;&gt;&gt; extension Array: Equatable where Element: Equatable { }<br>&gt;&gt;&gt; ^                ~~~~~~~~~<br>&gt;&gt;&gt; Conditional conformances can only be used when the additional requirements of the constrained extension are satisfied. For example, given the aforementioned Array conformance to Equatable:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f&lt;T: Equatable&gt;(_: T) { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct NotEquatable { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func test(a1: [Int], a2: [NotEquatable]) {<br>&gt;&gt;&gt;   f(a1)    // okay: [Int] conforms to Equatable because Int conforms to Equatable<br>&gt;&gt;&gt;   f(a2)    // error: [NotEquatable] does not conform to Equatable because NotEquatable has no conformance to Equatable<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Conditional conformances also have a run-time aspect, because a dynamic check for a protocol conformance might rely on the evaluation of the extra requirements needed to successfully use a conditional conformance. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;   func doSomething()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S: P {<br>&gt;&gt;&gt;   func doSomething() { print(&quot;S&quot;) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Array conforms to P if it&#39;s element type conforms to P<br>&gt;&gt;&gt; extension Array: P where Element: P {<br>&gt;&gt;&gt;   func doSomething() {<br>&gt;&gt;&gt;     for value in self {<br>&gt;&gt;&gt;       value.doSomething()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Dynamically query and use conformance to P.<br>&gt;&gt;&gt; func doSomethingIfP(_ value: Any) {<br>&gt;&gt;&gt;   if let p = value as? P {<br>&gt;&gt;&gt;     p.doSomething()<br>&gt;&gt;&gt;   } else {<br>&gt;&gt;&gt;     print(&quot;Not a P&quot;)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; doSomethingIfP([S(), S(), S()]) // prints &quot;S&quot; three times<br>&gt;&gt;&gt; doSomethingIfP([1, 2, 3])       // prints &quot;Not a P&quot;<br>&gt;&gt;&gt; The if-let in doSomethingIfP(_:) dynamically queries whether the type stored in value conforms to the protocol P. In the case of an Array, that conformance is conditional, which requires another dynamic lookup to determine whether the element type conforms to P: in the first call to doSomethingIfP(_:), the lookup finds the conformance of S to P. In the second case, there is no conformance of Int to P, so the conditional conformance cannot be used. The desire for this dynamic behavior motivates some of the design decisions in this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#detailed-design&gt;Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Most of the semantics of conditional conformances are obvious. However, there are a number of issues (mostly involving multiple conformances) that require more in-depth design.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#disallow-overlapping-conformances&gt;Disallow overlapping conformances<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With conditional conformances, it is possible to express that a given generic type can conform to the same protocol in two different ways, depending on the capabilities of its type arguments. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct SomeWrapper&lt;Wrapped&gt; {<br>&gt;&gt;&gt;   let wrapped: Wrapped<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol HasIdentity {<br>&gt;&gt;&gt;   static func ===(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension SomeWrapper: Equatable where Wrapped: Equatable {<br>&gt;&gt;&gt;   static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>&gt;&gt;&gt;     return lhs.wrapped == rhs.wrapped<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension SomeWrapper: Equatable where Wrapped: HasIdentity {<br>&gt;&gt;&gt;   static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>&gt;&gt;&gt;     return lhs.wrapped === rhs.wrapped<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Note that, for an arbitrary type T, there are four potential answers to the question of whether SomeWrapper&lt;T&gt; conforms to Equatable:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, it does not conform because T is neither Equatable nor HasIdentity.<br>&gt;&gt;&gt; Yes, it conforms via the first extension of SomeWrapper because T conforms to Equatable.<br>&gt;&gt;&gt; Yes, it conforms via the second extension of SomeWrapper because T conforms to HasIdentity.<br>&gt;&gt;&gt; Ambiguity, because T conforms to both Equatable and HasIdentity.<br>&gt;&gt;&gt; It is due to the possibility of #4 occurring that we refer to the two conditional conformances in the example as overlapping. There are designs that would allow one to address the ambiguity, for example, by writing a third conditional conformance that addresses #4:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Possible tie-breaker conformance<br>&gt;&gt;&gt; extension SomeWrapper: Equatable where Wrapped: Equatable &amp; HasIdentity, {<br>&gt;&gt;&gt;   static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>&gt;&gt;&gt;     return lhs.wrapped == rhs.wrapped<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; The design is consistent, because this third conditional conformance is more specialized the either of the first two conditional conformances, meaning that its requirements are a strict superset of the requirements of those two conditional conformances. However, there are a few downsides to such a system:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To address all possible ambiguities, one has to write a conditional conformance for every plausible combination of overlapping requirements. To statically resolve all ambiguities, one must also cover nonsensical combinations where the two requirements are mutually exclusive (or invent a way to state mutual-exclusivity).<br>&gt;&gt;&gt; It is no longer possible to uniquely say what is required to make a generic type conform to a protocol, because there might be several unrelated possibilities. This makes reasoning about the whole system more complex, because it admits divergent interfaces for the same generic type based on their type arguments. At its extreme, this invites the kind of cleverness we&#39;ve seen in the C++ community with template metaprogramming, which is something Swift has sought to avoid.<br>&gt;&gt;&gt; All of the disambiguation machinery required at compile time (e.g., to determine whether one conditional conformance is more specialized than another to order them) also needs to implements in the run-time, as part of the dynamic casting machinery. One must also address the possibility of ambiguities occurring at run-time. This is both a sharp increase in the complexity of the system and a potential run-time performance hazard.<br>&gt;&gt;&gt; For these reasons, this proposal bans overlapping conformances entirely. While the resulting system is less flexible than one that allowed overlapping conformances, the gain in simplicity in this potentially-confusing area is well worth the cost. Moreover, this ban follows with existing Swift rules regarding multiple conformances, which prohibit the same type from conforming to the same protocol in two different ways:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S : P { }<br>&gt;&gt;&gt; extension S : P { } // error: S already conforms to P<br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#implied-conditional-conformances&gt;Implied conditional conformances<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Stating conformance to a protocol implicitly states conformances to any of the protocols that it inherits. This is the case in Swift today, although most developers likely don&#39;t realize the rules it follows. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P { }<br>&gt;&gt;&gt; protocol Q : P { }<br>&gt;&gt;&gt; protocol R : P { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X1 { }<br>&gt;&gt;&gt; struct X2 { }<br>&gt;&gt;&gt; struct X3 { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X1: Q { }  // implies conformance to P<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X2: Q { }  // would imply conformance to P, but...<br>&gt;&gt;&gt; extension X2: P { }  // explicitly-stated conformance to P &quot;wins&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X3: Q { }  // implies conformance to P<br>&gt;&gt;&gt; extension X3: R { }  // also implies conformance to P<br>&gt;&gt;&gt;                      // one will &quot;win&quot;; which is unspecified<br>&gt;&gt;&gt; With conditional conformances, the question of which extension &quot;wins&quot; the implied conformance begins to matter, because the extensions might have different constraints on them. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X4&lt;T&gt; { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X4: Q where T: Q { }  // implies conformance to P<br>&gt;&gt;&gt; extension X4: R where T: R { }  // error: implies overlapping conformance to P<br>&gt;&gt;&gt; Both of these constrained extensions imply a conformance to P, but the actual P implied conformances to P are overlapping and, therefore, result in an error.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, in cases where there is a reasonable ordering between the two constrained extensions (i.e., one is more specialized than the other), the less specialized constrained extension should &quot;win&quot; the implied conformance. Continuing the example from above:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol S: R { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X5&lt;T&gt; { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X5: R where T: R { }  // &quot;wins&quot; implied conformance to P, because<br>&gt;&gt;&gt; extension X5: S where T: S { }  // the extension where &quot;T: S&quot; is more specialized<br>&gt;&gt;&gt;                                 // than the one where &quot;T: R&quot;<br>&gt;&gt;&gt; Thus, the rule for placing implied conformances is to pick the least specialized extension that implies the conformance. If there is more than one such extension, then either:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; All such extensions are not constrained extensions (i.e., they have no requirements beyond what the type requires), in which case Swift can continue to choose arbitrarily among the extensions, or<br>&gt;&gt;&gt; All such extensions are constrained extensions, in which case the program is ill-formed due to the ambiguity. The developer can explicitly specify conformance to the protocol to disambiguate. <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#overloading-across-constrained-extensions&gt;Overloading across constrained extensions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One particularly important aspect of the placement rule for implied conformances is that it affects which declarations are used to satisfy a particular requirement. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;   func f()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Q: P { }<br>&gt;&gt;&gt; protocol R: Q { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X1&lt;T&gt; { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X1: Q where T: Q {           // note: implied conformance to P here<br>&gt;&gt;&gt;   func f() {<br>&gt;&gt;&gt;     // #1: basic implementation of &#39;f()&#39;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X1: R where T: R {<br>&gt;&gt;&gt;   func f() {<br>&gt;&gt;&gt;     // #2: superfast implementation of f() using some knowledge of &#39;R&#39;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X2: R {<br>&gt;&gt;&gt;   func f() { }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (X1&lt;X2&gt;() as P).f() // calls #1, which was used to satisfy the requirement for &#39;f&#39;<br>&gt;&gt;&gt; X1&lt;X2&gt;().f()        // calls #2, which is preferred by overload resolution<br>&gt;&gt;&gt; Effectively, when satisfying a protocol requirement, one can only choose from members of the type that are guaranteed to available within the extension with which the conformance is associated. In this case, the conformance to P is placed on the first extension of X1, so the only f() that can be considered is the f() within that extension: the f() in the second extension won&#39;t necessarily always be available, because T may not conform to R. Hence, the call that treats an X1&lt;X2&gt;as a P gets the first implementation of X1.f(). When using the concrete type X1&lt;X2&gt;, where X2 conforms to R, both X.f() implementations are visible... and the second is more specialized.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Technically, this issue is no different from surprises where (e.g.) a member added to a concrete type in a different module won&#39;t affect an existing protocol conformance. The existing ideas to mediate these problems---warning for nearly-matching functions when they are declared in concrete types, for example---will likely be sufficient to help surprised users. That said, this proposal may increase the likelihood of such problems showing up.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#source-compatibility&gt;Source compatibility<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From the language perspective, conditional conformances are purely additive. They introduce no new syntax, but instead provide semantics for existing syntax---an extension that both declares a protocol conformance and has a where clause---whose use currently results in a type checker failure. That said, this is a feature that is expected to be widely adopted within the Swift standard library, which may indirectly affect source compatibility.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#effect-on-abi-stability&gt;Effect on ABI Stability<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As noted above, there are a number of places where the standard library is expected to adopt this feature, which fall into two classes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Improve composability: the example in the introduction &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/Introduction&gt; made Array conform to Equatable when its element type does; there are many places in the Swift standard library that could benefit from this form of conditional conformance, particularly so that collections and other types that contain values (e.g., Optional) can compose better with generic algorithms. Most of these changes won&#39;t be ABI- or source-breaking, because they&#39;re additive.<br>&gt;&gt;&gt; Eliminating repetition: the lazy wrappers described in the motivation &lt;https://github.com/DougGregor/swift-evolution/blob/conditional-conformances/proposals/motivation&gt; section could be collapsed into a single wrapper with several conditional conformances. A similar refactoring could also be applied to the range abstractions and slice types in the standard library, making the library itself simpler and smaller. All of these changes are potentially source-breaking and ABI-breaking, because they would remove types that could be used in Swift 3 code. However, there are mitigations: generic typealiases could provide source compatibility to Swift 3 clients, and the ABI-breaking aspect is only relevant if conditional conformances and the standard library changes they imply aren&#39;t part of Swift 4.<br>&gt;&gt;&gt; Aside from the standard library, conditional conformances have an impact on the Swift runtime, which will require specific support to handle dynamic casting. If that runtime support is not available once ABI stability has been declared, then introducing conditional conformances in a later language version either means the feature cannot be deployed backward or that it would provide only more limited, static behavior when used on older runtimes. Hence, there is significant motivation for doing this feature as part of Swift 4. Even if we waited to introduce conditional conformances, we would want to include a hook in the runtime to allow them to be implemented later, to avoid future backward-compatibility issues.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The most common request related to conditional conformances is to allow a (constrained) protocol extension to declare conformance to a protocol. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Collection: Equatable where Iterator.Element: Equatable {<br>&gt;&gt;&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;     // ...<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; This protocol extension will make any Collection of Equatable elements Equatable, which is a powerful feature that could be put to good use. Introducing conditional conformances for protocol extensions would exacerbate the problem of overlapping conformances, because it would be unreasonable to say that the existence of the above protocol extension means that no type that conforms to Collection could declare its own conformance to Equatable, conditional or otherwise.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160930/396d8e3b/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September 30, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Sep 30, 2016, at 6:25 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 28, 2016, at 5:53 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 28, 2016, at 1:28 PM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s good to see this starting to happen!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is the decision on &quot;no-overlapping-conformances” something that’s seen-as set in stone permanently, set in stone for the near future, or perhaps at least somewhat open to reconsideration at the present moment?<br>&gt;&gt; <br>&gt;&gt; There hasn’t been a decision per se, so it that sense it’s open to reconsideration.<br>&gt; <br>&gt; I see. A related question: if overlapping conditional conformances are disallowed in Swift 4, would e.g. ABI concerns make it infeasible to relax that restriction in future Swift (5, 6, X, etc.)?<br></p><p>It’s hard to be definitive without having a specific design for what overlapping conditional conformances would mean, but I feel fairly confident that we could introduce them later in some form. It would almost certainly involve deployment limitations—one would not be able to dynamically query for an overlapping conformance and have that code run correctly on a Swift 4 runtime—but the general scheme in the ABI should generalize. <br></p><p>&gt; <br>&gt;&gt; I have a strong *personal* bias against overlapping conformances, because I feel that the amount of complexity that they introduce into the language and its implementation far outweigh any benefits. Additionally, they enable use cases (e.g., static metaprogramming-ish tricks) that I feel would be actively harmful to the Swift language’s understandability. Generics systems can get very complicated very quickly, so any extension needs to be strongly motivated by use cases to matter to all or most Swift developers.<br>&gt; <br>&gt; This is purely anecdotal but I had a lot of utility code laying around that I’d marked with notes like `// TODO: revisit once conditional conformances are available`.<br>&gt; <br>&gt; When I was leaving those notes I was expecting to need overlapping conformances often, but I reviewed them *before* replying and I actually haven’t found an example where having overlapping conformances is both (1) a significant win and also (2) a win in a way that’d be of broad, general interest.<br>&gt; <br>&gt; - 80% have no real need for overlapping conditional conformances<br>&gt; - 15% might have “elegance gains” but nothing practically-significant<br>&gt; - 5% would *probably* see real gains but are likely not of broad interest<br>&gt; <br>&gt; …which wasn’t what I was expecting, but leaves me a lot more comfortable without overlapping conformances for now than I was in the abstract.<br></p><p>Very interesting, thanks for doing this review!<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160930/02cdde84/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>October  2, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Sep 30, 2016, at 1:23 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is purely anecdotal but I had a lot of utility code laying around that I’d marked with notes like `// TODO: revisit once conditional conformances are available`.<br>&gt;&gt; <br>&gt;&gt; When I was leaving those notes I was expecting to need overlapping conformances often, but I reviewed them *before* replying and I actually haven’t found an example where having overlapping conformances is both (1) a significant win and also (2) a win in a way that’d be of broad, general interest.<br>&gt;&gt; <br>&gt;&gt; - 80% have no real need for overlapping conditional conformances<br>&gt;&gt; - 15% might have “elegance gains” but nothing practically-significant<br>&gt;&gt; - 5% would *probably* see real gains but are likely not of broad interest<br>&gt;&gt; <br>&gt;&gt; …which wasn’t what I was expecting, but leaves me a lot more comfortable without overlapping conformances for now than I was in the abstract.<br>&gt; <br>&gt; Very interesting, thanks for doing this review!<br></p><p>I&#39;ve taken the time to provide a bit more color on the 80/15/5 breakdown because I don&#39;t see much discussion for this proposal in terms of concrete situations...just theoretical concerns and theoretical possibilities. I don&#39;t have any completed code either, but I have notes and to-do lists for things I was planning to do, and I think seeing even some semi-concrete scenarios might be helpful here.<br></p><p>The &quot;80%&quot; are generally analogous to the `SomeWrapper` in the writeup; as a concrete example, I was waiting on the availability of conditional conformances to resume work on an emulation of structural unions, e.g. something like:<br></p><p>  enum Sum2&lt;A,B&gt; {<br>    case a(A)<br>    case b(B)<br>  }<br>  <br>...(and analogously for 3, 4, as-necessary). <br></p><p>There&#39;s a very obvious way to write `extension Sum2 : Equatable where A:Equatable, B:Equatable {}`...and at the time I set this aside, I was expecting to also want to come back and have additional conformances for things like `...where A:Equatable, B:AnyObject` (using `===` for comparing `B`) and so on for other combinations.<br></p><p>Upon revisiting such things in light of the proposal, I now think differently: for this case it seems like a better long-term approach anyways to stick to a single conformance and work with it like this:<br></p><p>  extension Sum2:Equatable where A:Equatable, B:Equatable {<br>    // details elided<br>  }<br>  <br>  /// Adaptor using `ObjectIdentifier` to implement `==`.<br>  struct ObjectWrapper&lt;Wrapped:AnyObject&gt; : Equatable, Hashable {<br>    let wrapped: Wrapped<br>  }<br>  <br>...as upon reflection I really would prefer dealing with the hassle of working with `Sum2&lt;A,ObjectWrapper&lt;B&gt;&gt;` in situations where -- in theory -- `Sum2&lt;A,B&gt;` could do -- to the hassle of writing out 4+ conformances for `Sum2` (and so on...even with nice code-gen tools that&#39;s going to be a lot of bloat!). <br></p><p>What changed my mind was tracing through the implications of conditional conformances for the use-site ergonomics of adaptors like `ObjectWrapper` above; what I mean is, suppose I have a protocol like this:<br></p><p>  protocol WidgetFactory {<br>    associatedtype Widget<br>    associatedtype Material<br>    <br>    func produceWidget(using material: Material) -&gt; Widget<br>  }<br></p><p>...then it&#39;s rather easy to simply write this type of boilerplate:<br></p><p>  extension ObjectWrapper: WidgetFactory where Wrapped: WidgetFactory {<br>    typealias Widget = Wrapper.Widget<br>    typealias Material = Wrapper.Material<br>    <br>    func produceWidget(using material: Material) -&gt; Widget {<br>      return base.produceWidget(using: material)<br>    }<br>  }<br>  <br>...which thus means I have the tools I need to make my use of wrappers like the `ObjectWrapper` largely transparent at the use sites I care about; e.g. I can write a single conditional conformance like this:<br></p><p>  extension Sum2: WidgetFactory <br>    where <br>    A:WidgetFactory, B:WidgetFactory,<br>    A.Material == B.Material,<br>    A.Widget == B.Widget {<br>    <br>    typealias Widget = A.Widget<br>    typealias Material = A.Material<br>    <br>    func produceWidget(using material: Material) throws -&gt; Widget {<br>      switch self {<br>        case let .a(aa): return aa.produceWidget(using: material)<br>        case let .b(bb): return bb.produceWidget(using: material)<br>      }<br>    }<br>    <br>  }<br>  <br>...and it will apply even in situations where circumstances left me using `ObjectWrapper` (or similar) on any of the type parameters to `Sum2` (e.g. if I also needed an `Equatable` conformance for whatever reason).<br></p><p>At least for now--when I&#39;m still just revisiting plans and thinking about it in light of the proposal--I really would prefer having a simpler language and writing this type of boilerplate, than having a more-complex language and writing the *other* type of boilerplate (e.g. the 4+ `Equatable` conformances here, and so on for other situations).<br></p><p>Note that I&#39;m not claiming the above is the only use for overlapping conditional conformances -- not at all! -- just that situations like the above comprise about 80% of the things I was intending to do with conditional conformances...and that after revisiting them expecting to be troubled by the proposed banning of overlapping conformances, I&#39;m now thinking I&#39;d wind up not using the overlapping-conformance approach in such cases even if it were available.<br></p><p>So that&#39;s the first 80%.<br></p><p>Moving on, the next 15% are places where there&#39;s some forced theoretical or aesthetic inelegance due to the lack of overlapping conformances, but none of these seem to have any significant practical import.<br></p><p>A representative case here is that I currently have the following pair:<br></p><p>  /// `ChainSequence2(a,b)` enumerates the elements of `a` then `b`.<br>  struct ChainSequence2&lt;A:Sequence,B:Sequence&gt; : Sequence<br>    where A.Iterator.Element == B.Iterator.Element  {<br>    // elided<br>  }<br></p><p>  /// `ChainCollection2(a,b)` enumerates the elements of `a` then `b`.<br>  struct ChainCollection2&lt;A:Collection,B:Collection&gt; : Collection<br>    where A.Iterator.Element == B.Iterator.Element {<br>    // ^ `where` is not quite right, see below<br>  }<br></p><p>...and obviously conditional conformances will allow these to be consolidated into a single `Chain2` type that then has appropriate conditional conformances (and for which the cost/benefit for me will tip in favor of adding conditional conformances to `BidirectionalCollection` and `RandomAccessCollection`, also).<br></p><p>On paper--e.g., theoretically--the lack of overlapping conformances leaves in a few aesthetic issues...for example, at present `ChainCollection2` actually has to be one of these:<br></p><p>  // &quot;narrower&quot; option: not all `A`, `B` can necessarily be used together:<br>  struct ChainCollection2&lt;A:Collection,B:Collection&gt; : Collection<br>    where <br>    A.Iterator.Element == B.Iterator.Element,<br>    A.IndexDistance == B.IndexDistance {<br>    typealias IndexDistance = A.IndexDistance<br>  }<br></p><p>  // &quot;wasteful&quot; option: theoretically in some cases we are &quot;overpaying&quot; and <br>  // using a stronger `IndexDistance`, but now we can use any `A` and `B`<br>  struct ChainCollection2&lt;A:Collection,B:Collection&gt; : Collection<br>    where A.Iterator.Element == B.Iterator.Element {<br>    typealias IndexDistance = IntMax<br>  }<br></p><p>With overlapping conditional conformances you could have both: one conformance that uses base collections&#39; `IndexDistance` when possible, and another that uses `IntMax` when necessary...but without conditional conformances it&#39;s necessary to choose between the &quot;narrower&quot; approach or the &quot;wasteful&quot; approach (preserving the status quo).<br></p><p>If you&#39;re following along I&#39;m sure you&#39;re aware that in this specific case, this &quot;choice&quot; is purely academic (or purely aesthetic)...if you go with the `IntMax` route there&#39;s almost always going to be between &quot;no actual difference&quot; and &quot;no measurable difference&quot;, so even if it *maybe* feels a bit icky the right thing to do is get over it and stop making a mountain out of an anthill.<br></p><p>Note that I&#39;m well aware that you can choose to see this as a concrete instance of a more-general problem -- that the lack of overlapping conformances would potentially leave a lot of performance on the table due to forcing similar decisions (and in contexts where there *would* be a real difference!) -- but speaking personally I couldn&#39;t find very much in my &quot;chores pending availability of conditional conformance&quot; that both (a) fell into this category and (b) had more than &quot;aesthetic&quot; implications. <br></p><p>This brings me to that last 5% -- the handful of things for which overlapping conformances have nontrivial benefits -- and my conclusion here is that these tended to be things I doubt are of general interest.<br></p><p>An example here is that I like to use a function that takes two sequences and enumerates their &quot;cartesian product&quot;, with the following adjustments:<br></p><p>- no specific enumeration *ordering* is guaranteed<br>- does something useful even with infinite, one-shot sequences...<br>- ...meaning specifically that it will eventual-visit any specific pair (even when one or both inputs are infinite, one-shot)<br></p><p>...(useful for doing unit tests, mostly), which to be done &quot;optimally&quot; while also dotting all the is and crossing all the ts would currently require at least 8 concrete types:<br></p><p>- 4 sequences, like e.g.:<br>  - UnorderedProductSS2&lt;A:Sequence, B:Sequence&gt;<br>  - UnorderedProductSC2&lt;A:Sequence, B:Collection&gt;<br>  - UnorderedProductCS2&lt;A:Collection, B:Sequence&gt;<br>  - UnorderedProductCC2&lt;A:Collection, B:Collection&gt;<br>- 4 iterators (one for each of the above)<br></p><p>...since you need to use a different iteration strategy for each (yes you don’t *need* 8 types, but I’m trying to “dott all is, cross all ts” here). <br></p><p>In theory overlapping conditional conformances could be used to cut that down to only 5 types:<br></p><p>- 1 type like `UnorderedProduct&lt;A:Sequence,B:Sequence&gt;`<br>- the same 4 iterators from before, each used with the appropriate conformance<br></p><p>...which *is* less code *and* seemingly provides nontrivial gains (the `SS` variant must maintain buffers of the items it&#39;s already seen from each underlying sequence, but the others have no such requirement).<br></p><p>But, to be honest, even if those gains are realized, this is the kind of situation I&#39;m perfectly comfortable saying is a &quot;niche&quot; and neither broadly relevant to the majority of Swift developers nor broadly relevant to the majority of Swift code; if overlapping conformances were available I&#39;d use them here, but I&#39;m not going to ask for them just to be able to use them here.<br></p><p>Also, I&#39;m skeptical these gains would be realized in practice: between the proposed &quot;least specialized conformance wins&quot; rule and Swift&#39;s existing dispatch rules in generic contexts, it seems like even if overlapping conformances *were* allowed and I *did* use them, I&#39;d still wind up getting dispatched to the pessimal `SS` variant in many cases for which I&#39;d have been hoping for one of the more-optimal versions.<br></p><p>So between the niche-ness of such uses -- and their being 5% or less of what I was hoping to do -- and my skepticism about how dispatch would pan out in practice, I can&#39;t get behind fighting for overlapping conformances at this time unless they&#39;d be permanently banned by banning them now.<br></p><p>As already stated, I do think that their absence *will* reveal some *true* pain points, but I think it makes sense to adopt a &quot;wait-and-see&quot; approach here as some more-targeted solution could wind up being enough to address the majority of those future pain points.<br></p><p>These are my more-detailed thoughts after looking at what I was planning to do with conditional conformances once the became available. I realize it doesn&#39;t touch on every conceivable scenario and every conceivable use, but I want to reiterate that I did my review expecting to find a bunch of things that I could use as justifications for why Swift absolutely should have overlapping conditional conformances right now...but on actually looking at my plans, I couldn&#39;t find anything for which I actually felt that way.<br></p><p>&gt; <br>&gt; 	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161002/07f0215d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0411520c60ef1131670f84bb42dc8949?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Swift)</string> &lt;swift-callionica at callionica.com (Callionica&gt;<p>October  2, 2016 at 08:00:00am</p></header><div class="content"><p>Interesting comment about worries that you&#39;d be dispatched to the least<br>good SS version . A different language with different constraints, but when<br>LINQ to Objects implementers needed to provide optimized c# implementations<br>for some operations they chose a runtime type check to dispatch to the<br>optimized version. For example, while API is exposed as IEnumerable&lt;T&gt;<br>there are method implementations that check for ICollection&lt;T&gt; at runtime<br>in order to hit more efficient implementations. So static dispatch is good,<br>but win for collections often big enough to overcome a hit from dynamic<br>dispatch.<br></p><p>On Sunday, October 2, 2016, plx via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Sep 30, 2016, at 1:23 PM, Douglas Gregor &lt;dgregor at apple.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;dgregor at apple.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt; This is purely anecdotal but I had a lot of utility code laying around<br>&gt; that I’d marked with notes like `// TODO: revisit once conditional<br>&gt; conformances are available`.<br>&gt;<br>&gt; When I was leaving those notes I was expecting to need overlapping<br>&gt; conformances often, but I reviewed them *before* replying and I actually<br>&gt; haven’t found an example where having overlapping conformances is both (1)<br>&gt; a significant win and also (2) a win in a way that’d be of broad, general<br>&gt; interest.<br>&gt;<br>&gt; - 80% have no real need for overlapping conditional conformances<br>&gt; - 15% might have “elegance gains” but nothing practically-significant<br>&gt; - 5% would *probably* see real gains but are likely not of broad interest<br>&gt;<br>&gt; …which wasn’t what I was expecting, but leaves me a lot more comfortable<br>&gt; without overlapping conformances for now than I was in the abstract.<br>&gt;<br>&gt;<br>&gt; Very interesting, thanks for doing this review!<br>&gt;<br>&gt;<br>&gt; I&#39;ve taken the time to provide a bit more color on the 80/15/5 breakdown<br>&gt; because I don&#39;t see much discussion for this proposal in terms of concrete<br>&gt; situations...just theoretical concerns and theoretical possibilities. I<br>&gt; don&#39;t have any completed code either, but I have notes and to-do lists for<br>&gt; things I was planning to do, and I think seeing even some semi-concrete<br>&gt; scenarios might be helpful here.<br>&gt;<br>&gt; The &quot;80%&quot; are generally analogous to the `SomeWrapper` in the writeup; as<br>&gt; a concrete example, I was waiting on the availability of conditional<br>&gt; conformances to resume work on an emulation of structural unions, e.g.<br>&gt; something like:<br>&gt;<br>&gt;   enum Sum2&lt;A,B&gt; {<br>&gt;     case a(A)<br>&gt;     case b(B)<br>&gt;   }<br>&gt;<br>&gt; ...(and analogously for 3, 4, as-necessary).<br>&gt;<br>&gt; There&#39;s a very obvious way to write `extension Sum2 : Equatable where<br>&gt; A:Equatable, B:Equatable {}`...and at the time I set this aside, I was<br>&gt; expecting to also want to come back and have additional conformances for<br>&gt; things like `...where A:Equatable, B:AnyObject` (using `===` for comparing<br>&gt; `B`) and so on for other combinations.<br>&gt;<br>&gt; Upon revisiting such things in light of the proposal, I now think<br>&gt; differently: for this case it seems like a better long-term approach<br>&gt; anyways to stick to a single conformance and work with it like this:<br>&gt;<br>&gt;   extension Sum2:Equatable where A:Equatable, B:Equatable {<br>&gt;     // details elided<br>&gt;   }<br>&gt;<br>&gt;   /// Adaptor using `ObjectIdentifier` to implement `==`.<br>&gt;   struct ObjectWrapper&lt;Wrapped:AnyObject&gt; : Equatable, Hashable {<br>&gt;     let wrapped: Wrapped<br>&gt;   }<br>&gt;<br>&gt; ...as upon reflection I really would prefer dealing with the hassle of<br>&gt; working with `Sum2&lt;A,ObjectWrapper&lt;B&gt;&gt;` in situations where -- in theory --<br>&gt; `Sum2&lt;A,B&gt;` could do -- to the hassle of writing out 4+ conformances for<br>&gt; `Sum2` (and so on...even with nice code-gen tools that&#39;s going to be a lot<br>&gt; of bloat!).<br>&gt;<br>&gt; What changed my mind was tracing through the implications of conditional<br>&gt; conformances for the use-site ergonomics of adaptors like `ObjectWrapper`<br>&gt; above; what I mean is, suppose I have a protocol like this:<br>&gt;<br>&gt;   protocol WidgetFactory {<br>&gt;     associatedtype Widget<br>&gt;     associatedtype Material<br>&gt;<br>&gt;     func produceWidget(using material: Material) -&gt; Widget<br>&gt;   }<br>&gt;<br>&gt; ...then it&#39;s rather easy to simply write this type of boilerplate:<br>&gt;<br>&gt;   extension ObjectWrapper: WidgetFactory where Wrapped: WidgetFactory {<br>&gt;     typealias Widget = Wrapper.Widget<br>&gt;     typealias Material = Wrapper.Material<br>&gt;<br>&gt;     func produceWidget(using material: Material) -&gt; Widget {<br>&gt;       return base.produceWidget(using: material)<br>&gt;     }<br>&gt;   }<br>&gt;<br>&gt; ...which thus means I have the tools I need to make my use of wrappers<br>&gt; like the `ObjectWrapper` largely transparent at the use sites I care about;<br>&gt; e.g. I can write a single conditional conformance like this:<br>&gt;<br>&gt;   extension Sum2: WidgetFactory<br>&gt;     where<br>&gt;     A:WidgetFactory, B:WidgetFactory,<br>&gt;     A.Material == B.Material,<br>&gt;     A.Widget == B.Widget {<br>&gt;<br>&gt;     typealias Widget = A.Widget<br>&gt;     typealias Material = A.Material<br>&gt;<br>&gt;     func produceWidget(using material: Material) throws -&gt; Widget {<br>&gt;       switch self {<br>&gt;         case let .a(aa): return aa.produceWidget(using: material)<br>&gt;         case let .b(bb): return bb.produceWidget(using: material)<br>&gt;       }<br>&gt;     }<br>&gt;<br>&gt;   }<br>&gt;<br>&gt; ...and it will apply even in situations where circumstances left me using<br>&gt; `ObjectWrapper` (or similar) on any of the type parameters to `Sum2` (e.g.<br>&gt; if I also needed an `Equatable` conformance for whatever reason).<br>&gt;<br>&gt; At least for now--when I&#39;m still just revisiting plans and thinking about<br>&gt; it in light of the proposal--I really would prefer having a simpler<br>&gt; language and writing this type of boilerplate, than having a more-complex<br>&gt; language and writing the *other* type of boilerplate (e.g. the 4+<br>&gt; `Equatable` conformances here, and so on for other situations).<br>&gt;<br>&gt; Note that I&#39;m not claiming the above is the only use for overlapping<br>&gt; conditional conformances -- not at all! -- just that situations like the<br>&gt; above comprise about 80% of the things I was intending to do with<br>&gt; conditional conformances...and that after revisiting them expecting to be<br>&gt; troubled by the proposed banning of overlapping conformances, I&#39;m now<br>&gt; thinking I&#39;d wind up not using the overlapping-conformance approach in such<br>&gt; cases even if it were available.<br>&gt;<br>&gt; So that&#39;s the first 80%.<br>&gt;<br>&gt; Moving on, the next 15% are places where there&#39;s some forced theoretical<br>&gt; or aesthetic inelegance due to the lack of overlapping conformances, but<br>&gt; none of these seem to have any significant practical import.<br>&gt;<br>&gt; A representative case here is that I currently have the following pair:<br>&gt;<br>&gt;   /// `ChainSequence2(a,b)` enumerates the elements of `a` then `b`.<br>&gt;   struct ChainSequence2&lt;A:Sequence,B:Sequence&gt; : Sequence<br>&gt;     where A.Iterator.Element == B.Iterator.Element  {<br>&gt;     // elided<br>&gt;   }<br>&gt;<br>&gt;   /// `ChainCollection2(a,b)` enumerates the elements of `a` then `b`.<br>&gt;   struct ChainCollection2&lt;A:Collection,B:Collection&gt; : Collection<br>&gt;     where A.Iterator.Element == B.Iterator.Element {<br>&gt;     // ^ `where` is not quite right, see below<br>&gt;   }<br>&gt;<br>&gt; ...and obviously conditional conformances will allow these to be<br>&gt; consolidated into a single `Chain2` type that then has appropriate<br>&gt; conditional conformances (and for which the cost/benefit for me will tip in<br>&gt; favor of adding conditional conformances to `BidirectionalCollection` and<br>&gt; `RandomAccessCollection`, also).<br>&gt;<br>&gt; On paper--e.g., theoretically--the lack of overlapping conformances leaves<br>&gt; in a few aesthetic issues...for example, at present `ChainCollection2`<br>&gt; actually has to be one of these:<br>&gt;<br>&gt;   // &quot;narrower&quot; option: not all `A`, `B` can necessarily be used together:<br>&gt;   struct ChainCollection2&lt;A:Collection,B:Collection&gt; : Collection<br>&gt;     where<br>&gt;     A.Iterator.Element == B.Iterator.Element,<br>&gt;     A.IndexDistance == B.IndexDistance {<br>&gt;     typealias IndexDistance = A.IndexDistance<br>&gt;   }<br>&gt;<br>&gt;   // &quot;wasteful&quot; option: theoretically in some cases we are &quot;overpaying&quot;<br>&gt; and<br>&gt;   // using a stronger `IndexDistance`, but now we can use any `A` and `B`<br>&gt;   struct ChainCollection2&lt;A:Collection,B:Collection&gt; : Collection<br>&gt;     where A.Iterator.Element == B.Iterator.Element {<br>&gt;     typealias IndexDistance = IntMax<br>&gt;   }<br>&gt;<br>&gt; With overlapping conditional conformances you could have both: one<br>&gt; conformance that uses base collections&#39; `IndexDistance` when possible, and<br>&gt; another that uses `IntMax` when necessary...but without conditional<br>&gt; conformances it&#39;s necessary to choose between the &quot;narrower&quot; approach or<br>&gt; the &quot;wasteful&quot; approach (preserving the status quo).<br>&gt;<br>&gt; If you&#39;re following along I&#39;m sure you&#39;re aware that in this specific<br>&gt; case, this &quot;choice&quot; is purely academic (or purely aesthetic)...if you go<br>&gt; with the `IntMax` route there&#39;s almost always going to be between &quot;no<br>&gt; actual difference&quot; and &quot;no measurable difference&quot;, so even if it *maybe*<br>&gt; feels a bit icky the right thing to do is get over it and stop making a<br>&gt; mountain out of an anthill.<br>&gt;<br>&gt; Note that I&#39;m well aware that you can choose to see this as a concrete<br>&gt; instance of a more-general problem -- that the lack of overlapping<br>&gt; conformances would potentially leave a lot of performance on the table due<br>&gt; to forcing similar decisions (and in contexts where there *would* be a real<br>&gt; difference!) -- but speaking personally I couldn&#39;t find very much in my<br>&gt; &quot;chores pending availability of conditional conformance&quot; that both (a) fell<br>&gt; into this category and (b) had more than &quot;aesthetic&quot; implications.<br>&gt;<br>&gt; This brings me to that last 5% -- the handful of things for which<br>&gt; overlapping conformances have nontrivial benefits -- and my conclusion here<br>&gt; is that these tended to be things I doubt are of general interest.<br>&gt;<br>&gt; An example here is that I like to use a function that takes two sequences<br>&gt; and enumerates their &quot;cartesian product&quot;, with the following adjustments:<br>&gt;<br>&gt; - no specific enumeration *ordering* is guaranteed<br>&gt; - does something useful even with infinite, one-shot sequences...<br>&gt; - ...meaning specifically that it will eventual-visit any specific pair<br>&gt; (even when one or both inputs are infinite, one-shot)<br>&gt;<br>&gt; ...(useful for doing unit tests, mostly), which to be done &quot;optimally&quot;<br>&gt; while also dotting all the is and crossing all the ts would currently<br>&gt; require at least 8 concrete types:<br>&gt;<br>&gt; - 4 sequences, like e.g.:<br>&gt;   - UnorderedProductSS2&lt;A:Sequence, B:Sequence&gt;<br>&gt;   - UnorderedProductSC2&lt;A:Sequence, B:Collection&gt;<br>&gt;   - UnorderedProductCS2&lt;A:Collection, B:Sequence&gt;<br>&gt;   - UnorderedProductCC2&lt;A:Collection, B:Collection&gt;<br>&gt; - 4 iterators (one for each of the above)<br>&gt;<br>&gt; ...since you need to use a different iteration strategy for each (yes you<br>&gt; don’t *need* 8 types, but I’m trying to “dott all is, cross all ts” here).<br>&gt;<br>&gt; In theory overlapping conditional conformances could be used to cut that<br>&gt; down to only 5 types:<br>&gt;<br>&gt; - 1 type like `UnorderedProduct&lt;A:Sequence,B:Sequence&gt;`<br>&gt; - the same 4 iterators from before, each used with the appropriate<br>&gt; conformance<br>&gt;<br>&gt; ...which *is* less code *and* seemingly provides nontrivial gains (the<br>&gt; `SS` variant must maintain buffers of the items it&#39;s already seen from each<br>&gt; underlying sequence, but the others have no such requirement).<br>&gt;<br>&gt; But, to be honest, even if those gains are realized, this is the kind of<br>&gt; situation I&#39;m perfectly comfortable saying is a &quot;niche&quot; and neither broadly<br>&gt; relevant to the majority of Swift developers nor broadly relevant to the<br>&gt; majority of Swift code; if overlapping conformances were available I&#39;d use<br>&gt; them here, but I&#39;m not going to ask for them just to be able to use them<br>&gt; here.<br>&gt;<br>&gt; Also, I&#39;m skeptical these gains would be realized in practice: between the<br>&gt; proposed &quot;least specialized conformance wins&quot; rule and Swift&#39;s existing<br>&gt; dispatch rules in generic contexts, it seems like even if overlapping<br>&gt; conformances *were* allowed and I *did* use them, I&#39;d still wind up getting<br>&gt; dispatched to the pessimal `SS` variant in many cases for which I&#39;d have<br>&gt; been hoping for one of the more-optimal versions.<br>&gt;<br>&gt; So between the niche-ness of such uses -- and their being 5% or less of<br>&gt; what I was hoping to do -- and my skepticism about how dispatch would pan<br>&gt; out in practice, I can&#39;t get behind fighting for overlapping conformances<br>&gt; at this time unless they&#39;d be permanently banned by banning them now.<br>&gt;<br>&gt; As already stated, I do think that their absence *will* reveal some *true*<br>&gt; pain points, but I think it makes sense to adopt a &quot;wait-and-see&quot; approach<br>&gt; here as some more-targeted solution could wind up being enough to address<br>&gt; the majority of those future pain points.<br>&gt;<br>&gt; These are my more-detailed thoughts after looking at what I was planning<br>&gt; to do with conditional conformances once the became available. I realize it<br>&gt; doesn&#39;t touch on every conceivable scenario and every conceivable use, but<br>&gt; I want to reiterate that I did my review expecting to find a bunch of<br>&gt; things that I could use as justifications for why Swift absolutely should<br>&gt; have overlapping conditional conformances right now...but on actually<br>&gt; looking at my plans, I couldn&#39;t find anything for which I actually felt<br>&gt; that way.<br>&gt;<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161002/e0b1d29b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October  3, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Oct 2, 2016, at 8:56 AM, Callionica (Swift) via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Interesting comment about worries that you&#39;d be dispatched to the least good SS version . A different language with different constraints, but when LINQ to Objects implementers needed to provide optimized c# implementations for some operations they chose a runtime type check to dispatch to the optimized version. For example, while API is exposed as IEnumerable&lt;T&gt; there are method implementations that check for ICollection&lt;T&gt; at runtime in order to hit more efficient implementations. So static dispatch is good, but win for collections often big enough to overcome a hit from dynamic dispatch. <br></p><p>Yep, and Swift&#39;s specialization optimization already knows how to fold `is` and `as` checks after specializing a generic, so checking for a specific type or sub-protocol and jumping into a more optimized implementation for that subtype &quot;dynamically&quot; is still likely to be optimized away.<br></p><p>-Joe<br></p><p>&gt; On Sunday, October 2, 2016, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Sep 30, 2016, at 1:23 PM, Douglas Gregor &lt;dgregor at apple.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;dgregor at apple.com&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is purely anecdotal but I had a lot of utility code laying around that I’d marked with notes like `// TODO: revisit once conditional conformances are available`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When I was leaving those notes I was expecting to need overlapping conformances often, but I reviewed them *before* replying and I actually haven’t found an example where having overlapping conformances is both (1) a significant win and also (2) a win in a way that’d be of broad, general interest.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - 80% have no real need for overlapping conditional conformances<br>&gt;&gt;&gt; - 15% might have “elegance gains” but nothing practically-significant<br>&gt;&gt;&gt; - 5% would *probably* see real gains but are likely not of broad interest<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …which wasn’t what I was expecting, but leaves me a lot more comfortable without overlapping conformances for now than I was in the abstract.<br>&gt;&gt; <br>&gt;&gt; Very interesting, thanks for doing this review!<br>&gt; <br>&gt; I&#39;ve taken the time to provide a bit more color on the 80/15/5 breakdown because I don&#39;t see much discussion for this proposal in terms of concrete situations...just theoretical concerns and theoretical possibilities. I don&#39;t have any completed code either, but I have notes and to-do lists for things I was planning to do, and I think seeing even some semi-concrete scenarios might be helpful here.<br>&gt; <br>&gt; The &quot;80%&quot; are generally analogous to the `SomeWrapper` in the writeup; as a concrete example, I was waiting on the availability of conditional conformances to resume work on an emulation of structural unions, e.g. something like:<br>&gt; <br>&gt;   enum Sum2&lt;A,B&gt; {<br>&gt;     case a(A)<br>&gt;     case b(B)<br>&gt;   }<br>&gt;   <br>&gt; ...(and analogously for 3, 4, as-necessary). <br>&gt; <br>&gt; There&#39;s a very obvious way to write `extension Sum2 : Equatable where A:Equatable, B:Equatable {}`...and at the time I set this aside, I was expecting to also want to come back and have additional conformances for things like `...where A:Equatable, B:AnyObject` (using `===` for comparing `B`) and so on for other combinations.<br>&gt; <br>&gt; Upon revisiting such things in light of the proposal, I now think differently: for this case it seems like a better long-term approach anyways to stick to a single conformance and work with it like this:<br>&gt; <br>&gt;   extension Sum2:Equatable where A:Equatable, B:Equatable {<br>&gt;     // details elided<br>&gt;   }<br>&gt;   <br>&gt;   /// Adaptor using `ObjectIdentifier` to implement `==`.<br>&gt;   struct ObjectWrapper&lt;Wrapped:AnyObject&gt; : Equatable, Hashable {<br>&gt;     let wrapped: Wrapped<br>&gt;   }<br>&gt;   <br>&gt; ...as upon reflection I really would prefer dealing with the hassle of working with `Sum2&lt;A,ObjectWrapper&lt;B&gt;&gt;` in situations where -- in theory -- `Sum2&lt;A,B&gt;` could do -- to the hassle of writing out 4+ conformances for `Sum2` (and so on...even with nice code-gen tools that&#39;s going to be a lot of bloat!). <br>&gt; <br>&gt; What changed my mind was tracing through the implications of conditional conformances for the use-site ergonomics of adaptors like `ObjectWrapper` above; what I mean is, suppose I have a protocol like this:<br>&gt; <br>&gt;   protocol WidgetFactory {<br>&gt;     associatedtype Widget<br>&gt;     associatedtype Material<br>&gt;     <br>&gt;     func produceWidget(using material: Material) -&gt; Widget<br>&gt;   }<br>&gt; <br>&gt; ...then it&#39;s rather easy to simply write this type of boilerplate:<br>&gt; <br>&gt;   extension ObjectWrapper: WidgetFactory where Wrapped: WidgetFactory {<br>&gt;     typealias Widget = Wrapper.Widget<br>&gt;     typealias Material = Wrapper.Material<br>&gt;     <br>&gt;     func produceWidget(using material: Material) -&gt; Widget {<br>&gt;       return base.produceWidget(using: material)<br>&gt;     }<br>&gt;   }<br>&gt;   <br>&gt; ...which thus means I have the tools I need to make my use of wrappers like the `ObjectWrapper` largely transparent at the use sites I care about; e.g. I can write a single conditional conformance like this:<br>&gt; <br>&gt;   extension Sum2: WidgetFactory <br>&gt;     where <br>&gt;     A:WidgetFactory, B:WidgetFactory,<br>&gt;     A.Material == B.Material,<br>&gt;     A.Widget == B.Widget {<br>&gt;     <br>&gt;     typealias Widget = A.Widget<br>&gt;     typealias Material = A.Material<br>&gt;     <br>&gt;     func produceWidget(using material: Material) throws -&gt; Widget {<br>&gt;       switch self {<br>&gt;         case let .a(aa): return aa.produceWidget(using: material)<br>&gt;         case let .b(bb): return bb.produceWidget(using: material)<br>&gt;       }<br>&gt;     }<br>&gt;     <br>&gt;   }<br>&gt;   <br>&gt; ...and it will apply even in situations where circumstances left me using `ObjectWrapper` (or similar) on any of the type parameters to `Sum2` (e.g. if I also needed an `Equatable` conformance for whatever reason).<br>&gt; <br>&gt; At least for now--when I&#39;m still just revisiting plans and thinking about it in light of the proposal--I really would prefer having a simpler language and writing this type of boilerplate, than having a more-complex language and writing the *other* type of boilerplate (e.g. the 4+ `Equatable` conformances here, and so on for other situations).<br>&gt; <br>&gt; Note that I&#39;m not claiming the above is the only use for overlapping conditional conformances -- not at all! -- just that situations like the above comprise about 80% of the things I was intending to do with conditional conformances...and that after revisiting them expecting to be troubled by the proposed banning of overlapping conformances, I&#39;m now thinking I&#39;d wind up not using the overlapping-conformance approach in such cases even if it were available.<br>&gt; <br>&gt; So that&#39;s the first 80%.<br>&gt; <br>&gt; Moving on, the next 15% are places where there&#39;s some forced theoretical or aesthetic inelegance due to the lack of overlapping conformances, but none of these seem to have any significant practical import.<br>&gt; <br>&gt; A representative case here is that I currently have the following pair:<br>&gt; <br>&gt;   /// `ChainSequence2(a,b)` enumerates the elements of `a` then `b`.<br>&gt;   struct ChainSequence2&lt;A:Sequence,B:Sequence&gt; : Sequence<br>&gt;     where A.Iterator.Element == B.Iterator.Element  {<br>&gt;     // elided<br>&gt;   }<br>&gt; <br>&gt;   /// `ChainCollection2(a,b)` enumerates the elements of `a` then `b`.<br>&gt;   struct ChainCollection2&lt;A:Collection,B:Collection&gt; : Collection<br>&gt;     where A.Iterator.Element == B.Iterator.Element {<br>&gt;     // ^ `where` is not quite right, see below<br>&gt;   }<br>&gt; <br>&gt; ...and obviously conditional conformances will allow these to be consolidated into a single `Chain2` type that then has appropriate conditional conformances (and for which the cost/benefit for me will tip in favor of adding conditional conformances to `BidirectionalCollection` and `RandomAccessCollection`, also).<br>&gt; <br>&gt; On paper--e.g., theoretically--the lack of overlapping conformances leaves in a few aesthetic issues...for example, at present `ChainCollection2` actually has to be one of these:<br>&gt; <br>&gt;   // &quot;narrower&quot; option: not all `A`, `B` can necessarily be used together:<br>&gt;   struct ChainCollection2&lt;A:Collection,B:Collection&gt; : Collection<br>&gt;     where <br>&gt;     A.Iterator.Element == B.Iterator.Element,<br>&gt;     A.IndexDistance == B.IndexDistance {<br>&gt;     typealias IndexDistance = A.IndexDistance<br>&gt;   }<br>&gt; <br>&gt;   // &quot;wasteful&quot; option: theoretically in some cases we are &quot;overpaying&quot; and <br>&gt;   // using a stronger `IndexDistance`, but now we can use any `A` and `B`<br>&gt;   struct ChainCollection2&lt;A:Collection,B:Collection&gt; : Collection<br>&gt;     where A.Iterator.Element == B.Iterator.Element {<br>&gt;     typealias IndexDistance = IntMax<br>&gt;   }<br>&gt; <br>&gt; With overlapping conditional conformances you could have both: one conformance that uses base collections&#39; `IndexDistance` when possible, and another that uses `IntMax` when necessary...but without conditional conformances it&#39;s necessary to choose between the &quot;narrower&quot; approach or the &quot;wasteful&quot; approach (preserving the status quo).<br>&gt; <br>&gt; If you&#39;re following along I&#39;m sure you&#39;re aware that in this specific case, this &quot;choice&quot; is purely academic (or purely aesthetic)...if you go with the `IntMax` route there&#39;s almost always going to be between &quot;no actual difference&quot; and &quot;no measurable difference&quot;, so even if it *maybe* feels a bit icky the right thing to do is get over it and stop making a mountain out of an anthill.<br>&gt; <br>&gt; Note that I&#39;m well aware that you can choose to see this as a concrete instance of a more-general problem -- that the lack of overlapping conformances would potentially leave a lot of performance on the table due to forcing similar decisions (and in contexts where there *would* be a real difference!) -- but speaking personally I couldn&#39;t find very much in my &quot;chores pending availability of conditional conformance&quot; that both (a) fell into this category and (b) had more than &quot;aesthetic&quot; implications. <br>&gt; <br>&gt; This brings me to that last 5% -- the handful of things for which overlapping conformances have nontrivial benefits -- and my conclusion here is that these tended to be things I doubt are of general interest.<br>&gt; <br>&gt; An example here is that I like to use a function that takes two sequences and enumerates their &quot;cartesian product&quot;, with the following adjustments:<br>&gt; <br>&gt; - no specific enumeration *ordering* is guaranteed<br>&gt; - does something useful even with infinite, one-shot sequences...<br>&gt; - ...meaning specifically that it will eventual-visit any specific pair (even when one or both inputs are infinite, one-shot)<br>&gt; <br>&gt; ...(useful for doing unit tests, mostly), which to be done &quot;optimally&quot; while also dotting all the is and crossing all the ts would currently require at least 8 concrete types:<br>&gt; <br>&gt; - 4 sequences, like e.g.:<br>&gt;   - UnorderedProductSS2&lt;A:Sequence, B:Sequence&gt;<br>&gt;   - UnorderedProductSC2&lt;A:Sequence, B:Collection&gt;<br>&gt;   - UnorderedProductCS2&lt;A:Collection, B:Sequence&gt;<br>&gt;   - UnorderedProductCC2&lt;A:Collection, B:Collection&gt;<br>&gt; - 4 iterators (one for each of the above)<br>&gt; <br>&gt; ...since you need to use a different iteration strategy for each (yes you don’t *need* 8 types, but I’m trying to “dott all is, cross all ts” here). <br>&gt; <br>&gt; In theory overlapping conditional conformances could be used to cut that down to only 5 types:<br>&gt; <br>&gt; - 1 type like `UnorderedProduct&lt;A:Sequence,B:Sequence&gt;`<br>&gt; - the same 4 iterators from before, each used with the appropriate conformance<br>&gt; <br>&gt; ...which *is* less code *and* seemingly provides nontrivial gains (the `SS` variant must maintain buffers of the items it&#39;s already seen from each underlying sequence, but the others have no such requirement).<br>&gt; <br>&gt; But, to be honest, even if those gains are realized, this is the kind of situation I&#39;m perfectly comfortable saying is a &quot;niche&quot; and neither broadly relevant to the majority of Swift developers nor broadly relevant to the majority of Swift code; if overlapping conformances were available I&#39;d use them here, but I&#39;m not going to ask for them just to be able to use them here.<br>&gt; <br>&gt; Also, I&#39;m skeptical these gains would be realized in practice: between the proposed &quot;least specialized conformance wins&quot; rule and Swift&#39;s existing dispatch rules in generic contexts, it seems like even if overlapping conformances *were* allowed and I *did* use them, I&#39;d still wind up getting dispatched to the pessimal `SS` variant in many cases for which I&#39;d have been hoping for one of the more-optimal versions.<br>&gt; <br>&gt; So between the niche-ness of such uses -- and their being 5% or less of what I was hoping to do -- and my skepticism about how dispatch would pan out in practice, I can&#39;t get behind fighting for overlapping conformances at this time unless they&#39;d be permanently banned by banning them now.<br>&gt; <br>&gt; As already stated, I do think that their absence *will* reveal some *true* pain points, but I think it makes sense to adopt a &quot;wait-and-see&quot; approach here as some more-targeted solution could wind up being enough to address the majority of those future pain points.<br>&gt; <br>&gt; These are my more-detailed thoughts after looking at what I was planning to do with conditional conformances once the became available. I realize it doesn&#39;t touch on every conceivable scenario and every conceivable use, but I want to reiterate that I did my review expecting to find a bunch of things that I could use as justifications for why Swift absolutely should have overlapping conditional conformances right now...but on actually looking at my plans, I couldn&#39;t find anything for which I actually felt that way.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161003/b6d0dedb/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>September 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Sep 26, 2016, at 5:18 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Conditional conformances<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#disallow-overlapping-conformances&gt;Disallow overlapping conformances<br>&gt; <br>&gt; With conditional conformances, it is possible to express that a given generic type can conform to the same protocol in two different ways, depending on the capabilities of its type arguments. For example:<br>&gt; <br>&gt; …<br>&gt; <br>&gt; Note that, for an arbitrary type T, there are four potential answers to the question of whether SomeWrapper&lt;T&gt; conforms to Equatable:<br>&gt; <br>&gt; No, it does not conform because T is neither Equatable nor HasIdentity.<br>&gt; Yes, it conforms via the first extension of SomeWrapper because T conforms to Equatable.<br>&gt; Yes, it conforms via the second extension of SomeWrapper because T conforms to HasIdentity.<br>&gt; Ambiguity, because T conforms to both Equatable and HasIdentity.<br>&gt; It is due to the possibility of #4 occurring that we refer to the two conditional conformances in the example as overlapping. There are designs that would allow one to address the ambiguity<br>&gt; <br>&gt; …<br>&gt; <br>&gt; For these reasons, this proposal bans overlapping conformances entirely. <br></p><p>What other designs were considered and rejected? It seems like some kind of escape hatch would be preferred if you happen to get into this situation, though you make some really good points about the pitfalls.<br></p><p>Just to clarify when you say “bans” do you mean if Wrapped: Equatable &amp; HasIdentity then SomeWrapper is not Equatable, or do you mean you get a compile error because there are two constrained conformances SomeWrapper: Equatable? What would be the problem with allowing multiple conformances to Equatable so long as the constraints are disjoint or the concrete type only adopts one of the available protocols?<br></p><p>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#implied-conditional-conformances&gt;Implied conditional conformances<br>&gt; <br>&gt; Stating conformance to a protocol implicitly states conformances to any of the protocols that it inherits. This is the case in Swift today, although most developers likely don&#39;t realize the rules it follows. For example:<br>&gt; <br>&gt; protocol P { }<br>&gt; protocol Q : P { }<br>&gt; protocol R : P { }<br>&gt; <br>&gt; struct X1 { }<br>&gt; struct X2 { }<br>&gt; struct X3 { }<br>&gt; <br>&gt; extension X1: Q { }  // implies conformance to P<br>&gt; <br>&gt; extension X2: Q { }  // would imply conformance to P, but...<br>&gt; extension X2: P { }  // explicitly-stated conformance to P &quot;wins&quot;<br>&gt; <br>&gt; extension X3: Q { }  // implies conformance to P<br>&gt; extension X3: R { }  // also implies conformance to P<br>&gt;                      // one will &quot;win&quot;; which is unspecified<br>On X2 you’re declaring a redundant conformance to P but any protocol extensions will prefer Q and the compiler won’t let you redefine any members so you’ll have an incomplete conformance. Any explicit conformances (on the type or in extensions) are preferred over the defaults from the protocol extension, but that’s not new. I must be missing something, how would this be visible in Swift 3?<br></p><p>On X3, multiple implementations in protocol extensions are errors today and the resolution is to provide an explicit implementation on X3.<br></p><p><br></p><p><br>&gt; With conditional conformances, the question of which extension &quot;wins&quot; the implied conformance begins to matter, because the extensions might have different constraints on them. For example:<br>&gt; <br>&gt; struct X4&lt;T&gt; { }<br>&gt; <br>&gt; extension X4: Q where T: Q { }  // implies conformance to P<br>&gt; extension X4: R where T: R { }  // error: implies overlapping conformance to P<br>&gt; Both of these constrained extensions imply a conformance to P, but the actual P implied conformances to P are overlapping and, therefore, result in an error.<br>&gt; <br>If the related P conformance were inherited from conformance to Q or R then the rules would (IMHO) make more sense. Wouldn’t the extra rule you need simply be that either Q or R must provide a complete conformance to P (no mix-n-match)? <br></p><p>If T implements Q &amp; P why not just ignore T: P which means the X4: R extension is no longer relevant. <br></p><p>It seems like the tricky case is T: P and the same question applies - why not just ignore the extensions (X4&lt;T&gt; in that scenario doesn’t implement Q, R, or P). <br></p><p><br>Not allowing ambiguity seems like it solves the “which one” problem and requiring an extension to provide the entire implementation (no mix-n-match) cuts down on the cleverness problem.<br></p><p><br></p><p><br>&gt; However, in cases where there is a reasonable ordering between the two constrained extensions (i.e., one is more specialized than the other), the less specialized constrained extension should &quot;win&quot; the implied conformance. Continuing the example from above:<br>&gt; <br>&gt; protocol S: R { }<br>&gt; <br>&gt; struct X5&lt;T&gt; { }<br>&gt; <br>&gt; extension X5: R where T: R { }  // &quot;wins&quot; implied conformance to P, because<br>&gt; extension X5: S where T: S { }  // the extension where &quot;T: S&quot; is more specialized<br>&gt;                                 // than the one where &quot;T: R&quot;<br>&gt; Thus, the rule for placing implied conformances is to pick the least specialized extension that implies the conformance. If there is more than one such extension, then either:<br>&gt; <br>&gt; All such extensions are not constrained extensions (i.e., they have no requirements beyond what the type requires), in which case Swift can continue to choose arbitrarily among the extensions, or<br>&gt; All such extensions are constrained extensions, in which case the program is ill-formed due to the ambiguity. The developer can explicitly specify conformance to the protocol to disambiguate. <br>What is the rationale for picking the least specialized extension? That’s not what I would naively expect to happen. If T: R &amp; S then I would expect the more specialized S:R implementation to be preferred, and the explicit R implementation to kick in when T: R. <br></p><p><br></p><p>(Some of these may just be naive questions resulting from my misunderstanding)<br></p><p>Russ<br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/98c56215/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Sep 28, 2016, at 9:48 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 26, 2016, at 5:18 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Conditional conformances<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#disallow-overlapping-conformances&gt;Disallow overlapping conformances<br>&gt;&gt; <br>&gt;&gt; With conditional conformances, it is possible to express that a given generic type can conform to the same protocol in two different ways, depending on the capabilities of its type arguments. For example:<br>&gt;&gt; <br>&gt;&gt; …<br>&gt;&gt; <br>&gt;&gt; Note that, for an arbitrary type T, there are four potential answers to the question of whether SomeWrapper&lt;T&gt; conforms to Equatable:<br>&gt;&gt; <br>&gt;&gt; No, it does not conform because T is neither Equatable nor HasIdentity.<br>&gt;&gt; Yes, it conforms via the first extension of SomeWrapper because T conforms to Equatable.<br>&gt;&gt; Yes, it conforms via the second extension of SomeWrapper because T conforms to HasIdentity.<br>&gt;&gt; Ambiguity, because T conforms to both Equatable and HasIdentity.<br>&gt;&gt; It is due to the possibility of #4 occurring that we refer to the two conditional conformances in the example as overlapping. There are designs that would allow one to address the ambiguity<br>&gt;&gt; <br>&gt;&gt; …<br>&gt;&gt; <br>&gt;&gt; For these reasons, this proposal bans overlapping conformances entirely. <br>&gt; <br>&gt; What other designs were considered and rejected? It seems like some kind of escape hatch would be preferred if you happen to get into this situation, though you make some really good points about the pitfalls.<br></p><p>I don’t have a fully-baked alternative proposal—it would probably have to involve some kind of preference rule for picking the “best” set of (consistent!) conformances to satisfy a particular request, introduce a disambiguation syntax for cases where that preference rule does the wrong thing, and some way of teaching the dynamic-casting machinery to do the same thing.<br></p><p>&gt; Just to clarify when you say “bans” do you mean if Wrapped: Equatable &amp; HasIdentity then SomeWrapper is not Equatable, or do you mean you get a compile error because there are two constrained conformances SomeWrapper: Equatable?<br></p><p>You get a compile error if there are two conformances of SomeWrapper to Equatable; it doesn’t actually matter whether they are conditional, but people are far more likely to expect to be able to having overlapping conditional conformances.<br></p><p>&gt; What would be the problem with allowing multiple conformances to Equatable so long as the constraints are disjoint<br></p><p>From the language perspective, “disjoint” would have to mean that there are requirements that actively conflict, e.g., one extension has “Wrapped.Element == Int” and the other has “Wrapped.Element == String”.<br></p><p>There are implementation issues here deep in the type checker, e.g., because if a given type T can potential conform to a protocol P in multiple ways, it introduces a disjunction in the constraint solver that can push the constraint solver to be Even More Exponential.<br></p><p>For me, there’s also the usability issue, and that’s the key argument: the *human* has to reason about these things, too, and it is a whole lot simpler if “does T conform to P?” can only be answered in one way. I don’t think the use cases for having overlapping conformances justify such a drastic increase in complexity across the feature.<br></p><p>&gt; or the concrete type only adopts one of the available protocols?<br></p><p>Unless you assume that you have a fully-determined, closed system where you know about every potential conformance of a concrete type, this isn’t a question that can be answered at compile time.<br></p><p>&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/conditional-conformances#implied-conditional-conformances&gt;Implied conditional conformances<br>&gt;&gt; <br>&gt;&gt; Stating conformance to a protocol implicitly states conformances to any of the protocols that it inherits. This is the case in Swift today, although most developers likely don&#39;t realize the rules it follows. For example:<br>&gt;&gt; <br>&gt;&gt; protocol P { }<br>&gt;&gt; protocol Q : P { }<br>&gt;&gt; protocol R : P { }<br>&gt;&gt; <br>&gt;&gt; struct X1 { }<br>&gt;&gt; struct X2 { }<br>&gt;&gt; struct X3 { }<br>&gt;&gt; <br>&gt;&gt; extension X1: Q { }  // implies conformance to P<br>&gt;&gt; <br>&gt;&gt; extension X2: Q { }  // would imply conformance to P, but...<br>&gt;&gt; extension X2: P { }  // explicitly-stated conformance to P &quot;wins&quot;<br>&gt;&gt; <br>&gt;&gt; extension X3: Q { }  // implies conformance to P<br>&gt;&gt; extension X3: R { }  // also implies conformance to P<br>&gt;&gt;                      // one will &quot;win&quot;; which is unspecified<br>&gt; On X2 you’re declaring a redundant conformance to P but any protocol extensions will prefer Q and the compiler won’t let you redefine any members so you’ll have an incomplete conformance. Any explicit conformances (on the type or in extensions) are preferred over the defaults from the protocol extension, but that’s not new. I must be missing something, how would this be visible in Swift 3?<br></p><p><br>X2 states that it conforms to Q. That implies that it also conforms to P, because of course you can’t have a Q that isn’t a P.<br></p><p>Because X2 explicitly states that it conforms to P, the implication of P via Q doesn’t actually realize an actual conformance to P, because that conformance would be redundant. The rule is, basically, that an explicitly-stated conformance to a protocol suppresses any implied conformances to that protocol.<br></p><p>&gt; On X3, multiple implementations in protocol extensions are errors today and the resolution is to provide an explicit implementation on X3.<br></p><p>Not true! The code above is well-formed in Swift 3. Each extension of X3 above implies a conformance to P; it simply does not matter which extension actually realizes the conformance to P so long as only one of them does.<br></p><p>You could actually see which one it chooses by putting these into separate files—in the same module—and looking at the generated SIL.<br></p><p>&gt;&gt; With conditional conformances, the question of which extension &quot;wins&quot; the implied conformance begins to matter, because the extensions might have different constraints on them. For example:<br>&gt;&gt; <br>&gt;&gt; struct X4&lt;T&gt; { }<br>&gt;&gt; <br>&gt;&gt; extension X4: Q where T: Q { }  // implies conformance to P<br>&gt;&gt; extension X4: R where T: R { }  // error: implies overlapping conformance to P<br>&gt;&gt; Both of these constrained extensions imply a conformance to P, but the actual P implied conformances to P are overlapping and, therefore, result in an error.<br>&gt;&gt; <br>&gt; If the related P conformance were inherited from conformance to Q or R then the rules would (IMHO) make more sense. Wouldn’t the extra rule you need simply be that either Q or R must provide a complete conformance to P (no mix-n-match)? <br></p><p>A conformance to P introduced by the first extension would not be usable by the second extension, because the conformance to P introduced by the first extension might depend on details of “T: Q”… and the second extension can’t assume that “T: Q”.<br></p><p>&gt; <br>&gt; If T implements Q &amp; P why not just ignore T: P which means the X4: R extension is no longer relevant. <br></p><p>Implementing Q implies implementing P.<br></p><p>&gt; <br>&gt; It seems like the tricky case is T: P and the same question applies - why not just ignore the extensions (X4&lt;T&gt; in that scenario doesn’t implement Q, R, or P). <br>&gt; <br>&gt; <br>&gt; Not allowing ambiguity seems like it solves the “which one” problem and requiring an extension to provide the entire implementation (no mix-n-match) cuts down on the cleverness problem.<br></p><p>For reference, there was an early point in Swift 3.0 where I had added an error when it wasn’t clear which extension should realize a conformance to a protocol that was implied by multiple extensions (i.e., exactly the case of X3 that we discussed above), thinking that it would clear up the ambiguity and make code more obvious. Developers *hated* this error, because it doesn’t matter to the semantics of the program nor to their mental models, so I took it out.<br></p><p>&gt;&gt; However, in cases where there is a reasonable ordering between the two constrained extensions (i.e., one is more specialized than the other), the less specialized constrained extension should &quot;win&quot; the implied conformance. Continuing the example from above:<br>&gt;&gt; <br>&gt;&gt; protocol S: R { }<br>&gt;&gt; <br>&gt;&gt; struct X5&lt;T&gt; { }<br>&gt;&gt; <br>&gt;&gt; extension X5: R where T: R { }  // &quot;wins&quot; implied conformance to P, because<br>&gt;&gt; extension X5: S where T: S { }  // the extension where &quot;T: S&quot; is more specialized<br>&gt;&gt;                                 // than the one where &quot;T: R&quot;<br>&gt;&gt; Thus, the rule for placing implied conformances is to pick the least specialized extension that implies the conformance. If there is more than one such extension, then either:<br>&gt;&gt; <br>&gt;&gt; All such extensions are not constrained extensions (i.e., they have no requirements beyond what the type requires), in which case Swift can continue to choose arbitrarily among the extensions, or<br>&gt;&gt; All such extensions are constrained extensions, in which case the program is ill-formed due to the ambiguity. The developer can explicitly specify conformance to the protocol to disambiguate. <br>&gt; What is the rationale for picking the least specialized extension? That’s not what I would naively expect to happen. If T: R &amp; S then I would expect the more specialized S:R implementation to be preferred, and the explicit R implementation to kick in when T: R. <br></p><p>We have to pick the least-specialized extension, because it’s the only one that works. If you pick a more-specialized extension to realize the implied conformance to P, the less-specialized extension doesn’t have a conformance to P that it can rely on.<br></p><p>I’ll see about clarifying the proposal here, because the choice of (unique) least-specialized isn’t arbitrary: it’s the only answer that provides a correct result without introducing overlapping conformances.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160929/be56d21b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>September 29, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 29 Sep 2016, at 20:12, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; You get a compile error if there are two conformances of SomeWrapper to Equatable; it doesn’t actually matter whether they are conditional, but people are far more likely to expect to be able to having overlapping conditional conformances.<br></p><p>Slightly off-topic but I was hit quick badly by this recently because two libraries I was trying to import both conformed UIControlState to Hashable to be able to use it as Dictionary indices. It seems like something that might happen kind of regularly with important protocols like Hashable and Equatable.<br></p><p>Is there any plans to address those issues and might it have an effect on this proposal?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160929/480dbfa3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>September 29, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Sep 29, 2016, at 11:12 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Sep 28, 2016, at 9:48 PM, Russ Bishop &lt;xenadu at gmail.com &lt;mailto:xenadu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What other designs were considered and rejected? It seems like some kind of escape hatch would be preferred if you happen to get into this situation, though you make some really good points about the pitfalls.<br>&gt; <br>&gt; I don’t have a fully-baked alternative proposal—it would probably have to involve some kind of preference rule for picking the “best” set of (consistent!) conformances to satisfy a particular request, introduce a disambiguation syntax for cases where that preference rule does the wrong thing, and some way of teaching the dynamic-casting machinery to do the same thing.<br></p><p>Yeah your description is already sounding like a lot of work :)<br></p><p><br>&gt; <br>&gt;&gt; Just to clarify when you say “bans” do you mean if Wrapped: Equatable &amp; HasIdentity then SomeWrapper is not Equatable, or do you mean you get a compile error because there are two constrained conformances SomeWrapper: Equatable? <br>&gt; <br>&gt; You get a compile error if there are two conformances of SomeWrapper to Equatable; it doesn’t actually matter whether they are conditional, but people are far more likely to expect to be able to having overlapping conditional conformances.<br></p><p>Just to clarify in my mind, the problem here is that Swift would need runtime machinery to look at Wrapped and select the conformance to Equatable based on whether Wrapped: Equatable or Wrapped: HasIdentity. Is that right? Otherwise with the proposal as written Swift would need to check Wrapped to validate the constraints but once it does there is only one implementation of the conformance to pick from. <br></p><p>I believe you about the type checker, I’m just naively assuming inserting a table to select the correct conformance isn’t a big cost because you would canonicalize the constraints and being disjoint for any type T there would only ever be one matching entry.<br></p><p><br></p><p><br>&gt; <br>&gt;&gt; What would be the problem with allowing multiple conformances to Equatable so long as the constraints are disjoint <br>&gt; <br>&gt; From the language perspective, “disjoint” would have to mean that there are requirements that actively conflict, e.g., one extension has “Wrapped.Element == Int” and the other has “Wrapped.Element == String”.<br></p><p>Yes, I was also imagining protocols so long as there is no protocol they share in common except the empty protocol.<br></p><p><br>&gt; <br>&gt; There are implementation issues here deep in the type checker, e.g., because if a given type T can potential conform to a protocol P in multiple ways, it introduces a disjunction in the constraint solver that can push the constraint solver to be Even More Exponential.<br></p><p>That’s Bad ™️<br></p><p><br></p><p>&gt; For me, there’s also the usability issue, and that’s the key argument: the *human* has to reason about these things, too, and it is a whole lot simpler if “does T conform to P?” can only be answered in one way. I don’t think the use cases for having overlapping conformances justify such a drastic increase in complexity across the feature.<br></p><p>Constraints are already introducing some complexity there (which is worth it IMHO). You can’t just answer the question is Array: Equatable? You need to know about T. <br></p><p><br>&gt; <br>&gt;&gt; or the concrete type only adopts one of the available protocols?<br>&gt; <br>&gt; Unless you assume that you have a fully-determined, closed system where you know about every potential conformance of a concrete type, this isn’t a question that can be answered at compile time.<br></p><p>The problem is importing a random library can immediately introduce breakage when it is a compile error, or worse if both reference a shared library you also import… unless we’re saying extensions of types outside your module are only visible in the declaring module which is pretty restrictive e.g. some UI toolkit extending UIKit/AppKit classes with conveniences, or extending Array to say it CanLayout if elements are views where calling a.layout() tells all the views in the array to layout. In that example neither the views nor Array would be declared in the module doing the extending.<br></p><p>Now let’s say I want to use the swift-protobuf library and I also use GenericSocialMediaService’ SDK that also incorporates swift-protobuf. I’m just imagining what happens when we both try to define extensions. It would be nice if they could declare Array: ProtobufMessage where Element: GSMSEntityProtocol but I was able to provide Array: ProtobufMessage where Element: MyOwnProtocol. <br></p><p><br>That said the restrictions can always be relaxed later. I’d rather have this feature without overlapping conformances than not have it.<br></p><p><br></p><p>&gt; <br>&gt;&gt;&gt; With conditional conformances, the question of which extension &quot;wins&quot; the implied conformance begins to matter, because the extensions might have different constraints on them. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X4&lt;T&gt; { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X4: Q where T: Q { }  // implies conformance to P<br>&gt;&gt;&gt; extension X4: R where T: R { }  // error: implies overlapping conformance to P<br>&gt;&gt;&gt; Both of these constrained extensions imply a conformance to P, but the actual P implied conformances to P are overlapping and, therefore, result in an error.<br>&gt;&gt;&gt; <br>&gt;&gt; If the related P conformance were inherited from conformance to Q or R then the rules would (IMHO) make more sense. Wouldn’t the extra rule you need simply be that either Q or R must provide a complete conformance to P (no mix-n-match)? <br>&gt; <br>&gt; A conformance to P introduced by the first extension would not be usable by the second extension, because the conformance to P introduced by the first extension might depend on details of “T: Q”… and the second extension can’t assume that “T: Q”.<br></p><p>What I’m saying is that if T: Q then the entire implementation of P must come from the first extension. If T: R then the entire implementation of P must come from the second extension. If T: P then neither extension applies because there are overlapping extensions. Basically if there is any overlap then the compiler only considers explicit extensions that match without ambiguity, otherwise the extension is ignored. <br></p><p>func takes&lt;Value: P&gt;(value: Value) { }<br></p><p>struct CQ: Q { }<br>struct CR: R { }<br>struct CP: P { }<br></p><p>takes(X4&lt;CQ&gt;()) //fine, uses first extension<br>takes(X4&lt;CR&gt;()) //fine, uses second extension <br>takes(X4&lt;CP&gt;()) //error: ambiguous conformance	<br></p><p><br></p><p>This relates to the disjoint discussion above:<br></p><p>extension X4: P where T: P { } //error: ambiguous conformance<br></p><p>Even though there is technically a conformance to P available we just ignore it. Seems like this would be knowable statically by looking at the extensions and the protocol relationships in the constraints?<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; What is the rationale for picking the least specialized extension? That’s not what I would naively expect to happen. If T: R &amp; S then I would expect the more specialized S:R implementation to be preferred, and the explicit R implementation to kick in when T: R. <br>&gt; <br>&gt; We have to pick the least-specialized extension, because it’s the only one that works. If you pick a more-specialized extension to realize the implied conformance to P, the less-specialized extension doesn’t have a conformance to P that it can rely on.<br></p><p>That’s what I was trying to address by saying no mix-n-match. If you’re going to wonder into overlapping territory you must supply two entirely separate implementations of P, one explicit and one inside the Q extension. (I fully admit that might not help the implementation complexity - I don’t know enough about the type checker to answer that).<br></p><p>&gt; <br>&gt; I’ll see about clarifying the proposal here, because the choice of (unique) least-specialized isn’t arbitrary: it’s the only answer that provides a correct result without introducing overlapping conformances.<br>&gt; <br>&gt; 	- Doug<br></p><p><br>Thanks for your work on this proposal!<br></p><p>Russ<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160929/60238e99/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September 29, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Sep 29, 2016, at 3:05 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 29, 2016, at 11:12 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sep 28, 2016, at 9:48 PM, Russ Bishop &lt;xenadu at gmail.com &lt;mailto:xenadu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What other designs were considered and rejected? It seems like some kind of escape hatch would be preferred if you happen to get into this situation, though you make some really good points about the pitfalls.<br>&gt;&gt; <br>&gt;&gt; I don’t have a fully-baked alternative proposal—it would probably have to involve some kind of preference rule for picking the “best” set of (consistent!) conformances to satisfy a particular request, introduce a disambiguation syntax for cases where that preference rule does the wrong thing, and some way of teaching the dynamic-casting machinery to do the same thing.<br>&gt; <br>&gt; Yeah your description is already sounding like a lot of work :)<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Just to clarify when you say “bans” do you mean if Wrapped: Equatable &amp; HasIdentity then SomeWrapper is not Equatable, or do you mean you get a compile error because there are two constrained conformances SomeWrapper: Equatable? <br>&gt;&gt; <br>&gt;&gt; You get a compile error if there are two conformances of SomeWrapper to Equatable; it doesn’t actually matter whether they are conditional, but people are far more likely to expect to be able to having overlapping conditional conformances.<br>&gt; <br>&gt; Just to clarify in my mind, the problem here is that Swift would need runtime machinery to look at Wrapped and select the conformance to Equatable based on whether Wrapped: Equatable or Wrapped: HasIdentity. Is that right?<br></p><p><br>Correct. And diagnose / disambiguate if there are multiple conformances that match.<br></p><p>&gt; Otherwise with the proposal as written Swift would need to check Wrapped to validate the constraints but once it does there is only one implementation of the conformance to pick from. <br></p><p>Right.<br></p><p>&gt; I believe you about the type checker, I’m just naively assuming inserting a table to select the correct conformance isn’t a big cost because you would canonicalize the constraints and being disjoint for any type T there would only ever be one matching entry.<br></p><p>The table computation would have to be a runtime thing, because we don’t know all of the conformances until then, but yes—it’s doable.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; What would be the problem with allowing multiple conformances to Equatable so long as the constraints are disjoint <br>&gt;&gt; <br>&gt;&gt; From the language perspective, “disjoint” would have to mean that there are requirements that actively conflict, e.g., one extension has “Wrapped.Element == Int” and the other has “Wrapped.Element == String”.<br>&gt; <br>&gt; Yes, I was also imagining protocols so long as there is no protocol they share in common except the empty protocol.<br></p><p>The compiler won’t know that a given type can’t conform to two specific protocols, though, unless they have some kind of direct conflict (like my example above of Wrapped.Element being equated to two different concrete types) or we have some mechanism in the language to state that two protocols are mutually exclusive.<br></p><p>&gt;&gt;&gt; or the concrete type only adopts one of the available protocols?<br>&gt;&gt; <br>&gt;&gt; Unless you assume that you have a fully-determined, closed system where you know about every potential conformance of a concrete type, this isn’t a question that can be answered at compile time.<br>&gt; <br>&gt; The problem is importing a random library can immediately introduce breakage when it is a compile error, or worse if both reference a shared library you also import… unless we’re saying extensions of types outside your module are only visible in the declaring module which is pretty restrictive e.g. some UI toolkit extending UIKit/AppKit classes with conveniences, or extending Array to say it CanLayout if elements are views where calling a.layout() tells all the views in the array to layout. In that example neither the views nor Array would be declared in the module doing the extending.<br>&gt; <br>&gt; Now let’s say I want to use the swift-protobuf library and I also use GenericSocialMediaService’ SDK that also incorporates swift-protobuf. I’m just imagining what happens when we both try to define extensions. It would be nice if they could declare Array: ProtobufMessage where Element: GSMSEntityProtocol but I was able to provide Array: ProtobufMessage where Element: MyOwnProtocol. <br></p><p>Yes, I know.<br></p><p>&gt; That said the restrictions can always be relaxed later. I’d rather have this feature without overlapping conformances than not have it.<br></p><p>Right. If we find a model for it that works.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; With conditional conformances, the question of which extension &quot;wins&quot; the implied conformance begins to matter, because the extensions might have different constraints on them. For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct X4&lt;T&gt; { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension X4: Q where T: Q { }  // implies conformance to P<br>&gt;&gt;&gt;&gt; extension X4: R where T: R { }  // error: implies overlapping conformance to P<br>&gt;&gt;&gt;&gt; Both of these constrained extensions imply a conformance to P, but the actual P implied conformances to P are overlapping and, therefore, result in an error.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; If the related P conformance were inherited from conformance to Q or R then the rules would (IMHO) make more sense. Wouldn’t the extra rule you need simply be that either Q or R must provide a complete conformance to P (no mix-n-match)? <br>&gt;&gt; <br>&gt;&gt; A conformance to P introduced by the first extension would not be usable by the second extension, because the conformance to P introduced by the first extension might depend on details of “T: Q”… and the second extension can’t assume that “T: Q”.<br>&gt; <br>&gt; What I’m saying is that if T: Q then the entire implementation of P must come from the first extension. If T: R then the entire implementation of P must come from the second extension.<br></p><p>This fails when T: Q&amp;R, though, because you don’t know which implementation of P to choose—the one based on T: Q or the one based on T: R? That’s the reason for completing banning the overlap—it avoids the possibility of ambiguity (at compile time or at runtime).<br></p><p>&gt; If T: P then neither extension applies because there are overlapping extensions. Basically if there is any overlap then the compiler only considers explicit extensions that match without ambiguity, otherwise the extension is ignored. <br>&gt; <br>&gt; func takes&lt;Value: P&gt;(value: Value) { }<br>&gt; <br>&gt; struct CQ: Q { }<br>&gt; struct CR: R { }<br>&gt; struct CP: P { }<br>&gt; <br>&gt; takes(X4&lt;CQ&gt;()) //fine, uses first extension<br>&gt; takes(X4&lt;CR&gt;()) //fine, uses second extension <br>&gt; takes(X4&lt;CP&gt;()) //error: ambiguous conformance	<br></p><p>In the model you describe, this last one isn’t “ambiguous conformance”, it’s “no conformance” because neither of the (potential) conformances of X4 to P has its requirements satisfied. The case you didn’t enumerate is:<br></p><p>struct CQR: Q, R { }<br>takes(X4&lt;CQR&gt;()) // error: ambiguous conformance<br></p><p><br>&gt; This relates to the disjoint discussion above:<br>&gt; <br>&gt; extension X4: P where T: P { } //error: ambiguous conformance<br>&gt; <br>&gt; Even though there is technically a conformance to P available we just ignore it.<br></p><p>I don’t understand your “error: ambiguous conformance” annotation here. This extension of X4 is less specialized than either of the other extensions, yet provides a suitable P conformance, and (if it were present in your example immediately above) would allow “takes(X4&lt;CP&gt;())” to succeed. Indeed, this is the fix for the example in SE-0143 because it eliminates the overlap by providing a common, shared conformance to P.<br></p><p>&gt;  Seems like this would be knowable statically by looking at the extensions and the protocol relationships in the constraints?<br></p><p><br>You can see that either of the first two extensions is more specialized than this third extension, if you can see them all. Dynamic work comes in when multiple modules with extensions are linked together.<br></p><p>&gt;&gt;&gt; What is the rationale for picking the least specialized extension? That’s not what I would naively expect to happen. If T: R &amp; S then I would expect the more specialized S:R implementation to be preferred, and the explicit R implementation to kick in when T: R. <br>&gt;&gt; <br>&gt;&gt; We have to pick the least-specialized extension, because it’s the only one that works. If you pick a more-specialized extension to realize the implied conformance to P, the less-specialized extension doesn’t have a conformance to P that it can rely on.<br>&gt; <br>&gt; That’s what I was trying to address by saying no mix-n-match. If you’re going to wonder into overlapping territory you must supply two entirely separate implementations of P, one explicit and one inside the Q extension. (I fully admit that might not help the implementation complexity - I don’t know enough about the type checker to answer that).<br></p><p>If we were to allow overlap, then yes, maybe it should have to be explicit. My complaints/concerns about overlapping conformances still apply ;)<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160929/99d94939/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
