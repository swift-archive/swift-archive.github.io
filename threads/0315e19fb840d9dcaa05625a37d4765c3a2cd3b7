<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d569462ac92d4619342b1c5ff305043?s=50"></div><header><strong>Fwd: Swift Generic Subtype Problem</strong> from <string>frogcjn at 163.com</string> &lt;frogcjn at 163.com&gt;<p>February 16, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>I think the best way to solve the either problem is to separate it from generic. <br>Optional and Either shouldn’t work the same way of generic type. <br>It’s just a represent of multiple type in one location.<br></p><p>Using an old friend, Union in C.<br>union {<br>	case firstType<br>	case secondType<br>}<br></p><p>This is the final solution for the sub typing problem of optional.<br></p><p><br>A  == union(A,A)<br>union(A,B) == union(B,A)<br>B == union(B,B)<br></p><p>B is subtype of union(A,B)<br>A is subtype of union(A,B)<br></p><p>suppose <br>a is subclass of A<br>b is subclass of B, then<br>	union(a,B) is subtype of union(A,B)<br>	union(A,b) is subtype of union(A,B)<br>	union(a,b) is subtype of union(a,B)<br>	union(a,b) is subtype of union(A,b)<br></p><p>union can have as many case as possible. e.g., union(A,B,C,D,…)<br></p><p>So the Optional&lt;UITableView&gt; should be union(UITableView, None)<br>and Optional&lt;MyTableVIew&gt; should be union(MyTableView, None), which is subclass of union(UITableView, None)<br></p><p>This is a final rational solution. I think.<br></p><p>-Jiannan<br></p><p>&gt; 下面是被转发的邮件：<br>&gt; <br>&gt; 发件人: Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; 主题: [swift-evolution] Swift Generic Subtype Problem<br>&gt; 日期: 2016年2月16日 GMT+8 11:48:18<br>&gt; 收件人: swift-evolution at swift.org<br>&gt; 回复－收件人: Cao Jiannan &lt;frogcjn at 163.com&gt;<br>&gt; <br>&gt; <br>&gt; Hi all,<br>&gt; I want to discuss on a problem  about optional generic sub-typing.<br>&gt; <br>&gt; This is my suggesion.<br>&gt; <br>&gt; if B is subclass of A<br>&gt; Either&lt;B,B&gt; is subclass of Either&lt;A,A&gt;, Either&lt;A,B&gt;, Either&lt;B,A&gt;<br>&gt; Either&lt;B,A&gt; is subclass of Either&lt;A,A&gt;<br>&gt; Either&lt;A,B&gt; is subclass of Either&lt;A,A&gt;<br>&gt; <br>&gt; <br>&gt; Why? Let’s see an example code in a real project:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Here is a protocol type for some UIViewController,<br>&gt; protocol  SegueHandlerType {  <br>&gt;     var tableView: UITableView! { get }  <br>&gt; }  <br>&gt; <br>&gt; so the UITableViewController can conform to the protocal<br>&gt; extension UITableViewController : SegueHandlerType {  <br>&gt; }  <br>&gt; <br>&gt; It&#39;s great!<br>&gt; What if the tableView is a subclass UITableView?<br>&gt; like:<br>&gt; class MyTableView : UITableView {<br>&gt; }<br>&gt; <br>&gt; MyTableViewController {  <br>&gt;       @IBOutlet var tableView: MyTableView!  <br>&gt; }  <br>&gt; <br>&gt; Then <br>&gt; extension MyTableViewController:SegueHandlerType {  <br>&gt;   <br>&gt; }  <br>&gt; will trigger a compiler error.<br>&gt;  <br>&gt; So the Optional needs a subclass system.<br>&gt; Or to say, that the template system needs a subclass system.<br>&gt;  <br>&gt; Optional&lt;UITableView&gt; should be the super type of Optional&lt;MyTableView&gt;<br>&gt; Array&lt;UITableView&gt; should be the super type of Array&lt;MyTableView&gt;<br>&gt; <br>&gt; https://forums.developer.apple.com/message/101646#101646 &lt;https://forums.developer.apple.com/message/101646#101646&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt; Jiannan, Cao<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/0315d3b7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d569462ac92d4619342b1c5ff305043?s=50"></div><header><strong>Swift Generic Subtype Problem</strong> from <string>frogcjn at 163.com</string> &lt;frogcjn at 163.com&gt;<p>February 16, 2016 at 02:00:00pm</p></header><div class="content"><p>Also:<br></p><p>union(A,B,C) is subtype of union(A,B,C,D,…)<br></p><p>&gt; 在 2016年2月16日，14:36，Cao Jiannan &lt;frogcjn at 163.com&gt; 写道：<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I think the best way to solve the either problem is to separate it from generic. <br>&gt; Optional and Either shouldn’t work the same way of generic type. <br>&gt; It’s just a represent of multiple type in one location.<br>&gt; <br>&gt; Using an old friend, Union in C.<br>&gt; union {<br>&gt; 	case firstType<br>&gt; 	case secondType<br>&gt; }<br>&gt; <br>&gt; This is the final solution for the sub typing problem of optional.<br>&gt; <br>&gt; <br>&gt; A  == union(A,A)<br>&gt; union(A,B) == union(B,A)<br>&gt; B == union(B,B)<br>&gt; <br>&gt; B is subtype of union(A,B)<br>&gt; A is subtype of union(A,B)<br>&gt; <br>&gt; suppose <br>&gt; a is subclass of A<br>&gt; b is subclass of B, then<br>&gt; 	union(a,B) is subtype of union(A,B)<br>&gt; 	union(A,b) is subtype of union(A,B)<br>&gt; 	union(a,b) is subtype of union(a,B)<br>&gt; 	union(a,b) is subtype of union(A,b)<br>&gt; <br>&gt; union can have as many case as possible. e.g., union(A,B,C,D,…)<br>&gt; <br>&gt; So the Optional&lt;UITableView&gt; should be union(UITableView, None)<br>&gt; and Optional&lt;MyTableVIew&gt; should be union(MyTableView, None), which is subclass of union(UITableView, None)<br>&gt; <br>&gt; This is a final rational solution. I think.<br>&gt; <br>&gt; -Jiannan<br>&gt; <br>&gt;&gt; 下面是被转发的邮件：<br>&gt;&gt; <br>&gt;&gt; 发件人: Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; 主题: [swift-evolution] Swift Generic Subtype Problem<br>&gt;&gt; 日期: 2016年2月16日 GMT+8 11:48:18<br>&gt;&gt; 收件人: swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; 回复－收件人: Cao Jiannan &lt;frogcjn at 163.com &lt;mailto:frogcjn at 163.com&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; I want to discuss on a problem  about optional generic sub-typing.<br>&gt;&gt; <br>&gt;&gt; This is my suggesion.<br>&gt;&gt; <br>&gt;&gt; if B is subclass of A<br>&gt;&gt; Either&lt;B,B&gt; is subclass of Either&lt;A,A&gt;, Either&lt;A,B&gt;, Either&lt;B,A&gt;<br>&gt;&gt; Either&lt;B,A&gt; is subclass of Either&lt;A,A&gt;<br>&gt;&gt; Either&lt;A,B&gt; is subclass of Either&lt;A,A&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Why? Let’s see an example code in a real project:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Here is a protocol type for some UIViewController,<br>&gt;&gt; protocol  SegueHandlerType {  <br>&gt;&gt;     var tableView: UITableView! { get }  <br>&gt;&gt; }  <br>&gt;&gt; <br>&gt;&gt; so the UITableViewController can conform to the protocal<br>&gt;&gt; extension UITableViewController : SegueHandlerType {  <br>&gt;&gt; }  <br>&gt;&gt; <br>&gt;&gt; It&#39;s great!<br>&gt;&gt; What if the tableView is a subclass UITableView?<br>&gt;&gt; like:<br>&gt;&gt; class MyTableView : UITableView {<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; MyTableViewController {  <br>&gt;&gt;       @IBOutlet var tableView: MyTableView!  <br>&gt;&gt; }  <br>&gt;&gt; <br>&gt;&gt; Then <br>&gt;&gt; extension MyTableViewController:SegueHandlerType {  <br>&gt;&gt;   <br>&gt;&gt; }  <br>&gt;&gt; will trigger a compiler error.<br>&gt;&gt;  <br>&gt;&gt; So the Optional needs a subclass system.<br>&gt;&gt; Or to say, that the template system needs a subclass system.<br>&gt;&gt;  <br>&gt;&gt; Optional&lt;UITableView&gt; should be the super type of Optional&lt;MyTableView&gt;<br>&gt;&gt; Array&lt;UITableView&gt; should be the super type of Array&lt;MyTableView&gt;<br>&gt;&gt; <br>&gt;&gt; https://forums.developer.apple.com/message/101646#101646 &lt;https://forums.developer.apple.com/message/101646#101646&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Thanks!<br>&gt;&gt; <br>&gt;&gt; Jiannan, Cao<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/c28edda5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Swift Generic Subtype Problem</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>February 16, 2016 at 04:00:00pm</p></header><div class="content"><p>I think Union is a good solution as it&#39;s opt-in. The reason I&#39;d want opt-in<br>is because the compiler could infer the data size at compile time and<br>possibly eliminate dynamic dispatch if the exact type is known. You&#39;d<br>probably want a shorthand for the union though, for example:<br>    MyClass.typeUnion<br></p><p>The same goes for tuples. At the moment a tuple is the closest thing to a c<br>style struct. I think c structs are currently imported as tuples. If you<br>made it so (A,A) was interchangeable with (B,B) then they&#39;d have to have<br>the same size, and maybe also store type information where they may not<br>otherwise.<br></p><p>On Tuesday, 16 February 2016, Cao Jiannan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Also:<br>&gt;<br>&gt; union(A,B,C) is subtype of union(A,B,C,D,…)<br>&gt;<br>&gt; 在 2016年2月16日，14:36，Cao Jiannan &lt;frogcjn at 163.com&gt; 写道：<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; I think the best way to solve the either problem is to separate it from<br>&gt; generic.<br>&gt; Optional and Either shouldn’t work the same way of generic type.<br>&gt; It’s just a represent of multiple type in one location.<br>&gt;<br>&gt; Using an old friend, Union in C.<br>&gt; union {<br>&gt; case firstType<br>&gt; case secondType<br>&gt; }<br>&gt;<br>&gt; This is the final solution for the sub typing problem of optional.<br>&gt;<br>&gt;<br>&gt; A  == union(A,A)<br>&gt; union(A,B) == union(B,A)<br>&gt; B == union(B,B)<br>&gt;<br>&gt; B is subtype of union(A,B)<br>&gt; A is subtype of union(A,B)<br>&gt;<br>&gt; suppose<br>&gt; a is subclass of A<br>&gt; b is subclass of B, then<br>&gt; union(a,B) is subtype of union(A,B)<br>&gt; union(A,b) is subtype of union(A,B)<br>&gt; union(a,b) is subtype of union(a,B)<br>&gt; union(a,b) is subtype of union(A,b)<br>&gt;<br>&gt; union can have as many case as possible. e.g., union(A,B,C,D,…)<br>&gt;<br>&gt; So the Optional&lt;UITableView&gt; should be union(UITableView, None)<br>&gt; and Optional&lt;MyTableVIew&gt; should be union(MyTableView, None), which is<br>&gt; subclass of union(UITableView, None)<br>&gt;<br>&gt; This is a final rational solution. I think.<br>&gt;<br>&gt; -Jiannan<br>&gt;<br>&gt; 下面是被转发的邮件：<br>&gt;<br>&gt; *发件人: *Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; *主题: **[swift-evolution] Swift Generic Subtype Problem*<br>&gt; *日期: *2016年2月16日 GMT+8 11:48:18<br>&gt; *收件人: *swift-evolution at swift.org<br>&gt; *回复－收件人: *Cao Jiannan &lt;frogcjn at 163.com&gt;<br>&gt;<br>&gt;<br>&gt; Hi all,<br>&gt; I want to discuss on a problem  about optional generic sub-typing.<br>&gt;<br>&gt; This is my suggesion.<br>&gt;<br>&gt; if B is subclass of A<br>&gt; Either&lt;B,B&gt; is subclass of Either&lt;A,A&gt;, Either&lt;A,B&gt;, Either&lt;B,A&gt;<br>&gt; Either&lt;B,A&gt; is subclass of Either&lt;A,A&gt;<br>&gt; Either&lt;A,B&gt; is subclass of Either&lt;A,A&gt;<br>&gt;<br>&gt; Why? Let’s see an example code in a real project:<br>&gt;<br>&gt;<br>&gt;<br>&gt; Here is a protocol type for some UIViewController,<br>&gt;<br>&gt;    1. protocol  SegueHandlerType {<br>&gt;    2.     var tableView: UITableView! { get }<br>&gt;    3. }<br>&gt;<br>&gt;<br>&gt; so the UITableViewController can conform to the protocal<br>&gt;<br>&gt;    1. extension UITableViewController : SegueHandlerType {<br>&gt;    2. }<br>&gt;<br>&gt;<br>&gt; It&#39;s great!<br>&gt; What if the tableView is a subclass UITableView?<br>&gt; like:<br>&gt;<br>&gt;    1. class MyTableView : UITableView {<br>&gt;    2. }<br>&gt;    3.<br>&gt;    4. MyTableViewController {<br>&gt;    5.       @IBOutlet var tableView: MyTableView!<br>&gt;    6. }<br>&gt;<br>&gt;<br>&gt; Then<br>&gt;<br>&gt;    1. extension MyTableViewController:SegueHandlerType {<br>&gt;    2.<br>&gt;    3. }<br>&gt;<br>&gt; will trigger a compiler error.<br>&gt;<br>&gt; So the Optional needs a subclass system.<br>&gt; Or to say, that the template system needs a subclass system.<br>&gt;<br>&gt; Optional&lt;UITableView&gt; should be the super type of Optional&lt;MyTableView&gt;<br>&gt; Array&lt;UITableView&gt; should be the super type of Array&lt;MyTableView&gt;<br>&gt;<br>&gt; https://forums.developer.apple.com/message/101646#101646<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; Thanks!<br>&gt;<br>&gt; Jiannan, Cao<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/7e72b173/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Swift Generic Subtype Problem</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>February 16, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Feb 15, 2016, at 11:46 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The same goes for tuples. At the moment a tuple is the closest thing to a c style struct. I think c structs are currently imported as tuples.<br></p><p>Actually structs are imported as structs :-) (eg, import CoreGraphics - you get a CGPoint struct). We ask clang do the in-memory layout, but from a language perspective, they look mostly like normal Swift structs.<br></p><p>&gt; If you made it so (A,A) was interchangeable with (B,B) then they&#39;d have to have the same size, and maybe also store type information where they may not otherwise.<br></p><p>That’s not a requirement for subtyping relations actually.<br></p><p>If A is a struct conforming to some protocol P, then values of type ‘A’ have a different runtime representation than values of type ‘P’, because the protocol value needs to attach the runtime type to the payload, whereas the struct will not. However, we still do an implicit conversion allowing As to be passed as Ps, we just generate the right code at the point where the conversion takes place. <br></p><p>Another example is when you have a function () -&gt; A, the conversion to () -&gt; P requires actually generating a thunk to wrap the original function value.<br></p><p>Subtyping in Swift is different from a pointer cast in C — its semantically producing a new value, so any representational change issues are orthogonal to the language itself. They leak out in the cases that are not implemented (we don’t do tuple conversions currently, and didn’t do function conversions until 2.1) but those will get plugged over time.<br></p><p>Slava<br></p><p>&gt; <br>&gt; On Tuesday, 16 February 2016, Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Also:<br>&gt; <br>&gt; union(A,B,C) is subtype of union(A,B,C,D,…)<br>&gt; <br>&gt;&gt; 在 2016年2月16日，14:36，Cao Jiannan &lt;frogcjn at 163.com &lt;&gt;&gt; 写道：<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I think the best way to solve the either problem is to separate it from generic. <br>&gt;&gt; Optional and Either shouldn’t work the same way of generic type. <br>&gt;&gt; It’s just a represent of multiple type in one location.<br>&gt;&gt; <br>&gt;&gt; Using an old friend, Union in C.<br>&gt;&gt; union {<br>&gt;&gt; 	case firstType<br>&gt;&gt; 	case secondType<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This is the final solution for the sub typing problem of optional.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; A  == union(A,A)<br>&gt;&gt; union(A,B) == union(B,A)<br>&gt;&gt; B == union(B,B)<br>&gt;&gt; <br>&gt;&gt; B is subtype of union(A,B)<br>&gt;&gt; A is subtype of union(A,B)<br>&gt;&gt; <br>&gt;&gt; suppose <br>&gt;&gt; a is subclass of A<br>&gt;&gt; b is subclass of B, then<br>&gt;&gt; 	union(a,B) is subtype of union(A,B)<br>&gt;&gt; 	union(A,b) is subtype of union(A,B)<br>&gt;&gt; 	union(a,b) is subtype of union(a,B)<br>&gt;&gt; 	union(a,b) is subtype of union(A,b)<br>&gt;&gt; <br>&gt;&gt; union can have as many case as possible. e.g., union(A,B,C,D,…)<br>&gt;&gt; <br>&gt;&gt; So the Optional&lt;UITableView&gt; should be union(UITableView, None)<br>&gt;&gt; and Optional&lt;MyTableVIew&gt; should be union(MyTableView, None), which is subclass of union(UITableView, None)<br>&gt;&gt; <br>&gt;&gt; This is a final rational solution. I think.<br>&gt;&gt; <br>&gt;&gt; -Jiannan<br>&gt;&gt; <br>&gt;&gt;&gt; 下面是被转发的邮件：<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 发件人: Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt;<br>&gt;&gt;&gt; 主题: [swift-evolution] Swift Generic Subtype Problem<br>&gt;&gt;&gt; 日期: 2016年2月16日 GMT+8 11:48:18<br>&gt;&gt;&gt; 收件人: swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt; 回复－收件人: Cao Jiannan &lt;frogcjn at 163.com &lt;&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; I want to discuss on a problem  about optional generic sub-typing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is my suggesion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if B is subclass of A<br>&gt;&gt;&gt; Either&lt;B,B&gt; is subclass of Either&lt;A,A&gt;, Either&lt;A,B&gt;, Either&lt;B,A&gt;<br>&gt;&gt;&gt; Either&lt;B,A&gt; is subclass of Either&lt;A,A&gt;<br>&gt;&gt;&gt; Either&lt;A,B&gt; is subclass of Either&lt;A,A&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why? Let’s see an example code in a real project:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is a protocol type for some UIViewController,<br>&gt;&gt;&gt; protocol  SegueHandlerType {  <br>&gt;&gt;&gt;     var tableView: UITableView! { get }  <br>&gt;&gt;&gt; }  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; so the UITableViewController can conform to the protocal<br>&gt;&gt;&gt; extension UITableViewController : SegueHandlerType {  <br>&gt;&gt;&gt; }  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s great!<br>&gt;&gt;&gt; What if the tableView is a subclass UITableView?<br>&gt;&gt;&gt; like:<br>&gt;&gt;&gt; class MyTableView : UITableView {<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; MyTableViewController {  <br>&gt;&gt;&gt;       @IBOutlet var tableView: MyTableView!  <br>&gt;&gt;&gt; }  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then <br>&gt;&gt;&gt; extension MyTableViewController:SegueHandlerType {  <br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; }  <br>&gt;&gt;&gt; will trigger a compiler error.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; So the Optional needs a subclass system.<br>&gt;&gt;&gt; Or to say, that the template system needs a subclass system.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Optional&lt;UITableView&gt; should be the super type of Optional&lt;MyTableView&gt;<br>&gt;&gt;&gt; Array&lt;UITableView&gt; should be the super type of Array&lt;MyTableView&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://forums.developer.apple.com/message/101646#101646 &lt;https://forums.developer.apple.com/message/101646#101646&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jiannan, Cao<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/f9fd218d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Swift Generic Subtype Problem</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>February 16, 2016 at 05:00:00pm</p></header><div class="content"><p>Thanks for the detailed response, very interesting and its helped improve<br>my mental model. I think I may have misinterpreted the extent of the<br>proposal. Good point with CoreGraphics, I was the memory layout rather than<br>the public interface that I was thinking of, but perhaps my memory is out<br>of date :)<br></p><p>I think the thing I was remembering is this sort of thing:<br></p><p>public struct _opaque_pthread_t {<br></p><p>    public var __sig: Int<br></p><p>    public var __cleanup_stack: UnsafeMutablePointer&lt;<br>__darwin_pthread_handler_rec&gt;<br></p><p>    public var __opaque: (Int8, Int8, Int8, Int8, ...))<br></p><p>}<br></p><p><br>But I think that&#39;s a pthread thing, and probably for fixed sized arrays<br>too. Anyway tuples is for the other thread.<br></p><p><br>If my assumptions were false and the original idea doesn&#39;t change the<br>memory/performance overhead then I am all for it :)<br></p><p><br></p><p>On Tue, Feb 16, 2016 at 5:24 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Feb 15, 2016, at 11:46 PM, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The same goes for tuples. At the moment a tuple is the closest thing to a<br>&gt; c style struct. I think c structs are currently imported as tuples.<br>&gt;<br>&gt;<br>&gt; Actually structs are imported as structs :-) (eg, import CoreGraphics -<br>&gt; you get a CGPoint struct). We ask clang do the in-memory layout, but from a<br>&gt; language perspective, they look mostly like normal Swift structs.<br>&gt;<br>&gt; If you made it so (A,A) was interchangeable with (B,B) then they&#39;d have to<br>&gt; have the same size, and maybe also store type information where they may<br>&gt; not otherwise.<br>&gt;<br>&gt;<br>&gt; That’s not a requirement for subtyping relations actually.<br>&gt;<br>&gt; If A is a struct conforming to some protocol P, then values of type ‘A’<br>&gt; have a different runtime representation than values of type ‘P’, because<br>&gt; the protocol value needs to attach the runtime type to the payload, whereas<br>&gt; the struct will not. However, we still do an implicit conversion allowing<br>&gt; As to be passed as Ps, we just generate the right code at the point where<br>&gt; the conversion takes place.<br>&gt;<br>&gt; Another example is when you have a function () -&gt; A, the conversion to ()<br>&gt; -&gt; P requires actually generating a thunk to wrap the original function<br>&gt; value.<br>&gt;<br>&gt; Subtyping in Swift is different from a pointer cast in C — its<br>&gt; semantically producing a new value, so any representational change issues<br>&gt; are orthogonal to the language itself. They leak out in the cases that are<br>&gt; not implemented (we don’t do tuple conversions currently, and didn’t do<br>&gt; function conversions until 2.1) but those will get plugged over time.<br>&gt;<br>&gt; Slava<br>&gt;<br>&gt;<br>&gt; On Tuesday, 16 February 2016, Cao Jiannan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Also:<br>&gt;&gt;<br>&gt;&gt; union(A,B,C) is subtype of union(A,B,C,D,…)<br>&gt;&gt;<br>&gt;&gt; 在 2016年2月16日，14:36，Cao Jiannan &lt;frogcjn at 163.com&gt; 写道：<br>&gt;&gt;<br>&gt;&gt; Hi all,<br>&gt;&gt;<br>&gt;&gt; I think the best way to solve the either problem is to separate it from<br>&gt;&gt; generic.<br>&gt;&gt; Optional and Either shouldn’t work the same way of generic type.<br>&gt;&gt; It’s just a represent of multiple type in one location.<br>&gt;&gt;<br>&gt;&gt; Using an old friend, Union in C.<br>&gt;&gt; union {<br>&gt;&gt; case firstType<br>&gt;&gt; case secondType<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This is the final solution for the sub typing problem of optional.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; A  == union(A,A)<br>&gt;&gt; union(A,B) == union(B,A)<br>&gt;&gt; B == union(B,B)<br>&gt;&gt;<br>&gt;&gt; B is subtype of union(A,B)<br>&gt;&gt; A is subtype of union(A,B)<br>&gt;&gt;<br>&gt;&gt; suppose<br>&gt;&gt; a is subclass of A<br>&gt;&gt; b is subclass of B, then<br>&gt;&gt; union(a,B) is subtype of union(A,B)<br>&gt;&gt; union(A,b) is subtype of union(A,B)<br>&gt;&gt; union(a,b) is subtype of union(a,B)<br>&gt;&gt; union(a,b) is subtype of union(A,b)<br>&gt;&gt;<br>&gt;&gt; union can have as many case as possible. e.g., union(A,B,C,D,…)<br>&gt;&gt;<br>&gt;&gt; So the Optional&lt;UITableView&gt; should be union(UITableView, None)<br>&gt;&gt; and Optional&lt;MyTableVIew&gt; should be union(MyTableView, None), which is<br>&gt;&gt; subclass of union(UITableView, None)<br>&gt;&gt;<br>&gt;&gt; This is a final rational solution. I think.<br>&gt;&gt;<br>&gt;&gt; -Jiannan<br>&gt;&gt;<br>&gt;&gt; 下面是被转发的邮件：<br>&gt;&gt;<br>&gt;&gt; *发件人: *Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; *主题: **[swift-evolution] Swift Generic Subtype Problem*<br>&gt;&gt; *日期: *2016年2月16日 GMT+8 11:48:18<br>&gt;&gt; *收件人: *swift-evolution at swift.org<br>&gt;&gt; *回复－收件人: *Cao Jiannan &lt;frogcjn at 163.com&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Hi all,<br>&gt;&gt; I want to discuss on a problem  about optional generic sub-typing.<br>&gt;&gt;<br>&gt;&gt; This is my suggesion.<br>&gt;&gt;<br>&gt;&gt; if B is subclass of A<br>&gt;&gt; Either&lt;B,B&gt; is subclass of Either&lt;A,A&gt;, Either&lt;A,B&gt;, Either&lt;B,A&gt;<br>&gt;&gt; Either&lt;B,A&gt; is subclass of Either&lt;A,A&gt;<br>&gt;&gt; Either&lt;A,B&gt; is subclass of Either&lt;A,A&gt;<br>&gt;&gt;<br>&gt;&gt; Why? Let’s see an example code in a real project:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Here is a protocol type for some UIViewController,<br>&gt;&gt;<br>&gt;&gt;    1. protocol  SegueHandlerType {<br>&gt;&gt;    2.     var tableView: UITableView! { get }<br>&gt;&gt;    3. }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; so the UITableViewController can conform to the protocal<br>&gt;&gt;<br>&gt;&gt;    1. extension UITableViewController : SegueHandlerType {<br>&gt;&gt;    2. }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It&#39;s great!<br>&gt;&gt; What if the tableView is a subclass UITableView?<br>&gt;&gt; like:<br>&gt;&gt;<br>&gt;&gt;    1. class MyTableView : UITableView {<br>&gt;&gt;    2. }<br>&gt;&gt;    3.<br>&gt;&gt;    4. MyTableViewController {<br>&gt;&gt;    5.       @IBOutlet var tableView: MyTableView!<br>&gt;&gt;    6. }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Then<br>&gt;&gt;<br>&gt;&gt;    1. extension MyTableViewController:SegueHandlerType {<br>&gt;&gt;    2.<br>&gt;&gt;    3. }<br>&gt;&gt;<br>&gt;&gt; will trigger a compiler error.<br>&gt;&gt;<br>&gt;&gt; So the Optional needs a subclass system.<br>&gt;&gt; Or to say, that the template system needs a subclass system.<br>&gt;&gt;<br>&gt;&gt; Optional&lt;UITableView&gt; should be the super type of Optional&lt;MyTableView&gt;<br>&gt;&gt; Array&lt;UITableView&gt; should be the super type of Array&lt;MyTableView&gt;<br>&gt;&gt;<br>&gt;&gt; https://forums.developer.apple.com/message/101646#101646<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Thanks!<br>&gt;&gt;<br>&gt;&gt; Jiannan, Cao<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/e9e69269/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Swift Generic Subtype Problem</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>February 16, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Feb 16, 2016, at 12:37 AM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Thanks for the detailed response, very interesting and its helped improve my mental model. I think I may have misinterpreted the extent of the proposal. Good point with CoreGraphics, I was the memory layout rather than the public interface that I was thinking of, but perhaps my memory is out of date :)<br>&gt; <br>&gt; I think the thing I was remembering is this sort of thing:<br>&gt; <br>&gt; public struct _opaque_pthread_t {<br>&gt;     public var __sig: Int<br>&gt;     public var __cleanup_stack: UnsafeMutablePointer&lt;__darwin_pthread_handler_rec&gt;<br>&gt;     public var __opaque: (Int8, Int8, Int8, Int8, ...))<br>&gt; }<br>&gt; <br>&gt; But I think that&#39;s a pthread thing, and probably for fixed sized arrays too.<br></p><p>Yep, it’s fixed size arrays that are imported like that. We have no other way of modeling them in Swift right now.<br></p><p><br>&gt; Anyway tuples is for the other thread.<br>&gt; <br>&gt; If my assumptions were false and the original idea doesn&#39;t change the memory/performance overhead then I am all for it :)<br></p><p>In general, the only things in the current Swift implementation that are tagged with runtime type information are instances of classes in the heap, and values of protocol type. Everywhere else, the compiler knows the layout statically, or it is passed in separately from the data (ie generics).<br></p><p>&gt; <br>&gt; <br>&gt; On Tue, Feb 16, 2016 at 5:24 PM, Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Feb 15, 2016, at 11:46 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The same goes for tuples. At the moment a tuple is the closest thing to a c style struct. I think c structs are currently imported as tuples.<br>&gt; <br>&gt; Actually structs are imported as structs :-) (eg, import CoreGraphics - you get a CGPoint struct). We ask clang do the in-memory layout, but from a language perspective, they look mostly like normal Swift structs.<br>&gt; <br>&gt;&gt; If you made it so (A,A) was interchangeable with (B,B) then they&#39;d have to have the same size, and maybe also store type information where they may not otherwise.<br>&gt; <br>&gt; That’s not a requirement for subtyping relations actually.<br>&gt; <br>&gt; If A is a struct conforming to some protocol P, then values of type ‘A’ have a different runtime representation than values of type ‘P’, because the protocol value needs to attach the runtime type to the payload, whereas the struct will not. However, we still do an implicit conversion allowing As to be passed as Ps, we just generate the right code at the point where the conversion takes place. <br>&gt; <br>&gt; Another example is when you have a function () -&gt; A, the conversion to () -&gt; P requires actually generating a thunk to wrap the original function value.<br>&gt; <br>&gt; Subtyping in Swift is different from a pointer cast in C — its semantically producing a new value, so any representational change issues are orthogonal to the language itself. They leak out in the cases that are not implemented (we don’t do tuple conversions currently, and didn’t do function conversions until 2.1) but those will get plugged over time.<br>&gt; <br>&gt; Slava<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Tuesday, 16 February 2016, Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Also:<br>&gt;&gt; <br>&gt;&gt; union(A,B,C) is subtype of union(A,B,C,D,…)<br>&gt;&gt; <br>&gt;&gt;&gt; 在 2016年2月16日，14:36，Cao Jiannan &lt;frogcjn at 163.com &lt;&gt;&gt; 写道：<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the best way to solve the either problem is to separate it from generic. <br>&gt;&gt;&gt; Optional and Either shouldn’t work the same way of generic type. <br>&gt;&gt;&gt; It’s just a represent of multiple type in one location.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using an old friend, Union in C.<br>&gt;&gt;&gt; union {<br>&gt;&gt;&gt; 	case firstType<br>&gt;&gt;&gt; 	case secondType<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is the final solution for the sub typing problem of optional.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A  == union(A,A)<br>&gt;&gt;&gt; union(A,B) == union(B,A)<br>&gt;&gt;&gt; B == union(B,B)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; B is subtype of union(A,B)<br>&gt;&gt;&gt; A is subtype of union(A,B)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; suppose <br>&gt;&gt;&gt; a is subclass of A<br>&gt;&gt;&gt; b is subclass of B, then<br>&gt;&gt;&gt; 	union(a,B) is subtype of union(A,B)<br>&gt;&gt;&gt; 	union(A,b) is subtype of union(A,B)<br>&gt;&gt;&gt; 	union(a,b) is subtype of union(a,B)<br>&gt;&gt;&gt; 	union(a,b) is subtype of union(A,b)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; union can have as many case as possible. e.g., union(A,B,C,D,…)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So the Optional&lt;UITableView&gt; should be union(UITableView, None)<br>&gt;&gt;&gt; and Optional&lt;MyTableVIew&gt; should be union(MyTableView, None), which is subclass of union(UITableView, None)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a final rational solution. I think.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Jiannan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 下面是被转发的邮件：<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 发件人: Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 主题: [swift-evolution] Swift Generic Subtype Problem<br>&gt;&gt;&gt;&gt; 日期: 2016年2月16日 GMT+8 11:48:18<br>&gt;&gt;&gt;&gt; 收件人: swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt;&gt; 回复－收件人: Cao Jiannan &lt;frogcjn at 163.com &lt;&gt;&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; I want to discuss on a problem  about optional generic sub-typing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is my suggesion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if B is subclass of A<br>&gt;&gt;&gt;&gt; Either&lt;B,B&gt; is subclass of Either&lt;A,A&gt;, Either&lt;A,B&gt;, Either&lt;B,A&gt;<br>&gt;&gt;&gt;&gt; Either&lt;B,A&gt; is subclass of Either&lt;A,A&gt;<br>&gt;&gt;&gt;&gt; Either&lt;A,B&gt; is subclass of Either&lt;A,A&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Why? Let’s see an example code in a real project:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here is a protocol type for some UIViewController,<br>&gt;&gt;&gt;&gt; protocol  SegueHandlerType {  <br>&gt;&gt;&gt;&gt;     var tableView: UITableView! { get }  <br>&gt;&gt;&gt;&gt; }  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; so the UITableViewController can conform to the protocal<br>&gt;&gt;&gt;&gt; extension UITableViewController : SegueHandlerType {  <br>&gt;&gt;&gt;&gt; }  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s great!<br>&gt;&gt;&gt;&gt; What if the tableView is a subclass UITableView?<br>&gt;&gt;&gt;&gt; like:<br>&gt;&gt;&gt;&gt; class MyTableView : UITableView {<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; MyTableViewController {  <br>&gt;&gt;&gt;&gt;       @IBOutlet var tableView: MyTableView!  <br>&gt;&gt;&gt;&gt; }  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Then <br>&gt;&gt;&gt;&gt; extension MyTableViewController:SegueHandlerType {  <br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt; }  <br>&gt;&gt;&gt;&gt; will trigger a compiler error.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; So the Optional needs a subclass system.<br>&gt;&gt;&gt;&gt; Or to say, that the template system needs a subclass system.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Optional&lt;UITableView&gt; should be the super type of Optional&lt;MyTableView&gt;<br>&gt;&gt;&gt;&gt; Array&lt;UITableView&gt; should be the super type of Array&lt;MyTableView&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://forums.developer.apple.com/message/101646#101646 &lt;https://forums.developer.apple.com/message/101646#101646&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jiannan, Cao<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/716bce26/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Swift Generic Subtype Problem</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>February 16, 2016 at 12:00:00am</p></header><div class="content"><p>Hi Cao,<br></p><p>Note that Optional&lt;T&gt; already supports covariance as well as an “injection” from T to Optional&lt;T&gt;:<br></p><p>class A{<br></p><p>}<br></p><p>class B:A {<br></p><p>}<br></p><p>let b: B? = B()  // conversion from B to B?<br>let a: A? = b    // conversion from B? to A?<br></p><p>This is special-cased by the type checker, and not exposed for use by user-defined types such as Either in your example.<br></p><p> <br>&gt; On Feb 15, 2016, at 10:36 PM, Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; So the Optional&lt;UITableView&gt; should be union(UITableView, None)<br>&gt; and Optional&lt;MyTableVIew&gt; should be union(MyTableView, None), which is subclass of union(UITableView, None)<br></p><p>But you can still have generic type parameters here, if your function is generic over T and you write union(T, SomeOtherType). How would that work?<br></p><p>&gt; <br>&gt; This is a final rational solution. I think.<br>&gt; <br>&gt; -Jiannan<br>&gt; <br>&gt;&gt; 下面是被转发的邮件：<br>&gt;&gt; <br>&gt;&gt; 发件人: Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; 主题: [swift-evolution] Swift Generic Subtype Problem<br>&gt;&gt; 日期: 2016年2月16日 GMT+8 11:48:18<br>&gt;&gt; 收件人: swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; 回复－收件人: Cao Jiannan &lt;frogcjn at 163.com &lt;mailto:frogcjn at 163.com&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; I want to discuss on a problem  about optional generic sub-typing.<br>&gt;&gt; <br>&gt;&gt; This is my suggesion.<br>&gt;&gt; <br>&gt;&gt; if B is subclass of A<br>&gt;&gt; Either&lt;B,B&gt; is subclass of Either&lt;A,A&gt;, Either&lt;A,B&gt;, Either&lt;B,A&gt;<br>&gt;&gt; Either&lt;B,A&gt; is subclass of Either&lt;A,A&gt;<br>&gt;&gt; Either&lt;A,B&gt; is subclass of Either&lt;A,A&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Why? Let’s see an example code in a real project:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Here is a protocol type for some UIViewController,<br>&gt;&gt; protocol  SegueHandlerType {  <br>&gt;&gt;     var tableView: UITableView! { get }  <br>&gt;&gt; }  <br>&gt;&gt; <br>&gt;&gt; so the UITableViewController can conform to the protocal<br>&gt;&gt; extension UITableViewController : SegueHandlerType {  <br>&gt;&gt; }  <br>&gt;&gt; <br>&gt;&gt; It&#39;s great!<br>&gt;&gt; What if the tableView is a subclass UITableView?<br>&gt;&gt; like:<br>&gt;&gt; class MyTableView : UITableView {<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; MyTableViewController {  <br>&gt;&gt;       @IBOutlet var tableView: MyTableView!  <br>&gt;&gt; }  <br>&gt;&gt; <br>&gt;&gt; Then <br>&gt;&gt; extension MyTableViewController:SegueHandlerType {  <br>&gt;&gt;   <br>&gt;&gt; }  <br></p><p><br>&gt;&gt; will trigger a compiler error.<br></p><p>The issue here is slightly different actually, but another interesting corner case that should be addressed. Protocol witness matching only looks at exact type equivalence, and not subtyping. So even without the ! it would hit the same issue:<br></p><p>protocol P {<br>	func f() -&gt; A<br>}<br></p><p>class B : A {}<br></p><p>class C : P {<br>	func f() -&gt; B {} // compile error<br>}<br></p><p>Once witness matching supports variance, your example will work.<br></p><p>But a better way would be to use an associated type:<br></p><p>protocol SequeHandlerType {<br>    associatedtype View : UITableView<br>    var tableView: View! { get }<br>}<br></p><p>Now a witness can return any subclass of UITableView, which will unify with the View associated type. Furthermore, other requirements can also reference View and the type checker will ensure any conformance has the same View in all positions where it appears.<br></p><p>Slava<br></p><p><br>&gt;&gt;  <br>&gt;&gt; So the Optional needs a subclass system.<br>&gt;&gt; Or to say, that the template system needs a subclass system.<br>&gt;&gt;  <br>&gt;&gt; Optional&lt;UITableView&gt; should be the super type of Optional&lt;MyTableView&gt;<br>&gt;&gt; Array&lt;UITableView&gt; should be the super type of Array&lt;MyTableView&gt;<br>&gt;&gt; <br>&gt;&gt; https://forums.developer.apple.com/message/101646#101646 &lt;https://forums.developer.apple.com/message/101646#101646&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Thanks!<br>&gt;&gt; <br>&gt;&gt; Jiannan, Cao<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/e1a3ab79/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d569462ac92d4619342b1c5ff305043?s=50"></div><header><strong>Swift Generic Subtype Problem</strong> from <string>frogcjn at 163.com</string> &lt;frogcjn at 163.com&gt;<p>February 16, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi Slava:<br></p><p>&gt; class B : A {}<br>&gt; <br>&gt; class C : P {<br>&gt; 	func f() -&gt; B {} // compile error<br>&gt; }<br>&gt; <br>&gt; Once witness matching supports variance, your example will work.<br>&gt; <br>&gt; But a better way would be to use an associated type:<br>&gt; <br>&gt; protocol SequeHandlerType {<br>&gt;     associatedtype View : UITableView<br>&gt;     var tableView: View! { get }<br>&gt; }<br></p><p><br>Yes. This makes sense to me. <br>Associate type is a hard toy for me. <br>Sometimes I can figure out, sometimes I cannot. Sometimes I figure out but compiler say no.<br></p><p>The problem is not really with the optional sub typing relation, but looks like.<br>AssociatedType can solve the problem like this:<br></p><p>class A {}<br></p><p>class B : A {}<br></p><p><br>protocol HandlerType{<br>    var a: A { get }<br>}<br></p><p>class Handler: HandlerType{<br>    var b = B() //Compiler Error, though b is subtype of A<br>}<br></p><p>should be:<br></p><p>protocol HandlerType{<br>    typealias Target :A<br>    var a: Target { get }<br>}<br></p><p>class Handler: HandlerType {<br>    var a = B()<br>}<br></p><p>This is the solution to my question.<br>Thanks.<br></p><p>- Jiannan<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/fa1394bc/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
