<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85f9b9a5c2d7cbaa85388ff1e0f571dc?s=50"></div><header><strong>[Discussion] Difference between static and lazy variables regarding evaluation of closure</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at me.com&gt;<p>April  8, 2016 at 09:00:00am</p></header><div class="content"><p>I noticed a difference between how static and lazy variables evaluate closures and thought that it was a bug:<br>https://bugs.swift.org/browse/SR-1178<br>but apparently it’s not.<br></p><p>The difference can be illustrated in a small example. The following code will evaluate the closure for the static variable, even when *setting* the variable, but won’t evaluate the closure for the lazy variable. Thus, it prints “static”, but not “lazy”.<br></p><p>    class Foo {<br>        static var bar: String = {<br>            print(&quot;static&quot;)<br>            return &quot;Default&quot;<br>        }()<br>        <br>        lazy var baz: String = {<br>            print(&quot;lazy&quot;)<br>            return &quot;Lazy&quot;<br>        }()<br>    }<br></p><p>    Foo.bar = &quot;Set&quot;<br></p><p>    let foo = Foo()<br>    foo.baz = “Set&quot;<br></p><p>I would have thought that neither case should evaluate the closure when setting the variable, since the result from the closure is never used in that case. I don’t feel that strongly about if the closure is evaluated or not. But I would like both types (static and lazy) to behave the same. <br></p><p>- David<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Discussion] Difference between static and lazy variables regarding evaluation of closure</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April  8, 2016 at 07:00:00pm</p></header><div class="content"><p>Yes, IMO it really looks strange.<br>Just checked:<br></p><p>     class Foo {<br>         static var test = &quot;test&quot;<br></p><p>         static var bar: String = {<br>             print(&quot;static&quot;)<br>             return &quot;Default&quot;<br>         }()<br></p><p>         lazy var baz: String = {<br>             print(&quot;lazy&quot;)<br>             return &quot;Lazy&quot;<br>         }()<br>     }<br></p><p><br>     print(&quot;1&quot;)<br>     print(Foo.test)<br>     print(&quot;2&quot;)<br>     Foo.bar = &quot;Set&quot;<br>     print(&quot;3&quot;)<br>     let foo = Foo()<br>     foo.baz = &quot;Set&quot;<br>     print(&quot;4&quot;)<br></p><p>we have :<br>1<br>test<br>2<br>static<br>3<br>4<br></p><p>I strongly believe as static property is lazy by definition, it must not be <br>evaluated at all when we set it. This is something that &quot;lazyness&quot; promises <br>to us - that it will be called/calculated ONLY when we ask for this. So in <br>my opinion this is bug/issue and should be fixed/changed in Swift 3.0.<br></p><p><br>On 08.04.2016 10:36, David Rönnqvist via swift-evolution wrote:<br>&gt; I noticed a difference between how static and lazy variables evaluate closures and thought that it was a bug:<br>&gt; https://bugs.swift.org/browse/SR-1178<br>&gt; but apparently it’s not.<br> &gt; ...<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Discussion] Difference between static and lazy variables regarding evaluation of closure</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>May 31, 2016 at 03:00:00pm</p></header><div class="content"><p>With the risk of this showing up 3 times in the mailing list (I posted it as a new topic, but it didn&#39;t seem to show up).<br></p><p><br>Several weeks ago I posted that I was confused by the differences between how static variables and lazy variables evaluated (or - as I would expect - didn’t evaluate) when initially assigned with a different value. It didn’t result in any discussion, but I encountered it again and decided to draft a proposal hoping that there will be some discussion around it. The draft is available here: https://github.com/d-ronnqvist/swift-evolution/blob/master/proposals/0000-static-var-lazy-behavior.md &lt;https://github.com/d-ronnqvist/swift-evolution/blob/master/proposals/0000-static-var-lazy-behavior.md&gt;<br></p><p>Please let me know what you think, and if you believe this is something that’s worth pursuing.<br></p><p>- David<br></p><p><br>Lazy evaluation when assigning static variables<br></p><p>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>Author(s): David Rönnqvist &lt;https://github.com/d-ronnqvist&gt;<br>Status: Awaiting review &lt;https://github.com/d-ronnqvist/swift-evolution#rationale&gt;<br>Review manager: TBD<br> &lt;https://github.com/d-ronnqvist/swift-evolution#introduction&gt;Introduction<br></p><p>Both stored type properties (static) and lazy stored properties (lazy var) are lazily initialized. However, they have different initialization behavior in that stored type properties evaluate even when assigning them a new value.<br></p><p>The following code will print &quot;static&quot;, but not &quot;lazy&quot;:<br></p><p>class Foo {<br>    static var bar: String = {<br>        print(&quot;static&quot;)<br>        return &quot;Default&quot;<br>    }()<br></p><p>    lazy var baz: String = {<br>        print(&quot;lazy&quot;)<br>        return &quot;Lazy&quot;<br>    }()<br>}<br></p><p>Foo.bar = &quot;Set&quot; // this evaluates the initial value of `bar` before setting a new value<br></p><p>let foo = Foo()<br>foo.baz = &quot;Set&quot; // this doesn&#39;t evaluate `baz` before setting a new value<br>Swift-evolution thread: [Discussion] Difference between static and lazy variables regarding evaluation of closure &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14086&gt;<br> &lt;https://github.com/d-ronnqvist/swift-evolution#motivation&gt;Motivation<br></p><p>Swift currently evaluates stored type properties even when assigning a new value. This behavior is very subtle and can lead to objects being needlessly initialized and &quot;immediately&quot; de-initialized, as well as unwanted side effects (caused by the initialized objects).<br></p><p>For example, a shared re-assignable instance that is replaced during unit test set up will initialize the &quot;real&quot; object before assigning the test replacement. <br></p><p> &lt;https://github.com/d-ronnqvist/swift-evolution#detailed-design&gt;Detailed design<br></p><p>This proposal seeks to unify the lazy evaluation on assignment of stored type properties (static) and lazy stored properties (lazy var) so that the value being replaced isn&#39;t evaluated (the current behavior of lazy stored properties). <br></p><p>However, it seeks to keep their respective behaviors and guarantees regarding multithreaded simultaneous access:<br></p><p>From the The Swift Programming Language (Swift 2.2) &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID254&gt; regarding lazy stored properties: <br></p><p>If a property marked with the lazy modifier is accessed by multiple threads simultaneously and the property has not yet been initialized, there is no guarantee that the property will be initialized only once.<br>and regarding stored type properties:<br></p><p>Stored type properties are lazily initialized on their first access. They are guaranteed to be initialized only once, even when accessed by multiple threads simultaneously, and they do not need to be marked with the lazy modifier.<br>No changes to the syntax is proposed. <br></p><p>This provides a more consistent lazy evaluation behavior, and fixes a (small) source of potential, subtle bugs.<br></p><p> &lt;https://github.com/d-ronnqvist/swift-evolution#impact-on-existing-code&gt;Impact on existing code<br></p><p>This proposal changes the lazy evaluation of stored type properties when assigning a new value. <br></p><p>Any code that is relying on this effect would break in subtle ways. This is hard to detect and migrate, but hopefully very rare (and to the best of my knowledge the behavior that code would be relying upon is undocumented).<br></p><p> &lt;https://github.com/d-ronnqvist/swift-evolution#alternatives-considered&gt;Alternatives considered<br></p><p>One alternative is to be consistent with the stored type properties and always evaluate the initial value, even when re-assigning it. However, this version doesn&#39;t address the subtle bugs that can arise from this behavior.<br></p><p>Another alternative is to leave the the respective behaviors as is and mention their differences in The Swift Programming Language guide. This might still be the most viable alternative in case the current behavior is a consequence of their respective implementations with regards to multithreaded access.<br></p><p> &lt;https://github.com/d-ronnqvist/swift-evolution#rationale&gt;Rationale<br></p><p>On [Date], the core team decided to (TBD) this proposal. When the core team makes a decision regarding this proposal, their rationale for the decision will be written here.<br></p><p><br></p><p>8 apr. 2016 kl. 18:50 skrev Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br></p><p>&gt; Yes, IMO it really looks strange.<br>&gt; Just checked:<br>&gt; <br>&gt;    class Foo {<br>&gt;        static var test = &quot;test&quot;<br>&gt; <br>&gt;        static var bar: String = {<br>&gt;            print(&quot;static&quot;)<br>&gt;            return &quot;Default&quot;<br>&gt;        }()<br>&gt; <br>&gt;        lazy var baz: String = {<br>&gt;            print(&quot;lazy&quot;)<br>&gt;            return &quot;Lazy&quot;<br>&gt;        }()<br>&gt;    }<br>&gt; <br>&gt; <br>&gt;    print(&quot;1&quot;)<br>&gt;    print(Foo.test)<br>&gt;    print(&quot;2&quot;)<br>&gt;    Foo.bar = &quot;Set&quot;<br>&gt;    print(&quot;3&quot;)<br>&gt;    let foo = Foo()<br>&gt;    foo.baz = &quot;Set&quot;<br>&gt;    print(&quot;4&quot;)<br>&gt; <br>&gt; we have :<br>&gt; 1<br>&gt; test<br>&gt; 2<br>&gt; static<br>&gt; 3<br>&gt; 4<br>&gt; <br>&gt; I strongly believe as static property is lazy by definition, it must not be evaluated at all when we set it. This is something that &quot;lazyness&quot; promises to us - that it will be called/calculated ONLY when we ask for this. So in my opinion this is bug/issue and should be fixed/changed in Swift 3.0.<br>&gt; <br>&gt; <br>&gt; On 08.04.2016 10:36, David Rönnqvist via swift-evolution wrote:<br>&gt;&gt; I noticed a difference between how static and lazy variables evaluate closures and thought that it was a bug:<br>&gt;&gt; https://bugs.swift.org/browse/SR-1178 &lt;https://bugs.swift.org/browse/SR-1178&gt;<br>&gt;&gt; but apparently it’s not.<br>&gt; &gt; ...<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/2098768a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Discussion] Difference between static and lazy variables regarding evaluation of closure</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 31, 2016 at 02:00:00pm</p></header><div class="content"><p>I’m a +1 for making the behaviour more consistent, I can’t imagine many people rely on the guaranteed execution for static properties (personally I wasn’t even aware there was a difference), and anyone that needs guaranteed execution should be implementing lazy properties manually (i.e- with computed properties) as it’s possible to trigger required code more efficiently that way.<br></p><p>So yeah, I think that execution only as required is the right choice and that these should definitely be made consistent.<br></p><p>&gt; On 31 May 2016, at 14:32, David Rönnqvist via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; With the risk of this showing up 3 times in the mailing list (I posted it as a new topic, but it didn&#39;t seem to show up).<br>&gt; <br>&gt; <br>&gt; Several weeks ago I posted that I was confused by the differences between how static variables and lazy variables evaluated (or - as I would expect - didn’t evaluate) when initially assigned with a different value. It didn’t result in any discussion, but I encountered it again and decided to draft a proposal hoping that there will be some discussion around it. The draft is available here: https://github.com/d-ronnqvist/swift-evolution/blob/master/proposals/0000-static-var-lazy-behavior.md &lt;https://github.com/d-ronnqvist/swift-evolution/blob/master/proposals/0000-static-var-lazy-behavior.md&gt;<br>&gt; <br>&gt; Please let me know what you think, and if you believe this is something that’s worth pursuing.<br>&gt; <br>&gt; - David<br>&gt; <br>&gt; <br>&gt; Lazy evaluation when assigning static variables<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt; Author(s): David Rönnqvist &lt;https://github.com/d-ronnqvist&gt;<br>&gt; Status: Awaiting review &lt;https://github.com/d-ronnqvist/swift-evolution#rationale&gt;<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/d-ronnqvist/swift-evolution#introduction&gt;Introduction<br>&gt; <br>&gt; Both stored type properties (static) and lazy stored properties (lazy var) are lazily initialized. However, they have different initialization behavior in that stored type properties evaluate even when assigning them a new value.<br>&gt; <br>&gt; The following code will print &quot;static&quot;, but not &quot;lazy&quot;:<br>&gt; <br>&gt; class Foo {<br>&gt;     static var bar: String = {<br>&gt;         print(&quot;static&quot;)<br>&gt;         return &quot;Default&quot;<br>&gt;     }()<br>&gt; <br>&gt;     lazy var baz: String = {<br>&gt;         print(&quot;lazy&quot;)<br>&gt;         return &quot;Lazy&quot;<br>&gt;     }()<br>&gt; }<br>&gt; <br>&gt; Foo.bar = &quot;Set&quot; // this evaluates the initial value of `bar` before setting a new value<br>&gt; <br>&gt; let foo = Foo()<br>&gt; foo.baz = &quot;Set&quot; // this doesn&#39;t evaluate `baz` before setting a new value<br>&gt; Swift-evolution thread: [Discussion] Difference between static and lazy variables regarding evaluation of closure &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14086&gt;<br>&gt;  &lt;https://github.com/d-ronnqvist/swift-evolution#motivation&gt;Motivation<br>&gt; <br>&gt; Swift currently evaluates stored type properties even when assigning a new value. This behavior is very subtle and can lead to objects being needlessly initialized and &quot;immediately&quot; de-initialized, as well as unwanted side effects (caused by the initialized objects).<br>&gt; <br>&gt; For example, a shared re-assignable instance that is replaced during unit test set up will initialize the &quot;real&quot; object before assigning the test replacement. <br>&gt; <br>&gt;  &lt;https://github.com/d-ronnqvist/swift-evolution#detailed-design&gt;Detailed design<br>&gt; <br>&gt; This proposal seeks to unify the lazy evaluation on assignment of stored type properties (static) and lazy stored properties (lazy var) so that the value being replaced isn&#39;t evaluated (the current behavior of lazy stored properties). <br>&gt; <br>&gt; However, it seeks to keep their respective behaviors and guarantees regarding multithreaded simultaneous access:<br>&gt; <br>&gt; From the The Swift Programming Language (Swift 2.2) &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID254&gt; regarding lazy stored properties: <br>&gt; <br>&gt; If a property marked with the lazy modifier is accessed by multiple threads simultaneously and the property has not yet been initialized, there is no guarantee that the property will be initialized only once.<br>&gt; and regarding stored type properties:<br>&gt; <br>&gt; Stored type properties are lazily initialized on their first access. They are guaranteed to be initialized only once, even when accessed by multiple threads simultaneously, and they do not need to be marked with the lazy modifier.<br>&gt; No changes to the syntax is proposed. <br>&gt; <br>&gt; This provides a more consistent lazy evaluation behavior, and fixes a (small) source of potential, subtle bugs.<br>&gt; <br>&gt;  &lt;https://github.com/d-ronnqvist/swift-evolution#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This proposal changes the lazy evaluation of stored type properties when assigning a new value. <br>&gt; <br>&gt; Any code that is relying on this effect would break in subtle ways. This is hard to detect and migrate, but hopefully very rare (and to the best of my knowledge the behavior that code would be relying upon is undocumented).<br>&gt; <br>&gt;  &lt;https://github.com/d-ronnqvist/swift-evolution#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; One alternative is to be consistent with the stored type properties and always evaluate the initial value, even when re-assigning it. However, this version doesn&#39;t address the subtle bugs that can arise from this behavior.<br>&gt; <br>&gt; Another alternative is to leave the the respective behaviors as is and mention their differences in The Swift Programming Language guide. This might still be the most viable alternative in case the current behavior is a consequence of their respective implementations with regards to multithreaded access.<br>&gt; <br>&gt;  &lt;https://github.com/d-ronnqvist/swift-evolution#rationale&gt;Rationale<br>&gt; <br>&gt; On [Date], the core team decided to (TBD) this proposal. When the core team makes a decision regarding this proposal, their rationale for the decision will be written here.<br>&gt; <br>&gt; <br>&gt; <br>&gt; 8 apr. 2016 kl. 18:50 skrev Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; Yes, IMO it really looks strange.<br>&gt;&gt; Just checked:<br>&gt;&gt; <br>&gt;&gt;    class Foo {<br>&gt;&gt;        static var test = &quot;test&quot;<br>&gt;&gt; <br>&gt;&gt;        static var bar: String = {<br>&gt;&gt;            print(&quot;static&quot;)<br>&gt;&gt;            return &quot;Default&quot;<br>&gt;&gt;        }()<br>&gt;&gt; <br>&gt;&gt;        lazy var baz: String = {<br>&gt;&gt;            print(&quot;lazy&quot;)<br>&gt;&gt;            return &quot;Lazy&quot;<br>&gt;&gt;        }()<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;    print(&quot;1&quot;)<br>&gt;&gt;    print(Foo.test)<br>&gt;&gt;    print(&quot;2&quot;)<br>&gt;&gt;    Foo.bar = &quot;Set&quot;<br>&gt;&gt;    print(&quot;3&quot;)<br>&gt;&gt;    let foo = Foo()<br>&gt;&gt;    foo.baz = &quot;Set&quot;<br>&gt;&gt;    print(&quot;4&quot;)<br>&gt;&gt; <br>&gt;&gt; we have :<br>&gt;&gt; 1<br>&gt;&gt; test<br>&gt;&gt; 2<br>&gt;&gt; static<br>&gt;&gt; 3<br>&gt;&gt; 4<br>&gt;&gt; <br>&gt;&gt; I strongly believe as static property is lazy by definition, it must not be evaluated at all when we set it. This is something that &quot;lazyness&quot; promises to us - that it will be called/calculated ONLY when we ask for this. So in my opinion this is bug/issue and should be fixed/changed in Swift 3.0.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On 08.04.2016 10:36, David Rönnqvist via swift-evolution wrote:<br>&gt;&gt;&gt; I noticed a difference between how static and lazy variables evaluate closures and thought that it was a bug:<br>&gt;&gt;&gt; https://bugs.swift.org/browse/SR-1178 &lt;https://bugs.swift.org/browse/SR-1178&gt;<br>&gt;&gt;&gt; but apparently it’s not.<br>&gt;&gt; &gt; ...<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/9f294234/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Discussion] Difference between static and lazy variables regarding evaluation of closure</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 31, 2016 at 04:00:00pm</p></header><div class="content"><p>David, I personally see all 3 of your copies of proposal in list ;-)<br>+1 from me for this proposal. It removes inconsistency and removes <br>unexpected behavior. Known that static stored property is lazy(I&#39;d like to <br>require `lazy` keyword for static stored properties to highlight that <br>fact), I believe no one really expects that it will be evaluated on <br>assignment. Current behavior looks like a bug for me.<br></p><p>On 31.05.2016 16:32, David Rönnqvist wrote:<br>&gt; With the risk of this showing up 3 times in the mailing list (I posted it<br>&gt; as a new topic, but it didn&#39;t seem to show up).<br>&gt;<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Discussion] Difference between static and lazy variables regarding evaluation of closure</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 31, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi David,<br></p><p>I personally think that the behavior of static variables is correct. It may look like an abuse, but until we get a better support for singletons, something like this is quite a common pattern IMHO:<br></p><p>public private(set) static var currentSession: Session? = { <br>	let session = ... // Read stored session.<br>	if session.isExpired {<br>		session.clearCache()<br>		session.invalidateToken()<br>		return nil<br>	}<br>	<br>	return session<br>}()<br></p><p>- it is convenient to do some global initialization as well - it is guaranteed to be run only once and you may need to e.g. invalidate the session when reading it (expired, invalid, ...).<br></p><p>On the other hand, when it&#39;s an instance member (lazy var), this kind of initialization should be done in the initializer - there are currently no initializers for the metatype (unless you inherit from NSObject and override +initialize).<br></p><p>That said, I agree that the behavior is inconsistent, but I&#39;d approach it from the other side - I&#39;d vote for always executing the closure for lazy evaluation.<br></p><p>Your proposal would break a lot of existing code without any warning and would introduce very hard to catch bugs.<br></p><p>Charlie<br></p><p><br>&gt; On May 31, 2016, at 3:32 PM, David Rönnqvist via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; With the risk of this showing up 3 times in the mailing list (I posted it as a new topic, but it didn&#39;t seem to show up).<br>&gt; <br>&gt; <br>&gt; Several weeks ago I posted that I was confused by the differences between how static variables and lazy variables evaluated (or - as I would expect - didn’t evaluate) when initially assigned with a different value. It didn’t result in any discussion, but I encountered it again and decided to draft a proposal hoping that there will be some discussion around it. The draft is available here: https://github.com/d-ronnqvist/swift-evolution/blob/master/proposals/0000-static-var-lazy-behavior.md &lt;https://github.com/d-ronnqvist/swift-evolution/blob/master/proposals/0000-static-var-lazy-behavior.md&gt;<br>&gt; <br>&gt; Please let me know what you think, and if you believe this is something that’s worth pursuing.<br>&gt; <br>&gt; - David<br>&gt; <br>&gt; <br>&gt; Lazy evaluation when assigning static variables<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt; Author(s): David Rönnqvist &lt;https://github.com/d-ronnqvist&gt;<br>&gt; Status: Awaiting review &lt;https://github.com/d-ronnqvist/swift-evolution#rationale&gt;<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/d-ronnqvist/swift-evolution#introduction&gt;Introduction<br>&gt; <br>&gt; Both stored type properties (static) and lazy stored properties (lazy var) are lazily initialized. However, they have different initialization behavior in that stored type properties evaluate even when assigning them a new value.<br>&gt; <br>&gt; The following code will print &quot;static&quot;, but not &quot;lazy&quot;:<br>&gt; <br>&gt; class Foo {<br>&gt;     static var bar: String = {<br>&gt;         print(&quot;static&quot;)<br>&gt;         return &quot;Default&quot;<br>&gt;     }()<br>&gt; <br>&gt;     lazy var baz: String = {<br>&gt;         print(&quot;lazy&quot;)<br>&gt;         return &quot;Lazy&quot;<br>&gt;     }()<br>&gt; }<br>&gt; <br>&gt; Foo.bar = &quot;Set&quot; // this evaluates the initial value of `bar` before setting a new value<br>&gt; <br>&gt; let foo = Foo()<br>&gt; foo.baz = &quot;Set&quot; // this doesn&#39;t evaluate `baz` before setting a new value<br>&gt; Swift-evolution thread: [Discussion] Difference between static and lazy variables regarding evaluation of closure &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14086&gt;<br>&gt;  &lt;https://github.com/d-ronnqvist/swift-evolution#motivation&gt;Motivation<br>&gt; <br>&gt; Swift currently evaluates stored type properties even when assigning a new value. This behavior is very subtle and can lead to objects being needlessly initialized and &quot;immediately&quot; de-initialized, as well as unwanted side effects (caused by the initialized objects).<br>&gt; <br>&gt; For example, a shared re-assignable instance that is replaced during unit test set up will initialize the &quot;real&quot; object before assigning the test replacement. <br>&gt; <br>&gt;  &lt;https://github.com/d-ronnqvist/swift-evolution#detailed-design&gt;Detailed design<br>&gt; <br>&gt; This proposal seeks to unify the lazy evaluation on assignment of stored type properties (static) and lazy stored properties (lazy var) so that the value being replaced isn&#39;t evaluated (the current behavior of lazy stored properties). <br>&gt; <br>&gt; However, it seeks to keep their respective behaviors and guarantees regarding multithreaded simultaneous access:<br>&gt; <br>&gt; From the The Swift Programming Language (Swift 2.2) &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID254&gt; regarding lazy stored properties: <br>&gt; <br>&gt; If a property marked with the lazy modifier is accessed by multiple threads simultaneously and the property has not yet been initialized, there is no guarantee that the property will be initialized only once.<br>&gt; and regarding stored type properties:<br>&gt; <br>&gt; Stored type properties are lazily initialized on their first access. They are guaranteed to be initialized only once, even when accessed by multiple threads simultaneously, and they do not need to be marked with the lazy modifier.<br>&gt; No changes to the syntax is proposed. <br>&gt; <br>&gt; This provides a more consistent lazy evaluation behavior, and fixes a (small) source of potential, subtle bugs.<br>&gt; <br>&gt;  &lt;https://github.com/d-ronnqvist/swift-evolution#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This proposal changes the lazy evaluation of stored type properties when assigning a new value. <br>&gt; <br>&gt; Any code that is relying on this effect would break in subtle ways. This is hard to detect and migrate, but hopefully very rare (and to the best of my knowledge the behavior that code would be relying upon is undocumented).<br>&gt; <br>&gt;  &lt;https://github.com/d-ronnqvist/swift-evolution#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; One alternative is to be consistent with the stored type properties and always evaluate the initial value, even when re-assigning it. However, this version doesn&#39;t address the subtle bugs that can arise from this behavior.<br>&gt; <br>&gt; Another alternative is to leave the the respective behaviors as is and mention their differences in The Swift Programming Language guide. This might still be the most viable alternative in case the current behavior is a consequence of their respective implementations with regards to multithreaded access.<br>&gt; <br>&gt;  &lt;https://github.com/d-ronnqvist/swift-evolution#rationale&gt;Rationale<br>&gt; <br>&gt; On [Date], the core team decided to (TBD) this proposal. When the core team makes a decision regarding this proposal, their rationale for the decision will be written here.<br>&gt; <br>&gt; <br>&gt; <br>&gt; 8 apr. 2016 kl. 18:50 skrev Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; Yes, IMO it really looks strange.<br>&gt;&gt; Just checked:<br>&gt;&gt; <br>&gt;&gt;    class Foo {<br>&gt;&gt;        static var test = &quot;test&quot;<br>&gt;&gt; <br>&gt;&gt;        static var bar: String = {<br>&gt;&gt;            print(&quot;static&quot;)<br>&gt;&gt;            return &quot;Default&quot;<br>&gt;&gt;        }()<br>&gt;&gt; <br>&gt;&gt;        lazy var baz: String = {<br>&gt;&gt;            print(&quot;lazy&quot;)<br>&gt;&gt;            return &quot;Lazy&quot;<br>&gt;&gt;        }()<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;    print(&quot;1&quot;)<br>&gt;&gt;    print(Foo.test)<br>&gt;&gt;    print(&quot;2&quot;)<br>&gt;&gt;    Foo.bar = &quot;Set&quot;<br>&gt;&gt;    print(&quot;3&quot;)<br>&gt;&gt;    let foo = Foo()<br>&gt;&gt;    foo.baz = &quot;Set&quot;<br>&gt;&gt;    print(&quot;4&quot;)<br>&gt;&gt; <br>&gt;&gt; we have :<br>&gt;&gt; 1<br>&gt;&gt; test<br>&gt;&gt; 2<br>&gt;&gt; static<br>&gt;&gt; 3<br>&gt;&gt; 4<br>&gt;&gt; <br>&gt;&gt; I strongly believe as static property is lazy by definition, it must not be evaluated at all when we set it. This is something that &quot;lazyness&quot; promises to us - that it will be called/calculated ONLY when we ask for this. So in my opinion this is bug/issue and should be fixed/changed in Swift 3.0.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On 08.04.2016 10:36, David Rönnqvist via swift-evolution wrote:<br>&gt;&gt;&gt; I noticed a difference between how static and lazy variables evaluate closures and thought that it was a bug:<br>&gt;&gt;&gt; https://bugs.swift.org/browse/SR-1178 &lt;https://bugs.swift.org/browse/SR-1178&gt;<br>&gt;&gt;&gt; but apparently it’s not.<br>&gt;&gt; &gt; ...<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/53dde934/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Discussion] Difference between static and lazy variables regarding evaluation of closure</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 31, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 6:32 AM, David Rönnqvist via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Lazy evaluation when assigning static variables<br>&gt; <br>&gt;  &lt;https://github.com/d-ronnqvist/swift-evolution#introduction&gt;Introduction<br>&gt; <br>&gt; Both stored type properties (static) and lazy stored properties (lazy var) are lazily initialized. However, they have different initialization behavior in that stored type properties evaluate even when assigning them a new value.<br>&gt; <br>&gt; The following code will print &quot;static&quot;, but not &quot;lazy&quot;:<br>&gt; <br>&gt; class Foo {<br>&gt;     static var bar: String = {<br>&gt;         print(&quot;static&quot;)<br>&gt;         return &quot;Default&quot;<br>&gt;     }()<br>&gt; <br>&gt;     lazy var baz: String = {<br>&gt;         print(&quot;lazy&quot;)<br>&gt;         return &quot;Lazy&quot;<br>&gt;     }()<br>&gt; }<br>&gt; <br>&gt; Foo.bar = &quot;Set&quot; // this evaluates the initial value of `bar` before setting a new value<br>&gt; <br>&gt; let foo = Foo()<br>&gt; foo.baz = &quot;Set&quot; // this doesn&#39;t evaluate `baz` before setting a new value<br>This seems like a step in the right direction, but may not big a step far enough.  Keep in mind that “static” and global variables are quite different than lazy variables, both in terms of implementation and behavior but also in terms of planned future direction.<br></p><p>“lazy” is almost certainly to be replaced by property behaviors in the future, making them a library defined feature whose behavior can be changed arbitrarily, and can hopefully have useful additional functionality like a “reset()” method added to them.  Global variables are currently not like that: their behavior is defined by compiler magic instead of by property semantics.<br></p><p>If the goal was to remove magic from the compiler, then a possible direction would be to do something like:<br></p><p>1) Introduce a new declmodifier named something like “atomiclazy”.<br>2) Disallow global and static variables, unless they are explicitly marked atomiclazy (compiler would provide a fixit hint to suggest this).<br>3) Replace the atomiclazy magic with a property behavior when they exist.<br></p><p>In this model, you’d presumably have the choice about atomiclazy or lazy when setting up either a static or a local property.<br></p><p>-Chris<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/4325d260/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Discussion] Difference between static and lazy variables regarding evaluation of closure</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>May 31, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; 31 maj 2016 kl. 21:37 skrev Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt; <br>&gt;&gt; On May 31, 2016, at 6:32 AM, David Rönnqvist via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Lazy evaluation when assigning static variables<br>&gt;&gt; Introduction<br>&gt;&gt; Both stored type properties (static) and lazy stored properties (lazy var) are lazily initialized. However, they have different initialization behavior in that stored type properties evaluate even when assigning them a new value.<br>&gt;&gt; <br>&gt;&gt; The following code will print &quot;static&quot;, but not &quot;lazy&quot;:<br>&gt;&gt; <br>&gt;&gt; class Foo {<br>&gt;&gt;     static var bar: String = {<br>&gt;&gt;         print(&quot;static&quot;)<br>&gt;&gt;         return &quot;Default&quot;<br>&gt;&gt;     }()<br>&gt;&gt; <br>&gt;&gt;     lazy var baz: String = {<br>&gt;&gt;         print(&quot;lazy&quot;)<br>&gt;&gt;         return &quot;Lazy&quot;<br>&gt;&gt;     }()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Foo.bar = &quot;Set&quot; // this evaluates the initial value of `bar` before setting a new value<br>&gt;&gt; <br>&gt;&gt; let foo = Foo()<br>&gt;&gt; foo.baz = &quot;Set&quot; // this doesn&#39;t evaluate `baz` before setting a new value<br>&gt; This seems like a step in the right direction, but may not big a step far enough.  Keep in mind that “static” and global variables are quite different than lazy variables, both in terms of implementation and behavior but also in terms of planned future direction.<br>&gt; <br>&gt; “lazy” is almost certainly to be replaced by property behaviors in the future, making them a library defined feature whose behavior can be changed arbitrarily, and can hopefully have useful additional functionality like a “reset()” method added to them.  Global variables are currently not like that: their behavior is defined by compiler magic instead of by property semantics.<br>&gt; <br>&gt; If the goal was to remove magic from the compiler, then a possible direction would be to do something like:<br>&gt; <br>&gt; 1) Introduce a new declmodifier named something like “atomiclazy”.<br>&gt; 2) Disallow global and static variables, unless they are explicitly marked atomiclazy (compiler would provide a fixit hint to suggest this).<br>&gt; 3) Replace the atomiclazy magic with a property behavior when they exist.<br>&gt; <br>&gt; In this model, you’d presumably have the choice about atomiclazy or lazy when setting up either a static or a local property.<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>Did I understand it correctly that, under such a proposal, there would be no compiler magic for global properties and instead both global, type, and instance properties would be controlled by property behaviors (or lazy/atomiclazy until they are replaced by property behaviors)?<br></p><p>`lazy` having he current a behavior of lazy properties (no threading guarantees, not evaluating on assignment),<br>`atomiclazy` having the current behavior of static properties (guaranteed to only evaluate once when accessed from multiple threads, evaluating even on assignment)<br></p><p>- David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/983f0310/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Discussion] Difference between static and lazy variables regarding evaluation of closure</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 31, 2016 at 11:00:00pm</p></header><div class="content"><p>On 31.05.2016 22:37, Chris Lattner wrote:<br>&gt; 1) Introduce a new declmodifier named something like “atomiclazy”.<br>&gt; 2) Disallow global and static variables, unless they are explicitly marked<br>&gt; atomiclazy (compiler would provide a fixit hint to suggest this).<br>&gt; 3) Replace the atomiclazy magic with a property behavior when they exist.<br>&gt;<br>&gt; In this model, you’d presumably have the choice about atomiclazy or lazy<br>&gt; when setting up either a static or a local property.<br></p><p>OK, I like this direction. I.e. instead of changing current behavior of <br>static/global variables, we require explicit decoration for them with <br>`atomiclazy` and so their behavior becomes self-documented and it is clear <br>from definition that this behavior is different than just `lazy`. One can&#39;t <br>expect that `atomiclazy` is the same as `lazy`.<br></p><p>This appends some complexity to the language to syntax but also add clarity <br>and self-documentation to behavior of defined static/global variables.<br></p><p>As I understand, we need this `atomiclazy` only if static variable has <br>initialization block like here:<br></p><p>class A {<br>     static atomiclazy var p : Int = {10}()<br>}<br></p><p>but this will not require atomiclazy :<br></p><p>class A {<br>     static var p = 10<br>}<br></p><p>Opinions on this?<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Discussion] Difference between static and lazy variables regarding evaluation of closure</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 31, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 12:37 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On May 31, 2016, at 6:32 AM, David Rönnqvist via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Lazy evaluation when assigning static variables<br>&gt;&gt; <br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Both stored type properties (static) and lazy stored properties (lazy var) are lazily initialized. However, they have different initialization behavior in that stored type properties evaluate even when assigning them a new value.<br>&gt;&gt; <br>&gt;&gt; The following code will print &quot;static&quot;, but not &quot;lazy&quot;:<br>&gt;&gt; <br>&gt;&gt; class<br>&gt;&gt;  Foo {<br>&gt;&gt;     <br>&gt;&gt; static var bar: String =<br>&gt;&gt;  {<br>&gt;&gt;         <br>&gt;&gt; print(&quot;static&quot;<br>&gt;&gt; )<br>&gt;&gt;         <br>&gt;&gt; return &quot;Default&quot;<br>&gt;&gt; <br>&gt;&gt;     }()<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; lazy var baz: String =<br>&gt;&gt;  {<br>&gt;&gt;         <br>&gt;&gt; print(&quot;lazy&quot;<br>&gt;&gt; )<br>&gt;&gt;         <br>&gt;&gt; return &quot;Lazy&quot;<br>&gt;&gt; <br>&gt;&gt;     }()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Foo<br>&gt;&gt; .bar = &quot;Set&quot; // this evaluates the initial value of `bar` before setting a new value<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; let foo =<br>&gt;&gt;  Foo()<br>&gt;&gt; foo<br>&gt;&gt; .baz = &quot;Set&quot; // this doesn&#39;t evaluate `baz` before setting a new value<br>&gt; This seems like a step in the right direction, but may not big a step far enough.  Keep in mind that “static” and global variables are quite different than lazy variables, both in terms of implementation and behavior but also in terms of planned future direction.<br>&gt; <br>&gt; “lazy” is almost certainly to be replaced by property behaviors in the future, making them a library defined feature whose behavior can be changed arbitrarily, and can hopefully have useful additional functionality like a “reset()” method added to them.  Global variables are currently not like that: their behavior is defined by compiler magic instead of by property semantics.<br>&gt; <br>&gt; If the goal was to remove magic from the compiler, then a possible direction would be to do something like:<br>&gt; <br>&gt; 1) Introduce a new declmodifier named something like “atomiclazy”.<br>&gt; 2) Disallow global and static variables, unless they are explicitly marked atomiclazy (compiler would provide a fixit hint to suggest this).<br>&gt; 3) Replace the atomiclazy magic with a property behavior when they exist.<br></p><p>This doesn&#39;t make sense. This &quot;magic&quot; is the only sensible way to initialize a global that requires dynamic initialization. Even with property behaviors, we would need to lazily apply the behavior&#39;s initialization logic to get the property into its initial state. Nonatomic lazy would be a misoptimization—it&#39;s hard to beat dispatch_once at its own game.<br></p><p>-Joe<br></p><p>&gt; In this model, you’d presumably have the choice about atomiclazy or lazy when setting up either a static or a local property.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Discussion] Difference between static and lazy variables regarding evaluation of closure</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 31, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 6:20 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; If the goal was to remove magic from the compiler, then a possible direction would be to do something like:<br>&gt;&gt; <br>&gt;&gt; 1) Introduce a new declmodifier named something like “atomiclazy”.<br>&gt;&gt; 2) Disallow global and static variables, unless they are explicitly marked atomiclazy (compiler would provide a fixit hint to suggest this).<br>&gt;&gt; 3) Replace the atomiclazy magic with a property behavior when they exist.<br>&gt; <br>&gt; This doesn&#39;t make sense. This &quot;magic&quot; is the only sensible way to initialize a global that requires dynamic initialization. Even with property behaviors, we would need to lazily apply the behavior&#39;s initialization logic to get the property into its initial state. Nonatomic lazy would be a misoptimization—it&#39;s hard to beat dispatch_once at its own game.<br></p><p>Why couldn’t a &quot;sufficiently advanced&quot; property behavior provide the same static initialization guarantees (e.g. its initialization is statically known) for its stored property, and then use dispatch_once as its implementation?  The compiler doesn’t know anything magic here.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Discussion] Difference between static and lazy variables regarding evaluation of closure</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 31, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 5:54 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On May 31, 2016, at 6:20 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; If the goal was to remove magic from the compiler, then a possible direction would be to do something like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) Introduce a new declmodifier named something like “atomiclazy”.<br>&gt;&gt;&gt; 2) Disallow global and static variables, unless they are explicitly marked atomiclazy (compiler would provide a fixit hint to suggest this).<br>&gt;&gt;&gt; 3) Replace the atomiclazy magic with a property behavior when they exist.<br>&gt;&gt; <br>&gt;&gt; This doesn&#39;t make sense. This &quot;magic&quot; is the only sensible way to initialize a global that requires dynamic initialization. Even with property behaviors, we would need to lazily apply the behavior&#39;s initialization logic to get the property into its initial state. Nonatomic lazy would be a misoptimization—it&#39;s hard to beat dispatch_once at its own game.<br>&gt; <br>&gt; Why couldn’t a &quot;sufficiently advanced&quot; property behavior provide the same static initialization guarantees (e.g. its initialization is statically known) for its stored property, and then use dispatch_once as its implementation?  The compiler doesn’t know anything magic here.<br></p><p>There&#39;s quite a bit of magic about global initialization—it knows it can hoist and fold initialization checks, and how to turn effectively constant initializations into static initializations and avoid the laziness altogether. dispatch_once furthermore only works for global initializations, since its token is magic and must be statically initialized to zero at process start. Since our existing global initialization implementation only works for globals, and does the right thing for 99% of globals, this seems like foolish generalization to me, punishing the common case and opening opportunity for user mistakes for no gain.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
