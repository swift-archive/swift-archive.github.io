<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>Emitting redundant protocol conformances to support type lookup</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>January  8, 2016 at 07:00:00pm</p></header><div class="content"><p>In the fix for [SR-381] (links at end) we implement an API for looking up classes by name by searching the protocol conformance table. The initial consumer of this is NSClassFromString() as used by NSKeyedUnarchiver in Foundation.<br></p><p>The limitation of this approach is that only classes that explicitly conform to protocols can be resolved. We’ll work around this in Foundation by having subclasses that otherwise inherit their protocol conformance explicitly conform to a dummy protocol. However, this behaviour is confusing and would be nice to fix.<br></p><p>One approach I’ve been playing with is for classes always to have an explicit conformance to AnyObject (at least, if they don’t explicitly conform to anything else). (I have a bit of a hacky patch to implement this but it’s failing at link time as there’s no symbol for “_TMps9AnyObject”.)<br></p><p>Before I proceed further down this path – is this an approach worth pursuing or would it be better not to abuse the conformance table for name lookups long term?<br></p><p>— Luke<br></p><p>https://bugs.swift.org/browse/SR-381 &lt;https://bugs.swift.org/browse/SR-381&gt;<br>https://github.com/apple/swift/pull/834/files &lt;https://github.com/apple/swift/pull/834/files&gt;<br></p><p>--<br>www.lukehoward.com<br>soundcloud.com/lukehoward<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160108/9182330b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Emitting redundant protocol conformances to support type lookup</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>January  8, 2016 at 06:00:00pm</p></header><div class="content"><p>According to Swift docs on AnyObject,<br></p><p>The protocol to which all classes implicitly conform.<br></p><p>​So it is not ​<br>an explicit conformance.<br>​<br></p><p>​http://swiftdoc.org/v2.1/protocol/AnyObject/<br></p><p><br>z<br>​haoxin​<br></p><p>On Fri, Jan 8, 2016 at 4:50 PM, Luke Howard via swift-dev &lt;<br>swift-dev at swift.org&gt; wrote:<br></p><p>&gt; In the fix for [SR-381] (links at end) we implement an API for looking up<br>&gt; classes by name by searching the protocol conformance table. The initial<br>&gt; consumer of this is NSClassFromString() as used by NSKeyedUnarchiver in<br>&gt; Foundation.<br>&gt;<br>&gt; The limitation of this approach is that only classes that explicitly<br>&gt; conform to protocols can be resolved. We’ll work around this in Foundation<br>&gt; by having subclasses that otherwise inherit their protocol conformance<br>&gt; explicitly conform to a dummy protocol. However, this behaviour is<br>&gt; confusing and would be nice to fix.<br>&gt;<br>&gt; One approach I’ve been playing with is for classes always to have an<br>&gt; explicit conformance to AnyObject (at least, if they don’t explicitly<br>&gt; conform to anything else). (I have a bit of a hacky patch to implement this<br>&gt; but it’s failing at link time as there’s no symbol for “_TMps9AnyObject”.)<br>&gt;<br>&gt; Before I proceed further down this path – is this an approach worth<br>&gt; pursuing or would it be better not to abuse the conformance table for name<br>&gt; lookups long term?<br>&gt;<br>&gt; — Luke<br>&gt;<br>&gt; https://bugs.swift.org/browse/SR-381<br>&gt; https://github.com/apple/swift/pull/834/files<br>&gt;<br>&gt; --<br>&gt; www.lukehoward.com<br>&gt; soundcloud.com/lukehoward<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt;<br></p><p><br>-- <br></p><p>Owen Zhao<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160108/43e6333f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>Emitting redundant protocol conformances to support type lookup</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>January  8, 2016 at 09:00:00pm</p></header><div class="content"><p>Right, the point was to make it explicit so as to force a protocol conformance table entry to be emitted.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 8 Jan 2016, at 21:09, 肇鑫 &lt;owenzx at gmail.com&gt; wrote:<br>&gt; <br>&gt; According to Swift docs on AnyObject,<br>&gt;&gt; The protocol to which all classes implicitly conform.<br>&gt; ​So it is not ​an explicit conformance.​<br>&gt; <br>&gt; ​http://swiftdoc.org/v2.1/protocol/AnyObject/<br>&gt; <br>&gt; z​haoxin​<br>&gt; <br>&gt;&gt; On Fri, Jan 8, 2016 at 4:50 PM, Luke Howard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; In the fix for [SR-381] (links at end) we implement an API for looking up classes by name by searching the protocol conformance table. The initial consumer of this is NSClassFromString() as used by NSKeyedUnarchiver in Foundation.<br>&gt;&gt; <br>&gt;&gt; The limitation of this approach is that only classes that explicitly conform to protocols can be resolved. We’ll work around this in Foundation by having subclasses that otherwise inherit their protocol conformance explicitly conform to a dummy protocol. However, this behaviour is confusing and would be nice to fix.<br>&gt;&gt; <br>&gt;&gt; One approach I’ve been playing with is for classes always to have an explicit conformance to AnyObject (at least, if they don’t explicitly conform to anything else). (I have a bit of a hacky patch to implement this but it’s failing at link time as there’s no symbol for “_TMps9AnyObject”.)<br>&gt;&gt; <br>&gt;&gt; Before I proceed further down this path – is this an approach worth pursuing or would it be better not to abuse the conformance table for name lookups long term?<br>&gt;&gt; <br>&gt;&gt; — Luke<br>&gt;&gt; <br>&gt;&gt; https://bugs.swift.org/browse/SR-381<br>&gt;&gt; https://github.com/apple/swift/pull/834/files<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; www.lukehoward.com<br>&gt;&gt; soundcloud.com/lukehoward<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; <br>&gt; Owen Zhao<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160108/96f488e1/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>Emitting redundant protocol conformances to support type lookup</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>January  9, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; The limitation of this approach is that only classes that explicitly conform to protocols can be resolved. We’ll work around this in Foundation by having subclasses that otherwise inherit their protocol conformance explicitly conform to a dummy protocol. However, this behaviour is confusing and would be nice to fix.<br></p><p>Sorry “we’ll work around this” sounds a bit presumptuous – what I meant was “it can be worked around”. :-)<br></p><p>&gt; One approach I’ve been playing with is for classes always to have an explicit conformance to AnyObject (at least, if they don’t explicitly conform to anything else). (I have a bit of a hacky patch to implement this but it’s failing at link time as there’s no symbol for “_TMps9AnyObject”.)<br></p><p>Having IRGenModule::emitProtocolConformances() special case AnyObject to emit a zero reference solves the linkage issue. (RelativeIndirectablePointer will then return a bogus pointer, but maybe a Flag in the conformance record could be used to indicate null.)<br></p><p>This approach means the protocol conformance tables could get very large, but it has a fairly low impact to the compiler and runtime. An alternative might be to emit explicit entries only for classes that inherit from, say, NSObjectProtocol or NSCoding, and don’t conform to anything explicitly. Or classes could be marked as resolvable-by-name with some magic attribute (however this runs counter the goal of source code portability between Darwin and other platforms).<br></p><p>— Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Emitting redundant protocol conformances to support type lookup</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January  8, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 6:40 AM, Luke Howard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; The limitation of this approach is that only classes that explicitly conform to protocols can be resolved. We’ll work around this in Foundation by having subclasses that otherwise inherit their protocol conformance explicitly conform to a dummy protocol. However, this behaviour is confusing and would be nice to fix.<br>&gt; <br>&gt; Sorry “we’ll work around this” sounds a bit presumptuous – what I meant was “it can be worked around”. :-)<br>&gt; <br>&gt;&gt; One approach I’ve been playing with is for classes always to have an explicit conformance to AnyObject (at least, if they don’t explicitly conform to anything else). (I have a bit of a hacky patch to implement this but it’s failing at link time as there’s no symbol for “_TMps9AnyObject”.)<br>&gt; <br>&gt; Having IRGenModule::emitProtocolConformances() special case AnyObject to emit a zero reference solves the linkage issue. (RelativeIndirectablePointer will then return a bogus pointer, but maybe a Flag in the conformance record could be used to indicate null.)<br>&gt; <br>&gt; This approach means the protocol conformance tables could get very large, but it has a fairly low impact to the compiler and runtime. An alternative might be to emit explicit entries only for classes that inherit from, say, NSObjectProtocol or NSCoding, and don’t conform to anything explicitly. Or classes could be marked as resolvable-by-name with some magic attribute (however this runs counter the goal of source code portability between Darwin and other platforms).<br></p><p>I’m pretty opposed to wasting a bunch of space in the binary on formal protocol conformances that can be easy rederived by just checking whether the conforming type is a class type.  AnyObject is a special case in the compiler; it makes sense for it to be a special case in the runtime conformance checking routines.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Emitting redundant protocol conformances to support type lookup</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 9:09 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 8, 2016, at 6:40 AM, Luke Howard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; The limitation of this approach is that only classes that explicitly conform to protocols can be resolved. We’ll work around this in Foundation by having subclasses that otherwise inherit their protocol conformance explicitly conform to a dummy protocol. However, this behaviour is confusing and would be nice to fix.<br>&gt;&gt; <br>&gt;&gt; Sorry “we’ll work around this” sounds a bit presumptuous – what I meant was “it can be worked around”. :-)<br>&gt;&gt; <br>&gt;&gt;&gt; One approach I’ve been playing with is for classes always to have an explicit conformance to AnyObject (at least, if they don’t explicitly conform to anything else). (I have a bit of a hacky patch to implement this but it’s failing at link time as there’s no symbol for “_TMps9AnyObject”.)<br>&gt;&gt; <br>&gt;&gt; Having IRGenModule::emitProtocolConformances() special case AnyObject to emit a zero reference solves the linkage issue. (RelativeIndirectablePointer will then return a bogus pointer, but maybe a Flag in the conformance record could be used to indicate null.)<br>&gt;&gt; <br>&gt;&gt; This approach means the protocol conformance tables could get very large, but it has a fairly low impact to the compiler and runtime. An alternative might be to emit explicit entries only for classes that inherit from, say, NSObjectProtocol or NSCoding, and don’t conform to anything explicitly. Or classes could be marked as resolvable-by-name with some magic attribute (however this runs counter the goal of source code portability between Darwin and other platforms).<br>&gt; <br>&gt; I’m pretty opposed to wasting a bunch of space in the binary on formal protocol conformances that can be easy rederived by just checking whether the conforming type is a class type.  AnyObject is a special case in the compiler; it makes sense for it to be a special case in the runtime conformance checking routines.<br></p><p>Yeah, there&#39;s no reason to inject explicit AnyObject conformances. We could introduce a separate table in the image for all of the types in the image, or maybe just the types that aren&#39;t already involved in a conformance.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160108/7f72abb3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>Emitting redundant protocol conformances to support type lookup</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>January  9, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; Yeah, there&#39;s no reason to inject explicit AnyObject conformances. We could introduce a separate table in the image for all of the types in the image, or maybe just the types that aren&#39;t already involved in a conformance.<br></p><p>Cool, I’ll look at that then.<br></p><p>— Luke<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160109/c27c0b3e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>Emitting redundant protocol conformances to support type lookup</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>January  9, 2016 at 11:00:00am</p></header><div class="content"><p>So would one define a putative TypeMetadataRecord that is identical to a ProtocolConformanceRecord but only contains the metadata reference (and reference type discriminant)?<br></p><p>Is emitNominalMetadataRef() the right place to create (not emit) these records?<br></p><p>— Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>Emitting redundant protocol conformances to support type lookup</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>January  9, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 9 Jan 2016, at 11:25 AM, Luke Howard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Is emitNominalMetadataRef() the right place to create (not emit) these records?<br></p><p>Whoops, that emits references not definitions, seems like IRGenModule::emitXXX() is better.<br></p><p>— Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>Emitting redundant protocol conformances to support type lookup</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>January 10, 2016 at 10:00:00pm</p></header><div class="content"><p>I made an experimental patch to IRGen to emit a table of type metadata, independent of the protocol conformance table.<br></p><p>The entry format is a subset of a protocol conformance record:<br></p><p>struct TypeMetadataRecord {<br>private:<br>  // Some description of the type that is resolvable at runtime.<br>  union {<br>    /// A direct reference to the metadata.<br>    RelativeIndirectablePointer&lt;Metadata&gt; DirectType;<br>    <br>    /// An indirect reference to the metadata.<br>    RelativeIndirectablePointer&lt;const ClassMetadata *&gt; IndirectClass;<br>  };<br></p><p>  /// Flags describing the type metadata record.<br>  TypeMetadataRecordFlags Flags;<br>}<br></p><p>Otherwise the implementation is pretty similar. They are emitted in irgen::emitXXXMetadata. Mappings for generic types are at runtime when swift_getGenericMetadata() is called.<br></p><p>It seems to work OK and removes the limitation that the conformance table approach had, where one could only resolve the names of types with explicit protocol conformances.<br></p><p>Haven’t tested on Linux yet.<br></p><p>— Luke<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160110/52c8751e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>Emitting redundant protocol conformances to support type lookup</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>January 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 10 Jan 2016, at 10:37 PM, Luke Howard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; It seems to work OK and removes the limitation that the conformance table approach had, where one could only resolve the names of types with explicit protocol conformances.<br>&gt; <br>&gt; Haven’t tested on Linux yet.<br></p><p>Tested on Linux &amp; also updated to avoid emitting type metadata records when there is already a protocol conformance record for that type.<br></p><p>— Luke<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160111/63855616/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Emitting redundant protocol conformances to support type lookup</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 10, 2016, at 3:37 AM, Luke Howard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I made an experimental patch to IRGen to emit a table of type metadata, independent of the protocol conformance table.<br>&gt; <br>&gt; The entry format is a subset of a protocol conformance record:<br>&gt; <br>&gt; struct TypeMetadataRecord {<br>&gt; private:<br>&gt;   // Some description of the type that is resolvable at runtime.<br>&gt;   union {<br>&gt;     /// A direct reference to the metadata.<br>&gt;     RelativeIndirectablePointer&lt;Metadata&gt; DirectType;<br>&gt;     <br>&gt;     /// An indirect reference to the metadata.<br>&gt;     RelativeIndirectablePointer&lt;const ClassMetadata *&gt; IndirectClass;<br>&gt;   };<br>&gt; <br>&gt;   /// Flags describing the type metadata record.<br>&gt;   TypeMetadataRecordFlags Flags;<br>&gt; }<br>&gt; <br>&gt; Otherwise the implementation is pretty similar. They are emitted in irgen::emitXXXMetadata. Mappings for generic types are at runtime when swift_getGenericMetadata() is called.<br>&gt; <br>&gt; It seems to work OK and removes the limitation that the conformance table approach had, where one could only resolve the names of types with explicit protocol conformances.<br></p><p>Cool. We should also emit references to generic metadata pattern from this table. None of these pointers needs to be indirectable, since they&#39;ll always refer to types declared within the current object file.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160111/2f172c90/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>Emitting redundant protocol conformances to support type lookup</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>January 13, 2016 at 02:00:00pm</p></header><div class="content"><p>Would it be possible to extend GenericParameterDescriptor to include a tail-emplaced set of references to ProtocolDescriptors for any parameter type constraints that require witness tables? This would be useful plumbing for a future API that can dynamically instantiate generic types.<br></p><p>See:<br></p><p>https://github.com/lhoward/swift/blob/SR-381/include/swift/Runtime/Metadata.h#L1199 &lt;https://github.com/lhoward/swift/blob/SR-381/include/swift/Runtime/Metadata.h#L1199&gt;<br></p><p>https://github.com/lhoward/swift/blob/SR-381/stdlib/public/runtime/MetadataLookup.cpp#L338 &lt;https://github.com/lhoward/swift/blob/SR-381/stdlib/public/runtime/MetadataLookup.cpp#L338&gt;<br></p><p>— Luke<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160113/d0ef3552/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>Emitting redundant protocol conformances to support type lookup</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>January 13, 2016 at 06:00:00pm</p></header><div class="content"><p>NB – presently the Protocols list is at the very end of GenericParameterDescriptor but it’s cleaner (if ABI disruptive) to put nest it inside Parameter.<br></p><p>&gt; On 13 Jan 2016, at 2:46 PM, Luke Howard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Would it be possible to extend GenericParameterDescriptor to include a tail-emplaced set of references to ProtocolDescriptors for any parameter type constraints that require witness tables? This would be useful plumbing for a future API that can dynamically instantiate generic types.<br>&gt; <br>&gt; See:<br>&gt; <br>&gt; https://github.com/lhoward/swift/blob/SR-381/include/swift/Runtime/Metadata.h#L1199 &lt;https://github.com/lhoward/swift/blob/SR-381/include/swift/Runtime/Metadata.h#L1199&gt;<br>&gt; <br>&gt; https://github.com/lhoward/swift/blob/SR-381/stdlib/public/runtime/MetadataLookup.cpp#L338 &lt;https://github.com/lhoward/swift/blob/SR-381/stdlib/public/runtime/MetadataLookup.cpp#L338&gt;<br>&gt; <br>&gt; — Luke<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>--<br>www.lukehoward.com<br>soundcloud.com/lukehoward<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160113/ae01a205/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>Emitting redundant protocol conformances to support type lookup</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>January 13, 2016 at 06:00:00pm</p></header><div class="content"><p>Also, what’s the best way of doing alignment when emitting C structs from IRGen?<br></p><p>For now I added this to ConstantBuilderBase: <br></p><p>    void alignToWordBoundary() {<br>      NextOffset.roundUpToAlignment(IGM.getPointerAlignment());<br>    }<br></p><p>— Luke<br></p><p>&gt; On 13 Jan 2016, at 6:18 PM, Luke Howard &lt;lukeh at padl.com&gt; wrote:<br>&gt; <br>&gt; NB – presently the Protocols list is at the very end of GenericParameterDescriptor but it’s cleaner (if ABI disruptive) to put nest it inside Parameter.<br>&gt; <br>&gt;&gt; On 13 Jan 2016, at 2:46 PM, Luke Howard via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Would it be possible to extend GenericParameterDescriptor to include a tail-emplaced set of references to ProtocolDescriptors for any parameter type constraints that require witness tables? This would be useful plumbing for a future API that can dynamically instantiate generic types.<br>&gt;&gt; <br>&gt;&gt; See:<br>&gt;&gt; <br>&gt;&gt; https://github.com/lhoward/swift/blob/SR-381/include/swift/Runtime/Metadata.h#L1199 &lt;https://github.com/lhoward/swift/blob/SR-381/include/swift/Runtime/Metadata.h#L1199&gt;<br>&gt;&gt; <br>&gt;&gt; https://github.com/lhoward/swift/blob/SR-381/stdlib/public/runtime/MetadataLookup.cpp#L338 &lt;https://github.com/lhoward/swift/blob/SR-381/stdlib/public/runtime/MetadataLookup.cpp#L338&gt;<br>&gt;&gt; <br>&gt;&gt; — Luke<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br>&gt; --<br>&gt; www.lukehoward.com &lt;http://www.lukehoward.com/&gt;<br>&gt; soundcloud.com/lukehoward<br>&gt; <br></p><p>--<br>www.lukehoward.com<br>soundcloud.com/lukehoward<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160113/3e629f21/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Emitting redundant protocol conformances to support type lookup</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 13, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 12, 2016, at 11:37 PM, Luke Howard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Also, what’s the best way of doing alignment when emitting C structs from IRGen?<br>&gt; <br>&gt; For now I added this to ConstantBuilderBase: <br>&gt; <br>&gt;     void alignToWordBoundary() {<br>&gt;       NextOffset.roundUpToAlignment(IGM.getPointerAlignment());<br>&gt;     }<br></p><p>Why do you need to do this?<br></p><p>-Joe<br></p><p>&gt; — Luke<br>&gt; <br>&gt;&gt; On 13 Jan 2016, at 6:18 PM, Luke Howard &lt;lukeh at padl.com &lt;mailto:lukeh at padl.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; NB – presently the Protocols list is at the very end of GenericParameterDescriptor but it’s cleaner (if ABI disruptive) to put nest it inside Parameter.<br>&gt;&gt; <br>&gt;&gt;&gt; On 13 Jan 2016, at 2:46 PM, Luke Howard via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would it be possible to extend GenericParameterDescriptor to include a tail-emplaced set of references to ProtocolDescriptors for any parameter type constraints that require witness tables? This would be useful plumbing for a future API that can dynamically instantiate generic types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; See:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/lhoward/swift/blob/SR-381/include/swift/Runtime/Metadata.h#L1199 &lt;https://github.com/lhoward/swift/blob/SR-381/include/swift/Runtime/Metadata.h#L1199&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/lhoward/swift/blob/SR-381/stdlib/public/runtime/MetadataLookup.cpp#L338 &lt;https://github.com/lhoward/swift/blob/SR-381/stdlib/public/runtime/MetadataLookup.cpp#L338&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; — Luke<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; www.lukehoward.com &lt;http://www.lukehoward.com/&gt;<br>&gt;&gt; soundcloud.com/lukehoward &lt;http://soundcloud.com/lukehoward&gt;<br>&gt; <br>&gt; --<br>&gt; www.lukehoward.com &lt;http://www.lukehoward.com/&gt;<br>&gt; soundcloud.com/lukehoward &lt;http://soundcloud.com/lukehoward&gt;<br>&gt;  _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160113/2647e9cd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>Emitting redundant protocol conformances to support type lookup</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>January 14, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 14 Jan 2016, at 4:31 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 12, 2016, at 11:37 PM, Luke Howard via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Also, what’s the best way of doing alignment when emitting C structs from IRGen?<br>&gt;&gt; <br>&gt;&gt; For now I added this to ConstantBuilderBase: <br>&gt;&gt; <br>&gt;&gt;     void alignToWordBoundary() {<br>&gt;&gt;       NextOffset = NextOffset.roundUpToAlignment(IGM.getPointerAlignment());<br>&gt;&gt;     }<br>&gt; <br>&gt; Why do you need to do this?<br></p><p>Emitting this:<br></p><p>struct GenericParameterDescriptor {<br>  uint32_t Offset;<br>  uint32_t NumParams;<br>  uint32_t NumPrimaryParams;<br>  <br>  /// A type parameter.<br>  struct Parameter {<br>    /// The number of protocol witness tables required by this type parameter.<br>    size_t NumWitnessTables;<br>    /// The protocols required by this type parameter. If NumWitnessTables is<br>    /// zero, this is absent.<br>    ProtocolDescriptor *Protocols[1];<br>  };<br></p><p>  /// The parameter descriptors are in a tail-emplaced array of NumParams<br>  /// elements. Because Parameters are variable length, use getParameterAt()<br>  /// to access them.<br>  Parameter Parameters[1];<br>}<br></p><p>needed to align the start of Parameters correctly (and also Protocols but I changed NumWitnessTables to a size_t for now to make that simpler). But perhaps there’s a way to get LLVM to do the layout for you, I feel I’m doing something wrong here.<br></p><p>— Luke<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160114/2a985c10/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Emitting redundant protocol conformances to support type lookup</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 13, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 2:08 PM, Luke Howard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; On 14 Jan 2016, at 4:31 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 12, 2016, at 11:37 PM, Luke Howard via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, what’s the best way of doing alignment when emitting C structs from IRGen?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For now I added this to ConstantBuilderBase: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     void alignToWordBoundary() {<br>&gt;&gt;&gt;       NextOffset = NextOffset.roundUpToAlignment(IGM.getPointerAlignment());<br>&gt;&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; Why do you need to do this?<br>&gt; <br>&gt; Emitting this:<br>&gt; <br>&gt; struct GenericParameterDescriptor {<br>&gt;   uint32_t Offset;<br>&gt;   uint32_t NumParams;<br>&gt;   uint32_t NumPrimaryParams;<br>&gt;   <br>&gt;   /// A type parameter.<br>&gt;   struct Parameter {<br>&gt;     /// The number of protocol witness tables required by this type parameter.<br>&gt;     size_t NumWitnessTables;<br>&gt;     /// The protocols required by this type parameter. If NumWitnessTables is<br>&gt;     /// zero, this is absent.<br>&gt;     ProtocolDescriptor *Protocols[1];<br>&gt;   };<br>&gt; <br>&gt;   /// The parameter descriptors are in a tail-emplaced array of NumParams<br>&gt;   /// elements. Because Parameters are variable length, use getParameterAt()<br>&gt;   /// to access them.<br>&gt;   Parameter Parameters[1];<br>&gt; }<br>&gt; <br>&gt; needed to align the start of Parameters correctly (and also Protocols but I changed NumWitnessTables to a size_t for now to make that simpler). But perhaps there’s a way to get LLVM to do the layout for you, I feel I’m doing something wrong here.<br></p><p>You should use a relative reference here instead of an absolute pointer.  We really, really don’t want relocations in reflective metadata. <br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160113/2afdcbbf/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Emitting redundant protocol conformances to support type lookup</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 13, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 12, 2016, at 7:46 PM, Luke Howard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Would it be possible to extend GenericParameterDescriptor to include a tail-emplaced set of references to ProtocolDescriptors for any parameter type constraints that require witness tables? This would be useful plumbing for a future API that can dynamically instantiate generic types.<br>&gt; <br>&gt; See:<br>&gt; <br>&gt; https://github.com/lhoward/swift/blob/SR-381/include/swift/Runtime/Metadata.h#L1199 &lt;https://github.com/lhoward/swift/blob/SR-381/include/swift/Runtime/Metadata.h#L1199&gt;<br>&gt; <br>&gt; https://github.com/lhoward/swift/blob/SR-381/stdlib/public/runtime/MetadataLookup.cpp#L338 &lt;https://github.com/lhoward/swift/blob/SR-381/stdlib/public/runtime/MetadataLookup.cpp#L338&gt;<br>That&#39;s something to consider. However, we will be systematically revamping these metadata structures soon, so I don&#39;t think there&#39;s much benefit to incrementally changing what we have.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160113/ca3d32d5/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>Emitting redundant protocol conformances to support type lookup</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>January 15, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 12 Jan 2016, at 5:21 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; Cool. We should also emit references to generic metadata pattern from this table. None of these pointers needs to be indirectable, since they&#39;ll always refer to types declared within the current object file.<br></p><p>Based on your most recent request I’ve completely removed the generic type record support out of the SR-381 branch. But if you want I can just separate out the runtime changes and leave the compiler changes in.<br></p><p>No-generic – https://github.com/apple/swift/pull/834/files &lt;https://github.com/apple/swift/pull/834/files&gt;<br>Generic – https://github.com/apple/swift/pull/959/files &lt;https://github.com/apple/swift/pull/959/files&gt;<br></p><p>— Luke<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160115/f9b93bc8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
