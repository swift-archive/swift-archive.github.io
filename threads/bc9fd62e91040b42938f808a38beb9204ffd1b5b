<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>ExistentialMetatypeType assertion failure on Linux</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 30, 2015 at 04:00:00pm</p></header><div class="content"><p>I’m seeing an assertion failure when I try to compile the following on Linux:<br></p><p>	typealias TypeMetadataAccessor = @convention(c) () -&gt; AnyClass?<br></p><p>The assertion failing is:<br></p><p>    assert(getASTContext().LangOpts.EnableObjCInterop ||<br>           *repr != MetatypeRepresentation::ObjC);<br></p><p>in ExistentialMetatypeType::ExistentialMetatypeType(). Commenting it out and the code compiles and works.<br></p><p>Can someone that understands the compiler suggest the correct fix?<br></p><p>— Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>ExistentialMetatypeType assertion failure on Linux</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 30, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 29, 2015, at 9:04 PM, Luke Howard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m seeing an assertion failure when I try to compile the following on Linux:<br>&gt; <br>&gt; 	typealias TypeMetadataAccessor = @convention(c) () -&gt; AnyClass?<br>&gt; <br>&gt; The assertion failing is:<br>&gt; <br>&gt;    assert(getASTContext().LangOpts.EnableObjCInterop ||<br>&gt;           *repr != MetatypeRepresentation::ObjC);<br>&gt; <br>&gt; in ExistentialMetatypeType::ExistentialMetatypeType(). Commenting it out and the code compiles and works.<br>&gt; <br>&gt; Can someone that understands the compiler suggest the correct fix?<br></p><p>It looks like you&#39;re trying to poke at private runtime metadata structures; please don&#39;t do that. What are you trying to do?<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>ExistentialMetatypeType assertion failure on Linux</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 30, 2015 at 10:00:00am</p></header><div class="content"><p>That is the asset in the compiler that is being hit when the code unsafeBitCasts to a c function.<br></p><p>typealias TypeMetadataAccessor = @convention(c) () -&gt; AnyClass?<br>let accessor = unsafeBitCast(symbol, TypeMetadataAccessor.self) // &lt;— this causes the compiler to assert there.<br></p><p>&gt; On Dec 30, 2015, at 10:03 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 29, 2015, at 9:04 PM, Luke Howard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m seeing an assertion failure when I try to compile the following on Linux:<br>&gt;&gt; <br>&gt;&gt; 	typealias TypeMetadataAccessor = @convention(c) () -&gt; AnyClass?<br>&gt;&gt; <br>&gt;&gt; The assertion failing is:<br>&gt;&gt; <br>&gt;&gt;   assert(getASTContext().LangOpts.EnableObjCInterop ||<br>&gt;&gt;          *repr != MetatypeRepresentation::ObjC);<br>&gt;&gt; <br>&gt;&gt; in ExistentialMetatypeType::ExistentialMetatypeType(). Commenting it out and the code compiles and works.<br>&gt;&gt; <br>&gt;&gt; Can someone that understands the compiler suggest the correct fix?<br>&gt; <br>&gt; It looks like you&#39;re trying to poke at private runtime metadata structures; please don&#39;t do that. What are you trying to do?<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>ExistentialMetatypeType assertion failure on Linux</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 30, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 10:05 AM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; That is the asset in the compiler that is being hit when the code unsafeBitCasts to a c function.<br>&gt; <br>&gt; typealias TypeMetadataAccessor = @convention(c) () -&gt; AnyClass?<br>&gt; let accessor = unsafeBitCast(symbol, TypeMetadataAccessor.self) // &lt;— this causes the compiler to assert there.<br></p><p>Under the ObjC runtime model, C and ObjC APIs represent class metatypes as pointers to their ObjC class representation, but that distinction doesn&#39;t matter in non-ObjC interop. This is easy to fix, but I&#39;ll reiterate that type metadata accessors are something you almost certainly have no business directly interacting with. What are you trying to do?<br></p><p>-Joe<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>ExistentialMetatypeType assertion failure on Linux</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 31, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On 31 Dec 2015, at 5:03 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 29, 2015, at 9:04 PM, Luke Howard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m seeing an assertion failure when I try to compile the following on Linux:<br>&gt;&gt; <br>&gt;&gt; 	typealias TypeMetadataAccessor = @convention(c) () -&gt; AnyClass?<br>&gt;&gt; <br>&gt;&gt; The assertion failing is:<br>&gt;&gt; <br>&gt;&gt;   assert(getASTContext().LangOpts.EnableObjCInterop ||<br>&gt;&gt;          *repr != MetatypeRepresentation::ObjC);<br>&gt;&gt; <br>&gt;&gt; in ExistentialMetatypeType::ExistentialMetatypeType(). Commenting it out and the code compiles and works.<br>&gt;&gt; <br>&gt;&gt; Can someone that understands the compiler suggest the correct fix?<br>&gt; <br>&gt; It looks like you&#39;re trying to poke at private runtime metadata structures; please don&#39;t do that. What are you trying to do?<br></p><p>Per our exchange yesterday – implement NSStringFromClass() heuristics for NSKeyedArchiver<br></p><p>A better solution would be to provide a proposed API/patch to the runtime but I was just trying to get the NSCoding branch testable on Linux first – can’t tackle everything at once.<br></p><p>More:<br></p><p>	https://bugs.swift.org/browse/SR-381<br></p><p>— Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>ExistentialMetatypeType assertion failure on Linux</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 31, 2015 at 09:00:00am</p></header><div class="content"><p>&gt;&gt; It looks like you&#39;re trying to poke at private runtime metadata structures; please don&#39;t do that. What are you trying to do?<br>&gt; <br>&gt; Per our exchange yesterday – implement NSStringFromClass() heuristics for NSKeyedArchiver<br></p><p>Sorry I mean NSClassFromString(). I thought indirecting the lookup through the metadata accessor was at least a little bit less bad than accessing it directly. :)<br></p><p>— Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>ExistentialMetatypeType assertion failure on Linux</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 30, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 2:41 PM, Luke Howard &lt;lukeh at padl.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; It looks like you&#39;re trying to poke at private runtime metadata structures; please don&#39;t do that. What are you trying to do?<br>&gt;&gt; <br>&gt;&gt; Per our exchange yesterday – implement NSStringFromClass() heuristics for NSKeyedArchiver<br>&gt; <br>&gt; Sorry I mean NSClassFromString(). I thought indirecting the lookup through the metadata accessor was at least a little bit less bad than accessing it directly. :)<br></p><p>If you&#39;re experimenting privately that&#39;s OK, but I&#39;d prefer to get the runtime functionality in place before committing anything. We already have our hands full trying to clean up and stabilize the standard library/runtime interfaces.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>ExistentialMetatypeType assertion failure on Linux</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 30, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 3:21 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 30, 2015, at 2:41 PM, Luke Howard &lt;lukeh at padl.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; It looks like you&#39;re trying to poke at private runtime metadata structures; please don&#39;t do that. What are you trying to do?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Per our exchange yesterday – implement NSStringFromClass() heuristics for NSKeyedArchiver<br>&gt;&gt; <br>&gt;&gt; Sorry I mean NSClassFromString(). I thought indirecting the lookup through the metadata accessor was at least a little bit less bad than accessing it directly. :)<br>&gt; <br>&gt; If you&#39;re experimenting privately that&#39;s OK, but I&#39;d prefer to get the runtime functionality in place before committing anything. We already have our hands full trying to clean up and stabilize the standard library/runtime interfaces.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p><br>Yep and that is why I am holding off on merging this just yet until we can get something up and rolling from the stdlib to support this.<br>For now we could just limit these to the list of hand coded class to string conversions and omit the NSStringFromClass/NSClassFromString transform; that way we give the stdlib a bit of time to get back on their feet from the break and get this code in.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>ExistentialMetatypeType assertion failure on Linux</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 31, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On 31 Dec 2015, at 10:24 AM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; Yep and that is why I am holding off on merging this just yet until we can get something up and rolling from the stdlib to support this.<br>&gt; For now we could just limit these to the list of hand coded class to string conversions and omit the NSStringFromClass/NSClassFromString transform; that way we give the stdlib a bit of time to get back on their feet from the break and get this code in.<br></p><p>Your call; I know perfect is the enemy of good enough, but I’m definitely interested in helping get something in stdlib once we decide on what to do re: mangling etc.<br></p><p>— Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>ExistentialMetatypeType assertion failure on Linux</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 30, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 3:55 PM, Luke Howard &lt;lukeh at padl.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 31 Dec 2015, at 10:24 AM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yep and that is why I am holding off on merging this just yet until we can get something up and rolling from the stdlib to support this.<br>&gt;&gt; For now we could just limit these to the list of hand coded class to string conversions and omit the NSStringFromClass/NSClassFromString transform; that way we give the stdlib a bit of time to get back on their feet from the break and get this code in.<br>&gt; <br>&gt; Your call; I know perfect is the enemy of good enough, but I’m definitely interested in helping get something in stdlib once we decide on what to do re: mangling etc.<br>&gt; <br>&gt; — Luke<br></p><p>I really want to merge in the rest of the coders; so lets go ahead and omit the mangling stuff and leave it just as the Foundation classes . That will be a huge win in my book, it gives us something that is testable and functional enough to do some pretty impressive demonstrations of archiving.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>ExistentialMetatypeType assertion failure on Linux</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 31, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; I really want to merge in the rest of the coders; so lets go ahead and omit the mangling stuff and leave it just as the Foundation classes . That will be a huge win in my book, it gives us something that is testable and functional enough to do some pretty impressive demonstrations of archiving.<br></p><p>OK, the version I’ve pushed now removes the code that was poking into runtime structures but still uses dlopen()/the metadata accessor for NSClassFromString(). Tests verify on OS X and Linux (with compiler fix).<br></p><p>If you want to change this further to use a static mapping table, go for it, but I’d rather focus my time on getting the appropriate API into stdlib.<br></p><p>— Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>ExistentialMetatypeType assertion failure on Linux</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 31, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On 31 Dec 2015, at 11:25 AM, Luke Howard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I really want to merge in the rest of the coders; so lets go ahead and omit the mangling stuff and leave it just as the Foundation classes . That will be a huge win in my book, it gives us something that is testable and functional enough to do some pretty impressive demonstrations of archiving.<br>&gt; <br>&gt; OK, the version I’ve pushed now removes the code that was poking into runtime structures but still uses dlopen()/the metadata accessor for NSClassFromString(). Tests verify on OS X and Linux (with compiler fix).<br>&gt; <br>&gt; If you want to change this further to use a static mapping table, go for it, but I’d rather focus my time on getting the appropriate API into stdlib.<br></p><p>As a compromise how about a:<br></p><p>* swift_getTypeByName() API that only takes demangled names<br>* NSClassFromString()/NSStringFromClass() remain internal and hard fail with nested classes/generics<br>* We decide what to do about nested class interop later (is changing the Darwin behaviour something that would even be on the table?)<br></p><p>— Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>ExistentialMetatypeType assertion failure on Linux</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 30, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 6:57 PM, Luke Howard &lt;lukeh at padl.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 31 Dec 2015, at 11:25 AM, Luke Howard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I really want to merge in the rest of the coders; so lets go ahead and omit the mangling stuff and leave it just as the Foundation classes . That will be a huge win in my book, it gives us something that is testable and functional enough to do some pretty impressive demonstrations of archiving.<br>&gt;&gt; <br>&gt;&gt; OK, the version I’ve pushed now removes the code that was poking into runtime structures but still uses dlopen()/the metadata accessor for NSClassFromString(). Tests verify on OS X and Linux (with compiler fix).<br>&gt;&gt; <br>&gt;&gt; If you want to change this further to use a static mapping table, go for it, but I’d rather focus my time on getting the appropriate API into stdlib.<br>&gt; <br>&gt; As a compromise how about a:<br>&gt; <br>&gt; * swift_getTypeByName() API that only takes demangled names<br>&gt; * NSClassFromString()/NSStringFromClass() remain internal and hard fail with nested classes/generics<br>&gt; * We decide what to do about nested class interop later (is changing the Darwin behaviour something that would even be on the table?)<br>&gt; <br>&gt; — Luke<br></p><p>I think those are all pretty reasonable. The pipeline for changes is bi-directional; however it will have to get reviewed by the component owner and undergo our process to change API behavior internally. I am fairly certain that this is an edge case that hasn’t even been thought of and I would think that the rest of the Foundation team will be very apt to nail this down so we don’t have to worry about backwards compatibility problems that using the mangled name might incur in the future.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>ExistentialMetatypeType assertion failure on Linux</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 31, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On 31 Dec 2015, at 2:10 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; I think those are all pretty reasonable. The pipeline for changes is bi-directional; however it will have to get reviewed by the component owner and undergo our process to change API behavior internally. I am fairly certain that this is an edge case that hasn’t even been thought of and I would think that the rest of the Foundation team will be very apt to nail this down so we don’t have to worry about backwards compatibility problems that using the mangled name might incur in the future.<br></p><p>Right, NB the behaviour is really in libobjc’s objc_lookUpClass/class_getName.<br></p><p>— Luke<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>ExistentialMetatypeType assertion failure on Linux</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>January  1, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; I think those are all pretty reasonable. The pipeline for changes is bi-directional; however it will have to get reviewed by the component owner and undergo our process to change API behavior internally. I am fairly certain that this is an edge case that hasn’t even been thought of and I would think that the rest of the Foundation team will be very apt to nail this down so we don’t have to worry about backwards compatibility problems that using the mangled name might incur in the future.<br></p><p>If we can get _typeByName() into stdlib (taking an unmangled qualified name), then we could do mangling for nested type names in Foundation and get Darwin archive compatibility that way. It still breaks if the name mangling algorithm changes, but that may be a problem on Darwin too.<br></p><p>— Luke<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
