<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July 10, 2016 at 08:00:00pm</p></header><div class="content"><p>A quick pitch to introduce `continue` to switch statements. This would be additive and could not be considered for Swift 3.<br></p><p>-- E<br></p><p>Pitch: Introduce continue to Switch Statements<br></p><p> &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#introduction&gt;Introduction<br></p><p>This pitch completes the switch statement&#39;s control flow transfer suite by introducing continue. Doing so provides functionality that a large portion of newer developers expect from (but do not get from) fallthrough.<br></p><p> &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#motivation&gt;Motivation<br></p><p>Swift&#39;s fallthrough statement means &quot;continue by executing the code defined in the next case clause&quot;. It has at least one solid use-case, which is demonstrated in this example &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;<br>Swift Evolution discussed removing fallthrough on-list in early December &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000226.html&gt; We came to the consensus that fallthroughoffers sufficient utility to retain the feature in the language:<br></p><p> &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#the-problem-with-fallthrough&gt;The Problem with Fallthrough.<br></p><p>In Swift, fallthrough does not mean: &quot;execute this case and then continue pattern matching&quot;, which is what many naive users expect. Given the following code where x is 5, they anticipate the function to print &quot;5&quot; and then &quot;anything else&quot;. This is wrong. Swift prints &quot;5&quot; and then &quot;6&quot;.<br></p><p>func test(x : Int) {<br>    switch x {<br>    case 5:<br>        print(&quot;5&quot;)<br>        fallthrough<br>    case 6:<br>        print(&quot;6&quot;)<br>    default:<br>        print(&quot;anything else&quot;)<br>    }<br>}<br>Fallthrough is better suited for situations like the following:<br></p><p>case simple where even more subconditions hold: ... do complex things ...; fallthrough<br>case simple where subconditions hold: ... do other things ...; fallthrough<br>case simple: ... do base things ...<br>This example produces a sieve where the most restrictive conditions execute specialized code and then execute code for less restrictive conditions.<br></p><p>Fallthrough cannot be used for situations like the following example:<br></p><p>case specialized situation 1: ... code specific to situation 1 ...; fallthrough<br>case specialized situation 2: ... code specific to situation 2 ...; fallthrough<br>case specialized situation 3: ... code specific to situation 3 ...; fallthrough<br>case general: ... general code applicable as well to the three specialized situations ...<br>Those coming from C-like languages might have the insight to expect (wrongly, it should be noted) &quot;5&quot;, then &quot;6&quot;, then &quot;anything else&quot;, which is what you&#39;d get with the following flawed C-ish code, where case statements are missing break.<br></p><p>int x = 5;<br>switch (x) {<br>    case 5: NSLog(@&quot;5&quot;); // no break;<br>    case 6: NSLog(@&quot;6&quot;); // no break;<br>    default: NSLog(@&quot;anything else&quot;);<br>}<br>Swift-style switch statements are more powerful and general than C-style switch statements. While I do not endorse C-style switch statements, I do think there&#39;s a case to be made for continue, which would mean &quot;continue pattern matching&quot;. It would look like this:<br></p><p>case specialized situation 1: ... code specific to situation 1 ...; continue<br>case specialized situation 2: ... code specific to situation 2 ...; continue<br>case specialized situation 3: ... code specific to situation 3 ...; continue<br>case general: ... general code applicable as well to the three specialized situations ...<br>In this example, code that matched general might execute any of the three specialized subconditions as well but would not have to fall through each case. So if a pattern matched scenarios 1 and 3, it would execute those cases and the general case, but not scenario 2.<br></p><p> &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#the-advantages-of-continue&gt;The advantages of continue<br></p><p>If adopted, continue allows code to execute multiple matching patterns<br>It naturally reduces code redundancy where fallthrough cannot be used but code applies to multiple cases (such as the 1, 3, and general example above).<br>It uses an existing control flow transfer keyword, using it in a reasonably harmonious application that isn&#39;t that far out of step with how the keyword is used in other parts of the language.<br> &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#detailed-design&gt;Detailed Design<br></p><p>In the current design, switch statements support subset of control flow transfer:<br></p><p>control-transfer-statement → break-statement<br>control-transfer-statement → fallthrough-statement<br>control-transfer-statement → return-statement<br>control-transfer-statement → throw-statement<br>Notably missing is &quot;continue&quot;, which this proposal would adopt.<br></p><p>control-transfer-statement → continue-statement<br>The definition of continue in a switch statement would mean &quot;after executing the previous statements in this case clause, continue pattern matching the remaining cases until a match or default is found.<br></p><p>continue could either be disallowed in the final case (typically default) or could be ignored if included.<br></p><p> &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>None.<br></p><p> &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#alternatives-considered&gt;Alternatives Considered<br></p><p>Not adopting this idea<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/e4221c22/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>July 11, 2016 at 04:00:00am</p></header><div class="content"><p>There is possible impact on existing code: a switch statement inside a loop, that contains a continue.<br> <br>— Taras<br></p><p>&gt; On 11 Jul 2016, at 04:27, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A quick pitch to introduce `continue` to switch statements. This would be additive and could not be considered for Swift 3.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; Pitch: Introduce continue to Switch Statements<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#introduction&gt;Introduction<br>&gt; <br>&gt; This pitch completes the switch statement&#39;s control flow transfer suite by introducing continue. Doing so provides functionality that a large portion of newer developers expect from (but do not get from) fallthrough.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#motivation&gt;Motivation<br>&gt; <br>&gt; Swift&#39;s fallthrough statement means &quot;continue by executing the code defined in the next case clause&quot;. It has at least one solid use-case, which is demonstrated in this example &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;<br>&gt; Swift Evolution discussed removing fallthrough on-list in early December &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000226.html&gt; We came to the consensus that fallthroughoffers sufficient utility to retain the feature in the language:<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#the-problem-with-fallthrough&gt;The Problem with Fallthrough.<br>&gt; <br>&gt; In Swift, fallthrough does not mean: &quot;execute this case and then continue pattern matching&quot;, which is what many naive users expect. Given the following code where x is 5, they anticipate the function to print &quot;5&quot; and then &quot;anything else&quot;. This is wrong. Swift prints &quot;5&quot; and then &quot;6&quot;.<br>&gt; <br>&gt; func test(x : Int) {<br>&gt;     switch x {<br>&gt;     case 5:<br>&gt;         print(&quot;5&quot;)<br>&gt;         fallthrough<br>&gt;     case 6:<br>&gt;         print(&quot;6&quot;)<br>&gt;     default:<br>&gt;         print(&quot;anything else&quot;)<br>&gt;     }<br>&gt; }<br>&gt; Fallthrough is better suited for situations like the following:<br>&gt; <br>&gt; case simple where even more subconditions hold: ... do complex things ...; fallthrough<br>&gt; case simple where subconditions hold: ... do other things ...; fallthrough<br>&gt; case simple: ... do base things ...<br>&gt; This example produces a sieve where the most restrictive conditions execute specialized code and then execute code for less restrictive conditions.<br>&gt; <br>&gt; Fallthrough cannot be used for situations like the following example:<br>&gt; <br>&gt; case specialized situation 1: ... code specific to situation 1 ...; fallthrough<br>&gt; case specialized situation 2: ... code specific to situation 2 ...; fallthrough<br>&gt; case specialized situation 3: ... code specific to situation 3 ...; fallthrough<br>&gt; case general: ... general code applicable as well to the three specialized situations ...<br>&gt; Those coming from C-like languages might have the insight to expect (wrongly, it should be noted) &quot;5&quot;, then &quot;6&quot;, then &quot;anything else&quot;, which is what you&#39;d get with the following flawed C-ish code, where case statements are missing break.<br>&gt; <br>&gt; int x = 5;<br>&gt; switch (x) {<br>&gt;     case 5: NSLog(@&quot;5&quot;); // no break;<br>&gt;     case 6: NSLog(@&quot;6&quot;); // no break;<br>&gt;     default: NSLog(@&quot;anything else&quot;);<br>&gt; }<br>&gt; Swift-style switch statements are more powerful and general than C-style switch statements. While I do not endorse C-style switch statements, I do think there&#39;s a case to be made for continue, which would mean &quot;continue pattern matching&quot;. It would look like this:<br>&gt; <br>&gt; case specialized situation 1: ... code specific to situation 1 ...; continue<br>&gt; case specialized situation 2: ... code specific to situation 2 ...; continue<br>&gt; case specialized situation 3: ... code specific to situation 3 ...; continue<br>&gt; case general: ... general code applicable as well to the three specialized situations ...<br>&gt; In this example, code that matched general might execute any of the three specialized subconditions as well but would not have to fall through each case. So if a pattern matched scenarios 1 and 3, it would execute those cases and the general case, but not scenario 2.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#the-advantages-of-continue&gt;The advantages of continue<br>&gt; <br>&gt; If adopted, continue allows code to execute multiple matching patterns<br>&gt; It naturally reduces code redundancy where fallthrough cannot be used but code applies to multiple cases (such as the 1, 3, and general example above).<br>&gt; It uses an existing control flow transfer keyword, using it in a reasonably harmonious application that isn&#39;t that far out of step with how the keyword is used in other parts of the language.<br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; In the current design, switch statements support subset of control flow transfer:<br>&gt; <br>&gt; control-transfer-statement → break-statement<br>&gt; control-transfer-statement → fallthrough-statement<br>&gt; control-transfer-statement → return-statement<br>&gt; control-transfer-statement → throw-statement<br>&gt; Notably missing is &quot;continue&quot;, which this proposal would adopt.<br>&gt; <br>&gt; control-transfer-statement → continue-statement<br>&gt; The definition of continue in a switch statement would mean &quot;after executing the previous statements in this case clause, continue pattern matching the remaining cases until a match or default is found.<br>&gt; <br>&gt; continue could either be disallowed in the final case (typically default) or could be ignored if included.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; None.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; Not adopting this idea<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/13f13d81/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July 10, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jul 10, 2016, at 8:36 PM, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt; <br>&gt; There is possible impact on existing code: a switch statement inside a loop, that contains a continue.<br>&gt;  <br>&gt; — Taras<br></p><p>A switch statement within a loop may be broken by the introduction of `continue` semantics. To fix, the loop must be labeled and the `continue` must use that label to differentiate between switch continuation and loop continuation.<br></p><p>Updated gist: https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a<br></p><p>-- E<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 10, 2016 at 09:00:00pm</p></header><div class="content"><p>This is a neat idea, and I think a very sensible way to extend the<br>language. I worry only a little about the following:<br></p><p>Currently, unless preceded immediately by the keyword `fallthrough`, a<br>condition implicitly excludes all previous conditions. That is, if I write<br>`switch .. { case a: ...; case b: ...; case c: ... }`, my condition `c` is<br>really `!a &amp;&amp; !b &amp;&amp; c`. With more flexible control flow within a switch<br>statement, reasoning about what cases are matched by any particular<br>condition after the first becomes increasingly difficult.<br></p><p>On Sun, Jul 10, 2016 at 9:27 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; A quick pitch to introduce `continue` to switch statements. This would be<br>&gt; additive and could not be considered for Swift 3.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; Pitch: Introduce continue to Switch Statements<br>&gt; &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This pitch completes the switch statement&#39;s control flow transfer suite by<br>&gt; introducing continue. Doing so provides functionality that a large<br>&gt; portion of newer developers expect from (but do not get from) fallthrough.<br>&gt; &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Swift&#39;s fallthrough statement means &quot;continue by executing the code<br>&gt; defined in the next case clause&quot;. It has at least one solid use-case, which<br>&gt; is demonstrated in this example<br>&gt; &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;<br>&gt;<br>&gt; Swift Evolution discussed removing fallthrough on-list in early December<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000226.html&gt; We<br>&gt; came to the consensus that fallthroughoffers sufficient utility to retain<br>&gt; the feature in the language:<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#the-problem-with-fallthrough&gt;The<br>&gt; Problem with Fallthrough.<br>&gt;<br>&gt; In Swift, fallthrough does not mean: &quot;execute this case and then continue<br>&gt; pattern matching&quot;, which is what many naive users expect. Given the<br>&gt; following code where x is 5, they anticipate the function to print &quot;5&quot;<br>&gt; and then &quot;anything else&quot;. This is wrong. Swift prints &quot;5&quot; and then &quot;6&quot;.<br>&gt;<br>&gt; func test(x : Int) {<br>&gt;     switch x {<br>&gt;     case 5:<br>&gt;         print(&quot;5&quot;)<br>&gt;         fallthrough<br>&gt;     case 6:<br>&gt;         print(&quot;6&quot;)<br>&gt;     default:<br>&gt;         print(&quot;anything else&quot;)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Fallthrough is better suited for situations like the following:<br>&gt;<br>&gt; case simple where even more subconditions hold: ... do complex things ...; fallthrough<br>&gt; case simple where subconditions hold: ... do other things ...; fallthrough<br>&gt; case simple: ... do base things ...<br>&gt;<br>&gt; This example produces a sieve where the most restrictive conditions<br>&gt; execute specialized code and then execute code for less restrictive<br>&gt; conditions.<br>&gt;<br>&gt; Fallthrough *cannot* be used for situations like the following example:<br>&gt;<br>&gt; case specialized situation 1: ... code specific to situation 1 ...; fallthrough<br>&gt; case specialized situation 2: ... code specific to situation 2 ...; fallthrough<br>&gt; case specialized situation 3: ... code specific to situation 3 ...; fallthrough<br>&gt; case general: ... general code applicable as well to the three specialized situations ...<br>&gt;<br>&gt; Those coming from C-like languages might have the insight to expect<br>&gt; (wrongly, it should be noted) &quot;5&quot;, then &quot;6&quot;, then &quot;anything else&quot;, which is<br>&gt; what you&#39;d get with the following flawed C-ish code, where case statements<br>&gt; are missing break.<br>&gt;<br>&gt; int x = 5;<br>&gt; switch (x) {<br>&gt;     case 5: NSLog(@&quot;5&quot;); // no break;<br>&gt;     case 6: NSLog(@&quot;6&quot;); // no break;<br>&gt;     default: NSLog(@&quot;anything else&quot;);<br>&gt; }<br>&gt;<br>&gt; Swift-style switch statements are more powerful and general than C-style<br>&gt; switch statements. While I do not endorse C-style switch statements, I do<br>&gt; think there&#39;s a case to be made for continue, which would mean &quot;continue<br>&gt; pattern matching&quot;. It would look like this:<br>&gt;<br>&gt; case specialized situation 1: ... code specific to situation 1 ...; continue<br>&gt; case specialized situation 2: ... code specific to situation 2 ...; continue<br>&gt; case specialized situation 3: ... code specific to situation 3 ...; continue<br>&gt; case general: ... general code applicable as well to the three specialized situations ...<br>&gt;<br>&gt; In this example, code that matched general might execute any of the three<br>&gt; specialized subconditions as well but would not have to fall through each<br>&gt; case. So if a pattern matched scenarios 1 and 3, it would execute those<br>&gt; cases and the general case, but not scenario 2.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#the-advantages-of-continue&gt;The<br>&gt; advantages of continue<br>&gt;<br>&gt;    - If adopted, continue allows code to execute multiple matching<br>&gt;    patterns<br>&gt;    - It naturally reduces code redundancy where fallthrough cannot be<br>&gt;    used but code applies to multiple cases (such as the 1, 3, and general<br>&gt;    example above).<br>&gt;    - It uses an existing control flow transfer keyword, using it in a<br>&gt;    reasonably harmonious application that isn&#39;t that far out of step with how<br>&gt;    the keyword is used in other parts of the language.<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#detailed-design&gt;Detailed<br>&gt; Design<br>&gt;<br>&gt; In the current design, switch statements support subset of control flow<br>&gt; transfer:<br>&gt;<br>&gt; control-transfer-statement → break-statement<br>&gt; control-transfer-statement → fallthrough-statement<br>&gt; control-transfer-statement → return-statement<br>&gt; control-transfer-statement → throw-statement<br>&gt;<br>&gt; Notably missing is &quot;continue&quot;, which this proposal would adopt.<br>&gt;<br>&gt; control-transfer-statement → continue-statement<br>&gt;<br>&gt; The definition of continue in a switch statement would mean &quot;after<br>&gt; executing the previous statements in this case clause, continue pattern<br>&gt; matching the remaining cases until a match or default is found.<br>&gt;<br>&gt; continue could either be disallowed in the final case (typically default)<br>&gt; or could be ignored if included.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; None.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; Not adopting this idea<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/682d87ce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July 10, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jul 10, 2016, at 8:37 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; This is a neat idea, and I think a very sensible way to extend the language. I worry only a little about the following:<br>&gt; <br>&gt; Currently, unless preceded immediately by the keyword `fallthrough`, a condition implicitly excludes all previous conditions. That is, if I write `switch .. { case a: ...; case b: ...; case c: ... }`, my condition `c` is really `!a &amp;&amp; !b &amp;&amp; c`. With more flexible control flow within a switch statement, reasoning about what cases are matched by any particular condition after the first becomes increasingly difficult.<br></p><p>In the current Swift, absent `fallthrough`, the statement execution ends and no other statements are evaluated after the first match.<br></p><p>With `fallthrough` the current clause executes and the next clause executes, and then the statement execution ends.<br></p><p>With `continue`, the current clause executes and the switch continues searching for a matching pattern as if a pattern has not yet been matched.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 10, 2016 at 11:00:00pm</p></header><div class="content"><p>On Sun, Jul 10, 2016 at 10:48 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jul 10, 2016, at 8:37 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; This is a neat idea, and I think a very sensible way to extend the<br>&gt; language. I worry only a little about the following:<br>&gt; &gt;<br>&gt; &gt; Currently, unless preceded immediately by the keyword `fallthrough`, a<br>&gt; condition implicitly excludes all previous conditions. That is, if I write<br>&gt; `switch .. { case a: ...; case b: ...; case c: ... }`, my condition `c` is<br>&gt; really `!a &amp;&amp; !b &amp;&amp; c`. With more flexible control flow within a switch<br>&gt; statement, reasoning about what cases are matched by any particular<br>&gt; condition after the first becomes increasingly difficult.<br>&gt;<br>&gt; In the current Swift, absent `fallthrough`, the statement execution ends<br>&gt; and no other statements are evaluated after the first match.<br>&gt;<br>&gt; With `fallthrough` the current clause executes and the next clause<br>&gt; executes, and then the statement execution ends.<br>&gt;<br>&gt; With `continue`, the current clause executes and the switch continues<br>&gt; searching for a matching pattern as if a pattern has not yet been matched.<br>&gt;<br></p><p>I understand. What I&#39;m saying is that control flow becomes more difficult<br>to reason through in a scenario as follows, which is not possible currently:<br></p><p>Given patterns A, B, C, and D, suppose a value x matches A, C, and D,<br>whereas another value y matches B and D, and a third value matches B and<br>C. When evaluating x, y, or z, which statements are executed in the<br>following switch statement? How many of these reach the default case? What<br>happens if I append `fallthrough` at the end of case D? What happens if I<br>move case B after case D? (Yes, I know it is possible to figure it out [my<br>understanding of the answer to the first question is appended below], but I<br>hope you&#39;ll agree with me that this is much more difficult to decipher than<br>any switch statement that&#39;s currently possible.)<br></p><p>```<br>switch x /* or y, or z */ {<br>case A:<br>  // ...<br>  continue<br>case B:<br>  // ...<br>  if C ~= x /* or y, or z, whichever is switched over */ {<br>    continue<br>  }<br>  fallthrough<br>case C:<br>  // ...<br>  if B ~= x /* or y, or z, whichever is switched over */ {<br>    continue<br>  }<br>case D:<br>  // ...<br>default:<br>  // ...<br>}<br>```<br></p><p>[For switch x: statements in cases A and C only, not the default; for<br>switch y: statements in case B, C and D, not the default; for switch z:<br>statements in cases B and C, and in the default]<br></p><p>Finally, a really neat thing about `continue` in Swift is the ability to<br>use labels; would you propose allowing that here? If so, could I label<br>individual cases and have pattern matching resume at that case? How about<br>resuming at a previous case? It&#39;d be neat. It&#39;d also make it possible to<br>make an infinite loop out of a switch statement...<br></p><p><br>-- E<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/de4140bd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July 10, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jul 10, 2016, at 10:16 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; Given patterns A, B, C, and D, suppose a value x matches A, C, and D, whereas another value y matches B and D, and a third value matches B and C. When evaluating x, y, or z, which statements are executed in the following switch statement? How many of these reach the default case? What happens if I append `fallthrough` at the end of case D? What happens if I move case B after case D? (Yes, I know it is possible to figure it out [my understanding of the answer to the first question is appended below], but I hope you&#39;ll agree with me that this is much more difficult to decipher than any switch statement that&#39;s currently possible.)<br>&gt; <br>&gt; ```<br>&gt; switch x /* or y, or z */ {<br>&gt; case A:<br>&gt;   // ...<br>&gt;   continue<br>&gt; case B:<br>&gt;   // ...<br>&gt;   if C ~= x /* or y, or z, whichever is switched over */ {<br>&gt;     continue<br>&gt;   }<br>&gt;   fallthrough<br></p><p>I&#39;d say it would be fair to disallow continue and fallthrough to occur in the same clause<br></p><p>&gt; case C:<br>&gt;   // ...<br>&gt;   if B ~= x /* or y, or z, whichever is switched over */ {<br>&gt;     continue<br>&gt;   }<br>&gt; case D:<br>&gt;   // ...<br>&gt; default:<br>&gt;   // ...<br>&gt; }<br>&gt; ```<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/6ae769a2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 10, 2016 at 11:00:00pm</p></header><div class="content"><p>On Sun, Jul 10, 2016 at 11:21 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt; On Jul 10, 2016, at 10:16 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; Given patterns A, B, C, and D, suppose a value x matches A, C, and D,<br>&gt; whereas another value y matches B and D, and a third value matches B and<br>&gt; C. When evaluating x, y, or z, which statements are executed in the<br>&gt; following switch statement? How many of these reach the default case? What<br>&gt; happens if I append `fallthrough` at the end of case D? What happens if I<br>&gt; move case B after case D? (Yes, I know it is possible to figure it out [my<br>&gt; understanding of the answer to the first question is appended below], but I<br>&gt; hope you&#39;ll agree with me that this is much more difficult to decipher than<br>&gt; any switch statement that&#39;s currently possible.)<br>&gt;<br>&gt; ```<br>&gt; switch x /* or y, or z */ {<br>&gt; case A:<br>&gt;   // ...<br>&gt;   continue<br>&gt; case B:<br>&gt;   // ...<br>&gt;   if C ~= x /* or y, or z, whichever is switched over */ {<br>&gt;     continue<br>&gt;   }<br>&gt;   fallthrough<br>&gt;<br>&gt;<br>&gt; I&#39;d say it would be fair to disallow continue and fallthrough to occur in<br>&gt; the same clause<br>&gt;<br></p><p>Why should `fallthrough` be prohibited but implicit `break` become<br>mandatory in such a clause? If `continue` were to be implemented in this<br>context, I&#39;d want the full power of the keyword, including being allowed to<br>`continue` conditionally, `continue` with different labels, and round out<br>the case if no conditions are satisfied with either `fallthrough` or<br>`break` (or, for that matter, `return`, etc.).<br></p><p><br>&gt;<br>&gt; case C:<br>&gt;   // ...<br>&gt;   if B ~= x /* or y, or z, whichever is switched over */ {<br>&gt;     continue<br>&gt;   }<br>&gt; case D:<br>&gt;   // ...<br>&gt; default:<br>&gt;   // ...<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/e552d0c3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July 10, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jul 10, 2016, at 10:34 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Sun, Jul 10, 2016 at 11:21 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; On Jul 10, 2016, at 10:16 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; Given patterns A, B, C, and D, suppose a value x matches A, C, and D, whereas another value y matches B and D, and a third value matches B and C. When evaluating x, y, or z, which statements are executed in the following switch statement? How many of these reach the default case? What happens if I append `fallthrough` at the end of case D? What happens if I move case B after case D? (Yes, I know it is possible to figure it out [my understanding of the answer to the first question is appended below], but I hope you&#39;ll agree with me that this is much more difficult to decipher than any switch statement that&#39;s currently possible.)<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; switch x /* or y, or z */ {<br>&gt;&gt; case A:<br>&gt;&gt;   // ...<br>&gt;&gt;   continue<br>&gt;&gt; case B:<br>&gt;&gt;   // ...<br>&gt;&gt;   if C ~= x /* or y, or z, whichever is switched over */ {<br>&gt;&gt;     continue<br>&gt;&gt;   }<br>&gt;&gt;   fallthrough<br>&gt; <br>&gt; I&#39;d say it would be fair to disallow continue and fallthrough to occur in the same clause<br>&gt; <br>&gt; Why should `fallthrough` be prohibited but implicit `break` become mandatory in such a clause? If `continue` were to be implemented in this context, I&#39;d want the full power of the keyword, including being allowed to `continue` conditionally, `continue` with different labels, and round out the case if no conditions are satisfied with either `fallthrough` or `break` (or, for that matter, `return`, etc.).<br></p><p>I do not understand. `break` is already implicit unless no other code is used. <br></p><p>case something:<br>   if condition { continue }<br>   // ends here. the compiler knows not to go forward and it&#39;s not an empty clause<br>case somethingElse:<br></p><p>`fallthrough` means &quot;ignore the next case statement and execute its clause&quot;.<br></p><p>-- E<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/c260c758/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 11, 2016 at 05:00:00am</p></header><div class="content"><p>I know how it works. Why would you say that it&#39;s reasonable to prohibit<br>fallthrough when continue is used? The difference between it and break is<br>that Swift chooses the latter to be implied, and obviously we cannot<br>prohibit break.<br>On Sun, Jul 10, 2016 at 23:51 Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt; On Jul 10, 2016, at 10:34 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sun, Jul 10, 2016 at 11:21 PM, Erica Sadun &lt;erica at ericasadun.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Jul 10, 2016, at 10:16 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; Given patterns A, B, C, and D, suppose a value x matches A, C, and D,<br>&gt;&gt; whereas another value y matches B and D, and a third value matches B and<br>&gt;&gt; C. When evaluating x, y, or z, which statements are executed in the<br>&gt;&gt; following switch statement? How many of these reach the default case? What<br>&gt;&gt; happens if I append `fallthrough` at the end of case D? What happens if I<br>&gt;&gt; move case B after case D? (Yes, I know it is possible to figure it out [my<br>&gt;&gt; understanding of the answer to the first question is appended below], but I<br>&gt;&gt; hope you&#39;ll agree with me that this is much more difficult to decipher than<br>&gt;&gt; any switch statement that&#39;s currently possible.)<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; switch x /* or y, or z */ {<br>&gt;&gt; case A:<br>&gt;&gt;   // ...<br>&gt;&gt;   continue<br>&gt;&gt; case B:<br>&gt;&gt;   // ...<br>&gt;&gt;   if C ~= x /* or y, or z, whichever is switched over */ {<br>&gt;&gt;     continue<br>&gt;&gt;   }<br>&gt;&gt;   fallthrough<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;d say it would be fair to disallow continue and fallthrough to occur in<br>&gt;&gt; the same clause<br>&gt;&gt;<br>&gt;<br>&gt; Why should `fallthrough` be prohibited but implicit `break` become<br>&gt; mandatory in such a clause? If `continue` were to be implemented in this<br>&gt; context, I&#39;d want the full power of the keyword, including being allowed to<br>&gt; `continue` conditionally, `continue` with different labels, and round out<br>&gt; the case if no conditions are satisfied with either `fallthrough` or<br>&gt; `break` (or, for that matter, `return`, etc.).<br>&gt;<br>&gt;<br>&gt; I do not understand. `break` is already implicit unless no other code is<br>&gt; used.<br>&gt;<br>&gt; case something:<br>&gt;    if condition { continue }<br>&gt;    // ends here. the compiler knows not to go forward and it&#39;s not an<br>&gt; empty clause<br>&gt; case somethingElse:<br>&gt;<br>&gt; `fallthrough` means &quot;ignore the next case statement and execute its<br>&gt; clause&quot;.<br>&gt;<br>&gt; -- E<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/ff5315a1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July 10, 2016 at 11:00:00pm</p></header><div class="content"><p>Because one says &quot;consider the next case&quot; and the other says &quot;do not consider the next case&quot;<br></p><p>&gt; On Jul 10, 2016, at 11:03 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; I know how it works. Why would you say that it&#39;s reasonable to prohibit fallthrough when continue is used? The difference between it and break is that Swift chooses the latter to be implied, and obviously we cannot prohibit break.<br>&gt; On Sun, Jul 10, 2016 at 23:51 Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; On Jul 10, 2016, at 10:34 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sun, Jul 10, 2016 at 11:21 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Jul 10, 2016, at 10:16 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; Given patterns A, B, C, and D, suppose a value x matches A, C, and D, whereas another value y matches B and D, and a third value matches B and C. When evaluating x, y, or z, which statements are executed in the following switch statement? How many of these reach the default case? What happens if I append `fallthrough` at the end of case D? What happens if I move case B after case D? (Yes, I know it is possible to figure it out [my understanding of the answer to the first question is appended below], but I hope you&#39;ll agree with me that this is much more difficult to decipher than any switch statement that&#39;s currently possible.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; switch x /* or y, or z */ {<br>&gt;&gt;&gt; case A:<br>&gt;&gt;&gt;   // ...<br>&gt;&gt;&gt;   continue<br>&gt;&gt;&gt; case B:<br>&gt;&gt;&gt;   // ...<br>&gt;&gt;&gt;   if C ~= x /* or y, or z, whichever is switched over */ {<br>&gt;&gt;&gt;     continue<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   fallthrough<br>&gt;&gt; <br>&gt;&gt; I&#39;d say it would be fair to disallow continue and fallthrough to occur in the same clause<br>&gt;&gt; <br>&gt;&gt; Why should `fallthrough` be prohibited but implicit `break` become mandatory in such a clause? If `continue` were to be implemented in this context, I&#39;d want the full power of the keyword, including being allowed to `continue` conditionally, `continue` with different labels, and round out the case if no conditions are satisfied with either `fallthrough` or `break` (or, for that matter, `return`, etc.).<br>&gt; <br>&gt; I do not understand. `break` is already implicit unless no other code is used. <br>&gt; <br>&gt; case something:<br>&gt;    if condition { continue }<br>&gt;    // ends here. the compiler knows not to go forward and it&#39;s not an empty clause<br>&gt; case somethingElse:<br>&gt; <br>&gt; `fallthrough` means &quot;ignore the next case statement and execute its clause&quot;.<br>&gt; <br>&gt; -- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/88c2ac23/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 11, 2016 at 05:00:00am</p></header><div class="content"><p>Right. Both seem equally reasonable alternatives if a condition isn&#39;t<br>fulfilled where I&#39;d like to continue pattern matching. Why do you say one<br>of these would be fair to disallow?<br>On Mon, Jul 11, 2016 at 00:39 Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt; Because one says &quot;consider the next case&quot; and the other says &quot;do not<br>&gt; consider the next case&quot;<br>&gt;<br>&gt; On Jul 10, 2016, at 11:03 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; I know how it works. Why would you say that it&#39;s reasonable to prohibit<br>&gt; fallthrough when continue is used? The difference between it and break is<br>&gt; that Swift chooses the latter to be implied, and obviously we cannot<br>&gt; prohibit break.<br>&gt; On Sun, Jul 10, 2016 at 23:51 Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Jul 10, 2016, at 10:34 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sun, Jul 10, 2016 at 11:21 PM, Erica Sadun &lt;erica at ericasadun.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Jul 10, 2016, at 10:16 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; Given patterns A, B, C, and D, suppose a value x matches A, C, and D,<br>&gt;&gt;&gt; whereas another value y matches B and D, and a third value matches B and<br>&gt;&gt;&gt; C. When evaluating x, y, or z, which statements are executed in the<br>&gt;&gt;&gt; following switch statement? How many of these reach the default case? What<br>&gt;&gt;&gt; happens if I append `fallthrough` at the end of case D? What happens if I<br>&gt;&gt;&gt; move case B after case D? (Yes, I know it is possible to figure it out [my<br>&gt;&gt;&gt; understanding of the answer to the first question is appended below], but I<br>&gt;&gt;&gt; hope you&#39;ll agree with me that this is much more difficult to decipher than<br>&gt;&gt;&gt; any switch statement that&#39;s currently possible.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; switch x /* or y, or z */ {<br>&gt;&gt;&gt; case A:<br>&gt;&gt;&gt;   // ...<br>&gt;&gt;&gt;   continue<br>&gt;&gt;&gt; case B:<br>&gt;&gt;&gt;   // ...<br>&gt;&gt;&gt;   if C ~= x /* or y, or z, whichever is switched over */ {<br>&gt;&gt;&gt;     continue<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   fallthrough<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;d say it would be fair to disallow continue and fallthrough to occur<br>&gt;&gt;&gt; in the same clause<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Why should `fallthrough` be prohibited but implicit `break` become<br>&gt;&gt; mandatory in such a clause? If `continue` were to be implemented in this<br>&gt;&gt; context, I&#39;d want the full power of the keyword, including being allowed to<br>&gt;&gt; `continue` conditionally, `continue` with different labels, and round out<br>&gt;&gt; the case if no conditions are satisfied with either `fallthrough` or<br>&gt;&gt; `break` (or, for that matter, `return`, etc.).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I do not understand. `break` is already implicit unless no other code is<br>&gt;&gt; used.<br>&gt;&gt;<br>&gt;&gt; case something:<br>&gt;&gt;    if condition { continue }<br>&gt;&gt;    // ends here. the compiler knows not to go forward and it&#39;s not an<br>&gt;&gt; empty clause<br>&gt;&gt; case somethingElse:<br>&gt;&gt;<br>&gt;&gt; `fallthrough` means &quot;ignore the next case statement and execute its<br>&gt;&gt; clause&quot;.<br>&gt;&gt;<br>&gt;&gt; -- E<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/38cc8b90/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July 10, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jul 10, 2016, at 11:42 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Right. Both seem equally reasonable alternatives if a condition isn&#39;t fulfilled where I&#39;d like to continue pattern matching. Why do you say one of these would be fair to disallow?<br></p><p>I&#39;m saying pick behavior A or behavior B but don&#39;t do A &amp; B because that makes computing the possibilities unnecessarily complex and I cannot think of a single real-world use-case where one would want to do both at the same time.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 11, 2016 at 05:00:00am</p></header><div class="content"><p>I disagree. First, in both cases there&#39;s an A and a B. The two scenarios we<br>are comparing are &quot;if condition continue, else break&quot; and &quot;if condition<br>continue, else fallthrough&quot;. Both break and fallthrough are equally control<br>transfer experiments. Both of these scenarios add complexity for reasoning<br>(compare case B and case C in my example above).<br></p><p>Obviously, in code, whichever of statement A or B is first reached will<br>preclude execution of the other. But the whole point of control flow<br>statements is to provide an expressive way to branch when necessary. If we<br>agree that the complexity introduced by `continue` is worthwhile and<br>useful, then &quot;if condition continue, else fallthrough&quot; is just as<br>legitimate a use case as &quot;if condition continue, else break.&quot;<br></p><p>As such, I&#39;d conclude that I&#39;m neutral on the proposal (I could do without<br>it, but it would be intriguing and Swifty to empower the switch statement<br>further). However, if adopted I&#39;d strongly urge having all uses of continue<br>permitted. Including something like `continue case 0..&lt;2 where y &lt; z` if a<br>subsequent case is written as such, since after all cases are syntaxed like<br>labels.<br>On Mon, Jul 11, 2016 at 00:44 Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jul 10, 2016, at 11:42 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Right. Both seem equally reasonable alternatives if a condition isn&#39;t<br>&gt; fulfilled where I&#39;d like to continue pattern matching. Why do you say one<br>&gt; of these would be fair to disallow?<br>&gt;<br>&gt; I&#39;m saying pick behavior A or behavior B but don&#39;t do A &amp; B because that<br>&gt; makes computing the possibilities unnecessarily complex and I cannot think<br>&gt; of a single real-world use-case where one would want to do both at the same<br>&gt; time.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/06400500/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July 10, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jul 10, 2016, at 11:54 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; I disagree. First, in both cases there&#39;s an A and a B. The two scenarios we are comparing are &quot;if condition continue, else break&quot; and &quot;if condition continue, else fallthrough&quot;. Both break and fallthrough are equally control transfer experiments. Both of these scenarios add complexity for reasoning (compare case B and case C in my example above).<br>&gt; <br>&gt; Obviously, in code, whichever of statement A or B is first reached will preclude execution of the other. But the whole point of control flow statements is to provide an expressive way to branch when necessary. If we agree that the complexity introduced by `continue` is worthwhile and useful, then &quot;if condition continue, else fallthrough&quot; is just as legitimate a use case as &quot;if condition continue, else break.&quot;<br>&gt; <br>&gt; As such, I&#39;d conclude that I&#39;m neutral on the proposal (I could do without it, but it would be intriguing and Swifty to empower the switch statement further). However, if adopted I&#39;d strongly urge having all uses of continue permitted. Including something like `continue case 0..&lt;2 where y &lt; z` if a subsequent case is written as such, since after all cases are syntaxed like labels.<br>&gt; On Mon, Jul 11, 2016 at 00:44 Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Jul 10, 2016, at 11:42 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Right. Both seem equally reasonable alternatives if a condition isn&#39;t fulfilled where I&#39;d like to continue pattern matching. Why do you say one of these would be fair to disallow?<br>&gt; <br>&gt; I&#39;m saying pick behavior A or behavior B but don&#39;t do A &amp; B because that makes computing the possibilities unnecessarily complex and I cannot think of a single real-world use-case where one would want to do both at the same time.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br></p><p>Can you give me an example where anyone would ever want to say:<br></p><p>case something: <br>    continue<br>    fallthrough<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/824435a0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 11, 2016 at 06:00:00am</p></header><div class="content"><p>switch fourSidedShape {<br>case rhombus:<br>// do some rhombus-specific work<br>if parallelogram ~= shape { continue }<br>// do some other rhombus-specific but parallelogram-inapplicable work<br>fallthrough<br>case rhomboid:<br>// do work the slow way<br>// applies to all rhomboids including rhombuses unless parallelogram<br>/* implied break */<br>default:<br>// now we&#39;re left with parallelograms (including rectangles and squares)<br>// but in the case of non-rect parallelograms,<br>// some preparatory work has been done above<br>// do remaining work the fast way<br></p><p>}<br>On Mon, Jul 11, 2016 at 00:56 Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 10, 2016, at 11:54 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; I disagree. First, in both cases there&#39;s an A and a B. The two scenarios<br>&gt; we are comparing are &quot;if condition continue, else break&quot; and &quot;if condition<br>&gt; continue, else fallthrough&quot;. Both break and fallthrough are equally control<br>&gt; transfer experiments. Both of these scenarios add complexity for reasoning<br>&gt; (compare case B and case C in my example above).<br>&gt;<br>&gt; Obviously, in code, whichever of statement A or B is first reached will<br>&gt; preclude execution of the other. But the whole point of control flow<br>&gt; statements is to provide an expressive way to branch when necessary. If we<br>&gt; agree that the complexity introduced by `continue` is worthwhile and<br>&gt; useful, then &quot;if condition continue, else fallthrough&quot; is just as<br>&gt; legitimate a use case as &quot;if condition continue, else break.&quot;<br>&gt;<br>&gt; As such, I&#39;d conclude that I&#39;m neutral on the proposal (I could do without<br>&gt; it, but it would be intriguing and Swifty to empower the switch statement<br>&gt; further). However, if adopted I&#39;d strongly urge having all uses of continue<br>&gt; permitted. Including something like `continue case 0..&lt;2 where y &lt; z` if a<br>&gt; subsequent case is written as such, since after all cases are syntaxed like<br>&gt; labels.<br>&gt; On Mon, Jul 11, 2016 at 00:44 Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Jul 10, 2016, at 11:42 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Right. Both seem equally reasonable alternatives if a condition isn&#39;t<br>&gt;&gt; fulfilled where I&#39;d like to continue pattern matching. Why do you say one<br>&gt;&gt; of these would be fair to disallow?<br>&gt;&gt;<br>&gt;&gt; I&#39;m saying pick behavior A or behavior B but don&#39;t do A &amp; B because that<br>&gt;&gt; makes computing the possibilities unnecessarily complex and I cannot think<br>&gt;&gt; of a single real-world use-case where one would want to do both at the same<br>&gt;&gt; time.<br>&gt;&gt;<br>&gt;&gt; -- E<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt; Can you give me an example where anyone would ever want to say:<br>&gt;<br>&gt; case something:<br>&gt;     continue<br>&gt;     fallthrough<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/68a04da3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 11, 2016 at 01:00:00am</p></header><div class="content"><p>Or, less contrived, based on code I just wrote today (and refactored,<br>because this doesn&#39;t work today), given two optionals a and b:<br></p><p>```<br>let c: Foo?<br>switch (a, b) {<br>case let (x?, y?):<br>  if validate(x) &amp;&amp; validate(y) {<br>    c = x &amp; y // yes, bitwise and<br>    continue<br>  }<br>  fallthrough<br>case let (x?, nil):<br>  c = x<br>case let (nil, y?):<br>  c = y<br>case let (nil, nil):<br>  c = nil<br>  fallthrough /* or, for that matter, continue */<br>default:<br>  // other stuff here that needs to be done<br>  // unless c == x or c == y<br>}<br>```<br></p><p>On Mon, Jul 11, 2016 at 1:11 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; switch fourSidedShape {<br>&gt; case rhombus:<br>&gt; // do some rhombus-specific work<br>&gt; if parallelogram ~= shape { continue }<br>&gt; // do some other rhombus-specific but parallelogram-inapplicable work<br>&gt; fallthrough<br>&gt; case rhomboid:<br>&gt; // do work the slow way<br>&gt; // applies to all rhomboids including rhombuses unless parallelogram<br>&gt; /* implied break */<br>&gt; default:<br>&gt; // now we&#39;re left with parallelograms (including rectangles and squares)<br>&gt; // but in the case of non-rect parallelograms,<br>&gt; // some preparatory work has been done above<br>&gt; // do remaining work the fast way<br>&gt;<br>&gt; }<br>&gt; On Mon, Jul 11, 2016 at 00:56 Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 10, 2016, at 11:54 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I disagree. First, in both cases there&#39;s an A and a B. The two scenarios<br>&gt;&gt; we are comparing are &quot;if condition continue, else break&quot; and &quot;if condition<br>&gt;&gt; continue, else fallthrough&quot;. Both break and fallthrough are equally control<br>&gt;&gt; transfer experiments. Both of these scenarios add complexity for reasoning<br>&gt;&gt; (compare case B and case C in my example above).<br>&gt;&gt;<br>&gt;&gt; Obviously, in code, whichever of statement A or B is first reached will<br>&gt;&gt; preclude execution of the other. But the whole point of control flow<br>&gt;&gt; statements is to provide an expressive way to branch when necessary. If we<br>&gt;&gt; agree that the complexity introduced by `continue` is worthwhile and<br>&gt;&gt; useful, then &quot;if condition continue, else fallthrough&quot; is just as<br>&gt;&gt; legitimate a use case as &quot;if condition continue, else break.&quot;<br>&gt;&gt;<br>&gt;&gt; As such, I&#39;d conclude that I&#39;m neutral on the proposal (I could do<br>&gt;&gt; without it, but it would be intriguing and Swifty to empower the switch<br>&gt;&gt; statement further). However, if adopted I&#39;d strongly urge having all uses<br>&gt;&gt; of continue permitted. Including something like `continue case 0..&lt;2 where<br>&gt;&gt; y &lt; z` if a subsequent case is written as such, since after all cases are<br>&gt;&gt; syntaxed like labels.<br>&gt;&gt; On Mon, Jul 11, 2016 at 00:44 Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Jul 10, 2016, at 11:42 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Right. Both seem equally reasonable alternatives if a condition isn&#39;t<br>&gt;&gt;&gt; fulfilled where I&#39;d like to continue pattern matching. Why do you say one<br>&gt;&gt;&gt; of these would be fair to disallow?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m saying pick behavior A or behavior B but don&#39;t do A &amp; B because that<br>&gt;&gt;&gt; makes computing the possibilities unnecessarily complex and I cannot think<br>&gt;&gt;&gt; of a single real-world use-case where one would want to do both at the same<br>&gt;&gt;&gt; time.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; Can you give me an example where anyone would ever want to say:<br>&gt;&gt;<br>&gt;&gt; case something:<br>&gt;&gt;     continue<br>&gt;&gt;     fallthrough<br>&gt;&gt;<br>&gt;&gt; -- E<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/528011d3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July 10, 2016 at 11:00:00pm</p></header><div class="content"><p>Wouldn&#39;t that be served better by `case let (x?, y?) where validate(x) &amp;&amp;<br>validate(y)` ?<br></p><p>Jacob<br></p><p>On Sun, Jul 10, 2016 at 11:39 PM, Xiaodi Wu via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Or, less contrived, based on code I just wrote today (and refactored,<br>&gt; because this doesn&#39;t work today), given two optionals a and b:<br>&gt;<br>&gt; ```<br>&gt; let c: Foo?<br>&gt; switch (a, b) {<br>&gt; case let (x?, y?):<br>&gt;   if validate(x) &amp;&amp; validate(y) {<br>&gt;     c = x &amp; y // yes, bitwise and<br>&gt;     continue<br>&gt;   }<br>&gt;   fallthrough<br>&gt; case let (x?, nil):<br>&gt;   c = x<br>&gt; case let (nil, y?):<br>&gt;   c = y<br>&gt; case let (nil, nil):<br>&gt;   c = nil<br>&gt;   fallthrough /* or, for that matter, continue */<br>&gt; default:<br>&gt;   // other stuff here that needs to be done<br>&gt;   // unless c == x or c == y<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; On Mon, Jul 11, 2016 at 1:11 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; switch fourSidedShape {<br>&gt;&gt; case rhombus:<br>&gt;&gt; // do some rhombus-specific work<br>&gt;&gt; if parallelogram ~= shape { continue }<br>&gt;&gt; // do some other rhombus-specific but parallelogram-inapplicable work<br>&gt;&gt; fallthrough<br>&gt;&gt; case rhomboid:<br>&gt;&gt; // do work the slow way<br>&gt;&gt; // applies to all rhomboids including rhombuses unless parallelogram<br>&gt;&gt; /* implied break */<br>&gt;&gt; default:<br>&gt;&gt; // now we&#39;re left with parallelograms (including rectangles and squares)<br>&gt;&gt; // but in the case of non-rect parallelograms,<br>&gt;&gt; // some preparatory work has been done above<br>&gt;&gt; // do remaining work the fast way<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt; On Mon, Jul 11, 2016 at 00:56 Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jul 10, 2016, at 11:54 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I disagree. First, in both cases there&#39;s an A and a B. The two scenarios<br>&gt;&gt;&gt; we are comparing are &quot;if condition continue, else break&quot; and &quot;if condition<br>&gt;&gt;&gt; continue, else fallthrough&quot;. Both break and fallthrough are equally control<br>&gt;&gt;&gt; transfer experiments. Both of these scenarios add complexity for reasoning<br>&gt;&gt;&gt; (compare case B and case C in my example above).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Obviously, in code, whichever of statement A or B is first reached will<br>&gt;&gt;&gt; preclude execution of the other. But the whole point of control flow<br>&gt;&gt;&gt; statements is to provide an expressive way to branch when necessary. If we<br>&gt;&gt;&gt; agree that the complexity introduced by `continue` is worthwhile and<br>&gt;&gt;&gt; useful, then &quot;if condition continue, else fallthrough&quot; is just as<br>&gt;&gt;&gt; legitimate a use case as &quot;if condition continue, else break.&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As such, I&#39;d conclude that I&#39;m neutral on the proposal (I could do<br>&gt;&gt;&gt; without it, but it would be intriguing and Swifty to empower the switch<br>&gt;&gt;&gt; statement further). However, if adopted I&#39;d strongly urge having all uses<br>&gt;&gt;&gt; of continue permitted. Including something like `continue case 0..&lt;2 where<br>&gt;&gt;&gt; y &lt; z` if a subsequent case is written as such, since after all cases are<br>&gt;&gt;&gt; syntaxed like labels.<br>&gt;&gt;&gt; On Mon, Jul 11, 2016 at 00:44 Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On Jul 10, 2016, at 11:42 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Right. Both seem equally reasonable alternatives if a condition isn&#39;t<br>&gt;&gt;&gt;&gt; fulfilled where I&#39;d like to continue pattern matching. Why do you say one<br>&gt;&gt;&gt;&gt; of these would be fair to disallow?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;m saying pick behavior A or behavior B but don&#39;t do A &amp; B because<br>&gt;&gt;&gt;&gt; that makes computing the possibilities unnecessarily complex and I cannot<br>&gt;&gt;&gt;&gt; think of a single real-world use-case where one would want to do both at<br>&gt;&gt;&gt;&gt; the same time.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; Can you give me an example where anyone would ever want to say:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; case something:<br>&gt;&gt;&gt;     continue<br>&gt;&gt;&gt;     fallthrough<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/3f57a57a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b85275a7eb50a13a925d4ce05bb5daf7?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Remy Demarest</string> &lt;psycho.hedgehog at me.com&gt;<p>July 10, 2016 at 11:00:00pm</p></header><div class="content"><p>This is a great feature, and this is something that would allow the execution of multiple case statements that fallthrough does not currently allow. For example in today&#39;s world this is not allowed:<br></p><p>func blah(point: CGPoint) {<br>    switch (point.x, point.y) {<br>    case (let x, _) where x &gt; 10:<br>        print(&quot;\(x)&quot;)<br>        fallthrough // error &#39;fallthrough&#39; cannot transfer control to a case label that declares variables<br>    case (_, let y) where y &gt; 10:<br>        print(&quot;\(y)&quot;)<br>    case (let x, let y) where x &lt;= 10 &amp;&amp; y &lt;= 10:<br>        print(&quot;the point is too close from the border&quot;)<br>    }<br>}<br></p><p>Using continue as proposed by erica would allow both patterns at the top to be evaluated and have the ability to check x and y independently.<br></p><p>Also this raises in my opinion an interesting point. I think along this proposal it would be great to have another type of case that would only run if no other pattern could be recognized. I&#39;m not sure how to call it though.<br></p><p><br>&gt; Le 10 juil. 2016 à 19:27, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; A quick pitch to introduce `continue` to switch statements. This would be additive and could not be considered for Swift 3.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; Pitch: Introduce continue to Switch Statements<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#introduction&gt;Introduction<br>&gt; <br>&gt; This pitch completes the switch statement&#39;s control flow transfer suite by introducing continue. Doing so provides functionality that a large portion of newer developers expect from (but do not get from) fallthrough.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#motivation&gt;Motivation<br>&gt; <br>&gt; Swift&#39;s fallthrough statement means &quot;continue by executing the code defined in the next case clause&quot;. It has at least one solid use-case, which is demonstrated in this example &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;<br>&gt; Swift Evolution discussed removing fallthrough on-list in early December &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000226.html&gt; We came to the consensus that fallthroughoffers sufficient utility to retain the feature in the language:<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#the-problem-with-fallthrough&gt;The Problem with Fallthrough.<br>&gt; <br>&gt; In Swift, fallthrough does not mean: &quot;execute this case and then continue pattern matching&quot;, which is what many naive users expect. Given the following code where x is 5, they anticipate the function to print &quot;5&quot; and then &quot;anything else&quot;. This is wrong. Swift prints &quot;5&quot; and then &quot;6&quot;.<br>&gt; <br>&gt; func test(x : Int) {<br>&gt;     switch x {<br>&gt;     case 5:<br>&gt;         print(&quot;5&quot;)<br>&gt;         fallthrough<br>&gt;     case 6:<br>&gt;         print(&quot;6&quot;)<br>&gt;     default:<br>&gt;         print(&quot;anything else&quot;)<br>&gt;     }<br>&gt; }<br>&gt; Fallthrough is better suited for situations like the following:<br>&gt; <br>&gt; case simple where even more subconditions hold: ... do complex things ...; fallthrough<br>&gt; case simple where subconditions hold: ... do other things ...; fallthrough<br>&gt; case simple: ... do base things ...<br>&gt; This example produces a sieve where the most restrictive conditions execute specialized code and then execute code for less restrictive conditions.<br>&gt; <br>&gt; Fallthrough cannot be used for situations like the following example:<br>&gt; <br>&gt; case specialized situation 1: ... code specific to situation 1 ...; fallthrough<br>&gt; case specialized situation 2: ... code specific to situation 2 ...; fallthrough<br>&gt; case specialized situation 3: ... code specific to situation 3 ...; fallthrough<br>&gt; case general: ... general code applicable as well to the three specialized situations ...<br>&gt; Those coming from C-like languages might have the insight to expect (wrongly, it should be noted) &quot;5&quot;, then &quot;6&quot;, then &quot;anything else&quot;, which is what you&#39;d get with the following flawed C-ish code, where case statements are missing break.<br>&gt; <br>&gt; int x = 5;<br>&gt; switch (x) {<br>&gt;     case 5: NSLog(@&quot;5&quot;); // no break;<br>&gt;     case 6: NSLog(@&quot;6&quot;); // no break;<br>&gt;     default: NSLog(@&quot;anything else&quot;);<br>&gt; }<br>&gt; Swift-style switch statements are more powerful and general than C-style switch statements. While I do not endorse C-style switch statements, I do think there&#39;s a case to be made for continue, which would mean &quot;continue pattern matching&quot;. It would look like this:<br>&gt; <br>&gt; case specialized situation 1: ... code specific to situation 1 ...; continue<br>&gt; case specialized situation 2: ... code specific to situation 2 ...; continue<br>&gt; case specialized situation 3: ... code specific to situation 3 ...; continue<br>&gt; case general: ... general code applicable as well to the three specialized situations ...<br>&gt; In this example, code that matched general might execute any of the three specialized subconditions as well but would not have to fall through each case. So if a pattern matched scenarios 1 and 3, it would execute those cases and the general case, but not scenario 2.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#the-advantages-of-continue&gt;The advantages of continue<br>&gt; <br>&gt; If adopted, continue allows code to execute multiple matching patterns<br>&gt; It naturally reduces code redundancy where fallthrough cannot be used but code applies to multiple cases (such as the 1, 3, and general example above).<br>&gt; It uses an existing control flow transfer keyword, using it in a reasonably harmonious application that isn&#39;t that far out of step with how the keyword is used in other parts of the language.<br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; In the current design, switch statements support subset of control flow transfer:<br>&gt; <br>&gt; control-transfer-statement → break-statement<br>&gt; control-transfer-statement → fallthrough-statement<br>&gt; control-transfer-statement → return-statement<br>&gt; control-transfer-statement → throw-statement<br>&gt; Notably missing is &quot;continue&quot;, which this proposal would adopt.<br>&gt; <br>&gt; control-transfer-statement → continue-statement<br>&gt; The definition of continue in a switch statement would mean &quot;after executing the previous statements in this case clause, continue pattern matching the remaining cases until a match or default is found.<br>&gt; <br>&gt; continue could either be disallowed in the final case (typically default) or could be ignored if included.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; None.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; Not adopting this idea<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/4443b7bf/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/212199c56fae3d6b09dbf788f1c5e313?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>G B</string> &lt;g.c.b.at.work at gmail.com&gt;<p>July 11, 2016 at 12:00:00am</p></header><div class="content"><p>I like this idea.<br></p><p>Remember that `continue` can typically take an optional argument that allows a type of “goto” functionality.  Would it work to allow the `continue` target to be a labeled `case`?  This could allow for some rather sophisticated logic without needing to duplicate a lot of code and without needing to nest the switch in a loop-- especially if switching on a `var`.  <br></p><p>An `enum` and a `switch` with targeted `continues` would make for a nice, clean state machine by updating the state in the `case` and then jumping to the right point in the selection logic. The target could be, but wouldn’t need to be the top of the `switch`.<br></p><p><br></p><p>I’ve long thought that `fallthrough` should prefer a target to avoid the problems of accidentally slipping a `case` in between the `case` you’re falling out of and the `case` you’d meant to fall into.<br></p><p>I’m not sure what the right syntax would be for the target label if the `case` uses a colon for punctuation.  I suppose the label could be the `case`, but that seems verbose. <br></p><p>The ability to insert labels inside the switch would be another advantage of wrapping the `case` statements in curly brackets though.<br></p><p><br></p><p>&gt; On Jul 10, 2016, at 19:27 , Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A quick pitch to introduce `continue` to switch statements. This would be additive and could not be considered for Swift 3.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; Pitch: Introduce continue to Switch Statements<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#introduction&gt;Introduction<br>&gt; <br>&gt; This pitch completes the switch statement&#39;s control flow transfer suite by introducing continue. Doing so provides functionality that a large portion of newer developers expect from (but do not get from) fallthrough.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#motivation&gt;Motivation<br>&gt; <br>&gt; Swift&#39;s fallthrough statement means &quot;continue by executing the code defined in the next case clause&quot;. It has at least one solid use-case, which is demonstrated in this example &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;<br>&gt; Swift Evolution discussed removing fallthrough on-list in early December &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000226.html&gt; We came to the consensus that fallthroughoffers sufficient utility to retain the feature in the language:<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#the-problem-with-fallthrough&gt;The Problem with Fallthrough.<br>&gt; <br>&gt; In Swift, fallthrough does not mean: &quot;execute this case and then continue pattern matching&quot;, which is what many naive users expect. Given the following code where x is 5, they anticipate the function to print &quot;5&quot; and then &quot;anything else&quot;. This is wrong. Swift prints &quot;5&quot; and then &quot;6&quot;.<br>&gt; <br>&gt; func test(x : Int) {<br>&gt;     switch x {<br>&gt;     case 5:<br>&gt;         print(&quot;5&quot;)<br>&gt;         fallthrough<br>&gt;     case 6:<br>&gt;         print(&quot;6&quot;)<br>&gt;     default:<br>&gt;         print(&quot;anything else&quot;)<br>&gt;     }<br>&gt; }<br>&gt; Fallthrough is better suited for situations like the following:<br>&gt; <br>&gt; case simple where even more subconditions hold: ... do complex things ...; fallthrough<br>&gt; case simple where subconditions hold: ... do other things ...; fallthrough<br>&gt; case simple: ... do base things ...<br>&gt; This example produces a sieve where the most restrictive conditions execute specialized code and then execute code for less restrictive conditions.<br>&gt; <br>&gt; Fallthrough cannot be used for situations like the following example:<br>&gt; <br>&gt; case specialized situation 1: ... code specific to situation 1 ...; fallthrough<br>&gt; case specialized situation 2: ... code specific to situation 2 ...; fallthrough<br>&gt; case specialized situation 3: ... code specific to situation 3 ...; fallthrough<br>&gt; case general: ... general code applicable as well to the three specialized situations ...<br>&gt; Those coming from C-like languages might have the insight to expect (wrongly, it should be noted) &quot;5&quot;, then &quot;6&quot;, then &quot;anything else&quot;, which is what you&#39;d get with the following flawed C-ish code, where case statements are missing break.<br>&gt; <br>&gt; int x = 5;<br>&gt; switch (x) {<br>&gt;     case 5: NSLog(@&quot;5&quot;); // no break;<br>&gt;     case 6: NSLog(@&quot;6&quot;); // no break;<br>&gt;     default: NSLog(@&quot;anything else&quot;);<br>&gt; }<br>&gt; Swift-style switch statements are more powerful and general than C-style switch statements. While I do not endorse C-style switch statements, I do think there&#39;s a case to be made for continue, which would mean &quot;continue pattern matching&quot;. It would look like this:<br>&gt; <br>&gt; case specialized situation 1: ... code specific to situation 1 ...; continue<br>&gt; case specialized situation 2: ... code specific to situation 2 ...; continue<br>&gt; case specialized situation 3: ... code specific to situation 3 ...; continue<br>&gt; case general: ... general code applicable as well to the three specialized situations ...<br>&gt; In this example, code that matched general might execute any of the three specialized subconditions as well but would not have to fall through each case. So if a pattern matched scenarios 1 and 3, it would execute those cases and the general case, but not scenario 2.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#the-advantages-of-continue&gt;The advantages of continue<br>&gt; <br>&gt; If adopted, continue allows code to execute multiple matching patterns<br>&gt; It naturally reduces code redundancy where fallthrough cannot be used but code applies to multiple cases (such as the 1, 3, and general example above).<br>&gt; It uses an existing control flow transfer keyword, using it in a reasonably harmonious application that isn&#39;t that far out of step with how the keyword is used in other parts of the language.<br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; In the current design, switch statements support subset of control flow transfer:<br>&gt; <br>&gt; control-transfer-statement → break-statement<br>&gt; control-transfer-statement → fallthrough-statement<br>&gt; control-transfer-statement → return-statement<br>&gt; control-transfer-statement → throw-statement<br>&gt; Notably missing is &quot;continue&quot;, which this proposal would adopt.<br>&gt; <br>&gt; control-transfer-statement → continue-statement<br>&gt; The definition of continue in a switch statement would mean &quot;after executing the previous statements in this case clause, continue pattern matching the remaining cases until a match or default is found.<br>&gt; <br>&gt; continue could either be disallowed in the final case (typically default) or could be ignored if included.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; None.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; Not adopting this idea<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/6efc52b1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ab8ff5d36ad4f40d7905509956e5c706?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Jacopo Andrea Giola</string> &lt;swift-evolution at jacopo.giola.org&gt;<p>July 11, 2016 at 10:00:00am</p></header><div class="content"><p>Here we go again :)<br></p><p>I’m obviously supporting this proposal, like the first one we had tried to pass at the beginning of the swift evolution mailing list, even if in those times, we try to completely replace the fallthrough keyword with a new one.<br></p><p>I continue to have a draft of that proposal on gist https://gist.github.com/JGiola/f735212789bf2f697847<br></p><p>Instead of continue we put out a fallto keyword that must explicit state the case where we want to go at the end of that case, but this solution is more  clean and simple to reasoning with and use a well stated keyword used in others flow statements.<br></p><p>- Jacopo<br></p><p><br>&gt; On 11 Jul 2016, at 04:27, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A quick pitch to introduce `continue` to switch statements. This would be additive and could not be considered for Swift 3.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; Pitch: Introduce continue to Switch Statements<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#introduction&gt;Introduction<br>&gt; <br>&gt; This pitch completes the switch statement&#39;s control flow transfer suite by introducing continue. Doing so provides functionality that a large portion of newer developers expect from (but do not get from) fallthrough.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#motivation&gt;Motivation<br>&gt; <br>&gt; Swift&#39;s fallthrough statement means &quot;continue by executing the code defined in the next case clause&quot;. It has at least one solid use-case, which is demonstrated in this example &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;<br>&gt; Swift Evolution discussed removing fallthrough on-list in early December &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000226.html&gt; We came to the consensus that fallthroughoffers sufficient utility to retain the feature in the language:<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#the-problem-with-fallthrough&gt;The Problem with Fallthrough.<br>&gt; <br>&gt; In Swift, fallthrough does not mean: &quot;execute this case and then continue pattern matching&quot;, which is what many naive users expect. Given the following code where x is 5, they anticipate the function to print &quot;5&quot; and then &quot;anything else&quot;. This is wrong. Swift prints &quot;5&quot; and then &quot;6&quot;.<br>&gt; <br>&gt; func test(x : Int) {<br>&gt;     switch x {<br>&gt;     case 5:<br>&gt;         print(&quot;5&quot;)<br>&gt;         fallthrough<br>&gt;     case 6:<br>&gt;         print(&quot;6&quot;)<br>&gt;     default:<br>&gt;         print(&quot;anything else&quot;)<br>&gt;     }<br>&gt; }<br>&gt; Fallthrough is better suited for situations like the following:<br>&gt; <br>&gt; case simple where even more subconditions hold: ... do complex things ...; fallthrough<br>&gt; case simple where subconditions hold: ... do other things ...; fallthrough<br>&gt; case simple: ... do base things ...<br>&gt; This example produces a sieve where the most restrictive conditions execute specialized code and then execute code for less restrictive conditions.<br>&gt; <br>&gt; Fallthrough cannot be used for situations like the following example:<br>&gt; <br>&gt; case specialized situation 1: ... code specific to situation 1 ...; fallthrough<br>&gt; case specialized situation 2: ... code specific to situation 2 ...; fallthrough<br>&gt; case specialized situation 3: ... code specific to situation 3 ...; fallthrough<br>&gt; case general: ... general code applicable as well to the three specialized situations ...<br>&gt; Those coming from C-like languages might have the insight to expect (wrongly, it should be noted) &quot;5&quot;, then &quot;6&quot;, then &quot;anything else&quot;, which is what you&#39;d get with the following flawed C-ish code, where case statements are missing break.<br>&gt; <br>&gt; int x = 5;<br>&gt; switch (x) {<br>&gt;     case 5: NSLog(@&quot;5&quot;); // no break;<br>&gt;     case 6: NSLog(@&quot;6&quot;); // no break;<br>&gt;     default: NSLog(@&quot;anything else&quot;);<br>&gt; }<br>&gt; Swift-style switch statements are more powerful and general than C-style switch statements. While I do not endorse C-style switch statements, I do think there&#39;s a case to be made for continue, which would mean &quot;continue pattern matching&quot;. It would look like this:<br>&gt; <br>&gt; case specialized situation 1: ... code specific to situation 1 ...; continue<br>&gt; case specialized situation 2: ... code specific to situation 2 ...; continue<br>&gt; case specialized situation 3: ... code specific to situation 3 ...; continue<br>&gt; case general: ... general code applicable as well to the three specialized situations ...<br>&gt; In this example, code that matched general might execute any of the three specialized subconditions as well but would not have to fall through each case. So if a pattern matched scenarios 1 and 3, it would execute those cases and the general case, but not scenario 2.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#the-advantages-of-continue&gt;The advantages of continue<br>&gt; <br>&gt; If adopted, continue allows code to execute multiple matching patterns<br>&gt; It naturally reduces code redundancy where fallthrough cannot be used but code applies to multiple cases (such as the 1, 3, and general example above).<br>&gt; It uses an existing control flow transfer keyword, using it in a reasonably harmonious application that isn&#39;t that far out of step with how the keyword is used in other parts of the language.<br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; In the current design, switch statements support subset of control flow transfer:<br>&gt; <br>&gt; control-transfer-statement → break-statement<br>&gt; control-transfer-statement → fallthrough-statement<br>&gt; control-transfer-statement → return-statement<br>&gt; control-transfer-statement → throw-statement<br>&gt; Notably missing is &quot;continue&quot;, which this proposal would adopt.<br>&gt; <br>&gt; control-transfer-statement → continue-statement<br>&gt; The definition of continue in a switch statement would mean &quot;after executing the previous statements in this case clause, continue pattern matching the remaining cases until a match or default is found.<br>&gt; <br>&gt; continue could either be disallowed in the final case (typically default) or could be ignored if included.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; None.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; Not adopting this idea<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/932a2941/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>July 11, 2016 at 11:00:00am</p></header><div class="content"><p>I&#39;m in favour of this concept being available in Swift, but it does need to<br>make a clear distinction somewhere between a case which matches anything<br>(and can catch any fallthrough/continue) and a case which matches none of<br>the above. I don&#39;t know whether we need to introduce an explicit term for<br>this, or whether we make this the distinction between &#39;case _:&#39; and<br>&#39;default:&#39; (with the side-effect that we can now justify &#39;default&#39; in the<br>language).<br></p><p>For example: let&#39;s use this switch to play fizzbuzz.<br></p><p>switch value<br>{<br>  case x where x % 3 == 0:<br>    print(&quot;fizz&quot;)<br>    continue<br>  case x where x % 5 == 0:<br>    print(&quot;buzz&quot;)<br>  default:<br>    print(value)<br>}<br></p><p>I know this is a trivial example, but it&#39;s also a frequent example used to<br>teach switch to programmers.<br>The keywords in play are &#39;continue&#39; and &#39;default&#39;. A multiple of 5 but not<br>3 will print &#39;buzz&#39; and be done. A multiple of 3 and 5 will print &#39;fizz<br>buzz&#39;. Any number not a multiple of 3 or 5 will say its value. Crucially, a<br>multiple of 3 but not 5 will say fizz, won&#39;t say buzz, and won&#39;t say the<br>number itself - whereas if we used &#39;case _&#39;, it would say fizz and then the<br>number itself.<br></p><p><br></p><p><br></p><p>On Mon, Jul 11, 2016 at 9:33 AM, Jacopo Andrea Giola via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Here we go again :)<br>&gt;<br>&gt; I’m obviously supporting this proposal, like the first one we had tried to<br>&gt; pass at the beginning of the swift evolution mailing list, even if in those<br>&gt; times, we try to completely replace the fallthrough keyword with a new one.<br>&gt;<br>&gt; I continue to have a draft of that proposal on gist<br>&gt; https://gist.github.com/JGiola/f735212789bf2f697847<br>&gt;<br>&gt; Instead of continue we put out a fallto keyword that must explicit state<br>&gt; the case where we want to go at the end of that case, but this solution is<br>&gt; more  clean and simple to reasoning with and use a well stated keyword used<br>&gt; in others flow statements.<br>&gt;<br>&gt; - Jacopo<br>&gt;<br>&gt;<br>&gt; On 11 Jul 2016, at 04:27, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; A quick pitch to introduce `continue` to switch statements. This would be<br>&gt; additive and could not be considered for Swift 3.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; Pitch: Introduce continue to Switch Statements<br>&gt; &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This pitch completes the switch statement&#39;s control flow transfer suite by<br>&gt; introducing continue. Doing so provides functionality that a large<br>&gt; portion of newer developers expect from (but do not get from) fallthrough.<br>&gt; &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Swift&#39;s fallthrough statement means &quot;continue by executing the code<br>&gt; defined in the next case clause&quot;. It has at least one solid use-case, which<br>&gt; is demonstrated in this example<br>&gt; &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;<br>&gt;<br>&gt; Swift Evolution discussed removing fallthrough on-list in early December<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000226.html&gt; We<br>&gt; came to the consensus that fallthroughoffers sufficient utility to retain<br>&gt; the feature in the language:<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#the-problem-with-fallthrough&gt;The<br>&gt; Problem with Fallthrough.<br>&gt;<br>&gt; In Swift, fallthrough does not mean: &quot;execute this case and then continue<br>&gt; pattern matching&quot;, which is what many naive users expect. Given the<br>&gt; following code where x is 5, they anticipate the function to print &quot;5&quot;<br>&gt; and then &quot;anything else&quot;. This is wrong. Swift prints &quot;5&quot; and then &quot;6&quot;.<br>&gt;<br>&gt; func test(x : Int) {<br>&gt;     switch x {<br>&gt;     case 5:<br>&gt;         print(&quot;5&quot;)<br>&gt;         fallthrough<br>&gt;     case 6:<br>&gt;         print(&quot;6&quot;)<br>&gt;     default:<br>&gt;         print(&quot;anything else&quot;)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Fallthrough is better suited for situations like the following:<br>&gt;<br>&gt; case simple where even more subconditions hold: ... do complex things ...; fallthrough<br>&gt; case simple where subconditions hold: ... do other things ...; fallthrough<br>&gt; case simple: ... do base things ...<br>&gt;<br>&gt; This example produces a sieve where the most restrictive conditions<br>&gt; execute specialized code and then execute code for less restrictive<br>&gt; conditions.<br>&gt;<br>&gt; Fallthrough *cannot* be used for situations like the following example:<br>&gt;<br>&gt; case specialized situation 1: ... code specific to situation 1 ...; fallthrough<br>&gt; case specialized situation 2: ... code specific to situation 2 ...; fallthrough<br>&gt; case specialized situation 3: ... code specific to situation 3 ...; fallthrough<br>&gt; case general: ... general code applicable as well to the three specialized situations ...<br>&gt;<br>&gt; Those coming from C-like languages might have the insight to expect<br>&gt; (wrongly, it should be noted) &quot;5&quot;, then &quot;6&quot;, then &quot;anything else&quot;, which is<br>&gt; what you&#39;d get with the following flawed C-ish code, where case statements<br>&gt; are missing break.<br>&gt;<br>&gt; int x = 5;<br>&gt; switch (x) {<br>&gt;     case 5: NSLog(@&quot;5&quot;); // no break;<br>&gt;     case 6: NSLog(@&quot;6&quot;); // no break;<br>&gt;     default: NSLog(@&quot;anything else&quot;);<br>&gt; }<br>&gt;<br>&gt; Swift-style switch statements are more powerful and general than C-style<br>&gt; switch statements. While I do not endorse C-style switch statements, I do<br>&gt; think there&#39;s a case to be made for continue, which would mean &quot;continue<br>&gt; pattern matching&quot;. It would look like this:<br>&gt;<br>&gt; case specialized situation 1: ... code specific to situation 1 ...; continue<br>&gt; case specialized situation 2: ... code specific to situation 2 ...; continue<br>&gt; case specialized situation 3: ... code specific to situation 3 ...; continue<br>&gt; case general: ... general code applicable as well to the three specialized situations ...<br>&gt;<br>&gt; In this example, code that matched general might execute any of the three<br>&gt; specialized subconditions as well but would not have to fall through each<br>&gt; case. So if a pattern matched scenarios 1 and 3, it would execute those<br>&gt; cases and the general case, but not scenario 2.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#the-advantages-of-continue&gt;The<br>&gt; advantages of continue<br>&gt;<br>&gt;    - If adopted, continue allows code to execute multiple matching<br>&gt;    patterns<br>&gt;    - It naturally reduces code redundancy where fallthrough cannot be<br>&gt;    used but code applies to multiple cases (such as the 1, 3, and general<br>&gt;    example above).<br>&gt;    - It uses an existing control flow transfer keyword, using it in a<br>&gt;    reasonably harmonious application that isn&#39;t that far out of step with how<br>&gt;    the keyword is used in other parts of the language.<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#detailed-design&gt;Detailed<br>&gt; Design<br>&gt;<br>&gt; In the current design, switch statements support subset of control flow<br>&gt; transfer:<br>&gt;<br>&gt; control-transfer-statement → break-statement<br>&gt; control-transfer-statement → fallthrough-statement<br>&gt; control-transfer-statement → return-statement<br>&gt; control-transfer-statement → throw-statement<br>&gt;<br>&gt; Notably missing is &quot;continue&quot;, which this proposal would adopt.<br>&gt;<br>&gt; control-transfer-statement → continue-statement<br>&gt;<br>&gt; The definition of continue in a switch statement would mean &quot;after<br>&gt; executing the previous statements in this case clause, continue pattern<br>&gt; matching the remaining cases until a match or default is found.<br>&gt;<br>&gt; continue could either be disallowed in the final case (typically default)<br>&gt; or could be ignored if included.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; None.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; Not adopting this idea<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/a5164b2f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July 11, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 4:49 AM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m in favour of this concept being available in Swift, but it does need to make a clear distinction somewhere between a case which matches anything (and can catch any fallthrough/continue) and a case which matches none of the above. I don&#39;t know whether we need to introduce an explicit term for this, or whether we make this the distinction between &#39;case _:&#39; and &#39;default:&#39; (with the side-effect that we can now justify &#39;default&#39; in the language).<br>&gt; <br>&gt; For example: let&#39;s use this switch to play fizzbuzz.<br>&gt; <br>&gt; switch value<br>&gt; {<br>&gt;   case x where x % 3 == 0:<br>&gt;     print(&quot;fizz&quot;)<br>&gt;     continue<br>&gt;   case x where x % 5 == 0:<br>&gt;     print(&quot;buzz&quot;)<br>&gt;   default:<br>&gt;     print(value)<br>&gt; }<br>&gt; <br>&gt; I know this is a trivial example, but it&#39;s also a frequent example used to teach switch to programmers.<br>&gt; The keywords in play are &#39;continue&#39; and &#39;default&#39;. A multiple of 5 but not 3 will print &#39;buzz&#39; and be done. A multiple of 3 and 5 will print &#39;fizz buzz&#39;. Any number not a multiple of 3 or 5 will say its value. Crucially, a multiple of 3 but not 5 will say fizz, won&#39;t say buzz, and won&#39;t say the number itself - whereas if we used &#39;case _&#39;, it would say fizz and then the number itself.<br></p><p><br>The standard question asks you to print the value and then fizz and/or buzz on the same line and then move to the next line.<br></p><p>If you use the rules you stated (&quot;Any number not a multiple of 3 or 5 will say its value.&quot;), it would look like this:<br></p><p>switch value<br>{<br>case _ where !(x % 5 == 0 || x % 3 == 0):<br>    print(value)<br>case x where x % 3 == 0:<br>    print(&quot;fizz&quot;, terminator: &quot;&quot;)<br>    continue<br>case x where x % 5 == 0:<br>    print(&quot;buzz&quot;, terminator: &quot;&quot;)<br>    continue<br>default:<br>    print(&quot;&quot;)<br>    break<br>}<br></p><p>If you use the standard rules, it looks like this:<br></p><p>switch value<br>{<br>case _:<br>    print(value, terminator: &quot;&quot;)<br>case x where x % 3 == 0:<br>    print(&quot; fizz&quot;, terminator: &quot;&quot;)<br>    continue<br>case x where x % 5 == 0:<br>    print(&quot; buzz&quot;, terminator: &quot;&quot;)<br>    continue<br>default:<br>    print(&quot;&quot;)<br>    break<br>}<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/0f4adc74/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July 11, 2016 at 12:00:00pm</p></header><div class="content"><p>I&#39;ll have to give this a -1. Code seems to be confusing with this new<br>use of continue and we may easily lose control of the flow. If we are<br>to allow another case to be executed, we should be able to explicitly<br>direct the flow to the case we want. C# does that using the goto<br>keyword (yes, I know). I would support this (goto) here but it however<br>was designed to work well with constant cases and I don&#39;t see how this<br>could work with cases with where expressions like the ones in this<br>example.<br></p><p>L<br></p><p><br>On 11 July 2016 at 11:54, Erica Sadun via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Jul 11, 2016, at 4:49 AM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; I&#39;m in favour of this concept being available in Swift, but it does need to<br>&gt; make a clear distinction somewhere between a case which matches anything<br>&gt; (and can catch any fallthrough/continue) and a case which matches none of<br>&gt; the above. I don&#39;t know whether we need to introduce an explicit term for<br>&gt; this, or whether we make this the distinction between &#39;case _:&#39; and<br>&gt; &#39;default:&#39; (with the side-effect that we can now justify &#39;default&#39; in the<br>&gt; language).<br>&gt;<br>&gt; For example: let&#39;s use this switch to play fizzbuzz.<br>&gt;<br>&gt; switch value<br>&gt; {<br>&gt;   case x where x % 3 == 0:<br>&gt;     print(&quot;fizz&quot;)<br>&gt;     continue<br>&gt;   case x where x % 5 == 0:<br>&gt;     print(&quot;buzz&quot;)<br>&gt;   default:<br>&gt;     print(value)<br>&gt; }<br>&gt;<br>&gt; I know this is a trivial example, but it&#39;s also a frequent example used to<br>&gt; teach switch to programmers.<br>&gt; The keywords in play are &#39;continue&#39; and &#39;default&#39;. A multiple of 5 but not 3<br>&gt; will print &#39;buzz&#39; and be done. A multiple of 3 and 5 will print &#39;fizz buzz&#39;.<br>&gt; Any number not a multiple of 3 or 5 will say its value. Crucially, a<br>&gt; multiple of 3 but not 5 will say fizz, won&#39;t say buzz, and won&#39;t say the<br>&gt; number itself - whereas if we used &#39;case _&#39;, it would say fizz and then the<br>&gt; number itself.<br>&gt;<br>&gt;<br>&gt;<br>&gt; The standard question asks you to print the value and then fizz and/or buzz<br>&gt; on the same line and then move to the next line.<br>&gt;<br>&gt; If you use the rules you stated (&quot;Any number not a multiple of 3 or 5 will<br>&gt; say its value.&quot;), it would look like this:<br>&gt;<br>&gt; switch value<br>&gt; {<br>&gt; case _ where !(x % 5 == 0 || x % 3 == 0):<br>&gt;     print(value)<br>&gt; case x where x % 3 == 0:<br>&gt;     print(&quot;fizz&quot;, terminator: &quot;&quot;)<br>&gt;     continue<br>&gt; case x where x % 5 == 0:<br>&gt;     print(&quot;buzz&quot;, terminator: &quot;&quot;)<br>&gt;     continue<br>&gt; default:<br>&gt;     print(&quot;&quot;)<br>&gt;     break<br>&gt; }<br>&gt;<br>&gt; If you use the standard rules, it looks like this:<br>&gt;<br>&gt; switch value<br>&gt; {<br>&gt; case _:<br>&gt;     print(value, terminator: &quot;&quot;)<br>&gt; case x where x % 3 == 0:<br>&gt;     print(&quot; fizz&quot;, terminator: &quot;&quot;)<br>&gt;     continue<br>&gt; case x where x % 5 == 0:<br>&gt;     print(&quot; buzz&quot;, terminator: &quot;&quot;)<br>&gt;     continue<br>&gt; default:<br>&gt;     print(&quot;&quot;)<br>&gt;     break<br>&gt; }<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July 11, 2016 at 11:00:00am</p></header><div class="content"><p>I&#39;m a bit undecided about this feature, as I think it&#39;s harder to read the switch statement. For example, with this new feature I could write something like so:<br></p><p>	switch x {<br>		case 1:<br>			print(&quot;1&quot;)<br>		case 2:<br>			print(&quot;2&quot;)<br>			continue<br>		case 3:<br>			print(&quot;3&quot;)<br>			continue<br>		default:<br>			print(&quot;base&quot;)<br>	}<br></p><p>But right now I can achieve this with the following:<br></p><p>	switch x {<br>		case 1:<br>			print(&quot;1&quot;)<br>		default:<br>			switch x {<br>				case 2:<br>					print(&quot;2&quot;)<br>				case 3:<br>					print(&quot;3&quot;)<br>			}<br>			print(&quot;base&quot;)<br>	}<br></p><p>Personally I prefer the latter; it isn&#39;t actually much more code, though it&#39;s certainly more visually noisy, but it&#39;s very explicit about what&#39;s going on, and avoids having to consider which cases will be reconsidered as the nested switch makes it very clear what it covers. Of course very complex cases may require more nesting, so become even less pretty, but personally I think the grouping outweighs this overall as it visually narrows the focus.<br></p><p>I wonder if perhaps there might be a way to instead simplify nested switches when operating on the same value? Is there a good real-world example that shows where a continue keyword would have clear advantage over nesting?<br></p><p>&gt; On 11 Jul 2016, at 03:27, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A quick pitch to introduce `continue` to switch statements. This would be additive and could not be considered for Swift 3.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; Pitch: Introduce continue to Switch Statements<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#introduction&gt;Introduction<br>&gt; <br>&gt; This pitch completes the switch statement&#39;s control flow transfer suite by introducing continue. Doing so provides functionality that a large portion of newer developers expect from (but do not get from) fallthrough.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#motivation&gt;Motivation<br>&gt; <br>&gt; Swift&#39;s fallthrough statement means &quot;continue by executing the code defined in the next case clause&quot;. It has at least one solid use-case, which is demonstrated in this example &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;<br>&gt; Swift Evolution discussed removing fallthrough on-list in early December &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000226.html&gt; We came to the consensus that fallthroughoffers sufficient utility to retain the feature in the language:<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#the-problem-with-fallthrough&gt;The Problem with Fallthrough.<br>&gt; <br>&gt; In Swift, fallthrough does not mean: &quot;execute this case and then continue pattern matching&quot;, which is what many naive users expect. Given the following code where x is 5, they anticipate the function to print &quot;5&quot; and then &quot;anything else&quot;. This is wrong. Swift prints &quot;5&quot; and then &quot;6&quot;.<br>&gt; <br>&gt; func test(x : Int) {<br>&gt;     switch x {<br>&gt;     case 5:<br>&gt;         print(&quot;5&quot;)<br>&gt;         fallthrough<br>&gt;     case 6:<br>&gt;         print(&quot;6&quot;)<br>&gt;     default:<br>&gt;         print(&quot;anything else&quot;)<br>&gt;     }<br>&gt; }<br>&gt; Fallthrough is better suited for situations like the following:<br>&gt; <br>&gt; case simple where even more subconditions hold: ... do complex things ...; fallthrough<br>&gt; case simple where subconditions hold: ... do other things ...; fallthrough<br>&gt; case simple: ... do base things ...<br>&gt; This example produces a sieve where the most restrictive conditions execute specialized code and then execute code for less restrictive conditions.<br>&gt; <br>&gt; Fallthrough cannot be used for situations like the following example:<br>&gt; <br>&gt; case specialized situation 1: ... code specific to situation 1 ...; fallthrough<br>&gt; case specialized situation 2: ... code specific to situation 2 ...; fallthrough<br>&gt; case specialized situation 3: ... code specific to situation 3 ...; fallthrough<br>&gt; case general: ... general code applicable as well to the three specialized situations ...<br>&gt; Those coming from C-like languages might have the insight to expect (wrongly, it should be noted) &quot;5&quot;, then &quot;6&quot;, then &quot;anything else&quot;, which is what you&#39;d get with the following flawed C-ish code, where case statements are missing break.<br>&gt; <br>&gt; int x = 5;<br>&gt; switch (x) {<br>&gt;     case 5: NSLog(@&quot;5&quot;); // no break;<br>&gt;     case 6: NSLog(@&quot;6&quot;); // no break;<br>&gt;     default: NSLog(@&quot;anything else&quot;);<br>&gt; }<br>&gt; Swift-style switch statements are more powerful and general than C-style switch statements. While I do not endorse C-style switch statements, I do think there&#39;s a case to be made for continue, which would mean &quot;continue pattern matching&quot;. It would look like this:<br>&gt; <br>&gt; case specialized situation 1: ... code specific to situation 1 ...; continue<br>&gt; case specialized situation 2: ... code specific to situation 2 ...; continue<br>&gt; case specialized situation 3: ... code specific to situation 3 ...; continue<br>&gt; case general: ... general code applicable as well to the three specialized situations ...<br>&gt; In this example, code that matched general might execute any of the three specialized subconditions as well but would not have to fall through each case. So if a pattern matched scenarios 1 and 3, it would execute those cases and the general case, but not scenario 2.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#the-advantages-of-continue&gt;The advantages of continue<br>&gt; <br>&gt; If adopted, continue allows code to execute multiple matching patterns<br>&gt; It naturally reduces code redundancy where fallthrough cannot be used but code applies to multiple cases (such as the 1, 3, and general example above).<br>&gt; It uses an existing control flow transfer keyword, using it in a reasonably harmonious application that isn&#39;t that far out of step with how the keyword is used in other parts of the language.<br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; In the current design, switch statements support subset of control flow transfer:<br>&gt; <br>&gt; control-transfer-statement → break-statement<br>&gt; control-transfer-statement → fallthrough-statement<br>&gt; control-transfer-statement → return-statement<br>&gt; control-transfer-statement → throw-statement<br>&gt; Notably missing is &quot;continue&quot;, which this proposal would adopt.<br>&gt; <br>&gt; control-transfer-statement → continue-statement<br>&gt; The definition of continue in a switch statement would mean &quot;after executing the previous statements in this case clause, continue pattern matching the remaining cases until a match or default is found.<br>&gt; <br>&gt; continue could either be disallowed in the final case (typically default) or could be ignored if included.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; None.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; Not adopting this idea<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/b0c498ae/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>July 11, 2016 at 08:00:00am</p></header><div class="content"><p>Just to be clear, under your proposal, what does the following program<br>print? Can you make an argument in favor of your interpretation?<br></p><p>    var x = 1<br>    switch x {<br>    case 1:<br>        print(&quot;one&quot;)<br>        x = 2<br>        continue<br>    case 2:<br>        print(&quot;two&quot;)<br>    default:<br>        break<br>    }<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 7:27 AM, Rob Mayoff &lt;mayoff at dqd.com&gt; wrote:<br>&gt; <br>&gt; Just to be clear, under your proposal, what does the following program<br>&gt; print? Can you make an argument in favor of your interpretation?<br>&gt; <br>&gt;    var x = 1<br>&gt;    switch x {<br>&gt;    case 1:<br>&gt;        print(&quot;one&quot;)<br>&gt;        x = 2<br>&gt;        continue<br>&gt;    case 2:<br>&gt;        print(&quot;two&quot;)<br>&gt;    default:<br>&gt;        break<br>&gt;    }<br></p><p>The switch statement is defined as:<br></p><p>switch-statement → switch expression {switch-cases*}<br></p><p>I&#39;d imagine this means the expression is evaluated once, e.g.:<br></p><p>switch 2 + 3 {<br>case 5: print(&quot;Five!&quot;)<br>default: break<br>}<br></p><p>So I&#39;m more likely to expect &quot;one&quot; than &quot;one&quot;/&quot;two&quot;.  I would defer this question <br>to the core team for a better answer.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/3eac633b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 11, 2016 at 03:00:00pm</p></header><div class="content"><p>As for all of the other additive changes, I would strongly prefer you to *wait* on even proposing or discussing these things until after the Swift 3.0 evolution cycle is done.  Not only is it distracting for the community, but the core team and many others won’t be be able to even read the thread or the responses, thus your discussion cycle will be lacking key input.<br></p><p>On this topic, we specifically discussed this when labeled breaks were being designed, and when they were expanded to “do” in Swift 2.  We specifically decided to allow break but not continue, because we didn’t want these control flow statements to be “another way to spell a loop”.<br></p><p>-Chris<br></p><p>&gt; On Jul 10, 2016, at 7:27 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A quick pitch to introduce `continue` to switch statements. This would be additive and could not be considered for Swift 3.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; Pitch: Introduce continue to Switch Statements<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#introduction&gt;Introduction<br>&gt; <br>&gt; This pitch completes the switch statement&#39;s control flow transfer suite by introducing continue. Doing so provides functionality that a large portion of newer developers expect from (but do not get from) fallthrough.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/d5cf546d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 12, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 3:49 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; As for all of the other additive changes, I would strongly prefer you to *wait* on even proposing or discussing these things until after the Swift 3.0 evolution cycle is done.  Not only is it distracting for the community, but the core team and many others won’t be be able to even read the thread or the responses, thus your discussion cycle will be lacking key input.<br>&gt; <br>&gt; On this topic, we specifically discussed this when labeled breaks were being designed, and when they were expanded to “do” in Swift 2.  We specifically decided to allow break but not continue, because we didn’t want these control flow statements to be “another way to spell a loop”.<br></p><p>Right.  If you&#39;re interested in pursuing something like this, you might pitch a proposal that adds a &quot;reswitch&quot; that takes an operand to re-dispatch on; but like Chris says, you should wait until the Swift 4 cycle starts.<br></p><p>John.<br></p><p>&gt; <br>&gt; -Chris<br>&gt; <br>&gt;&gt; On Jul 10, 2016, at 7:27 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; A quick pitch to introduce `continue` to switch statements. This would be additive and could not be considered for Swift 3.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; Pitch: Introduce continue to Switch Statements<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/04835de3d3d9121ef7308dd9b093158a#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; This pitch completes the switch statement&#39;s control flow transfer suite by introducing continue. Doing so provides functionality that a large portion of newer developers expect from (but do not get from) fallthrough.<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/fbffb095/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July 12, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 4:49 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; As for all of the other additive changes, I would strongly prefer you to *wait* on even proposing or discussing these things until after the Swift 3.0 evolution cycle is done.  Not only is it distracting for the community, but the core team and many others won’t be be able to even read the thread or the responses, thus your discussion cycle will be lacking key input.<br>&gt; <br>&gt; On this topic, we specifically discussed this when labeled breaks were being designed, and when they were expanded to “do” in Swift 2.  We specifically decided to allow break but not continue, because we didn’t want these control flow statements to be “another way to spell a loop”.<br>&gt; <br>&gt; -Chris<br></p><p>So I can take it as a given that this is out of scope for Swift 3 too?<br></p><p>https://gist.github.com/erica/a78045d09fa5bb20e6e566295140c84d &lt;https://gist.github.com/erica/a78045d09fa5bb20e6e566295140c84d&gt;<br></p><p><br>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/56b7e275/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5af07e950f10c7c1df1c44bed055c1eb?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Daniel Steinberg</string> &lt;daniel at dimsumthinking.com&gt;<p>July 12, 2016 at 11:00:00am</p></header><div class="content"><p>Love that!<br>&gt; On Jul 12, 2016, at 11:47 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 11, 2016, at 4:49 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As for all of the other additive changes, I would strongly prefer you to *wait* on even proposing or discussing these things until after the Swift 3.0 evolution cycle is done.  Not only is it distracting for the community, but the core team and many others won’t be be able to even read the thread or the responses, thus your discussion cycle will be lacking key input.<br>&gt;&gt; <br>&gt;&gt; On this topic, we specifically discussed this when labeled breaks were being designed, and when they were expanded to “do” in Swift 2.  We specifically decided to allow break but not continue, because we didn’t want these control flow statements to be “another way to spell a loop”.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; So I can take it as a given that this is out of scope for Swift 3 too?<br>&gt; <br>&gt; https://gist.github.com/erica/a78045d09fa5bb20e6e566295140c84d &lt;https://gist.github.com/erica/a78045d09fa5bb20e6e566295140c84d&gt;<br>&gt; <br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/7ab43ceb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>July 12, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jul 12, 2016, at 8:47 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 11, 2016, at 4:49 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As for all of the other additive changes, I would strongly prefer you to *wait* on even proposing or discussing these things until after the Swift 3.0 evolution cycle is done.  Not only is it distracting for the community, but the core team and many others won’t be be able to even read the thread or the responses, thus your discussion cycle will be lacking key input.<br>&gt;&gt; <br>&gt;&gt; On this topic, we specifically discussed this when labeled breaks were being designed, and when they were expanded to “do” in Swift 2.  We specifically decided to allow break but not continue, because we didn’t want these control flow statements to be “another way to spell a loop”.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; So I can take it as a given that this is out of scope for Swift 3 too?<br>&gt; <br>&gt; https://gist.github.com/erica/a78045d09fa5bb20e6e566295140c84d &lt;https://gist.github.com/erica/a78045d09fa5bb20e6e566295140c84d&gt;<br></p><p>No, *that* is out of scope for *Swift*. <br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/4ba027b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July 12, 2016 at 01:00:00pm</p></header><div class="content"><p>I&#39;d agree with Doug, completely out of scope. The only way I&#39;d support<br>a goto statement was to jump to another switch case as in C#.<br></p><p>L<br></p><p><br>On 12 July 2016 at 12:49, Douglas Gregor via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Jul 12, 2016, at 8:47 AM, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 11, 2016, at 4:49 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt; As for all of the other additive changes, I would strongly prefer you to<br>&gt; *wait* on even proposing or discussing these things until after the Swift<br>&gt; 3.0 evolution cycle is done.  Not only is it distracting for the community,<br>&gt; but the core team and many others won’t be be able to even read the thread<br>&gt; or the responses, thus your discussion cycle will be lacking key input.<br>&gt;<br>&gt; On this topic, we specifically discussed this when labeled breaks were being<br>&gt; designed, and when they were expanded to “do” in Swift 2.  We specifically<br>&gt; decided to allow break but not continue, because we didn’t want these<br>&gt; control flow statements to be “another way to spell a loop”.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; So I can take it as a given that this is out of scope for Swift 3 too?<br>&gt;<br>&gt; https://gist.github.com/erica/a78045d09fa5bb20e6e566295140c84d<br>&gt;<br>&gt;<br>&gt; No, *that* is out of scope for *Swift*.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>July 12, 2016 at 06:00:00pm</p></header><div class="content"><p>Starting to know Erica, I think it was a joke, not to be taken seriously :)<br></p><p>&gt; On 12 Jul 2016, at 18:07, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;d agree with Doug, completely out of scope. The only way I&#39;d support<br>&gt; a goto statement was to jump to another switch case as in C#.<br>&gt; <br>&gt; L<br>&gt; <br>&gt; <br>&gt; On 12 July 2016 at 12:49, Douglas Gregor via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Jul 12, 2016, at 8:47 AM, Erica Sadun via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 11, 2016, at 4:49 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As for all of the other additive changes, I would strongly prefer you to<br>&gt;&gt; *wait* on even proposing or discussing these things until after the Swift<br>&gt;&gt; 3.0 evolution cycle is done.  Not only is it distracting for the community,<br>&gt;&gt; but the core team and many others won’t be be able to even read the thread<br>&gt;&gt; or the responses, thus your discussion cycle will be lacking key input.<br>&gt;&gt; <br>&gt;&gt; On this topic, we specifically discussed this when labeled breaks were being<br>&gt;&gt; designed, and when they were expanded to “do” in Swift 2.  We specifically<br>&gt;&gt; decided to allow break but not continue, because we didn’t want these<br>&gt;&gt; control flow statements to be “another way to spell a loop”.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; So I can take it as a given that this is out of scope for Swift 3 too?<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/erica/a78045d09fa5bb20e6e566295140c84d<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; No, *that* is out of scope for *Swift*.<br>&gt;&gt; <br>&gt;&gt; - Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>July 12, 2016 at 06:00:00pm</p></header><div class="content"><p>I’d love to see goto in Swift, but on the other hand, do {} with labels have so far been sufficient for any practical problem I encountered so far. Goto is much more useful in languages like C, which lack nested functions and other abstraction mechanisms. <br></p><p>Of course, I wouldn’t try to write a high-performance interpreter in Swift any time soon. <br></p><p>— T<br></p><p>&gt; On 12 Jul 2016, at 18:07, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;d agree with Doug, completely out of scope. The only way I&#39;d support<br>&gt; a goto statement was to jump to another switch case as in C#.<br>&gt; <br>&gt; L<br>&gt; <br>&gt; <br>&gt; On 12 July 2016 at 12:49, Douglas Gregor via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Jul 12, 2016, at 8:47 AM, Erica Sadun via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 11, 2016, at 4:49 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As for all of the other additive changes, I would strongly prefer you to<br>&gt;&gt; *wait* on even proposing or discussing these things until after the Swift<br>&gt;&gt; 3.0 evolution cycle is done.  Not only is it distracting for the community,<br>&gt;&gt; but the core team and many others won’t be be able to even read the thread<br>&gt;&gt; or the responses, thus your discussion cycle will be lacking key input.<br>&gt;&gt; <br>&gt;&gt; On this topic, we specifically discussed this when labeled breaks were being<br>&gt;&gt; designed, and when they were expanded to “do” in Swift 2.  We specifically<br>&gt;&gt; decided to allow break but not continue, because we didn’t want these<br>&gt;&gt; control flow statements to be “another way to spell a loop”.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; So I can take it as a given that this is out of scope for Swift 3 too?<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/erica/a78045d09fa5bb20e6e566295140c84d<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; No, *that* is out of scope for *Swift*.<br>&gt;&gt; <br>&gt;&gt; - Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>July 12, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 12, 2016, at 9:20 AM, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt; <br>&gt; I’d love to see goto in Swift, but on the other hand, do {} with labels have so far been sufficient for any practical problem I encountered so far. Goto is much more useful in languages like C, which lack nested functions and other abstraction mechanisms. <br>&gt; <br>&gt; Of course, I wouldn’t try to write a high-performance interpreter in Swift any time soon. <br></p><p>*Sigh*.<br></p><p>Erica was making a joke. There shall be no ‘goto’ in Swift.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; — T<br>&gt; <br>&gt;&gt; On 12 Jul 2016, at 18:07, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;d agree with Doug, completely out of scope. The only way I&#39;d support<br>&gt;&gt; a goto statement was to jump to another switch case as in C#.<br>&gt;&gt; <br>&gt;&gt; L<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On 12 July 2016 at 12:49, Douglas Gregor via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 12, 2016, at 8:47 AM, Erica Sadun via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 11, 2016, at 4:49 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for all of the other additive changes, I would strongly prefer you to<br>&gt;&gt;&gt; *wait* on even proposing or discussing these things until after the Swift<br>&gt;&gt;&gt; 3.0 evolution cycle is done.  Not only is it distracting for the community,<br>&gt;&gt;&gt; but the core team and many others won’t be be able to even read the thread<br>&gt;&gt;&gt; or the responses, thus your discussion cycle will be lacking key input.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On this topic, we specifically discussed this when labeled breaks were being<br>&gt;&gt;&gt; designed, and when they were expanded to “do” in Swift 2.  We specifically<br>&gt;&gt;&gt; decided to allow break but not continue, because we didn’t want these<br>&gt;&gt;&gt; control flow statements to be “another way to spell a loop”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So I can take it as a given that this is out of scope for Swift 3 too?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/erica/a78045d09fa5bb20e6e566295140c84d<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, *that* is out of scope for *Swift*.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Pitch] Introduce continue to switch statements</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>July 12, 2016 at 06:00:00pm</p></header><div class="content"><p>There is some truth in every joke ;) I do like goto though. It makes my C code cleaner and easier to maintain. But given that Swift already has a very reasonable restricted goto mechanism with labels, I am as happy as it gets :)<br></p><p>— T<br></p><p><br>&gt; On 12 Jul 2016, at 18:21, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 12, 2016, at 9:20 AM, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’d love to see goto in Swift, but on the other hand, do {} with labels have so far been sufficient for any practical problem I encountered so far. Goto is much more useful in languages like C, which lack nested functions and other abstraction mechanisms. <br>&gt;&gt; <br>&gt;&gt; Of course, I wouldn’t try to write a high-performance interpreter in Swift any time soon. <br>&gt; <br>&gt; *Sigh*.<br>&gt; <br>&gt; Erica was making a joke. There shall be no ‘goto’ in Swift.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt; <br>&gt;&gt; — T<br>&gt;&gt; <br>&gt;&gt;&gt; On 12 Jul 2016, at 18:07, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d agree with Doug, completely out of scope. The only way I&#39;d support<br>&gt;&gt;&gt; a goto statement was to jump to another switch case as in C#.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; L<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 12 July 2016 at 12:49, Douglas Gregor via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 12, 2016, at 8:47 AM, Erica Sadun via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 11, 2016, at 4:49 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As for all of the other additive changes, I would strongly prefer you to<br>&gt;&gt;&gt;&gt; *wait* on even proposing or discussing these things until after the Swift<br>&gt;&gt;&gt;&gt; 3.0 evolution cycle is done.  Not only is it distracting for the community,<br>&gt;&gt;&gt;&gt; but the core team and many others won’t be be able to even read the thread<br>&gt;&gt;&gt;&gt; or the responses, thus your discussion cycle will be lacking key input.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On this topic, we specifically discussed this when labeled breaks were being<br>&gt;&gt;&gt;&gt; designed, and when they were expanded to “do” in Swift 2.  We specifically<br>&gt;&gt;&gt;&gt; decided to allow break but not continue, because we didn’t want these<br>&gt;&gt;&gt;&gt; control flow statements to be “another way to spell a loop”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So I can take it as a given that this is out of scope for Swift 3 too?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://gist.github.com/erica/a78045d09fa5bb20e6e566295140c84d<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, *that* is out of scope for *Swift*.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
