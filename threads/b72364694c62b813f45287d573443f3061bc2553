<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 29, 2016 at 01:00:00pm</p></header><div class="content"><p>The following proposal apparently was not considered widely enough discussed since it was “buried” in a 400 message discussion thread that meandered before coming to the final draft.<br></p><p>As such, to have it reopened — I am restarting the discussion in a new thread to ensure wider discussion.<br></p><p><br>https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md &lt;https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md&gt;<br></p><p><br>Pattern Matching Partial Function<br></p><p>Proposal: SE-0024 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md&gt;<br>Author(s): Craig Cruden &lt;https://github.com/cacruden&gt;<br>Status: Awaiting review<br>Review manager: TBD<br> &lt;https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md#introduction&gt;Introduction<br></p><p>Provide the ability for defining partial functions using familiar case/default pattern matching syntax. A new global matchfunction would use this to provide switch-expression functionality for all types. This function would accept a value and a closure containing the case/default partial functions. Combining case/default partial functions in a closure must always be exhaustive providing a total function. Functions on arrays, dictionaries or other collections such as reduce orfilter, or rather all higher order functions taking a unary function as argument, would accept these closures as they are just normal closures.<br></p><p>Swift-evolution thread: ternary operator ?: suggestion &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006194.html&gt;<br> &lt;https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md#motivation&gt;Motivation<br></p><p>There is currently no elegant methodology within Swift closures to conditionally map values. This type of scenario occurs often in Swift code and this proposal provides a generalized and flexible solution. Anywhere a closure is used the developer will also be able to conditionally execute multiple partial closures depending on the mapping of values. The syntax proposed makes Swift code easier to read, easier to write, and less issue prone.<br></p><p>The following example where a string is mapped to an enum case is indicative of the problem:<br></p><p>let str:String<br></p><p>switch state {<br>case .Cold: <br>    str = “Too cold”<br>case .Hot: <br>    str = “Too hot”<br>default: <br>    str = “Just right”<br>}<br>The syntax above does not elegantly express our intent as the switch statement is designed for “flow control”. Aside from being limited to choosing a single value our example requires no “flow control”. In addition, the ability to execute unrelated statements inside the switch statement makes it harder prove correctness of the algorithm.<br></p><p>Alternatives to using switch do exist but are unsatisfactory. A Dictionary, for example, increases cognitive load (i.e. requires Hashable keys and returns an optional). This makes it less clear as to what function is being performed.Dictionary also lacks exhautiveness or uniqueness checks which may result in unexpected runtime exceptions.<br></p><p>This proposal provides a simple mechanism which covers many different types of scenarios. It may be used where the ideal solution is a switch expression. It may also be used to provide a way of simply mapping conditionally between multiple values in two related but different domains. In addition, it can be used in combination with other functions such as reduceand filter where the logic is partially conditional.<br></p><p>The syntax is based on familiar case/default clauses common to switch statements which may be used in functions such as map, filter, reduce. This makes it easy for the developer to remember and understand.<br></p><p> &lt;https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md#proposed-solution&gt;Proposed solution<br></p><p>Any function which accepts a closure would also be able to accept a closure composed of partial functions defined usingcase/default syntax used in switch-case. Each case or defaultis considered a partial function since it defines the closure for a subset of values.<br></p><p>public enum Trade {<br>    case Buy(quantity: Double, price: Double)<br>    case Sell(quantity: Double, price: Double)<br>}<br></p><p>let commissions = trades.map {<br>    case .Buy(let quantity, let price) where quantity * price &gt; 10000:<br>        let vipCommissionRate = calculateCommissionRate(...)<br>        quantity * price * vipCommissionRate / 100<br>    case .Buy(let quantity, let price):<br>        let commissionRate = calculateCommissionRate(...)<br>        quantity * price * commissionRate / 100<br>    case .Sell(let quantity, let price) where quantity * price &gt; 10000:<br>        let vipCommissionRate = calculateCommissionRate(...)<br>        quantity * price * vipCommissionRate / 100<br>    case .Sell(let quantity, let price):<br>        let commissionRate = calculateCommissionRate(...)<br>        quantity * price * commissionRate / 100<br>}      <br>Each of the case clauses represent a partial closure / partial function. As with a total closure the case result may be specified with the optional return clause. For example:<br></p><p>case .Buy(let quantity, let price) where quantity * price &gt; 10000:<br>    let vipCommissionRate = calculateCommissionRate(...)<br>    return quantity * price * vipCommissionRate / 100<br>Alternative grammar cases/default which is a specialized version that can be used for the simplest and the most consise use case. If the use case is a simple definition of mapping of values then cases can be used to define multiple case clauses. cases clause may not be used with a where clause. The purpose of allowing cases as syntatic sugar for multiple case clauses is to allow a less verbose option for use cases where the developer would use a multi-case ternary expression.<br></p><p>let col = [1,5,7,9]<br></p><p>let newCol = col.map {<br>    cases 1: &quot;one&quot;, 2: &quot;two&quot;,   3: &quot;three&quot;, 4: &quot;four&quot;, 5: &quot;five&quot;,<br>          6: &quot;six&quot;, 7: &quot;seven&quot;, 8: &quot;eight&quot;, 9: &quot;nine&quot;, 0: &quot;zero&quot;<br>    default: &quot;&quot;<br>}<br>The following global match function would provide switch-expression functionality to all types:<br></p><p>func match&lt;T,U&gt;(x: T, @noescape mapping: T -&gt; U) -&gt; U {<br>    return mapping(x)<br>}<br>The match function would be used similar to the following:<br></p><p>let n = 5<br></p><p>let s = match(n) {<br>    cases 1: &quot;one&quot;, 2: &quot;two&quot;,   3: &quot;three&quot;, 4: &quot;four&quot;, 5: &quot;five&quot;,<br>          6: &quot;six&quot;, 7: &quot;seven&quot;, 8: &quot;eight&quot;, 9: &quot;nine&quot;, 0: &quot;zero&quot;<br>    default: &quot;&quot;<br>}<br>Functions such as reduce that receive two or more values must be enclosed in brackets (x, y) to otherwise the parser would likely have trouble distinquishing between comma delimited lists of values which are currently allowed as a single case.<br></p><p>public enum Troy {<br>    case Pound(Int)<br>    case Ounce(Int)<br>    case Pennyweight(Int)<br>    case Grain(Int)<br>}<br></p><p>let weightTroy = [Troy.Pound(5), Troy.Ounce(4), Troy.Pennyweight(6), Troy.Grain(9)]<br></p><p>let weightKg = weightTroy.reduce(0.00) {<br>    case (let acc, Troy.Pound(let quantity)):<br>        acc + Double(quantity) * 0.373<br>    case (let acc, Troy.Ounce(let quantity)):<br>        acc + Double(quantity) * 0.031103<br>    case (let acc, Troy.Pennyweight(let quantity)):<br>        acc + Double(quantity) * 0.001555<br>    case (let acc, Troy.Grain(let quantity)):<br>        acc + Double(quantity) * 0.0000648<br>}<br> &lt;https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md#detailed-design&gt;Detailed design<br></p><p>Any function which accepts a closure would also be able to accept a closure composed of partial functions defined usingcase/default syntax used in switch-case. Each case or defaultis considered a partial function since it defines the closure for a subset of values.<br></p><p>GRAMMAR OF A CLOSURE COMPOSED OF PARTIAL FUNCTIONS<br></p><p>closure → ­ {­switch-cases­opt­}­<br>switch-cases → switch-case­ switch-cases­opt<br>switch-case → case-label­ statements­ | default-label­ statements<br>case-label → case­ case-item-list­ :­<br>case-item-list → pattern­ where-clause­opt­ | pattern ­where-clause­opt­ , ­case-item-list­<br>default-label → default­ :­<br>where-clause → where­ where-expression­<br>where-expression → expression­<br></p><p>Alternative grammar cases/default which is a specialized version that can be used for the simplest and the most consise use case. If the use case is a simple definition of mapping of values then cases can be used to define multiple case clauses. cases clause may not be used with a where clause. The purpose of allowing cases as syntatic sugar for multiple case clauses is to allow a less verbose option for use cases where the developer would use a multi-case ternary expression.<br></p><p>NEW GRAMMAR FOR CONSISE FORM OF CASES<br></p><p>closure → ­ {­switch-cases­opt­}­<br>switch-cases → cases-label­ statements­ | default-label­ statements<br>cases-label → cases­ case-item-map­<br>case-item-map → pattern­ : value | pattern : value ­ , ­case-item-list­<br>default-label → default­:­<br></p><p> &lt;https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>This mechanism is opt-in, so existing code won&#39;t be affected by this change.<br></p><p> &lt;https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md#alternatives-considered&gt;Alternatives considered<br></p><p>There were various specialized multi-ternary suggestions made as a replacement/expansion of ternary which supported more than two possible examples, but are more of a specialized case that this proposal should eliminate the need for.<br></p><p>The only other alternative considered that was a generalized version similar to the proposal above was basically the same but using in instead of : because we were defining partial functions and not a switch command. The overwelming sentiment was in favour of using exactly the same syntax as the switch command where possible.<br></p><p>public enum Troy {<br>    case Pound(Int)<br>    case Ounce(Int)<br>    case Pennyweight(Int)<br>    case Grain(Int)<br>}<br></p><p>let weightTroy = [Troy.Pound(5), Troy.Ounce(4), Troy.Pennyweight(6), Troy.Grain(9)]<br></p><p>let weightKg = weightTroy.reduce(0.00) {<br>    case (let acc, Troy.Pound(let quantity)) in<br>        acc + Double(quantity) * 0.373<br>    case (let acc, Troy.Ounce(let quantity)) in<br>        acc + Double(quantity) * 0.031103<br>    case (let acc, Troy.Pennyweight(let quantity)) in<br>        acc + Double(quantity) * 0.001555<br>    case (let acc, Troy.Grain(let quantity)) in<br>        acc + Double(quantity) * 0.0000648<br>    }<br>}<br> &lt;https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md#out-of-scope&gt;Out of Scope<br></p><p>Named partial functions are out of scope for this proposal.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/b7232553/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>January 28, 2016 at 11:00:00pm</p></header><div class="content"><p>I&#39;m still +1 on this.<br></p><p>I would very much enjoy being able to do this:<br></p><p>let str = state.map {<br></p><p>	case .Cold: 	“Too cold”<br></p><p>	case .Hot: 	“Too hot”<br></p><p>	default: 	“Just right”<br></p><p>}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/92f762f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fb5a6986048ff63d65b0f34fd1ecd1a9?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Paul Cantrell</string> &lt;paul at innig.net&gt;<p>January 29, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 1:01 AM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m still +1 on this.<br>&gt; <br>&gt; I would very much enjoy being able to do this:<br>&gt; <br>&gt; let str = state.map {<br>&gt; 	case .Cold: 	“Too cold”<br>&gt; 	case .Hot: 	“Too hot”<br>&gt; 	default: 	“Just right”<br>&gt; }<br></p><p><br>The language currently allows this:<br></p><p>    let str: String<br>    switch(state) {<br>        case .Cold: str = &quot;Too cold&quot;<br>        case .Hot:  str = &quot;Too hot&quot;<br>        default:    str = &quot;Just right&quot;<br>    }<br></p><p>While that’s slightly noisier, I’m not convinced the minor additional concision justifies the substantial additional language complexity. I’m not even convinced the new syntax is clearer so much as cleverer.<br></p><p>I’d need to see a much more compelling example to be in favor of this proposal.<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/3dd87e03/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>January 28, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; While that’s slightly noisier, I’m not convinced the minor additional<br>concision justifies the substantial additional language complexity.<br></p><p>I&#39;d definitely prefer it were even shorter (I actually made suggestions<br>earlier on this list, but they didn&#39;t gain much support).<br></p><p>But I&#39;ll take &quot;little too verbose&quot; over &quot;much too verbose&quot; any day of the<br>week.<br></p><p>Unfortunately, the problem with figuring out what is &quot;too verbose&quot; is that<br>it&#39;s so subjective.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/26678d75/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>January 28, 2016 at 11:00:00pm</p></header><div class="content"><p>@Paul<br></p><p>On the more objective side of things, there is also the fact that, as the<br>proposal states, it&#39;s nice to have protection against this happening:<br></p><p>    let str: String<br>    switch(state) {<br>        case .Cold: str = &quot;Too cold&quot;; self.freezer.stop()<br>        case .Hot:  str = &quot;Too hot&quot;<br>        default:    str = &quot;Just right&quot;<br>    }<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/c71bde60/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January 28, 2016 at 11:00:00pm</p></header><div class="content"><p>Hi Paul, <br></p><p>Your example, can’t use type inference to determine the type of str which feels clumsy, and “str =“ is duplicated over and over. You also have no guarantee that str get assigned in each case. While this example that error is not likely, if your cases are more complex that could become a problem. Also, if I am writing something that is functional, it is less likely, as Charles points out, another developer will stick some side effect based code in your cases. Finally, for the proposal you could write it even more compactly: Switch statements seem much more heavyweight. <br></p><p>let str = match(state) { cases .Cold: “Too cold”, .Hot: “Too hot”<br>			default: “Just right” }<br></p><p>Cheers,<br>- Paul<br></p><p><br>&gt; On Jan 28, 2016, at 11:37 PM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; @Paul<br>&gt; <br>&gt; On the more objective side of things, there is also the fact that, as the proposal states, it&#39;s nice to have protection against this happening:<br>&gt; <br>&gt;     let str: String<br>&gt;     switch(state) {<br>&gt;         case .Cold: str = &quot;Too cold&quot;; self.freezer.stop()<br>&gt;         case .Hot:  str = &quot;Too hot&quot;<br>&gt;         default:    str = &quot;Just right&quot;<br>&gt;     }<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/22d8b9a7/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>January 29, 2016 at 12:00:00am</p></header><div class="content"><p>Sorry for the barrage here, Paul :)<br></p><p>&gt; I’m not even convinced the new syntax is clearer so much as cleverer.<br></p><p>As I&#39;ve followed the various threads for switch-like assignments, I&#39;ve been<br>thinking a lot about how valid it is to say that more explicit is all that<br>helpful to beginners. I wish I had the resources to test these assumptions<br>with actual people who had never written Swift.<br></p><p>As an example.<br></p><p>We assume that this:<br></p><p>    let phrase: String<br></p><p>    switch( temperature ) {<br></p><p>        case .Cold: str = &quot;Too cold&quot;<br></p><p>        case .Hot:  str = &quot;Too hot&quot;<br></p><p>        default:    str = &quot;Just right&quot;<br></p><p>    }<br></p><p>is going to be easier for beginners than something like this:<br></p><p>    let phrase = temperature ?<br></p><p>        &quot;Too cold&quot; if .Cold :<br></p><p>        &quot;Too hot” if .Hot :<br></p><p>        &quot;Just right&quot; if _<br></p><p><br>I&#39;m using a short version here that is not the actual proposal, and that we<br>won&#39;t use (since we don&#39;t want to overload &quot;if&quot;). But I have a strong hunch<br>that a beginner is not going to find the longer version any more clear.<br>There&#39;s a lot of syntax for the programmer to parse in the &quot;switch&quot;<br>statement, as it stands. I suspect the less redundancy we have, the easier<br>it is to figure out what is going on.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/4b13e10d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January 29, 2016 at 09:00:00am</p></header><div class="content"><p>I think all of this could be solved by just having postfix if statements<br></p><p>var str: String?<br></p><p>str = &quot;hot&quot; if state == .Hot<br>str = &quot;cold&quot; if state == .Cold<br></p><p>//if the ??= operator proposal is accepted then we could just do:<br>str ??= &quot;Invalid Temperature&quot;<br></p><p><br>This is used a lot in Ruby, more flexible since it could be used on any line of code, flexible and concise. I think it reads quite well so beginners will grasp it easily (as I did when writing my first Ruby)<br></p><p>I think compiler wise it could be treated like a do while loop except it only loops once ;) <br></p><p>Sent from my iPhone<br></p><p>&gt; On 29 Jan 2016, at 08:06, Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry for the barrage here, Paul :)<br>&gt; <br>&gt; &gt; I’m not even convinced the new syntax is clearer so much as cleverer.<br>&gt; <br>&gt; As I&#39;ve followed the various threads for switch-like assignments, I&#39;ve been thinking a lot about how valid it is to say that more explicit is all that helpful to beginners. I wish I had the resources to test these assumptions with actual people who had never written Swift.<br>&gt; <br>&gt; As an example. <br>&gt; <br>&gt; We assume that this:<br>&gt; <br>&gt;     let phrase: String<br>&gt;     switch( temperature ) {<br>&gt;         case .Cold: str = &quot;Too cold&quot;<br>&gt;         case .Hot:  str = &quot;Too hot&quot;<br>&gt;         default:    str = &quot;Just right&quot;<br>&gt;     }<br>&gt; <br>&gt; is going to be easier for beginners than something like this:<br>&gt; <br>&gt;     let phrase = temperature ?<br>&gt;         &quot;Too cold&quot; if .Cold :<br>&gt;         &quot;Too hot” if .Hot :<br>&gt;         &quot;Just right&quot; if _  <br>&gt; <br>&gt; I&#39;m using a short version here that is not the actual proposal, and that we won&#39;t use (since we don&#39;t want to overload &quot;if&quot;). But I have a strong hunch that a beginner is not going to find the longer version any more clear. There&#39;s a lot of syntax for the programmer to parse in the &quot;switch&quot; statement, as it stands. I suspect the less redundancy we have, the easier it is to figure out what is going on.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/e68ab332/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 29, 2016 at 04:00:00pm</p></header><div class="content"><p>So the solution to everything in the proposal is to create a mutable variable and then a bunch of if statements in inverse format?<br></p><p>Then take that and embed in a “pure” function where you need closures?  <br></p><p>And forget about pattern matching and decomposing enums?<br></p><p>And this is the solution to “all”?<br></p><p><br></p><p>&gt; On 2016-01-29, at 16:09:19, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think all of this could be solved by just having postfix if statements<br>&gt; <br>&gt; var str: String?<br>&gt; <br>&gt; str = &quot;hot&quot; if state == .Hot<br>&gt; str = &quot;cold&quot; if state == .Cold<br>&gt; <br>&gt; //if the ??= operator proposal is accepted then we could just do:<br>&gt; str ??= &quot;Invalid Temperature&quot;<br>&gt; <br>&gt; <br>&gt; This is used a lot in Ruby, more flexible since it could be used on any line of code, flexible and concise. I think it reads quite well so beginners will grasp it easily (as I did when writing my first Ruby)<br>&gt; <br>&gt; I think compiler wise it could be treated like a do while loop except it only loops once ;) <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On 29 Jan 2016, at 08:06, Charles Constant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Sorry for the barrage here, Paul :)<br>&gt;&gt; <br>&gt;&gt; &gt; I’m not even convinced the new syntax is clearer so much as cleverer.<br>&gt;&gt; <br>&gt;&gt; As I&#39;ve followed the various threads for switch-like assignments, I&#39;ve been thinking a lot about how valid it is to say that more explicit is all that helpful to beginners. I wish I had the resources to test these assumptions with actual people who had never written Swift.<br>&gt;&gt; <br>&gt;&gt; As an example. <br>&gt;&gt; <br>&gt;&gt; We assume that this:<br>&gt;&gt; <br>&gt;&gt;     let phrase: String<br>&gt;&gt;     switch( temperature ) {<br>&gt;&gt;         case .Cold: str = &quot;Too cold&quot;<br>&gt;&gt;         case .Hot:  str = &quot;Too hot&quot;<br>&gt;&gt;         default:    str = &quot;Just right&quot;<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; is going to be easier for beginners than something like this:<br>&gt;&gt; <br>&gt;&gt;     let phrase = temperature ?<br>&gt;&gt;         &quot;Too cold&quot; if .Cold :<br>&gt;&gt;         &quot;Too hot” if .Hot :<br>&gt;&gt;         &quot;Just right&quot; if _  <br>&gt;&gt; <br>&gt;&gt; I&#39;m using a short version here that is not the actual proposal, and that we won&#39;t use (since we don&#39;t want to overload &quot;if&quot;). But I have a strong hunch that a beginner is not going to find the longer version any more clear. There&#39;s a lot of syntax for the programmer to parse in the &quot;switch&quot; statement, as it stands. I suspect the less redundancy we have, the easier it is to figure out what is going on.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/02b4a1e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>January 29, 2016 at 02:00:00am</p></header><div class="content"><p>I just used that example with &quot;if&quot; to try to make a point that it&#39;s not<br>always self-evident whether brevity is less clear. Maybe that was a poor<br>choice, because I was attempting to justify my support of Craig&#39;s proposal.<br>I don&#39;t agree that proposal is a case of &quot;cleverer but not clearer.&quot; On the<br>contrary, it&#39;s probably easier for a beginner to parse, than a &quot;switch&quot; as<br>it stands.<br></p><p>&gt; I think all of this could be solved by just having postfix &quot;if&quot; statements<br></p><p>I don&#39;t think the Swift team would go for that, since they&#39;ve worked hard<br>to avoid overloading statements in the rest of the language. In previous<br>iterations of this discussion thread, we&#39;ve already discussed variations<br>like &quot;when&quot; and &quot;on&quot; etc.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/443cc3d6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>January 30, 2016 at 08:00:00pm</p></header><div class="content"><p>I certainly would prefer if we could use switch (and if/else for that matter) as an expression, instead of some magic syntax usable in `map`. so:<br></p><p>let str = switch(state) {<br>        case .Cold:  &quot;Too cold&quot;<br>        case .Hot:    &quot;Too hot&quot;<br>        default:        &quot;Just right&quot;<br>    }<br></p><p><br>— Radek<br></p><p>&gt; On 29 Jan 2016, at 08:10, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 29, 2016, at 1:01 AM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m still +1 on this.<br>&gt;&gt; <br>&gt;&gt; I would very much enjoy being able to do this:<br>&gt;&gt; <br>&gt;&gt; let str = state.map {<br>&gt;&gt; 	case .Cold: 	“Too cold”<br>&gt;&gt; 	case .Hot: 	“Too hot”<br>&gt;&gt; 	default: 	“Just right”<br>&gt;&gt; }<br>&gt; <br>&gt; <br>&gt; The language currently allows this:<br>&gt; <br>&gt;     let str: String<br>&gt;     switch(state) {<br>&gt;         case .Cold: str = &quot;Too cold&quot;<br>&gt;         case .Hot:  str = &quot;Too hot&quot;<br>&gt;         default:    str = &quot;Just right&quot;<br>&gt;     }<br>&gt; <br>&gt; While that’s slightly noisier, I’m not convinced the minor additional concision justifies the substantial additional language complexity. I’m not even convinced the new syntax is clearer so much as cleverer.<br>&gt; <br>&gt; I’d need to see a much more compelling example to be in favor of this proposal.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/3f488c57/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 31, 2016 at 02:00:00am</p></header><div class="content"><p>The case partial functions are available in all closures, plus you still have the option to write your syntax based on the proposal with the only difference being the keyword of match vs switch.<br></p><p>let str = match(state) {<br>	case .Cold: “Too cold”<br>	case .Hot: “Too hot”<br>	default: “now it is just boring”<br>}<br></p><p>match just being a function that takes a value and a closure.<br></p><p><br></p><p><br>&gt; On 2016-01-31, at 2:11:20, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I certainly would prefer if we could use switch (and if/else for that matter) as an expression, instead of some magic syntax usable in `map`. so:<br>&gt; <br>&gt; let str = switch(state) {<br>&gt;         case .Cold:  &quot;Too cold&quot;<br>&gt;         case .Hot:    &quot;Too hot&quot;<br>&gt;         default:        &quot;Just right&quot;<br>&gt;     }<br>&gt; <br>&gt; <br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 29 Jan 2016, at 08:10, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 29, 2016, at 1:01 AM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m still +1 on this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would very much enjoy being able to do this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let str = state.map {<br>&gt;&gt;&gt; 	case .Cold: 	“Too cold”<br>&gt;&gt;&gt; 	case .Hot: 	“Too hot”<br>&gt;&gt;&gt; 	default: 	“Just right”<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The language currently allows this:<br>&gt;&gt; <br>&gt;&gt;     let str: String<br>&gt;&gt;     switch(state) {<br>&gt;&gt;         case .Cold: str = &quot;Too cold&quot;<br>&gt;&gt;         case .Hot:  str = &quot;Too hot&quot;<br>&gt;&gt;         default:    str = &quot;Just right&quot;<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; While that’s slightly noisier, I’m not convinced the minor additional concision justifies the substantial additional language complexity. I’m not even convinced the new syntax is clearer so much as cleverer.<br>&gt;&gt; <br>&gt;&gt; I’d need to see a much more compelling example to be in favor of this proposal.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; Paul<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/6f2d9155/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 31, 2016 at 12:00:00pm</p></header><div class="content"><p>If values and objects were made Collections of exactly one value then you<br>could write:<br></p><p>  let str = state.flatMap {<br>      switch $0 {<br>          case .Cold: return &quot;Too cold&quot;<br>          case .Hot: return &quot;Too hot&quot;<br>          default: return &quot;now it&#39;s just boring&quot;<br>      }<br>  }<br></p><p>This would be purely a library solution which is a lot easier to implement<br>and has the advantage of then giving real use data to see if people<br>actually use the facility.<br></p><p>On Sunday, 31 January 2016, Craig Cruden via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The case partial functions are available in all closures, plus you still<br>&gt; have the option to write your syntax based on the proposal with the only<br>&gt; difference being the keyword of match vs switch.<br>&gt;<br>&gt; let str = match(state) {<br>&gt; case .Cold: “Too cold”<br>&gt; case .Hot: “Too hot”<br>&gt; default: “now it is just boring”<br>&gt; }<br>&gt;<br>&gt; match just being a function that takes a value and a closure.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 2016-01-31, at 2:11:20, Radosław Pietruszewski via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; I certainly would prefer if we could use switch (and if/else for that<br>&gt; matter) as an expression, instead of some magic syntax usable in `map`. so:<br>&gt;<br>&gt; let str = switch(state) {<br>&gt;         case .Cold:  &quot;Too cold&quot;<br>&gt;         case .Hot:    &quot;Too hot&quot;<br>&gt;         default:        &quot;Just right&quot;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt; — Radek<br>&gt;<br>&gt; On 29 Jan 2016, at 08:10, Paul Cantrell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 29, 2016, at 1:01 AM, Charles Constant via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; I&#39;m still +1 on this.<br>&gt;<br>&gt; I would very much enjoy being able to do this:<br>&gt;<br>&gt; let str = state.map {<br>&gt; 	case .Cold: 	“Too cold”<br>&gt; 	case .Hot: 	“Too hot”<br>&gt; 	default: 	“Just right”<br>&gt; }<br>&gt;<br>&gt;<br>&gt; The language currently allows this:<br>&gt;<br>&gt;     let str: String<br>&gt;     switch(state) {<br>&gt;         case .Cold: str = &quot;Too cold&quot;<br>&gt;         case .Hot:  str = &quot;Too hot&quot;<br>&gt;         default:    str = &quot;Just right&quot;<br>&gt;     }<br>&gt;<br>&gt; While that’s slightly noisier, I’m not convinced the minor additional<br>&gt; concision justifies the substantial additional language complexity. I’m not<br>&gt; even convinced the new syntax is clearer so much as cleverer.<br>&gt;<br>&gt; I’d need to see a much more compelling example to be in favor of this<br>&gt; proposal.<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; Paul<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/222126df/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e860a1e0d21a7ae5467aacfe1d9c6a78?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Denis Nikitenko</string> &lt;d.nikitenko at icloud.com&gt;<p>February  2, 2016 at 09:00:00pm</p></header><div class="content"><p>+1 from me - I would like to see this discussion continue.  Swift already recognizes the utility of pattern matching for initialization by retaining the ?: operator.  It would be nice to see a more general and flexible solution that is still reasonably concise and doesn’t introduce new keywords and operators - though I’m sure at least some changes to the language would be inevitable.  <br></p><p><br>&gt; On Jan 29, 2016, at 1:43 AM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The following proposal apparently was not considered widely enough discussed since it was “buried” in a 400 message discussion thread that meandered before coming to the final draft.<br>&gt; <br>&gt; As such, to have it reopened — I am restarting the discussion in a new thread to ensure wider discussion.<br>&gt; <br>&gt; <br>&gt; https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md &lt;https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md&gt;<br>&gt; <br>&gt; <br>&gt; Pattern Matching Partial Function<br>&gt; <br></p><p>&lt;snip&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/af2937d6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>February  2, 2016 at 10:00:00pm</p></header><div class="content"><p>Agreed. I really would like this to move forward.<br></p><p><br>&gt; On Feb 2, 2016, at 6:59 PM, Denis Nikitenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 from me - I would like to see this discussion continue.  Swift already recognizes the utility of pattern matching for initialization by retaining the ?: operator.  It would be nice to see a more general and flexible solution that is still reasonably concise and doesn’t introduce new keywords and operators - though I’m sure at least some changes to the language would be inevitable.  <br>&gt; <br>&gt; <br>&gt;&gt; On Jan 29, 2016, at 1:43 AM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The following proposal apparently was not considered widely enough discussed since it was “buried” in a 400 message discussion thread that meandered before coming to the final draft.<br>&gt;&gt; <br>&gt;&gt; As such, to have it reopened — I am restarting the discussion in a new thread to ensure wider discussion.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md &lt;https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Pattern Matching Partial Function<br>&gt;&gt; <br>&gt; <br>&gt; &lt;snip&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/ce4ed1f9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February  3, 2016 at 01:00:00pm</p></header><div class="content"><p>I will wait another 24 hours before resubmitting it (even though this discussion thread is not long)…. <br></p><p>Anyone that had commented on this in the other thread, but not this one — it would be greatly appreciated if at least one comment (yay or nay) were added to this thread.<br></p><p>I think the last thread where this was discussed for at least 10 days and had many more comments - already fleshed everything out.<br></p><p><br>&gt; On 2016-02-03, at 13:03:18, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt; <br>&gt; Agreed. I really would like this to move forward.<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 6:59 PM, Denis Nikitenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1 from me - I would like to see this discussion continue.  Swift already recognizes the utility of pattern matching for initialization by retaining the ?: operator.  It would be nice to see a more general and flexible solution that is still reasonably concise and doesn’t introduce new keywords and operators - though I’m sure at least some changes to the language would be inevitable.  <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 29, 2016, at 1:43 AM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The following proposal apparently was not considered widely enough discussed since it was “buried” in a 400 message discussion thread that meandered before coming to the final draft.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As such, to have it reopened — I am restarting the discussion in a new thread to ensure wider discussion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md &lt;https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Pattern Matching Partial Function<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &lt;snip&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/67770881/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February  2, 2016 at 10:00:00pm</p></header><div class="content"><p>I&#39;m really confused by this proposal. Primarily it really seems to be asking for two things:<br></p><p>  1. Allow closures to skip the &quot;switch item&quot; line, and<br>  2. Implicit returns within closures<br></p><p>The desired troy example:<br></p><p>let weightKg = weightTroy.reduce(0.00) {<br>    case (let acc, Troy.Pound(let quantity)): acc + Double(quantity) * 0.373<br>    case (let acc, Troy.Ounce(let quantity)): acc + Double(quantity) * 0.031103<br>    case (let acc, Troy.Pennyweight(let quantity)): acc + Double(quantity) * 0.001555<br>    case (let acc, Troy.Grain(let quantity)): acc + Double(quantity) * 0.0000648<br>}<br></p><p>What you can already do today:<br></p><p>let weightKg = weightTroy.reduce(0.00) { acc, troy in<br>    switch troy {<br>    case let .Pound(quantity): return acc + Double(quantity) * 0.373<br>    case let .Ounce(quantity): return acc + Double(quantity) * 0.031103<br>    case let .Pennyweight(quantity): return acc + Double(quantity) * 0.001555<br>    case let .Grain(quantity): return acc + Double(quantity) * 0.0000648<br>    }<br>}<br></p><p>Unless I&#39;m misunderstanding some other great value, this seems like a lot of syntax to save typing &quot;switch troy&quot; and &quot;return&quot;. If you forget &quot;return&quot;, the compiler will already error for you. I don&#39;t think the desired example brings more clarity either.<br></p><p>As to the initialization example:<br></p><p>let str: String = {<br>    switch($0) {<br>    case .Cold: return &quot;Too cold&quot;<br>    case .Hot:  return &quot;Too hot&quot;<br>    default:    return &quot;Just right&quot;<br>    }<br>}(state)<br></p><p>Yes, the type must be explicit because Swift cannot figure it out. I&#39;d rather address that issue.<br></p><p>For me, I&#39;m really not seeing the value the complexity of the proposal brings.<br></p><p>-David<br></p><p>&gt; On Feb 2, 2016, at 10:07 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I will wait another 24 hours before resubmitting it (even though this discussion thread is not long)…. <br>&gt; <br>&gt; Anyone that had commented on this in the other thread, but not this one — it would be greatly appreciated if at least one comment (yay or nay) were added to this thread.<br>&gt; <br>&gt; I think the last thread where this was discussed for at least 10 days and had many more comments - already fleshed everything out.<br>&gt; <br>&gt; <br>&gt;&gt; On 2016-02-03, at 13:03:18, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Agreed. I really would like this to move forward.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 2, 2016, at 6:59 PM, Denis Nikitenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 from me - I would like to see this discussion continue.  Swift already recognizes the utility of pattern matching for initialization by retaining the ?: operator.  It would be nice to see a more general and flexible solution that is still reasonably concise and doesn’t introduce new keywords and operators - though I’m sure at least some changes to the language would be inevitable.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 29, 2016, at 1:43 AM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The following proposal apparently was not considered widely enough discussed since it was “buried” in a 400 message discussion thread that meandered before coming to the final draft.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As such, to have it reopened — I am restarting the discussion in a new thread to ensure wider discussion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md &lt;https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Pattern Matching Partial Function<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/082c1aec/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>February  3, 2016 at 10:00:00pm</p></header><div class="content"><p>I agree completely with this analysis. Spot on.<br></p><p>&gt; On Feb 3, 2016, at 12:39 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m really confused by this proposal. Primarily it really seems to be asking for two things:<br>&gt; <br>&gt;   1. Allow closures to skip the &quot;switch item&quot; line, and<br>&gt;   2. Implicit returns within closures<br></p><p>…plus (3) overloading “map” to operator on single objects and not just collections.<br></p><p>&gt; <br>&gt; The desired troy example:<br>&gt; <br>&gt; let weightKg = weightTroy.reduce(0.00) {<br>&gt;     case (let acc, Troy.Pound(let quantity)): acc + Double(quantity) * 0.373<br>&gt;     case (let acc, Troy.Ounce(let quantity)): acc + Double(quantity) * 0.031103<br>&gt;     case (let acc, Troy.Pennyweight(let quantity)): acc + Double(quantity) * 0.001555<br>&gt;     case (let acc, Troy.Grain(let quantity)): acc + Double(quantity) * 0.0000648<br>&gt; }<br>&gt; <br>&gt; What you can already do today:<br>&gt; <br>&gt; let weightKg = weightTroy.reduce(0.00) { acc, troy in<br>&gt;     switch troy {<br>&gt;     case let .Pound(quantity): return acc + Double(quantity) * 0.373<br>&gt;     case let .Ounce(quantity): return acc + Double(quantity) * 0.031103<br>&gt;     case let .Pennyweight(quantity): return acc + Double(quantity) * 0.001555<br>&gt;     case let .Grain(quantity): return acc + Double(quantity) * 0.0000648<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Unless I&#39;m misunderstanding some other great value, this seems like a lot of syntax to save typing &quot;switch troy&quot; and &quot;return”.<br></p><p>Bingo.<br></p><p>&gt; If you forget &quot;return&quot;, the compiler will already error for you. I don&#39;t think the desired example brings more clarity either.<br>&gt; <br>&gt; As to the initialization example:<br>&gt; <br>&gt; let str: String = {<br>&gt;     switch($0) {<br>&gt;     case .Cold: return &quot;Too cold&quot;<br>&gt;     case .Hot:  return &quot;Too hot&quot;<br>&gt;     default:    return &quot;Just right&quot;<br>&gt;     }<br>&gt; }(state)<br>&gt; <br>&gt; Yes, the type must be explicit because Swift cannot figure it out. I&#39;d rather address that issue.<br>&gt; <br>&gt; For me, I&#39;m really not seeing the value the complexity of the proposal brings.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 10:07 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I will wait another 24 hours before resubmitting it (even though this discussion thread is not long)…. <br>&gt;&gt; <br>&gt;&gt; Anyone that had commented on this in the other thread, but not this one — it would be greatly appreciated if at least one comment (yay or nay) were added to this thread.<br>&gt;&gt; <br>&gt;&gt; I think the last thread where this was discussed for at least 10 days and had many more comments - already fleshed everything out.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 2016-02-03, at 13:03:18, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Agreed. I really would like this to move forward.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 2, 2016, at 6:59 PM, Denis Nikitenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1 from me - I would like to see this discussion continue.  Swift already recognizes the utility of pattern matching for initialization by retaining the ?: operator.  It would be nice to see a more general and flexible solution that is still reasonably concise and doesn’t introduce new keywords and operators - though I’m sure at least some changes to the language would be inevitable.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 29, 2016, at 1:43 AM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The following proposal apparently was not considered widely enough discussed since it was “buried” in a 400 message discussion thread that meandered before coming to the final draft.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As such, to have it reopened — I am restarting the discussion in a new thread to ensure wider discussion.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md &lt;https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Pattern Matching Partial Function<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/fe134443/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February  4, 2016 at 01:00:00pm</p></header><div class="content"><p>A switch statement is a a flow-control construct which could also be viewed as a more limited implementation of switch expression that only allows the return type of void/Unit.  And the only way to make the switch statement useful is to program by virtue of side-effects - such as mutating a variable.  The fact that Swift has a special allowance to set a ‘let’ to nil, then allow it to be set once again to another value as a hack for the most part because of limitations to the fact that it contains flow-control elements with where expressions / functions would allow for the same thing to be done by programming without side-effects.  <br></p><p>For example, “switch” could be viewed as <br></p><p>func switch&lt;T,U&gt;(x: T, mapping: T -&gt; U) -&gt; Void {<br>    return mapping(x)<br>}<br></p><p>where the only way to do anything useful is to implement the closure containing something that causes side-effects.<br></p><p><br>Functions/closures etc. foundations come from functional programming constructs, and like those constructs there is a mathematical concept allowing for the defining of a function f(X’) -&gt; Y where X’ is maps only part of the set of values in the set X.  <br></p><p>Examples of partial functions are the function square root WHERE square root is restricted to Integers.  If you applied that function to (1, 2, 4, 5, 7, 16), the implementation of that function would apply to a subset (1,4, 16) while the function applied to (2,5,7) would be undefined.  I am however not suggesting that we implement partial functions in general since for the most part the general implementation is of limited use and can easily implemented using Optionals or ‘Either’.  In this case the function closure would be defined through cases (restrictions / defining subsets):<br></p><p>sudo code:<br>case x is Integer where x is a perfect square :  Some(square root of x)<br>default : None<br></p><p>That is of course a very simple mathematical example of a partial function that is limited by the nature of the types themselves.  <br></p><p>Swift at it’s core is not and likely will never be a programming language that fully supports the functional paradigm, but some simple things that like not forcing programmers to program with flow-control and side-effects can make it easier for those that wish to program functionally to at least extend the language through functional libraries.<br></p><p>There has been a lot of interest in allowing the Swift language to implement switch-expressions rather being forced as a hack to use switch flow control statements.  This proposal allows for that (using match function) while allowing for a more general implementation that allows for greater flexibility. <br></p><p>Flow-Control statements often are implemented from the viewpoint of for certain conditions - execute this block, for other conditions, this block… which leads to the blocks becoming overloaded and doing many things since if you have one flow control statement that covers it then everything gets implemented in one block rather than having two flow control statements.  The functional concept of it is that it is just a function and given a function f(x) you will get y (pure function) where you can test that code and know that no side effects, no state will cause a different result.  This allows for very finite test (and reasoning) to prove that a function is correct or not.  Programming by flow-control and side-effects ultimately leads you to more complexity and less ability to be sure that a testing will fully cover all cases all branches of the code - which results in less software quality.<br></p><p><br>&gt; On 2016-02-04, at 11:40:42, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree completely with this analysis. Spot on.<br>&gt; <br>&gt;&gt; On Feb 3, 2016, at 12:39 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m really confused by this proposal. Primarily it really seems to be asking for two things:<br>&gt;&gt; <br>&gt;&gt;   1. Allow closures to skip the &quot;switch item&quot; line, and<br>&gt;&gt;   2. Implicit returns within closures<br>&gt; <br>&gt; …plus (3) overloading “map” to operator on single objects and not just collections.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; The desired troy example:<br>&gt;&gt; <br>&gt;&gt; let weightKg = weightTroy.reduce(0.00) {<br>&gt;&gt;     case (let acc, Troy.Pound(let quantity)): acc + Double(quantity) * 0.373<br>&gt;&gt;     case (let acc, Troy.Ounce(let quantity)): acc + Double(quantity) * 0.031103<br>&gt;&gt;     case (let acc, Troy.Pennyweight(let quantity)): acc + Double(quantity) * 0.001555<br>&gt;&gt;     case (let acc, Troy.Grain(let quantity)): acc + Double(quantity) * 0.0000648<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; What you can already do today:<br>&gt;&gt; <br>&gt;&gt; let weightKg = weightTroy.reduce(0.00) { acc, troy in<br>&gt;&gt;     switch troy {<br>&gt;&gt;     case let .Pound(quantity): return acc + Double(quantity) * 0.373<br>&gt;&gt;     case let .Ounce(quantity): return acc + Double(quantity) * 0.031103<br>&gt;&gt;     case let .Pennyweight(quantity): return acc + Double(quantity) * 0.001555<br>&gt;&gt;     case let .Grain(quantity): return acc + Double(quantity) * 0.0000648<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Unless I&#39;m misunderstanding some other great value, this seems like a lot of syntax to save typing &quot;switch troy&quot; and &quot;return”.<br>&gt; <br>&gt; Bingo.<br>&gt; <br>&gt;&gt; If you forget &quot;return&quot;, the compiler will already error for you. I don&#39;t think the desired example brings more clarity either.<br>&gt;&gt; <br>&gt;&gt; As to the initialization example:<br>&gt;&gt; <br>&gt;&gt; let str: String = {<br>&gt;&gt;     switch($0) {<br>&gt;&gt;     case .Cold: return &quot;Too cold&quot;<br>&gt;&gt;     case .Hot:  return &quot;Too hot&quot;<br>&gt;&gt;     default:    return &quot;Just right&quot;<br>&gt;&gt;     }<br>&gt;&gt; }(state)<br>&gt;&gt; <br>&gt;&gt; Yes, the type must be explicit because Swift cannot figure it out. I&#39;d rather address that issue.<br>&gt;&gt; <br>&gt;&gt; For me, I&#39;m really not seeing the value the complexity of the proposal brings.<br>&gt;&gt; <br>&gt;&gt; -David<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 2, 2016, at 10:07 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I will wait another 24 hours before resubmitting it (even though this discussion thread is not long)…. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyone that had commented on this in the other thread, but not this one — it would be greatly appreciated if at least one comment (yay or nay) were added to this thread.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the last thread where this was discussed for at least 10 days and had many more comments - already fleshed everything out.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 2016-02-03, at 13:03:18, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Agreed. I really would like this to move forward.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 2, 2016, at 6:59 PM, Denis Nikitenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1 from me - I would like to see this discussion continue.  Swift already recognizes the utility of pattern matching for initialization by retaining the ?: operator.  It would be nice to see a more general and flexible solution that is still reasonably concise and doesn’t introduce new keywords and operators - though I’m sure at least some changes to the language would be inevitable.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 29, 2016, at 1:43 AM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The following proposal apparently was not considered widely enough discussed since it was “buried” in a 400 message discussion thread that meandered before coming to the final draft.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As such, to have it reopened — I am restarting the discussion in a new thread to ensure wider discussion.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md &lt;https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Pattern Matching Partial Function<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/3ee9b183/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February  3, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; And the only way to make the switch statement useful is to program by virtue of side-effects - such as mutating a variable. <br></p><p><br>This statement is not true, or maybe I don&#39;t really understand what you&#39;re saying. There are no side-effects in the code below:<br></p><p>func match&lt;T, U&gt;(matchee: T, mapping: T -&gt; U) -&gt; U {<br>    return mapping(matchee)<br>}<br></p><p>let str: String = match(state) {<br>    switch $0 {<br>    case .Cold: return &quot;Too cold&quot;<br>    case .Hot:  return &quot;Too hot&quot;<br>    default:    return &quot;Just right&quot;<br>    }<br>}<br></p><p>-David<br></p><p>&gt; On Feb 3, 2016, at 10:52 PM, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt; <br>&gt; A switch statement is a a flow-control construct which could also be viewed as a more limited implementation of switch expression that only allows the return type of void/Unit.  And the only way to make the switch statement useful is to program by virtue of side-effects - such as mutating a variable.  The fact that Swift has a special allowance to set a ‘let’ to nil, then allow it to be set once again to another value as a hack for the most part because of limitations to the fact that it contains flow-control elements with where expressions / functions would allow for the same thing to be done by programming without side-effects.  <br>&gt; <br>&gt; For example, “switch” could be viewed as <br>&gt; <br>&gt; func switch&lt;T,U&gt;(x: T, mapping: T -&gt; U) -&gt; Void {<br>&gt;     return mapping(x)<br>&gt; }<br>&gt; <br>&gt; where the only way to do anything useful is to implement the closure containing something that causes side-effects.<br>&gt; <br>&gt; <br>&gt; Functions/closures etc. foundations come from functional programming constructs, and like those constructs there is a mathematical concept allowing for the defining of a function f(X’) -&gt; Y where X’ is maps only part of the set of values in the set X.  <br>&gt; <br>&gt; Examples of partial functions are the function square root WHERE square root is restricted to Integers.  If you applied that function to (1, 2, 4, 5, 7, 16), the implementation of that function would apply to a subset (1,4, 16) while the function applied to (2,5,7) would be undefined.  I am however not suggesting that we implement partial functions in general since for the most part the general implementation is of limited use and can easily implemented using Optionals or ‘Either’.  In this case the function closure would be defined through cases (restrictions / defining subsets):<br>&gt; <br>&gt; sudo code:<br>&gt; case x is Integer where x is a perfect square :  Some(square root of x)<br>&gt; default : None<br>&gt; <br>&gt; That is of course a very simple mathematical example of a partial function that is limited by the nature of the types themselves.  <br>&gt; <br>&gt; Swift at it’s core is not and likely will never be a programming language that fully supports the functional paradigm, but some simple things that like not forcing programmers to program with flow-control and side-effects can make it easier for those that wish to program functionally to at least extend the language through functional libraries.<br>&gt; <br>&gt; There has been a lot of interest in allowing the Swift language to implement switch-expressions rather being forced as a hack to use switch flow control statements.  This proposal allows for that (using match function) while allowing for a more general implementation that allows for greater flexibility. <br>&gt; <br>&gt; Flow-Control statements often are implemented from the viewpoint of for certain conditions - execute this block, for other conditions, this block… which leads to the blocks becoming overloaded and doing many things since if you have one flow control statement that covers it then everything gets implemented in one block rather than having two flow control statements.  The functional concept of it is that it is just a function and given a function f(x) you will get y (pure function) where you can test that code and know that no side effects, no state will cause a different result.  This allows for very finite test (and reasoning) to prove that a function is correct or not.  Programming by flow-control and side-effects ultimately leads you to more complexity and less ability to be sure that a testing will fully cover all cases all branches of the code - which results in less software quality.<br>&gt; <br>&gt; <br>&gt;&gt; On 2016-02-04, at 11:40:42, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree completely with this analysis. Spot on.<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 3, 2016, at 12:39 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m really confused by this proposal. Primarily it really seems to be asking for two things:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   1. Allow closures to skip the &quot;switch item&quot; line, and<br>&gt;&gt;&gt;   2. Implicit returns within closures<br>&gt;&gt; <br>&gt;&gt; …plus (3) overloading “map” to operator on single objects and not just collections.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The desired troy example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let weightKg = weightTroy.reduce(0.00) {<br>&gt;&gt;&gt;     case (let acc, Troy.Pound(let quantity)): acc + Double(quantity) * 0.373<br>&gt;&gt;&gt;     case (let acc, Troy.Ounce(let quantity)): acc + Double(quantity) * 0.031103<br>&gt;&gt;&gt;     case (let acc, Troy.Pennyweight(let quantity)): acc + Double(quantity) * 0.001555<br>&gt;&gt;&gt;     case (let acc, Troy.Grain(let quantity)): acc + Double(quantity) * 0.0000648<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What you can already do today:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let weightKg = weightTroy.reduce(0.00) { acc, troy in<br>&gt;&gt;&gt;     switch troy {<br>&gt;&gt;&gt;     case let .Pound(quantity): return acc + Double(quantity) * 0.373<br>&gt;&gt;&gt;     case let .Ounce(quantity): return acc + Double(quantity) * 0.031103<br>&gt;&gt;&gt;     case let .Pennyweight(quantity): return acc + Double(quantity) * 0.001555<br>&gt;&gt;&gt;     case let .Grain(quantity): return acc + Double(quantity) * 0.0000648<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unless I&#39;m misunderstanding some other great value, this seems like a lot of syntax to save typing &quot;switch troy&quot; and &quot;return”.<br>&gt;&gt; <br>&gt;&gt; Bingo.<br>&gt;&gt; <br>&gt;&gt;&gt; If you forget &quot;return&quot;, the compiler will already error for you. I don&#39;t think the desired example brings more clarity either.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As to the initialization example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let str: String = {<br>&gt;&gt;&gt;     switch($0) {<br>&gt;&gt;&gt;     case .Cold: return &quot;Too cold&quot;<br>&gt;&gt;&gt;     case .Hot:  return &quot;Too hot&quot;<br>&gt;&gt;&gt;     default:    return &quot;Just right&quot;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }(state)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, the type must be explicit because Swift cannot figure it out. I&#39;d rather address that issue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For me, I&#39;m really not seeing the value the complexity of the proposal brings.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 2, 2016, at 10:07 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I will wait another 24 hours before resubmitting it (even though this discussion thread is not long)…. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Anyone that had commented on this in the other thread, but not this one — it would be greatly appreciated if at least one comment (yay or nay) were added to this thread.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think the last thread where this was discussed for at least 10 days and had many more comments - already fleshed everything out.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 2016-02-03, at 13:03:18, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Agreed. I really would like this to move forward.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Feb 2, 2016, at 6:59 PM, Denis Nikitenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; +1 from me - I would like to see this discussion continue.  Swift already recognizes the utility of pattern matching for initialization by retaining the ?: operator.  It would be nice to see a more general and flexible solution that is still reasonably concise and doesn’t introduce new keywords and operators - though I’m sure at least some changes to the language would be inevitable.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 29, 2016, at 1:43 AM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The following proposal apparently was not considered widely enough discussed since it was “buried” in a 400 message discussion thread that meandered before coming to the final draft.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As such, to have it reopened — I am restarting the discussion in a new thread to ensure wider discussion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md &lt;https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Pattern Matching Partial Function<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/aee7c5f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February  4, 2016 at 02:00:00pm</p></header><div class="content"><p>That is not existing swift code, switch right now is a statement.  <br></p><p>What you are implementing there is a hack, trying to shoe-horn a switch statement construct into functional switch/match expression use.   And yes, technically when you execute “return” in the middle of a switch statement — it is in fact a flow-control/side effect because “return” is an early return / short circuit that immediately exits in the middle of execution.<br></p><p>You also lose the ability for str to be defined through type inference because of it.  Adding to the clutter (in addition to having to implement a switch statement) — you are basically forcing a lot of code boilerplate into it and thus taking away from focusing just what the functionality is.  <br></p><p>You are focusing too much on switch / case syntax that you are inferring that a `case` inside a closure is effectively the same thing.  <br></p><p>The `case` inside the closure should just be in a method for decomposing and conditionally defining part of a function.  <br></p><p>Think of f(x, y | x &gt; 5) as partial function f(x, y) where x &gt; 5<br>And f(x, y | x &lt;= 5) as a partial function f(x, y) where x &lt;= 5<br></p><p>So instead of defining a total function:<br></p><p>  (x, y) in { …. }<br></p><p>you are defining only a partial of the function in each case:<br></p><p>  case (x, y) where x &gt; 5 in {  }<br>  case (x, y) where &lt;= 5 in { } <br></p><p>each case there is an inferred “orElse” chaining the partial functions into a total function.<br></p><p>Instead of using the functional ‘in’ we are sticking with existing ‘:’ notation since that is what people are use to.<br></p><p><br></p><p><br>&gt; On 2016-02-04, at 14:08:13, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt;&gt; And the only way to make the switch statement useful is to program by virtue of side-effects - such as mutating a variable. <br>&gt; <br>&gt; <br>&gt; This statement is not true, or maybe I don&#39;t really understand what you&#39;re saying. There are no side-effects in the code below:<br>&gt; <br>&gt; func match&lt;T, U&gt;(matchee: T, mapping: T -&gt; U) -&gt; U {<br>&gt;     return mapping(matchee)<br>&gt; }<br>&gt; <br>&gt; let str: String = match(state) {<br>&gt;     switch $0 {<br>&gt;     case .Cold: return &quot;Too cold&quot;<br>&gt;     case .Hot:  return &quot;Too hot&quot;<br>&gt;     default:    return &quot;Just right&quot;<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; -David<br>&gt; <br>&gt;&gt; On Feb 3, 2016, at 10:52 PM, Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; A switch statement is a a flow-control construct which could also be viewed as a more limited implementation of switch expression that only allows the return type of void/Unit.  And the only way to make the switch statement useful is to program by virtue of side-effects - such as mutating a variable.  The fact that Swift has a special allowance to set a ‘let’ to nil, then allow it to be set once again to another value as a hack for the most part because of limitations to the fact that it contains flow-control elements with where expressions / functions would allow for the same thing to be done by programming without side-effects.  <br>&gt;&gt; <br>&gt;&gt; For example, “switch” could be viewed as <br>&gt;&gt; <br>&gt;&gt; func switch&lt;T,U&gt;(x: T, mapping: T -&gt; U) -&gt; Void {<br>&gt;&gt;     return mapping(x)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; where the only way to do anything useful is to implement the closure containing something that causes side-effects.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Functions/closures etc. foundations come from functional programming constructs, and like those constructs there is a mathematical concept allowing for the defining of a function f(X’) -&gt; Y where X’ is maps only part of the set of values in the set X.  <br>&gt;&gt; <br>&gt;&gt; Examples of partial functions are the function square root WHERE square root is restricted to Integers.  If you applied that function to (1, 2, 4, 5, 7, 16), the implementation of that function would apply to a subset (1,4, 16) while the function applied to (2,5,7) would be undefined.  I am however not suggesting that we implement partial functions in general since for the most part the general implementation is of limited use and can easily implemented using Optionals or ‘Either’.  In this case the function closure would be defined through cases (restrictions / defining subsets):<br>&gt;&gt; <br>&gt;&gt; sudo code:<br>&gt;&gt; case x is Integer where x is a perfect square :  Some(square root of x)<br>&gt;&gt; default : None<br>&gt;&gt; <br>&gt;&gt; That is of course a very simple mathematical example of a partial function that is limited by the nature of the types themselves.  <br>&gt;&gt; <br>&gt;&gt; Swift at it’s core is not and likely will never be a programming language that fully supports the functional paradigm, but some simple things that like not forcing programmers to program with flow-control and side-effects can make it easier for those that wish to program functionally to at least extend the language through functional libraries.<br>&gt;&gt; <br>&gt;&gt; There has been a lot of interest in allowing the Swift language to implement switch-expressions rather being forced as a hack to use switch flow control statements.  This proposal allows for that (using match function) while allowing for a more general implementation that allows for greater flexibility. <br>&gt;&gt; <br>&gt;&gt; Flow-Control statements often are implemented from the viewpoint of for certain conditions - execute this block, for other conditions, this block… which leads to the blocks becoming overloaded and doing many things since if you have one flow control statement that covers it then everything gets implemented in one block rather than having two flow control statements.  The functional concept of it is that it is just a function and given a function f(x) you will get y (pure function) where you can test that code and know that no side effects, no state will cause a different result.  This allows for very finite test (and reasoning) to prove that a function is correct or not.  Programming by flow-control and side-effects ultimately leads you to more complexity and less ability to be sure that a testing will fully cover all cases all branches of the code - which results in less software quality.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 2016-02-04, at 11:40:42, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree completely with this analysis. Spot on.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 3, 2016, at 12:39 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m really confused by this proposal. Primarily it really seems to be asking for two things:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   1. Allow closures to skip the &quot;switch item&quot; line, and<br>&gt;&gt;&gt;&gt;   2. Implicit returns within closures<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …plus (3) overloading “map” to operator on single objects and not just collections.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The desired troy example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let weightKg = weightTroy.reduce(0.00) {<br>&gt;&gt;&gt;&gt;     case (let acc, Troy.Pound(let quantity)): acc + Double(quantity) * 0.373<br>&gt;&gt;&gt;&gt;     case (let acc, Troy.Ounce(let quantity)): acc + Double(quantity) * 0.031103<br>&gt;&gt;&gt;&gt;     case (let acc, Troy.Pennyweight(let quantity)): acc + Double(quantity) * 0.001555<br>&gt;&gt;&gt;&gt;     case (let acc, Troy.Grain(let quantity)): acc + Double(quantity) * 0.0000648<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What you can already do today:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let weightKg = weightTroy.reduce(0.00) { acc, troy in<br>&gt;&gt;&gt;&gt;     switch troy {<br>&gt;&gt;&gt;&gt;     case let .Pound(quantity): return acc + Double(quantity) * 0.373<br>&gt;&gt;&gt;&gt;     case let .Ounce(quantity): return acc + Double(quantity) * 0.031103<br>&gt;&gt;&gt;&gt;     case let .Pennyweight(quantity): return acc + Double(quantity) * 0.001555<br>&gt;&gt;&gt;&gt;     case let .Grain(quantity): return acc + Double(quantity) * 0.0000648<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unless I&#39;m misunderstanding some other great value, this seems like a lot of syntax to save typing &quot;switch troy&quot; and &quot;return”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Bingo.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you forget &quot;return&quot;, the compiler will already error for you. I don&#39;t think the desired example brings more clarity either.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As to the initialization example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let str: String = {<br>&gt;&gt;&gt;&gt;     switch($0) {<br>&gt;&gt;&gt;&gt;     case .Cold: return &quot;Too cold&quot;<br>&gt;&gt;&gt;&gt;     case .Hot:  return &quot;Too hot&quot;<br>&gt;&gt;&gt;&gt;     default:    return &quot;Just right&quot;<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }(state)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, the type must be explicit because Swift cannot figure it out. I&#39;d rather address that issue.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For me, I&#39;m really not seeing the value the complexity of the proposal brings.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 2, 2016, at 10:07 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I will wait another 24 hours before resubmitting it (even though this discussion thread is not long)…. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Anyone that had commented on this in the other thread, but not this one — it would be greatly appreciated if at least one comment (yay or nay) were added to this thread.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think the last thread where this was discussed for at least 10 days and had many more comments - already fleshed everything out.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 2016-02-03, at 13:03:18, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Agreed. I really would like this to move forward.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 2, 2016, at 6:59 PM, Denis Nikitenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 from me - I would like to see this discussion continue.  Swift already recognizes the utility of pattern matching for initialization by retaining the ?: operator.  It would be nice to see a more general and flexible solution that is still reasonably concise and doesn’t introduce new keywords and operators - though I’m sure at least some changes to the language would be inevitable.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 29, 2016, at 1:43 AM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The following proposal apparently was not considered widely enough discussed since it was “buried” in a 400 message discussion thread that meandered before coming to the final draft.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As such, to have it reopened — I am restarting the discussion in a new thread to ensure wider discussion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md &lt;https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Pattern Matching Partial Function<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/4120e4b8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>February  3, 2016 at 11:00:00pm</p></header><div class="content"><p>What we are proposing is not really control flow, but a way of mapping values without side effects concisely. They are partial functions as Craig pointed out, that map every value of input to another value of output. That is, they must have be completely specified and return the same type. Switch statements may not check every output is returning a value which can lead to errors. Because there is one returned type, we are able to use type inference to determine the result type. <br></p><p>With this construct, it is harder for another programmer to go in and add another statement with side effects into the expression.<br></p><p>The proposal is powerful in that it provides a very nice way of apply this same concept to values in containers not just individual values, no for-loop is necessary. <br></p><p>If the proposal is accepted, there will be essentially two closure forms,. the one we are all used to and a new one which uses case and default which is a partial function. <br></p><p>In one example in this thread a while ago, I took every example from the switch section of the swift book and they were all more simply and concisely done with expressions than statements. I also think this form might be used more than the switch statement once people get comfortable with it and as functional programming becomes more popular. <br></p><p>With the compact form, for simple mappings, you are able to be even more concise because the word “case” does not need to be repeated. <br></p><p>- Paul <br></p><p>&gt; On Feb 3, 2016, at 11:08 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; And the only way to make the switch statement useful is to program by virtue of side-effects - such as mutating a variable. <br>&gt; <br>&gt; <br>&gt; This statement is not true, or maybe I don&#39;t really understand what you&#39;re saying. There are no side-effects in the code below:<br>&gt; <br>&gt; func match&lt;T, U&gt;(matchee: T, mapping: T -&gt; U) -&gt; U {<br>&gt;     return mapping(matchee)<br>&gt; }<br>&gt; <br>&gt; let str: String = match(state) {<br>&gt;     switch $0 {<br>&gt;     case .Cold: return &quot;Too cold&quot;<br>&gt;     case .Hot:  return &quot;Too hot&quot;<br>&gt;     default:    return &quot;Just right&quot;<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; -David<br>&gt; <br>&gt;&gt; On Feb 3, 2016, at 10:52 PM, Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; A switch statement is a a flow-control construct which could also be viewed as a more limited implementation of switch expression that only allows the return type of void/Unit.  And the only way to make the switch statement useful is to program by virtue of side-effects - such as mutating a variable.  The fact that Swift has a special allowance to set a ‘let’ to nil, then allow it to be set once again to another value as a hack for the most part because of limitations to the fact that it contains flow-control elements with where expressions / functions would allow for the same thing to be done by programming without side-effects.  <br>&gt;&gt; <br>&gt;&gt; For example, “switch” could be viewed as <br>&gt;&gt; <br>&gt;&gt; func switch&lt;T,U&gt;(x: T, mapping: T -&gt; U) -&gt; Void {<br>&gt;&gt;     return mapping(x)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; where the only way to do anything useful is to implement the closure containing something that causes side-effects.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Functions/closures etc. foundations come from functional programming constructs, and like those constructs there is a mathematical concept allowing for the defining of a function f(X’) -&gt; Y where X’ is maps only part of the set of values in the set X.  <br>&gt;&gt; <br>&gt;&gt; Examples of partial functions are the function square root WHERE square root is restricted to Integers.  If you applied that function to (1, 2, 4, 5, 7, 16), the implementation of that function would apply to a subset (1,4, 16) while the function applied to (2,5,7) would be undefined.  I am however not suggesting that we implement partial functions in general since for the most part the general implementation is of limited use and can easily implemented using Optionals or ‘Either’.  In this case the function closure would be defined through cases (restrictions / defining subsets):<br>&gt;&gt; <br>&gt;&gt; sudo code:<br>&gt;&gt; case x is Integer where x is a perfect square :  Some(square root of x)<br>&gt;&gt; default : None<br>&gt;&gt; <br>&gt;&gt; That is of course a very simple mathematical example of a partial function that is limited by the nature of the types themselves.  <br>&gt;&gt; <br>&gt;&gt; Swift at it’s core is not and likely will never be a programming language that fully supports the functional paradigm, but some simple things that like not forcing programmers to program with flow-control and side-effects can make it easier for those that wish to program functionally to at least extend the language through functional libraries.<br>&gt;&gt; <br>&gt;&gt; There has been a lot of interest in allowing the Swift language to implement switch-expressions rather being forced as a hack to use switch flow control statements.  This proposal allows for that (using match function) while allowing for a more general implementation that allows for greater flexibility. <br>&gt;&gt; <br>&gt;&gt; Flow-Control statements often are implemented from the viewpoint of for certain conditions - execute this block, for other conditions, this block… which leads to the blocks becoming overloaded and doing many things since if you have one flow control statement that covers it then everything gets implemented in one block rather than having two flow control statements.  The functional concept of it is that it is just a function and given a function f(x) you will get y (pure function) where you can test that code and know that no side effects, no state will cause a different result.  This allows for very finite test (and reasoning) to prove that a function is correct or not.  Programming by flow-control and side-effects ultimately leads you to more complexity and less ability to be sure that a testing will fully cover all cases all branches of the code - which results in less software quality.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 2016-02-04, at 11:40:42, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree completely with this analysis. Spot on.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 3, 2016, at 12:39 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m really confused by this proposal. Primarily it really seems to be asking for two things:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   1. Allow closures to skip the &quot;switch item&quot; line, and<br>&gt;&gt;&gt;&gt;   2. Implicit returns within closures<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …plus (3) overloading “map” to operator on single objects and not just collections.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The desired troy example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let weightKg = weightTroy.reduce(0.00) {<br>&gt;&gt;&gt;&gt;     case (let acc, Troy.Pound(let quantity)): acc + Double(quantity) * 0.373<br>&gt;&gt;&gt;&gt;     case (let acc, Troy.Ounce(let quantity)): acc + Double(quantity) * 0.031103<br>&gt;&gt;&gt;&gt;     case (let acc, Troy.Pennyweight(let quantity)): acc + Double(quantity) * 0.001555<br>&gt;&gt;&gt;&gt;     case (let acc, Troy.Grain(let quantity)): acc + Double(quantity) * 0.0000648<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What you can already do today:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let weightKg = weightTroy.reduce(0.00) { acc, troy in<br>&gt;&gt;&gt;&gt;     switch troy {<br>&gt;&gt;&gt;&gt;     case let .Pound(quantity): return acc + Double(quantity) * 0.373<br>&gt;&gt;&gt;&gt;     case let .Ounce(quantity): return acc + Double(quantity) * 0.031103<br>&gt;&gt;&gt;&gt;     case let .Pennyweight(quantity): return acc + Double(quantity) * 0.001555<br>&gt;&gt;&gt;&gt;     case let .Grain(quantity): return acc + Double(quantity) * 0.0000648<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unless I&#39;m misunderstanding some other great value, this seems like a lot of syntax to save typing &quot;switch troy&quot; and &quot;return”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Bingo.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you forget &quot;return&quot;, the compiler will already error for you. I don&#39;t think the desired example brings more clarity either.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As to the initialization example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let str: String = {<br>&gt;&gt;&gt;&gt;     switch($0) {<br>&gt;&gt;&gt;&gt;     case .Cold: return &quot;Too cold&quot;<br>&gt;&gt;&gt;&gt;     case .Hot:  return &quot;Too hot&quot;<br>&gt;&gt;&gt;&gt;     default:    return &quot;Just right&quot;<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }(state)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, the type must be explicit because Swift cannot figure it out. I&#39;d rather address that issue.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For me, I&#39;m really not seeing the value the complexity of the proposal brings.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 2, 2016, at 10:07 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I will wait another 24 hours before resubmitting it (even though this discussion thread is not long)…. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Anyone that had commented on this in the other thread, but not this one — it would be greatly appreciated if at least one comment (yay or nay) were added to this thread.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think the last thread where this was discussed for at least 10 days and had many more comments - already fleshed everything out.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 2016-02-03, at 13:03:18, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Agreed. I really would like this to move forward.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 2, 2016, at 6:59 PM, Denis Nikitenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 from me - I would like to see this discussion continue.  Swift already recognizes the utility of pattern matching for initialization by retaining the ?: operator.  It would be nice to see a more general and flexible solution that is still reasonably concise and doesn’t introduce new keywords and operators - though I’m sure at least some changes to the language would be inevitable.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 29, 2016, at 1:43 AM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The following proposal apparently was not considered widely enough discussed since it was “buried” in a 400 message discussion thread that meandered before coming to the final draft.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As such, to have it reopened — I am restarting the discussion in a new thread to ensure wider discussion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md &lt;https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Pattern Matching Partial Function<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/5fb49432/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>February  7, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Le 4 févr. 2016 à 02:41, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; What we are proposing is not really control flow, but a way of mapping values without side effects concisely. They are partial functions as Craig pointed out, that map every value of input to another value of output. That is, they must have be completely specified and return the same type. Switch statements may not check every output is returning a value which can lead to errors. Because there is one returned type, we are able to use type inference to determine the result type. <br>&gt; <br>&gt; With this construct, it is harder for another programmer to go in and add another statement with side effects into the expression.<br>&gt; <br>&gt; The proposal is powerful in that it provides a very nice way of apply this same concept to values in containers not just individual values, no for-loop is necessary. <br>&gt; <br>&gt; If the proposal is accepted, there will be essentially two closure forms,. the one we are all used to and a new one which uses case and default which is a partial function. <br></p><p>Some might say that since functions can be use in lieu of closures (but not as a trailing one), that would be three types of function with different support for implicit return.<br></p><p>From what I remember, the current proposal comes from a wish to have the equivalent of ?: but with multiple values, which after multiple attempt evolved into:<br></p><p>{ cases 1:  “A”, 2: “B”, 3: “C”, default: “D” }<br></p><p>assuming the possibility of implicit returns. So let’s focus on implicit returns. Implicit returns in such short set of statements is elegant and it is hard for someone new to the code area to break it unintentionally. But, within longer sets of statements, it could be quite easy for one to unwillingly break the code. I have seen some code in bash where someone added logging data for a rare failure; on success the code kept working as intended, but on the rare failure, the code now started to return success due to the implicit return of the logging which was always successful. So I’m bit scared of expanding the current limited support for implicit return; will the compiler guarantee an error if one add code where he should not within the implicit returns. Once bitten, twice shy… More on such guarantee later<br></p><p>The current closure allows implicit returns only for single statement closure, you can have:<br></p><p>{ $0 &gt; 10 }<br>{ $0 &gt; 10 ? true : false }<br></p><p>but even though the resulting code is mainly the same, one cannot do:<br></p><p>{ if $0 &gt; 10 { true } else  { false } } // doesn’t work<br></p><p>which I admit is not that readable, but is in a way is similar to the current switch proposal (not about readability, but about possible use), especially once you start nesting the if with condition ill suited for a switch statement. So if we put aside the not having to write the switch keyword, all the effort to support safe implicit returns for this proposal could be applicable to nested if. Of course at the cost of changing the propose syntax to:<br></p><p>{ switch $0 { case … } }<br></p><p>One example in the proposal contains two statements per conditional path, a let and an implicit return, such thing is currently prohibited in the current supported implicit returns (not sure why)<br></p><p>{ let x=$0; x &gt; 10 } // doesn’t work<br></p><p>Declaring variable is benign so it could be allowed but to simplify lets assume we cannot.<br></p><p>IMHO, with the following rules for implicit returns:<br>- only supported for single statement (value, function) or exhaustive conditional (if, switch) which obey to this rule<br>- all implicit returns must have same type<br>most case should be covered, while protecting the code.<br></p><p>Good examples (according to the rule, but not so as real use cases)<br>{ $0 }<br>{ sqrt($0) }<br>{ if $0 != &quot;data&quot; { &quot;generic&quot; } else { switch $1 { case &quot;r&quot;: &quot;red&quot;; default: &quot;off&quot; }}}<br></p><p>Compile errors:<br>{ print($0); $0 } // multiple statement<br>{ if $0 = 10 { &quot;ten&quot; } } // non-exhaustive<br>{ switch $0 { case &quot;r&quot;: 10; default: &quot;ten&quot; } } // different type for implicit<br></p><p>As mentioned a few times, the parameters for such closure can be currently provided after the closure.<br></p><p>{ $0 &gt; 10 ? &quot;green&quot; : &quot;red&quot; }(10)<br></p><p>But for long closure the parameters seem lost in a far away location, which have been a big deal in the thread. Assuming this implicit return part of this proposal get generalized, could we instead of the dedicated match function have a generic way to feed the parameters to the closure at the start, where it would make sense for the desired switch usage.<br></p><p>let str:String = (state) -&gt; { switch $0 { case .Cold: &quot;Too Cold&quot;; case .Hot: &quot;Too Hot&quot;; default: &quot;Just right&quot; } }<br></p><p>which is not much longer than the current proposal<br></p><p>let str:String = match(state) { case .Cold: &quot;Too Cold&quot;; case .Hot: &quot;Too Hot&quot;; default: &quot;Just right&quot; }<br></p><p>Overloading -&gt; could lead to confusion, but I could not come up with a clearer operator for &quot;feed to&quot;.<br></p><p><br>-<br>Dany<br></p><p>&gt; In one example in this thread a while ago, I took every example from the switch section of the swift book and they were all more simply and concisely done with expressions than statements. I also think this form might be used more than the switch statement once people get comfortable with it and as functional programming becomes more popular. <br>&gt; <br>&gt; With the compact form, for simple mappings, you are able to be even more concise because the word “case” does not need to be repeated. <br>&gt; <br>&gt; - Paul <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February  8, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Am 07.02.2016 um 16:47 schrieb Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Assuming this implicit return part of this proposal get generalized, could we instead of the dedicated match function have a generic way to feed the parameters to the closure at the start, where it would make sense for the desired switch usage.<br>&gt; <br>&gt; let str:String = (state) -&gt; { switch $0 { case .Cold: &quot;Too Cold&quot;; case .Hot: &quot;Too Hot&quot;; default: &quot;Just right&quot; } }<br></p><p>That&#39;s easy, just use the match() function from the proposal:<br></p><p>let str:String = match(state) { switch $0 { case .Cold: &quot;Too Cold&quot;; case .Hot: &quot;Too Hot&quot;; default: &quot;Just right&quot; } }<br></p><p>No new syntax needed for that.<br></p><p>-Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/bcee43f2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>February  8, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Le 8 févr. 2016 à 10:54, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt; <br>&gt; Am 07.02.2016 um 16:47 schrieb Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; Assuming this implicit return part of this proposal get generalized, could we instead of the dedicated match function have a generic way to feed the parameters to the closure at the start, where it would make sense for the desired switch usage.<br>&gt;&gt; <br>&gt;&gt; let str:String = (state) -&gt; { switch $0 { case .Cold: &quot;Too Cold&quot;; case .Hot: &quot;Too Hot&quot;; default: &quot;Just right&quot; } }<br>&gt; <br>&gt; That&#39;s easy, just use the match() function from the proposal:<br>&gt; <br>&gt; let str:String = match(state) { switch $0 { case .Cold: &quot;Too Cold&quot;; case .Hot: &quot;Too Hot&quot;; default: &quot;Just right&quot; } }<br>&gt; <br>&gt; No new syntax needed for that.<br></p><p>As/if the implicit returns is generalized, I feel that match is bit out of place in the for nested if. I should have provided an example to clarify my thought. Here’s one, where the :? do a better job, but this thread has its origin in came people not liking this sometime cryptic operator (which I like to use)<br></p><p>    str = major &gt; 0 ? &quot;Major&quot; : minor &gt; 0 ? &quot;Minor&quot; : &quot;None&quot;<br></p><p>which is ill suited for switch case but doable.<br></p><p>    switch (major,minor) {<br>        case (_, _) where major &gt; 0: str=&quot;Major&quot;<br>        case (_, _) where minor &gt; 0: str=&quot;Minor&quot;<br>        default: str=&quot;None&quot;<br>    }<br></p><p>Assuming that the implicit returns is generalized to all closures (and even functions like getter), of course only for the one matching my safety rule (in short single statement/function call/exhaustive if or switch). The if  can be express as, using the new global match function:<br></p><p>    str = match(major,minor){ if $0 &gt; 0 { &quot;Major&quot; } else if $1 &gt; 0 { &quot;Minor&quot; } else { &quot;None&quot; } }<br></p><p>or using normal inline closure calls:<br></p><p>    str = { if $0 &gt; 0 { &quot;Major&quot; } else if $1 &gt; 0 { &quot;Minor&quot; } else { &quot;None&quot; } }(major,minor)<br></p><p>versus the feeding I wonder about:<br></p><p>    str = (major,minor) -&gt; { if $0 &gt; 0 { &quot;Major&quot; } else if $1 &gt; 0 { &quot;Minor&quot; } else { &quot;None&quot; } }<br></p><p>Maybe it’s just me, but the match function feels a bit weird, in the first version.<br></p><p>Dany<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/72bc2979/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February  9, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Am 09.02.2016 um 01:51 schrieb Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; Le 8 févr. 2016 à 10:54, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 07.02.2016 um 16:47 schrieb Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Assuming this implicit return part of this proposal get generalized, could we instead of the dedicated match function have a generic way to feed the parameters to the closure at the start, where it would make sense for the desired switch usage.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let str:String = (state) -&gt; { switch $0 { case .Cold: &quot;Too Cold&quot;; case .Hot: &quot;Too Hot&quot;; default: &quot;Just right&quot; } }<br>&gt;&gt; <br>&gt;&gt; That&#39;s easy, just use the match() function from the proposal:<br>&gt;&gt; <br>&gt;&gt; let str:String = match(state) { switch $0 { case .Cold: &quot;Too Cold&quot;; case .Hot: &quot;Too Hot&quot;; default: &quot;Just right&quot; } }<br>&gt;&gt; <br>&gt;&gt; No new syntax needed for that.<br>&gt; <br>&gt; As/if the implicit returns is generalized, I feel that match is bit out of place in the for nested if. I should have provided an example to clarify my thought. Here’s one, where the :? do a better job, but this thread has its origin in came people not liking this sometime cryptic operator (which I like to use)<br></p><p>I like :? too, btw.<br></p><p>&gt;     str = major &gt; 0 ? &quot;Major&quot; : minor &gt; 0 ? &quot;Minor&quot; : &quot;None&quot;<br>&gt; <br>&gt; which is ill suited for switch case but doable.<br></p><p>No need to press something into switch which does not fit.<br>The proposal is not about using switch for everything and it is not about replacing the ternary operator. It is more about making a switch expression available.<br></p><p>&gt;     switch (major,minor) {<br>&gt;         case (_, _) where major &gt; 0: str=&quot;Major&quot;<br>&gt;         case (_, _) where minor &gt; 0: str=&quot;Minor&quot;<br>&gt;         default: str=&quot;None&quot;<br>&gt;     }<br></p><p>Rewriting a little bit I don&#39;t think switch looks that bad even for your example:<br></p><p>switch (major,minor) {<br>case _ where major &gt; 0: &quot;Major&quot;<br>case _ where minor &gt; 0: &quot;Minor&quot;<br>default: &quot;None&quot;<br>}<br></p><p><br>&gt; Assuming that the implicit returns is generalized to all closures (and even functions like getter), of course only for the one matching my safety rule (in short single statement/function call/exhaustive if or switch). The if  can be express as, using the new global match function:<br>&gt; <br>&gt;     str = match(major,minor){ if $0 &gt; 0 { &quot;Major&quot; } else if $1 &gt; 0 { &quot;Minor&quot; } else { &quot;None&quot; } }<br>&gt; <br></p><p>Making `if` into an expression (which would be a requirementbhere) has been more or less ruled out by Chris Lattner. <br></p><p><br>&gt; <br>&gt; or using normal inline closure calls:<br>&gt; <br>&gt;     str = { if $0 &gt; 0 { &quot;Major&quot; } else if $1 &gt; 0 { &quot;Minor&quot; } else { &quot;None&quot; } }(major,minor)<br>&gt; <br>&gt; versus the feeding I wonder about:<br>&gt; <br>&gt;     str = (major,minor) -&gt; { if $0 &gt; 0 { &quot;Major&quot; } else if $1 &gt; 0 { &quot;Minor&quot; } else { &quot;None&quot; } }<br>&gt; <br>&gt; Maybe it’s just me, but the match function feels a bit weird, in the first version.<br></p><p>I agree. That&#39;s why it is accompanied by the partial function closure syntax which effectively results in a switch or rather match expression.<br></p><p>-Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/d0513e86/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>February  9, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Le 9 févr. 2016 à 01:00, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt; <br>&gt; Am 09.02.2016 um 01:51 schrieb Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 8 févr. 2016 à 10:54, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 07.02.2016 um 16:47 schrieb Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Assuming this implicit return part of this proposal get generalized, could we instead of the dedicated match function have a generic way to feed the parameters to the closure at the start, where it would make sense for the desired switch usage.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let str:String = (state) -&gt; { switch $0 { case .Cold: &quot;Too Cold&quot;; case .Hot: &quot;Too Hot&quot;; default: &quot;Just right&quot; } }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s easy, just use the match() function from the proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let str:String = match(state) { switch $0 { case .Cold: &quot;Too Cold&quot;; case .Hot: &quot;Too Hot&quot;; default: &quot;Just right&quot; } }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No new syntax needed for that.<br>&gt;&gt; <br>&gt;&gt; As/if the implicit returns is generalized, I feel that match is bit out of place in the for nested if. I should have provided an example to clarify my thought. Here’s one, where the :? do a better job, but this thread has its origin in came people not liking this sometime cryptic operator (which I like to use)<br>&gt; <br>&gt; I like :? too, btw.<br>&gt; <br>&gt;&gt;     str = major &gt; 0 ? &quot;Major&quot; : minor &gt; 0 ? &quot;Minor&quot; : &quot;None&quot;<br>&gt;&gt; <br>&gt;&gt; which is ill suited for switch case but doable.<br>&gt; <br>&gt; No need to press something into switch which does not fit.<br>&gt; The proposal is not about using switch for everything and it is not about replacing the ternary operator. It is more about making a switch expression available.<br></p><p>Of course, it’s not about what should remain unmentioned (saying it out loud three time may cause that thread to come back and haunt us).<br>But while the proposal can be mainly read as:<br></p><p>- provide a special case-list closure (aka pattern matching partial function dedicated to switch) and expand implicit returns support for this closure type only.<br></p><p>it could also be read as<br></p><p>- expand the implicit returns support for all closure, allow such closure to skip the switch keyword; be the case list (aka pattern matching partial function).<br></p><p>I do think that safely expanding the implicit returns support in either the dedicated closure or the general closure would be roughly the same.<br></p><p>I’m not sure where I stand on the switch-less case-list closure, but I am afraid that providing such dedicated closure syntax may set a precedent and cause others to want yet another dedicated closure syntax for their own goal; how do we consider a special closure syntax as acceptable, how many of them are too many. This is why, I’m looking at it from a wide angle view; an expanded implicit returns support safely done could benefit other general cases. Doing this as a first step, will miss 50% of this proposal (still need to use switch ($0)), but the overall use case goal will still be achieved; being able to do something like; let something = condition ? data1 : data2; for more complex scenarios.<br></p><p>I’m having trouble following my own train of thought, but I think it’s leading me toward  having the &quot;safely expanded implicit returns » portion extracted as its own proposal for general purpose, which this proposal can then rely on.<br></p><p>&gt; <br>&gt;&gt;     switch (major,minor) {<br>&gt;&gt;         case (_, _) where major &gt; 0: str=&quot;Major&quot;<br>&gt;&gt;         case (_, _) where minor &gt; 0: str=&quot;Minor&quot;<br>&gt;&gt;         default: str=&quot;None&quot;<br>&gt;&gt;     }<br>&gt; <br>&gt; Rewriting a little bit I don&#39;t think switch looks that bad even for your example:<br>&gt; <br>&gt; switch (major,minor) {<br>&gt; case _ where major &gt; 0: &quot;Major&quot;<br>&gt; case _ where minor &gt; 0: &quot;Minor&quot;<br>&gt; default: &quot;None&quot;<br>&gt; }<br>&gt; <br>&gt; <br>&gt;&gt; Assuming that the implicit returns is generalized to all closures (and even functions like getter), of course only for the one matching my safety rule (in short single statement/function call/exhaustive if or switch). The if  can be express as, using the new global match function:<br>&gt;&gt; <br>&gt;&gt;     str = match(major,minor){ if $0 &gt; 0 { &quot;Major&quot; } else if $1 &gt; 0 { &quot;Minor&quot; } else { &quot;None&quot; } }<br>&gt;&gt; <br>&gt; <br>&gt; Making `if` into an expression (which would be a requirementbhere) has been more or less ruled out by Chris Lattner. <br></p><p>I recall some oppositions early on, but I do not recall if it was before the thread move into closure territory.<br>Don’t forget my example here as two big if:<br>- if we generalized the implicit return done safely to any closure.<br>- if we try to call the closure passing the parameters with the only (to be) available prefix syntax<br></p><p>Dany<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; or using normal inline closure calls:<br>&gt;&gt; <br>&gt;&gt;     str = { if $0 &gt; 0 { &quot;Major&quot; } else if $1 &gt; 0 { &quot;Minor&quot; } else { &quot;None&quot; } }(major,minor)<br>&gt;&gt; <br>&gt;&gt; versus the feeding I wonder about:<br>&gt;&gt; <br>&gt;&gt;     str = (major,minor) -&gt; { if $0 &gt; 0 { &quot;Major&quot; } else if $1 &gt; 0 { &quot;Minor&quot; } else { &quot;None&quot; } }<br>&gt;&gt; <br>&gt;&gt; Maybe it’s just me, but the match function feels a bit weird, in the first version.<br>&gt; <br>&gt; I agree. That&#39;s why it is accompanied by the partial function closure syntax which effectively results in a switch or rather match expression.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/4fc6063b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February  9, 2016 at 12:00:00pm</p></header><div class="content"><p>The ternary expression can also be accomplished by this match:<br></p><p>    str = match((major &gt; 0, minor &gt; 0)) {<br>        case (true, _): &quot;Major&quot;<br>        case (_, true): &quot;Minor&quot;<br>        default: &quot;None&quot;<br>    }<br></p><p>Or using &quot;cases&quot;:<br></p><p>    str = match((major &gt; 0, minor &gt; 0)) {<br>        cases (true, _): &quot;Major&quot;, (_, true): &quot;Minor&quot;<br>        default: &quot;None&quot;<br>    }<br></p><p>At least the former version is to me clearer than the original ternary expression.<br>While the switch expression &quot;forces&quot; you to format the code whereas a ternary operator doesn&#39;t.<br></p><p>&quot;correctly&quot; formatted:<br></p><p>    str = major &gt; 0 ? &quot;Major&quot; :<br>             minor &gt; 0 ? &quot;Minor&quot; : &quot;None&quot;<br></p><p>But as Thorsten has already said the proposal is not about removing the ternary operator.<br></p><p>- Maximilian<br></p><p>&gt; Am 09.02.2016 um 01:51 schrieb Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; Le 8 févr. 2016 à 10:54, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 07.02.2016 um 16:47 schrieb Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Assuming this implicit return part of this proposal get generalized, could we instead of the dedicated match function have a generic way to feed the parameters to the closure at the start, where it would make sense for the desired switch usage.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let str:String = (state) -&gt; { switch $0 { case .Cold: &quot;Too Cold&quot;; case .Hot: &quot;Too Hot&quot;; default: &quot;Just right&quot; } }<br>&gt;&gt; <br>&gt;&gt; That&#39;s easy, just use the match() function from the proposal:<br>&gt;&gt; <br>&gt;&gt; let str:String = match(state) { switch $0 { case .Cold: &quot;Too Cold&quot;; case .Hot: &quot;Too Hot&quot;; default: &quot;Just right&quot; } }<br>&gt;&gt; <br>&gt;&gt; No new syntax needed for that.<br>&gt; <br>&gt; As/if the implicit returns is generalized, I feel that match is bit out of place in the for nested if. I should have provided an example to clarify my thought. Here’s one, where the :? do a better job, but this thread has its origin in came people not liking this sometime cryptic operator (which I like to use)<br>&gt; <br>&gt;     str = major &gt; 0 ? &quot;Major&quot; : minor &gt; 0 ? &quot;Minor&quot; : &quot;None&quot;<br>&gt; <br>&gt; which is ill suited for switch case but doable.<br>&gt; <br>&gt;     switch (major,minor) {<br>&gt;         case (_, _) where major &gt; 0: str=&quot;Major&quot;<br>&gt;         case (_, _) where minor &gt; 0: str=&quot;Minor&quot;<br>&gt;         default: str=&quot;None&quot;<br>&gt;     }<br>&gt; <br>&gt; Assuming that the implicit returns is generalized to all closures (and even functions like getter), of course only for the one matching my safety rule (in short single statement/function call/exhaustive if or switch). The if  can be express as, using the new global match function:<br>&gt; <br>&gt;     str = match(major,minor){ if $0 &gt; 0 { &quot;Major&quot; } else if $1 &gt; 0 { &quot;Minor&quot; } else { &quot;None&quot; } }<br>&gt; <br>&gt; or using normal inline closure calls:<br>&gt; <br>&gt;     str = { if $0 &gt; 0 { &quot;Major&quot; } else if $1 &gt; 0 { &quot;Minor&quot; } else { &quot;None&quot; } }(major,minor)<br>&gt; <br>&gt; versus the feeding I wonder about:<br>&gt; <br>&gt;     str = (major,minor) -&gt; { if $0 &gt; 0 { &quot;Major&quot; } else if $1 &gt; 0 { &quot;Minor&quot; } else { &quot;None&quot; } }<br>&gt; <br>&gt; Maybe it’s just me, but the match function feels a bit weird, in the first version.<br>&gt; <br>&gt; Dany<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/247c3ab3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>February  4, 2016 at 12:00:00pm</p></header><div class="content"><p>Yes, I assume that we understand all of this as a starting point for this discussion. No need to explain what pure functions  are. And no need to import the functional vs. imperative holy wars here; they have beaten to death elsewhere!<br></p><p>I like pure functional programming too. And if Swift were Scheme or Haskell, then building switch expressions out of these partial functions would make good sense.<br></p><p>But Swift isn’t, and it doesn’t. Despite its support for functional style, Swift is a language that uses expressions — not lambdas — as its basic building block.<br></p><p>Thus, while this is true:<br></p><p>&gt; There has been a lot of interest in allowing the Swift language to implement switch-expressions rather being forced as a hack to use switch flow control statements.  This proposal allows for that (using match function)<br></p><p>…it’s putting the cart before the horse in the Swift world. If you took that partial expression + match function approach you’re proposed to build switch expressions, it would be the only feature of Swift where an expression-like construct is built from lambdas rather than the other way around. And it would stick out like a sore thumb.<br></p><p>This is not true:<br></p><p>&gt; while allowing for a more general implementation that allows for greater flexibility. <br></p><p>Switch expressions and the “partial function” closures proposed here are trivially equivalent. It’s easy to build one out of the other, and neither offers greater flexibility than the other. It’s just that one is more concise/natural if your code is mostly built out of lambdas, and the other is more concise/natural if it’s mostly expressions.<br></p><p>This is a misdescription of what Swift does:<br></p><p>&gt; The fact that Swift has a special allowance to set a ‘let’ to nil, then allow it to be set once again<br></p><p>Semantically, the “let” is not set to _anything_ on any code path where its initialization is not guaranteed. There is no moment when an uninitialized let var is observably nil (unless you start doing unsafe ops on raw memory, in which case all behavioral guarantees go out the window).<br></p><p>Though laid out sequentially, a series of statements which do nothing but initialize one or more let vars are a logically equivalent to a single expression that initializes them. In fact, I believe it’s the case that Swift’s lovely struct semantics are such that if you (1) don’t use classes and (2) only use “let” in your local vars (though “var” is fine on struct properties!), then your is secretly all pure functions — even when it has things that look like assignments.<br></p><p>Fundamentally, this switch expr vs. partial functions debate should not be about whether functional programming is better and everyone should do it, but about what solves problems for Swift programmers in a way that’s consistent with Swift’s programmer model.<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br>&gt; On Feb 4, 2016, at 12:52 AM, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt; <br>&gt; A switch statement is a a flow-control construct which could also be viewed as a more limited implementation of switch expression that only allows the return type of void/Unit.  And the only way to make the switch statement useful is to program by virtue of side-effects - such as mutating a variable.  The fact that Swift has a special allowance to set a ‘let’ to nil, then allow it to be set once again to another value as a hack for the most part because of limitations to the fact that it contains flow-control elements with where expressions / functions would allow for the same thing to be done by programming without side-effects.  <br>&gt; <br>&gt; For example, “switch” could be viewed as <br>&gt; <br>&gt; func switch&lt;T,U&gt;(x: T, mapping: T -&gt; U) -&gt; Void {<br>&gt;     return mapping(x)<br>&gt; }<br>&gt; <br>&gt; where the only way to do anything useful is to implement the closure containing something that causes side-effects.<br>&gt; <br>&gt; <br>&gt; Functions/closures etc. foundations come from functional programming constructs, and like those constructs there is a mathematical concept allowing for the defining of a function f(X’) -&gt; Y where X’ is maps only part of the set of values in the set X.  <br>&gt; <br>&gt; Examples of partial functions are the function square root WHERE square root is restricted to Integers.  If you applied that function to (1, 2, 4, 5, 7, 16), the implementation of that function would apply to a subset (1,4, 16) while the function applied to (2,5,7) would be undefined.  I am however not suggesting that we implement partial functions in general since for the most part the general implementation is of limited use and can easily implemented using Optionals or ‘Either’.  In this case the function closure would be defined through cases (restrictions / defining subsets):<br>&gt; <br>&gt; sudo code:<br>&gt; case x is Integer where x is a perfect square :  Some(square root of x)<br>&gt; default : None<br>&gt; <br>&gt; That is of course a very simple mathematical example of a partial function that is limited by the nature of the types themselves.  <br>&gt; <br>&gt; Swift at it’s core is not and likely will never be a programming language that fully supports the functional paradigm, but some simple things that like not forcing programmers to program with flow-control and side-effects can make it easier for those that wish to program functionally to at least extend the language through functional libraries.<br>&gt; <br>&gt; There has been a lot of interest in allowing the Swift language to implement switch-expressions rather being forced as a hack to use switch flow control statements.  This proposal allows for that (using match function) while allowing for a more general implementation that allows for greater flexibility. <br>&gt; <br>&gt; Flow-Control statements often are implemented from the viewpoint of for certain conditions - execute this block, for other conditions, this block… which leads to the blocks becoming overloaded and doing many things since if you have one flow control statement that covers it then everything gets implemented in one block rather than having two flow control statements.  The functional concept of it is that it is just a function and given a function f(x) you will get y (pure function) where you can test that code and know that no side effects, no state will cause a different result.  This allows for very finite test (and reasoning) to prove that a function is correct or not.  Programming by flow-control and side-effects ultimately leads you to more complexity and less ability to be sure that a testing will fully cover all cases all branches of the code - which results in less software quality.<br>&gt; <br>&gt; <br>&gt;&gt; On 2016-02-04, at 11:40:42, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree completely with this analysis. Spot on.<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 3, 2016, at 12:39 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m really confused by this proposal. Primarily it really seems to be asking for two things:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   1. Allow closures to skip the &quot;switch item&quot; line, and<br>&gt;&gt;&gt;   2. Implicit returns within closures<br>&gt;&gt; <br>&gt;&gt; …plus (3) overloading “map” to operator on single objects and not just collections.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The desired troy example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let weightKg = weightTroy.reduce(0.00) {<br>&gt;&gt;&gt;     case (let acc, Troy.Pound(let quantity)): acc + Double(quantity) * 0.373<br>&gt;&gt;&gt;     case (let acc, Troy.Ounce(let quantity)): acc + Double(quantity) * 0.031103<br>&gt;&gt;&gt;     case (let acc, Troy.Pennyweight(let quantity)): acc + Double(quantity) * 0.001555<br>&gt;&gt;&gt;     case (let acc, Troy.Grain(let quantity)): acc + Double(quantity) * 0.0000648<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What you can already do today:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let weightKg = weightTroy.reduce(0.00) { acc, troy in<br>&gt;&gt;&gt;     switch troy {<br>&gt;&gt;&gt;     case let .Pound(quantity): return acc + Double(quantity) * 0.373<br>&gt;&gt;&gt;     case let .Ounce(quantity): return acc + Double(quantity) * 0.031103<br>&gt;&gt;&gt;     case let .Pennyweight(quantity): return acc + Double(quantity) * 0.001555<br>&gt;&gt;&gt;     case let .Grain(quantity): return acc + Double(quantity) * 0.0000648<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unless I&#39;m misunderstanding some other great value, this seems like a lot of syntax to save typing &quot;switch troy&quot; and &quot;return”.<br>&gt;&gt; <br>&gt;&gt; Bingo.<br>&gt;&gt; <br>&gt;&gt;&gt; If you forget &quot;return&quot;, the compiler will already error for you. I don&#39;t think the desired example brings more clarity either.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As to the initialization example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let str: String = {<br>&gt;&gt;&gt;     switch($0) {<br>&gt;&gt;&gt;     case .Cold: return &quot;Too cold&quot;<br>&gt;&gt;&gt;     case .Hot:  return &quot;Too hot&quot;<br>&gt;&gt;&gt;     default:    return &quot;Just right&quot;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }(state)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, the type must be explicit because Swift cannot figure it out. I&#39;d rather address that issue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For me, I&#39;m really not seeing the value the complexity of the proposal brings.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 2, 2016, at 10:07 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I will wait another 24 hours before resubmitting it (even though this discussion thread is not long)…. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Anyone that had commented on this in the other thread, but not this one — it would be greatly appreciated if at least one comment (yay or nay) were added to this thread.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think the last thread where this was discussed for at least 10 days and had many more comments - already fleshed everything out.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 2016-02-03, at 13:03:18, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Agreed. I really would like this to move forward.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Feb 2, 2016, at 6:59 PM, Denis Nikitenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; +1 from me - I would like to see this discussion continue.  Swift already recognizes the utility of pattern matching for initialization by retaining the ?: operator.  It would be nice to see a more general and flexible solution that is still reasonably concise and doesn’t introduce new keywords and operators - though I’m sure at least some changes to the language would be inevitable.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 29, 2016, at 1:43 AM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The following proposal apparently was not considered widely enough discussed since it was “buried” in a 400 message discussion thread that meandered before coming to the final draft.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As such, to have it reopened — I am restarting the discussion in a new thread to ensure wider discussion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md &lt;https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Pattern Matching Partial Function<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/3562c763/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February  3, 2016 at 07:00:00am</p></header><div class="content"><p>Hi Craig, <br></p><p>the following sentence is a bit misleading as it makes the feature seem a special ability on functions which accept closures which I do not think it should be.<br></p><p>&gt; Am 29.01.2016 um 07:43 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Any function which accepts a closure would also be able to accept a closure composed of partial functions defined usingcase/default syntax used in switch-case.<br></p><p>I think it should be a new feature how unary closures can be written, so I would reword it a little bit:<br></p><p>&quot;Any closure that takes one argument can be composed of ...&quot;<br></p><p>This would make your example of using it with reduce() invalid, though, but I think this would create ambiguities with cases where the closure is actually called with a tuple as single argument anyway (similar to the problems of the current autosplatting of tuples as function arguments which Chris want&#39;s to remove because of the subtle problems this introduces). It probably would be sufficient to just use match() within the reduction closure.<br></p><p>I still don&#39;t like the shortened &quot;cases&quot; variant and would prefer to drop it or at least replace or extend the match() example with a standard variant making it look like a &quot;real&quot; case expression.<br></p><p>-Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/80de939f/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
