<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e4a1f3ac9e9faed38980dbf9aa80d72e?s=50"></div><header><strong>Warning for possible overflow or optional</strong> from <string>Stéphane Lizeray</string> &lt;stephane at lizeray.net&gt;<p>February 16, 2016 at 01:00:00pm</p></header><div class="content"><p>Hello,<br></p><p><br>Don’t you think that the compiler should emit a warning for a possible overflow in the following code?<br></p><p><br>func foo(x:UInt16) {<br></p><p>	let y = Int16(x)		&lt;— Shouldn’t we have a warning here? Or an optional?<br>	print(y)<br>}<br></p><p>This code is very very fragile and Swift is supposed to bring safety?<br></p><p><br>Thanks,<br></p><p><br>Stéphane<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/c108a4e2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7321934b88ca8da079d7b89926501a9c?s=50"></div><header><strong>Warning for possible overflow or optional</strong> from <string>David Turnbull</string> &lt;dturnbull at gmail.com&gt;<p>February 16, 2016 at 10:00:00am</p></header><div class="content"><p>This is perfectly safe since it&#39;s checked at runtime. If you don&#39;t want it<br>checked at runtime you can use Int16(bitPattern: x).<br></p><p>I just finished writing the inflate algorithm in Swift. With your<br>suggestion I would have used bitPattern or truncatingBitPattern everywhere<br>to bypass warnings and missed at least two times where Swift caught a<br>mistake a runtime. C API users would have a similar problem.<br></p><p>-david  https://github.com/AE9RB/SwiftGL<br></p><p>On Tue, Feb 16, 2016 at 4:45 AM, Stéphane Lizeray &lt;swift-evolution at swift.org<br>&gt; wrote:<br></p><p>&gt; Hello,<br>&gt;<br>&gt;<br>&gt; Don’t you think that the compiler should emit a warning for a possible<br>&gt; overflow in the following code?<br>&gt;<br>&gt;<br>&gt; func foo(x:UInt16) {<br>&gt;<br>&gt; let y = Int16(x) &lt;— Shouldn’t we have a warning here? Or an optional?<br>&gt; print(y)<br>&gt; }<br>&gt;<br>&gt; This code is very very fragile and Swift is supposed to bring safety?<br>&gt;<br>&gt;<br>&gt; Thanks,<br>&gt;<br>&gt;<br>&gt; Stéphane<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/61774501/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e4a1f3ac9e9faed38980dbf9aa80d72e?s=50"></div><header><strong>Warning for possible overflow or optional</strong> from <string>Stéphane Lizeray</string> &lt;stephane at lizeray.net&gt;<p>February 16, 2016 at 07:00:00pm</p></header><div class="content"><p>Safety does not mean you can easily write code that crashes once it is deployed…. <br> <br>Safety means that the compiler helps you to avoid programming errors as much as possible. This is what Optional is all about.<br></p><p>In this case, I should have used an Int32 instead of converting an UInt16 to an Int16….<br></p><p>Int16(UInt16:) should be either a failable constructor or the compiler should emit a warning.<br></p><p><br>Stéphane<br></p><p><br></p><p><br>&gt; On 16 Feb 2016, at 19:02, David Turnbull &lt;dturnbull at gmail.com&gt; wrote:<br>&gt; <br>&gt; This is perfectly safe since it&#39;s checked at runtime. If you don&#39;t want it checked at runtime you can use Int16(bitPattern: x).<br>&gt; <br>&gt; I just finished writing the inflate algorithm in Swift. With your suggestion I would have used bitPattern or truncatingBitPattern everywhere to bypass warnings and missed at least two times where Swift caught a mistake a runtime. C API users would have a similar problem.<br>&gt; <br>&gt; -david  https://github.com/AE9RB/SwiftGL &lt;https://github.com/AE9RB/SwiftGL&gt;<br>&gt; <br>&gt; On Tue, Feb 16, 2016 at 4:45 AM, Stéphane Lizeray &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hello,<br>&gt; <br>&gt; <br>&gt; Don’t you think that the compiler should emit a warning for a possible overflow in the following code?<br>&gt; <br>&gt; <br>&gt; func foo(x:UInt16) {<br>&gt; <br>&gt; 	let y = Int16(x)		&lt;— Shouldn’t we have a warning here? Or an optional?<br>&gt; 	print(y)<br>&gt; }<br>&gt; <br>&gt; This code is very very fragile and Swift is supposed to bring safety?<br>&gt; <br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; <br>&gt; Stéphane<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/803c2ddd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Warning for possible overflow or optional</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 16, 2016 at 06:00:00pm</p></header><div class="content"><p>&quot;Int16(UInt16:) should be either a failable constructor or the compiler<br>should emit a warning.&quot;<br></p><p>That feels right to me (failable constructor) from a safety standpoint,<br>make you code to deal with it explicitly instead of being surprised by a<br>runtime failure that you make not detect easily in testing, etc.<br></p><p>On Tue, Feb 16, 2016 at 10:20 AM Stéphane Lizeray &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt;<br>&gt; Safety does not mean you can easily write code that crashes once it is<br>&gt; deployed….<br>&gt;<br>&gt; Safety means that the compiler helps you to avoid programming errors as<br>&gt; much as possible. This is what Optional is all about.<br>&gt;<br>&gt; In this case, I should have used an Int32 instead of converting an UInt16<br>&gt; to an Int16….<br>&gt;<br>&gt; Int16(UInt16:) should be either a failable constructor or the compiler<br>&gt; should emit a warning.<br>&gt;<br>&gt;<br>&gt; Stéphane<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 16 Feb 2016, at 19:02, David Turnbull &lt;dturnbull at gmail.com&gt; wrote:<br>&gt;<br>&gt; This is perfectly safe since it&#39;s checked at runtime. If you don&#39;t want it<br>&gt; checked at runtime you can use Int16(bitPattern: x).<br>&gt;<br>&gt; I just finished writing the inflate algorithm in Swift. With your<br>&gt; suggestion I would have used bitPattern or truncatingBitPattern everywhere<br>&gt; to bypass warnings and missed at least two times where Swift caught a<br>&gt; mistake a runtime. C API users would have a similar problem.<br>&gt;<br>&gt; -david  https://github.com/AE9RB/SwiftGL<br>&gt;<br>&gt; On Tue, Feb 16, 2016 at 4:45 AM, Stéphane Lizeray &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hello,<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Don’t you think that the compiler should emit a warning for a possible<br>&gt;&gt; overflow in the following code?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; func foo(x:UInt16) {<br>&gt;&gt;<br>&gt;&gt; let y = Int16(x) &lt;— Shouldn’t we have a warning here? Or an optional?<br>&gt;&gt; print(y)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This code is very very fragile and Swift is supposed to bring safety?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Stéphane<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/75ada48a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7321934b88ca8da079d7b89926501a9c?s=50"></div><header><strong>Warning for possible overflow or optional</strong> from <string>David Turnbull</string> &lt;dturnbull at gmail.com&gt;<p>February 16, 2016 at 11:00:00am</p></header><div class="content"><p>Can you show some examples where and why you use not-Int types and this is<br>a problem? What you&#39;re suggesting will be a burden to those of us who need<br>bitwise optimizations or work with C APIs.<br></p><p>My last week was spent reading files with huffman coding. So I had no<br>choice but to use bitwise operations. My experience is that Swift got this<br>right (except for &quot;truncatingBitPattern&quot; taking up 25% of an 80 column<br>line).<br></p><p>So my question is, &quot;why are you not using Int?&quot; There&#39;s plenty of use<br>cases, you just haven&#39;t stated yours so we can&#39;t understand why the current<br>system is failing you.<br></p><p>Safety does not mean you can easily write code that crashes once it is<br>&gt; deployed….<br></p><p><br>var a = [Int](); a[0]=99<br></p><p>That was pretty easy. I don&#39;t buy into this argument. If you don&#39;t want an<br>out of bounds error, you either make sure you don&#39;t math your way out of<br>bounds or you check every time before you subscript. I don&#39;t see why an<br>integer conversion should be any different.<br></p><p>-david<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/6dde1744/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Warning for possible overflow or optional</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 16, 2016 at 07:00:00pm</p></header><div class="content"><p>I believe you stated that you ran across at least two times that runtime<br>checks caught a narrowing error (e.g. overflow) in your recent work. I<br>support runtime checks however I feel in the case of operations that could<br>have a narrowing issue using a failable constructor makes sense. It puts<br>you control in how to deal with a narrowing error. You could assert if you<br>so want (much like what happens now) or you could deal with the edge case.<br>Swift makes the code to deal with a failable  initializer generally trivial.<br></p><p>It makes you think about this very real pitfall (in some problem<br>domains) when going between numerical types.<br></p><p>The issue of why are you using unsigned, etc. is orthogonal to this issue.<br>If these types exist in the language folks will use them and it should be<br>safe / consistent for them when they do.<br></p><p>-Shawn<br></p><p>On Tue, Feb 16, 2016 at 11:11 AM David Turnbull &lt;dturnbull at gmail.com&gt; wrote:<br></p><p>&gt; Can you show some examples where and why you use not-Int types and this is<br>&gt; a problem? What you&#39;re suggesting will be a burden to those of us who need<br>&gt; bitwise optimizations or work with C APIs.<br>&gt;<br>&gt; My last week was spent reading files with huffman coding. So I had no<br>&gt; choice but to use bitwise operations. My experience is that Swift got this<br>&gt; right (except for &quot;truncatingBitPattern&quot; taking up 25% of an 80 column<br>&gt; line).<br>&gt;<br>&gt; So my question is, &quot;why are you not using Int?&quot; There&#39;s plenty of use<br>&gt; cases, you just haven&#39;t stated yours so we can&#39;t understand why the current<br>&gt; system is failing you.<br>&gt;<br>&gt; Safety does not mean you can easily write code that crashes once it is<br>&gt;&gt; deployed….<br>&gt;<br>&gt;<br>&gt; var a = [Int](); a[0]=99<br>&gt;<br>&gt; That was pretty easy. I don&#39;t buy into this argument. If you don&#39;t want an<br>&gt; out of bounds error, you either make sure you don&#39;t math your way out of<br>&gt; bounds or you check every time before you subscript. I don&#39;t see why an<br>&gt; integer conversion should be any different.<br>&gt;<br>&gt; -david<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/2449514f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Warning for possible overflow or optional</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 16, 2016 at 07:00:00pm</p></header><div class="content"><p>Thinking a little more about this how about just adding failable<br>constructors so it becomes easier to deal with runtime narrowing errors for<br>those that need it? (that was my main issue I ran across when using these<br>classes in an early project, I had to put code around things to deal with<br>the edge case that the library was already obviously doing)<br></p><p>extension UInt16 {<br>    public init(_ v: UInt8)<br>    public init(_ v: Int8)<br>    public init(_ v: Int16)<br>    public init(_ v: UInt32)                    // runtime narrowing check,<br>asserts BOOOM<br>    public init?(validatingValue: UInt32)       // runtime narrowing check,<br>failable initializer<br>    public init(truncatingBitPattern: UInt32)   // narrowing &quot;fixup&quot;<br>initializer<br>    public init(_ v: Int32)                     // runtime narrowing check,<br>asserts BOOOM<br>    public init?(validatingValue: UInt32)       // runtime narrowing check,<br>failable initializer<br>    public init(truncatingBitPattern: Int32)    // narrowing &quot;fixup&quot;<br>initializer<br> ...<br>    public init(bitPattern: Int16)              // I know what I doing!<br>(aka live dangerously)<br>}<br></p><p>Ideally – to me – you would want the failable initializers to be the<br>default ones available with the boom crash ones being something you could<br>switch to use much like the the other special &quot;i know what I am doing<br>ones&quot;. Not sure of the naming to use for such an initializer however.<br></p><p>-Shawn<br></p><p><br>On Tue, Feb 16, 2016 at 11:28 AM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br></p><p>&gt; I believe you stated that you ran across at least two times that runtime<br>&gt; checks caught a narrowing error (e.g. overflow) in your recent work. I<br>&gt; support runtime checks however I feel in the case of operations that could<br>&gt; have a narrowing issue using a failable constructor makes sense. It puts<br>&gt; you control in how to deal with a narrowing error. You could assert if you<br>&gt; so want (much like what happens now) or you could deal with the edge case.<br>&gt; Swift makes the code to deal with a failable  initializer generally trivial.<br>&gt;<br>&gt; It makes you think about this very real pitfall (in some problem<br>&gt; domains) when going between numerical types.<br>&gt;<br>&gt; The issue of why are you using unsigned, etc. is orthogonal to this issue.<br>&gt; If these types exist in the language folks will use them and it should be<br>&gt; safe / consistent for them when they do.<br>&gt;<br>&gt;<br>&gt; -Shawn<br>&gt;<br>&gt; On Tue, Feb 16, 2016 at 11:11 AM David Turnbull &lt;dturnbull at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Can you show some examples where and why you use not-Int types and this<br>&gt;&gt; is a problem? What you&#39;re suggesting will be a burden to those of us who<br>&gt;&gt; need bitwise optimizations or work with C APIs.<br>&gt;&gt;<br>&gt;&gt; My last week was spent reading files with huffman coding. So I had no<br>&gt;&gt; choice but to use bitwise operations. My experience is that Swift got this<br>&gt;&gt; right (except for &quot;truncatingBitPattern&quot; taking up 25% of an 80 column<br>&gt;&gt; line).<br>&gt;&gt;<br>&gt;&gt; So my question is, &quot;why are you not using Int?&quot; There&#39;s plenty of use<br>&gt;&gt; cases, you just haven&#39;t stated yours so we can&#39;t understand why the current<br>&gt;&gt; system is failing you.<br>&gt;&gt;<br>&gt;&gt; Safety does not mean you can easily write code that crashes once it is<br>&gt;&gt;&gt; deployed….<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; var a = [Int](); a[0]=99<br>&gt;&gt;<br>&gt;&gt; That was pretty easy. I don&#39;t buy into this argument. If you don&#39;t want<br>&gt;&gt; an out of bounds error, you either make sure you don&#39;t math your way out of<br>&gt;&gt; bounds or you check every time before you subscript. I don&#39;t see why an<br>&gt;&gt; integer conversion should be any different.<br>&gt;&gt;<br>&gt;&gt; -david<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/2db17617/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Warning for possible overflow or optional</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 16, 2016 at 08:00:00pm</p></header><div class="content"><p>Ok one last reply to myself...<br></p><p>public class Int16 {<br>    public init(_ v: UInt8) {}<br>    public init(_ v: Int8) {}<br></p><p>    public init?(_ v: UInt16) {...on overflow return nil...}<br>    public init(assertValue: UInt16) {...on overflow assert...} // I think<br>we could just drop this<br>    public init(truncatingValue: UInt16) {...on overflow truncate, alway<br>positive...}<br></p><p>    public init?(_ v: Int32) {...on overflow return nil...}<br>    public init(assertValue: Int32) {...on overflow assert...} // I think<br>we could just drop this<br>    public init(truncatingValue: Int32) {...on overflow truncate, maintain<br>sign...}<br></p><p>    public init?(_ v: UInt32) {...on overflow return nil...}<br>    public init(assertValue: UInt32) {...on overflow assert...} // I think<br>we could just drop this<br>    public init(truncatingValue: UInt32) {...on overflow truncate, alway<br>positive...}<br></p><p>    ...others...<br></p><p>    public init(bitPattern: UInt16) {...close your eyes and copy the<br>bits...}<br>}<br></p><p><br>let unsigned32 = UInt32(UInt16.max + 50)<br></p><p>guard let foo = Int16(unsigned32) else {<br>    throw Blah ...or... assert(&quot;BOOM&quot;)<br>}<br>...do stuff...<br></p><p>...or...<br></p><p>if let foo = Int16(unsigned32) {<br>    ...do stuff...<br>}<br>else {<br>    ...handle error...<br>}<br></p><p>...or...<br></p><p>let foo = Int16(truncatingValue: unsigned32)<br>...do stuff...<br></p><p>...or...<br></p><p>let foo = Int16(assertValue: unsigned32) //again I think we could just drop<br>this<br>...do stuff unless I just went boom...<br></p><p><br>On Tue, Feb 16, 2016 at 11:57 AM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br></p><p>&gt; Thinking a little more about this how about just adding failable<br>&gt; constructors so it becomes easier to deal with runtime narrowing errors for<br>&gt; those that need it? (that was my main issue I ran across when using these<br>&gt; classes in an early project, I had to put code around things to deal with<br>&gt; the edge case that the library was already obviously doing)<br>&gt;<br>&gt; extension UInt16 {<br>&gt;     public init(_ v: UInt8)<br>&gt;     public init(_ v: Int8)<br>&gt;     public init(_ v: Int16)<br>&gt;     public init(_ v: UInt32)                    // runtime narrowing<br>&gt; check, asserts BOOOM<br>&gt;     public init?(validatingValue: UInt32)       // runtime narrowing<br>&gt; check, failable initializer<br>&gt;     public init(truncatingBitPattern: UInt32)   // narrowing &quot;fixup&quot;<br>&gt; initializer<br>&gt;     public init(_ v: Int32)                     // runtime narrowing<br>&gt; check, asserts BOOOM<br>&gt;     public init?(validatingValue: UInt32)       // runtime narrowing<br>&gt; check, failable initializer<br>&gt;     public init(truncatingBitPattern: Int32)    // narrowing &quot;fixup&quot;<br>&gt; initializer<br>&gt;  ...<br>&gt;     public init(bitPattern: Int16)              // I know what I doing!<br>&gt; (aka live dangerously)<br>&gt; }<br>&gt;<br>&gt; Ideally – to me – you would want the failable initializers to be the<br>&gt; default ones available with the boom crash ones being something you could<br>&gt; switch to use much like the the other special &quot;i know what I am doing<br>&gt; ones&quot;. Not sure of the naming to use for such an initializer however.<br>&gt;<br>&gt;<br>&gt; -Shawn<br>&gt;<br>&gt;<br>&gt; On Tue, Feb 16, 2016 at 11:28 AM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I believe you stated that you ran across at least two times that runtime<br>&gt;&gt; checks caught a narrowing error (e.g. overflow) in your recent work. I<br>&gt;&gt; support runtime checks however I feel in the case of operations that could<br>&gt;&gt; have a narrowing issue using a failable constructor makes sense. It puts<br>&gt;&gt; you control in how to deal with a narrowing error. You could assert if you<br>&gt;&gt; so want (much like what happens now) or you could deal with the edge case.<br>&gt;&gt; Swift makes the code to deal with a failable  initializer generally trivial.<br>&gt;&gt;<br>&gt;&gt; It makes you think about this very real pitfall (in some problem<br>&gt;&gt; domains) when going between numerical types.<br>&gt;&gt;<br>&gt;&gt; The issue of why are you using unsigned, etc. is orthogonal to this<br>&gt;&gt; issue. If these types exist in the language folks will use them and it<br>&gt;&gt; should be safe / consistent for them when they do.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; -Shawn<br>&gt;&gt;<br>&gt;&gt; On Tue, Feb 16, 2016 at 11:11 AM David Turnbull &lt;dturnbull at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Can you show some examples where and why you use not-Int types and this<br>&gt;&gt;&gt; is a problem? What you&#39;re suggesting will be a burden to those of us who<br>&gt;&gt;&gt; need bitwise optimizations or work with C APIs.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My last week was spent reading files with huffman coding. So I had no<br>&gt;&gt;&gt; choice but to use bitwise operations. My experience is that Swift got this<br>&gt;&gt;&gt; right (except for &quot;truncatingBitPattern&quot; taking up 25% of an 80 column<br>&gt;&gt;&gt; line).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So my question is, &quot;why are you not using Int?&quot; There&#39;s plenty of use<br>&gt;&gt;&gt; cases, you just haven&#39;t stated yours so we can&#39;t understand why the current<br>&gt;&gt;&gt; system is failing you.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Safety does not mean you can easily write code that crashes once it is<br>&gt;&gt;&gt;&gt; deployed….<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var a = [Int](); a[0]=99<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That was pretty easy. I don&#39;t buy into this argument. If you don&#39;t want<br>&gt;&gt;&gt; an out of bounds error, you either make sure you don&#39;t math your way out of<br>&gt;&gt;&gt; bounds or you check every time before you subscript. I don&#39;t see why an<br>&gt;&gt;&gt; integer conversion should be any different.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -david<br>&gt;&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/0b7cbfc9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Warning for possible overflow or optional</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February 16, 2016 at 04:00:00pm</p></header><div class="content"><p>I launched a similar thread just a few days ago. https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009950.html<br></p><p>Félix<br></p><p>&gt; Le 16 févr. 2016 à 15:37:17, Shawn Erickson via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Ok one last reply to myself...<br>&gt; <br>&gt; public class Int16 {<br>&gt;     public init(_ v: UInt8) {}<br>&gt;     public init(_ v: Int8) {}<br>&gt;     <br>&gt;     public init?(_ v: UInt16) {...on overflow return nil...}<br>&gt;     public init(assertValue: UInt16) {...on overflow assert...} // I think we could just drop this<br>&gt;     public init(truncatingValue: UInt16) {...on overflow truncate, alway positive...}<br>&gt;     <br>&gt;     public init?(_ v: Int32) {...on overflow return nil...}<br>&gt;     public init(assertValue: Int32) {...on overflow assert...} // I think we could just drop this<br>&gt;     public init(truncatingValue: Int32) {...on overflow truncate, maintain sign...}<br>&gt;     <br>&gt;     public init?(_ v: UInt32) {...on overflow return nil...}<br>&gt;     public init(assertValue: UInt32) {...on overflow assert...} // I think we could just drop this<br>&gt;     public init(truncatingValue: UInt32) {...on overflow truncate, alway positive...}<br>&gt;     <br>&gt;     ...others...<br>&gt;     <br>&gt;     public init(bitPattern: UInt16) {...close your eyes and copy the bits...}<br>&gt; }<br>&gt; <br>&gt; <br>&gt; let unsigned32 = UInt32(UInt16.max + 50)<br>&gt; <br>&gt; guard let foo = Int16(unsigned32) else {<br>&gt;     throw Blah ...or... assert(&quot;BOOM&quot;)<br>&gt; }<br>&gt; ...do stuff...<br>&gt; <br>&gt; ...or...<br>&gt; <br>&gt; if let foo = Int16(unsigned32) {<br>&gt;     ...do stuff...<br>&gt; }<br>&gt; else {<br>&gt;     ...handle error...<br>&gt; }<br>&gt; <br>&gt; ...or...<br>&gt; <br>&gt; let foo = Int16(truncatingValue: unsigned32)<br>&gt; ...do stuff...<br>&gt; <br>&gt; ...or...<br>&gt; <br>&gt; let foo = Int16(assertValue: unsigned32) //again I think we could just drop this<br>&gt; ...do stuff unless I just went boom...<br>&gt; <br>&gt; <br>&gt; On Tue, Feb 16, 2016 at 11:57 AM Shawn Erickson &lt;shawnce at gmail.com &lt;mailto:shawnce at gmail.com&gt;&gt; wrote:<br>&gt; Thinking a little more about this how about just adding failable constructors so it becomes easier to deal with runtime narrowing errors for those that need it? (that was my main issue I ran across when using these classes in an early project, I had to put code around things to deal with the edge case that the library was already obviously doing)<br>&gt; <br>&gt; extension UInt16 {<br>&gt;     public init(_ v: UInt8)<br>&gt;     public init(_ v: Int8)<br>&gt;     public init(_ v: Int16)<br>&gt;     public init(_ v: UInt32)                    // runtime narrowing check, asserts BOOOM<br>&gt;     public init?(validatingValue: UInt32)       // runtime narrowing check, failable initializer<br>&gt;     public init(truncatingBitPattern: UInt32)   // narrowing &quot;fixup&quot; initializer<br>&gt;     public init(_ v: Int32)                     // runtime narrowing check, asserts BOOOM<br>&gt;     public init?(validatingValue: UInt32)       // runtime narrowing check, failable initializer<br>&gt;     public init(truncatingBitPattern: Int32)    // narrowing &quot;fixup&quot; initializer<br>&gt;  ...<br>&gt;     public init(bitPattern: Int16)              // I know what I doing! (aka live dangerously)<br>&gt; }<br>&gt; <br>&gt; Ideally – to me – you would want the failable initializers to be the default ones available with the boom crash ones being something you could switch to use much like the the other special &quot;i know what I am doing ones&quot;. Not sure of the naming to use for such an initializer however.<br>&gt; <br>&gt; <br>&gt; -Shawn<br>&gt; <br>&gt; <br>&gt; On Tue, Feb 16, 2016 at 11:28 AM Shawn Erickson &lt;shawnce at gmail.com &lt;mailto:shawnce at gmail.com&gt;&gt; wrote:<br>&gt; I believe you stated that you ran across at least two times that runtime checks caught a narrowing error (e.g. overflow) in your recent work. I support runtime checks however I feel in the case of operations that could have a narrowing issue using a failable constructor makes sense. It puts you control in how to deal with a narrowing error. You could assert if you so want (much like what happens now) or you could deal with the edge case. Swift makes the code to deal with a failable  initializer generally trivial.<br>&gt; <br>&gt; It makes you think about this very real pitfall (in some problem domains) when going between numerical types.<br>&gt; <br>&gt; The issue of why are you using unsigned, etc. is orthogonal to this issue. If these types exist in the language folks will use them and it should be safe / consistent for them when they do.<br>&gt; <br>&gt; <br>&gt; -Shawn<br>&gt; <br>&gt; On Tue, Feb 16, 2016 at 11:11 AM David Turnbull &lt;dturnbull at gmail.com &lt;mailto:dturnbull at gmail.com&gt;&gt; wrote:<br>&gt; Can you show some examples where and why you use not-Int types and this is a problem? What you&#39;re suggesting will be a burden to those of us who need bitwise optimizations or work with C APIs.<br>&gt; <br>&gt; My last week was spent reading files with huffman coding. So I had no choice but to use bitwise operations. My experience is that Swift got this right (except for &quot;truncatingBitPattern&quot; taking up 25% of an 80 column line).<br>&gt; <br>&gt; So my question is, &quot;why are you not using Int?&quot; There&#39;s plenty of use cases, you just haven&#39;t stated yours so we can&#39;t understand why the current system is failing you.<br>&gt; <br>&gt; Safety does not mean you can easily write code that crashes once it is deployed….<br>&gt; <br>&gt; var a = [Int](); a[0]=99<br>&gt; <br>&gt; That was pretty easy. I don&#39;t buy into this argument. If you don&#39;t want an out of bounds error, you either make sure you don&#39;t math your way out of bounds or you check every time before you subscript. I don&#39;t see why an integer conversion should be any different.<br>&gt; <br>&gt; -david<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/d408c178/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e4a1f3ac9e9faed38980dbf9aa80d72e?s=50"></div><header><strong>Warning for possible overflow or optional</strong> from <string>Stéphane Lizeray</string> &lt;stephane at lizeray.net&gt;<p>February 16, 2016 at 10:00:00pm</p></header><div class="content"><p>Yes, this is exactly my proposal!<br></p><p>Thanks,<br></p><p>Stéphane<br></p><p>&gt; On 16 Feb 2016, at 22:20, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I launched a similar thread just a few days ago. https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009950.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009950.html&gt;<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 16 févr. 2016 à 15:37:17, Shawn Erickson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Ok one last reply to myself...<br>&gt;&gt; <br>&gt;&gt; public class Int16 {<br>&gt;&gt;     public init(_ v: UInt8) {}<br>&gt;&gt;     public init(_ v: Int8) {}<br>&gt;&gt;     <br>&gt;&gt;     public init?(_ v: UInt16) {...on overflow return nil...}<br>&gt;&gt;     public init(assertValue: UInt16) {...on overflow assert...} // I think we could just drop this<br>&gt;&gt;     public init(truncatingValue: UInt16) {...on overflow truncate, alway positive...}<br>&gt;&gt;     <br>&gt;&gt;     public init?(_ v: Int32) {...on overflow return nil...}<br>&gt;&gt;     public init(assertValue: Int32) {...on overflow assert...} // I think we could just drop this<br>&gt;&gt;     public init(truncatingValue: Int32) {...on overflow truncate, maintain sign...}<br>&gt;&gt;     <br>&gt;&gt;     public init?(_ v: UInt32) {...on overflow return nil...}<br>&gt;&gt;     public init(assertValue: UInt32) {...on overflow assert...} // I think we could just drop this<br>&gt;&gt;     public init(truncatingValue: UInt32) {...on overflow truncate, alway positive...}<br>&gt;&gt;     <br>&gt;&gt;     ...others...<br>&gt;&gt;     <br>&gt;&gt;     public init(bitPattern: UInt16) {...close your eyes and copy the bits...}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; let unsigned32 = UInt32(UInt16.max + 50)<br>&gt;&gt; <br>&gt;&gt; guard let foo = Int16(unsigned32) else {<br>&gt;&gt;     throw Blah ...or... assert(&quot;BOOM&quot;)<br>&gt;&gt; }<br>&gt;&gt; ...do stuff...<br>&gt;&gt; <br>&gt;&gt; ...or...<br>&gt;&gt; <br>&gt;&gt; if let foo = Int16(unsigned32) {<br>&gt;&gt;     ...do stuff...<br>&gt;&gt; }<br>&gt;&gt; else {<br>&gt;&gt;     ...handle error...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; ...or...<br>&gt;&gt; <br>&gt;&gt; let foo = Int16(truncatingValue: unsigned32)<br>&gt;&gt; ...do stuff...<br>&gt;&gt; <br>&gt;&gt; ...or...<br>&gt;&gt; <br>&gt;&gt; let foo = Int16(assertValue: unsigned32) //again I think we could just drop this<br>&gt;&gt; ...do stuff unless I just went boom...<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, Feb 16, 2016 at 11:57 AM Shawn Erickson &lt;shawnce at gmail.com &lt;mailto:shawnce at gmail.com&gt;&gt; wrote:<br>&gt;&gt; Thinking a little more about this how about just adding failable constructors so it becomes easier to deal with runtime narrowing errors for those that need it? (that was my main issue I ran across when using these classes in an early project, I had to put code around things to deal with the edge case that the library was already obviously doing)<br>&gt;&gt; <br>&gt;&gt; extension UInt16 {<br>&gt;&gt;     public init(_ v: UInt8)<br>&gt;&gt;     public init(_ v: Int8)<br>&gt;&gt;     public init(_ v: Int16)<br>&gt;&gt;     public init(_ v: UInt32)                    // runtime narrowing check, asserts BOOOM<br>&gt;&gt;     public init?(validatingValue: UInt32)       // runtime narrowing check, failable initializer<br>&gt;&gt;     public init(truncatingBitPattern: UInt32)   // narrowing &quot;fixup&quot; initializer<br>&gt;&gt;     public init(_ v: Int32)                     // runtime narrowing check, asserts BOOOM<br>&gt;&gt;     public init?(validatingValue: UInt32)       // runtime narrowing check, failable initializer<br>&gt;&gt;     public init(truncatingBitPattern: Int32)    // narrowing &quot;fixup&quot; initializer<br>&gt;&gt;  ...<br>&gt;&gt;     public init(bitPattern: Int16)              // I know what I doing! (aka live dangerously)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Ideally – to me – you would want the failable initializers to be the default ones available with the boom crash ones being something you could switch to use much like the the other special &quot;i know what I am doing ones&quot;. Not sure of the naming to use for such an initializer however.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -Shawn<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, Feb 16, 2016 at 11:28 AM Shawn Erickson &lt;shawnce at gmail.com &lt;mailto:shawnce at gmail.com&gt;&gt; wrote:<br>&gt;&gt; I believe you stated that you ran across at least two times that runtime checks caught a narrowing error (e.g. overflow) in your recent work. I support runtime checks however I feel in the case of operations that could have a narrowing issue using a failable constructor makes sense. It puts you control in how to deal with a narrowing error. You could assert if you so want (much like what happens now) or you could deal with the edge case. Swift makes the code to deal with a failable  initializer generally trivial.<br>&gt;&gt; <br>&gt;&gt; It makes you think about this very real pitfall (in some problem domains) when going between numerical types.<br>&gt;&gt; <br>&gt;&gt; The issue of why are you using unsigned, etc. is orthogonal to this issue. If these types exist in the language folks will use them and it should be safe / consistent for them when they do.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -Shawn<br>&gt;&gt; <br>&gt;&gt; On Tue, Feb 16, 2016 at 11:11 AM David Turnbull &lt;dturnbull at gmail.com &lt;mailto:dturnbull at gmail.com&gt;&gt; wrote:<br>&gt;&gt; Can you show some examples where and why you use not-Int types and this is a problem? What you&#39;re suggesting will be a burden to those of us who need bitwise optimizations or work with C APIs.<br>&gt;&gt; <br>&gt;&gt; My last week was spent reading files with huffman coding. So I had no choice but to use bitwise operations. My experience is that Swift got this right (except for &quot;truncatingBitPattern&quot; taking up 25% of an 80 column line).<br>&gt;&gt; <br>&gt;&gt; So my question is, &quot;why are you not using Int?&quot; There&#39;s plenty of use cases, you just haven&#39;t stated yours so we can&#39;t understand why the current system is failing you.<br>&gt;&gt; <br>&gt;&gt; Safety does not mean you can easily write code that crashes once it is deployed….<br>&gt;&gt; <br>&gt;&gt; var a = [Int](); a[0]=99<br>&gt;&gt; <br>&gt;&gt; That was pretty easy. I don&#39;t buy into this argument. If you don&#39;t want an out of bounds error, you either make sure you don&#39;t math your way out of bounds or you check every time before you subscript. I don&#39;t see why an integer conversion should be any different.<br>&gt;&gt; <br>&gt;&gt; -david<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/a610294d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
