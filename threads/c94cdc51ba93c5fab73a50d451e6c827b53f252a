<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 19, 2016 at 03:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib&quot; begins now and runs through May 23. This is a refinement of part of SE-0045.  The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0094-sequence-function.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Review] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>May 19, 2016 at 07:00:00pm</p></header><div class="content"><p>* What is your evaluation of the proposal?<br>+1. I&#39;ve used unfold/iterate functions in Haskell and Clojure, and they are<br>very useful.<br>        * Is the problem being addressed significant enough to warrant a<br>change to Swift?<br>Yes.<br>        * Does this proposal fit well with the feel and direction of Swift?<br>Yes.<br>        * If you have used other languages or libraries with a similar<br>feature, how do you feel that this proposal compares to those?<br>See above.<br>        * How much effort did you put into your review? A glance, a quick<br>reading, or an in-depth study?<br>Quick reading.<br></p><p>Also note that there&#39;s a typo in the second example:<br></p><p>for view in sequence(initial: someView, next: { $0.superview }) {<br>    // someView, someView.superview, someView.superview.superview, ...<br>}<br></p><p><br>should be:<br></p><p>for view in sequence(state: someView, next: { $0.superview }) {<br>    // someView, someView.superview, someView.superview.superview, ...<br>}<br></p><p><br></p><p><br>On Thu, May 19, 2016 at 6:29 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;SE-0094: Add sequence(initial:next:) and<br>&gt; sequence(state:next:) to the stdlib&quot; begins now and runs through May 23.<br>&gt; This is a refinement of part of SE-0045.  The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0094-sequence-function.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/64df435b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>May 19, 2016 at 04:00:00pm</p></header><div class="content"><p>On Thu, May 19, 2016, at 04:20 PM, Trent Nadeau via swift-evolution wrote:<br>&gt; Also note that there&#39;s a typo in the second example:<br>&gt;<br>&gt; for view in sequence(initial: someView, next: { $.superview }) {  //<br>&gt; someView, someView.superview, someView.superview.superview, ... }<br>&gt;<br>&gt; should be:<br>&gt;<br>&gt; for view in sequence(state: someView, next: { $.superview }) {  //<br>&gt; someView, someView.superview, someView.superview.superview, ... }<br> <br>The code as written is correct. The rewritten version would actually<br>just emit [someView.superview, someView.superview, someView.superview,<br>...] forever. I imagine the confusion stems from the fact that there&#39;s 2<br>examples but they both demonstrate just the first function, and there&#39;s<br>no examples of the second function, which is something I&#39;ll try to<br>address soon.<br> <br>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/d8f76687/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 19, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Also note that there&#39;s a typo in the second example:<br>&gt; <br>&gt; for view in sequence(initial: someView, next: { $0.<br>&gt; superview }) {<br>&gt;     <br>&gt; // someView, someView.superview, someView.superview.superview, ...<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; should be:<br>&gt; <br>&gt; for view in sequence(state: someView, next: { $0.<br>&gt; superview }) {<br>&gt;     <br>&gt; // someView, someView.superview, someView.superview.superview, ...<br>&gt; <br>&gt; }<br></p><p>I don&#39;t think these are mistakes—in each iteration of the loop, $0 is supposed to be the view from the previous iteration.<br></p><p>If you wanted an example using `state`, here&#39;s one which is roughly equivalent to `stride(from: 1.0, to: 2.0, by: 0.1)`, using a non-error-accumulating algorithm:<br></p><p>	let start = 1.0<br>	let end = 2.0<br>	let distance = 0.1<br>	<br>	for color in sequence(state: -1.0, next: { $0 += 1; let next = start + $0 * distance; return next &lt; end ? next : nil }) {<br>		…<br>	}<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Review] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>May 19, 2016 at 08:00:00pm</p></header><div class="content"><p>Ah, yes. I apologize. The fact that state is inout, and the same instance<br>is always passed in confused me. Thanks for the correction.<br></p><p>On Thu, May 19, 2016 at 7:46 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; Also note that there&#39;s a typo in the second example:<br>&gt; &gt;<br>&gt; &gt; for view in sequence(initial: someView, next: { $0.<br>&gt; &gt; superview }) {<br>&gt; &gt;<br>&gt; &gt; // someView, someView.superview, someView.superview.superview, ...<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; should be:<br>&gt; &gt;<br>&gt; &gt; for view in sequence(state: someView, next: { $0.<br>&gt; &gt; superview }) {<br>&gt; &gt;<br>&gt; &gt; // someView, someView.superview, someView.superview.superview, ...<br>&gt; &gt;<br>&gt; &gt; }<br>&gt;<br>&gt; I don&#39;t think these are mistakes—in each iteration of the loop, $0 is<br>&gt; supposed to be the view from the previous iteration.<br>&gt;<br>&gt; If you wanted an example using `state`, here&#39;s one which is roughly<br>&gt; equivalent to `stride(from: 1.0, to: 2.0, by: 0.1)`, using a<br>&gt; non-error-accumulating algorithm:<br>&gt;<br>&gt;         let start = 1.0<br>&gt;         let end = 2.0<br>&gt;         let distance = 0.1<br>&gt;<br>&gt;         for color in sequence(state: -1.0, next: { $0 += 1; let next =<br>&gt; start + $0 * distance; return next &lt; end ? next : nil }) {<br>&gt;                 …<br>&gt;         }<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/6a482b76/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Review] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 20, 2016 at 10:00:00am</p></header><div class="content"><p>Would `sequence(mutatingState:next:)` perhaps be clearer?<br></p><p><br>&gt; On 20 May 2016, at 10:37 AM, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ah, yes. I apologize. The fact that state is inout, and the same instance is always passed in confused me. Thanks for the correction.<br>&gt; <br>&gt; On Thu, May 19, 2016 at 7:46 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt; &gt; Also note that there&#39;s a typo in the second example:<br>&gt; &gt;<br>&gt; &gt; for view in sequence(initial: someView, next: { $0.<br>&gt; &gt; superview }) {<br>&gt; &gt;<br>&gt; &gt; // someView, someView.superview, someView.superview.superview, ...<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; should be:<br>&gt; &gt;<br>&gt; &gt; for view in sequence(state: someView, next: { $0.<br>&gt; &gt; superview }) {<br>&gt; &gt;<br>&gt; &gt; // someView, someView.superview, someView.superview.superview, ...<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; <br>&gt; I don&#39;t think these are mistakes—in each iteration of the loop, $0 is supposed to be the view from the previous iteration.<br>&gt; <br>&gt; If you wanted an example using `state`, here&#39;s one which is roughly equivalent to `stride(from: 1.0, to: 2.0, by: 0.1)`, using a non-error-accumulating algorithm:<br>&gt; <br>&gt;         let start = 1.0<br>&gt;         let end = 2.0<br>&gt;         let distance = 0.1<br>&gt; <br>&gt;         for color in sequence(state: -1.0, next: { $0 += 1; let next = start + $0 * distance; return next &lt; end ? next : nil }) {<br>&gt;                 …<br>&gt;         }<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/4992c0c4/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Review] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>May 19, 2016 at 08:00:00pm</p></header><div class="content"><p>It would certainly be clearer that the state is changing on each<br>&quot;iteration&quot;, but I&#39;m not sure it&#39;s worth such a long parameter label. Maybe<br>`sequence(state:update:)`?<br></p><p>On Thu, May 19, 2016 at 8:46 PM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br></p><p>&gt; Would `sequence(mutatingState:next:)` perhaps be clearer?<br>&gt;<br>&gt;<br>&gt; On 20 May 2016, at 10:37 AM, Trent Nadeau via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Ah, yes. I apologize. The fact that state is inout, and the same instance<br>&gt; is always passed in confused me. Thanks for the correction.<br>&gt;<br>&gt; On Thu, May 19, 2016 at 7:46 PM, Brent Royal-Gordon &lt;<br>&gt; brent at architechies.com&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; Also note that there&#39;s a typo in the second example:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; for view in sequence(initial: someView, next: { $0.<br>&gt;&gt; &gt; superview }) {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // someView, someView.superview, someView.superview.superview, ...<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; should be:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; for view in sequence(state: someView, next: { $0.<br>&gt;&gt; &gt; superview }) {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // someView, someView.superview, someView.superview.superview, ...<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; }<br>&gt;&gt;<br>&gt;&gt; I don&#39;t think these are mistakes—in each iteration of the loop, $0 is<br>&gt;&gt; supposed to be the view from the previous iteration.<br>&gt;&gt;<br>&gt;&gt; If you wanted an example using `state`, here&#39;s one which is roughly<br>&gt;&gt; equivalent to `stride(from: 1.0, to: 2.0, by: 0.1)`, using a<br>&gt;&gt; non-error-accumulating algorithm:<br>&gt;&gt;<br>&gt;&gt;         let start = 1.0<br>&gt;&gt;         let end = 2.0<br>&gt;&gt;         let distance = 0.1<br>&gt;&gt;<br>&gt;&gt;         for color in sequence(state: -1.0, next: { $0 += 1; let next =<br>&gt;&gt; start + $0 * distance; return next &lt; end ? next : nil }) {<br>&gt;&gt;                 …<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Trent Nadeau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/1c730f85/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>May 19, 2016 at 05:00:00pm</p></header><div class="content"><p>After having given this some thought, it seems apparent that<br>`sequence(state:next:)` is  equivalent to `AnyIterator({ ... })` where<br>the closure captures a single mutable variable. The microbenchmark<br>performance may differ slightly, as the AnyIterator version will<br>allocate a box on the heap to hold the captured variable (assuming it<br>can&#39;t get inlined entirely), whereas UnfoldSequence won&#39;t. But the<br>functionality is the same.<br> <br>Thus the question: do we want to keep `sequence(state:next:)` or is it<br>too close to AnyIterator in functionality? Arguments in favor of<br>`sequence(state:next:)`:<br> <br>* It&#39;s equivalent to unfold and the dual of reduce, so people who&#39;ve<br>  used functional programming languages may expect it to exist.<br>* It allows you to create ad-hoc stateful sequences without polluting<br>  the current scope with a variable that exists solely to be captured.<br>* If the cost of a small heap allocation is significant for your code,<br>  it may be more performant than AnyIterator.<br> <br>Personally, the most important reason here for me is not having to<br>pollute the current closure with a variable. And this could actually be<br>solved another way, by allowing the use of `var` in a capture list,<br>which would let you say something like `AnyGenerator({ [var state=foo]<br>in ... })`.<br> <br>Given all this, at this point I&#39;m actually leaning towards<br>saying`sequence(state:next:)` doesn&#39;t pull its own weight and we should<br>just go with `sequence(initial:next:)`.<br> <br>-Kevin Ballard<br> <br>On Thu, May 19, 2016, at 05:37 PM, Trent Nadeau via swift-evolution wrote:<br>&gt; Ah, yes. I apologize. The fact that state is inout, and the same<br>&gt; instance is always passed in confused me. Thanks for the correction.<br>&gt;<br>&gt; On Thu, May 19, 2016 at 7:46 PM, Brent Royal-Gordon<br>&gt; &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; &gt; Also note that there&#39;s a typo in the second example:<br>&gt;&gt;  &gt;<br>&gt;&gt;  &gt; for view in sequence(initial: someView, next: { $0. superview }) {<br>&gt;&gt;  &gt;<br>&gt;&gt;  &gt; // someView, someView.superview, someView.superview.superview, ...<br>&gt;&gt;  &gt;<br>&gt;&gt;  &gt; }<br>&gt;&gt;  &gt;<br>&gt;&gt;  &gt;<br>&gt;&gt;  &gt; should be:<br>&gt;&gt;  &gt;<br>&gt;&gt;  &gt; for view in sequence(state: someView, next: { $0. superview }) {<br>&gt;&gt;  &gt;<br>&gt;&gt;  &gt; // someView, someView.superview, someView.superview.superview, ...<br>&gt;&gt;  &gt;<br>&gt;&gt;  &gt; }<br>&gt;&gt;<br>&gt;&gt; I don&#39;t think these are mistakes—in each iteration of the loop, $0 is<br>&gt;&gt; supposed to be the view from the previous iteration.<br>&gt;&gt;<br>&gt;&gt;  If you wanted an example using `state`, here&#39;s one which is roughly<br>&gt;&gt;  equivalent to `stride(from: 1.0, to: 2.0, by: 0.1)`, using a non-error-<br>&gt;&gt;  accumulating algorithm:<br>&gt;&gt;<br>&gt;&gt;  let start = 1.0<br>&gt;&gt;  let end = 2.0<br>&gt;&gt;  let distance = 0.1<br>&gt;&gt;<br>&gt;&gt;  for color in sequence(state: -1.0, next: { $0 += 1; let next = start<br>&gt;&gt;  + $0 * distance; return next &lt; end ? next : nil }) {<br>&gt;&gt;  …<br>&gt;&gt;  }<br>&gt;&gt;<br>&gt;&gt;  --<br>&gt;&gt;  Brent Royal-Gordon Architechies<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Trent Nadeau<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/592bdf6c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 19, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 19, 2016, at 6:52 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; After having given this some thought, it seems apparent that `sequence(state:next:)` is equivalent to `AnyIterator({ ... })` where the closure captures a single mutable variable. The microbenchmark performance may differ slightly, as the AnyIterator version will allocate a box on the heap to hold the captured variable (assuming it can&#39;t get inlined entirely), whereas UnfoldSequence won&#39;t. But the functionality is the same.<br>&gt;  <br>&gt; Thus the question: do we want to keep `sequence(state:next:)` or is it too close to AnyIterator in functionality? Arguments in favor of `sequence(state:next:)`:<br>&gt;  <br>&gt; * It&#39;s equivalent to unfold and the dual of reduce, so people who&#39;ve used functional programming languages may expect it to exist.<br>&gt; * It allows you to create ad-hoc stateful sequences without polluting the current scope with a variable that exists solely to be captured.<br>&gt; * If the cost of a small heap allocation is significant for your code, it may be more performant than AnyIterator.<br>&gt;  <br>&gt; Personally, the most important reason here for me is not having to pollute the current closure with a variable. And this could actually be solved another way, by allowing the use of `var` in a capture list, which would let you say something like `AnyGenerator({ [var state=foo] in ... })`.<br>&gt;  <br>&gt; Given all this, at this point I&#39;m actually leaning towards saying`sequence(state:next:)` doesn&#39;t pull its own weight and we should just go with `sequence(initial:next:)`.<br>&gt;  <br>&gt; -Kevin Ballard<br></p><p>Adding on, to the best of my understanding the biggest win in the stateful variation is to be able to create a sequence from a starting state without declaring any external variables, as in the perfectly wrong and evil example I showed Kevin:<br></p><p>enum Finger: Int { case Thumb = 1, Pointer, Middle, Ring, Pinky }<br></p><p>extension Finger {<br>    static func members() -&gt; AnySequence&lt;Finger&gt; {<br>        return sequence(Thumb.rawValue, next: {<br>            (inout idx: Int) in<br>            defer { idx += 1 }<br>            return Finger(rawValue: idx)<br>        })<br>    }<br>}<br></p><p>for finger in Finger.members() { print(finger) }<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/3fd45bb7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Review] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 20, 2016 at 11:00:00am</p></header><div class="content"><p>I think that is a little confusing and has potential to be ‘abused’. I think it’s more confusing that a `for(;;)` loop for instance, and that got removed. I think var + AnyIterator is more explicit, and can become the canonical way to do this.<br></p><p>Hopefully AnyIterator can be optimized to the same performance.<br></p><p><br>&gt; On 20 May 2016, at 10:57 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 19, 2016, at 6:52 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; After having given this some thought, it seems apparent that `sequence(state:next:)` is equivalent to `AnyIterator({ ... })` where the closure captures a single mutable variable. The microbenchmark performance may differ slightly, as the AnyIterator version will allocate a box on the heap to hold the captured variable (assuming it can&#39;t get inlined entirely), whereas UnfoldSequence won&#39;t. But the functionality is the same.<br>&gt;&gt;  <br>&gt;&gt; Thus the question: do we want to keep `sequence(state:next:)` or is it too close to AnyIterator in functionality? Arguments in favor of `sequence(state:next:)`:<br>&gt;&gt;  <br>&gt;&gt; * It&#39;s equivalent to unfold and the dual of reduce, so people who&#39;ve used functional programming languages may expect it to exist.<br>&gt;&gt; * It allows you to create ad-hoc stateful sequences without polluting the current scope with a variable that exists solely to be captured.<br>&gt;&gt; * If the cost of a small heap allocation is significant for your code, it may be more performant than AnyIterator.<br>&gt;&gt;  <br>&gt;&gt; Personally, the most important reason here for me is not having to pollute the current closure with a variable. And this could actually be solved another way, by allowing the use of `var` in a capture list, which would let you say something like `AnyGenerator({ [var state=foo] in ... })`.<br>&gt;&gt;  <br>&gt;&gt; Given all this, at this point I&#39;m actually leaning towards saying`sequence(state:next:)` doesn&#39;t pull its own weight and we should just go with `sequence(initial:next:)`.<br>&gt;&gt;  <br>&gt;&gt; -Kevin Ballard<br>&gt; <br>&gt; Adding on, to the best of my understanding the biggest win in the stateful variation is to be able to create a sequence from a starting state without declaring any external variables, as in the perfectly wrong and evil example I showed Kevin:<br>&gt; <br>&gt; enum Finger: Int { case Thumb = 1, Pointer, Middle, Ring, Pinky }<br>&gt; <br>&gt; extension Finger {<br>&gt;     static func members() -&gt; AnySequence&lt;Finger&gt; {<br>&gt;         return sequence(Thumb.rawValue, next: {<br>&gt;             (inout idx: Int) in<br>&gt;             defer { idx += 1 }<br>&gt;             return Finger(rawValue: idx)<br>&gt;         })<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; for finger in Finger.members() { print(finger) }<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/e7e4de8e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 19, 2016 at 07:00:00pm</p></header><div class="content"><p>Once you start using it, it&#39;s really hard to put it down.<br></p><p>-- E, who will not make the obvious &quot;for&quot; joke<br></p><p><br>&gt; On May 19, 2016, at 7:10 PM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think that is a little confusing and has potential to be ‘abused’. I think it’s more confusing that a `for(;;)` loop for instance, and that got removed. I think var + AnyIterator is more explicit, and can become the canonical way to do this.<br>&gt; <br>&gt; Hopefully AnyIterator can be optimized to the same performance.<br>&gt; <br>&gt; <br>&gt;&gt; On 20 May 2016, at 10:57 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 19, 2016, at 6:52 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After having given this some thought, it seems apparent that `sequence(state:next:)` is equivalent to `AnyIterator({ ... })` where the closure captures a single mutable variable. The microbenchmark performance may differ slightly, as the AnyIterator version will allocate a box on the heap to hold the captured variable (assuming it can&#39;t get inlined entirely), whereas UnfoldSequence won&#39;t. But the functionality is the same.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Thus the question: do we want to keep `sequence(state:next:)` or is it too close to AnyIterator in functionality? Arguments in favor of `sequence(state:next:)`:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; * It&#39;s equivalent to unfold and the dual of reduce, so people who&#39;ve used functional programming languages may expect it to exist.<br>&gt;&gt;&gt; * It allows you to create ad-hoc stateful sequences without polluting the current scope with a variable that exists solely to be captured.<br>&gt;&gt;&gt; * If the cost of a small heap allocation is significant for your code, it may be more performant than AnyIterator.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Personally, the most important reason here for me is not having to pollute the current closure with a variable. And this could actually be solved another way, by allowing the use of `var` in a capture list, which would let you say something like `AnyGenerator({ [var state=foo] in ... })`.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Given all this, at this point I&#39;m actually leaning towards saying`sequence(state:next:)` doesn&#39;t pull its own weight and we should just go with `sequence(initial:next:)`.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt; <br>&gt;&gt; Adding on, to the best of my understanding the biggest win in the stateful variation is to be able to create a sequence from a starting state without declaring any external variables, as in the perfectly wrong and evil example I showed Kevin:<br>&gt;&gt; <br>&gt;&gt; enum Finger: Int { case Thumb = 1, Pointer, Middle, Ring, Pinky }<br>&gt;&gt; <br>&gt;&gt; extension Finger {<br>&gt;&gt;     static func members() -&gt; AnySequence&lt;Finger&gt; {<br>&gt;&gt;         return sequence(Thumb.rawValue, next: {<br>&gt;&gt;             (inout idx: Int) in<br>&gt;&gt;             defer { idx += 1 }<br>&gt;&gt;             return Finger(rawValue: idx)<br>&gt;&gt;         })<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; for finger in Finger.members() { print(finger) }<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/d5ca1296/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Review] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 20, 2016 at 10:00:00am</p></header><div class="content"><p>This sounds fair to me. I imagine a functional version would return two item tuple instead of mutating, so would it be that similar to what people expect?<br></p><p><br>&gt; On 20 May 2016, at 10:52 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; After having given this some thought, it seems apparent that `sequence(state:next:)` is equivalent to `AnyIterator({ ... })` where the closure captures a single mutable variable. The microbenchmark performance may differ slightly, as the AnyIterator version will allocate a box on the heap to hold the captured variable (assuming it can&#39;t get inlined entirely), whereas UnfoldSequence won&#39;t. But the functionality is the same.<br>&gt;  <br>&gt; Thus the question: do we want to keep `sequence(state:next:)` or is it too close to AnyIterator in functionality? Arguments in favor of `sequence(state:next:)`:<br>&gt;  <br>&gt; * It&#39;s equivalent to unfold and the dual of reduce, so people who&#39;ve used functional programming languages may expect it to exist.<br>&gt; * It allows you to create ad-hoc stateful sequences without polluting the current scope with a variable that exists solely to be captured.<br>&gt; * If the cost of a small heap allocation is significant for your code, it may be more performant than AnyIterator.<br>&gt;  <br>&gt; Personally, the most important reason here for me is not having to pollute the current closure with a variable. And this could actually be solved another way, by allowing the use of `var` in a capture list, which would let you say something like `AnyGenerator({ [var state=foo] in ... })`.<br>&gt;  <br>&gt; Given all this, at this point I&#39;m actually leaning towards saying`sequence(state:next:)` doesn&#39;t pull its own weight and we should just go with `sequence(initial:next:)`.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Thu, May 19, 2016, at 05:37 PM, Trent Nadeau via swift-evolution wrote:<br>&gt;&gt; Ah, yes. I apologize. The fact that state is inout, and the same instance is always passed in confused me. Thanks for the correction.<br>&gt;&gt;  <br>&gt;&gt; On Thu, May 19, 2016 at 7:46 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt; &gt; Also note that there&#39;s a typo in the second example:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; for view in sequence(initial: someView, next: { $0.<br>&gt;&gt; &gt; superview }) {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // someView, someView.superview, someView.superview.superview, ...<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; should be:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; for view in sequence(state: someView, next: { $0.<br>&gt;&gt; &gt; superview }) {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // someView, someView.superview, someView.superview.superview, ...<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; }<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think these are mistakes—in each iteration of the loop, $0 is supposed to be the view from the previous iteration.<br>&gt;&gt;  <br>&gt;&gt; If you wanted an example using `state`, here&#39;s one which is roughly equivalent to `stride(from: 1.0, to: 2.0, by: 0.1)`, using a non-error-accumulating algorithm:<br>&gt;&gt;  <br>&gt;&gt; let start = 1.0<br>&gt;&gt; let end = 2.0<br>&gt;&gt; let distance = 0.1<br>&gt;&gt;  <br>&gt;&gt; for color in sequence(state: -1.0, next: { $0 += 1; let next = start + $0 * distance; return next &lt; end ? next : nil }) {<br>&gt;&gt; …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; -- <br>&gt;&gt; Trent Nadeau<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/4af246f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>May 19, 2016 at 07:00:00pm</p></header><div class="content"><p>On Thu, May 19, 2016, at 05:59 PM, Patrick Smith wrote:<br>&gt; This sounds fair to me. I imagine a functional version would return<br>&gt; two item tuple instead of mutating, so would it be that similar to<br>&gt; what people expect?<br> <br>A functional version of `sequence(state:next:)` would indeed use the<br>type signature of `next` as `State -&gt; (T, State)?`. This is precisely<br>how Haskell&#39;s `unfoldr` works. But doing that with Swift where the state<br>contains Copy-on-Write data structures will end up with unnecessary<br>copies if the COW data structure is mutated.<br> <br>-Kevin<br> <br>&gt;&gt; On 20 May 2016, at 10:52 AM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; After having given this some thought, it seems apparent that<br>&gt;&gt; `sequence(state:next:)` is  equivalent to `AnyIterator({ ... })`<br>&gt;&gt; where the closure captures a single mutable variable. The<br>&gt;&gt; microbenchmark performance may differ slightly, as the AnyIterator<br>&gt;&gt; version will allocate a box on the heap to hold the captured variable<br>&gt;&gt; (assuming it can&#39;t get inlined entirely), whereas UnfoldSequence<br>&gt;&gt; won&#39;t. But the functionality is the same.<br>&gt;&gt;<br>&gt;&gt; Thus the question: do we want to keep `sequence(state:next:)` or is<br>&gt;&gt; it too close to AnyIterator in functionality? Arguments in favor of<br>&gt;&gt; `sequence(state:next:)`:<br>&gt;&gt;<br>&gt;&gt; * It&#39;s equivalent to unfold and the dual of reduce, so people who&#39;ve<br>&gt;&gt;   used functional programming languages may expect it to exist.<br>&gt;&gt; * It allows you to create ad-hoc stateful sequences without polluting<br>&gt;&gt;   the current scope with a variable that exists solely to be<br>&gt;&gt;   captured.<br>&gt;&gt; * If the cost of a small heap allocation is significant for your<br>&gt;&gt;   code, it may be more performant than AnyIterator.<br>&gt;&gt;<br>&gt;&gt; Personally, the most important reason here for me is not having to<br>&gt;&gt; pollute the current closure with a variable. And this could actually<br>&gt;&gt; be solved another way, by allowing the use of `var` in a capture<br>&gt;&gt; list, which would let you say something like `AnyGenerator({ [var<br>&gt;&gt; state=foo] in ... })`.<br>&gt;&gt;<br>&gt;&gt; Given all this, at this point I&#39;m actually leaning towards<br>&gt;&gt; saying`sequence(state:next:)` doesn&#39;t pull its own weight and we<br>&gt;&gt; should just go with `sequence(initial:next:)`.<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; On Thu, May 19, 2016, at 05:37 PM, Trent Nadeau via swift-<br>&gt;&gt; evolution wrote:<br>&gt;&gt;&gt; Ah, yes. I apologize. The fact that state is inout, and the same<br>&gt;&gt;&gt; instance is always passed in confused me. Thanks for the correction.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Thu, May 19, 2016 at 7:46 PM, Brent Royal-Gordon<br>&gt;&gt;&gt; &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; Also note that there&#39;s a typo in the second example:<br>&gt;&gt;&gt;&gt;  &gt;<br>&gt;&gt;&gt;&gt;  &gt; for view in sequence(initial: someView, next: { $0. superview<br>&gt;&gt;&gt;&gt;  &gt; }) {<br>&gt;&gt;&gt;&gt;  &gt;<br>&gt;&gt;&gt;&gt;  &gt; // someView, someView.superview, someView.superview.superview,<br>&gt;&gt;&gt;&gt;  &gt; ...<br>&gt;&gt;&gt;&gt;  &gt;<br>&gt;&gt;&gt;&gt;  &gt; }<br>&gt;&gt;&gt;&gt;  &gt;<br>&gt;&gt;&gt;&gt;  &gt;<br>&gt;&gt;&gt;&gt;  &gt; should be:<br>&gt;&gt;&gt;&gt;  &gt;<br>&gt;&gt;&gt;&gt;  &gt; for view in sequence(state: someView, next: { $0. superview }) {<br>&gt;&gt;&gt;&gt;  &gt;<br>&gt;&gt;&gt;&gt;  &gt; // someView, someView.superview, someView.superview.superview,<br>&gt;&gt;&gt;&gt;  &gt; ...<br>&gt;&gt;&gt;&gt;  &gt;<br>&gt;&gt;&gt;&gt;  &gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I don&#39;t think these are mistakes—in each iteration of the loop, $0<br>&gt;&gt;&gt;&gt; is supposed to be the view from the previous iteration.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If you wanted an example using `state`, here&#39;s one which is roughly<br>&gt;&gt;&gt;&gt; equivalent to `stride(from: 1.0, to: 2.0, by: 0.1)`, using a non-error-<br>&gt;&gt;&gt;&gt; accumulating algorithm:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let start = 1.0<br>&gt;&gt;&gt;&gt; let end = 2.0<br>&gt;&gt;&gt;&gt; let distance = 0.1<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; for color in sequence(state: -1.0, next: { $0 += 1; let next =<br>&gt;&gt;&gt;&gt; start + $0 * distance; return next &lt; end ? next : nil }) {<br>&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;  Brent Royal-Gordon Architechies<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Trent Nadeau<br>&gt;&gt;&gt; _________________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/3220ff7f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 25, 2016 at 01:00:00pm</p></header><div class="content"><p>On behalf of Dmitri Gribenko, Max Moiseev, and myself:<br></p><p>on Thu May 19 2016, Kevin Ballard &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br></p><p>&gt; After having given this some thought, it seems apparent that `sequence<br>&gt; (state:next:)` is equivalent to `AnyIterator({ ... })` where the closure<br>&gt; captures a single mutable variable. <br></p><p>Yes.  <br></p><p>&gt; The microbenchmark performance may differ slightly, as the AnyIterator<br>&gt; version will allocate a box on the heap to hold the captured variable<br>&gt; (assuming it can&#39;t get inlined entirely), whereas UnfoldSequence<br>&gt; won&#39;t. But the functionality is the same.  Thus the question: do we<br>&gt; want to keep `sequence(state:next:)` or is it too close to AnyIterator<br>&gt; in functionality? <br></p><p>We think the need to do a capture is icky, so the sequence form is<br>almost always better.<br></p><p>&gt; Arguments in favor of `sequence(state:next:)`: *<br>&gt; It&#39;s equivalent to unfold and the dual of reduce, so people who&#39;ve<br>&gt; used functional programming languages may expect it to exist.  * It<br>&gt; allows you to create ad-hoc stateful sequences without polluting the<br>&gt; current scope with a variable that exists solely to be captured.  * If<br>&gt; the cost of a small heap allocation is significant for your code, it<br>&gt; may be more performant than AnyIterator.  Personally, the most<br>&gt; important reason here for me is not having to pollute the current<br>&gt; closure with a variable. And this could actually be solved another<br>&gt; way, by allowing the use of `var` in a capture list, which would let<br>&gt; you say something like `AnyGenerator({ [var state=foo] in ... })`.<br>&gt; Given all this, at this point I&#39;m actually leaning towards<br>&gt; saying`sequence (state:next:)` doesn&#39;t pull its own weight and we<br>&gt; should just go with `sequence (initial:next:)`.  -Kevin Ballard<br></p><p>We forgot to mention this earlier: we prefer “first” over “initial” as the<br>label on the latter.<br></p><p>The design of AnySequence and AnyIterator dates from a time when the<br>compiler was very immature and many design avenues we might have taken<br>were not available.  I find the `sequence` forms to be superior in<br>general, and IMO at some point we should re-evaluate the interfaces to<br>AnySequence and AnyIterator.<br></p><p>Cheers,<br>Dave<br></p><p>&gt; On Thu, May 19, 2016, at 05:37 PM, Trent Nadeau via swift-evolution wrote:<br>&gt;<br>&gt;     Ah, yes. I apologize. The fact that state is inout, and the same instance is<br>&gt;     always passed in confused me. Thanks for the correction.<br>&gt;<br>&gt;     On Thu, May 19, 2016 at 7:46 PM, Brent Royal-Gordon<br>&gt;     &lt;brent-iffxGAVYld63nE1h+Mp7gA at public.gmane.org&gt; wrote:<br>&gt;<br>&gt;         &gt; Also note that there&#39;s a typo in the second example:<br>&gt;         &gt;<br>&gt;         &gt; for view in sequence(initial: someView, next: { $0.<br>&gt;         &gt; superview }) {<br>&gt;         &gt;<br>&gt;         &gt; // someView, someView.superview, someView.superview.superview, ...<br>&gt;         &gt;<br>&gt;         &gt; }<br>&gt;         &gt;<br>&gt;         &gt;<br>&gt;         &gt; should be:<br>&gt;         &gt;<br>&gt;         &gt; for view in sequence(state: someView, next: { $0.<br>&gt;         &gt; superview }) {<br>&gt;         &gt;<br>&gt;         &gt; // someView, someView.superview, someView.superview.superview, ...<br>&gt;         &gt;<br>&gt;         &gt; }<br>&gt;<br>&gt;         I don&#39;t think these are mistakes—in each iteration of the loop, $0 is<br>&gt;         supposed to be the view from the previous iteration.<br>&gt;<br>&gt;         If you wanted an example using `state`, here&#39;s one which is roughly<br>&gt;         equivalent to `stride(from: 1.0, to: 2.0, by: 0.1)`, using a<br>&gt;         non-error-accumulating algorithm:<br>&gt;<br>&gt;         let start = 1.0<br>&gt;<br>&gt;         let end = 2.0<br>&gt;<br>&gt;         let distance = 0.1<br>&gt;<br>&gt;         for color in sequence(state: -1.0, next: { $0 += 1; let next = start +<br>&gt;         $0 * distance; return next &lt; end ? next : nil }) {<br>&gt;<br>&gt;         …<br>&gt;<br>&gt;         }<br>&gt;<br>&gt;         --<br>&gt;         Brent Royal-Gordon<br>&gt;         Architechies<br>&gt;<br>&gt;     -- <br>&gt;<br>&gt;     Trent Nadeau<br>&gt;<br>&gt;     _______________________________________________<br>&gt;<br>&gt;     swift-evolution mailing list<br>&gt;<br>&gt;     swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 19, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; <br>&gt;         * What is your evaluation of the proposal?<br></p><p>+1.  These functions are really handy.  The standard library should definitely include commonly useful utilities like these.<br></p><p>&gt;         * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.  It’s best to have these in the standard library rather than all creating our own versions.<br></p><p>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt;         * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I like that this proposal modifies the signature of `sequence(state:next:) to use `inout`.  The ability to do this is an advantage Swift has over functional languages.<br></p><p>&gt;         * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Quick reading, but also followed the discussions and the prior review.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/2a88d8d4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 19, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>This is an important and positive addition to the standard library. It allows us to quickly build ad-hoc sequences and, combined with `prefix(while:)`, easily simulates most of what the C-style `for` loop could do. I can easily imagine using this to convert complex `while let` loops like parent chain walking into `for` loops, create infinite sequences, prototype interesting generators, and do lots of other things that currently require much more work.<br></p><p>I especially like the way `sequence(state:next:)` is designed, with an `inout` state. The traditional functional design is quite awkward; this way is much better.<br></p><p>I could bikeshed the names a little—I&#39;d prefer `sequence(first:next:)` and `sequence(state:each:)` to represent the slightly different roles the parameters have in the two calls—but ultimately this is a really solid design and I&#39;m looking forward to seeing it in Swift.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. Enough pixels have been spilled over the C-style for loop alone. Let&#39;s put it to bed.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes. This is a super-flexible and elegant design, inspired by functional programming languages but much more usable in many ways.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I&#39;ve written a few loops that I would rewrite using `sequence(initial:next:)` now that it&#39;s available, but I&#39;ve never actually used `unfold` or any equivalent to this function even in languages which supported them. They just seemed too abstract and disconnected from the problem I was trying to solve. `sequence(initial:next:)` avoids that problem by squarely addressing the common use case.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I&#39;ve participated in discussions surrounding this feature from the beginning, including some private prototyping. (My prototype was `induce(from:while:by:)`; its naming turned out to be too clever by half, even in my own estimation, and the `while:` part turned out to be separable as `prefix(while:)`.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Review] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>May 20, 2016 at 02:00:00pm</p></header><div class="content"><p>* What is your evaluation of the proposal?<br>+1. These are useful additions to the standard library.<br></p><p>Naming the first argument `initial` (in the `T-&gt;T?` variant) is consistent with `reduce` and makes it clear (to me) that the initial value is part of the result. <br></p><p>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes, these are good building blocks for other functionality and are useful additions to the standard library <br></p><p>	* Does this proposal fit well with the feel and direction of Swift?<br>Yes, in both naming and functionality it fits well with existing functions for operating on sequences and collections. Using inout for the state argument nicely leverages the fact that Swift can be functional without some of the restrictions of a _purely_ functional language.<br></p><p>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>I’ve used iterate and unfold in Haskell. These additions are true to the usefulness of those two functions, in a Swift style (see above).<br></p><p>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>Participated in the discussion and review of SE-0045 and the discussion that followed it being accepted with modifications.<br></p><p>- David<br></p><p><br>&gt; On 20 May 2016, at 00:29, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib&quot; begins now and runs through May 23. This is a refinement of part of SE-0045.  The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0094-sequence-function.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[Review] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>May 23, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On 19 May 2016, at 23:29, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1<br></p><p>I think I would find myself using this in loads of places, if it was implemented.<br></p><p>One question: what is the downside of making these functions `rethrows` and allowing the closure to throw?<br></p><p><br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. I probably implement something similar to this in every project.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I’ve dabbled in Haskell but I wouldn’t claim to have used its equivalent of this feature.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I read the proposal and the previous responses.<br></p><p><br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>May 23, 2016 at 02:00:00pm</p></header><div class="content"><p>On Mon, May 23, 2016, at 05:44 AM, Jeremy Pereira via swift-evolution wrote:<br>&gt; <br>&gt; &gt; On 19 May 2016, at 23:29, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; I think I would find myself using this in loads of places, if it was implemented.<br>&gt; <br>&gt; One question: what is the downside of making these functions `rethrows` and allowing the closure to throw?<br></p><p>They wouldn&#39;t be lazy anymore.<br></p><p>-Kevin Ballard<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
