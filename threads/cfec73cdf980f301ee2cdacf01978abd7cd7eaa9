<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c155243169db74a7787bab9d57a1c3d6?s=50"></div><header><strong>Add max/min to floating point types</strong> from <string>Darren Mo</string> &lt;darren.mo at me.com&gt;<p>June 10, 2016 at 02:00:00pm</p></header><div class="content"><p>Today, one can get max/min by doing:<br></p><p>let max = Float.greatestFiniteMagnitude<br>let min = -Float.greatestFiniteMagnitude<br></p><p>I propose that the floating point types expose properties for max/min.<br></p><p>max, in particular, is used quite a lot in UI code for fixed-width layout of text. But having to spell out greatestFiniteMagnitude every time is a pain. For example…<br></p><p>Compare this:<br>extension NSTextView {<br>   func configureForFixedWidth() {<br>      minSize = NSSize.zero<br>      maxSize = NSSize(width: CGFloat.greatestFiniteMagnitude, height: CGFloat.greatestFiniteMagnitude)<br>      isHorizontallyResizable = false<br>      isVerticallyResizable = true<br></p><p>      textContainer?.containerSize = NSSize(width: bounds.width, height: CGFloat.greatestFiniteMagnitude)<br>      textContainer?.widthTracksTextView = true<br>   }<br>}<br></p><p>To this:<br>extension NSTextView {<br>   func configureForFixedWidth() {<br>      minSize = NSSize.zero<br>      maxSize = NSSize(width: CGFloat.max, height: CGFloat.max)<br>      isHorizontallyResizable = false<br>      isVerticallyResizable = true<br></p><p>      textContainer?.containerSize = NSSize(width: bounds.width, height: CGFloat.max)<br>      textContainer?.widthTracksTextView = true<br>   }<br>}<br></p><p>The latter snippet is much more understandable (and less typing). It is more understandable because users don’t have to know exactly how floating point works in order to get the equivalent of Int.max/Int.min for CGFloat.<br></p><p>One of the concerns with naming them max/min is that infinity/-infinity is technically the real max/min. We could name them finiteMax/finiteMin, but I think keeping the names consistent with Int et al. is important since they serve the same purpose. Besides, I think dealing with infinity is rare in real-world usage. Those that are using infinity know that it is obviously the true max.<br></p><p>I think adding these floating point properties is in line with Swift 3’s goals of consistency and refinement.<br></p><p>Thoughts?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/cfeceaa9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Add max/min to floating point types</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 10, 2016 at 01:00:00pm</p></header><div class="content"><p>CGFloat has .max and .min. And if you use them, you get:<br>2016-06-10 13:32:14.185 Untitled Page 10[18435:13174627] This NSLayoutConstraint is being configured with a constant that exceeds internal limits.  A smaller value will be substituted, but this problem should be fixed. Break on void _NSLayoutConstraintNumberExceedsLimit() to debug.  This will be logged only once.  This may break in the future.<br></p><p>-- E<br></p><p>&gt; On Jun 10, 2016, at 12:24 PM, Darren Mo via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Today, one can get max/min by doing:<br>&gt; <br>&gt; let max = Float.greatestFiniteMagnitude<br>&gt; let min = -Float.greatestFiniteMagnitude<br>&gt; <br>&gt; I propose that the floating point types expose properties for max/min.<br>&gt; <br>&gt; max, in particular, is used quite a lot in UI code for fixed-width layout of text. But having to spell out greatestFiniteMagnitude every time is a pain. For example…<br>&gt; <br>&gt; Compare this:<br>&gt; extension NSTextView {<br>&gt;    func configureForFixedWidth() {<br>&gt;       minSize = NSSize.zero<br>&gt;       maxSize = NSSize(width: CGFloat.greatestFiniteMagnitude, height: CGFloat.greatestFiniteMagnitude)<br>&gt;       isHorizontallyResizable = false<br>&gt;       isVerticallyResizable = true<br>&gt; <br>&gt;       textContainer?.containerSize = NSSize(width: bounds.width, height: CGFloat.greatestFiniteMagnitude)<br>&gt;       textContainer?.widthTracksTextView = true<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; To this:<br>&gt; extension NSTextView {<br>&gt;    func configureForFixedWidth() {<br>&gt;       minSize = NSSize.zero<br>&gt;       maxSize = NSSize(width: CGFloat.max, height: CGFloat.max)<br>&gt;       isHorizontallyResizable = false<br>&gt;       isVerticallyResizable = true<br></p><p>&gt; <br>&gt;       textContainer?.containerSize = NSSize(width: bounds.width, height: CGFloat.max)<br>&gt;       textContainer?.widthTracksTextView = true<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; The latter snippet is much more understandable (and less typing). It is more understandable because users don’t have to know exactly how floating point works in order to get the equivalent of Int.max/Int.min for CGFloat.<br>&gt; <br>&gt; One of the concerns with naming them max/min is that infinity/-infinity is technically the real max/min. We could name them finiteMax/finiteMin, but I think keeping the names consistent with Int et al. is important since they serve the same purpose. Besides, I think dealing with infinity is rare in real-world usage. Those that are using infinity know that it is obviously the true max.<br>&gt; <br>&gt; I think adding these floating point properties is in line with Swift 3’s goals of consistency and refinement.<br>&gt; <br>&gt; Thoughts?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/e5753c02/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c155243169db74a7787bab9d57a1c3d6?s=50"></div><header><strong>Add max/min to floating point types</strong> from <string>Darren Mo</string> &lt;darren.mo at me.com&gt;<p>June 10, 2016 at 04:00:00pm</p></header><div class="content"><p>Interesting. I didn’t know that you couldn’t use CGFloat.max/CGFloat.min (aka CGFloat.greatestFiniteMagnitude/CGFloat.leastNormalMagnitude) with auto layout. Good to know.<br></p><p>However, I was not referring to auto layout, but to the calculation of text height based on a fixed width. Like:<br></p><p>let fixedWidthSize = CGSize(width: myWidth, height: CGFloat.greatestFiniteMagnitude)<br>let textHeight = myLabel.sizeThatFits(fixedWidthSize).height<br></p><p>I have done this many times before with no errors and I have seen other people do this too. (Surely you have as well!)<br></p><p>&gt; On Jun 10, 2016, at 3:32 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; CGFloat has .max and .min. And if you use them, you get:<br>&gt; 2016-06-10 13:32:14.185 Untitled Page 10[18435:13174627] This NSLayoutConstraint is being configured with a constant that exceeds internal limits.  A smaller value will be substituted, but this problem should be fixed. Break on void _NSLayoutConstraintNumberExceedsLimit() to debug.  This will be logged only once.  This may break in the future.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt;&gt; On Jun 10, 2016, at 12:24 PM, Darren Mo via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Today, one can get max/min by doing:<br>&gt;&gt; <br>&gt;&gt; let max = Float.greatestFiniteMagnitude<br>&gt;&gt; let min = -Float.greatestFiniteMagnitude<br>&gt;&gt; <br>&gt;&gt; I propose that the floating point types expose properties for max/min.<br>&gt;&gt; <br>&gt;&gt; max, in particular, is used quite a lot in UI code for fixed-width layout of text. But having to spell out greatestFiniteMagnitude every time is a pain. For example…<br>&gt;&gt; <br>&gt;&gt; Compare this:<br>&gt;&gt; extension NSTextView {<br>&gt;&gt;    func configureForFixedWidth() {<br>&gt;&gt;       minSize = NSSize.zero<br>&gt;&gt;       maxSize = NSSize(width: CGFloat.greatestFiniteMagnitude, height: CGFloat.greatestFiniteMagnitude)<br>&gt;&gt;       isHorizontallyResizable = false<br>&gt;&gt;       isVerticallyResizable = true<br>&gt;&gt; <br>&gt;&gt;       textContainer?.containerSize = NSSize(width: bounds.width, height: CGFloat.greatestFiniteMagnitude)<br>&gt;&gt;       textContainer?.widthTracksTextView = true<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; To this:<br>&gt;&gt; extension NSTextView {<br>&gt;&gt;    func configureForFixedWidth() {<br>&gt;&gt;       minSize = NSSize.zero<br>&gt;&gt;       maxSize = NSSize(width: CGFloat.max, height: CGFloat.max)<br>&gt;&gt;       isHorizontallyResizable = false<br>&gt;&gt;       isVerticallyResizable = true<br>&gt; <br>&gt;&gt; <br>&gt;&gt;       textContainer?.containerSize = NSSize(width: bounds.width, height: CGFloat.max)<br>&gt;&gt;       textContainer?.widthTracksTextView = true<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The latter snippet is much more understandable (and less typing). It is more understandable because users don’t have to know exactly how floating point works in order to get the equivalent of Int.max/Int.min for CGFloat.<br>&gt;&gt; <br>&gt;&gt; One of the concerns with naming them max/min is that infinity/-infinity is technically the real max/min. We could name them finiteMax/finiteMin, but I think keeping the names consistent with Int et al. is important since they serve the same purpose. Besides, I think dealing with infinity is rare in real-world usage. Those that are using infinity know that it is obviously the true max.<br>&gt;&gt; <br>&gt;&gt; I think adding these floating point properties is in line with Swift 3’s goals of consistency and refinement.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/cbf781a0/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Add max/min to floating point types</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 10, 2016 at 02:00:00pm</p></header><div class="content"><p>On Fri, Jun 10, 2016 at 1:24 PM, Darren Mo via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Today, one can get max/min by doing:<br>&gt;<br>&gt; let max = Float.greatestFiniteMagnitude<br>&gt; let min = -Float.greatestFiniteMagnitude<br>&gt;<br></p><p>On review of the proposal for the new FloatingPoint, I too commented on the<br>lack of `max` and `min`. You&#39;ve pointed out the issue with infinity. But<br>also, FLT_MIN (from your local friendly C universe and available in Swift,<br>obviously) is actually the smallest representable positive value, so<br>`Float.min` is of ambiguous meaning. It was therefore decided not to use<br>those words `max` and `min`.<br></p><p><br>&gt;<br>&gt; I propose that the floating point types expose properties for max/min.<br>&gt;<br>&gt; max, in particular, is used quite a lot in UI code for fixed-width layout<br>&gt; of text. But having to spell out greatestFiniteMagnitude every time is a<br>&gt; pain. For example…<br>&gt;<br>&gt; Compare this:<br>&gt; extension NSTextView {<br>&gt;    func configureForFixedWidth() {<br>&gt;       minSize = NSSize.zero<br>&gt;       maxSize = NSSize(width: CGFloat.greatestFiniteMagnitude,<br>&gt; height: CGFloat.greatestFiniteMagnitude)<br>&gt;       isHorizontallyResizable = false<br>&gt;       isVerticallyResizable = true<br>&gt;<br>&gt;       textContainer?.containerSize = NSSize(width: bounds.width,<br>&gt; height: CGFloat.greatestFiniteMagnitude)<br>&gt;       textContainer?.widthTracksTextView = true<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; To this:<br>&gt; extension NSTextView {<br>&gt;    func configureForFixedWidth() {<br>&gt;       minSize = NSSize.zero<br>&gt;       maxSize = NSSize(width: CGFloat.max, height: CGFloat.max)<br>&gt;       isHorizontallyResizable = false<br>&gt;       isVerticallyResizable = true<br>&gt;<br>&gt;       textContainer?.containerSize = NSSize(width: bounds.width, height:<br>&gt;  CGFloat.max)<br>&gt;       textContainer?.widthTracksTextView = true<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; The latter snippet is much more understandable (and less typing). It is<br>&gt; more understandable because users don’t have to know exactly how floating<br>&gt; point works in order to get the equivalent of Int.max/Int.min for CGFloat.<br>&gt;<br>&gt; One of the concerns with naming them max/min is that infinity/-infinity<br>&gt; is technically the real max/min. We could name them finiteMax/finiteMin,<br>&gt; but I think keeping the names consistent with Int et al. is important<br>&gt; since they serve the same purpose. Besides, I think dealing with infinity<br>&gt; is rare in real-world usage. Those that are using infinity know that it<br>&gt; is obviously the true max.<br>&gt;<br>&gt; I think adding these floating point properties is in line with Swift 3’s<br>&gt; goals of consistency and refinement.<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/cd6ed5cd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Add max/min to floating point types</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>June 10, 2016 at 03:00:00pm</p></header><div class="content"><p>On Jun 10, 2016, at 12:38 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Fri, Jun 10, 2016 at 1:24 PM, Darren Mo via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Today, one can get max/min by doing:<br>&gt; <br>&gt; let max = Float.greatestFiniteMagnitude<br>&gt; let min = -Float.greatestFiniteMagnitude<br>&gt; <br>&gt; On review of the proposal for the new FloatingPoint, I too commented on the lack of `max` and `min`. You&#39;ve pointed out the issue with infinity. But also, FLT_MIN (from your local friendly C universe and available in Swift, obviously) is actually the smallest representable positive value, so `Float.min` is of ambiguous meaning. It was therefore decided not to use those words `max` and `min`.<br></p><p>It’s worth noting that this issue has been pretty extensively discussed both on- and off-list.  Although convenience is good, the objections to the ambiguity of `.max` and `.min` would be *very* hard to overcome:<br></p><p>– They’re not actually the maximum and minimum values of the type.  In particular, that `max(Float.infinity, .max)` wouldn’t be `Float.max` is pretty seriously confusing.<br></p><p>– The proposed `.min` doesn&#39;t align with the meaning of the &quot;float-min-thing” in most other major languages:<br></p><p>	In C, FLT_MIN is the smallest positive normal<br>	In C++, std::numeric_limits&lt;float&gt;::min() is the smallest positive normal<br>	In Python, sys.float_info.min is the smallest positive normal<br>	In C#, .minValue is documented as “the smallest possible value”, but is actually the value you want, rather than the documented –infinity.<br>	In Java, MIN_VALUE is the smallest positive value (including subnormals)<br>	In Ruby, MIN is the smallest positive normal<br>	In R, double.xmin is the smallest positive normal<br>	In MATLAB, realmin is the smallest positive normal<br>	Actually, Rust is the only language I know of where `MIN` is the value you want *and* correctly documented as such.<br></p><p>All that’s not to say that Swift can’t do this, but there’s a lot of opportunity for confusion on this point, and having a very explicit name isn’t really a bad thing.<br></p><p>– There is also some concern that having `.min` and `.max` with the same names as on Integer types would lead people to try to use them the same way in code, which generally isn’t going to work the way users expect.<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/285e2cf2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c155243169db74a7787bab9d57a1c3d6?s=50"></div><header><strong>Add max/min to floating point types</strong> from <string>Darren Mo</string> &lt;darren.mo at me.com&gt;<p>June 10, 2016 at 08:00:00pm</p></header><div class="content"><p>Thanks for the summary of the arguments against max/min! Comments inline.<br></p><p>&gt; On Jun 10, 2016, at 6:51 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; <br>&gt; On Jun 10, 2016, at 12:38 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Fri, Jun 10, 2016 at 1:24 PM, Darren Mo via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Today, one can get max/min by doing:<br>&gt;&gt; <br>&gt;&gt; let max = Float.greatestFiniteMagnitude<br>&gt;&gt; let min = -Float.greatestFiniteMagnitude<br>&gt;&gt; <br>&gt;&gt; On review of the proposal for the new FloatingPoint, I too commented on the lack of `max` and `min`. You&#39;ve pointed out the issue with infinity. But also, FLT_MIN (from your local friendly C universe and available in Swift, obviously) is actually the smallest representable positive value, so `Float.min` is of ambiguous meaning. It was therefore decided not to use those words `max` and `min`.<br>&gt; <br>&gt; It’s worth noting that this issue has been pretty extensively discussed both on- and off-list.  Although convenience is good, the objections to the ambiguity of `.max` and `.min` would be *very* hard to overcome:<br>&gt; <br>&gt; – They’re not actually the maximum and minimum values of the type.  In particular, that `max(Float.infinity, .max)` wouldn’t be `Float.max` is pretty seriously confusing.<br></p><p>Infinity is a special value. I would argue that people who use infinity know exactly what they are doing and would not be thrown by Float.infinity being greater than Float.max. I am willing to bet that most regular users don’t even know that infinity can be represented since it is rarely needed in real-world usage.<br></p><p>&gt; <br>&gt; – The proposed `.min` doesn&#39;t align with the meaning of the &quot;float-min-thing” in most other major languages:<br>&gt; <br>&gt; 	In C, FLT_MIN is the smallest positive normal<br>&gt; 	In C++, std::numeric_limits&lt;float&gt;::min() is the smallest positive normal<br>&gt; 	In Python, sys.float_info.min is the smallest positive normal<br>&gt; 	In C#, .minValue is documented as “the smallest possible value”, but is actually the value you want, rather than the documented –infinity.<br>&gt; 	In Java, MIN_VALUE is the smallest positive value (including subnormals)<br>&gt; 	In Ruby, MIN is the smallest positive normal<br>&gt; 	In R, double.xmin is the smallest positive normal<br>&gt; 	In MATLAB, realmin is the smallest positive normal<br>&gt; 	Actually, Rust is the only language I know of where `MIN` is the value you want *and* correctly documented as such.<br>&gt; <br>&gt; All that’s not to say that Swift can’t do this, but there’s a lot of opportunity for confusion on this point, and having a very explicit name isn’t really a bad thing.<br></p><p>I think if we have .min *and* .leastNormalMagnitude *and* .leastNonzeroMagnitude, then there is no ambiguity or confusion. Moreover, I would suspect most people naturally think of .min as the most-negative number that can be represented (c.f. the top search results for “FLT_MIN”). If this is true, then we have an opportunity to align the language with the user’s true desires instead of just following precedent.<br></p><p>&gt; <br>&gt; – There is also some concern that having `.min` and `.max` with the same names as on Integer types would lead people to try to use them the same way in code, which generally isn’t going to work the way users expect.<br></p><p>What is an example of this?<br></p><p>&gt; <br>&gt; – Steve<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/e1c00b06/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Add max/min to floating point types</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 11, 2016 at 12:00:00pm</p></header><div class="content"><p>Agree with all you said<br></p><p>&gt; On 11 Jun 2016, at 02:20, Darren Mo via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for the summary of the arguments against max/min! Comments inline.<br>&gt; <br>&gt;&gt; On Jun 10, 2016, at 6:51 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 10, 2016, at 12:38 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, Jun 10, 2016 at 1:24 PM, Darren Mo via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Today, one can get max/min by doing:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let max = Float.greatestFiniteMagnitude<br>&gt;&gt;&gt;&gt; let min = -Float.greatestFiniteMagnitude<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On review of the proposal for the new FloatingPoint, I too commented on the lack of `max` and `min`. You&#39;ve pointed out the issue with infinity. But also, FLT_MIN (from your local friendly C universe and available in Swift, obviously) is actually the smallest representable positive value, so `Float.min` is of ambiguous meaning. It was therefore decided not to use those words `max` and `min`.<br>&gt;&gt; <br>&gt;&gt; It’s worth noting that this issue has been pretty extensively discussed both on- and off-list.  Although convenience is good, the objections to the ambiguity of `.max` and `.min` would be *very* hard to overcome:<br>&gt;&gt; <br>&gt;&gt; – They’re not actually the maximum and minimum values of the type.  In particular, that `max(Float.infinity, .max)` wouldn’t be `Float.max` is pretty seriously confusing.<br>&gt; <br>&gt; Infinity is a special value. I would argue that people who use infinity know exactly what they are doing and would not be thrown by Float.infinity being greater than Float.max. I am willing to bet that most regular users don’t even know that infinity can be represented since it is rarely needed in real-world usage.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; – The proposed `.min` doesn&#39;t align with the meaning of the &quot;float-min-thing” in most other major languages:<br>&gt;&gt; <br>&gt;&gt; 	In C, FLT_MIN is the smallest positive normal<br>&gt;&gt; 	In C++, std::numeric_limits&lt;float&gt;::min() is the smallest positive normal<br>&gt;&gt; 	In Python, sys.float_info.min is the smallest positive normal<br>&gt;&gt; 	In C#, .minValue is documented as “the smallest possible value”, but is actually the value you want, rather than the documented –infinity.<br>&gt;&gt; 	In Java, MIN_VALUE is the smallest positive value (including subnormals)<br>&gt;&gt; 	In Ruby, MIN is the smallest positive normal<br>&gt;&gt; 	In R, double.xmin is the smallest positive normal<br>&gt;&gt; 	In MATLAB, realmin is the smallest positive normal<br>&gt;&gt; 	Actually, Rust is the only language I know of where `MIN` is the value you want *and* correctly documented as such.<br>&gt;&gt; <br>&gt;&gt; All that’s not to say that Swift can’t do this, but there’s a lot of opportunity for confusion on this point, and having a very explicit name isn’t really a bad thing.<br>&gt; <br>&gt; I think if we have .min *and* .leastNormalMagnitude *and* .leastNonzeroMagnitude, then there is no ambiguity or confusion. Moreover, I would suspect most people naturally think of .min as the most-negative number that can be represented (c.f. the top search results for “FLT_MIN”). If this is true, then we have an opportunity to align the language with the user’s true desires instead of just following precedent.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; – There is also some concern that having `.min` and `.max` with the same names as on Integer types would lead people to try to use them the same way in code, which generally isn’t going to work the way users expect.<br>&gt; <br>&gt; What is an example of this?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; – Steve<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160611/22ff7d16/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Add max/min to floating point types</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>June 12, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 10, 2016, at 5:20 PM, Darren Mo &lt;darren.mo at me.com&gt; wrote:<br>&gt; <br>&gt;&gt; – They’re not actually the maximum and minimum values of the type.  In particular, that `max(Float.infinity, .max)` wouldn’t be `Float.max` is pretty seriously confusing.<br>&gt; <br>&gt; Infinity is a special value. I would argue that people who use infinity know exactly what they are doing and would not be thrown by Float.infinity being greater than Float.max. I am willing to bet that most regular users don’t even know that infinity can be represented since it is rarely needed in real-world usage.<br></p><p>For clarity, what use cases do you have in mind where the largest finite value is more appropriate than infinity?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160612/da79ff4b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c155243169db74a7787bab9d57a1c3d6?s=50"></div><header><strong>Add max/min to floating point types</strong> from <string>Darren Mo</string> &lt;darren.mo at me.com&gt;<p>June 12, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jun 12, 2016, at 11:35 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 10, 2016, at 5:20 PM, Darren Mo &lt;darren.mo at me.com &lt;mailto:darren.mo at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; – They’re not actually the maximum and minimum values of the type.  In particular, that `max(Float.infinity, .max)` wouldn’t be `Float.max` is pretty seriously confusing.<br>&gt;&gt; <br>&gt;&gt; Infinity is a special value. I would argue that people who use infinity know exactly what they are doing and would not be thrown by Float.infinity being greater than Float.max. I am willing to bet that most regular users don’t even know that infinity can be represented since it is rarely needed in real-world usage.<br>&gt; <br>&gt; For clarity, what use cases do you have in mind where the largest finite value is more appropriate than infinity?<br></p><p>That… is a very good question.<br></p><p>My main use case was laying out fixed-width text. In the Objective-C days, I would use CGFLOAT_MAX. I guess when I started to write the same code in Swift, I didn’t stop to think about whether there was a better value. Now thanks to you, I see that CGFloat.infinity is the clearest and most appropriate value.<br></p><p>Proposal cancelled. Thanks! ☺️<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160612/0b2dad73/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
