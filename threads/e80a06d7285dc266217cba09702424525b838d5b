<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 10, 2016 at 10:00:00am</p></header><div class="content"><p>on Fri Apr 08 2016, Dietmar Planitzer &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The biggest missing part with this model is that we are still not able<br>&gt; to enable macro-level optimizations in the delegating type by checking<br>&gt; whether the delegate does provide his own implementation of an<br>&gt; optional method or doesn’t. However, this is an important advantage of<br>&gt; the ObjC model that we should not lose.<br>&gt;<br>&gt; Maybe it’s time to take a big step back and ignore the question of how<br>&gt; to implement things for a moment and to instead focus on the question<br>&gt; of what the conceptual differences are between ObjC protocols with<br>&gt; optional methods and Swift protocols with default<br>&gt; implementations. There are two relevant viewpoints here:<br>&gt;<br>&gt; 1) From the viewpoint of a protocol adaptor:<br>&gt;<br>&gt; ObjC:<br>&gt;<br>&gt; 1a) adopter may provide his own implementation of the protocol method,<br>&gt; but he is no required to.<br>&gt;<br>&gt; 1b) adopter can see in the protocol declaration for which methods he<br>&gt; must provide an implementation. Those methods do not have the<br>&gt; “optional” keyword in front of them while optional methods do.<br>&gt;<br>&gt; Swift:<br>&gt;<br>&gt; 1c) same as (1a).<br>&gt;<br>&gt; 1d) opening a binary-only Swift file in Xcode with a protocol<br>&gt; definition in it which contains methods with default implementations<br>&gt; will not give any indication of which method has a default<br>&gt; implementation and which doesn’t. It’s only possible to see a<br>&gt; difference on the syntax level if you have access to the sources.<br></p><p>This visibility problem is something we aim to correct in Swift, but<br>that is a question of syntax, documentation, and “header” generation,<br>and really orthogonal to what&#39;s fundamental about “optional<br>requirements:” <br></p><p>1. The ability to “conform” to the protocol without a<br>   default implementation of the requirement have been provided<br>   anywhere.<br></p><p>2. The ability to dynamically query whether a type actually provides the<br>   requirement.<br></p><p>Both of these “features,” IMO, are actually bugs.<br></p><p>&gt; So from the viewpoint of the protocol adopter, there isn’t much of a<br>&gt; difference. The only relevant difference is that its always possible<br>&gt; in ObjC to tell whether a protocol method must be implemented by the<br>&gt; adopter or whether a method already has a default behavior. We<br>&gt; shouldn’t actually have to change anything on the syntax-level in<br>&gt; Swift to fix this problem. It should be sufficient to improve the<br>&gt; Swift interface generator in Xcode so that it gives an indication<br>&gt; whether a protocol method has a default implementation or doesn’t. Eg<br>&gt; if we want to ensure that the generated interface is valid syntax then<br>&gt; we could do this:<br>&gt;<br>&gt; protocol Foo {<br>&gt;<br>&gt;    func void bar() -&gt; Int /* has default */<br>&gt;<br>&gt; }<br>&gt;<br>&gt; or if we say that it is fine that the generated interface is not valid<br>&gt; syntax (I think it already shows &quot;= default” for function arguments<br>&gt; with a default value which I don’t think is valid syntax), then we<br>&gt; could do this:<br>&gt;<br>&gt; protocol Foo {<br>&gt;<br>&gt;    func void bar() -&gt; Int {…}<br>&gt;<br>&gt; }<br>&gt;<br>&gt; Now on to the other side of the equation.<br>&gt;<br>&gt; 2) From the viewpoint of the protocol provider (the person who defines<br>&gt; the protocol and the type that will invoke the protocol methods):<br>&gt;<br>&gt; ObjC:<br>&gt;<br>&gt; 2a) provider has freedom in deciding where to put the default<br>&gt; implementation and he can put the default implementation in a single<br>&gt; place or spread it out if necessary over multiple places. So has the<br>&gt; freedom to choose whatever makes the most sense for the problem at<br>&gt; hand.<br></p><p>But freedom for protocol implementors reduces predictability for protocol<br>clients and adopters.<br></p><p>&gt; 2b) provider can detect whether the adopter provides his own protocol<br>&gt; method implementation without compromising the definition of the<br>&gt; protocol (compromising here means making return values optional when<br>&gt; they should not be optional based on the natural definition of the<br>&gt; API). This enables the provider to implement macro-level optimizations<br>&gt; (eg table view can understand whether fixed or variable row heights<br>&gt; are desired).<br>&gt;<br>&gt; Swift:<br>&gt;<br>&gt; 2c) provider is forced to put the default implementation in a specific<br>&gt; place.<br>&gt;<br>&gt; 2d) provider has no way to detect whether the adopter has provided his<br>&gt; own implementation of the protocol method.<br>&gt;<br>&gt; I do think that (2a) would be nice to have but we can probably do<br>&gt; without it if it helps us to make progress with this topic. However,<br>&gt; the ability to detect whether a protocol adopter provides his own<br>&gt; implementation of a protocol method which comes with a default is a<br>&gt; useful and important feature which helps us in optimizing the<br>&gt; implementation of types and which allows us to keep the API surface<br>&gt; smaller than it would be without this ability. Just go and compare eg<br>&gt; UITableView to the Android ListView / RecyclerView to see the<br>&gt; consequences of not having that ability and how it inflates the API<br>&gt; surface (and keep in mind that the Android equivalents provide a<br>&gt; fraction of the UITableView functionality).<br>&gt;<br>&gt; The important point about (2b) is actually that we are able to detect<br>&gt; whether an “override” (I’ll just call this overriding for now) of the<br>&gt; default implementation exists or does not exist. <br></p><p>IMO the important point about (2b) is that it leads to protocol designs<br>that create work and complexity for clients of the protocol, and being<br>constrained to make your protocol work so that clients don&#39;t have to do<br>these kinds of checks is a Very Good Thing™.<br></p><p>&gt; In ObjC we make this distinction by checking whether an implementation<br>&gt; of the method exists at all. But we don’t have to do it that way. An<br>&gt; alternative approach could be based on a check that sees whether the<br>&gt; dispatch table of the delegate contains a pointer to the default<br>&gt; implementation of the protocol method or to some other method. So<br>&gt; conceptually what we want is an operation like this:<br>&gt;<br>&gt; func void useDelegate(delegate: NSTableViewDelegate) {<br>&gt;<br>&gt;    if has_override(delegate, tableView(_:, heightOfRow:)) { // ask the<br>&gt; delegate how many rows it has // allocate the geometry cache // fill<br>&gt; in the geometry cache by calling tableView(_:, heightForRow:) for each<br>&gt; row } else { // nothing to do here } }<br>&gt;<br>&gt; Which would get the job done but doesn’t look good. Maybe someone has<br>&gt; a better idea of how the syntax such an operator could look.<br>&gt;<br>&gt; So my point here is that what we care about is the ability to detect<br>&gt; whether the adopter provides an implementation of a protocol method<br>&gt; which comes with a default implementation. The point is not that Swift<br>&gt; protocols should work the exact same way that ObjC protocols have been<br>&gt; working under the hood. But I do think that we want to eventually get<br>&gt; to a point where the @objc attribute disappears and that we get a<br>&gt; truly unified language on the syntactical level. An approach where:<br>&gt;<br>&gt; I) we accept that the default behavior of a protocol method has to be<br>&gt; provided by the protocol itself<br>&gt;<br>&gt; II) the language is extended with a mechanism that makes it possible<br>&gt; for a protocol provider to detect whether the adopter has “overridden”<br>&gt; the default implementation<br>&gt;<br>&gt; III) we improve the Xcode Swift interface generator so that it gives a<br>&gt; clear indication whether a protocol method does come with a default<br>&gt; implementation<br>&gt;<br>&gt; would give us all the relevant advantages of ObjC-style optional<br>&gt; protocol methods and it should allow us to create a unified syntax<br>&gt; where there is no longer a visible difference between an optional<br>&gt; protocol method that was imported from ObjC and a native Swift<br>&gt; protocol with default implementations.<br>&gt;<br>&gt; Regards,<br>&gt;<br>&gt; Dietmar Planitzer<br>&gt;<br>&gt;&gt; On Apr 7, 2016, at 17:12, Douglas Gregor via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Optional protocol requirements in Swift have the restriction that<br>&gt;&gt; they only work in @objc protocols, a topic that’s come up a number<br>&gt;&gt; of times. The start of these threads imply that optional<br>&gt;&gt; requirements should be available for all protocols in Swift. While<br>&gt;&gt; this direction is implementable, each time this is discussed there<br>&gt;&gt; is significant feedback that optional requirements are not a feature<br>&gt;&gt; we want in Swift. They overlap almost completely with default<br>&gt;&gt; implementations of protocol requirements, which is a more general<br>&gt;&gt; feature, and people seem to feel that designs based around default<br>&gt;&gt; implementations and refactoring of protocol hierarchies are overall<br>&gt;&gt; better.<br>&gt;&gt;  The main concern with removing optional requirements from Swift is their impact on Cocoa: Objective-C protocols, especially for delegates and data sources, make heavy use of optional requirements. Moreover, there are no default implementations for any of these optional requirements: each caller effectively checks for the presence of the method explicitly, and implements its own logic if the method isn’t there.<br>&gt;&gt; <br>&gt;&gt; A Non-Workable Solution: Import as optional property requirements One suggestion that’s come up to map an optional requirement to a property with optional type, were “nil” indicates that the requirement was not satisfied. For example,<br>&gt;&gt; <br>&gt;&gt; @protocol NSTableViewDelegate @optional - (nullable NSView *)tableView:(NSTableView *)tableView viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row; - (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row; @end<br>&gt;&gt; <br>&gt;&gt; currently comes in as<br>&gt;&gt; <br>&gt;&gt; @objc protocol NSTableViewDelegate { optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?  optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat }<br>&gt;&gt; <br>&gt;&gt; would come in as:<br>&gt;&gt; <br>&gt;&gt; @objc protocol NSTableViewDelegate { var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? { get } var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get } }<br>&gt;&gt; <br>&gt;&gt; with a default implementation of “nil” for each. However, this isn’t practical for a number of reasons:<br>&gt;&gt; <br>&gt;&gt; a) We would end up overloading the property name “tableView” a couple dozen times, which doesn’t actually work.<br>&gt;&gt; <br>&gt;&gt; b) You can no longer refer to the member with a compound name, e.g., “delegate.tableView(_:viewFor:row:)” no longer works, because the name of the property is “tableView”.<br>&gt;&gt; <br>&gt;&gt; c) Implementers of the protocol now need to provide a read-only property that returns a closure. So instead of<br>&gt;&gt; <br>&gt;&gt; class MyDelegate : NSTableViewDelegate { func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { … } }<br>&gt;&gt; <br>&gt;&gt; one would have to write something like<br>&gt;&gt; <br>&gt;&gt; class MyDelegate : NSTableViewDelegate { var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? = { … except you can’t refer to self in here unless you make it lazy ...  } }<br>&gt;&gt; <br>&gt;&gt; d) We’ve seriously considered eliminating argument labels on function types, because they’re a complexity in the type system that doesn’t serve much of a purpose.<br>&gt;&gt; <br>&gt;&gt; One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br>&gt;&gt; <br>&gt;&gt; Proposed Solution: Caller-side default implementations<br>&gt;&gt; <br>&gt;&gt; Default implementations and optional requirements differ most on the caller side. For example, let’s use NSTableView delegate as it’s imported today:<br>&gt;&gt; <br>&gt;&gt; func useDelegate(delegate: NSTableViewDelegate) { if let getView = delegate.tableView(_:viewFor:row:) { // since the requirement is optional, a reference to the method produces a value of optional function type // I can call getView here }<br>&gt;&gt; <br>&gt;&gt;   if let getHeight = delegate.tableView(_:heightOfRow:) { // I can call getHeight here } }<br>&gt;&gt; <br>&gt;&gt; With my proposal, we’d have some compiler-synthesized attribute (let’s call it @__caller_default_implementation) that gets places on Objective-C optional requirements when they get imported, e.g.,<br>&gt;&gt; <br>&gt;&gt; @objc protocol NSTableViewDelegate { @__caller_default_implementation func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?  @__caller_default_implementation func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat }<br>&gt;&gt; <br>&gt;&gt; And “optional” disappears from the language. Now, there’s no optionality left, so our useDelegate example tries to just do correct calls:<br>&gt;&gt; <br>&gt;&gt; func useDelegate(delegate: NSTableViewDelegate) -&gt; NSView? { let view = delegate.tableView(tableView, viewFor: column, row: row) let height = delegate.tableView(tableView, heightOfRow: row) }<br>&gt;&gt; <br>&gt;&gt; Of course, the code above will fail if the actual delegate doesn’t implement both methods. We need some kind of default implementation to fall back on in that case. I propose that the code above produce a compiler error on both lines *unless* there is a “default implementation” visible. So, to make the code above compile without error, one would have to add:<br>&gt;&gt; <br>&gt;&gt; extension NSTableViewDelegate { @nonobjc func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { return nil }<br>&gt;&gt;   <br>&gt;&gt;   @nonobjc func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { return 17 } }<br>&gt;&gt; <br>&gt;&gt; Now, the useDelegate example compiles. If the actual delegate implements the optional requirement, we’ll use that implementation. Otherwise, the caller will use the default (Swift-only) implementation it sees. From an implementation standpoint, the compiler would effectively produce the following for the first of these calls:<br>&gt;&gt; <br>&gt;&gt; if delegate.responds(to: #selector(NSTableViewDelegate.tableView(_:viewFor:row:))) { // call the @objc instance method with the selector tableView:viewForTableColumn:row: } else { // call the Swift-only implementation of tableView(_:viewFor:row:) in the protocol extension above }<br>&gt;&gt; <br>&gt;&gt; There are a number of reasons why I like this approach:<br>&gt;&gt; <br>&gt;&gt; 1) It eliminates the notion of ‘optional’ requirements from the language. For classes that are adopting the NSTableViewDelegate protocol, it is as if these requirements had default implementations.<br>&gt;&gt; <br>&gt;&gt; 2) Only the callers to these requirements have to deal with the lack<br>&gt;&gt; of default implementations. This was already the case for optional<br>&gt;&gt; requirements, so it’s not an extra burden in principle, and it’s<br>&gt;&gt; generally going to be easier to write one defaulted implementation<br>&gt;&gt; than deal with it in several different places. Additionally, most of<br>&gt;&gt; these callers are probably in the Cocoa frameworks, not application<br>&gt;&gt; code, so the overall impact should be small.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d1af757c2ce75a92193ad0c34bc62af1?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Dietmar Planitzer</string> &lt;dplanitzer at q.com&gt;<p>April 10, 2016 at 11:00:00am</p></header><div class="content"><p>I’m not sure whether you’ve read the conclusion of my mail since you’ve only commented on the introductory part. In the conclusion I wrote that a possible approach for the replacement of ObjC-style optional protocol methods would be:<br></p><p>1) the default implementation of a protocol method must be defined in the protocol (so just like in native Swift protocols today).<br></p><p>2) we add a way for a protocol provider to check whether the protocol adopter has provided an “override” of the default method.<br></p><p>3) we improve the Xcode interface generator so that it clearly shows whether a protocol method comes with a default or whether it doesn’t.<br></p><p>(1) should address your main concern since it would guarantee that the protocol provider is always able to call the protocol method without having to do any checks. (2) would address the main concern of protocol providers who need to guarantee that the protocol using type achieves a certain minimum speed and does not use more than a certain amount of memory for its internal book-keeping.<br></p><p>(3) is important because it would fix one of the many aspects that make Swift protocols confusing for people who are new to the language.<br></p><p>Finally, let me restate that the goal should really be that we completely remove the syntactical differences between @objc and native Swift protocols. There should be one concept of protocol in Swift and we should be able to cover the use cases of formal and informal ObjC Protocols with them. The use case of formal protocols is already covered today. The use case of informal protocols could be covered with the approach above.<br></p><p>So is this an approach that would be acceptable to you?<br></p><p><br>Regards,<br></p><p>Dietmar Planitzer<br></p><p><br>&gt; <br>&gt; On Apr 10, 2016, at 10:29, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Apr 08 2016, Dietmar Planitzer &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; The biggest missing part with this model is that we are still not able<br>&gt;&gt; to enable macro-level optimizations in the delegating type by checking<br>&gt;&gt; whether the delegate does provide his own implementation of an<br>&gt;&gt; optional method or doesn’t. However, this is an important advantage of<br>&gt;&gt; the ObjC model that we should not lose.<br>&gt;&gt; <br>&gt;&gt; Maybe it’s time to take a big step back and ignore the question of how<br>&gt;&gt; to implement things for a moment and to instead focus on the question<br>&gt;&gt; of what the conceptual differences are between ObjC protocols with<br>&gt;&gt; optional methods and Swift protocols with default<br>&gt;&gt; implementations. There are two relevant viewpoints here:<br>&gt;&gt; <br>&gt;&gt; 1) From the viewpoint of a protocol adaptor:<br>&gt;&gt; <br>&gt;&gt; ObjC:<br>&gt;&gt; <br>&gt;&gt; 1a) adopter may provide his own implementation of the protocol method,<br>&gt;&gt; but he is no required to.<br>&gt;&gt; <br>&gt;&gt; 1b) adopter can see in the protocol declaration for which methods he<br>&gt;&gt; must provide an implementation. Those methods do not have the<br>&gt;&gt; “optional” keyword in front of them while optional methods do.<br>&gt;&gt; <br>&gt;&gt; Swift:<br>&gt;&gt; <br>&gt;&gt; 1c) same as (1a).<br>&gt;&gt; <br>&gt;&gt; 1d) opening a binary-only Swift file in Xcode with a protocol<br>&gt;&gt; definition in it which contains methods with default implementations<br>&gt;&gt; will not give any indication of which method has a default<br>&gt;&gt; implementation and which doesn’t. It’s only possible to see a<br>&gt;&gt; difference on the syntax level if you have access to the sources.<br>&gt; <br>&gt; This visibility problem is something we aim to correct in Swift, but<br>&gt; that is a question of syntax, documentation, and “header” generation,<br>&gt; and really orthogonal to what&#39;s fundamental about “optional<br>&gt; requirements:” <br>&gt; <br>&gt; 1. The ability to “conform” to the protocol without a<br>&gt;   default implementation of the requirement have been provided<br>&gt;   anywhere.<br>&gt; <br>&gt; 2. The ability to dynamically query whether a type actually provides the<br>&gt;   requirement.<br>&gt; <br>&gt; Both of these “features,” IMO, are actually bugs.<br>&gt; <br>&gt;&gt; So from the viewpoint of the protocol adopter, there isn’t much of a<br>&gt;&gt; difference. The only relevant difference is that its always possible<br>&gt;&gt; in ObjC to tell whether a protocol method must be implemented by the<br>&gt;&gt; adopter or whether a method already has a default behavior. We<br>&gt;&gt; shouldn’t actually have to change anything on the syntax-level in<br>&gt;&gt; Swift to fix this problem. It should be sufficient to improve the<br>&gt;&gt; Swift interface generator in Xcode so that it gives an indication<br>&gt;&gt; whether a protocol method has a default implementation or doesn’t. Eg<br>&gt;&gt; if we want to ensure that the generated interface is valid syntax then<br>&gt;&gt; we could do this:<br>&gt;&gt; <br>&gt;&gt; protocol Foo {<br>&gt;&gt; <br>&gt;&gt;   func void bar() -&gt; Int /* has default */<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; or if we say that it is fine that the generated interface is not valid<br>&gt;&gt; syntax (I think it already shows &quot;= default” for function arguments<br>&gt;&gt; with a default value which I don’t think is valid syntax), then we<br>&gt;&gt; could do this:<br>&gt;&gt; <br>&gt;&gt; protocol Foo {<br>&gt;&gt; <br>&gt;&gt;   func void bar() -&gt; Int {…}<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Now on to the other side of the equation.<br>&gt;&gt; <br>&gt;&gt; 2) From the viewpoint of the protocol provider (the person who defines<br>&gt;&gt; the protocol and the type that will invoke the protocol methods):<br>&gt;&gt; <br>&gt;&gt; ObjC:<br>&gt;&gt; <br>&gt;&gt; 2a) provider has freedom in deciding where to put the default<br>&gt;&gt; implementation and he can put the default implementation in a single<br>&gt;&gt; place or spread it out if necessary over multiple places. So has the<br>&gt;&gt; freedom to choose whatever makes the most sense for the problem at<br>&gt;&gt; hand.<br>&gt; <br>&gt; But freedom for protocol implementors reduces predictability for protocol<br>&gt; clients and adopters.<br>&gt; <br>&gt;&gt; 2b) provider can detect whether the adopter provides his own protocol<br>&gt;&gt; method implementation without compromising the definition of the<br>&gt;&gt; protocol (compromising here means making return values optional when<br>&gt;&gt; they should not be optional based on the natural definition of the<br>&gt;&gt; API). This enables the provider to implement macro-level optimizations<br>&gt;&gt; (eg table view can understand whether fixed or variable row heights<br>&gt;&gt; are desired).<br>&gt;&gt; <br>&gt;&gt; Swift:<br>&gt;&gt; <br>&gt;&gt; 2c) provider is forced to put the default implementation in a specific<br>&gt;&gt; place.<br>&gt;&gt; <br>&gt;&gt; 2d) provider has no way to detect whether the adopter has provided his<br>&gt;&gt; own implementation of the protocol method.<br>&gt;&gt; <br>&gt;&gt; I do think that (2a) would be nice to have but we can probably do<br>&gt;&gt; without it if it helps us to make progress with this topic. However,<br>&gt;&gt; the ability to detect whether a protocol adopter provides his own<br>&gt;&gt; implementation of a protocol method which comes with a default is a<br>&gt;&gt; useful and important feature which helps us in optimizing the<br>&gt;&gt; implementation of types and which allows us to keep the API surface<br>&gt;&gt; smaller than it would be without this ability. Just go and compare eg<br>&gt;&gt; UITableView to the Android ListView / RecyclerView to see the<br>&gt;&gt; consequences of not having that ability and how it inflates the API<br>&gt;&gt; surface (and keep in mind that the Android equivalents provide a<br>&gt;&gt; fraction of the UITableView functionality).<br>&gt;&gt; <br>&gt;&gt; The important point about (2b) is actually that we are able to detect<br>&gt;&gt; whether an “override” (I’ll just call this overriding for now) of the<br>&gt;&gt; default implementation exists or does not exist. <br>&gt; <br>&gt; IMO the important point about (2b) is that it leads to protocol designs<br>&gt; that create work and complexity for clients of the protocol, and being<br>&gt; constrained to make your protocol work so that clients don&#39;t have to do<br>&gt; these kinds of checks is a Very Good Thing™.<br>&gt; <br>&gt;&gt; In ObjC we make this distinction by checking whether an implementation<br>&gt;&gt; of the method exists at all. But we don’t have to do it that way. An<br>&gt;&gt; alternative approach could be based on a check that sees whether the<br>&gt;&gt; dispatch table of the delegate contains a pointer to the default<br>&gt;&gt; implementation of the protocol method or to some other method. So<br>&gt;&gt; conceptually what we want is an operation like this:<br>&gt;&gt; <br>&gt;&gt; func void useDelegate(delegate: NSTableViewDelegate) {<br>&gt;&gt; <br>&gt;&gt;   if has_override(delegate, tableView(_:, heightOfRow:)) { // ask the<br>&gt;&gt; delegate how many rows it has // allocate the geometry cache // fill<br>&gt;&gt; in the geometry cache by calling tableView(_:, heightForRow:) for each<br>&gt;&gt; row } else { // nothing to do here } }<br>&gt;&gt; <br>&gt;&gt; Which would get the job done but doesn’t look good. Maybe someone has<br>&gt;&gt; a better idea of how the syntax such an operator could look.<br>&gt;&gt; <br>&gt;&gt; So my point here is that what we care about is the ability to detect<br>&gt;&gt; whether the adopter provides an implementation of a protocol method<br>&gt;&gt; which comes with a default implementation. The point is not that Swift<br>&gt;&gt; protocols should work the exact same way that ObjC protocols have been<br>&gt;&gt; working under the hood. But I do think that we want to eventually get<br>&gt;&gt; to a point where the @objc attribute disappears and that we get a<br>&gt;&gt; truly unified language on the syntactical level. An approach where:<br>&gt;&gt; <br>&gt;&gt; I) we accept that the default behavior of a protocol method has to be<br>&gt;&gt; provided by the protocol itself<br>&gt;&gt; <br>&gt;&gt; II) the language is extended with a mechanism that makes it possible<br>&gt;&gt; for a protocol provider to detect whether the adopter has “overridden”<br>&gt;&gt; the default implementation<br>&gt;&gt; <br>&gt;&gt; III) we improve the Xcode Swift interface generator so that it gives a<br>&gt;&gt; clear indication whether a protocol method does come with a default<br>&gt;&gt; implementation<br>&gt;&gt; <br>&gt;&gt; would give us all the relevant advantages of ObjC-style optional<br>&gt;&gt; protocol methods and it should allow us to create a unified syntax<br>&gt;&gt; where there is no longer a visible difference between an optional<br>&gt;&gt; protocol method that was imported from ObjC and a native Swift<br>&gt;&gt; protocol with default implementations.<br>&gt;&gt; <br>&gt;&gt; Regards,<br>&gt;&gt; <br>&gt;&gt; Dietmar Planitzer<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 7, 2016, at 17:12, Douglas Gregor via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Optional protocol requirements in Swift have the restriction that<br>&gt;&gt;&gt; they only work in @objc protocols, a topic that’s come up a number<br>&gt;&gt;&gt; of times. The start of these threads imply that optional<br>&gt;&gt;&gt; requirements should be available for all protocols in Swift. While<br>&gt;&gt;&gt; this direction is implementable, each time this is discussed there<br>&gt;&gt;&gt; is significant feedback that optional requirements are not a feature<br>&gt;&gt;&gt; we want in Swift. They overlap almost completely with default<br>&gt;&gt;&gt; implementations of protocol requirements, which is a more general<br>&gt;&gt;&gt; feature, and people seem to feel that designs based around default<br>&gt;&gt;&gt; implementations and refactoring of protocol hierarchies are overall<br>&gt;&gt;&gt; better.<br>&gt;&gt;&gt; The main concern with removing optional requirements from Swift is their impact on Cocoa: Objective-C protocols, especially for delegates and data sources, make heavy use of optional requirements. Moreover, there are no default implementations for any of these optional requirements: each caller effectively checks for the presence of the method explicitly, and implements its own logic if the method isn’t there.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A Non-Workable Solution: Import as optional property requirements One suggestion that’s come up to map an optional requirement to a property with optional type, were “nil” indicates that the requirement was not satisfied. For example,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @protocol NSTableViewDelegate @optional - (nullable NSView *)tableView:(NSTableView *)tableView viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row; - (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row; @end<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; currently comes in as<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @objc protocol NSTableViewDelegate { optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?  optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; would come in as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @objc protocol NSTableViewDelegate { var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? { get } var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get } }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; with a default implementation of “nil” for each. However, this isn’t practical for a number of reasons:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; a) We would end up overloading the property name “tableView” a couple dozen times, which doesn’t actually work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; b) You can no longer refer to the member with a compound name, e.g., “delegate.tableView(_:viewFor:row:)” no longer works, because the name of the property is “tableView”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; c) Implementers of the protocol now need to provide a read-only property that returns a closure. So instead of<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class MyDelegate : NSTableViewDelegate { func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { … } }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; one would have to write something like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class MyDelegate : NSTableViewDelegate { var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? = { … except you can’t refer to self in here unless you make it lazy ...  } }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; d) We’ve seriously considered eliminating argument labels on function types, because they’re a complexity in the type system that doesn’t serve much of a purpose.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed Solution: Caller-side default implementations<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Default implementations and optional requirements differ most on the caller side. For example, let’s use NSTableView delegate as it’s imported today:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func useDelegate(delegate: NSTableViewDelegate) { if let getView = delegate.tableView(_:viewFor:row:) { // since the requirement is optional, a reference to the method produces a value of optional function type // I can call getView here }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  if let getHeight = delegate.tableView(_:heightOfRow:) { // I can call getHeight here } }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With my proposal, we’d have some compiler-synthesized attribute (let’s call it @__caller_default_implementation) that gets places on Objective-C optional requirements when they get imported, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @objc protocol NSTableViewDelegate { @__caller_default_implementation func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?  @__caller_default_implementation func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And “optional” disappears from the language. Now, there’s no optionality left, so our useDelegate example tries to just do correct calls:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func useDelegate(delegate: NSTableViewDelegate) -&gt; NSView? { let view = delegate.tableView(tableView, viewFor: column, row: row) let height = delegate.tableView(tableView, heightOfRow: row) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course, the code above will fail if the actual delegate doesn’t implement both methods. We need some kind of default implementation to fall back on in that case. I propose that the code above produce a compiler error on both lines *unless* there is a “default implementation” visible. So, to make the code above compile without error, one would have to add:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension NSTableViewDelegate { @nonobjc func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { return nil }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  @nonobjc func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { return 17 } }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now, the useDelegate example compiles. If the actual delegate implements the optional requirement, we’ll use that implementation. Otherwise, the caller will use the default (Swift-only) implementation it sees. From an implementation standpoint, the compiler would effectively produce the following for the first of these calls:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if delegate.responds(to: #selector(NSTableViewDelegate.tableView(_:viewFor:row:))) { // call the @objc instance method with the selector tableView:viewForTableColumn:row: } else { // call the Swift-only implementation of tableView(_:viewFor:row:) in the protocol extension above }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are a number of reasons why I like this approach:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) It eliminates the notion of ‘optional’ requirements from the language. For classes that are adopting the NSTableViewDelegate protocol, it is as if these requirements had default implementations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2) Only the callers to these requirements have to deal with the lack<br>&gt;&gt;&gt; of default implementations. This was already the case for optional<br>&gt;&gt;&gt; requirements, so it’s not an extra burden in principle, and it’s<br>&gt;&gt;&gt; generally going to be easier to write one defaulted implementation<br>&gt;&gt;&gt; than deal with it in several different places. Additionally, most of<br>&gt;&gt;&gt; these callers are probably in the Cocoa frameworks, not application<br>&gt;&gt;&gt; code, so the overall impact should be small.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
