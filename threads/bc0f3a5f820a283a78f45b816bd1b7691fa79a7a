<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Comparing POP to OOP</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  5, 2016 at 10:00:00pm</p></header><div class="content"><p>on Sat Mar 05 2016, Jon Hoffman &lt;swift-users-AT-swift.org&gt; wrote:<br></p><p>&gt;&gt; On Feb 25, 2016, at 7:38 PM, Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon Feb 15 2016, Jon Hoffman &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; Thank you for the feedback however you cannot design the code as you<br>&gt;&gt;&gt; describe, if I understand your explanation correctly, because one of the<br>&gt;&gt;&gt; requirements is the animals may be apart of multiple categories.  As the<br>&gt;&gt;&gt; example in the post shows the alligator belongs to both the Land and the<br>&gt;&gt;&gt; Sea categories.  In you description that would mean that the Alligator type<br>&gt;&gt;&gt; would need to be a subclass of both the Land and Sea superclasses which is<br>&gt;&gt;&gt; not permitted.  Remember that one of the drawbacks with OOP is a subclass<br>&gt;&gt;&gt; can only inherit from one superclass.<br>&gt;&gt; <br>&gt;&gt; That&#39;s true in Swift, but not in all realizations of OOP.  If your<br>&gt;&gt; article is merely using protocols to get the benefits of multiple<br>&gt;&gt; inheritance from abstract classes, it may not touch at all on what<br>&gt;&gt; differentiates OOP from POP at a fundamental level.<br>&gt;<br>&gt; You are absolutely correct; with protocols we do gain a lot more than<br>&gt; just multiple inheritance.  In this post I touch on protocol<br>&gt; composition <br></p><p>In what ways do you see “protocol composition” as being distinct from<br>“multiple inheritance?”<br></p><p>&gt; and also extensions just to name two of them.  <br></p><p>I don&#39;t view extensions themselves as a fundamental part of POP.  After<br>all, we can extend classes as well as protocols.  It&#39;s possible to<br>express the things that we do with protocol extensions using other<br>language features that don&#39;t make types fully open for extension outside<br>the scope in which they&#39;re defined.<br></p><p>&gt; One of the things that I do emphasize when I talk about<br>&gt; Protocol-Oriented programming is it is about so much more than just<br>&gt; the protocol.<br></p><p>Do tell!  What do you mean?<br></p><p>&gt; To be honest, I think that Apple may have done a disservice to POP by<br>&gt; giving it the name “Protocol-Oriented Programming”.  With OOP and POP<br>&gt; having such similar names, people tend to relate them together and in<br>&gt; my opinion, how you design your application with POP is fundamentally<br>&gt; different than with OOP.  <br></p><p>Isn&#39;t that the whole point?  It&#39;s a different orientation.<br></p><p>The way in which OOP is “object oriented” is that it starts with the<br>premise that the fundamental unit of abstraction is the object,<br>i.e. class instance.  The way in which POP is “protocol oriented” is<br>that it says the fundamental unit of abstraction is the protocol.<br></p><p>&gt; Hopefully I will be able to write some additional posts about<br>&gt; designing applications in a POP way using case studies.  Just a matter<br>&gt; of finding time.<br>&gt;<br>&gt; In one of the e-mails about this post, someone mentioned<br>&gt; Entity-Component Systems<br>&gt; (https://en.wikipedia.org/wiki/Entity_component_system).  I personally<br>&gt; have not used ECS however from what I read from the links provided in<br>&gt; that e-mail, in a lot of ways the design philosophy behind POP seems<br>&gt; to be closer to ECS than OOP<br></p><p>&gt;From what I read there, an ECS has almost nothing in common with what<br>I&#39;ve tried to capture as protocol-oriented programming.  In particular,<br>ECS seems to much closer to “stringly typed” or dictionary-oriented<br>programming, with lots of dynamic interrogation for object properties<br>rather than use of strong static typing.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8bc65b07027beac76b917624be47611?s=50"></div><header><strong>Comparing POP to OOP</strong> from <string>Jon Hoffman</string> &lt;hoffman.jon at gmail.com&gt;<p>March  6, 2016 at 07:00:00pm</p></header><div class="content"><p>I am going to try to answer all of your questions at once (sorry if I miss anything), which is why I am top posting here.  Also sorry for the long e-mails but I am trying to capture what I want to say and still keep the response as small as possible but I am not doing a good job at the small part.<br></p><p>As an architect and developer, I look at POP as more than just developing to an interface.  If we were to take the view that POP was simply about an interface first design then we would be able to say that Java and C# could be POP languages.  While there are plenty of approaches like OSGI that take an interface first approach, they still use the fundamentals of OOP in their design (reference types, class hierarchies).<br></p><p>You say that you do not view extensions themselves as a fundamental part of POP.  My response to that is:  Can we really have POP without protocol extensions?  Without protocol extensions, if we had common functionality between our conforming types we would need to take one of the following three approaches: <br></p><p>    *  We would need to create large monolithic super classes as we do with OOP that all conforming types would also inherit from.<br></p><p>    *  Have large amounts of duplicate code in our types<br></p><p>    *  Use global functions<br></p><p>While these approaches have worked in the past, in my opinion (and I know some will argue this) they are not ideal solutions.  With protocol extensions we are able to have our cake and eat it too (and who does not like cake).  We are able to define smaller, very specific protocols (rather than monolithic super classes) and also provide an implementation for functionality that is common to our conforming types thereby avoiding duplicate code and global functions.  Therefore would POP really be a viable programming paradigm without protocol extensions?<br></p><p>If you take that logic further, then what is actually part of the POP paradigm?  Apple really hasn’t defined that and has seemed to have left that question up to the community.  Looking at that question from an architect’s point of view then I can see a number of area that we can include.  In my book I included sections on the type choices that we have (classes, structures, enumerations, tuples…), error handling, protocols and extensions.  From one of your earlier e-mails, hindsight being 20-20, maybe I should have had a separate section on generics.  I did touch on generics in the protocol chapter but maybe I do need to expand on that.<br></p><p>Where I see ECS design to be similar to POP (in my opinion) is in ECS every entity consists of one or more components which add additional behavior or functionality to the entity.  With POP we can think of the components as the protocol (with protocol extensions).   Then each protocol that a type conforms to will add additional behavior or functionality similar to ECS.  With OOP and single inheritance as we have with Swift, we have the monolithic super classes rather than smaller components like POP and ECS.  This is one of the things that has drawn me to POP.<br></p><p>I kept the e-mail as small as I could and hopefully I still got my ideas across.<br></p><p>Jon<br></p><p>&gt; On Mar 6, 2016, at 1:30 AM, Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat Mar 05 2016, Jon Hoffman &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Feb 25, 2016, at 7:38 PM, Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Mon Feb 15 2016, Jon Hoffman &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Thank you for the feedback however you cannot design the code as you<br>&gt;&gt;&gt;&gt; describe, if I understand your explanation correctly, because one of the<br>&gt;&gt;&gt;&gt; requirements is the animals may be apart of multiple categories.  As the<br>&gt;&gt;&gt;&gt; example in the post shows the alligator belongs to both the Land and the<br>&gt;&gt;&gt;&gt; Sea categories.  In you description that would mean that the Alligator type<br>&gt;&gt;&gt;&gt; would need to be a subclass of both the Land and Sea superclasses which is<br>&gt;&gt;&gt;&gt; not permitted.  Remember that one of the drawbacks with OOP is a subclass<br>&gt;&gt;&gt;&gt; can only inherit from one superclass.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s true in Swift, but not in all realizations of OOP.  If your<br>&gt;&gt;&gt; article is merely using protocols to get the benefits of multiple<br>&gt;&gt;&gt; inheritance from abstract classes, it may not touch at all on what<br>&gt;&gt;&gt; differentiates OOP from POP at a fundamental level.<br>&gt;&gt; <br>&gt;&gt; You are absolutely correct; with protocols we do gain a lot more than<br>&gt;&gt; just multiple inheritance.  In this post I touch on protocol<br>&gt;&gt; composition <br>&gt; <br>&gt; In what ways do you see “protocol composition” as being distinct from<br>&gt; “multiple inheritance?”<br>&gt; <br>&gt;&gt; and also extensions just to name two of them.  <br>&gt; <br>&gt; I don&#39;t view extensions themselves as a fundamental part of POP.  After<br>&gt; all, we can extend classes as well as protocols.  It&#39;s possible to<br>&gt; express the things that we do with protocol extensions using other<br>&gt; language features that don&#39;t make types fully open for extension outside<br>&gt; the scope in which they&#39;re defined.<br>&gt; <br>&gt;&gt; One of the things that I do emphasize when I talk about<br>&gt;&gt; Protocol-Oriented programming is it is about so much more than just<br>&gt;&gt; the protocol.<br>&gt; <br>&gt; Do tell!  What do you mean?<br>&gt; <br>&gt;&gt; To be honest, I think that Apple may have done a disservice to POP by<br>&gt;&gt; giving it the name “Protocol-Oriented Programming”.  With OOP and POP<br>&gt;&gt; having such similar names, people tend to relate them together and in<br>&gt;&gt; my opinion, how you design your application with POP is fundamentally<br>&gt;&gt; different than with OOP.  <br>&gt; <br>&gt; Isn&#39;t that the whole point?  It&#39;s a different orientation.<br>&gt; <br>&gt; The way in which OOP is “object oriented” is that it starts with the<br>&gt; premise that the fundamental unit of abstraction is the object,<br>&gt; i.e. class instance.  The way in which POP is “protocol oriented” is<br>&gt; that it says the fundamental unit of abstraction is the protocol.<br>&gt; <br>&gt;&gt; Hopefully I will be able to write some additional posts about<br>&gt;&gt; designing applications in a POP way using case studies.  Just a matter<br>&gt;&gt; of finding time.<br>&gt;&gt; <br>&gt;&gt; In one of the e-mails about this post, someone mentioned<br>&gt;&gt; Entity-Component Systems<br>&gt;&gt; (https://en.wikipedia.org/wiki/Entity_component_system).  I personally<br>&gt;&gt; have not used ECS however from what I read from the links provided in<br>&gt;&gt; that e-mail, in a lot of ways the design philosophy behind POP seems<br>&gt;&gt; to be closer to ECS than OOP<br>&gt; <br>&gt; From what I read there, an ECS has almost nothing in common with what<br>&gt; I&#39;ve tried to capture as protocol-oriented programming.  In particular,<br>&gt; ECS seems to much closer to “stringly typed” or dictionary-oriented<br>&gt; programming, with lots of dynamic interrogation for object properties<br>&gt; rather than use of strong static typing.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160306/e74285d9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Comparing POP to OOP</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  6, 2016 at 09:00:00pm</p></header><div class="content"><p>on Sun Mar 06 2016, Jon Hoffman &lt;hoffman.jon-AT-gmail.com&gt; wrote:<br></p><p>&gt; I am going to try to answer all of your questions at once (sorry if I<br>&gt; miss anything), which is why I am top posting here.  <br></p><p>Forty lashes with a wet noodle for you, my friend.<br></p><p>&gt; Also sorry for the long e-mails <br></p><p>Okay, fifty :-)<br></p><p>&gt; but I am trying to capture what I want to say and still keep the<br>&gt; response as small as possible but I am not doing a good job at the<br>&gt; small part.<br></p><p>Maybe you ran out of time.<br>http://quoteinvestigator.com/2012/04/28/shorter-letter/<br></p><p>&gt; As an architect and developer, I look at POP as more than just<br>&gt; developing to an interface.  If we were to take the view that POP was<br>&gt; simply about an interface first design then we would be able to say<br>&gt; that Java and C# could be POP languages.  While there are plenty of<br>&gt; approaches like OSGI that take an interface first approach, they still<br>&gt; use the fundamentals of OOP in their design (reference types, class<br>&gt; hierarchies).<br>&gt;<br>&gt; You say that you do not view extensions themselves as a fundamental<br>&gt; part of POP.  My response to that is: Can we really have POP without<br>&gt; protocol extensions?  Without protocol extensions, if we had common<br>&gt; functionality between our conforming types we would need to take one<br>&gt; of the following three approaches:<br>&gt;<br>&gt;     * We would need to create large monolithic super classes as we do<br>&gt; with OOP that all conforming types would also inherit from.<br>&gt;<br>&gt;     *  Have large amounts of duplicate code in our types<br>&gt;<br>&gt;     *  Use global functions<br></p><p>My point about protocol extensions has to do with the “extension” part<br>rather than the “protocol” part.  The fundamental property of extensions<br>is that you can add to a type&#39;s interface *without owning that type*.<br>There are other ways one could express the same kind of code sharing for<br>protocols without having a mechanism that allows arbitrary extension by<br>authors that don&#39;t own the protocol.  For example, the same basic<br>expressive capabilities were built into<br>http://www.generic-programming.org/software/ConceptGCC/, which in many<br>ways was a precursor to Swift&#39;s generics system in the form of concept<br>maps.  Extensions happened to be the most convenient vehicle for<br>bringing these capabilities into Swift.<br></p><p>&gt; While these approaches have worked in the past, in my opinion (and I<br>&gt; know some will argue this) they are not ideal solutions.  With<br>&gt; protocol extensions we are able to have our cake and eat it too (and<br>&gt; who does not like cake).  We are able to define smaller, very specific<br>&gt; protocols (rather than monolithic super classes) and also provide an<br>&gt; implementation for functionality that is common to our conforming<br>&gt; types thereby avoiding duplicate code and global functions.  Therefore<br>&gt; would POP really be a viable programming paradigm without protocol<br>&gt; extensions?<br></p><p>Yes, but you&#39;d need other mechanisms to achieve the same ends.<br></p><p>&gt; If you take that logic further, then what is actually part of the POP<br>&gt; paradigm?  Apple really hasn’t defined that and has seemed to have<br>&gt; left that question up to the community.  <br></p><p>Mea culpa.  But we only have so much time for writing blog posts,<br>etc. while simultaneously changing the face of all Apple APIs and trying<br>to develop the Swift standard library ;-)<br></p><p>I&#39;m just glad there are thoughtful and insightful authors like you out<br>there to pick up the thread.<br></p><p>&gt; Looking at that question from an architect’s point of view then I can<br>&gt; see a number of area that we can include.  In my book I included<br>&gt; sections on the type choices that we have (classes, structures,<br>&gt; enumerations, tuples…), error handling, protocols and extensions.<br>&gt; From one of your earlier e-mails, hindsight being 20-20, maybe I<br>&gt; should have had a separate section on generics.  I did touch on<br>&gt; generics in the protocol chapter but maybe I do need to expand on<br>&gt; that.<br></p><p>Great idea.<br></p><p>&gt; Where I see ECS design to be similar to POP (in my opinion) is in ECS<br>&gt; every entity consists of one or more components which add additional<br>&gt; behavior or functionality to the entity.  With POP we can think of the<br>&gt; components as the protocol (with protocol extensions).  Then each<br>&gt; protocol that a type conforms to will add additional behavior or<br>&gt; functionality similar to ECS.  With OOP and single inheritance as we<br>&gt; have with Swift, we have the monolithic super classes rather than<br>&gt; smaller components like POP and ECS.  This is one of the things that<br>&gt; has drawn me to POP.<br></p><p>If what you&#39;re saying is that POP is better than OOP for decomposing<br>designs in Swift, I won&#39;t argue.  ECS is a different path to a granular<br>design, but AFAICT that&#39;s where any similarity to POP ends.<br></p><p>&gt; I kept the e-mail as small as I could and hopefully I still got my ideas across.<br>&gt;<br>&gt; Jon<br>&gt;<br>&gt;&gt; On Mar 6, 2016, at 1:30 AM, Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sat Mar 05 2016, Jon Hoffman &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 25, 2016, at 7:38 PM, Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Mon Feb 15 2016, Jon Hoffman &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thank you for the feedback however you cannot design the code as you<br>&gt;&gt;&gt;&gt;&gt; describe, if I understand your explanation correctly, because one of the<br>&gt;&gt;&gt;&gt;&gt; requirements is the animals may be apart of multiple categories.  As the<br>&gt;&gt;&gt;&gt;&gt; example in the post shows the alligator belongs to both the Land and the<br>&gt;&gt;&gt;&gt;&gt; Sea categories.  In you description that would mean that the Alligator type<br>&gt;&gt;&gt;&gt;&gt; would need to be a subclass of both the Land and Sea superclasses which is<br>&gt;&gt;&gt;&gt;&gt; not permitted.  Remember that one of the drawbacks with OOP is a subclass<br>&gt;&gt;&gt;&gt;&gt; can only inherit from one superclass.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s true in Swift, but not in all realizations of OOP.  If your<br>&gt;&gt;&gt;&gt; article is merely using protocols to get the benefits of multiple<br>&gt;&gt;&gt;&gt; inheritance from abstract classes, it may not touch at all on what<br>&gt;&gt;&gt;&gt; differentiates OOP from POP at a fundamental level.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You are absolutely correct; with protocols we do gain a lot more than<br>&gt;&gt;&gt; just multiple inheritance.  In this post I touch on protocol<br>&gt;&gt;&gt; composition <br>&gt;&gt; <br>&gt;&gt; In what ways do you see “protocol composition” as being distinct from<br>&gt;&gt; “multiple inheritance?”<br>&gt;&gt; <br>&gt;&gt;&gt; and also extensions just to name two of them.  <br>&gt;&gt; <br>&gt;&gt; I don&#39;t view extensions themselves as a fundamental part of POP.  After<br>&gt;&gt; all, we can extend classes as well as protocols.  It&#39;s possible to<br>&gt;&gt; express the things that we do with protocol extensions using other<br>&gt;&gt; language features that don&#39;t make types fully open for extension outside<br>&gt;&gt; the scope in which they&#39;re defined.<br>&gt;&gt; <br>&gt;&gt;&gt; One of the things that I do emphasize when I talk about<br>&gt;&gt;&gt; Protocol-Oriented programming is it is about so much more than just<br>&gt;&gt;&gt; the protocol.<br>&gt;&gt; <br>&gt;&gt; Do tell!  What do you mean?<br>&gt;&gt; <br>&gt;&gt;&gt; To be honest, I think that Apple may have done a disservice to POP by<br>&gt;&gt;&gt; giving it the name “Protocol-Oriented Programming”.  With OOP and POP<br>&gt;&gt;&gt; having such similar names, people tend to relate them together and in<br>&gt;&gt;&gt; my opinion, how you design your application with POP is fundamentally<br>&gt;&gt;&gt; different than with OOP.  <br>&gt;&gt; <br>&gt;&gt; Isn&#39;t that the whole point?  It&#39;s a different orientation.<br>&gt;&gt; <br>&gt;&gt; The way in which OOP is “object oriented” is that it starts with the<br>&gt;&gt; premise that the fundamental unit of abstraction is the object,<br>&gt;&gt; i.e. class instance.  The way in which POP is “protocol oriented” is<br>&gt;&gt; that it says the fundamental unit of abstraction is the protocol.<br>&gt;&gt; <br>&gt;&gt;&gt; Hopefully I will be able to write some additional posts about<br>&gt;&gt;&gt; designing applications in a POP way using case studies.  Just a matter<br>&gt;&gt;&gt; of finding time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In one of the e-mails about this post, someone mentioned<br>&gt;&gt;&gt; Entity-Component Systems<br>&gt;&gt;&gt; (https://en.wikipedia.org/wiki/Entity_component_system).  I personally<br>&gt;&gt;&gt; have not used ECS however from what I read from the links provided in<br>&gt;&gt;&gt; that e-mail, in a lot of ways the design philosophy behind POP seems<br>&gt;&gt;&gt; to be closer to ECS than OOP<br>&gt;&gt; <br>&gt;&gt; From what I read there, an ECS has almost nothing in common with what<br>&gt;&gt; I&#39;ve tried to capture as protocol-oriented programming.  In particular,<br>&gt;&gt; ECS seems to much closer to “stringly typed” or dictionary-oriented<br>&gt;&gt; programming, with lots of dynamic interrogation for object properties<br>&gt;&gt; rather than use of strong static typing.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8bc65b07027beac76b917624be47611?s=50"></div><header><strong>Comparing POP to OOP</strong> from <string>Jon Hoffman</string> &lt;hoffman.jon at gmail.com&gt;<p>March  7, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Mar 7, 2016, at 12:16 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun Mar 06 2016, Jon Hoffman &lt;hoffman.jon-AT-gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; I am going to try to answer all of your questions at once (sorry if I<br>&gt;&gt; miss anything), which is why I am top posting here.  <br>&gt; <br>&gt; Forty lashes with a wet noodle for you, my friend.<br></p><p>Not the wet noodle, anything but that.  :)  <br></p><p>&gt; <br>&gt;&gt; Also sorry for the long e-mails <br>&gt; <br>&gt; Okay, fifty :-)<br>&gt; <br>&gt;&gt; but I am trying to capture what I want to say and still keep the<br>&gt;&gt; response as small as possible but I am not doing a good job at the<br>&gt;&gt; small part.<br>&gt; <br>&gt; Maybe you ran out of time.<br>&gt; http://quoteinvestigator.com/2012/04/28/shorter-letter/ &lt;http://quoteinvestigator.com/2012/04/28/shorter-letter/&gt;<br></p><p>Oh if we only had more time to do all of the things we wanted or at least to shorten our e-mails.<br></p><p>&gt; <br>&gt;&gt; As an architect and developer, I look at POP as more than just<br>&gt;&gt; developing to an interface.  If we were to take the view that POP was<br>&gt;&gt; simply about an interface first design then we would be able to say<br>&gt;&gt; that Java and C# could be POP languages.  While there are plenty of<br>&gt;&gt; approaches like OSGI that take an interface first approach, they still<br>&gt;&gt; use the fundamentals of OOP in their design (reference types, class<br>&gt;&gt; hierarchies).<br>&gt;&gt; <br>&gt;&gt; You say that you do not view extensions themselves as a fundamental<br>&gt;&gt; part of POP.  My response to that is: Can we really have POP without<br>&gt;&gt; protocol extensions?  Without protocol extensions, if we had common<br>&gt;&gt; functionality between our conforming types we would need to take one<br>&gt;&gt; of the following three approaches:<br>&gt;&gt; <br>&gt;&gt;    * We would need to create large monolithic super classes as we do<br>&gt;&gt; with OOP that all conforming types would also inherit from.<br>&gt;&gt; <br>&gt;&gt;    *  Have large amounts of duplicate code in our types<br>&gt;&gt; <br>&gt;&gt;    *  Use global functions<br>&gt; <br>&gt; My point about protocol extensions has to do with the “extension” part<br>&gt; rather than the “protocol” part.  The fundamental property of extensions<br>&gt; is that you can add to a type&#39;s interface *without owning that type*.<br>&gt; There are other ways one could express the same kind of code sharing for<br>&gt; protocols without having a mechanism that allows arbitrary extension by<br>&gt; authors that don&#39;t own the protocol.  For example, the same basic<br>&gt; expressive capabilities were built into<br>&gt; http://www.generic-programming.org/software/ConceptGCC/, which in many<br>&gt; ways was a precursor to Swift&#39;s generics system in the form of concept<br>&gt; maps.  Extensions happened to be the most convenient vehicle for<br>&gt; bringing these capabilities into Swift.<br></p><p>I agree that there is other ways we can do code sharing besides protocol extensions however as you pointed out extensions are the most convenient way.  I would also say that in my opinion protocol extensions are also the most elegant and one of the easiest for new programmers to learn when coming from an OOP background.  Developers coming from a functional backgrounds can still use global methods.  <br></p><p>To help grow POP with Swift, in my opinion, there really should be a standard or recommended way for adding common functionality even if some developers prefer to take a different approach.  This will allow us to write books and articles about POP and show a consistent approach.  If different authors take different approaches, it could get confusing for other developers that are trying to figure out what POP is.   To me standardizing on protocol extensions make the most sense.<br></p><p>I can see the benefits with also showing other approaches at the same time we show protocol extensions larger print mediums like books however having that standard approach will make it easier all the way around. <br></p><p><br>&gt; <br>&gt;&gt; While these approaches have worked in the past, in my opinion (and I<br>&gt;&gt; know some will argue this) they are not ideal solutions.  With<br>&gt;&gt; protocol extensions we are able to have our cake and eat it too (and<br>&gt;&gt; who does not like cake).  We are able to define smaller, very specific<br>&gt;&gt; protocols (rather than monolithic super classes) and also provide an<br>&gt;&gt; implementation for functionality that is common to our conforming<br>&gt;&gt; types thereby avoiding duplicate code and global functions.  Therefore<br>&gt;&gt; would POP really be a viable programming paradigm without protocol<br>&gt;&gt; extensions?<br>&gt; <br>&gt; Yes, but you&#39;d need other mechanisms to achieve the same ends.<br>&gt; <br>&gt;&gt; If you take that logic further, then what is actually part of the POP<br>&gt;&gt; paradigm?  Apple really hasn’t defined that and has seemed to have<br>&gt;&gt; left that question up to the community.  <br>&gt; <br>&gt; Mea culpa.  But we only have so much time for writing blog posts,<br>&gt; etc. while simultaneously changing the face of all Apple APIs and trying<br>&gt; to develop the Swift standard library ;-)<br>With all of the talent at Apple, you should have all that completed next week and still have time for a paint ball tournament, right?  :) <br></p><p><br></p><p>&gt; <br>&gt; I&#39;m just glad there are thoughtful and insightful authors like you out<br>&gt; there to pick up the thread.<br></p><p>Thank you for the compliment<br></p><p>&gt; <br>&gt;&gt; Looking at that question from an architect’s point of view then I can<br>&gt;&gt; see a number of area that we can include.  In my book I included<br>&gt;&gt; sections on the type choices that we have (classes, structures,<br>&gt;&gt; enumerations, tuples…), error handling, protocols and extensions.<br>&gt;&gt; From one of your earlier e-mails, hindsight being 20-20, maybe I<br>&gt;&gt; should have had a separate section on generics.  I did touch on<br>&gt;&gt; generics in the protocol chapter but maybe I do need to expand on<br>&gt;&gt; that.<br>&gt; <br>&gt; Great idea.<br></p><p>Generics are a pretty broad subject to cover all at once, what parts do you think matter the most when it comes to POP? <br></p><p>&gt; <br>&gt;&gt; Where I see ECS design to be similar to POP (in my opinion) is in ECS<br>&gt;&gt; every entity consists of one or more components which add additional<br>&gt;&gt; behavior or functionality to the entity.  With POP we can think of the<br>&gt;&gt; components as the protocol (with protocol extensions).  Then each<br>&gt;&gt; protocol that a type conforms to will add additional behavior or<br>&gt;&gt; functionality similar to ECS.  With OOP and single inheritance as we<br>&gt;&gt; have with Swift, we have the monolithic super classes rather than<br>&gt;&gt; smaller components like POP and ECS.  This is one of the things that<br>&gt;&gt; has drawn me to POP.<br>&gt; <br>&gt; If what you&#39;re saying is that POP is better than OOP for decomposing<br>&gt; designs in Swift, I won&#39;t argue.  ECS is a different path to a granular<br>&gt; design, but AFAICT that&#39;s where any similarity to POP ends.<br></p><p>I do not know enough about ECS to comment any further than the granular approach but yes I think that approach is similar to what POP is.  <br></p><p><br>&gt; <br>&gt;&gt; I kept the e-mail as small as I could and hopefully I still got my ideas across.<br>&gt;&gt; <br>&gt;&gt; Jon<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160307/b3403c90/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Comparing POP to OOP</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>March  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Forty lashes with a wet noodle for you, my friend.<br>that&#39;s so cruel… I think it&#39;s unfair of you to join this discussion: It&#39;s like Hemingway dropping in an oral exam about &quot;The Old Man and the Sea&quot;, starting to ask questions ;-)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8bc65b07027beac76b917624be47611?s=50"></div><header><strong>Comparing POP to OOP</strong> from <string>Jon Hoffman</string> &lt;hoffman.jon at gmail.com&gt;<p>March  8, 2016 at 07:00:00am</p></header><div class="content"><p>On Mar 8, 2016, at 4:49 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br></p><p>&gt;&gt; Forty lashes with a wet noodle for you, my friend.<br>&gt; that&#39;s so cruel… I think it&#39;s unfair of you to join this discussion: It&#39;s like Hemingway dropping in an oral exam about &quot;The Old Man and the Sea&quot;, starting to ask questions ;-)<br></p><p>But who better to have a discussion about &quot;The Old Man and the Sea&quot; with then Hemingway himself?<br></p><p>Jon<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
