<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>June 15, 2016 at 11:00:00pm</p></header><div class="content"><p>My understanding of the proposal was that the unannotated properties/methods inside of a scope have the same *visibility* as their surrounding scope, or internal, whichever is less.<br></p><p>That is slightly different than having the same access level.  Thus:<br></p><p>private struct Outer {<br>	var inner:Int<br>}<br></p><p>is different than:<br></p><p>private struct Outer {<br>	private var inner:Int<br>}<br></p><p>In the first, inner is accessible precisely everywhere where Outer is accessible.  In the second, inner is only accessible within Outer itself.  It is important that we have the first behavior for unannotated inner, because there is no other way to spell it.<br></p><p>That is my understanding of the intent of SE-0025, even if the exact wording is confusing.<br></p><p>Thanks,<br>Jon<br></p><p>P.S.  I would personally like to see unannotated properties/methods inside of a scope have the same visibility as their surrounding scope. Full stop. End of sentence.  (It seems to me like the special handling of internal is what is causing the confusion here).  That is what I would expect the behavior to be if I didn’t know.  That isn’t what was written in the proposal though...<br></p><p>&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; ~Robert Widmann<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/d7fb12f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 16, 2016 at 12:00:00am</p></header><div class="content"><p>But the proposal does not specify that and that is not how swift&#39;s access control mechanisms currently work, unfortunately.  A private aggregate must have private members, and those members are subject to private access whether annotated or not.<br></p><p>On top of that, you break containment this way.  A private member is not supposed to be visible outside of its current declaration.  An aggregate full of private members similarly.  You can see the aggregate, but you cannot see its members.  If we relax this, then private is no different from fileprivate and we should just stick to our current tri-valued access control system.<br></p><p>~Robert Widmann<br></p><p>2016/06/15 23:04、Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; My understanding of the proposal was that the unannotated properties/methods inside of a scope have the same *visibility* as their surrounding scope, or internal, whichever is less.<br>&gt; <br>&gt; That is slightly different than having the same access level.  Thus:<br>&gt; <br>&gt; private struct Outer {<br>&gt; 	var inner:Int<br>&gt; }<br>&gt; <br>&gt; is different than:<br>&gt; <br>&gt; private struct Outer {<br>&gt; 	private var inner:Int<br>&gt; }<br>&gt; <br>&gt; In the first, inner is accessible precisely everywhere where Outer is accessible.  In the second, inner is only accessible within Outer itself.  It is important that we have the first behavior for unannotated inner, because there is no other way to spell it.<br>&gt; <br>&gt; That is my understanding of the intent of SE-0025, even if the exact wording is confusing.<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; P.S.  I would personally like to see unannotated properties/methods inside of a scope have the same visibility as their surrounding scope. Full stop. End of sentence.  (It seems to me like the special handling of internal is what is causing the confusion here).  That is what I would expect the behavior to be if I didn’t know.  That isn’t what was written in the proposal though...<br>&gt; <br>&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>June 16, 2016 at 12:00:00am</p></header><div class="content"><p>They happen to be the same at the top level, but they are very different when dealing with nested types…<br></p><p>A private member is visible inside it’s containing scope.  For the top-level, that is the file.  For a nested type, that is the outer type.<br></p><p>You may, for instance have an outer type which is marked Internal or public, but an inner type which is marked fileprivate so that extensions in the file can use the inner type.  That is different than marking the inner type private, which would only allow access inside the outer type, but not in extensions.<br></p><p>Again, I want to point out that the behavior I described in my earlier message is the only plausible/usable behavior because we have no other way to specify that a member should have the same visibility as it’s enclosing scope… which is a common and important use-case.  Doing it your way, as you point out in your original message, leads to the problem of having no way to instantiate types marked private.<br></p><p>This was all thoroughly discussed during the proposal process, with lots of people talking about the fact that private &amp; fileprivate are the same at the top level… and the response was that, yes, this is by design.  In most cases you can continue to just use the shorter private, and you only need to bring in fileprivate for nested types.  Fileprivate is one of those things that you REALLY need when you need it though, which is why it was included.<br></p><p>Thanks,<br>Jon<br></p><p><br>&gt; On Jun 16, 2016, at 12:06 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; But the proposal does not specify that and that is not how swift&#39;s access control mechanisms currently work, unfortunately.  A private aggregate must have private members, and those members are subject to private access whether annotated or not.<br>&gt; <br>&gt; On top of that, you break containment this way.  A private member is not supposed to be visible outside of its current declaration.  An aggregate full of private members similarly.  You can see the aggregate, but you cannot see its members.  If we relax this, then private is no different from fileprivate and we should just stick to our current tri-valued access control system.<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/06/15 23:04、Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt; <br>&gt;&gt; My understanding of the proposal was that the unannotated properties/methods inside of a scope have the same *visibility* as their surrounding scope, or internal, whichever is less.<br>&gt;&gt; <br>&gt;&gt; That is slightly different than having the same access level.  Thus:<br>&gt;&gt; <br>&gt;&gt; private struct Outer {<br>&gt;&gt; 	var inner:Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; is different than:<br>&gt;&gt; <br>&gt;&gt; private struct Outer {<br>&gt;&gt; 	private var inner:Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In the first, inner is accessible precisely everywhere where Outer is accessible.  In the second, inner is only accessible within Outer itself.  It is important that we have the first behavior for unannotated inner, because there is no other way to spell it.<br>&gt;&gt; <br>&gt;&gt; That is my understanding of the intent of SE-0025, even if the exact wording is confusing.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; P.S.  I would personally like to see unannotated properties/methods inside of a scope have the same visibility as their surrounding scope. Full stop. End of sentence.  (It seems to me like the special handling of internal is what is causing the confusion here).  That is what I would expect the behavior to be if I didn’t know.  That isn’t what was written in the proposal though...<br>&gt;&gt; <br>&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 16, 2016 at 12:00:00am</p></header><div class="content"><p>~Robert Widmann<br></p><p>2016/06/16 0:29、Jonathan Hull &lt;jhull at gbis.com&gt; のメッセージ:<br></p><p>&gt; They happen to be the same at the top level, but they are very different when dealing with nested types…<br>&gt; <br>&gt; A private member is visible inside it’s containing scope.  For the top-level, that is the file.  For a nested type, that is the outer type.<br></p><p>A wonderful idea, but not in the proposal.  In fact, the singular example given therein runs directly counter to this idea by explicitly showing the scoping behavior of a private member.<br></p><p>&gt; <br>&gt; You may, for instance have an outer type which is marked Internal or public, but an inner type which is marked fileprivate so that extensions in the file can use the inner type.  That is different than marking the inner type private, which would only allow access inside the outer type, but not in extensions.<br></p><p>That is defined behavior.  The inner private type&#39;s members are, however, still private and cannot escalate their access beyond that.<br></p><p>&gt; <br>&gt; Again, I want to point out that the behavior I described in my earlier message is the only plausible/usable behavior because we have no other way to specify that a member should have the same visibility as it’s enclosing scope… which is a common and important use-case.  Doing it your way, as you point out in your original message, leads to the problem of having no way to instantiate types marked private.<br></p><p>Then we should amend the proposal posthaste!<br></p><p>&gt; <br>&gt; This was all thoroughly discussed during the proposal process, with lots of people talking about the fact that private &amp; fileprivate are the same at the top level… and the response was that, yes, this is by design.  In most cases you can continue to just use the shorter private, and you only need to bring in fileprivate for nested types.  Fileprivate is one of those things that you REALLY need when you need it though, which is why it was included.<br></p><p>Good to know I&#39;m not the only one with reservations.<br></p><p>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 16, 2016, at 12:06 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; But the proposal does not specify that and that is not how swift&#39;s access control mechanisms currently work, unfortunately.  A private aggregate must have private members, and those members are subject to private access whether annotated or not.<br>&gt;&gt; <br>&gt;&gt; On top of that, you break containment this way.  A private member is not supposed to be visible outside of its current declaration.  An aggregate full of private members similarly.  You can see the aggregate, but you cannot see its members.  If we relax this, then private is no different from fileprivate and we should just stick to our current tri-valued access control system.<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/06/15 23:04、Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; My understanding of the proposal was that the unannotated properties/methods inside of a scope have the same *visibility* as their surrounding scope, or internal, whichever is less.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is slightly different than having the same access level.  Thus:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private struct Outer {<br>&gt;&gt;&gt;    var inner:Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; is different than:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private struct Outer {<br>&gt;&gt;&gt;    private var inner:Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the first, inner is accessible precisely everywhere where Outer is accessible.  In the second, inner is only accessible within Outer itself.  It is important that we have the first behavior for unannotated inner, because there is no other way to spell it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is my understanding of the intent of SE-0025, even if the exact wording is confusing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; P.S.  I would personally like to see unannotated properties/methods inside of a scope have the same visibility as their surrounding scope. Full stop. End of sentence.  (It seems to me like the special handling of internal is what is causing the confusion here).  That is what I would expect the behavior to be if I didn’t know.  That isn’t what was written in the proposal though...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>June 16, 2016 at 02:00:00am</p></header><div class="content"><p>From the Impact portion of the proposal:<br>&gt; The existing code will need to rename private to fileprivate to achieve the same semantics. In many cases the new meaning of private is likely to compile as well and the code will then run exactly as before.<br></p><p>I believe the second sentence refers to the case where fileprivate and private are the same at the top level.  I agree that the proposal is a bit vaguely/ambiguously written, but it in no way precludes the behavior everyone is saying was intended.<br></p><p>I know the current implementation just gives unannotated members the same access modifier as the outer scope’s, but that is an implementation detail.  Furthermore it is entirely consistent with the interpretation given above in the case with only “fileprivate”, “internal”, and “public” scopes.  It is only when we add the new “private” scope that there is a difference.<br></p><p>We have an ambiguous proposal which can be read in two different ways, but one of those ways is unworkable (the bug you mentioned), so I see no problem in interpreting it the other way (which just so happens to be the interpretation everyone says was intended) and moving forward.  It is entirely consistent with the proposal.<br></p><p><br></p><p>&gt; On Jun 16, 2016, at 12:35 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/06/16 0:29、Jonathan Hull &lt;jhull at gbis.com&gt; のメッセージ:<br>&gt; <br>&gt;&gt; They happen to be the same at the top level, but they are very different when dealing with nested types…<br>&gt;&gt; <br>&gt;&gt; A private member is visible inside it’s containing scope.  For the top-level, that is the file.  For a nested type, that is the outer type.<br>&gt; <br>&gt; A wonderful idea, but not in the proposal.  In fact, the singular example given therein runs directly counter to this idea by explicitly showing the scoping behavior of a private member.<br></p><p>Chis Lattner’s response to the initial proposal (before the name fileprivate was chosen):<br>&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt; <br>&gt; To summarize the place we’d like to end up:<br>&gt; <br>&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt; - unknown -&gt; symbol visible within the current file.<br>&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br>&gt; <br>&gt; The rationale here is that this aligns Swift with common art seen in other languages, and that many people using private today don’t *want* visibility out of their current declaration.  It also encourages “extension oriented programming”, at least it will when some of the other restrictions on extensions are lifted.  We discussed dropping the third one entirely, but think it *is* a useful and important level of access control, and when/if we ever get the ability to write unit tests inside of the file that defines the functionality, they will be a nicer solution to &lt;at&gt; testable.<br></p><p>As you can see the definition of “unknown” (now fileprivate) and “private” are exactly what I said.  Many people wanted to name the new private “scoped” or “local&quot; because of the way it worked, though “private” won in the end.  As you see, they thought of getting rid of fileprivate, but decided it was necessary.<br></p><p><br>&gt; Then we should amend the proposal posthaste!<br></p><p><br>Basically, what I am saying here is that the intent is clear from the context (and original discussion) around the proposal. We all seem to agree about what needs to happen behavior-wise.  At most this is a bug-fix, and shouldn’t require a full rehashing on evolution.<br></p><p>Thanks,<br>Jon<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/9dc77cb2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 16, 2016 at 07:00:00am</p></header><div class="content"><p>That is for migration.  It does not affect the semantics of private at any level, it merely explains how we should go about the initial transition.  &quot;In many cases&quot; private being equivalent to fileprivate could be read that way, but given the rest of the proposal I didn&#39;t take any artistic freedoms and don&#39;t believe we should without clarification. <br></p><p>~Robert Widmann<br></p><p>2016/06/16 2:00、Jonathan Hull &lt;jhull at gbis.com&gt; のメッセージ:<br></p><p>&gt; From the Impact portion of the proposal:<br>&gt;&gt; The existing code will need to rename private to fileprivate to achieve the same semantics. In many cases the new meaning of private is likely to compile as well and the code will then run exactly as before.<br>&gt; <br>&gt; I believe the second sentence refers to the case where fileprivate and private are the same at the top level.  I agree that the proposal is a bit vaguely/ambiguously written, but it in no way precludes the behavior everyone is saying was intended.<br>&gt; <br>&gt; I know the current implementation just gives unannotated members the same access modifier as the outer scope’s, but that is an implementation detail.  Furthermore it is entirely consistent with the interpretation given above in the case with only “fileprivate”, “internal”, and “public” scopes.  It is only when we add the new “private” scope that there is a difference.<br>&gt; <br>&gt; We have an ambiguous proposal which can be read in two different ways, but one of those ways is unworkable (the bug you mentioned), so I see no problem in interpreting it the other way (which just so happens to be the interpretation everyone says was intended) and moving forward.  It is entirely consistent with the proposal.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jun 16, 2016, at 12:35 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/06/16 0:29、Jonathan Hull &lt;jhull at gbis.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; They happen to be the same at the top level, but they are very different when dealing with nested types…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A private member is visible inside it’s containing scope.  For the top-level, that is the file.  For a nested type, that is the outer type.<br>&gt;&gt; <br>&gt;&gt; A wonderful idea, but not in the proposal.  In fact, the singular example given therein runs directly counter to this idea by explicitly showing the scoping behavior of a private member.<br>&gt; <br>&gt; Chis Lattner’s response to the initial proposal (before the name fileprivate was chosen):<br>&gt;&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt;&gt; <br>&gt;&gt; To summarize the place we’d like to end up:<br>&gt;&gt; <br>&gt;&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt;&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt;&gt; - unknown -&gt; symbol visible within the current file.<br>&gt;&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt; <br>&gt;&gt; The rationale here is that this aligns Swift with common art seen in other languages, and that many people using private today don’t *want* visibility out of their current declaration.  It also encourages “extension oriented programming”, at least it will when some of the other restrictions on extensions are lifted.  We discussed dropping the third one entirely, but think it *is* a useful and important level of access control, and when/if we ever get the ability to write unit tests inside of the file that defines the functionality, they will be a nicer solution to &lt;at&gt; testable.<br>&gt; <br>&gt; As you can see the definition of “unknown” (now fileprivate) and “private” are exactly what I said.  Many people wanted to name the new private “scoped” or “local&quot; because of the way it worked, though “private” won in the end.  As you see, they thought of getting rid of fileprivate, but decided it was necessary.<br>&gt; <br>&gt; <br>&gt;&gt; Then we should amend the proposal posthaste!<br>&gt; <br>&gt; <br>&gt; Basically, what I am saying here is that the intent is clear from the context (and original discussion) around the proposal. We all seem to agree about what needs to happen behavior-wise.  At most this is a bug-fix, and shouldn’t require a full rehashing on evolution.<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/ef4c30ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>June 16, 2016 at 10:00:00am</p></header><div class="content"><p>Ok, I guess we will wait for the core team (or perhaps Ilya) to return and advise then…<br></p><p>Thanks,<br>Jon<br></p><p>&gt; On Jun 16, 2016, at 7:33 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; That is for migration.  It does not affect the semantics of private at any level, it merely explains how we should go about the initial transition.  &quot;In many cases&quot; private being equivalent to fileprivate could be read that way, but given the rest of the proposal I didn&#39;t take any artistic freedoms and don&#39;t believe we should without clarification. <br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/06/16 2:00、Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; From the Impact portion of the proposal:<br>&gt;&gt;&gt; The existing code will need to rename private to fileprivate to achieve the same semantics. In many cases the new meaning of private is likely to compile as well and the code will then run exactly as before.<br>&gt;&gt; <br>&gt;&gt; I believe the second sentence refers to the case where fileprivate and private are the same at the top level.  I agree that the proposal is a bit vaguely/ambiguously written, but it in no way precludes the behavior everyone is saying was intended.<br>&gt;&gt; <br>&gt;&gt; I know the current implementation just gives unannotated members the same access modifier as the outer scope’s, but that is an implementation detail.  Furthermore it is entirely consistent with the interpretation given above in the case with only “fileprivate”, “internal”, and “public” scopes.  It is only when we add the new “private” scope that there is a difference.<br>&gt;&gt; <br>&gt;&gt; We have an ambiguous proposal which can be read in two different ways, but one of those ways is unworkable (the bug you mentioned), so I see no problem in interpreting it the other way (which just so happens to be the interpretation everyone says was intended) and moving forward.  It is entirely consistent with the proposal.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 16, 2016, at 12:35 AM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/06/16 0:29、Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; They happen to be the same at the top level, but they are very different when dealing with nested types…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A private member is visible inside it’s containing scope.  For the top-level, that is the file.  For a nested type, that is the outer type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A wonderful idea, but not in the proposal.  In fact, the singular example given therein runs directly counter to this idea by explicitly showing the scoping behavior of a private member.<br>&gt;&gt; <br>&gt;&gt; Chis Lattner’s response to the initial proposal (before the name fileprivate was chosen):<br>&gt;&gt;&gt; Per Doug’s email, the core team agrees we should make a change here, but would like some bikeshedding to happen on the replacement name for private.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To summarize the place we’d like to end up:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - “public” -&gt; symbol visible outside the current module.<br>&gt;&gt;&gt; - “internal” -&gt; symbol visible within the current module.<br>&gt;&gt;&gt; - unknown -&gt; symbol visible within the current file.<br>&gt;&gt;&gt; - “private” -&gt; symbol visible within the current declaration (class, extension, etc).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The rationale here is that this aligns Swift with common art seen in other languages, and that many people using private today don’t *want* visibility out of their current declaration.  It also encourages “extension oriented programming”, at least it will when some of the other restrictions on extensions are lifted.  We discussed dropping the third one entirely, but think it *is* a useful and important level of access control, and when/if we ever get the ability to write unit tests inside of the file that defines the functionality, they will be a nicer solution to &lt;at&gt; testable.<br>&gt;&gt; <br>&gt;&gt; As you can see the definition of “unknown” (now fileprivate) and “private” are exactly what I said.  Many people wanted to name the new private “scoped” or “local&quot; because of the way it worked, though “private” won in the end.  As you see, they thought of getting rid of fileprivate, but decided it was necessary.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Then we should amend the proposal posthaste!<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Basically, what I am saying here is that the intent is clear from the context (and original discussion) around the proposal. We all seem to agree about what needs to happen behavior-wise.  At most this is a bug-fix, and shouldn’t require a full rehashing on evolution.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/ca776b39/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
