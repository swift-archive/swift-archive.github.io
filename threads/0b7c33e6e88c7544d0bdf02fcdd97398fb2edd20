<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4db4fede2f4e473341b873406b68e4e1?s=50"></div><header><strong>Proof-of-concept port of Swift for Android</strong> from <string>Geordie Jay</string> &lt;geojay at gmail.com&gt;<p>December 11, 2015 at 01:00:00pm</p></header><div class="content"><p>Hi, maybe one of the Apple devs can help out with this quick Q:<br></p><p>To interface with the JNI, we’d presumably need to call swift functions from our compiled swift binaries from C (or directly from Java, the result being the same). Is there a way to demangle certain symbols in the output binary to this effect, or is there another / a better way to access Swift functions from C?<br></p><p>Thanks<br></p><p>----<br></p><p>For anyone else following along, there is some discussion here:<br>https://www.reddit.com/r/swift/comments/3w0xrd/im_patching_the_opensource_swift_compiler_to/ &lt;https://www.reddit.com/r/swift/comments/3w0xrd/im_patching_the_opensource_swift_compiler_to/&gt;<br>.. which I guess we’d probably be better off keeping on this mailing list instead.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151211/0b7cdd20/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 455 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151211/0b7cdd20/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Proof-of-concept port of Swift for Android</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 11, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 4:33 AM, Geordie Jay via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi, maybe one of the Apple devs can help out with this quick Q:<br>&gt; <br>&gt; To interface with the JNI, we’d presumably need to call swift functions from our compiled swift binaries from C (or directly from Java, the result being the same). Is there a way to demangle certain symbols in the output binary to this effect, or is there another / a better way to access Swift functions from C?<br></p><p>Others can probably give a more detailed response, but...<br></p><p>There’s a Swift demangler in Swift’s “Basic” library (lib/Basic/Demangle.cpp), along with a standalone tool (swift-demangle) you can experiment with. The information in the mangled name should be complete enough to call, but you’ll need to match Swift’s calling convention.<br></p><p>If it’s just a specific set of Swift functions you want to call from C, you can use the @_silgen_name attribute to override the mangled name, and/or make them @convention(c) to use the C calling convention.<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proof-of-concept port of Swift for Android</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 11, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 7:13 AM, Douglas Gregor via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 4:33 AM, Geordie Jay via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi, maybe one of the Apple devs can help out with this quick Q:<br>&gt;&gt; <br>&gt;&gt; To interface with the JNI, we’d presumably need to call swift functions from our compiled swift binaries from C (or directly from Java, the result being the same). Is there a way to demangle certain symbols in the output binary to this effect, or is there another / a better way to access Swift functions from C?<br>&gt; <br>&gt; Others can probably give a more detailed response, but...<br>&gt; <br>&gt; There’s a Swift demangler in Swift’s “Basic” library (lib/Basic/Demangle.cpp), along with a standalone tool (swift-demangle) you can experiment with. The information in the mangled name should be complete enough to call, but you’ll need to match Swift’s calling convention.<br>&gt; <br>&gt; If it’s just a specific set of Swift functions you want to call from C, you can use the @_silgen_name attribute to override the mangled name, and/or make them @convention(c) to use the C calling convention.<br></p><p>@_silgen_name isn&#39;t the right answer here, since the convention will be wrong, and it won&#39;t interact properly with Clang imports and exports. Like Slava said, you want something like the &#39;@_cdecl&#39; attribute he proposed and I half-implemented.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4db4fede2f4e473341b873406b68e4e1?s=50"></div><header><strong>Proof-of-concept port of Swift for Android</strong> from <string>Geordie Jay</string> &lt;geojay at gmail.com&gt;<p>December 11, 2015 at 09:00:00am</p></header><div class="content"><p>Hi Joe,<br></p><p>I was just commenting on your @_cdecl commit on GitHub but I’ll keep the discussion here.<br></p><p><br></p><p><br>I was wondering what it is about your implementation that makes it rely on ObjC interop, as you noted. And whether this dependency can be removed for a quick and dirty proof of concept, or whether it’s something more fundamental than that?<br></p><p><br></p><p><br></p><p><br></p><p>In this (admittedly very simple) example, the author just calls the mangled name from C and appears to get away with it:<br></p><p>http://romain.goyet.com/articles/running_swift_code_on_android/<br></p><p><br></p><p><br>Makes me wonder whether the @_silgen_name approach wouldn’t suffice after all for a proof of concept?<br></p><p><br></p><p><br>Best regards,<br></p><p>Geordie<br></p><p><br></p><p><br>(Joe: apologies for the double up, I’m evidently terrible at mailing lists and hit reply instead of reply all!)<br></p><p>On Fri, Dec 11, 2015 at 5:53 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;&gt; On Dec 11, 2015, at 7:13 AM, Douglas Gregor via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 4:33 AM, Geordie Jay via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi, maybe one of the Apple devs can help out with this quick Q:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To interface with the JNI, we’d presumably need to call swift functions from our compiled swift binaries from C (or directly from Java, the result being the same). Is there a way to demangle certain symbols in the output binary to this effect, or is there another / a better way to access Swift functions from C?<br>&gt;&gt; <br>&gt;&gt; Others can probably give a more detailed response, but...<br>&gt;&gt; <br>&gt;&gt; There’s a Swift demangler in Swift’s “Basic” library (lib/Basic/Demangle.cpp), along with a standalone tool (swift-demangle) you can experiment with. The information in the mangled name should be complete enough to call, but you’ll need to match Swift’s calling convention.<br>&gt;&gt; <br>&gt;&gt; If it’s just a specific set of Swift functions you want to call from C, you can use the @_silgen_name attribute to override the mangled name, and/or make them @convention(c) to use the C calling convention.<br>&gt; @_silgen_name isn&#39;t the right answer here, since the convention will be wrong, and it won&#39;t interact properly with Clang imports and exports. Like Slava said, you want something like the &#39;@_cdecl&#39; attribute he proposed and I half-implemented.<br>&gt; -Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151211/4112c5fb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proof-of-concept port of Swift for Android</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 11, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 9:03 AM, Geordie Jay &lt;geojay at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi Joe,<br>&gt; I was just commenting on your @_cdecl commit on GitHub but I’ll keep the discussion here.<br>&gt; <br>&gt; I was wondering what it is about your implementation that makes it rely on ObjC interop, as you noted. And whether this dependency can be removed for a quick and dirty proof of concept, or whether it’s something more fundamental than that?<br></p><p>It&#39;s mostly because that&#39;s how the parameter type validation logic I borrowed from @objc works, and I didn&#39;t have time to change it. The code for @cdecl has to be refined to support a &quot;C-only&quot; model, or maybe just only require ObjCInterop and &#39;import Foundation&#39; when ObjC-specific constructs are used.<br></p><p>&gt; <br>&gt; In this (admittedly very simple) example, the author just calls the mangled name from C and appears to get away with it:<br>&gt; http://romain.goyet.com/articles/running_swift_code_on_android/ &lt;http://romain.goyet.com/articles/running_swift_code_on_android/&gt;<br>&gt; <br>&gt; Makes me wonder whether the @_silgen_name approach wouldn’t suffice after all for a proof of concept?<br></p><p>They&#39;re getting lucky. Swift function ABIs happen to coincide with C function ABIs in some cases, but this can&#39;t be relied on, and will probably break soon when we switch over the Swift-specific calling convention in LLVM.<br></p><p>-Joe<br></p><p>&gt; Best regards,<br>&gt; Geordie<br>&gt; <br>&gt; (Joe: apologies for the double up, I’m evidently terrible at mailing lists and hit reply instead of reply all!)<br>&gt; <br>&gt; <br>&gt; On Fri, Dec 11, 2015 at 5:53 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; &gt; On Dec 11, 2015, at 7:13 AM, Douglas Gregor via swift-dev &lt;swift-dev at swift.org&gt; wrote: <br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt;&gt; On Dec 11, 2015, at 4:33 AM, Geordie Jay via swift-dev &lt;swift-dev at swift.org&gt; wrote: <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Hi, maybe one of the Apple devs can help out with this quick Q: <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; To interface with the JNI, we’d presumably need to call swift functions from our compiled swift binaries from C (or directly from Java, the result being the same). Is there a way to demangle certain symbols in the output binary to this effect, or is there another / a better way to access Swift functions from C? <br>&gt; &gt; <br>&gt; &gt; Others can probably give a more detailed response, but... <br>&gt; &gt; <br>&gt; &gt; There’s a Swift demangler in Swift’s “Basic” library (lib/Basic/Demangle.cpp), along with a standalone tool (swift-demangle) you can experiment with. The information in the mangled name should be complete enough to call, but you’ll need to match Swift’s calling convention. <br>&gt; &gt; <br>&gt; &gt; If it’s just a specific set of Swift functions you want to call from C, you can use the @_silgen_name attribute to override the mangled name, and/or make them @convention(c) to use the C calling convention. <br>&gt; <br>&gt; @_silgen_name isn&#39;t the right answer here, since the convention will be wrong, and it won&#39;t interact properly with Clang imports and exports. Like Slava said, you want something like the &#39;@_cdecl&#39; attribute he proposed and I half-implemented. <br>&gt; <br>&gt; -Joe<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151211/166e2560/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4db4fede2f4e473341b873406b68e4e1?s=50"></div><header><strong>Proof-of-concept port of Swift for Android</strong> from <string>Geordie Jay</string> &lt;geojay at gmail.com&gt;<p>December 11, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt;&gt; On Dec 11, 2015, at 9:03 AM, Geordie Jay &lt;geojay at gmail.com &lt;mailto:geojay at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Joe,<br>&gt;&gt; I was just commenting on your @_cdecl commit on GitHub but I’ll keep the discussion here.<br>&gt;&gt; <br>&gt;&gt; I was wondering what it is about your implementation that makes it rely on ObjC interop, as you noted. And whether this dependency can be removed for a quick and dirty proof of concept, or whether it’s something more fundamental than that?<br>&gt; <br>&gt; It&#39;s mostly because that&#39;s how the parameter type validation logic I borrowed from @objc works, and I didn&#39;t have time to change it. The code for @cdecl has to be refined to support a &quot;C-only&quot; model, or maybe just only require ObjCInterop and &#39;import Foundation&#39; when ObjC-specific constructs are used.<br></p><p>I’d like to have a look at making a simple C-only model of this. Compiler hacking is new to me though so I’ll be stabbing in the dark for a while. Can you elaborate as to whether you&#39;re referring to the block starting at line 4108 in &#39;lib/Sema/TypeCheckDecl.cpp’, or something else? Presumably there are already relevant type-checking routines for Swift&#39;s @convention_c functions, no?<br></p><p>&gt;&gt; In this (admittedly very simple) example, the author just calls the mangled name from C and appears to get away with it:<br>&gt;&gt; http://romain.goyet.com/articles/running_swift_code_on_android/ &lt;http://romain.goyet.com/articles/running_swift_code_on_android/&gt;<br>&gt;&gt; <br>&gt;&gt; Makes me wonder whether the @_silgen_name approach wouldn’t suffice after all for a proof of concept?<br>&gt; <br>&gt; They&#39;re getting lucky. Swift function ABIs happen to coincide with C function ABIs in some cases, but this can&#39;t be relied on, and will probably break soon when we switch over the Swift-specific calling convention in LLVM.<br></p><p>Are we talking about safety / type checking? I mean about validating that we’re not asking for e.g. a Swift Struct in our @_cdecl function? Or is there something else at play? The goal of Swift is obviously to be safe, but since I’m so new to this, what I’d like to see first is something that ‘works&#39; at all, and continue on the safe side after that. I’m just after a proof of concept for now.<br></p><p><br>—<br></p><p>I’m sorry about repeatedly starting new threads, I can’t figure out what the mailing list system expects of me. Even if I click reply from the web archive, which fills in the to/reply-to and subject (complete with RE: RE: etc.), it still starts a new thread. I haven’t felt this technically incompetent since the early 90s :)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151211/99087524/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 195 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151211/99087524/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proof-of-concept port of Swift for Android</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 11, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 11:41 AM, Geordie Jay &lt;geojay at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 9:03 AM, Geordie Jay &lt;geojay at gmail.com &lt;mailto:geojay at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Joe,<br>&gt;&gt;&gt; I was just commenting on your @_cdecl commit on GitHub but I’ll keep the discussion here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was wondering what it is about your implementation that makes it rely on ObjC interop, as you noted. And whether this dependency can be removed for a quick and dirty proof of concept, or whether it’s something more fundamental than that?<br>&gt;&gt; <br>&gt;&gt; It&#39;s mostly because that&#39;s how the parameter type validation logic I borrowed from @objc works, and I didn&#39;t have time to change it. The code for @cdecl has to be refined to support a &quot;C-only&quot; model, or maybe just only require ObjCInterop and &#39;import Foundation&#39; when ObjC-specific constructs are used.<br>&gt; <br>&gt; I’d like to have a look at making a simple C-only model of this. Compiler hacking is new to me though so I’ll be stabbing in the dark for a while. Can you elaborate as to whether you&#39;re referring to the block starting at line 4108 in &#39;lib/Sema/TypeCheckDecl.cpp’, or something else? Presumably there are already relevant type-checking routines for Swift&#39;s @convention_c functions, no?<br></p><p>The checking code is in the &quot;isRepresentableInObjC&quot; family of functions around there, yeah. @convention(c) didn&#39;t need to distinguish C from ObjC on Darwin platforms, since ObjC and Foundation are always available there, so we didn&#39;t bother trying to separate them. You could probably get started by just disabling the checks for Foundation and ObjC interop altogether and avoiding touching any class, block, or CF types (which probably is easy on Android).<br></p><p>&gt;&gt;&gt; In this (admittedly very simple) example, the author just calls the mangled name from C and appears to get away with it:<br>&gt;&gt;&gt; http://romain.goyet.com/articles/running_swift_code_on_android/ &lt;http://romain.goyet.com/articles/running_swift_code_on_android/&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Makes me wonder whether the @_silgen_name approach wouldn’t suffice after all for a proof of concept?<br>&gt;&gt; <br>&gt;&gt; They&#39;re getting lucky. Swift function ABIs happen to coincide with C function ABIs in some cases, but this can&#39;t be relied on, and will probably break soon when we switch over the Swift-specific calling convention in LLVM.<br>&gt; <br>&gt; Are we talking about safety / type checking? I mean about validating that we’re not asking for e.g. a Swift Struct in our @_cdecl function? Or is there something else at play? The goal of Swift is obviously to be safe, but since I’m so new to this, what I’d like to see first is something that ‘works&#39; at all, and continue on the safe side after that. I’m just after a proof of concept for now.<br></p><p>I&#39;m talking about linkage safety. If swiftc exports a swift function with a certain symbol name, and C code links against it, we don&#39;t want to guarantee they&#39;ll use the same calling convention, unless the function is explicitly exported with an attribute saying it uses the C calling convention.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151211/087566db/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Proof-of-concept port of Swift for Android</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>December 11, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 4:33 AM, Geordie Jay via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi, maybe one of the Apple devs can help out with this quick Q:<br>&gt; <br>&gt; To interface with the JNI, we’d presumably need to call swift functions from our compiled swift binaries from C (or directly from Java, the result being the same). Is there a way to demangle certain symbols in the output binary to this effect, or is there another / a better way to access Swift functions from C?<br></p><p>Joe Groff has a proof-of-concept implementation of a @cdecl attribute for exporting functions to C in the cdecl-attribute branch on GitHub.<br></p><p>Slava<br></p><p>&gt; <br>&gt; Thanks<br>&gt; <br>&gt; ----<br>&gt; <br>&gt; For anyone else following along, there is some discussion here:<br>&gt; https://www.reddit.com/r/swift/comments/3w0xrd/im_patching_the_opensource_swift_compiler_to/ &lt;https://www.reddit.com/r/swift/comments/3w0xrd/im_patching_the_opensource_swift_compiler_to/&gt;<br>&gt; .. which I guess we’d probably be better off keeping on this mailing list instead.<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151211/74be4cb4/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
