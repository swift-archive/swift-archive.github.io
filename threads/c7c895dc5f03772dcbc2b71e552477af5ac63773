<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1b852c5986959201d1f8eca105491072?s=50"></div><header><strong>Could enums have their rawValue type inferred?</strong> from <string>Eric Miller</string> &lt;hi at simple.gy&gt;<p>May 13, 2016 at 12:00:00pm</p></header><div class="content"><p>This might open a larger can of worms than I imagine, but what do you folks<br>think about using the `rawValue` of an enum when that rawValue is a fit for<br>the expected type?<br></p><p>Use case.<br></p><p>I&#39;m making an animation facade, and it has some speed presets:<br></p><p>class Animate {<br>  enum transitionSpeed: NSTimeInterval {<br>    case fast = 0.15<br>    case slow = 0.5<br>  }<br>  enum ambientAnimationSpeed: NSTimeInterval {<br>    case fast = 1.0<br>    case slow = 5.0<br>  }<br>  ...<br>}<br></p><p>I did them with static variables at first but that made the call site<br>verbose. Compare:<br></p><p>Animate.fadeIn(view, withSpeed: Animate.cfg.transitionFast)<br>Animate.fadeIn(view, withSpeed: .fast)<br></p><p>So, I like the enum approach better, but my library code has to use<br>`rawValue` to do anything with the actual value, of course:<br></p><p>static func fadeIn(view: UIView?, withSpeed duration:transitionSpeed =<br>.fast) {<br>  ...<br>  UIView.animateWithDuration(duration.rawValue, animations: { })<br>}<br></p><p>It&#39;s not a serious issue, but the code is more clear and beautiful if it<br>has just myIntent, rather than myIntent.rawValue.<br></p><p>I&#39;ve hit this issue when modeling other things, such as:<br></p><p>* server fault codes<br>* HTTP status codes<br>* Currency codes<br>* Days of the week<br></p><p>Would it be appropriate to &quot;autocast&quot; to the rawValue of the enum when the<br>rawValue&#39;s Type matches the type expectation of the API? Or would this<br>introduce a bunch of type system uncertainty?<br></p><p>Maybe this could be implemented as a protocol? It feels almost like the<br>convenience of `CustomStringConvertible`&#39;s `description` property.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/c7c83773/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Could enums have their rawValue type inferred?</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 13, 2016 at 04:00:00pm</p></header><div class="content"><p>Eric, I think I understood your proposal. If I may explain in other words<br>it would be &quot;to automatically cast rawValue when assigning an enum value to<br>a variable or argument of the type of the enum&#39;s raw value&quot;, am I right? I<br>think this would imply a little more inference and type checking rules from<br>the compiler and maybe even take a little longer to fully compile code. I&#39;m<br>not sure it&#39;s feasible but from your examples, I can see how it enhances<br>readability of the code, so I&#39;m +1 for it. My only concern is that you<br>would still need to fully declare the enum&#39;s name where the value of the<br>enum is used. Taking from your own example<br></p><p>    Animate.fadeIn(view, withSpeed: .fast)<br></p><p>couldn&#39;t be called that way if withSpeed expects and NSTimeInterval because<br>the compiler won&#39;t know whether you&#39;re refering to transitionSpeed or to<br>ambientAnimationSpeed. You would still have to call it like<br></p><p>    Animate.fadeIn(view, withSpeed: transitionSpeed.fast)<br></p><p>even if you had only one possible enum value over all declared enums<br>because that would still force the compiler to search for each value over<br>all known enums to define where the value you&#39;re using comes from and make<br>sure there are no two enums with the same value.<br></p><p>Aside from that, I good with the idea.<br></p><p><br></p><p>On 13 May 2016 at 15:09, Eric Miller via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This might open a larger can of worms than I imagine, but what do you<br>&gt; folks think about using the `rawValue` of an enum when that rawValue is a<br>&gt; fit for the expected type?<br>&gt;<br>&gt; Use case.<br>&gt;<br>&gt; I&#39;m making an animation facade, and it has some speed presets:<br>&gt;<br>&gt; class Animate {<br>&gt;   enum transitionSpeed: NSTimeInterval {<br>&gt;     case fast = 0.15<br>&gt;     case slow = 0.5<br>&gt;   }<br>&gt;   enum ambientAnimationSpeed: NSTimeInterval {<br>&gt;     case fast = 1.0<br>&gt;     case slow = 5.0<br>&gt;   }<br>&gt;   ...<br>&gt; }<br>&gt;<br>&gt; I did them with static variables at first but that made the call site<br>&gt; verbose. Compare:<br>&gt;<br>&gt; Animate.fadeIn(view, withSpeed: Animate.cfg.transitionFast)<br>&gt; Animate.fadeIn(view, withSpeed: .fast)<br>&gt;<br>&gt; So, I like the enum approach better, but my library code has to use<br>&gt; `rawValue` to do anything with the actual value, of course:<br>&gt;<br>&gt; static func fadeIn(view: UIView?, withSpeed duration:transitionSpeed =<br>&gt; .fast) {<br>&gt;   ...<br>&gt;   UIView.animateWithDuration(duration.rawValue, animations: { })<br>&gt; }<br>&gt;<br>&gt; It&#39;s not a serious issue, but the code is more clear and beautiful if it<br>&gt; has just myIntent, rather than myIntent.rawValue.<br>&gt;<br>&gt; I&#39;ve hit this issue when modeling other things, such as:<br>&gt;<br>&gt; * server fault codes<br>&gt; * HTTP status codes<br>&gt; * Currency codes<br>&gt; * Days of the week<br>&gt;<br>&gt; Would it be appropriate to &quot;autocast&quot; to the rawValue of the enum when the<br>&gt; rawValue&#39;s Type matches the type expectation of the API? Or would this<br>&gt; introduce a bunch of type system uncertainty?<br>&gt;<br>&gt; Maybe this could be implemented as a protocol? It feels almost like the<br>&gt; convenience of `CustomStringConvertible`&#39;s `description` property.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/05a1d4c2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Could enums have their rawValue type inferred?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 16, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; This might open a larger can of worms than I imagine, but what do you folks think about using the `rawValue` of an enum when that rawValue is a fit for the expected type?<br></p><p>No.<br></p><p>An enum case is something quite distinct from its raw value. If you just want a convenient way to write some particular value you use a lot, what you&#39;re looking for is a constant, not an enum.<br></p><p>&gt; Use case.<br>&gt; <br>&gt; I&#39;m making an animation facade, and it has some speed presets:<br>&gt; <br>&gt; class Animate { <br>&gt;   enum transitionSpeed: NSTimeInterval {<br>&gt;     case fast = 0.15<br>&gt;     case slow = 0.5<br>&gt;   }<br>&gt;   enum ambientAnimationSpeed: NSTimeInterval {<br>&gt;     case fast = 1.0<br>&gt;     case slow = 5.0<br>&gt;   }<br>&gt;   ...<br>&gt; }<br>&gt; <br>&gt; I did them with static variables at first but that made the call site verbose. Compare:<br>&gt; <br>&gt; Animate.fadeIn(view, withSpeed: Animate.cfg.transitionFast)<br>&gt; Animate.fadeIn(view, withSpeed: .fast)<br>&gt; <br>&gt; So, I like the enum approach better, but my library code has to use `rawValue` to do anything with the actual value, of course:<br>&gt; <br>&gt; static func fadeIn(view: UIView?, withSpeed duration:transitionSpeed = .fast) {<br>&gt;   ...<br>&gt;   UIView.animateWithDuration(duration.rawValue, animations: { })<br>&gt; }<br></p><p>For instance, in this case, you should just write something like:<br></p><p>	extension NSTimeInterval {<br>		static let fastTransition: NSTimeInterval = 0.15<br>		static let slowTransition: NSTimeInterval = 0.5<br>		<br>		static let fastAmbientAnimation: NSTimeInterval = 1.0<br>		static let slowAmbientAnimation: NSTimeInterval = 5.0<br>	}<br>	<br>	class Animate {<br>		static func fadeIn(view: UIView?, withSpeed duration: NSTimeInterval = .fastTransition) {<br>			...<br>			UIView.animateWithDuration(duration, animations: { })<br>		}<br>	}<br>	<br>	Animate.fadeIn(view, withSpeed: .fastTransition)<br>	Animate.fadeIn(view, withSpeed: .slowTransition)<br>	Animate.fadeIn(view, withSpeed: 3.14159)		// or anything else<br></p><p>Alternatively, if you really do want to lock people into either &quot;fast&quot; or &quot;slow&quot;, then by all means use an enum. But realize that your new type is just that: a new type. It has its own semantic meaning, its own operations and methods and properties, and its own set of permitted values. It is not interchangeable with the raw value.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Could enums have their rawValue type inferred?</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>May 17, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;m not sure if I want the proposal to be standard-behavior, but in the past, I have written numerous extensions which basically took an enum to forward its raw value to an existing method (mostly keys for NSUserDefaults).<br>So, it would be convenient if the conversation happens automatically… but this use case isn&#39;t actually a &quot;real&quot; enum; it is just handy to get the value and a namespace for free, and I expect that there will be better ways to achieve this in the future.<br>On the other hand: What&#39;s the point of &quot;raw-value enums&quot;? Are they just a bridge-technogy, or is it ok to use them to store constants?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Could enums have their rawValue type inferred?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 17, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On the other hand: What&#39;s the point of &quot;raw-value enums&quot;? Are they just a bridge-technogy, or is it ok to use them to store constants?<br></p><p>I think of RawRepresentable (the protocol behind rawValue) as a serialization mechanism, basically the Swift standard library&#39;s answer to NSCoding. Thus, rawValue is a way to serialize your enum into an Int or String you know how to read and write from disk. More broadly, I often apply RawRepresentable to structs and have them return plist- or JSON-compatible dictionaries. <br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Could enums have their rawValue type inferred?</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 17, 2016 at 01:00:00pm</p></header><div class="content"><p>Oh, this is a really interesting use case for that protocol. I wonder if<br>RawRepresentable might one day be auto-derivable for certain types, as part<br>of a more comprehensive Swift serialization/deserialization feature.<br></p><p>Austin<br></p><p>On Tue, May 17, 2016 at 1:05 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On the other hand: What&#39;s the point of &quot;raw-value enums&quot;? Are they just<br>&gt; a bridge-technogy, or is it ok to use them to store constants?<br>&gt;<br>&gt; I think of RawRepresentable (the protocol behind rawValue) as a<br>&gt; serialization mechanism, basically the Swift standard library&#39;s answer to<br>&gt; NSCoding. Thus, rawValue is a way to serialize your enum into an Int or<br>&gt; String you know how to read and write from disk. More broadly, I often<br>&gt; apply RawRepresentable to structs and have them return plist- or<br>&gt; JSON-compatible dictionaries.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/2885e0ba/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Could enums have their rawValue type inferred?</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 17, 2016 at 10:00:00pm</p></header><div class="content"><p>Thanks Brent, this one is quite a keeper :). Concise and very friendly way of explaining RawRepresentable.<br></p><p>Sent from my iPhone<br></p><p>On 17 May 2016, at 21:05, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On the other hand: What&#39;s the point of &quot;raw-value enums&quot;? Are they just a bridge-technogy, or is it ok to use them to store constants?<br>&gt; <br>&gt; I think of RawRepresentable (the protocol behind rawValue) as a serialization mechanism, basically the Swift standard library&#39;s answer to NSCoding. Thus, rawValue is a way to serialize your enum into an Int or String you know how to read and write from disk. More broadly, I often apply RawRepresentable to structs and have them return plist- or JSON-compatible dictionaries. <br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
