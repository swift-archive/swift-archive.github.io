<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>April  6, 2016 at 02:00:00pm</p></header><div class="content"><p>If you&#39;ve ever gotten to the point where you have a sufficiently generic interface to a thing and you need to constrain it, possibly in an extension, maybe for a generic free function or operator, you know what a pain the syntax can be for these kinds of operations.  For example, the Swift book implements this example to motivate where clauses<br></p><p>func anyCommonElements &lt;T: SequenceType, U: SequenceType where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt; (lhs: T, _ rhs: U) -&gt; Bool<br></p><p>This is noisy and uncomfortable to my eyes, and almost impossible to align correctly.  Per a short discussion on Twitter with Joe Groff and Erica Sadun, I&#39;d like so see what the community feels about moving the where clause out of the angle brackets.  So that example becomes<br></p><p>func anyCommonElements &lt;T: SequenceType, U: SequenceType&gt;<br>where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>(lhs: T, _ rhs: U) -&gt; Bool<br></p><p>Or, if you&#39;re feeling ambitious, even<br></p><p>func anyCommonElements &lt;T, U&gt;<br>where T : SequenceType, U : SequenceType,<br>T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>(lhs: T, _ rhs: U) -&gt; Bool<br></p><p>Thoughts?<br></p><p>~Robert Widmann<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>April  6, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 06 Apr 2016, at 21:30, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If you&#39;ve ever gotten to the point where you have a sufficiently generic interface to a thing and you need to constrain it, possibly in an extension, maybe for a generic free function or operator, you know what a pain the syntax can be for these kinds of operations.<br></p><p>+1 already!<br></p><p>&gt; Or, if you&#39;re feeling ambitious, even<br>&gt; <br>&gt; func anyCommonElements &lt;T, U&gt;<br>&gt; where T : SequenceType, U : SequenceType,<br>&gt; T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt; (lhs: T, _ rhs: U) -&gt; Bool<br></p><p>I would actually move them as far as after everything else, and right before the definition body. For the above function that would mean:<br></p><p>func anyCommonElements&lt;T, U&gt;(lhs: T, _ rhs: U) -&gt; Bool<br>    where T : SequenceType,<br>          U : SequenceType,<br>          T.Generator.Element: Equatable,<br>          T.Generator.Element == U.Generator.Element<br>{<br>    ...<br>}<br></p><p>That would make the definition look closer to what the call site looks like.<br></p><p>The same would work for generic types  too:<br></p><p>public struct Dictionary&lt;Key, Value&gt;<br>    where Key : Hashable<br>{<br>   ...<br>}<br></p><p>— Pyry<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/2445af9b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>April  6, 2016 at 06:00:00pm</p></header><div class="content"><p>On Wed, Apr 6, 2016 at 11:36 AM Pyry Jahkola via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On 06 Apr 2016, at 21:30, Developer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; If you&#39;ve ever gotten to the point where you have a sufficiently generic<br>&gt; interface to a thing and you need to constrain it, possibly in an<br>&gt; extension, maybe for a generic free function or operator, you know what a<br>&gt; pain the syntax can be for these kinds of operations.<br>&gt;<br>&gt;<br>&gt; +1 already!<br>&gt;<br>&gt; Or, if you&#39;re feeling ambitious, even<br>&gt;<br>&gt; func anyCommonElements &lt;T, U&gt;<br>&gt; where T : SequenceType, U : SequenceType,<br>&gt; T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt;<br>&gt;<br>&gt; I would actually move them as far as after everything else, and right<br>&gt; before the definition body. For the above function that would mean:<br>&gt;<br>&gt; func anyCommonElements&lt;T, U&gt;*(lhs: T, _ rhs: U) -&gt; Bool*<br>&gt; *    where T : SequenceType,*<br>&gt;<br>&gt; *          U : SequenceType,          T.Generator.Element: Equatable,*<br>&gt;<br>&gt; *          T.Generator.Element == U.Generator.Element*<br>&gt; {<br>&gt;     ...<br>&gt; }<br>&gt;<br>&gt; That would make the definition look closer to what the call site looks<br>&gt; like.<br>&gt;<br>&gt; The same would work for generic types  too:<br>&gt;<br>&gt; public struct Dictionary&lt;Key, Value&gt;<br>&gt;     where Key : Hashable<br>&gt; {<br>&gt;    ...<br>&gt; }<br>&gt;<br></p><p>I very much like this suggestion.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/84758eb5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>April  7, 2016 at 11:00:00am</p></header><div class="content"><p>Because I am a mailing list noob, my email wasn&#39;t CC&#39;d to all. So here we go again:<br></p><p>Big +1 from me. <br></p><p>I expected not to like this syntax but I believe it makes it far clearer. It always felt backwards to me to have to come up with all the constraints before the function signature. Maybe this is moot because you should already know what the function should look like before writing. But we are all human and things may change as we are writing it, resulting in a constant going back and forth from the signature to the constraints. <br></p><p>It reads much more naturally (and I think it&#39;s easier to write) when the where clause is after the signature because you have to look *back* to the parameters in the function instead of looking forward. And when having to look forward, you have to parse a possibly long list of constraints before even finding the signature. Repeat this possibly for each constraint and there is some mental overload there. <br></p><p>With the where at the end, you&#39;ve already read the function signature and the signature is in a known easy to find place when looking back at it. <br></p><p>So in summary:<br>- it reads more naturally<br>- more comfortable on the eyes<br>- easier to find the function signature when looking back after reading the constraints <br></p><p>This all leads to less mental overload IMO<br></p><p>Brandon <br></p><p>&gt; On Apr 6, 2016, at 2:37 PM, Shawn Erickson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Wed, Apr 6, 2016 at 11:36 AM Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On 06 Apr 2016, at 21:30, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you&#39;ve ever gotten to the point where you have a sufficiently generic interface to a thing and you need to constrain it, possibly in an extension, maybe for a generic free function or operator, you know what a pain the syntax can be for these kinds of operations.<br>&gt;&gt; <br>&gt;&gt; +1 already!<br>&gt;&gt; <br>&gt;&gt;&gt; Or, if you&#39;re feeling ambitious, even<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func anyCommonElements &lt;T, U&gt;<br>&gt;&gt;&gt; where T : SequenceType, U : SequenceType,<br>&gt;&gt;&gt; T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt;&gt;&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I would actually move them as far as after everything else, and right before the definition body. For the above function that would mean:<br>&gt;&gt; <br>&gt;&gt; func anyCommonElements&lt;T, U&gt;(lhs: T, _ rhs: U) -&gt; Bool<br>&gt;&gt;     where T : SequenceType,<br>&gt;&gt;           U : SequenceType,<br>&gt;&gt;           T.Generator.Element: Equatable,<br>&gt;&gt;           T.Generator.Element == U.Generator.Element<br>&gt;&gt; {<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; That would make the definition look closer to what the call site looks like.<br>&gt;&gt; <br>&gt;&gt; The same would work for generic types  too:<br>&gt;&gt; <br>&gt;&gt; public struct Dictionary&lt;Key, Value&gt;<br>&gt;&gt;     where Key : Hashable<br>&gt;&gt; {<br>&gt;&gt;    ...<br>&gt;&gt; }<br>&gt; <br>&gt; I very much like this suggestion. <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/0b45b24d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>April  6, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; The same would work for generic types  too:<br>&gt; <br>&gt; public struct Dictionary&lt;Key, Value&gt;<br>&gt;     where Key : Hashable<br>&gt; {<br>&gt;    ...<br>&gt; }<br></p><p>And I&#39;m not sure if people feel the same as me, but I haven&#39;t been happy with the current way generic arguments (such as Key and Value above) magically appear in type extensions but are inaccessible from anywhere else and can&#39;t be made public (`public typealias Key = Key` is an error).<br></p><p>The above syntax would make it possible to use whatever identifiers locally so that it&#39;s clear what they are:<br></p><p>extension Dictionary&lt;K, V&gt;<br>    // (unclear if `where K : Hashable` should be repeated here, though)<br>{<br>    ...<br>}<br></p><p>extension Array&lt;T&gt;<br>    where T : Comparable<br>{<br>    ...<br>}<br></p><p>extension Array&lt;T&gt;<br>    where T == String<br>{<br>    ...<br>}<br></p><p>etc.<br></p><p>— Pyry<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/6d735026/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April  6, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 6 Apr 2016, at 19:35, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; func anyCommonElements&lt;T, U&gt;(lhs: T, _ rhs: U) -&gt; Bool<br>&gt;     where T : SequenceType,<br>&gt;           U : SequenceType,<br>&gt;           T.Generator.Element: Equatable,<br>&gt;           T.Generator.Element == U.Generator.Element<br>&gt; {<br>&gt;     ...<br>&gt; }<br>&gt; <br></p><p>This is an excellent idea: +1!<br></p><p>If `where` is left on a previous line, it would also appear more in line with `throws`:<br></p><p>func anyCommonElements&lt;T, U&gt;(lhs: T, _ rhs: U) -&gt; Bool where<br>    T : SequenceType,<br>    U : SequenceType,<br>    T.Generator.Element: Equatable,<br>    T.Generator.Element == U.Generator.Element<br>{<br>    ...<br>}<br></p><p><br>milos<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/c84dc8d2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>April  6, 2016 at 01:00:00pm</p></header><div class="content"><p>This almost seems like it could work so that it didn&#39;t even need the bracketed parts to be able to figure out the types:<br></p><p>func anyCommonElements(lhs: T, _ rhs: U) -&gt; Bool where<br>    T : SequenceType,<br>    U : SequenceType,<br>    T.Generator.Element: Equatable,<br>    T.Generator.Element == U.Generator.Element<br>{}<br></p><p>.. which would address my concerns about distance from names to params, too!<br></p><p>l8r<br>Sean<br></p><p><br></p><p>&gt; On Apr 6, 2016, at 1:47 PM, Milos Rankovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 6 Apr 2016, at 19:35, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; func anyCommonElements&lt;T, U&gt;(lhs: T, _ rhs: U) -&gt; Bool<br>&gt;&gt;     where T : SequenceType,<br>&gt;&gt;           U : SequenceType,<br>&gt;&gt;           T.Generator.Element: Equatable,<br>&gt;&gt;           T.Generator.Element == U.Generator.Element<br>&gt;&gt; {<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt; <br>&gt; This is an excellent idea: +1!<br>&gt; <br>&gt; If `where` is left on a previous line, it would also appear more in line with `throws`:<br>&gt; <br>&gt; func anyCommonElements&lt;T, U&gt;(lhs: T, _ rhs: U) -&gt; Bool where<br>&gt;     T : SequenceType,<br>&gt;     U : SequenceType,<br>&gt;     T.Generator.Element: Equatable,<br>&gt;     T.Generator.Element == U.Generator.Element<br>&gt; {<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; <br>&gt; milos<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06130940a44c84dfc6c5aeabfd8482f8?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Timothy Wood</string> &lt;tjw at me.com&gt;<p>April  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 11:48 AM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This almost seems like it could work so that it didn&#39;t even need the bracketed parts to be able to figure out the types:<br>&gt; <br>&gt; func anyCommonElements(lhs: T, _ rhs: U) -&gt; Bool where<br>&gt;    T : SequenceType,<br>&gt;    U : SequenceType,<br>&gt;    T.Generator.Element: Equatable,<br>&gt;    T.Generator.Element == U.Generator.Element<br>&gt; {}<br>&gt; <br></p><p>... though if there are no type constraints, this would be ambiguous:<br></p><p>	// If there are no know types T and R in scope, is this an error or are T and R assumed to be unconstrained generic parameters?<br>	func f(arg: T) -&gt; R<br></p><p>-tim<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>April  6, 2016 at 02:00:00pm</p></header><div class="content"><p>I would think it’d just be unconstrained generic parameters - same as this is now:<br></p><p>func f&lt;A, B&gt;(lhs: A, _ rhs: B) {}<br></p><p>However I can see how it’d certainly be potentially too confusing. It might be worthwhile to retain the brackets, but require type restrictions to be moved to the trailing “where” so that it keeps the &lt;&gt; part as short as possible, so this would be an error:<br></p><p>func f&lt;A: SequenceType, B: Equatable&gt;(lhs: A, _ rhs: B) -&gt; Bool {}<br></p><p>And would have to be written:<br></p><p>func f&lt;A, B&gt;(lhs: A, _ rhs: B) -&gt; Bool where A: SequenceType, B: Equatable {}<br></p><p>Maybe? That’s a bit longer, though. Maybe it’s not worth changing that aspect of it. I like moving “where” to the end, though.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Apr 6, 2016, at 1:53 PM, Timothy Wood &lt;tjw at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 6, 2016, at 11:48 AM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This almost seems like it could work so that it didn&#39;t even need the bracketed parts to be able to figure out the types:<br>&gt;&gt; <br>&gt;&gt; func anyCommonElements(lhs: T, _ rhs: U) -&gt; Bool where<br>&gt;&gt;   T : SequenceType,<br>&gt;&gt;   U : SequenceType,<br>&gt;&gt;   T.Generator.Element: Equatable,<br>&gt;&gt;   T.Generator.Element == U.Generator.Element<br>&gt;&gt; {}<br>&gt;&gt; <br>&gt; <br>&gt; ... though if there are no type constraints, this would be ambiguous:<br>&gt; <br>&gt; 	// If there are no know types T and R in scope, is this an error or are T and R assumed to be unconstrained generic parameters?<br>&gt; 	func f(arg: T) -&gt; R<br>&gt; <br>&gt; -tim<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>April  6, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; This almost seems like it could work so that it didn&#39;t even need the bracketed parts to be able to figure out the types:<br>&gt; <br>&gt; func anyCommonElements(lhs: T, _ rhs: U) -&gt; Bool where<br>&gt;    T : SequenceType,<br>&gt;    U : SequenceType,<br>&gt;    T.Generator.Element: Equatable,<br>&gt;    T.Generator.Element == U.Generator.Element<br>&gt; {}<br></p><p>I&#39;d still keep the generic arguments listed there in the brackets if only for the following reasons:<br></p><p>1. The new names get introduced (in `&lt;...&gt;`) before their first use. So if you happened to name one of them `String`, it would be clear that you didn&#39;t mean `Swift.String`.<br></p><p>2. It&#39;s been sometimes wished that you could explicitly specify which specialisation you want to use, e.g. when passing a function into a handler (e.g. `let operation = anyCommonElements&lt;[Int], [Int]&gt;(_:_:)`).<br></p><p>3. How would you otherwise mention a generic type if there were no constraints for it? I think the suggested form:<br></p><p>extension Array&lt;T&gt; {<br>    // no constraints needed (not for T above, not for U below)<br>    func map&lt;U&gt;(transform: T -&gt; U) -&gt; Array&lt;U&gt; { ... }<br>}<br></p><p>reads better than this:<br></p><p>extension Array&lt;T&gt; {<br>    // Wait what, where did U come from?<br>    func map(transform: T -&gt; U) -&gt; Array&lt;U&gt; { ... }<br>}<br></p><p>— Pyry<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/da6e0917/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April  6, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 6 Apr 2016, at 19:48, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; This almost seems like it could work so that it didn&#39;t even need the bracketed parts to be able to figure out the types:<br>&gt; <br>&gt; func anyCommonElements(lhs: T, _ rhs: U) -&gt; Bool where<br>&gt;    T : SequenceType,<br>&gt;    U : SequenceType,<br>&gt;    T.Generator.Element: Equatable,<br>&gt;    T.Generator.Element == U.Generator.Element<br>&gt; {}<br>&gt; <br></p><p>But if the brackets are kept, we may be able to do away with commas? For example, this Standard Library function:<br></p><p>    public func + &lt;<br>        C : RangeReplaceableCollectionType,<br>        S : SequenceType<br>        where S.Generator.Element == C.Generator.Element<br>    &gt; (lhs: C, rhs: S) -&gt; C<br></p><p>would become:<br></p><p>    public func + (lhs: C, rhs: S) -&gt; C where &lt;<br>        C : RangeReplaceableCollectionType<br>        C : SequenceType<br>        S.Generator.Element == C.Generator.Element<br>    &gt;<br> <br>Brackets may also be needed for the api view of the library.<br></p><p>milos<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/f969ed3d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April  6, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; For example, this Standard Library function:<br>&gt; <br>&gt;     public func + &lt;<br>&gt;         C : RangeReplaceableCollectionType,<br>&gt;         S : SequenceType<br>&gt;         where S.Generator.Element == C.Generator.Element<br>&gt;     &gt; (lhs: C, rhs: S) -&gt; C<br>&gt; <br>&gt; would become:<br>&gt; <br>&gt;     public func + (lhs: C, rhs: S) -&gt; C where &lt;<br>&gt;         C : RangeReplaceableCollectionType<br>&gt;         C : SequenceType<br>&gt;         S.Generator.Element == C.Generator.Element<br>&gt;     &gt;<br>&gt; <br></p><p>As for structs, this Standard Library struct:<br></p><p>	public struct FlattenBidirectionalCollection &lt;Base : CollectionType where Base.Generator.Element : CollectionType, Base.Index : BidirectionalIndexType, Base.Generator.Element.Index : BidirectionalIndexType&gt; : CollectionType { … }<br></p><p>… could become:<br></p><p>	public struct FlattenBidirectionalCollection&lt;Base&gt; : CollectionType where &lt;<br>		 Base : CollectionType<br>		 Base.Generator.Element : CollectionType<br>		 Base.Index : BidirectionalIndexType<br>		 Base.Generator.Element.Index : BidirectionalIndexType<br>	&gt; { … }<br></p><p>milos<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/582e7f65/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>April  6, 2016 at 08:00:00pm</p></header><div class="content"><p>A big +1 to this notation. <br></p><p><br>&gt; On 06 Apr 2016, at 20:47, Milos Rankovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 6 Apr 2016, at 19:35, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; func anyCommonElements&lt;T, U&gt;(lhs: T, _ rhs: U) -&gt; Bool<br>&gt;&gt;     where T : SequenceType,<br>&gt;&gt;           U : SequenceType,<br>&gt;&gt;           T.Generator.Element: Equatable,<br>&gt;&gt;           T.Generator.Element == U.Generator.Element<br>&gt;&gt; {<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt; <br>&gt; This is an excellent idea: +1!<br>&gt; <br>&gt; If `where` is left on a previous line, it would also appear more in line with `throws`:<br>&gt; <br>&gt; func anyCommonElements&lt;T, U&gt;(lhs: T, _ rhs: U) -&gt; Bool where<br>&gt;     T : SequenceType,<br>&gt;     U : SequenceType,<br>&gt;     T.Generator.Element: Equatable,<br>&gt;     T.Generator.Element == U.Generator.Element<br>&gt; {<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; <br>&gt; milos<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/f08307f9/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9df2c06d044639a33128b3b66f0b6509?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Juan Ignacio Laube</string> &lt;juanignaciolaube at gmail.com&gt;<p>April  6, 2016 at 04:00:00pm</p></header><div class="content"><p>+1. I like the idea of seeing the function signature first, then the constraints.<br></p><p><br>&gt; On Apr 6, 2016, at 3:47 PM, Milos Rankovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 6 Apr 2016, at 19:35, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; func anyCommonElements&lt;T, U&gt;(lhs: T, _ rhs: U) -&gt; Bool<br>&gt;&gt;     where T : SequenceType,<br>&gt;&gt;           U : SequenceType,<br>&gt;&gt;           T.Generator.Element: Equatable,<br>&gt;&gt;           T.Generator.Element == U.Generator.Element<br>&gt;&gt; {<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt; <br>&gt; This is an excellent idea: +1!<br>&gt; <br>&gt; If `where` is left on a previous line, it would also appear more in line with `throws`:<br>&gt; <br>&gt; func anyCommonElements&lt;T, U&gt;(lhs: T, _ rhs: U) -&gt; Bool where<br>&gt;     T : SequenceType,<br>&gt;     U : SequenceType,<br>&gt;     T.Generator.Element: Equatable,<br>&gt;     T.Generator.Element == U.Generator.Element<br>&gt; {<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; <br>&gt; milos<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/ac690dd2/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April  6, 2016 at 08:00:00pm</p></header><div class="content"><p>With `where` at the end, the Standard Library function:<br></p><p>	public func != &lt;<br>		A : Equatable, <br>		B : Equatable, <br>		C : Equatable, <br>		D : Equatable, <br>		E : Equatable, <br>		F : Equatable<br>	&gt; (lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -&gt; Bool<br></p><p>becomes:<br></p><p>	public func != (lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -&gt; Bool where &lt;<br>		A : Equatable,<br>		B : Equatable,<br>		C : Equatable,<br>		D : Equatable,<br>		E : Equatable,<br>		F : Equatable<br>	&gt;<br>milos<br></p><p>&gt; On 6 Apr 2016, at 19:35, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On 06 Apr 2016, at 21:30, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If you&#39;ve ever gotten to the point where you have a sufficiently generic interface to a thing and you need to constrain it, possibly in an extension, maybe for a generic free function or operator, you know what a pain the syntax can be for these kinds of operations.<br>&gt; <br>&gt; +1 already!<br>&gt; <br>&gt;&gt; Or, if you&#39;re feeling ambitious, even<br>&gt;&gt; <br>&gt;&gt; func anyCommonElements &lt;T, U&gt;<br>&gt;&gt; where T : SequenceType, U : SequenceType,<br>&gt;&gt; T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt;&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; <br>&gt; I would actually move them as far as after everything else, and right before the definition body. For the above function that would mean:<br>&gt; <br>&gt; func anyCommonElements&lt;T, U&gt;(lhs: T, _ rhs: U) -&gt; Bool<br>&gt;     where T : SequenceType,<br>&gt;           U : SequenceType,<br>&gt;           T.Generator.Element: Equatable,<br>&gt;           T.Generator.Element == U.Generator.Element<br>&gt; {<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; That would make the definition look closer to what the call site looks like.<br>&gt; <br>&gt; The same would work for generic types  too:<br>&gt; <br>&gt; public struct Dictionary&lt;Key, Value&gt;<br>&gt;     where Key : Hashable<br>&gt; {<br>&gt;    ...<br>&gt; }<br>&gt; <br>&gt; — Pyry<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/1aa79cd7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>April  6, 2016 at 03:00:00pm</p></header><div class="content"><p>Even better.  +1.<br></p><p>~Robert Widmann<br></p><p>2016/04/06 14:35、Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt;&gt; On 06 Apr 2016, at 21:30, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If you&#39;ve ever gotten to the point where you have a sufficiently generic interface to a thing and you need to constrain it, possibly in an extension, maybe for a generic free function or operator, you know what a pain the syntax can be for these kinds of operations.<br>&gt; <br>&gt; +1 already!<br>&gt; <br>&gt;&gt; Or, if you&#39;re feeling ambitious, even<br>&gt;&gt; <br>&gt;&gt; func anyCommonElements &lt;T, U&gt;<br>&gt;&gt; where T : SequenceType, U : SequenceType,<br>&gt;&gt; T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt;&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; <br>&gt; I would actually move them as far as after everything else, and right before the definition body. For the above function that would mean:<br>&gt; <br>&gt; func anyCommonElements&lt;T, U&gt;(lhs: T, _ rhs: U) -&gt; Bool<br>&gt;     where T : SequenceType,<br>&gt;           U : SequenceType,<br>&gt;           T.Generator.Element: Equatable,<br>&gt;           T.Generator.Element == U.Generator.Element<br>&gt; {<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; That would make the definition look closer to what the call site looks like.<br>&gt; <br>&gt; The same would work for generic types  too:<br>&gt; <br>&gt; public struct Dictionary&lt;Key, Value&gt;<br>&gt;     where Key : Hashable<br>&gt; {<br>&gt;    ...<br>&gt; }<br>&gt; <br>&gt; ― Pyry<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/ba18724f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  6, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; I would actually move them as far as after everything else, and right before the definition body. For the above function that would mean:<br>&gt; <br>&gt; func anyCommonElements&lt;T, U&gt;(lhs: T, _ rhs: U) -&gt; Bool<br>&gt;     where T : SequenceType,<br>&gt;           U : SequenceType,<br>&gt;           T.Generator.Element: Equatable,<br>&gt;           T.Generator.Element == U.Generator.Element<br>&gt; {<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; That would make the definition look closer to what the call site looks like.<br>&gt; <br>&gt; The same would work for generic types  too:<br>&gt; <br>&gt; public struct Dictionary&lt;Key, Value&gt;<br>&gt;     where Key : Hashable<br>&gt; {<br>&gt;    ...<br>&gt; }<br></p><p>Another nice thing about this style is that, in principle, I think it could be extended to specify requirements on non-type parameter values.<br></p><p>	func ..&lt; &lt;Element: Incrementable&gt;(lhs: Element, rhs: Element) -&gt; Range&lt;Element&gt;<br>		where Element: Comparable, lhs &lt;= rhs {<br>		…<br>	}<br></p><p>I&#39;m not saying we must or even should include that feature, merely that it gives us a nice syntactic slot to use if we choose to do so later.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>April  7, 2016 at 01:00:00am</p></header><div class="content"><p>I&#39;m hoping this extends to type values.<br></p><p>struct StructWithClosure<br>{<br>   let closure : (lhs: Element, rhs:Element) -&gt; Range&lt;Element&gt; where<br>Element : Incrementable, Comparable<br>}<br></p><p>or for that matter, protocol values:<br></p><p>struct StructWithIntCollectionType<br>{<br>    let collection : C where C : CollectionType, C.Element == Int<br>}<br></p><p><br>On Thu, Apr 7, 2016 at 1:13 AM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; I would actually move them as far as after everything else, and right<br>&gt; before the definition body. For the above function that would mean:<br>&gt; &gt;<br>&gt; &gt; func anyCommonElements&lt;T, U&gt;(lhs: T, _ rhs: U) -&gt; Bool<br>&gt; &gt;     where T : SequenceType,<br>&gt; &gt;           U : SequenceType,<br>&gt; &gt;           T.Generator.Element: Equatable,<br>&gt; &gt;           T.Generator.Element == U.Generator.Element<br>&gt; &gt; {<br>&gt; &gt;     ...<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; That would make the definition look closer to what the call site looks<br>&gt; like.<br>&gt; &gt;<br>&gt; &gt; The same would work for generic types  too:<br>&gt; &gt;<br>&gt; &gt; public struct Dictionary&lt;Key, Value&gt;<br>&gt; &gt;     where Key : Hashable<br>&gt; &gt; {<br>&gt; &gt;    ...<br>&gt; &gt; }<br>&gt;<br>&gt; Another nice thing about this style is that, in principle, I think it<br>&gt; could be extended to specify requirements on non-type parameter values.<br>&gt;<br>&gt;         func ..&lt; &lt;Element: Incrementable&gt;(lhs: Element, rhs: Element) -&gt;<br>&gt; Range&lt;Element&gt;<br>&gt;                 where Element: Comparable, lhs &lt;= rhs {<br>&gt;                 …<br>&gt;         }<br>&gt;<br>&gt; I&#39;m not saying we must or even should include that feature, merely that it<br>&gt; gives us a nice syntactic slot to use if we choose to do so later.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/805e0959/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>April  6, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>On Apr 6, 2016, at 7:13 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; I would actually move them as far as after everything else, and right before the definition body. For the above function that would mean:<br>&gt;&gt; <br>&gt;&gt; func anyCommonElements&lt;T, U&gt;(lhs: T, _ rhs: U) -&gt; Bool<br>&gt;&gt;    where T : SequenceType,<br>&gt;&gt;          U : SequenceType,<br>&gt;&gt;          T.Generator.Element: Equatable,<br>&gt;&gt;          T.Generator.Element == U.Generator.Element<br>&gt;&gt; {<br>&gt;&gt;    ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; That would make the definition look closer to what the call site looks like.<br>&gt;&gt; <br>&gt;&gt; The same would work for generic types  too:<br>&gt;&gt; <br>&gt;&gt; public struct Dictionary&lt;Key, Value&gt;<br>&gt;&gt;    where Key : Hashable<br>&gt;&gt; {<br>&gt;&gt;   ...<br>&gt;&gt; }<br>&gt; <br>&gt; Another nice thing about this style is that, in principle, I think it could be extended to specify requirements on non-type parameter values.<br>&gt; <br>&gt;    func ..&lt; &lt;Element: Incrementable&gt;(lhs: Element, rhs: Element) -&gt; Range&lt;Element&gt;<br>&gt;        where Element: Comparable, lhs &lt;= rhs {<br>&gt;        …<br>&gt;    }<br>&gt; <br>&gt; I&#39;m not saying we must or even should include that feature, merely that it gives us a nice syntactic slot to use if we choose to do so later.<br></p><p>I know you&#39;re not proposing that feature right now, but want to understand how you expect it to work.  It looks to me like this starts to enter design by contract territory.  Would the predicate behave as if it was part of a precondition?<br></p><p>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April  7, 2016 at 10:00:00am</p></header><div class="content"><p>I like the idea, I find the beginning of a declaration too cluttered and it<br>obscures the main purpose. Like Brent I am wary of the design by contract<br>(DBC) bit, `lhs &lt;= rhs`. DBC is probably for a separate discussion, but<br>moving the where clause would probably help.<br></p><p>  -- Howard.<br></p><p>On 7 April 2016 at 10:36, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Apr 6, 2016, at 7:13 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; I would actually move them as far as after everything else, and right<br>&gt; before the definition body. For the above function that would mean:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func anyCommonElements&lt;T, U&gt;(lhs: T, _ rhs: U) -&gt; Bool<br>&gt; &gt;&gt;    where T : SequenceType,<br>&gt; &gt;&gt;          U : SequenceType,<br>&gt; &gt;&gt;          T.Generator.Element: Equatable,<br>&gt; &gt;&gt;          T.Generator.Element == U.Generator.Element<br>&gt; &gt;&gt; {<br>&gt; &gt;&gt;    ...<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; That would make the definition look closer to what the call site looks<br>&gt; like.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The same would work for generic types  too:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; public struct Dictionary&lt;Key, Value&gt;<br>&gt; &gt;&gt;    where Key : Hashable<br>&gt; &gt;&gt; {<br>&gt; &gt;&gt;   ...<br>&gt; &gt;&gt; }<br>&gt; &gt;<br>&gt; &gt; Another nice thing about this style is that, in principle, I think it<br>&gt; could be extended to specify requirements on non-type parameter values.<br>&gt; &gt;<br>&gt; &gt;    func ..&lt; &lt;Element: Incrementable&gt;(lhs: Element, rhs: Element) -&gt;<br>&gt; Range&lt;Element&gt;<br>&gt; &gt;        where Element: Comparable, lhs &lt;= rhs {<br>&gt; &gt;        …<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; I&#39;m not saying we must or even should include that feature, merely that<br>&gt; it gives us a nice syntactic slot to use if we choose to do so later.<br>&gt;<br>&gt; I know you&#39;re not proposing that feature right now, but want to understand<br>&gt; how you expect it to work.  It looks to me like this starts to enter design<br>&gt; by contract territory.  Would the predicate behave as if it was part of a<br>&gt; precondition?<br>&gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/2a023da2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  6, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; I know you&#39;re not proposing that feature right now, but want to understand how you expect it to work.  It looks to me like this starts to enter design by contract territory.  Would the predicate behave as if it was part of a precondition?<br></p><p>I suppose I imagine it as equivalent to a precondition() placed at the call site, rather than inside the function. If the compiler can prove that the precondition will be violated, it can refuse to compile the call. But I haven&#39;t thought deeply about it, so I don&#39;t really know for sure.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>April  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 17:13, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Another nice thing about this style is that, in principle, I think it could be extended to specify requirements on non-type parameter values.<br></p><p>I had this thought too.  The possibilities that this syntax change suggests for compile time evaluation are very interesting, in my opinion.<br></p><p>-Matt<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April  7, 2016 at 12:00:00pm</p></header><div class="content"><p>I quite like this variation, so I’m a +1 for that.<br></p><p>However, I think this would be greatly helped if we could define protocol generics more like type generics like so:<br></p><p>	protocol Foo&lt;Element&gt; { … }<br>	func anyStringFoo(lhs:Foo&lt;String&gt;) { … }<br></p><p>But yeah, for the more complicated cases, it makes a lot of sense to relocate the where clause away from the main signature. I’d maybe still allow declarations of type though like-so:<br></p><p>	func anyCommonElements&lt;T:SequenceType, U:SequenceType&gt;(lhs:T, _ rhs:U) -&gt; Bool<br>		where T.Generator.Element:Equatable, T.Generator.Element == U.Generator.Element<br></p><p>Perhaps allowing us the choice of doing it this way at least.<br></p><p>&gt; On 6 Apr 2016, at 19:35, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On 06 Apr 2016, at 21:30, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If you&#39;ve ever gotten to the point where you have a sufficiently generic interface to a thing and you need to constrain it, possibly in an extension, maybe for a generic free function or operator, you know what a pain the syntax can be for these kinds of operations.<br>&gt; <br>&gt; +1 already!<br>&gt; <br>&gt;&gt; Or, if you&#39;re feeling ambitious, even<br>&gt;&gt; <br>&gt;&gt; func anyCommonElements &lt;T, U&gt;<br>&gt;&gt; where T : SequenceType, U : SequenceType,<br>&gt;&gt; T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt;&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; <br>&gt; I would actually move them as far as after everything else, and right before the definition body. For the above function that would mean:<br>&gt; <br>&gt; func anyCommonElements&lt;T, U&gt;(lhs: T, _ rhs: U) -&gt; Bool<br>&gt;     where T : SequenceType,<br>&gt;           U : SequenceType,<br>&gt;           T.Generator.Element: Equatable,<br>&gt;           T.Generator.Element == U.Generator.Element<br>&gt; {<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; That would make the definition look closer to what the call site looks like.<br>&gt; <br>&gt; The same would work for generic types  too:<br>&gt; <br>&gt; public struct Dictionary&lt;Key, Value&gt;<br>&gt;     where Key : Hashable<br>&gt; {<br>&gt;    ...<br>&gt; }<br>&gt; <br>&gt; — Pyry<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/c83104bb/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>April  6, 2016 at 01:00:00pm</p></header><div class="content"><p>*grabs paintbrush*<br></p><p>Something that has always bothered me about the generic syntax for functions is how far the function’s name is from its parameters. There are probably reasons why the following might not work, but it could address my desire to keep the name of the thing close to the names of the inputs:<br></p><p>func &lt;T: SequenceType, U: SequenceType&gt;<br>where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>anyCommonElements(lhs: T, _ rhs: U) -&gt; Bool {<br>}<br></p><p>I haven&#39;t given this tons of thought, but this seemed like a good a thread as any to mention my concern about the distance of the name from the parameters. :)<br></p><p>l8r<br>Sean<br></p><p><br></p><p>&gt; where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt; (lhs: T, _ rhs: U) -&gt; Bool<br></p><p><br></p><p>&gt; On Apr 6, 2016, at 1:30 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If you&#39;ve ever gotten to the point where you have a sufficiently generic interface to a thing and you need to constrain it, possibly in an extension, maybe for a generic free function or operator, you know what a pain the syntax can be for these kinds of operations.  For example, the Swift book implements this example to motivate where clauses<br>&gt; <br>&gt; func anyCommonElements &lt;T: SequenceType, U: SequenceType where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; <br>&gt; This is noisy and uncomfortable to my eyes, and almost impossible to align correctly.  Per a short discussion on Twitter with Joe Groff and Erica Sadun, I&#39;d like so see what the community feels about moving the where clause out of the angle brackets.  So that example becomes<br>&gt; <br>&gt; func anyCommonElements &lt;T: SequenceType, U: SequenceType&gt;<br>&gt; where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; <br>&gt; Or, if you&#39;re feeling ambitious, even<br>&gt; <br>&gt; func anyCommonElements &lt;T, U&gt;<br>&gt; where T : SequenceType, U : SequenceType,<br>&gt; T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  6, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 12:30 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If you&#39;ve ever gotten to the point where you have a sufficiently generic interface to a thing and you need to constrain it, possibly in an extension, maybe for a generic free function or operator, you know what a pain the syntax can be for these kinds of operations.  For example, the Swift book implements this example to motivate where clauses<br>&gt; <br>&gt; This is noisy and uncomfortable to my eyes, and almost impossible to align correctly.  Per a short discussion on Twitter with Joe Groff and Erica Sadun, I&#39;d like so see what the community feels about moving the where clause out of the angle brackets.  So that example becomes<br>&gt; <br>&gt; Thoughts?<br></p><p>+1.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/317a7943/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April  6, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 11:30 AM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If you&#39;ve ever gotten to the point where you have a sufficiently generic interface to a thing and you need to constrain it, possibly in an extension, maybe for a generic free function or operator, you know what a pain the syntax can be for these kinds of operations.  For example, the Swift book implements this example to motivate where clauses<br>&gt; <br>&gt; func anyCommonElements &lt;T: SequenceType, U: SequenceType where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; <br>&gt; This is noisy and uncomfortable to my eyes, and almost impossible to align correctly.  Per a short discussion on Twitter with Joe Groff and Erica Sadun, I&#39;d like so see what the community feels about moving the where clause out of the angle brackets.  So that example becomes<br>&gt; <br>&gt; func anyCommonElements &lt;T: SequenceType, U: SequenceType&gt;<br>&gt; where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; <br>&gt; Or, if you&#39;re feeling ambitious, even<br>&gt; <br>&gt; func anyCommonElements &lt;T, U&gt;<br>&gt; where T : SequenceType, U : SequenceType,<br>&gt; T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; <br>&gt; Thoughts?<br></p><p>I think this is a good idea, though I would put the `where` clause after the function signature:<br></p><p>func foo&lt;T: Foo, U: Bar&gt;(x: T, y: U) -&gt; Result&lt;T,U&gt;<br>    where T.Foo == U.Bar /*, etc. */<br>{<br>}<br></p><p> As others noted, it&#39;s also appealing to do this for type declarations too:<br></p><p>struct Foo&lt;T: Foo, U: Bar&gt;<br>    where T.Foo == U.Bar<br>{<br>}<br></p><p>and that gives a consistent feeling with extensions and protocol declarations.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>April  6, 2016 at 10:00:00pm</p></header><div class="content"><p>Joe,<br></p><p>Just from your experience on this topic, is there any reason not to also move the primary constraints into the trailing `where` clause?<br></p><p>So instead of what you wrote, we&#39;d have it this way:<br></p><p>    func foo&lt;T, U&gt;(x: T, y: U) -&gt; Result&lt;T,U&gt;<br>       where T: Foo, U: Bar, T.Foo == U.Bar /*, etc. */<br>    {<br>    }<br></p><p>…as well as:<br></p><p>    struct Foo&lt;T, U&gt;<br>       where T: Foo, U: Bar, T.Foo == U.Bar<br>    {<br>    }<br></p><p>Like I said earlier in this thread, I think this would also make the `extension` syntax more uniform with types (by turning generic parameters into strictly locally visible things):<br></p><p>    extension Foo&lt;T, U&gt; where U == Baz { // (Could&#39;ve used X and Y here as well.)<br>        // Now it&#39;s clear where the names T and U come from.<br>        var bazzes: [U] { return ... }<br>    }<br></p><p>— Pyry<br></p><p>&gt; I think this is a good idea, though I would put the `where` clause after the function signature:<br>&gt; <br>&gt; func foo&lt;T: Foo, U: Bar&gt;(x: T, y: U) -&gt; Result&lt;T,U&gt;<br>&gt;    where T.Foo == U.Bar /*, etc. */<br>&gt; {<br>&gt; }<br>&gt; <br>&gt; As others noted, it&#39;s also appealing to do this for type declarations too:<br>&gt; <br>&gt; struct Foo&lt;T: Foo, U: Bar&gt;<br>&gt;    where T.Foo == U.Bar<br>&gt; {<br>&gt; }<br>&gt; <br>&gt; and that gives a consistent feeling with extensions and protocol declarations.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/4e7010d7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April  6, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 12:52 PM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br>&gt; <br>&gt; Joe,<br>&gt; <br>&gt; Just from your experience on this topic, is there any reason not to also move the primary constraints into the trailing `where` clause?<br>&gt; <br>&gt; So instead of what you wrote, we&#39;d have it this way:<br>&gt; <br>&gt;     func foo&lt;T, U&gt;(x: T, y: U) -&gt; Result&lt;T,U&gt;<br>&gt;        where T: Foo, U: Bar, T.Foo == U.Bar /*, etc. */<br>&gt;     {<br>&gt;     }<br>&gt; <br>&gt; …as well as:<br>&gt; <br>&gt;     struct Foo&lt;T, U&gt;<br>&gt;        where T: Foo, U: Bar, T.Foo == U.Bar<br>&gt;     {<br>&gt;     }<br>&gt; <br>&gt; Like I said earlier in this thread, I think this would also make the `extension` syntax more uniform with types (by turning generic parameters into strictly locally visible things):<br>&gt; <br>&gt;     extension Foo&lt;T, U&gt; where U == Baz { // (Could&#39;ve used X and Y here as well.)<br>&gt;         // Now it&#39;s clear where the names T and U come from.<br>&gt;         var bazzes: [U] { return ... }<br>&gt;     }<br></p><p>It&#39;s a judgment call. It&#39;s my feeling that in many cases, a generic parameter is constrained by at least one important protocol or base class that&#39;s worth calling out up front, so it&#39;s reasonable to allow things like &#39;func foo&lt;C: Collection&gt;(x: C) -&gt; C.Element&#39; without banishing the &#39;Collection&#39; constraint too far from the front of the declaration.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>April  6, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Joe Groff wrote:<br>&gt; <br>&gt; It&#39;s a judgment call. It&#39;s my feeling that in many cases, a generic parameter is constrained by at least one important protocol or base class that&#39;s worth calling out up front, so it&#39;s reasonable to allow things like &#39;func foo&lt;C: Collection&gt;(x: C) -&gt; C.Element&#39; without banishing the &#39;Collection&#39; constraint too far from the front of the declaration.<br></p><p>Fair enough. I think it would be clearer if all the constraints appeared in one standard place (in the `where` clause).<br></p><p>— Pyry<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/c04fbe5a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>April  6, 2016 at 08:00:00pm</p></header><div class="content"><p>I think the where clause should be moved to the end as you outlined an any<br>constraints beyond simple statements of conformance to a protocol or<br>superclass should only be allowed in the where clause. If someone desires<br>to state simple conformance/superclass for a generic parameter they should<br>be allowed to do so in either location.<br></p><p>On Wed, Apr 6, 2016 at 1:21 PM Pyry Jahkola via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Joe Groff wrote:<br>&gt;<br>&gt;<br>&gt; It&#39;s a judgment call. It&#39;s my feeling that in many cases, a generic<br>&gt; parameter is constrained by at least one important protocol or base class<br>&gt; that&#39;s worth calling out up front, so it&#39;s reasonable to allow things like<br>&gt; &#39;func foo&lt;C: Collection&gt;(x: C) -&gt; C.Element&#39; without banishing the<br>&gt; &#39;Collection&#39; constraint too far from the front of the declaration.<br>&gt;<br>&gt;<br>&gt; Fair enough. I think it would be clearer if all the constraints appeared<br>&gt; in one standard place (in the `where` clause).<br>&gt;<br>&gt; — Pyry<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/da860bff/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April  6, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 1:21 PM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br>&gt; <br>&gt;&gt; Joe Groff wrote:<br>&gt;&gt; <br>&gt;&gt; It&#39;s a judgment call. It&#39;s my feeling that in many cases, a generic parameter is constrained by at least one important protocol or base class that&#39;s worth calling out up front, so it&#39;s reasonable to allow things like &#39;func foo&lt;C: Collection&gt;(x: C) -&gt; C.Element&#39; without banishing the &#39;Collection&#39; constraint too far from the front of the declaration.<br>&gt; <br>&gt; Fair enough. I think it would be clearer if all the constraints appeared in one standard place (in the `where` clause).<br></p><p>That&#39;s definitely a reasonable position worth discussing.<br></p><p>-Joe<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  6, 2016 at 02:00:00pm</p></header><div class="content"><p>On Apr 6, 2016, at 2:03 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Apr 6, 2016, at 12:52 PM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Joe,<br>&gt;&gt; <br>&gt;&gt; Just from your experience on this topic, is there any reason not to also move the primary constraints into the trailing `where` clause?<br>&gt; It&#39;s a judgment call. It&#39;s my feeling that in many cases, a generic parameter is constrained by at least one important protocol or base class that&#39;s worth calling out up front, so it&#39;s reasonable to allow things like &#39;func foo&lt;C: Collection&gt;(x: C) -&gt; C.Element&#39; without banishing the &#39;Collection&#39; constraint too far from the front of the declaration.<br></p><p>From a reading point of view, it&#39;s always better to declare tokens before using them. This groups them with the parameters (and the parameters in turn may use the tokens), so the scope-specific vocabulary is all laid out in front.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/549c0a10/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>April  6, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Le 6 avr. 2016 à 16:03, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 6, 2016, at 12:52 PM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Joe,<br>&gt;&gt; <br>&gt;&gt; Just from your experience on this topic, is there any reason not to also move the primary constraints into the trailing `where` clause?<br>&gt;&gt; <br>&gt;&gt; So instead of what you wrote, we&#39;d have it this way:<br>&gt;&gt; <br>&gt;&gt;    func foo&lt;T, U&gt;(x: T, y: U) -&gt; Result&lt;T,U&gt;<br>&gt;&gt;       where T: Foo, U: Bar, T.Foo == U.Bar /*, etc. */<br>&gt;&gt;    {<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; …as well as:<br>&gt;&gt; <br>&gt;&gt;    struct Foo&lt;T, U&gt;<br>&gt;&gt;       where T: Foo, U: Bar, T.Foo == U.Bar<br>&gt;&gt;    {<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; Like I said earlier in this thread, I think this would also make the `extension` syntax more uniform with types (by turning generic parameters into strictly locally visible things):<br>&gt;&gt; <br>&gt;&gt;    extension Foo&lt;T, U&gt; where U == Baz { // (Could&#39;ve used X and Y here as well.)<br>&gt;&gt;        // Now it&#39;s clear where the names T and U come from.<br>&gt;&gt;        var bazzes: [U] { return ... }<br>&gt;&gt;    }<br>&gt; <br>&gt; It&#39;s a judgment call. It&#39;s my feeling that in many cases, a generic parameter is constrained by at least one important protocol or base class that&#39;s worth calling out up front, so it&#39;s reasonable to allow things like &#39;func foo&lt;C: Collection&gt;(x: C) -&gt; C.Element&#39; without banishing the &#39;Collection&#39; constraint too far from the front of the declaration.<br>&gt; <br></p><p>I&#39;m with Joe here on not banning it. Having the key constraint up front seems make it easier to grasp the goal of the generic function with a quick glance.<br></p><p>Flexibility around the constraint already exist, as one can currently write:<br></p><p>func foo&lt;C where C: Collection&gt;(x: C) -&gt; C.Element<br></p><p>But probably few do so (maybe just because it&#39;s longer to type)<br></p><p>Dany<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>April  6, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 1:36 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think this is a good idea, though I would put the `where` clause after the function signature:<br>&gt; <br>&gt; func foo&lt;T: Foo, U: Bar&gt;(x: T, y: U) -&gt; Result&lt;T,U&gt;<br>&gt;    where T.Foo == U.Bar /*, etc. */<br>&gt; {<br>&gt; }<br></p><p>A bit of a meta-argument:<br></p><p>It is very common to use single-capital letter generic parameters, and the API style does not give guidance around the naming of generic parameters.<br></p><p>However in my humble-but-opinionated view, they are effectively scope-bound, dynamic type aliases. Declaring func &quot;foo&lt;T&gt;&quot; is like declaring “var i”, but its forgiven since coming up with a good, concise name for such a type alias can be hard.<br></p><p>The standard library seems inconsistent about this as well:<br></p><p>func == &lt;A : Equatable, B : Equatable&gt;(_: (A, B), rhs: (A, B))<br></p><p>vs.<br></p><p>func == &lt;Key : Equatable, Value : Equatable&gt;(_: [Key : Value], rhs: [Key : Value])<br></p><p>The argument I bring up is that naming of the generic parameters may wind up affecting whether the code is clearer having type constraints and the where clause within the brackets or trailing the function. It is important to take this into account and compare both apples to apples and oranges to oranges when evaluating syntax.<br></p><p>(or, change the API guide and standard library to discourage either apples or oranges)<br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/63c35202/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/63c35202/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  6, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 5:45 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 6, 2016, at 1:36 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think this is a good idea, though I would put the `where` clause after the function signature:<br>&gt;&gt; <br>&gt;&gt; func foo&lt;T: Foo, U: Bar&gt;(x: T, y: U) -&gt; Result&lt;T,U&gt;<br>&gt;&gt;    where T.Foo == U.Bar /*, etc. */<br>&gt;&gt; {<br>&gt;&gt; }<br>&gt; <br>&gt; A bit of a meta-argument:<br>&gt; <br>&gt; It is very common to use single-capital letter generic parameters, and the API style does not give guidance around the naming of generic parameters.<br>&gt; <br>&gt; However in my humble-but-opinionated view, they are effectively scope-bound, dynamic type aliases. Declaring func &quot;foo&lt;T&gt;&quot; is like declaring “var i”, but its forgiven since coming up with a good, concise name for such a type alias can be hard.<br>&gt; <br>&gt; The standard library seems inconsistent about this as well:<br>&gt; <br>&gt; func == &lt;A : Equatable, B : Equatable&gt;(_: (A, B), rhs: (A, B))<br>&gt; <br>&gt; vs.<br>&gt; <br>&gt; func == &lt;Key : Equatable, Value : Equatable&gt;(_: [Key : Value], rhs: [Key : Value])<br>&gt; <br>&gt; The argument I bring up is that naming of the generic parameters may wind up affecting whether the code is clearer having type constraints and the where clause within the brackets or trailing the function. It is important to take this into account and compare both apples to apples and oranges to oranges when evaluating syntax.<br>&gt; <br>&gt; (or, change the API guide and standard library to discourage either apples or oranges)<br>&gt; <br>&gt; -DW<br></p><p>I&#39;ll keep this short. IMO:<br></p><p>* Dictionaries have semantics, so Key/Value makes sense.<br>* Truly &quot;generic&quot; equatable values do not, so A and B are simple stand-ins.<br>* Always prefer named tokens when there are actual semantics (Element, Wrapped, etc). <br></p><p>This may or may not be appropriate for inclusion in the API guidelines.<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/80fa6fbd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>April  6, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 16:52, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Apr 6, 2016, at 5:45 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 6, 2016, at 1:36 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this is a good idea, though I would put the `where` clause after the function signature:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo&lt;T: Foo, U: Bar&gt;(x: T, y: U) -&gt; Result&lt;T,U&gt;<br>&gt;&gt;&gt;    where T.Foo == U.Bar /*, etc. */<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; A bit of a meta-argument:<br>&gt;&gt; <br>&gt;&gt; It is very common to use single-capital letter generic parameters, and the API style does not give guidance around the naming of generic parameters.<br>&gt;&gt; <br>&gt;&gt; However in my humble-but-opinionated view, they are effectively scope-bound, dynamic type aliases. Declaring func &quot;foo&lt;T&gt;&quot; is like declaring “var i”, but its forgiven since coming up with a good, concise name for such a type alias can be hard.<br>&gt;&gt; <br>&gt;&gt; The standard library seems inconsistent about this as well:<br>&gt;&gt; <br>&gt;&gt; func == &lt;A : Equatable, B : Equatable&gt;(_: (A, B), rhs: (A, B))<br>&gt;&gt; <br>&gt;&gt; vs.<br>&gt;&gt; <br>&gt;&gt; func == &lt;Key : Equatable, Value : Equatable&gt;(_: [Key : Value], rhs: [Key : Value])<br>&gt;&gt; <br>&gt;&gt; The argument I bring up is that naming of the generic parameters may wind up affecting whether the code is clearer having type constraints and the where clause within the brackets or trailing the function. It is important to take this into account and compare both apples to apples and oranges to oranges when evaluating syntax.<br>&gt;&gt; <br>&gt;&gt; (or, change the API guide and standard library to discourage either apples or oranges)<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt; <br>&gt; I&#39;ll keep this short. IMO:<br>&gt; <br>&gt; * Dictionaries have semantics, so Key/Value makes sense.<br>&gt; * Truly &quot;generic&quot; equatable values do not, so A and B are simple stand-ins.<br>&gt; * Always prefer named tokens when there are actual semantics (Element, Wrapped, etc). <br>&gt; <br>&gt; This may or may not be appropriate for inclusion in the API guidelines.<br></p><p>Another factor here is that we&#39;ve been planning for a while for generic parameters to types to be exposed as implicit member typealiases, since they already conflict with the namespace for member typealiases. Therefore it&#39;s important to name generic parameters to types well, but less important to do so for generic parameters for functions. (They&#39;re also much less likely to be ad hoc for types; there has to be something that describes the relation between the Self type and the parameter, while the function might not have anything more interesting than &quot;operand&quot;.)<br></p><p>This is also a minor point against declaring generic parameters for extensions, since they would have to match up. We also do need a syntax some day to represent new parameters:<br></p><p>// For expository purposes only:<br>extension &lt;T&gt; Array where Element == Optional&lt;T&gt;<br></p><p>But that deserves its own proposal. I just don&#39;t want us to paint ourselves into a corner.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/837bc021/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>April  7, 2016 at 11:00:00am</p></header><div class="content"><p>Jordan,<br></p><p>Your comments brought up a few more closely related ideas that have been bubbling under.<br></p><p>To everyone,<br></p><p>Sorry for going beyond topic here. The discussion of the further proposals below should be taken into their own threads if there&#39;s interest. I&#39;m just trying to motivate what else moving out the `where` clause would make possible.<br></p><p>1. My counter-proposal against making generic parameters public<br></p><p>&gt; Another factor here is that we&#39;ve been planning for a while for generic parameters to types to be exposed as implicit member typealiases, since they already conflict with the namespace for member typealiases. Therefore it&#39;s important to name generic parameters to types well, but less important to do so for generic parameters for functions. (They&#39;re also much less likely to be ad hoc for types; there has to be something that describes the relation between the Self type and the parameter, while the function might not have anything more interesting than &quot;operand&quot;.)<br></p><p>I disagree with that. I think it&#39;s more natural to restrict generic type parameters to the immediate local scope of the class/struct/enum definition or extension, and simply allow making the type public with `typealias`. For example, this would make `Element` a public member of `Array`:<br></p><p>    public enum Result&lt;T, Error&gt; {<br>        public typealias Value = T // This makes `Value` public for extensions and everyone<br>    }<br></p><p>I would even allow publishing the otherwise local name by repeating it in `typealias` like this:<br></p><p>    public struct Array&lt;Element&gt; { // This `Element` is only available in (the missing) where clause and the scope below.<br>        public typealias Element = Element // This line makes `Element` available everywhere, see below.<br>    }<br></p><p>    extension Array&lt;T&gt; { // &lt;- Regardless of the pattern (`T`) used here,<br>        var mid: Element? { // the type `Element = T` is available here<br>            return ...      // because it was made public elsewhere.<br>        }<br>    }<br>    extension Array&lt;Optional&lt;T&gt;&gt; { // &lt;- An example of pattern matching (see further below).<br>        // Ditto, `Element = T?`<br>    }<br></p><p>    typealias Ints = [Int]<br>    let x: Ints.Element = ... // Int<br></p><p>Next, I propose how to extend this syntax with pattern matching. The above thinking is a natural progression from the use of pattern matching for introducing generic type parameters in type `extension`s.<br></p><p><br>2. Proposal to enable pattern matching of generic types in generic parameters<br></p><p>&gt; This is also a minor point against declaring generic parameters for extensions, since they would have to match up. We also do need a syntax some day to represent new parameters:<br>&gt; <br>&gt; // For expository purposes only:<br>&gt; extension &lt;T&gt; Array where Element == Optional&lt;T&gt;<br>&gt; <br>&gt; But that deserves its own proposal. I just don&#39;t want us to paint ourselves into a corner.<br></p><p>I agree that we need that feature. But instead of your proposed syntax, I&#39;d take influence from the already existing pattern matching that we have at value level, such that:<br></p><p>1. any generic type expressions within the angle brackets `&lt;...&gt;` are taken as patterns to match against  (e.g. `Array&lt;Element&gt;`, `Optional&lt;Foo&gt;`, `Dictionary&lt;S, S&gt;`), and<br>2. all non-generic type identifiers in those expressions are taken as generic parameters and not concrete types (`Element`, `Foo`, or `S`, respectively).<br></p><p>Your example would translate into the first of these two:<br></p><p>    extension Array&lt;Optional&lt;T&gt;&gt; { // extending [T?] doesn&#39;t even need any `where` clause<br>        func unwrapAll() -&gt; [T] { ... }<br>    }<br></p><p>    extension Dictionary&lt;K, Dictionary&lt;K, V&gt;&gt; { // This pattern match requires the same `K` twice.<br>        subscript(x: K, y: K) -&gt; V { ... }<br>    }<br></p><p>The generic parameters would shadow any existing names in the outer scope, i.e. `extension Array&lt;String&gt;` would mean the same as `extension Array&lt;Element&gt;`. But it would be a good idea to add a warning (or linter error) at least when stdlib types such as `Swift.String` are shadowed like that. I think the benefits from pattern matching outweigh the possible confusion, especially since you can&#39;t use any members of `String` if you mistakenly wrote `extension Array&lt;String&gt; { ... }` instead of `extension Array&lt;T&gt; where T == String`.<br></p><p>With this syntax, we could also allow extending Array, Dictionary, and Optional in their more natural notation:<br></p><p>    extension [T?] {<br>        func unwrapAll() -&gt; [T] { /* ... */ }<br>    }<br></p><p>    extension [K: [K: V]] {<br>        subscript(x: K, y: K) -&gt; V { /* ... */ }<br>    }<br></p><p>Here are a few more (somewhat realistically needed) examples with further `where` clauses:<br></p><p>    extension [T] where T : Hashable { /* ... */ }<br>    extension T? where T : Comparable { /* ... */ }<br>    extension [K: V] where V : Equatable { /* ... */ }<br>    extension [T] where T == String { /* ... */ }<br></p><p>I think pattern matching is a very expressive, intuitive, and readable technique that works quite well for this purpose, better than what we currently have.<br></p><p><br>3. Future directions<br></p><p>Brent already pointed out that the `where` constraint syntax could be used for dependent types (i.e. type-level values as generic parameters). Four more possible directions come to my mind:<br></p><p>(1) Adding conditional protocol conformances:<br></p><p>    extension [T]: Equatable where T : Equatable { /* ... */ }<br>    extension [T]: Comparable where T : Comparable { /* ... */ }<br>    extension [K, V]: Equatable where V : Equatable { /* ... */ }<br>    extension Foo&lt;X, Bar&lt;Y&gt;&gt; : Bazzable where X : Baz, Y : Baz { /* ... */ }<br></p><p>(2) Extending non-nominal types:<br></p><p>    extension (A, B) { var tail: B { /* ... */ }}<br>    extension (A, B, C) { var tail: (B, C) { /* ... */ }}<br></p><p>(3) Using variadic patterns (shamefully borrowing the `...` notation from C++ here to mean an arbitrary-length list of patterns to match or expressions to expand):<br></p><p>    extension (T...) : Equatable where T : Equatable... {}<br></p><p>    func == &lt;T...&gt;(lhs: (T...), rhs: (T...)) -&gt; Bool where T : Equatable... { /* ... */ }<br></p><p>(4) Since all type constraints with `:` fly out to of the generic parameter list into the `where` clause, we could enable the use of colons to give labels to generic parameters (and thus even make some of them have default values):<br></p><p>    struct Parser&lt;encoding: Encoding, input: Input&gt;<br>        where Encoding : EncodingProtocol /*, ... */<br>    {<br>        // ...<br>    }<br></p><p>    let parser = Parser&lt;encoding: UTF8, input: String&gt;()<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/dd845200/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April  7, 2016 at 01:00:00pm</p></header><div class="content"><p>These are fantastic proposals! With these in place, there would be precious little to envy Haskell. <br></p><p>For example, regarding “counter-proposal against making generic parameters public”, the current behaviour of Swift is essentially a bug, as reported by Noah Blake (https://bugs.swift.org/browse/SR-1065 &lt;https://bugs.swift.org/browse/SR-1065&gt;).<br></p><p>Then there is:<br></p><p>&gt; (3) Using variadic patterns (shamefully borrowing the `...` notation from C++ here to mean an arbitrary-length list of patterns to match or expressions to expand):<br>&gt; <br>&gt;     extension (T...) : Equatable where T : Equatable... {}<br>&gt; <br>&gt;     func == &lt;T...&gt;(lhs: (T...), rhs: (T...)) -&gt; Bool where T : Equatable... { /* ... */ }<br></p><p><br>Not only that this would make certain Standard Library signatures less embarrassing, but would enable entirely new programming patterns. For example, the size of a fixed-length sequence could be type guaranteed like so:<br></p><p>    let v = Vector&lt;_2,_0,_1,_6&gt;(repeatedValue: 42)<br>    v.count // 2016<br></p><p>… wehere types like _2 and _6 may be caseless enums:<br></p><p>    enum _2 : DecimalDigitType { }<br></p><p>milos<br></p><p>&gt; On 7 Apr 2016, at 09:44, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Jordan,<br>&gt; <br>&gt; Your comments brought up a few more closely related ideas that have been bubbling under.<br>&gt; <br>&gt; To everyone,<br>&gt; <br>&gt; Sorry for going beyond topic here. The discussion of the further proposals below should be taken into their own threads if there&#39;s interest. I&#39;m just trying to motivate what else moving out the `where` clause would make possible.<br>&gt; <br>&gt; 1. My counter-proposal against making generic parameters public<br>&gt; <br>&gt;&gt; Another factor here is that we&#39;ve been planning for a while for generic parameters to types to be exposed as implicit member typealiases, since they already conflict with the namespace for member typealiases. Therefore it&#39;s important to name generic parameters to types well, but less important to do so for generic parameters for functions. (They&#39;re also much less likely to be ad hoc for types; there has to be something that describes the relation between the Self type and the parameter, while the function might not have anything more interesting than &quot;operand&quot;.)<br>&gt; <br>&gt; I disagree with that. I think it&#39;s more natural to restrict generic type parameters to the immediate local scope of the class/struct/enum definition or extension, and simply allow making the type public with `typealias`. For example, this would make `Element` a public member of `Array`:<br>&gt; <br>&gt;     public enum Result&lt;T, Error&gt; {<br>&gt;         public typealias Value = T // This makes `Value` public for extensions and everyone<br>&gt;     }<br>&gt; <br>&gt; I would even allow publishing the otherwise local name by repeating it in `typealias` like this:<br>&gt; <br>&gt;     public struct Array&lt;Element&gt; { // This `Element` is only available in (the missing) where clause and the scope below.<br>&gt;         public typealias Element = Element // This line makes `Element` available everywhere, see below.<br>&gt;     }<br>&gt; <br>&gt;     extension Array&lt;T&gt; { // &lt;- Regardless of the pattern (`T`) used here,<br>&gt;         var mid: Element? { // the type `Element = T` is available here<br>&gt;             return ...      // because it was made public elsewhere.<br>&gt;         }<br>&gt;     }<br>&gt;     extension Array&lt;Optional&lt;T&gt;&gt; { // &lt;- An example of pattern matching (see further below).<br>&gt;         // Ditto, `Element = T?`<br>&gt;     }<br>&gt; <br>&gt;     typealias Ints = [Int]<br>&gt;     let x: Ints.Element = ... // Int<br>&gt; <br>&gt; Next, I propose how to extend this syntax with pattern matching. The above thinking is a natural progression from the use of pattern matching for introducing generic type parameters in type `extension`s.<br>&gt; <br>&gt; <br>&gt; 2. Proposal to enable pattern matching of generic types in generic parameters<br>&gt; <br>&gt;&gt; This is also a minor point against declaring generic parameters for extensions, since they would have to match up. We also do need a syntax some day to represent new parameters:<br>&gt;&gt; <br>&gt;&gt; // For expository purposes only:<br>&gt;&gt; extension &lt;T&gt; Array where Element == Optional&lt;T&gt;<br>&gt;&gt; <br>&gt;&gt; But that deserves its own proposal. I just don&#39;t want us to paint ourselves into a corner.<br>&gt; <br>&gt; I agree that we need that feature. But instead of your proposed syntax, I&#39;d take influence from the already existing pattern matching that we have at value level, such that:<br>&gt; <br>&gt; 1. any generic type expressions within the angle brackets `&lt;...&gt;` are taken as patterns to match against  (e.g. `Array&lt;Element&gt;`, `Optional&lt;Foo&gt;`, `Dictionary&lt;S, S&gt;`), and<br>&gt; 2. all non-generic type identifiers in those expressions are taken as generic parameters and not concrete types (`Element`, `Foo`, or `S`, respectively).<br>&gt; <br>&gt; Your example would translate into the first of these two:<br>&gt; <br>&gt;     extension Array&lt;Optional&lt;T&gt;&gt; { // extending [T?] doesn&#39;t even need any `where` clause<br>&gt;         func unwrapAll() -&gt; [T] { ... }<br>&gt;     }<br>&gt; <br>&gt;     extension Dictionary&lt;K, Dictionary&lt;K, V&gt;&gt; { // This pattern match requires the same `K` twice.<br>&gt;         subscript(x: K, y: K) -&gt; V { ... }<br>&gt;     }<br>&gt; <br>&gt; The generic parameters would shadow any existing names in the outer scope, i.e. `extension Array&lt;String&gt;` would mean the same as `extension Array&lt;Element&gt;`. But it would be a good idea to add a warning (or linter error) at least when stdlib types such as `Swift.String` are shadowed like that. I think the benefits from pattern matching outweigh the possible confusion, especially since you can&#39;t use any members of `String` if you mistakenly wrote `extension Array&lt;String&gt; { ... }` instead of `extension Array&lt;T&gt; where T == String`.<br>&gt; <br>&gt; With this syntax, we could also allow extending Array, Dictionary, and Optional in their more natural notation:<br>&gt; <br>&gt;     extension [T?] {<br>&gt;         func unwrapAll() -&gt; [T] { /* ... */ }<br>&gt;     }<br>&gt; <br>&gt;     extension [K: [K: V]] {<br>&gt;         subscript(x: K, y: K) -&gt; V { /* ... */ }<br>&gt;     }<br>&gt; <br>&gt; Here are a few more (somewhat realistically needed) examples with further `where` clauses:<br>&gt; <br>&gt;     extension [T] where T : Hashable { /* ... */ }<br>&gt;     extension T? where T : Comparable { /* ... */ }<br>&gt;     extension [K: V] where V : Equatable { /* ... */ }<br>&gt;     extension [T] where T == String { /* ... */ }<br>&gt; <br>&gt; I think pattern matching is a very expressive, intuitive, and readable technique that works quite well for this purpose, better than what we currently have.<br>&gt; <br>&gt; <br>&gt; 3. Future directions<br>&gt; <br>&gt; Brent already pointed out that the `where` constraint syntax could be used for dependent types (i.e. type-level values as generic parameters). Four more possible directions come to my mind:<br>&gt; <br>&gt; (1) Adding conditional protocol conformances:<br>&gt; <br>&gt;     extension [T]: Equatable where T : Equatable { /* ... */ }<br>&gt;     extension [T]: Comparable where T : Comparable { /* ... */ }<br>&gt;     extension [K, V]: Equatable where V : Equatable { /* ... */ }<br>&gt;     extension Foo&lt;X, Bar&lt;Y&gt;&gt; : Bazzable where X : Baz, Y : Baz { /* ... */ }<br>&gt; <br>&gt; (2) Extending non-nominal types:<br>&gt; <br>&gt;     extension (A, B) { var tail: B { /* ... */ }}<br>&gt;     extension (A, B, C) { var tail: (B, C) { /* ... */ }}<br>&gt; <br>&gt; (3) Using variadic patterns (shamefully borrowing the `...` notation from C++ here to mean an arbitrary-length list of patterns to match or expressions to expand):<br>&gt; <br>&gt;     extension (T...) : Equatable where T : Equatable... {}<br>&gt; <br>&gt;     func == &lt;T...&gt;(lhs: (T...), rhs: (T...)) -&gt; Bool where T : Equatable... { /* ... */ }<br>&gt; <br>&gt; (4) Since all type constraints with `:` fly out to of the generic parameter list into the `where` clause, we could enable the use of colons to give labels to generic parameters (and thus even make some of them have default values):<br>&gt; <br>&gt;     struct Parser&lt;encoding: Encoding, input: Input&gt;<br>&gt;         where Encoding : EncodingProtocol /*, ... */<br>&gt;     {<br>&gt;         // ...<br>&gt;     }<br>&gt; <br>&gt;     let parser = Parser&lt;encoding: UTF8, input: String&gt;()<br>&gt; <br>&gt; — Pyry<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/8e4665da/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>April 29, 2016 at 04:00:00pm</p></header><div class="content"><p>+1 I almost fully agree with all your points. However I disagree with your first point:<br></p><p>What do you mean by: &quot;I think it&#39;s more natural to restrict generic type parameters to the immediate local scope&quot;<br></p><p>To me it feels like an &quot;associated type&quot; so it should be almost equally exposed in comparison to &quot;associatedtype&quot; of a protocol<br></p><p>Kind regards<br>- Maximilian<br></p><p>&gt; Am 07.04.2016 um 10:44 schrieb Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Jordan,<br>&gt; <br>&gt; Your comments brought up a few more closely related ideas that have been bubbling under.<br>&gt; <br>&gt; To everyone,<br>&gt; <br>&gt; Sorry for going beyond topic here. The discussion of the further proposals below should be taken into their own threads if there&#39;s interest. I&#39;m just trying to motivate what else moving out the `where` clause would make possible.<br>&gt; <br>&gt; 1. My counter-proposal against making generic parameters public<br>&gt; <br>&gt;&gt; Another factor here is that we&#39;ve been planning for a while for generic parameters to types to be exposed as implicit member typealiases, since they already conflict with the namespace for member typealiases. Therefore it&#39;s important to name generic parameters to types well, but less important to do so for generic parameters for functions. (They&#39;re also much less likely to be ad hoc for types; there has to be something that describes the relation between the Self type and the parameter, while the function might not have anything more interesting than &quot;operand&quot;.)<br>&gt; <br>&gt; I disagree with that. I think it&#39;s more natural to restrict generic type parameters to the immediate local scope of the class/struct/enum definition or extension, and simply allow making the type public with `typealias`. For example, this would make `Element` a public member of `Array`:<br>&gt; <br>&gt;     public enum Result&lt;T, Error&gt; {<br>&gt;         public typealias Value = T // This makes `Value` public for extensions and everyone<br>&gt;     }<br>&gt; <br>&gt; I would even allow publishing the otherwise local name by repeating it in `typealias` like this:<br>&gt; <br>&gt;     public struct Array&lt;Element&gt; { // This `Element` is only available in (the missing) where clause and the scope below.<br>&gt;         public typealias Element = Element // This line makes `Element` available everywhere, see below.<br>&gt;     }<br>&gt; <br>&gt;     extension Array&lt;T&gt; { // &lt;- Regardless of the pattern (`T`) used here,<br>&gt;         var mid: Element? { // the type `Element = T` is available here<br>&gt;             return ...      // because it was made public elsewhere.<br>&gt;         }<br>&gt;     }<br>&gt;     extension Array&lt;Optional&lt;T&gt;&gt; { // &lt;- An example of pattern matching (see further below).<br>&gt;         // Ditto, `Element = T?`<br>&gt;     }<br>&gt; <br>&gt;     typealias Ints = [Int]<br>&gt;     let x: Ints.Element = ... // Int<br>&gt; <br>&gt; Next, I propose how to extend this syntax with pattern matching. The above thinking is a natural progression from the use of pattern matching for introducing generic type parameters in type `extension`s.<br>&gt; <br>&gt; <br>&gt; 2. Proposal to enable pattern matching of generic types in generic parameters<br>&gt; <br>&gt;&gt; This is also a minor point against declaring generic parameters for extensions, since they would have to match up. We also do need a syntax some day to represent new parameters:<br>&gt;&gt; <br>&gt;&gt; // For expository purposes only:<br>&gt;&gt; extension &lt;T&gt; Array where Element == Optional&lt;T&gt;<br>&gt;&gt; <br>&gt;&gt; But that deserves its own proposal. I just don&#39;t want us to paint ourselves into a corner.<br>&gt; <br>&gt; I agree that we need that feature. But instead of your proposed syntax, I&#39;d take influence from the already existing pattern matching that we have at value level, such that:<br>&gt; <br>&gt; 1. any generic type expressions within the angle brackets `&lt;...&gt;` are taken as patterns to match against  (e.g. `Array&lt;Element&gt;`, `Optional&lt;Foo&gt;`, `Dictionary&lt;S, S&gt;`), and<br>&gt; 2. all non-generic type identifiers in those expressions are taken as generic parameters and not concrete types (`Element`, `Foo`, or `S`, respectively).<br>&gt; <br>&gt; Your example would translate into the first of these two:<br>&gt; <br>&gt;     extension Array&lt;Optional&lt;T&gt;&gt; { // extending [T?] doesn&#39;t even need any `where` clause<br>&gt;         func unwrapAll() -&gt; [T] { ... }<br>&gt;     }<br>&gt; <br>&gt;     extension Dictionary&lt;K, Dictionary&lt;K, V&gt;&gt; { // This pattern match requires the same `K` twice.<br>&gt;         subscript(x: K, y: K) -&gt; V { ... }<br>&gt;     }<br>&gt; <br>&gt; The generic parameters would shadow any existing names in the outer scope, i.e. `extension Array&lt;String&gt;` would mean the same as `extension Array&lt;Element&gt;`. But it would be a good idea to add a warning (or linter error) at least when stdlib types such as `Swift.String` are shadowed like that. I think the benefits from pattern matching outweigh the possible confusion, especially since you can&#39;t use any members of `String` if you mistakenly wrote `extension Array&lt;String&gt; { ... }` instead of `extension Array&lt;T&gt; where T == String`.<br>&gt; <br>&gt; With this syntax, we could also allow extending Array, Dictionary, and Optional in their more natural notation:<br>&gt; <br>&gt;     extension [T?] {<br>&gt;         func unwrapAll() -&gt; [T] { /* ... */ }<br>&gt;     }<br>&gt; <br>&gt;     extension [K: [K: V]] {<br>&gt;         subscript(x: K, y: K) -&gt; V { /* ... */ }<br>&gt;     }<br>&gt; <br>&gt; Here are a few more (somewhat realistically needed) examples with further `where` clauses:<br>&gt; <br>&gt;     extension [T] where T : Hashable { /* ... */ }<br>&gt;     extension T? where T : Comparable { /* ... */ }<br>&gt;     extension [K: V] where V : Equatable { /* ... */ }<br>&gt;     extension [T] where T == String { /* ... */ }<br>&gt; <br>&gt; I think pattern matching is a very expressive, intuitive, and readable technique that works quite well for this purpose, better than what we currently have.<br>&gt; <br>&gt; <br>&gt; 3. Future directions<br>&gt; <br>&gt; Brent already pointed out that the `where` constraint syntax could be used for dependent types (i.e. type-level values as generic parameters). Four more possible directions come to my mind:<br>&gt; <br>&gt; (1) Adding conditional protocol conformances:<br>&gt; <br>&gt;     extension [T]: Equatable where T : Equatable { /* ... */ }<br>&gt;     extension [T]: Comparable where T : Comparable { /* ... */ }<br>&gt;     extension [K, V]: Equatable where V : Equatable { /* ... */ }<br>&gt;     extension Foo&lt;X, Bar&lt;Y&gt;&gt; : Bazzable where X : Baz, Y : Baz { /* ... */ }<br>&gt; <br>&gt; (2) Extending non-nominal types:<br>&gt; <br>&gt;     extension (A, B) { var tail: B { /* ... */ }}<br>&gt;     extension (A, B, C) { var tail: (B, C) { /* ... */ }}<br>&gt; <br>&gt; (3) Using variadic patterns (shamefully borrowing the `...` notation from C++ here to mean an arbitrary-length list of patterns to match or expressions to expand):<br>&gt; <br>&gt;     extension (T...) : Equatable where T : Equatable... {}<br>&gt; <br>&gt;     func == &lt;T...&gt;(lhs: (T...), rhs: (T...)) -&gt; Bool where T : Equatable... { /* ... */ }<br>&gt; <br>&gt; (4) Since all type constraints with `:` fly out to of the generic parameter list into the `where` clause, we could enable the use of colons to give labels to generic parameters (and thus even make some of them have default values):<br>&gt; <br>&gt;     struct Parser&lt;encoding: Encoding, input: Input&gt;<br>&gt;         where Encoding : EncodingProtocol /*, ... */<br>&gt;     {<br>&gt;         // ...<br>&gt;     }<br>&gt; <br>&gt;     let parser = Parser&lt;encoding: UTF8, input: String&gt;()<br>&gt; <br>&gt; — Pyry<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/1064efa6/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>April  7, 2016 at 01:00:00am</p></header><div class="content"><p>It&#39;s probably appropriate. Given that, in this example, Bar implicitly<br>unifies its generic constraint T with Foo&#39;s associatedtype T (or,<br>typealiases T with T), you need to be at least a little careful how you<br>name your generic constraints.<br></p><p>protocol Foo<br>{<br>    associatedtype T<br>}<br></p><p>struct&lt;T&gt; Bar : Foo<br>{<br>}<br></p><p>On Thu, Apr 7, 2016 at 12:52 AM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Apr 6, 2016, at 5:45 PM, David Waite via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Apr 6, 2016, at 1:36 PM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I think this is a good idea, though I would put the `where` clause after<br>&gt; the function signature:<br>&gt;<br>&gt; func foo&lt;T: Foo, U: Bar&gt;(x: T, y: U) -&gt; Result&lt;T,U&gt;<br>&gt;    where T.Foo == U.Bar /*, etc. */<br>&gt; {<br>&gt; }<br>&gt;<br>&gt;<br>&gt; A bit of a meta-argument:<br>&gt;<br>&gt; It is very common to use single-capital letter generic parameters, and the<br>&gt; API style does not give guidance around the naming of generic parameters.<br>&gt;<br>&gt; However in my humble-but-opinionated view, they are effectively<br>&gt; scope-bound, dynamic type aliases. Declaring func &quot;foo&lt;T&gt;&quot; is like<br>&gt; declaring “var i”, but its forgiven since coming up with a good, concise<br>&gt; name for such a type alias can be hard.<br>&gt;<br>&gt; The standard library seems inconsistent about this as well:<br>&gt;<br>&gt; func == &lt;A : Equatable, B : Equatable&gt;(_: (A, B), rhs: (A, B))<br>&gt;<br>&gt; vs.<br>&gt;<br>&gt; func == &lt;Key : Equatable, Value : Equatable&gt;(_: [Key : Value], rhs: [Key :<br>&gt; Value])<br>&gt;<br>&gt; The argument I bring up is that naming of the generic parameters may wind<br>&gt; up affecting whether the code is clearer having type constraints and the<br>&gt; where clause within the brackets or trailing the function. It is important<br>&gt; to take this into account and compare both apples to apples and oranges to<br>&gt; oranges when evaluating syntax.<br>&gt;<br>&gt; (or, change the API guide and standard library to discourage either apples<br>&gt; or oranges)<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt;<br>&gt; I&#39;ll keep this short. IMO:<br>&gt;<br>&gt; * Dictionaries have semantics, so Key/Value makes sense.<br>&gt; * Truly &quot;generic&quot; equatable values do not, so A and B are simple stand-ins.<br>&gt; * Always prefer named tokens when there are actual semantics (Element,<br>&gt; Wrapped, etc).<br>&gt;<br>&gt; This may or may not be appropriate for inclusion in the API guidelines.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/7aeaa1c0/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>April  6, 2016 at 07:00:00pm</p></header><div class="content"><p>+1 to moving the `where` clause after the function signature.<br></p><p>-Matt<br></p><p>&gt; On Apr 6, 2016, at 12:36, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 6, 2016, at 11:30 AM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If you&#39;ve ever gotten to the point where you have a sufficiently generic interface to a thing and you need to constrain it, possibly in an extension, maybe for a generic free function or operator, you know what a pain the syntax can be for these kinds of operations.  For example, the Swift book implements this example to motivate where clauses<br>&gt;&gt; <br>&gt;&gt; func anyCommonElements &lt;T: SequenceType, U: SequenceType where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; This is noisy and uncomfortable to my eyes, and almost impossible to align correctly.  Per a short discussion on Twitter with Joe Groff and Erica Sadun, I&#39;d like so see what the community feels about moving the where clause out of the angle brackets.  So that example becomes<br>&gt;&gt; <br>&gt;&gt; func anyCommonElements &lt;T: SequenceType, U: SequenceType&gt;<br>&gt;&gt; where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt;&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; Or, if you&#39;re feeling ambitious, even<br>&gt;&gt; <br>&gt;&gt; func anyCommonElements &lt;T, U&gt;<br>&gt;&gt; where T : SequenceType, U : SequenceType,<br>&gt;&gt; T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt;&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt; <br>&gt; I think this is a good idea, though I would put the `where` clause after the function signature:<br>&gt; <br>&gt; func foo&lt;T: Foo, U: Bar&gt;(x: T, y: U) -&gt; Result&lt;T,U&gt;<br>&gt;    where T.Foo == U.Bar /*, etc. */<br>&gt; {<br>&gt; }<br>&gt; <br>&gt; As others noted, it&#39;s also appealing to do this for type declarations too:<br>&gt; <br>&gt; struct Foo&lt;T: Foo, U: Bar&gt;<br>&gt;    where T.Foo == U.Bar<br>&gt; {<br>&gt; }<br>&gt; <br>&gt; and that gives a consistent feeling with extensions and protocol declarations.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>April  6, 2016 at 10:00:00pm</p></header><div class="content"><p>Another +1 to `where` at the end.<br></p><p>On Wed, Apr 6, 2016 at 10:33 PM, Matt Whiteside via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 to moving the `where` clause after the function signature.<br>&gt;<br>&gt; -Matt<br>&gt;<br>&gt; &gt; On Apr 6, 2016, at 12:36, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Apr 6, 2016, at 11:30 AM, Developer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; If you&#39;ve ever gotten to the point where you have a sufficiently<br>&gt; generic interface to a thing and you need to constrain it, possibly in an<br>&gt; extension, maybe for a generic free function or operator, you know what a<br>&gt; pain the syntax can be for these kinds of operations.  For example, the<br>&gt; Swift book implements this example to motivate where clauses<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func anyCommonElements &lt;T: SequenceType, U: SequenceType where<br>&gt; T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt;<br>&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This is noisy and uncomfortable to my eyes, and almost impossible to<br>&gt; align correctly.  Per a short discussion on Twitter with Joe Groff and<br>&gt; Erica Sadun, I&#39;d like so see what the community feels about moving the<br>&gt; where clause out of the angle brackets.  So that example becomes<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func anyCommonElements &lt;T: SequenceType, U: SequenceType&gt;<br>&gt; &gt;&gt; where T.Generator.Element: Equatable, T.Generator.Element ==<br>&gt; U.Generator.Element<br>&gt; &gt;&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Or, if you&#39;re feeling ambitious, even<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func anyCommonElements &lt;T, U&gt;<br>&gt; &gt;&gt; where T : SequenceType, U : SequenceType,<br>&gt; &gt;&gt; T.Generator.Element: Equatable, T.Generator.Element ==<br>&gt; U.Generator.Element<br>&gt; &gt;&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thoughts?<br>&gt; &gt;<br>&gt; &gt; I think this is a good idea, though I would put the `where` clause after<br>&gt; the function signature:<br>&gt; &gt;<br>&gt; &gt; func foo&lt;T: Foo, U: Bar&gt;(x: T, y: U) -&gt; Result&lt;T,U&gt;<br>&gt; &gt;    where T.Foo == U.Bar /*, etc. */<br>&gt; &gt; {<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; As others noted, it&#39;s also appealing to do this for type declarations<br>&gt; too:<br>&gt; &gt;<br>&gt; &gt; struct Foo&lt;T: Foo, U: Bar&gt;<br>&gt; &gt;    where T.Foo == U.Bar<br>&gt; &gt; {<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; and that gives a consistent feeling with extensions and protocol<br>&gt; declarations.<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/c72bd6be/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>April  6, 2016 at 02:00:00pm</p></header><div class="content"><p>I don’t see much value in moving them out of the angle brackets but preserving the position; consider:<br></p><p>  // status-quo:<br>  func anyCommonElements &lt;T: SequenceType, U: SequenceType<br>    where <br>    T.Generator.Element: Equatable, <br>    T.Generator.Element == U.Generator.Element&gt; <br>    (lhs: T, _ rhs: U) -&gt; Bool<br>  <br>  // as-per proposal:<br>  func anyCommonElements &lt;T: SequenceType, U: SequenceType&gt;<br>    where <br>    T.Generator.Element: Equatable, <br>    T.Generator.Element == U.Generator.Element<br>    (lhs: T, _ rhs: U) -&gt; Bool<br></p><p>…not very different! Or, if you want it with fewer lines:<br></p><p>  // status-quo:<br>  func anyCommonElements &lt;T: SequenceType, U: SequenceType<br>    where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt; <br>    (lhs: T, _ rhs: U) -&gt; Bool<br>  <br>  // as-per proposal:<br>  func anyCommonElements &lt;T: SequenceType, U: SequenceType&gt;<br>    where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>    (lhs: T, _ rhs: U) -&gt; Bool<br></p><p>…still not very different!<br></p><p>Moving the `where` to come after “everything else&quot; seems like an improvement for functions:<br></p><p>  func anyCommonElements &lt;T: SequenceType, U: SequenceType&gt;(lhs: T, _ rhs: U) -&gt; Bool<br>    where <br>    T.Generator.Element: Equatable, <br>    T.Generator.Element == U.Generator.Element { <br>  // body here...<br>}<br></p><p>…and presumably-also for type declarations:<br></p><p>  class SomeClass&lt;A,B,C,D,E&gt; : BaseClass, SomeProtocol, AnotherProtocol<br>    where<br>    A.Something == SomethingElse,<br>    B.Input == C.Output {<br></p><p>  }<br></p><p>..,but would take some getting-used-to.<br></p><p>Losing the ability to write `:` constraints inline in the brackets seems a non-starter, but perhaps constraints within the brackets could be limited to `:` constraints?<br></p><p>&gt; On Apr 6, 2016, at 1:30 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If you&#39;ve ever gotten to the point where you have a sufficiently generic interface to a thing and you need to constrain it, possibly in an extension, maybe for a generic free function or operator, you know what a pain the syntax can be for these kinds of operations.  For example, the Swift book implements this example to motivate where clauses<br>&gt; <br>&gt; func anyCommonElements &lt;T: SequenceType, U: SequenceType where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; <br>&gt; This is noisy and uncomfortable to my eyes, and almost impossible to align correctly.  Per a short discussion on Twitter with Joe Groff and Erica Sadun, I&#39;d like so see what the community feels about moving the where clause out of the angle brackets.  So that example becomes<br>&gt; <br>&gt; func anyCommonElements &lt;T: SequenceType, U: SequenceType&gt;<br>&gt; where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; <br>&gt; Or, if you&#39;re feeling ambitious, even<br>&gt; <br>&gt; func anyCommonElements &lt;T, U&gt;<br>&gt; where T : SequenceType, U : SequenceType,<br>&gt; T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April  7, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 11:30 AM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If you&#39;ve ever gotten to the point where you have a sufficiently generic interface to a thing and you need to constrain it, possibly in an extension, maybe for a generic free function or operator, you know what a pain the syntax can be for these kinds of operations.  For example, the Swift book implements this example to motivate where clauses<br>&gt; <br>&gt; func anyCommonElements &lt;T: SequenceType, U: SequenceType where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; <br>&gt; This is noisy and uncomfortable to my eyes, and almost impossible to align correctly.  Per a short discussion on Twitter with Joe Groff and Erica Sadun, I&#39;d like so see what the community feels about moving the where clause out of the angle brackets.  So that example becomes<br>&gt; <br>&gt; func anyCommonElements &lt;T: SequenceType, U: SequenceType&gt;<br>&gt; where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; <br>&gt; Or, if you&#39;re feeling ambitious, even<br>&gt; <br>&gt; func anyCommonElements &lt;T, U&gt;<br>&gt; where T : SequenceType, U : SequenceType,<br>&gt; T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; <br>&gt; Thoughts?<br></p><p>+1, long overdue.  Please keep basic constraints (ones expressible without a ‘where’ clause, like simple conformances) inline though.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>April 29, 2016 at 04:00:00pm</p></header><div class="content"><p>What’s up with this great idea? Can’t see a proposal on swift-evolution anywhere.<br></p><p>&gt; On 08 Apr 2016, at 08:15, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 6, 2016, at 11:30 AM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If you&#39;ve ever gotten to the point where you have a sufficiently generic interface to a thing and you need to constrain it, possibly in an extension, maybe for a generic free function or operator, you know what a pain the syntax can be for these kinds of operations.  For example, the Swift book implements this example to motivate where clauses<br>&gt;&gt; <br>&gt;&gt; func anyCommonElements &lt;T: SequenceType, U: SequenceType where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; This is noisy and uncomfortable to my eyes, and almost impossible to align correctly.  Per a short discussion on Twitter with Joe Groff and Erica Sadun, I&#39;d like so see what the community feels about moving the where clause out of the angle brackets.  So that example becomes<br>&gt;&gt; <br>&gt;&gt; func anyCommonElements &lt;T: SequenceType, U: SequenceType&gt;<br>&gt;&gt; where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt;&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; Or, if you&#39;re feeling ambitious, even<br>&gt;&gt; <br>&gt;&gt; func anyCommonElements &lt;T, U&gt;<br>&gt;&gt; where T : SequenceType, U : SequenceType,<br>&gt;&gt; T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt;&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt; <br>&gt; +1, long overdue.  Please keep basic constraints (ones expressible without a ‘where’ clause, like simple conformances) inline though.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Moving where Clauses Out Of Parameter Lists</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 29, 2016 at 09:00:00am</p></header><div class="content"><p>This is one of those where I keep hoping someone will pick it up and get the proposal out there.<br></p><p>-- E<br></p><p>&gt; On Apr 29, 2016, at 8:57 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What’s up with this great idea? Can’t see a proposal on swift-evolution anywhere.<br>&gt; <br>&gt;&gt; On 08 Apr 2016, at 08:15, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 6, 2016, at 11:30 AM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you&#39;ve ever gotten to the point where you have a sufficiently generic interface to a thing and you need to constrain it, possibly in an extension, maybe for a generic free function or operator, you know what a pain the syntax can be for these kinds of operations.  For example, the Swift book implements this example to motivate where clauses<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func anyCommonElements &lt;T: SequenceType, U: SequenceType where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is noisy and uncomfortable to my eyes, and almost impossible to align correctly.  Per a short discussion on Twitter with Joe Groff and Erica Sadun, I&#39;d like so see what the community feels about moving the where clause out of the angle brackets.  So that example becomes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func anyCommonElements &lt;T: SequenceType, U: SequenceType&gt;<br>&gt;&gt;&gt; where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt;&gt;&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or, if you&#39;re feeling ambitious, even<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func anyCommonElements &lt;T, U&gt;<br>&gt;&gt;&gt; where T : SequenceType, U : SequenceType,<br>&gt;&gt;&gt; T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element<br>&gt;&gt;&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; +1, long overdue.  Please keep basic constraints (ones expressible without a ‘where’ clause, like simple conformances) inline though.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
