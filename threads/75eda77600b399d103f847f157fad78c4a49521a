<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 23, 2016 at 03:00:00am</p></header><div class="content"><p>If you&#39;ve written enums before, you&#39;ve no doubt noticed the irritating phenomenon of `switch self` being absolutely everywhere. I first discovered this in some of my very first Swift code, code so old we were still using the `T[]` shorthand syntax:<br></p><p>    enum Suit: Int {<br>        case Hearts, Spades, Diamonds, Clubs<br>        <br>        static var all: Suit[] { return [ Hearts, Spades, Diamonds, Clubs ] }<br>        <br>        var description: String {<br>            switch(self) {<br>            case .Hearts:<br>                return &quot;♥️&quot;<br>            case .Spades:<br>                return &quot;♠️&quot;<br>            case .Diamonds:<br>                return &quot;♦️&quot;<br>            case .Clubs:<br>                return &quot;♣️&quot;<br>            }<br>        }<br>        <br>        var isRed: Bool {<br>            switch(self) {<br>            case .Hearts, .Diamonds:<br>                return true<br>            case .Spades, .Clubs:<br>                return false<br>            }<br>        }<br>    }<br></p><p>It would be nice if we could somehow eliminate that. I have two suggestions:<br></p><p>* Implicitly switch on `self` at the top level of a function or accessor (or at least an enum one with top-level `case` statements).<br></p><p>    enum Suit: Int {<br>        case Hearts, Spades, Diamonds, Clubs<br>        <br>        static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>        <br>        var description: String {<br>        case .Hearts:<br>            return &quot;♥️&quot;<br>        case .Spades:<br>            return &quot;♠️&quot;<br>        case .Diamonds:<br>            return &quot;♦️&quot;<br>        case .Clubs:<br>            return &quot;♣️&quot;<br>        }<br>        <br>        var isRed: Bool {<br>        case .Hearts, .Diamonds:<br>            return true<br>        case .Spades, .Clubs:<br>            return false<br>        }<br>    }<br></p><p>* Allow you to attach member definitions to particular cases. It would be an error if they didn&#39;t all define the same members, unless there was a top-level catchall.<br></p><p>    enum Suit: Int {<br>        var isRed: Bool { return false }<br>        <br>        case Hearts {<br>            let description: String { return &quot;♥️&quot; }<br>            let isRed: Bool { return true }<br>        }<br>        case Spades {<br>            let description: String { return  &quot;♠️&quot; }<br>        }<br>        case Diamonds {<br>            let description: String { return  &quot;♦️&quot; }<br>            let isRed: Bool { return true }<br>        }<br>        case Clubs {<br>            let description: String { return  &quot;♣️&quot; }<br>        }<br>        <br>        static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>    }<br></p><p>Any thoughts? This has, to be honest, bothered me since approximately the third day I used the language; I&#39;d love to address it sooner or later.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6f9eea37d3dbcfd7a49b0369cf826bbd?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Scott Matthewman</string> &lt;scott at matthewman.net&gt;<p>March 23, 2016 at 11:00:00am</p></header><div class="content"><p>Looks like you’re coming close to @cjwirth’s approach of using a private<br>struct to represent the various combinations of values that a single enum<br>could represent:<br></p><p>http://cjwirth.com/2016/03/14/easier-enums/<br></p><p>It’s always tricky when coming up with generic and simple examples to<br>illustrate a pain point; I think in both your case and Caesar’s, enums’ switch<br>self is potentially liveable with.<br></p><p>When it gets to writing four or more for a single enum, the value object<br>approach has definite benefits – but it also feels as if it’s maybe a sign<br>that we’re leaning too heavily on the enum, and maybe there’s some other<br>amendments the problem’s object graph that may help.<br></p><p>—<br></p><p>Scott<br></p><p><br>On Wed, 23 Mar 2016 at 10:14 Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; If you&#39;ve written enums before, you&#39;ve no doubt noticed the irritating<br>&gt; phenomenon of `switch self` being absolutely everywhere. I first discovered<br>&gt; this in some of my very first Swift code, code so old we were still using<br>&gt; the `T[]` shorthand syntax:<br>&gt;<br>&gt;     enum Suit: Int {<br>&gt;         case Hearts, Spades, Diamonds, Clubs<br>&gt;<br>&gt;         static var all: Suit[] { return [ Hearts, Spades, Diamonds, Clubs<br>&gt; ] }<br>&gt;<br>&gt;         var description: String {<br>&gt;             switch(self) {<br>&gt;             case .Hearts:<br>&gt;                 return &quot;♥️&quot;<br>&gt;             case .Spades:<br>&gt;                 return &quot;♠️&quot;<br>&gt;             case .Diamonds:<br>&gt;                 return &quot;♦️&quot;<br>&gt;             case .Clubs:<br>&gt;                 return &quot;♣️&quot;<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt;         var isRed: Bool {<br>&gt;             switch(self) {<br>&gt;             case .Hearts, .Diamonds:<br>&gt;                 return true<br>&gt;             case .Spades, .Clubs:<br>&gt;                 return false<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt; It would be nice if we could somehow eliminate that. I have two<br>&gt; suggestions:<br>&gt;<br>&gt; * Implicitly switch on `self` at the top level of a function or accessor<br>&gt; (or at least an enum one with top-level `case` statements).<br>&gt;<br>&gt;     enum Suit: Int {<br>&gt;         case Hearts, Spades, Diamonds, Clubs<br>&gt;<br>&gt;         static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>&gt;<br>&gt;         var description: String {<br>&gt;         case .Hearts:<br>&gt;             return &quot;♥️&quot;<br>&gt;         case .Spades:<br>&gt;             return &quot;♠️&quot;<br>&gt;         case .Diamonds:<br>&gt;             return &quot;♦️&quot;<br>&gt;         case .Clubs:<br>&gt;             return &quot;♣️&quot;<br>&gt;         }<br>&gt;<br>&gt;         var isRed: Bool {<br>&gt;         case .Hearts, .Diamonds:<br>&gt;             return true<br>&gt;         case .Spades, .Clubs:<br>&gt;             return false<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt; * Allow you to attach member definitions to particular cases. It would be<br>&gt; an error if they didn&#39;t all define the same members, unless there was a<br>&gt; top-level catchall.<br>&gt;<br>&gt;     enum Suit: Int {<br>&gt;         var isRed: Bool { return false }<br>&gt;<br>&gt;         case Hearts {<br>&gt;             let description: String { return &quot;♥️&quot; }<br>&gt;             let isRed: Bool { return true }<br>&gt;         }<br>&gt;         case Spades {<br>&gt;             let description: String { return  &quot;♠️&quot; }<br>&gt;         }<br>&gt;         case Diamonds {<br>&gt;             let description: String { return  &quot;♦️&quot; }<br>&gt;             let isRed: Bool { return true }<br>&gt;         }<br>&gt;         case Clubs {<br>&gt;             let description: String { return  &quot;♣️&quot; }<br>&gt;         }<br>&gt;<br>&gt;         static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>&gt;     }<br>&gt;<br>&gt; Any thoughts? This has, to be honest, bothered me since approximately the<br>&gt; third day I used the language; I&#39;d love to address it sooner or later.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/08444640/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>March 23, 2016 at 12:00:00pm</p></header><div class="content"><p>I encountered the same issues and agree that it can be tedious to deal with enums.<br>Imho the first variant (skipping the switch(self) {} doesn&#39;t offer enough benefit to justify a special case.<br></p><p>The second is nice because it keeps the &quot;properties&quot; of each case together — but afaics, Swift doesn&#39;t use the model of case classes (like http://docs.scala-lang.org/tutorials/tour/case-classes.html) for its enums, so it is no good fit for the language (btw, shouldn&#39;t the cases be lower case?).<br></p><p>As &quot;isRed&quot; is declared as &quot;var&quot;, I would expect it can be changed, but it&#39;s redeclared &quot;let&quot; afterwards… maybe this could be simplified by using each case-block like an init-method:<br>   enum Suit: Int {<br>       let isRed: Bool<br></p><p>       case Hearts {<br>          isRed = true<br>       }<br>….<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 23, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; As &quot;isRed&quot; is declared as &quot;var&quot;, I would expect it can be changed, but it&#39;s redeclared &quot;let&quot; afterwards…<br></p><p>Sorry, that was a mistake on my part. I originally wrote all of the definitions as `let variable = value`, assuming Swift would optimize that into a single instance shared by all instances of a particular case. But upon further reflection I realized that this wouldn&#39;t work properly if the property returned an object, so I decided to change them to computed properties. When I did that, I forgot to change the `let`s to `var`s.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>March 23, 2016 at 01:00:00pm</p></header><div class="content"><p>Hi Brent,<br></p><p>First of all, I like your suggestions however there was already a proposal about &quot;Pattern matching partial functions&quot; which could address this and many other issues (See pull request #111; unfortunately the discussion doesn&#39;t went on... Hopefully this time).<br></p><p>This proposal addresses the issue of switch statements which return something in every &quot;case&quot;. It uses special closures as unapplied switch statements and uses a global &quot;match&quot; function:<br></p><p>func match&lt;T, U&gt;(value: T, closure: T -&gt; U) -&gt; U {<br>         return closure(value)<br>}<br></p><p>The case you describe could now be rewritten to:<br></p><p>// no returns<br>enum Suit: Int {<br>       case Hearts, Spades, Diamonds, Clubs<br></p><p>       static var all: Suit[] { return [ Hearts, Spades, Diamonds, Clubs ] }<br></p><p>       var description: String {<br>           return match(self) {<br>               case .Hearts: &quot;♥️&quot;<br>               case .Spades: &quot;♠️&quot;<br>               case .Diamonds: &quot;♦️&quot;<br>               case .Clubs: &quot;♣️&quot;<br>           }<br>       }<br></p><p>       var isRed: Bool {<br>           return match(self) {<br>               case .Hearts, .Diamonds: true<br>               case .Spades, .Clubs: false<br>           }<br>       }<br>   }<br></p><p>// or even without case (which was highly controversial in the discussions)<br>enum Suit: Int {<br>       case Hearts, Spades, Diamonds, Clubs<br></p><p>       static var all: Suit[] { return [ Hearts, Spades, Diamonds, Clubs ] }<br></p><p>       var description: String {<br>           return match(self) {<br>               cases .Hearts: &quot;♥️&quot;, .Spades: &quot;♠️&quot;, .Diamonds: &quot;♦️&quot;, .Clubs: &quot;♣️&quot;<br>           }<br>       }<br></p><p>       var isRed: Bool {<br>           return match(self) {<br>               cases .Hearts, .Diamonds: true, .Spades, .Clubs: false<br>           }<br>       }<br>   }<br></p><p>What do you think about this?<br></p><p>Kind regards<br>- Maximilian<br></p><p>&gt; Am 23.03.2016 um 11:13 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; If you&#39;ve written enums before, you&#39;ve no doubt noticed the irritating phenomenon of `switch self` being absolutely everywhere. I first discovered this in some of my very first Swift code, code so old we were still using the `T[]` shorthand syntax:<br>&gt; <br>&gt;    enum Suit: Int {<br>&gt;        case Hearts, Spades, Diamonds, Clubs<br>&gt; <br>&gt;        static var all: Suit[] { return [ Hearts, Spades, Diamonds, Clubs ] }<br>&gt; <br>&gt;        var description: String {<br>&gt;            switch(self) {<br>&gt;            case .Hearts:<br>&gt;                return &quot;♥️&quot;<br>&gt;            case .Spades:<br>&gt;                return &quot;♠️&quot;<br>&gt;            case .Diamonds:<br>&gt;                return &quot;♦️&quot;<br>&gt;            case .Clubs:<br>&gt;                return &quot;♣️&quot;<br>&gt;            }<br>&gt;        }<br>&gt; <br>&gt;        var isRed: Bool {<br>&gt;            switch(self) {<br>&gt;            case .Hearts, .Diamonds:<br>&gt;                return true<br>&gt;            case .Spades, .Clubs:<br>&gt;                return false<br>&gt;            }<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; It would be nice if we could somehow eliminate that. I have two suggestions:<br>&gt; <br>&gt; * Implicitly switch on `self` at the top level of a function or accessor (or at least an enum one with top-level `case` statements).<br>&gt; <br>&gt;    enum Suit: Int {<br>&gt;        case Hearts, Spades, Diamonds, Clubs<br>&gt; <br>&gt;        static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>&gt; <br>&gt;        var description: String {<br>&gt;        case .Hearts:<br>&gt;            return &quot;♥️&quot;<br>&gt;        case .Spades:<br>&gt;            return &quot;♠️&quot;<br>&gt;        case .Diamonds:<br>&gt;            return &quot;♦️&quot;<br>&gt;        case .Clubs:<br>&gt;            return &quot;♣️&quot;<br>&gt;        }<br>&gt; <br>&gt;        var isRed: Bool {<br>&gt;        case .Hearts, .Diamonds:<br>&gt;            return true<br>&gt;        case .Spades, .Clubs:<br>&gt;            return false<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; * Allow you to attach member definitions to particular cases. It would be an error if they didn&#39;t all define the same members, unless there was a top-level catchall.<br>&gt; <br>&gt;    enum Suit: Int {<br>&gt;        var isRed: Bool { return false }<br>&gt; <br>&gt;        case Hearts {<br>&gt;            let description: String { return &quot;♥️&quot; }<br>&gt;            let isRed: Bool { return true }<br>&gt;        }<br>&gt;        case Spades {<br>&gt;            let description: String { return  &quot;♠️&quot; }<br>&gt;        }<br>&gt;        case Diamonds {<br>&gt;            let description: String { return  &quot;♦️&quot; }<br>&gt;            let isRed: Bool { return true }<br>&gt;        }<br>&gt;        case Clubs {<br>&gt;            let description: String { return  &quot;♣️&quot; }<br>&gt;        }<br>&gt; <br>&gt;        static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>&gt;    }<br>&gt; Any thoughts? This has, to be honest, bothered me since approximately the third day I used the language; I&#39;d love to address it sooner or later.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/0ec2eced/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>March 23, 2016 at 06:00:00am</p></header><div class="content"><p>Thanx Maximillian for writing this, saved me from doing it and well put! :-)<br></p><p>- Paul<br>&gt; On Mar 23, 2016, at 5:46 AM, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Brent,<br>&gt; <br>&gt; First of all, I like your suggestions however there was already a proposal about &quot;Pattern matching partial functions&quot; which could address this and many other issues (See pull request #111; unfortunately the discussion doesn&#39;t went on... Hopefully this time).<br>&gt; <br>&gt; This proposal addresses the issue of switch statements which return something in every &quot;case&quot;. It uses special closures as unapplied switch statements and uses a global &quot;match&quot; function:<br>&gt; <br>&gt; func match&lt;T, U&gt;(value: T, closure: T -&gt; U) -&gt; U {<br>&gt;          return closure(value)<br>&gt; }<br>&gt; <br>&gt; The case you describe could now be rewritten to:<br>&gt; <br>&gt; // no returns<br>&gt; enum Suit: Int {<br>&gt;        case Hearts, Spades, Diamonds, Clubs<br>&gt; <br>&gt;        static var all: Suit[] { return [ Hearts, Spades, Diamonds, Clubs ] }<br>&gt; <br>&gt;        var description: String {<br>&gt;            return match(self) {<br>&gt;                case .Hearts: &quot;♥️&quot;<br>&gt;                case .Spades: &quot;♠️&quot;<br>&gt;                case .Diamonds: &quot;♦️&quot;<br>&gt;                case .Clubs: &quot;♣️&quot;<br>&gt;            }<br>&gt;        }<br>&gt; <br>&gt;        var isRed: Bool {<br>&gt;            return match(self) {<br>&gt;                case .Hearts, .Diamonds: true<br>&gt;                case .Spades, .Clubs: false<br>&gt;            }<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; // or even without case (which was highly controversial in the discussions)<br>&gt; enum Suit: Int {<br>&gt;        case Hearts, Spades, Diamonds, Clubs<br>&gt; <br>&gt;        static var all: Suit[] { return [ Hearts, Spades, Diamonds, Clubs ] }<br>&gt; <br>&gt;        var description: String {<br>&gt;            return match(self) {<br>&gt;                cases .Hearts: &quot;♥️&quot;, .Spades: &quot;♠️&quot;, .Diamonds: &quot;♦️&quot;, .Clubs: &quot;♣️&quot;<br>&gt;            }<br>&gt;        }<br>&gt; <br>&gt;        var isRed: Bool {<br>&gt;            return match(self) {<br>&gt;                cases .Hearts, .Diamonds: true, .Spades, .Clubs: false<br>&gt;            }<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; What do you think about this?<br>&gt; <br>&gt; Kind regards<br>&gt; - Maximilian<br>&gt; <br>&gt; Am 23.03.2016 um 11:13 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; If you&#39;ve written enums before, you&#39;ve no doubt noticed the irritating phenomenon of `switch self` being absolutely everywhere. I first discovered this in some of my very first Swift code, code so old we were still using the `T[]` shorthand syntax:<br>&gt;&gt; <br>&gt;&gt;    enum Suit: Int {<br>&gt;&gt;        case Hearts, Spades, Diamonds, Clubs<br>&gt;&gt; <br>&gt;&gt;        static var all: Suit[] { return [ Hearts, Spades, Diamonds, Clubs ] }<br>&gt;&gt; <br>&gt;&gt;        var description: String {<br>&gt;&gt;            switch(self) {<br>&gt;&gt;            case .Hearts:<br>&gt;&gt;                return &quot;♥️&quot;<br>&gt;&gt;            case .Spades:<br>&gt;&gt;                return &quot;♠️&quot;<br>&gt;&gt;            case .Diamonds:<br>&gt;&gt;                return &quot;♦️&quot;<br>&gt;&gt;            case .Clubs:<br>&gt;&gt;                return &quot;♣️&quot;<br>&gt;&gt;            }<br>&gt;&gt;        }<br>&gt;&gt; <br>&gt;&gt;        var isRed: Bool {<br>&gt;&gt;            switch(self) {<br>&gt;&gt;            case .Hearts, .Diamonds:<br>&gt;&gt;                return true<br>&gt;&gt;            case .Spades, .Clubs:<br>&gt;&gt;                return false<br>&gt;&gt;            }<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; It would be nice if we could somehow eliminate that. I have two suggestions:<br>&gt;&gt; <br>&gt;&gt; * Implicitly switch on `self` at the top level of a function or accessor (or at least an enum one with top-level `case` statements).<br>&gt;&gt; <br>&gt;&gt;    enum Suit: Int {<br>&gt;&gt;        case Hearts, Spades, Diamonds, Clubs<br>&gt;&gt; <br>&gt;&gt;        static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>&gt;&gt; <br>&gt;&gt;        var description: String {<br>&gt;&gt;        case .Hearts:<br>&gt;&gt;            return &quot;♥️&quot;<br>&gt;&gt;        case .Spades:<br>&gt;&gt;            return &quot;♠️&quot;<br>&gt;&gt;        case .Diamonds:<br>&gt;&gt;            return &quot;♦️&quot;<br>&gt;&gt;        case .Clubs:<br>&gt;&gt;            return &quot;♣️&quot;<br>&gt;&gt;        }<br>&gt;&gt; <br>&gt;&gt;        var isRed: Bool {<br>&gt;&gt;        case .Hearts, .Diamonds:<br>&gt;&gt;            return true<br>&gt;&gt;        case .Spades, .Clubs:<br>&gt;&gt;            return false<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; * Allow you to attach member definitions to particular cases. It would be an error if they didn&#39;t all define the same members, unless there was a top-level catchall.<br>&gt;&gt; <br>&gt;&gt;    enum Suit: Int {<br>&gt;&gt;        var isRed: Bool { return false }<br>&gt;&gt; <br>&gt;&gt;        case Hearts {<br>&gt;&gt;            let description: String { return &quot;♥️&quot; }<br>&gt;&gt;            let isRed: Bool { return true }<br>&gt;&gt;        }<br>&gt;&gt;        case Spades {<br>&gt;&gt;            let description: String { return  &quot;♠️&quot; }<br>&gt;&gt;        }<br>&gt;&gt;        case Diamonds {<br>&gt;&gt;            let description: String { return  &quot;♦️&quot; }<br>&gt;&gt;            let isRed: Bool { return true }<br>&gt;&gt;        }<br>&gt;&gt;        case Clubs {<br>&gt;&gt;            let description: String { return  &quot;♣️&quot; }<br>&gt;&gt;        }<br>&gt;&gt; <br>&gt;&gt;        static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>&gt;&gt;    }<br>&gt;&gt; Any thoughts? This has, to be honest, bothered me since approximately the third day I used the language; I&#39;d love to address it sooner or later.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/a2113e21/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 23, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; enum Suit: Int {<br>&gt;        case Hearts, Spades, Diamonds, Clubs<br>&gt; <br>&gt;        static var all: Suit[] { return [ Hearts, Spades, Diamonds, Clubs ] }<br>&gt; <br>&gt;        var description: String {<br>&gt;            return match(self) {<br>&gt;                case .Hearts: &quot;♥️&quot;<br>&gt;                case .Spades: &quot;♠️&quot;<br>&gt;                case .Diamonds: &quot;♦️&quot;<br>&gt;                case .Clubs: &quot;♣️&quot;<br>&gt;            }<br>&gt;        }<br>&gt; <br>&gt;        var isRed: Bool {<br>&gt;            return match(self) {<br>&gt;                case .Hearts, .Diamonds: true<br>&gt;                case .Spades, .Clubs: false<br>&gt;            }<br>&gt;        }<br>&gt;    }<br></p><p>This attacks the `return` boilerplate rather than the `switch` boilerplate. That means that, while it helps in this case, it would not help with members which have complicated logic or side effects. (And technically, the boilerplate is still there—it&#39;s just a `match(self)` instead of a `switch self`. I feel like they&#39;re orthogonal issues.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>March 25, 2016 at 11:00:00am</p></header><div class="content"><p>I don&#39;t think that removing &quot;switch(self)&quot; would remove much boilerplate. I rather see the returns and cases as such.<br></p><p>It is true your second approach is much more maintainable if you want to add or remove a case. However I think it suffers from readability and you cannot group related logic inside computed properties. So the upcoming boilerplate is much bigger than the one you&#39;re about to remove.<br>In addition if you always use exhaustive switches the maintainability isn&#39;t that bad.<br></p><p>- Maximilian<br></p><p>Am 24.03.2016 um 02:22 schrieb Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br></p><p>&gt;&gt; enum Suit: Int {<br>&gt;&gt;       case Hearts, Spades, Diamonds, Clubs<br>&gt;&gt; <br>&gt;&gt;       static var all: Suit[] { return [ Hearts, Spades, Diamonds, Clubs ] }<br>&gt;&gt; <br>&gt;&gt;       var description: String {<br>&gt;&gt;           return match(self) {<br>&gt;&gt;               case .Hearts: &quot;♥️&quot;<br>&gt;&gt;               case .Spades: &quot;♠️&quot;<br>&gt;&gt;               case .Diamonds: &quot;♦️&quot;<br>&gt;&gt;               case .Clubs: &quot;♣️&quot;<br>&gt;&gt;           }<br>&gt;&gt;       }<br>&gt;&gt; <br>&gt;&gt;       var isRed: Bool {<br>&gt;&gt;           return match(self) {<br>&gt;&gt;               case .Hearts, .Diamonds: true<br>&gt;&gt;               case .Spades, .Clubs: false<br>&gt;&gt;           }<br>&gt;&gt;       }<br>&gt;&gt;   }<br>&gt; <br>&gt; This attacks the `return` boilerplate rather than the `switch` boilerplate. That means that, while it helps in this case, it would not help with members which have complicated logic or side effects. (And technically, the boilerplate is still there—it&#39;s just a `match(self)` instead of a `switch self`. I feel like they&#39;re orthogonal issues.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March 24, 2016 at 03:00:00am</p></header><div class="content"><p>Honestly, we really need this for a lot of different cases:<br></p><p>&gt; * Allow you to attach member definitions to particular cases. It would be an error if they didn&#39;t all define the same members, unless there was a top-level catchall.<br>&gt; <br>&gt;    enum Suit: Int {<br>&gt;        var isRed: Bool { return false }<br>&gt; <br>&gt;        case Hearts {<br>&gt;            let description: String { return &quot;♥️&quot; }<br>&gt;            let isRed: Bool { return true }<br>&gt;        }<br>&gt;        case Spades {<br>&gt;            let description: String { return  &quot;♠️&quot; }<br>&gt;        }<br>&gt;        case Diamonds {<br>&gt;            let description: String { return  &quot;♦️&quot; }<br>&gt;            let isRed: Bool { return true }<br>&gt;        }<br>&gt;        case Clubs {<br>&gt;            let description: String { return  &quot;♣️&quot; }<br>&gt;        }<br>&gt; <br>&gt;        static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>&gt;    }<br></p><p>A.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>March 24, 2016 at 09:00:00am</p></header><div class="content"><p>In Java, the enum type behaves as an abstract class, sealed against the case members (which are singleton instance subclasses.)<br></p><p>While Swift enums aren’t discrete types or singletons, it sounds like what you would like is the ability to have an enum behave as so - to be able to override base (or protocol extension) behavior with a particular enum case, and have that translated most likely into a switch statement (most likely - I suppose if you are using witness tables it could optimize the switch away)<br></p><p>Actually with a protocol default behavior being overridden with a single enum case, this would give you functionality not possible today (referencing that protocol extension method)<br></p><p>In Java, I exploit the enum behavior to implement the State design pattern quite a bit, but am limited as Java enums are singletons and thus should be isolated from state. Swift enums are even more powerful here, but doing this in switch statements is a pain for maintainability.<br></p><p>I like the idea<br></p><p>-DW<br></p><p><br>&gt; On Mar 23, 2016, at 4:13 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If you&#39;ve written enums before, you&#39;ve no doubt noticed the irritating phenomenon of `switch self` being absolutely everywhere. I first discovered this in some of my very first Swift code, code so old we were still using the `T[]` shorthand syntax:<br>&gt; <br>&gt;    enum Suit: Int {<br>&gt;        case Hearts, Spades, Diamonds, Clubs<br>&gt; <br>&gt;        static var all: Suit[] { return [ Hearts, Spades, Diamonds, Clubs ] }<br>&gt; <br>&gt;        var description: String {<br>&gt;            switch(self) {<br>&gt;            case .Hearts:<br>&gt;                return &quot;♥️&quot;<br>&gt;            case .Spades:<br>&gt;                return &quot;♠️&quot;<br>&gt;            case .Diamonds:<br>&gt;                return &quot;♦️&quot;<br>&gt;            case .Clubs:<br>&gt;                return &quot;♣️&quot;<br>&gt;            }<br>&gt;        }<br>&gt; <br>&gt;        var isRed: Bool {<br>&gt;            switch(self) {<br>&gt;            case .Hearts, .Diamonds:<br>&gt;                return true<br>&gt;            case .Spades, .Clubs:<br>&gt;                return false<br>&gt;            }<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; It would be nice if we could somehow eliminate that. I have two suggestions:<br>&gt; <br>&gt; * Implicitly switch on `self` at the top level of a function or accessor (or at least an enum one with top-level `case` statements).<br>&gt; <br>&gt;    enum Suit: Int {<br>&gt;        case Hearts, Spades, Diamonds, Clubs<br>&gt; <br>&gt;        static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>&gt; <br>&gt;        var description: String {<br>&gt;        case .Hearts:<br>&gt;            return &quot;♥️&quot;<br>&gt;        case .Spades:<br>&gt;            return &quot;♠️&quot;<br>&gt;        case .Diamonds:<br>&gt;            return &quot;♦️&quot;<br>&gt;        case .Clubs:<br>&gt;            return &quot;♣️&quot;<br>&gt;        }<br>&gt; <br>&gt;        var isRed: Bool {<br>&gt;        case .Hearts, .Diamonds:<br>&gt;            return true<br>&gt;        case .Spades, .Clubs:<br>&gt;            return false<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; * Allow you to attach member definitions to particular cases. It would be an error if they didn&#39;t all define the same members, unless there was a top-level catchall.<br>&gt; <br>&gt;    enum Suit: Int {<br>&gt;        var isRed: Bool { return false }<br>&gt; <br>&gt;        case Hearts {<br>&gt;            let description: String { return &quot;♥️&quot; }<br>&gt;            let isRed: Bool { return true }<br>&gt;        }<br>&gt;        case Spades {<br>&gt;            let description: String { return  &quot;♠️&quot; }<br>&gt;        }<br>&gt;        case Diamonds {<br>&gt;            let description: String { return  &quot;♦️&quot; }<br>&gt;            let isRed: Bool { return true }<br>&gt;        }<br>&gt;        case Clubs {<br>&gt;            let description: String { return  &quot;♣️&quot; }<br>&gt;        }<br>&gt; <br>&gt;        static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>&gt;    }<br>&gt; <br>&gt; Any thoughts? This has, to be honest, bothered me since approximately the third day I used the language; I&#39;d love to address it sooner or later.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 25, 2016 at 11:00:00am</p></header><div class="content"><p>+1 for adding Java behaviour, it is something I have missed.<br></p><p>The example would be:<br></p><p>enum Suit: Int, CustomStringConvertible {<br>       case Hearts {<br>           var description: String { return “♥️&quot; }<br>       }<br>       case Spades {<br>           var description: String { return “♠️&quot; }<br>       }<br>       case Diamonds {<br>           var description: String { return “♦️&quot; }<br>       }<br>       case Clubs {<br>           var description: String { return “♣️&quot; }<br>       }<br>	<br>       // ...<br>}<br></p><p>The compiler could automatically generate the switch statement if that was better than virtual dispatch.<br></p><p><br>&gt; On 25 Mar 2016, at 2:42 AM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In Java, the enum type behaves as an abstract class, sealed against the case members (which are singleton instance subclasses.)<br>&gt; <br>&gt; While Swift enums aren’t discrete types or singletons, it sounds like what you would like is the ability to have an enum behave as so - to be able to override base (or protocol extension) behavior with a particular enum case, and have that translated most likely into a switch statement (most likely - I suppose if you are using witness tables it could optimize the switch away)<br>&gt; <br>&gt; Actually with a protocol default behavior being overridden with a single enum case, this would give you functionality not possible today (referencing that protocol extension method)<br>&gt; <br>&gt; In Java, I exploit the enum behavior to implement the State design pattern quite a bit, but am limited as Java enums are singletons and thus should be isolated from state. Swift enums are even more powerful here, but doing this in switch statements is a pain for maintainability.<br>&gt; <br>&gt; I like the idea<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 23, 2016, at 4:13 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If you&#39;ve written enums before, you&#39;ve no doubt noticed the irritating phenomenon of `switch self` being absolutely everywhere. I first discovered this in some of my very first Swift code, code so old we were still using the `T[]` shorthand syntax:<br>&gt;&gt; <br>&gt;&gt;   enum Suit: Int {<br>&gt;&gt;       case Hearts, Spades, Diamonds, Clubs<br>&gt;&gt; <br>&gt;&gt;       static var all: Suit[] { return [ Hearts, Spades, Diamonds, Clubs ] }<br>&gt;&gt; <br>&gt;&gt;       var description: String {<br>&gt;&gt;           switch(self) {<br>&gt;&gt;           case .Hearts:<br>&gt;&gt;               return &quot;♥️&quot;<br>&gt;&gt;           case .Spades:<br>&gt;&gt;               return &quot;♠️&quot;<br>&gt;&gt;           case .Diamonds:<br>&gt;&gt;               return &quot;♦️&quot;<br>&gt;&gt;           case .Clubs:<br>&gt;&gt;               return &quot;♣️&quot;<br>&gt;&gt;           }<br>&gt;&gt;       }<br>&gt;&gt; <br>&gt;&gt;       var isRed: Bool {<br>&gt;&gt;           switch(self) {<br>&gt;&gt;           case .Hearts, .Diamonds:<br>&gt;&gt;               return true<br>&gt;&gt;           case .Spades, .Clubs:<br>&gt;&gt;               return false<br>&gt;&gt;           }<br>&gt;&gt;       }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; It would be nice if we could somehow eliminate that. I have two suggestions:<br>&gt;&gt; <br>&gt;&gt; * Implicitly switch on `self` at the top level of a function or accessor (or at least an enum one with top-level `case` statements).<br>&gt;&gt; <br>&gt;&gt;   enum Suit: Int {<br>&gt;&gt;       case Hearts, Spades, Diamonds, Clubs<br>&gt;&gt; <br>&gt;&gt;       static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>&gt;&gt; <br>&gt;&gt;       var description: String {<br>&gt;&gt;       case .Hearts:<br>&gt;&gt;           return &quot;♥️&quot;<br>&gt;&gt;       case .Spades:<br>&gt;&gt;           return &quot;♠️&quot;<br>&gt;&gt;       case .Diamonds:<br>&gt;&gt;           return &quot;♦️&quot;<br>&gt;&gt;       case .Clubs:<br>&gt;&gt;           return &quot;♣️&quot;<br>&gt;&gt;       }<br>&gt;&gt; <br>&gt;&gt;       var isRed: Bool {<br>&gt;&gt;       case .Hearts, .Diamonds:<br>&gt;&gt;           return true<br>&gt;&gt;       case .Spades, .Clubs:<br>&gt;&gt;           return false<br>&gt;&gt;       }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; * Allow you to attach member definitions to particular cases. It would be an error if they didn&#39;t all define the same members, unless there was a top-level catchall.<br>&gt;&gt; <br>&gt;&gt;   enum Suit: Int {<br>&gt;&gt;       var isRed: Bool { return false }<br>&gt;&gt; <br>&gt;&gt;       case Hearts {<br>&gt;&gt;           let description: String { return &quot;♥️&quot; }<br>&gt;&gt;           let isRed: Bool { return true }<br>&gt;&gt;       }<br>&gt;&gt;       case Spades {<br>&gt;&gt;           let description: String { return  &quot;♠️&quot; }<br>&gt;&gt;       }<br>&gt;&gt;       case Diamonds {<br>&gt;&gt;           let description: String { return  &quot;♦️&quot; }<br>&gt;&gt;           let isRed: Bool { return true }<br>&gt;&gt;       }<br>&gt;&gt;       case Clubs {<br>&gt;&gt;           let description: String { return  &quot;♣️&quot; }<br>&gt;&gt;       }<br>&gt;&gt; <br>&gt;&gt;       static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; Any thoughts? This has, to be honest, bothered me since approximately the third day I used the language; I&#39;d love to address it sooner or later.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/0c27b834/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>March 31, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 23 Mar 2016, at 11:13, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; * Allow you to attach member definitions to particular cases. It would be an error if they didn&#39;t all define the same members, unless there was a top-level catchall.<br>&gt; <br>&gt;    enum Suit: Int {<br>&gt;        var isRed: Bool { return false }<br>&gt; <br>&gt;        case Hearts {<br>&gt;            let description: String { return &quot;♥️&quot; }<br>&gt;            let isRed: Bool { return true }<br>&gt;        }<br>&gt;        case Spades {<br>&gt;            let description: String { return  &quot;♠️&quot; }<br>&gt;        }<br>&gt;        case Diamonds {<br>&gt;            let description: String { return  &quot;♦️&quot; }<br>&gt;            let isRed: Bool { return true }<br>&gt;        }<br>&gt;        case Clubs {<br>&gt;            let description: String { return  &quot;♣️&quot; }<br>&gt;        }<br>&gt; <br>&gt;        static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>&gt;    }<br></p><p>Ah, that’s interesting! This would make enum cases less like values, and more like their own types.<br></p><p>(Or maybe not — it’s still a property of the enum itself, and the definitions must cover all cases. But it does suggest a different way of thinking about what enum cases are. Maybe it would be a good thing to have enum cases be more like types, and have their own properties and stuff? I don’t know…)<br></p><p>— Radek<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/3254857b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>March 31, 2016 at 10:00:00am</p></header><div class="content"><p>I like this. I might be inclined to do something a bit more like this, though, syntax-wise:<br></p><p>enum Suit {<br>  let description: String<br>  var isRed = false<br></p><p>  case hearts {<br>    description = &quot;♥️&quot;<br>    isRed = true<br>  }<br>  case spades {<br>    description = &quot;♠️&quot;<br>  }<br>  case diamonds {<br>    description = “♦️&quot;<br>    isRed = true<br>  }<br>  case clubs {<br>    description = “♣️&quot;<br>  }<br>}<br></p><p>By the end of the enum {} you must provide a value for every property declared in the enum or else it’d be a compile error. If you declare one as “var”, then you can specify a default value that can be overridden by just a few cases such as the “isRed” example. Declaring a property as “let” means every case must supply their own value for it. (If something is declared as var but each case supplies a value, there’d be a warning to turn the “var” into a “let”.)<br></p><p>However just because the property is declared as var doesn’t mean you can actually arbitrarily change it externally:<br></p><p>var foo = Suit.hearts<br>foo.isRed = false  // error - enum values are immutable<br></p><p>l8r<br>Sean<br></p><p><br></p><p>&gt; On Mar 31, 2016, at 7:15 AM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On 23 Mar 2016, at 11:13, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; * Allow you to attach member definitions to particular cases. It would be an error if they didn&#39;t all define the same members, unless there was a top-level catchall.<br>&gt;&gt; <br>&gt;&gt;    enum Suit: Int {<br>&gt;&gt;        var isRed: Bool { return false }<br>&gt;&gt; <br>&gt;&gt;        case Hearts {<br>&gt;&gt;            let description: String { return &quot;♥️&quot; }<br>&gt;&gt;            let isRed: Bool { return true }<br>&gt;&gt;        }<br>&gt;&gt;        case Spades {<br>&gt;&gt;            let description: String { return  &quot;♠️&quot; }<br>&gt;&gt;        }<br>&gt;&gt;        case Diamonds {<br>&gt;&gt;            let description: String { return  &quot;♦️&quot; }<br>&gt;&gt;            let isRed: Bool { return true }<br>&gt;&gt;        }<br>&gt;&gt;        case Clubs {<br>&gt;&gt;            let description: String { return  &quot;♣️&quot; }<br>&gt;&gt;        }<br>&gt;&gt; <br>&gt;&gt;        static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>&gt;&gt;    }<br>&gt; <br>&gt; Ah, that’s interesting! This would make enum cases less like values, and more like their own types.<br>&gt; <br>&gt; (Or maybe not — it’s still a property of the enum itself, and the definitions must cover all cases. But it does suggest a different way of thinking about what enum cases are. Maybe it would be a good thing to have enum cases be more like types, and have their own properties and stuff? I don’t know…)<br>&gt; <br>&gt; — Radek<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>March 31, 2016 at 05:00:00pm</p></header><div class="content"><p>This is what happens if you don’t follow the swift-evolution list for a while… I have send a very similar suggestion to the list today (but mine focuses more on methods). Didn’t mean to plagiarise your idea, sorry! Maybe we should bring the two of them together. <br></p><p>Best, <br></p><p> Taras<br></p><p>&gt; On 23 Mar 2016, at 11:13, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If you&#39;ve written enums before, you&#39;ve no doubt noticed the irritating phenomenon of `switch self` being absolutely everywhere. I first discovered this in some of my very first Swift code, code so old we were still using the `T[]` shorthand syntax:<br>&gt; <br>&gt;    enum Suit: Int {<br>&gt;        case Hearts, Spades, Diamonds, Clubs<br>&gt; <br>&gt;        static var all: Suit[] { return [ Hearts, Spades, Diamonds, Clubs ] }<br>&gt; <br>&gt;        var description: String {<br>&gt;            switch(self) {<br>&gt;            case .Hearts:<br>&gt;                return &quot;♥️&quot;<br>&gt;            case .Spades:<br>&gt;                return &quot;♠️&quot;<br>&gt;            case .Diamonds:<br>&gt;                return &quot;♦️&quot;<br>&gt;            case .Clubs:<br>&gt;                return &quot;♣️&quot;<br>&gt;            }<br>&gt;        }<br>&gt; <br>&gt;        var isRed: Bool {<br>&gt;            switch(self) {<br>&gt;            case .Hearts, .Diamonds:<br>&gt;                return true<br>&gt;            case .Spades, .Clubs:<br>&gt;                return false<br>&gt;            }<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; It would be nice if we could somehow eliminate that. I have two suggestions:<br>&gt; <br>&gt; * Implicitly switch on `self` at the top level of a function or accessor (or at least an enum one with top-level `case` statements).<br>&gt; <br>&gt;    enum Suit: Int {<br>&gt;        case Hearts, Spades, Diamonds, Clubs<br>&gt; <br>&gt;        static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>&gt; <br>&gt;        var description: String {<br>&gt;        case .Hearts:<br>&gt;            return &quot;♥️&quot;<br>&gt;        case .Spades:<br>&gt;            return &quot;♠️&quot;<br>&gt;        case .Diamonds:<br>&gt;            return &quot;♦️&quot;<br>&gt;        case .Clubs:<br>&gt;            return &quot;♣️&quot;<br>&gt;        }<br>&gt; <br>&gt;        var isRed: Bool {<br>&gt;        case .Hearts, .Diamonds:<br>&gt;            return true<br>&gt;        case .Spades, .Clubs:<br>&gt;            return false<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; * Allow you to attach member definitions to particular cases. It would be an error if they didn&#39;t all define the same members, unless there was a top-level catchall.<br>&gt; <br>&gt;    enum Suit: Int {<br>&gt;        var isRed: Bool { return false }<br>&gt; <br>&gt;        case Hearts {<br>&gt;            let description: String { return &quot;♥️&quot; }<br>&gt;            let isRed: Bool { return true }<br>&gt;        }<br>&gt;        case Spades {<br>&gt;            let description: String { return  &quot;♠️&quot; }<br>&gt;        }<br>&gt;        case Diamonds {<br>&gt;            let description: String { return  &quot;♦️&quot; }<br>&gt;            let isRed: Bool { return true }<br>&gt;        }<br>&gt;        case Clubs {<br>&gt;            let description: String { return  &quot;♣️&quot; }<br>&gt;        }<br>&gt; <br>&gt;        static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>&gt;    }<br>&gt; <br>&gt; Any thoughts? This has, to be honest, bothered me since approximately the third day I used the language; I&#39;d love to address it sooner or later.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>April  8, 2016 at 11:00:00am</p></header><div class="content"><p>I much prefer the Java style of enums, which are essentially classes limited to a fixed set of instances. In Java, Suit would look like this:<br></p><p>public enum Suit {<br>   Hearts(&quot;♥&quot;, true),<br>   Spades(&quot;♠&quot;, false),<br>   Diamonds(&quot;♦&quot;, true),<br>   Clubs(&quot;♣&quot;, false);<br></p><p>   String description;<br>   boolean isRed;<br></p><p>   Suit(String description, boolean isRed) {<br>      this.description = description;<br>      this.isRed = isRed;<br>   }<br>}<br></p><p>The class java.lang.Enum already provides handy methods like<br>    name(),<br>    ordinal(), <br>    toString(), and its inverse, valueOf()<br>    values() - to get all values<br></p><p>-Kenny<br></p><p>&gt; On Mar 23, 2016, at 3:13 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If you&#39;ve written enums before, you&#39;ve no doubt noticed the irritating phenomenon of `switch self` being absolutely everywhere. I first discovered this in some of my very first Swift code, code so old we were still using the `T[]` shorthand syntax:<br>&gt; <br>&gt;    enum Suit: Int {<br>&gt;        case Hearts, Spades, Diamonds, Clubs<br>&gt; <br>&gt;        static var all: Suit[] { return [ Hearts, Spades, Diamonds, Clubs ] }<br>&gt; <br>&gt;        var description: String {<br>&gt;            switch(self) {<br>&gt;            case .Hearts:<br>&gt;                return &quot;♥️&quot;<br>&gt;            case .Spades:<br>&gt;                return &quot;♠️&quot;<br>&gt;            case .Diamonds:<br>&gt;                return &quot;♦️&quot;<br>&gt;            case .Clubs:<br>&gt;                return &quot;♣️&quot;<br>&gt;            }<br>&gt;        }<br>&gt; <br>&gt;        var isRed: Bool {<br>&gt;            switch(self) {<br>&gt;            case .Hearts, .Diamonds:<br>&gt;                return true<br>&gt;            case .Spades, .Clubs:<br>&gt;                return false<br>&gt;            }<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; It would be nice if we could somehow eliminate that. I have two suggestions:<br>&gt; <br>&gt; * Implicitly switch on `self` at the top level of a function or accessor (or at least an enum one with top-level `case` statements).<br>&gt; <br>&gt;    enum Suit: Int {<br>&gt;        case Hearts, Spades, Diamonds, Clubs<br>&gt; <br>&gt;        static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>&gt; <br>&gt;        var description: String {<br>&gt;        case .Hearts:<br>&gt;            return &quot;♥️&quot;<br>&gt;        case .Spades:<br>&gt;            return &quot;♠️&quot;<br>&gt;        case .Diamonds:<br>&gt;            return &quot;♦️&quot;<br>&gt;        case .Clubs:<br>&gt;            return &quot;♣️&quot;<br>&gt;        }<br>&gt; <br>&gt;        var isRed: Bool {<br>&gt;        case .Hearts, .Diamonds:<br>&gt;            return true<br>&gt;        case .Spades, .Clubs:<br>&gt;            return false<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; * Allow you to attach member definitions to particular cases. It would be an error if they didn&#39;t all define the same members, unless there was a top-level catchall.<br>&gt; <br>&gt;    enum Suit: Int {<br>&gt;        var isRed: Bool { return false }<br>&gt; <br>&gt;        case Hearts {<br>&gt;            let description: String { return &quot;♥️&quot; }<br>&gt;            let isRed: Bool { return true }<br>&gt;        }<br>&gt;        case Spades {<br>&gt;            let description: String { return  &quot;♠️&quot; }<br>&gt;        }<br>&gt;        case Diamonds {<br>&gt;            let description: String { return  &quot;♦️&quot; }<br>&gt;            let isRed: Bool { return true }<br>&gt;        }<br>&gt;        case Clubs {<br>&gt;            let description: String { return  &quot;♣️&quot; }<br>&gt;        }<br>&gt; <br>&gt;        static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>&gt;    }<br>&gt; <br>&gt; Any thoughts? This has, to be honest, bothered me since approximately the third day I used the language; I&#39;d love to address it sooner or later.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April  9, 2016 at 12:00:00am</p></header><div class="content"><p>I also agree that there are some problems with enums in current Swift.<br></p><p>(tl;dr: will Swift 3.0 improve iteration for enum values? Some kind of <br>.next() method for values or .all[] property. Currently we have a problem <br>with this.)<br></p><p>Java&#39;s version of enum declaration in this case seems much better IMO. It <br>allows to assign additional parameters to &quot;main&quot; enum value in handy way <br>and in one place(where the main value itself is declared). In Swift to <br>implement the same we have to write these for each param:<br>    var &lt;param&gt;: &lt;Type&gt; {<br>        switch self {<br>            case .&lt;first&gt; : return &lt;for first&gt;<br>            case .&lt;second&gt; : return &lt;for second&gt;<br>            case .&lt;etc&gt; : return &lt;for etc&gt;<br>        }<br>    }<br></p><p>Actually, as I understand , we can use custom struct as RawValue to have <br>assigned params for each value i.e. something like this:<br>enum Devices: CGSize {<br>    case iPhone5 = CGSize(width: 320, height: 568)<br>    case iPhone6 = CGSize(width: 375, height: 667)<br>    case iPhone6Plus = CGSize(width: 414, height: 736)<br>}<br>and<br>extension CGSize: StringLiteralConvertible {..}<br>let a = Devices.iPhone5<br>let b = a.rawValue<br>print(&quot;string is \(a), width is \(b.width), height is \(b.height)&quot;)<br>(found in Internet)<br></p><p>But personally I don&#39;t think this is big problem or if this is totally <br>unusable. I think we can live with this.<br></p><p>The real problem is iteration the enum values.<br></p><p>In initial message for this [Idea], in code sample, they use static <br>property to be able to iterate enum values - array where all values is stored:<br>static var all = [ Hearts, Spades, Diamonds, Clubs ]<br></p><p>If we add new enum value to this enum - Swift will protect us and force us <br>to add one more case: in each &quot;switch self&quot;.<br>But! It will not protect us from not adding this new value to this &quot;all&quot; <br>array. This is absolutely not-Swift way.<br></p><p>Without such &quot;all&quot; property, how will you iterate values for such enum? I <br>didn&#39;t find any good method to iterate enums.<br></p><p>In Delphi(yes, I know ;-) you can iterate enums using such syntax:<br>i: EnumType<br>for i := Low(EnumType) to High(EnumType)<br>i.e. it will always work correctly, don&#39;t need to change this if you added <br>value.<br>and can have such declaration of array where indexes are EnumType:<br>a: array [EnumType] of String = (&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;)<br>and it will force you to fill/fix this array if you added/deleted the enum <br>value.<br></p><p>In Swift we need something to normally iterate enum values. Probably some <br>.next()-&gt;EnumType? method for each value or built-in .all:[EnumType] property.<br></p><p>Am I wrong somewhere? Are there some plans to improve enums?<br></p><p>On 08.04.2016 21:13, Kenny Leung via swift-evolution wrote:<br>&gt; I much prefer the Java style of enums, which are essentially classes limited to a fixed set of instances. In Java, Suit would look like this:<br>&gt;<br>&gt; public enum Suit {<br>&gt;     Hearts(&quot;♥&quot;, true),<br>&gt;     Spades(&quot;♠&quot;, false),<br>&gt;     Diamonds(&quot;♦&quot;, true),<br>&gt;     Clubs(&quot;♣&quot;, false);<br>&gt;<br>&gt;     String description;<br>&gt;     boolean isRed;<br>&gt;<br>&gt;     Suit(String description, boolean isRed) {<br>&gt;        this.description = description;<br>&gt;        this.isRed = isRed;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; The class java.lang.Enum already provides handy methods like<br>&gt;      name(),<br>&gt;      ordinal(),<br>&gt;      toString(), and its inverse, valueOf()<br>&gt;      values() - to get all values<br>&gt;<br>&gt; -Kenny<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  8, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; (tl;dr: will Swift 3.0 improve iteration for enum values? Some kind of .next() method for values or .all[] property. Currently we have a problem with this.)<br></p><p>There are proposals to do this, but they&#39;re on hold at the moment because the guy who was the main driving force got busy with meatspace things. Roughly, you would be able to conform an enum to a ValuesEnumerable protocol which would automatically synthesize an `allValues` static property on it. You could use an extension to do this to an enum that didn&#39;t belong to you, so you could get this even if the original author didn&#39;t think to add it.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April  9, 2016 at 09:00:00am</p></header><div class="content"><p>On 09.04.2016 6:49, Brent Royal-Gordon wrote:<br>&gt;&gt; (tl;dr: will Swift 3.0 improve iteration for enum values? Some kind of .next() method for values or .all[] property. Currently we have a problem with this.)<br>&gt;<br>&gt; There are proposals to do this, but they&#39;re on hold at the moment because the guy who was the main driving force got busy with meatspace things. Roughly, you would be able to conform an enum to a ValuesEnumerable protocol which would automatically synthesize an `allValues` static property on it. You could use an extension to do this to an enum that didn&#39;t belong to you, so you could get this even if the original author didn&#39;t think to add it.<br>&gt;<br></p><p>Could you provide a little more information about this ValuesEnumerable <br>protocol? My Swift says it doesn&#39;t know about such protocol.<br>Strange, but goggle knows nothing about<br>&#39;swift &quot;ValuesEnumerable&quot;&#39;<br>But I can see ValuesEnumerable in some articles related to C#.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  8, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt;&gt;&gt; (tl;dr: will Swift 3.0 improve iteration for enum values? Some kind of .next() method for values or .all[] property. Currently we have a problem with this.)<br>&gt;&gt; <br>&gt;&gt; There are proposals to do this, but they&#39;re on hold at the moment because the guy who was the main driving force got busy with meatspace things. Roughly, you would be able to conform an enum to a ValuesEnumerable protocol which would automatically synthesize an `allValues` static property on it. You could use an extension to do this to an enum that didn&#39;t belong to you, so you could get this even if the original author didn&#39;t think to add it.<br>&gt;&gt; <br>&gt; <br>&gt; Could you provide a little more information about this ValuesEnumerable protocol? My Swift says it doesn&#39;t know about such protocol.<br>&gt; Strange, but goggle knows nothing about<br>&gt; &#39;swift &quot;ValuesEnumerable&quot;&#39;<br>&gt; But I can see ValuesEnumerable in some articles related to C#.<br></p><p>This design is still very much under development—it hasn&#39;t even been reviewed, let alone added to the language. Here&#39;s the draft proposal: &lt;https://github.com/jtbandes/swift-evolution/blob/case-enumerable/proposals/0000-derived-collection-of-enum-cases.md&gt;<br></p><p>I&#39;m not saying that this will necessarily be a solution that ends up being accepted—I&#39;m merely saying that yes, it&#39;s something people are thinking about and designing; it&#39;s just been inactive for a few weeks.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April  9, 2016 at 10:00:00am</p></header><div class="content"><p>On 09.04.2016 9:31, Brent Royal-Gordon wrote:<br>&gt; This design is still very much under development—it hasn&#39;t even been reviewed, let alone added to the language. Here&#39;s the draft proposal:&lt;https://github.com/jtbandes/swift-evolution/blob/case-enumerable/proposals/0000-derived-collection-of-enum-cases.md&gt;<br>&gt;<br>&gt; I&#39;m not saying that this will necessarily be a solution that ends up being accepted—I&#39;m merely saying that yes, it&#39;s something people are thinking about and designing; it&#39;s just been inactive for a few weeks.<br></p><p>Oh, I see. Thank you for letting know. Just missed &quot;you would be able&quot; in <br>your previous message, did read it as &quot;you are able&quot;, so was trying to find <br>this in current Swift version. OK, glad to know that most likely we&#39;ll have <br>improvements in enums eterations for Swift 3.0.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>May 20, 2016 at 04:00:00am</p></header><div class="content"><p>I wrote some code tonight to experiment with this kind of thing. I<br>apologize if it&#39;s off-topic for the thread, but it might be useful to<br>others who want to experiment.<br></p><p><br></p><p>//: Playground - noun: a place where people can play<br></p><p><br>import Cocoa<br></p><p><br>infix operator • { precedence 180 }<br></p><p>infix operator → { associativity left precedence 70 }<br></p><p>infix operator … { associativity right precedence 60 }<br></p><p><br>func → &lt;T&gt;( lhs: Bool, rhs: T ) -&gt; T? {<br></p><p>return lhs ? rhs : nil<br></p><p>}<br></p><p><br>func … &lt;T&gt;( lhs:T?, rhs:T ) -&gt; T {<br></p><p>return lhs != nil ? lhs! : rhs<br></p><p>}<br></p><p><br>func depends&lt;I,O&gt;( dep:I, _ closure: (I)-&gt;(O) ) -&gt; O {<br></p><p>return closure( dep )<br></p><p>}<br></p><p><br>func • &lt;I,O&gt;( lhs: I, rhs: (I)-&gt;(O) ) -&gt; O {<br></p><p>return depends( lhs, rhs )<br></p><p>}<br></p><p><br>/* Example using &quot;depends&quot; */<br></p><p><br>let<br></p><p>str:String,<br></p><p>i = 7<br></p><p><br>str = depends( i ){<br></p><p>$0==2 → &quot;two&quot; …<br></p><p>$0==3 → &quot;three&quot; …<br></p><p>$0==4 → &quot;four&quot; …<br></p><p>&quot;other&quot;<br></p><p>}<br></p><p><br>/* Example using &quot;•&quot; operator as &quot;depends&quot; */<br></p><p><br>enum People { case Kurtz, Popescu, Lime, Martins }<br></p><p>enum Order { case First, Second, Third, Unknown }<br></p><p><br>let<br></p><p>order:Order,<br></p><p>person:People = .Lime<br></p><p><br>order = person • {<br></p><p>$0 == .Kurtz → .First …<br></p><p>$0 == .Popescu → .Second …<br></p><p>$0 == .Lime → .Third …<br></p><p>.Unknown<br></p><p>}<br></p><p><br></p><p>I also have some trepidation about posting it here, because it might have<br>bugs. I wans&#39;t sure what &quot;precedence&quot; and &quot;associativity&quot; should be, for<br>example. But it does make it more convenient to test alternative characters<br>for operators, etc.<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p>On Sat, Apr 9, 2016 at 12:05 AM, Vladimir.S via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 09.04.2016 9:31, Brent Royal-Gordon wrote:<br>&gt;<br>&gt;&gt; This design is still very much under development—it hasn&#39;t even been<br>&gt;&gt; reviewed, let alone added to the language. Here&#39;s the draft proposal:&lt;<br>&gt;&gt; https://github.com/jtbandes/swift-evolution/blob/case-enumerable/proposals/0000-derived-collection-of-enum-cases.md<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;m not saying that this will necessarily be a solution that ends up<br>&gt;&gt; being accepted—I&#39;m merely saying that yes, it&#39;s something people are<br>&gt;&gt; thinking about and designing; it&#39;s just been inactive for a few weeks.<br>&gt;&gt;<br>&gt;<br>&gt; Oh, I see. Thank you for letting know. Just missed &quot;you would be able&quot; in<br>&gt; your previous message, did read it as &quot;you are able&quot;, so was trying to find<br>&gt; this in current Swift version. OK, glad to know that most likely we&#39;ll have<br>&gt; improvements in enums eterations for Swift 3.0.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/fe9219cd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/74b2be3f33e2efebef65c9a48c32872a?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Angelo Villegas</string> &lt;gelo.web at gmail.com&gt;<p>May 20, 2016 at 11:00:00pm</p></header><div class="content"><p>This is very similar to Haskell&#39;s guard I tried to pitch before, but the community seem to not want it on Swift.<br></p><p>let a | case1 = &quot;case 1&quot;<br>      | case2 = &quot;case 2&quot;<br>      | otherwise = &quot;default&quot;<br></p><p>Where otherwise is simply defined as otherwise = True that catches everything (similar to switch default)<br></p><p>On behalf of the OP&#39;s:<br></p><p>var description: String {<br>    case .Hearts:<br>        return &quot;♥️&quot;<br>    case .Spades:<br>        return &quot;♠️&quot;<br>    case .Diamonds:<br>        return &quot;♦️&quot;<br>    case .Clubs:<br>        return &quot;♣️&quot;<br>}<br></p><p>can be:<br></p><p>var description: String {<br>    return | .Hearts = &quot;♥️&quot;<br>           | .Spades = &quot;♠️&quot;<br>           | .Diamonds = &quot;♦️&quot;<br>           | .Clubs = &quot;♣️&quot;<br>}<br></p><p>On 20 May 2016, 7:15 PM +0800, Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt;, wrote:<br>&gt; I wrote some code tonight to experiment with this kind of thing. I apologize if it&#39;s off-topic for the thread, but it might be useful to others who want to experiment. <br>&gt; <br>&gt; <br>&gt; <br>&gt; //: Playground - noun: a place where people can play<br>&gt; <br>&gt; import Cocoa<br>&gt; <br>&gt; infix operator • { precedence 180 }<br>&gt; infix operator → { associativity left precedence 70 }<br>&gt; infix operator … { associativity right precedence 60 }<br>&gt; <br>&gt; func → &lt;T&gt;( lhs: Bool, rhs: T ) -&gt; T? {<br>&gt; return lhs ? rhs : nil<br>&gt; }<br>&gt; <br>&gt; func … &lt;T&gt;( lhs:T?, rhs:T ) -&gt; T {<br>&gt; return lhs != nil ? lhs! : rhs<br>&gt; }<br>&gt; <br>&gt; func depends&lt;I,O&gt;( dep:I, _ closure: (I)-&gt;(O) ) -&gt; O {<br>&gt; return closure( dep )<br>&gt; }<br>&gt; <br>&gt; func • &lt;I,O&gt;( lhs: I, rhs: (I)-&gt;(O) ) -&gt; O {<br>&gt; return depends( lhs, rhs )<br>&gt; }<br>&gt; <br>&gt; /* Example using &quot;depends&quot; */<br>&gt; <br>&gt; let<br>&gt; str:String,<br>&gt; i = 7<br>&gt; <br>&gt; str = depends( i ){<br>&gt; $0==2 → &quot;two&quot; …<br>&gt; $0==3 → &quot;three&quot; …<br>&gt; $0==4 → &quot;four&quot; …<br>&gt; &quot;other&quot;<br>&gt; }<br>&gt; <br>&gt; /* Example using &quot;•&quot; operator as &quot;depends&quot; */<br>&gt; <br>&gt; enum People { case Kurtz, Popescu, Lime, Martins }<br>&gt; enum Order { case First, Second, Third, Unknown }<br>&gt; <br>&gt; let<br>&gt; order:Order,<br>&gt; person:People = .Lime<br>&gt; <br>&gt; order = person • {<br>&gt; $0 == .Kurtz → .First …<br>&gt; $0 == .Popescu → .Second …<br>&gt; $0 == .Lime → .Third …<br>&gt; .Unknown<br>&gt; }<br>&gt; <br>&gt; <br>&gt; I also have some trepidation about posting it here, because it might have bugs. I wans&#39;t sure what &quot;precedence&quot; and &quot;associativity&quot; should be, for example. But it does make it more convenient to test alternative characters for operators, etc.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On Sat, Apr 9, 2016 at 12:05 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; On 09.04.2016 9:31, Brent Royal-Gordon wrote:<br>&gt; This design is still very much under development—it hasn&#39;t even been reviewed, let alone added to the language. Here&#39;s the draft proposal:&lt;https://github.com/jtbandes/swift-evolution/blob/case-enumerable/proposals/0000-derived-collection-of-enum-cases.md &lt;https://github.com/jtbandes/swift-evolution/blob/case-enumerable/proposals/0000-derived-collection-of-enum-cases.md&gt;&gt;<br>&gt; <br>&gt; I&#39;m not saying that this will necessarily be a solution that ends up being accepted—I&#39;m merely saying that yes, it&#39;s something people are thinking about and designing; it&#39;s just been inactive for a few weeks.<br>&gt; <br>&gt; Oh, I see. Thank you for letting know. Just missed &quot;you would be able&quot; in your previous message, did read it as &quot;you are able&quot;, so was trying to find this in current Swift version. OK, glad to know that most likely we&#39;ll have improvements in enums eterations for Swift 3.0.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/6e4d470e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 10:18 AM, Angelo Villegas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is very similar to Haskell&#39;s guard I tried to pitch before, but the community seem to not want it on Swift.<br>&gt; <br>&gt; let a | case1 = &quot;case 1&quot;<br>&gt;       | case2 = &quot;case 2&quot;<br>&gt;       | otherwise = &quot;default&quot;<br>&gt; <br>&gt; Where otherwise is simply defined as otherwise = True that catches everything (similar to switch default)<br>&gt; <br>&gt; On behalf of the OP&#39;s:<br>&gt; <br>&gt; var description: String {<br>&gt;     case .Hearts:<br>&gt;         return &quot;♥️&quot;<br>&gt;     case .Spades:<br>&gt;         return &quot;♠️&quot;<br>&gt;     case .Diamonds:<br>&gt;         return &quot;♦️&quot;<br>&gt;     case .Clubs:<br>&gt;         return &quot;♣️&quot;<br>&gt; }<br>&gt; <br>&gt; can be:<br>&gt; <br>&gt; var description: String {<br>&gt;     return | .Hearts = &quot;♥️&quot;<br>&gt;            | .Spades = &quot;♠️&quot;<br>&gt;            | .Diamonds = &quot;♦️&quot;<br>&gt;            | .Clubs = &quot;♣️&quot;<br>&gt; }<br></p><p>If we’re going to introduce something like this we should consider having it switch on all parameters, not just self.<br></p><p>&gt; <br>&gt; On 20 May 2016, 7:15 PM +0800, Charles Constant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;, wrote:<br>&gt;&gt; I wrote some code tonight to experiment with this kind of thing. I apologize if it&#39;s off-topic for the thread, but it might be useful to others who want to experiment. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; //: Playground - noun: a place where people can play<br>&gt;&gt; <br>&gt;&gt; import Cocoa<br>&gt;&gt; <br>&gt;&gt; infix operator • { precedence 180 }<br>&gt;&gt; infix operator → { associativity left precedence 70 }<br>&gt;&gt; infix operator … { associativity right precedence 60 }<br>&gt;&gt; <br>&gt;&gt; func → &lt;T&gt;( lhs: Bool, rhs: T ) -&gt; T? {<br>&gt;&gt; return lhs ? rhs : nil<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func … &lt;T&gt;( lhs:T?, rhs:T ) -&gt; T {<br>&gt;&gt; return lhs != nil ? lhs! : rhs<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func depends&lt;I,O&gt;( dep:I, _ closure: (I)-&gt;(O) ) -&gt; O {<br>&gt;&gt; return closure( dep )<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func • &lt;I,O&gt;( lhs: I, rhs: (I)-&gt;(O) ) -&gt; O {<br>&gt;&gt; return depends( lhs, rhs )<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; /* Example using &quot;depends&quot; */<br>&gt;&gt; <br>&gt;&gt; let<br>&gt;&gt; str:String,<br>&gt;&gt; i = 7<br>&gt;&gt; <br>&gt;&gt; str = depends( i ){<br>&gt;&gt; $0==2 → &quot;two&quot; …<br>&gt;&gt; $0==3 → &quot;three&quot; …<br>&gt;&gt; $0==4 → &quot;four&quot; …<br>&gt;&gt; &quot;other&quot;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; /* Example using &quot;•&quot; operator as &quot;depends&quot; */<br>&gt;&gt; <br>&gt;&gt; enum People { case Kurtz, Popescu, Lime, Martins }<br>&gt;&gt; enum Order { case First, Second, Third, Unknown }<br>&gt;&gt; <br>&gt;&gt; let<br>&gt;&gt; order:Order,<br>&gt;&gt; person:People = .Lime<br>&gt;&gt; <br>&gt;&gt; order = person • {<br>&gt;&gt; $0 == .Kurtz → .First …<br>&gt;&gt; $0 == .Popescu → .Second …<br>&gt;&gt; $0 == .Lime → .Third …<br>&gt;&gt; .Unknown<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I also have some trepidation about posting it here, because it might have bugs. I wans&#39;t sure what &quot;precedence&quot; and &quot;associativity&quot; should be, for example. But it does make it more convenient to test alternative characters for operators, etc.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sat, Apr 9, 2016 at 12:05 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On 09.04.2016 9:31, Brent Royal-Gordon wrote:<br>&gt;&gt; This design is still very much under development—it hasn&#39;t even been reviewed, let alone added to the language. Here&#39;s the draft proposal:&lt;https://github.com/jtbandes/swift-evolution/blob/case-enumerable/proposals/0000-derived-collection-of-enum-cases.md &lt;https://github.com/jtbandes/swift-evolution/blob/case-enumerable/proposals/0000-derived-collection-of-enum-cases.md&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; I&#39;m not saying that this will necessarily be a solution that ends up being accepted—I&#39;m merely saying that yes, it&#39;s something people are thinking about and designing; it&#39;s just been inactive for a few weeks.<br>&gt;&gt; <br>&gt;&gt; Oh, I see. Thank you for letting know. Just missed &quot;you would be able&quot; in your previous message, did read it as &quot;you are able&quot;, so was trying to find this in current Swift version. OK, glad to know that most likely we&#39;ll have improvements in enums eterations for Swift 3.0.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/1d03dd48/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>May 21, 2016 at 11:00:00pm</p></header><div class="content"><p>Thought I&#39;d just followup about the code I posted. It&#39;s basically<br>*horrible* for anything other than toying around. I just clued in that it<br>doesn&#39;t short when it finds a value. Also it causes Playground to stall for<br>a couple minutes on my machine. Shame :(<br></p><p>PS: It would also have been nice to replace &quot;…&quot; with the built-in &quot;??&quot; but<br>the precedence doesn&#39;t leave any space between 130, and 131 (which is a<br>pretty good argument to support recently discussed proposal about making<br>precedence relative)<br></p><p>Do we already have a proposal to add ternary-style *custom* operators (ie:<br>in addition to infix/prefix/postfix)? I would settle for that, if none of<br>the &quot;switch assignment&quot; or &quot;multiary ternary&quot; proposals make it into Swift<br>4.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160521/dda7540d/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>May 23, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Le 20 mai 2016 à 07:14, Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I wrote some code tonight to experiment with this kind of thing. I apologize if it&#39;s off-topic for the thread, but it might be useful to others who want to experiment. <br>&gt; <br>&gt; <br>&gt; <br>&gt; //: Playground - noun: a place where people can play<br>&gt; <br>&gt; import Cocoa<br>&gt; <br>&gt; infix operator • { precedence 180 }<br>&gt; infix operator → { associativity left precedence 70 }<br>&gt; infix operator … { associativity right precedence 60 }<br>&gt; <br>&gt; func → &lt;T&gt;( lhs: Bool, rhs: T ) -&gt; T? {<br>&gt; 	return lhs ? rhs : nil<br>&gt; }<br>&gt; <br>&gt; func … &lt;T&gt;( lhs:T?, rhs:T ) -&gt; T {<br>&gt; 	return lhs != nil ? lhs! : rhs<br>&gt; }<br>&gt; <br>&gt; func depends&lt;I,O&gt;( dep:I, _ closure: (I)-&gt;(O) ) -&gt; O {<br>&gt; 	return closure( dep )<br>&gt; }<br>&gt; <br>&gt; func • &lt;I,O&gt;( lhs: I, rhs: (I)-&gt;(O) ) -&gt; O {<br>&gt; 	return depends( lhs, rhs )<br>&gt; }<br>&gt; <br>&gt; /* Example using &quot;depends&quot; */<br>&gt; <br>&gt; let<br>&gt; 	str:String,<br>&gt; 	i = 7<br>&gt; <br>&gt; str = depends( i ){<br>&gt; 	$0==2 → &quot;two&quot; …<br>&gt; 	$0==3 → &quot;three&quot; …<br>&gt; 	$0==4 → &quot;four&quot; …<br>&gt; 	&quot;other&quot;<br>&gt; }<br>&gt; <br></p><p>Hmm… replacing -&gt; by ?, and … by : you get:<br></p><p>str = depends( i ){<br>    $0==2 ? &quot;two&quot; :<br>    $0==3 ? &quot;three&quot; :<br>    $0==4 ? &quot;four&quot; :<br>    &quot;other&quot;<br>}<br></p><p>which work as is without a need to define new operators.<br></p><p>Dany<br></p><p>&gt; /* Example using &quot;•&quot; operator as &quot;depends&quot; */<br>&gt; <br>&gt; enum People { case Kurtz, Popescu, Lime, Martins }<br>&gt; enum Order { case First, Second, Third, Unknown }<br>&gt; <br>&gt; let<br>&gt; 	order:Order,<br>&gt; 	person:People = .Lime<br>&gt; <br>&gt; order = person • {<br>&gt; 	$0 == .Kurtz → .First …<br>&gt; 	$0 == .Popescu → .Second …<br>&gt; 	$0 == .Lime → .Third …<br>&gt; 	.Unknown<br>&gt; }<br>&gt; <br>&gt; <br>&gt; I also have some trepidation about posting it here, because it might have bugs. I wans&#39;t sure what &quot;precedence&quot; and &quot;associativity&quot; should be, for example. But it does make it more convenient to test alternative characters for operators, etc.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On Sat, Apr 9, 2016 at 12:05 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; On 09.04.2016 9:31, Brent Royal-Gordon wrote:<br>&gt; This design is still very much under development—it hasn&#39;t even been reviewed, let alone added to the language. Here&#39;s the draft proposal:&lt;https://github.com/jtbandes/swift-evolution/blob/case-enumerable/proposals/0000-derived-collection-of-enum-cases.md &lt;https://github.com/jtbandes/swift-evolution/blob/case-enumerable/proposals/0000-derived-collection-of-enum-cases.md&gt;&gt;<br>&gt; <br>&gt; I&#39;m not saying that this will necessarily be a solution that ends up being accepted—I&#39;m merely saying that yes, it&#39;s something people are thinking about and designing; it&#39;s just been inactive for a few weeks.<br>&gt; <br>&gt; Oh, I see. Thank you for letting know. Just missed &quot;you would be able&quot; in your previous message, did read it as &quot;you are able&quot;, so was trying to find this in current Swift version. OK, glad to know that most likely we&#39;ll have improvements in enums eterations for Swift 3.0.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/591424cb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>May 23, 2016 at 09:00:00pm</p></header><div class="content"><p>Good grief. I think you&#39;re right.<br></p><p>Some how, a long time ago, I got it into my head that the order in which<br>each part of the ternary got evaluated would cause problems for this kind<br>of thing.<br></p><p>I&#39;ve had a huge blindspot and I&#39;ve been railing on the list for something I<br>don&#39;t need for weeks.<br></p><p>Wow, I couldn&#39;t be more embarassed.<br></p><p>But I&#39;m happy too, because I can go ahead and just use a chained ternary.<br></p><p>Sorry all, and thanks.<br></p><p><br>On Mon, May 23, 2016 at 6:26 PM, Dany St-Amant &lt;dsa.mls at icloud.com&gt; wrote:<br></p><p>&gt;<br>&gt; Le 20 mai 2016 à 07:14, Charles Constant via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; I wrote some code tonight to experiment with this kind of thing. I<br>&gt; apologize if it&#39;s off-topic for the thread, but it might be useful to<br>&gt; others who want to experiment.<br>&gt;<br>&gt;<br>&gt;<br>&gt; //: Playground - noun: a place where people can play<br>&gt;<br>&gt; import Cocoa<br>&gt;<br>&gt; infix operator • { precedence 180 }<br>&gt; infix operator → { associativity left precedence 70 }<br>&gt; infix operator … { associativity right precedence 60 }<br>&gt;<br>&gt; func → &lt;T&gt;( lhs: Bool, rhs: T ) -&gt; T? {<br>&gt; return lhs ? rhs : nil<br>&gt; }<br>&gt;<br>&gt; func … &lt;T&gt;( lhs:T?, rhs:T ) -&gt; T {<br>&gt; return lhs != nil ? lhs! : rhs<br>&gt; }<br>&gt;<br>&gt; func depends&lt;I,O&gt;( dep:I, _ closure: (I)-&gt;(O) ) -&gt; O {<br>&gt; return closure( dep )<br>&gt; }<br>&gt;<br>&gt; func • &lt;I,O&gt;( lhs: I, rhs: (I)-&gt;(O) ) -&gt; O {<br>&gt; return depends( lhs, rhs )<br>&gt; }<br>&gt;<br>&gt; /* Example using &quot;depends&quot; */<br>&gt;<br>&gt; let<br>&gt; str:String,<br>&gt; i = 7<br>&gt;<br>&gt; str = depends( i ){<br>&gt; $0==2 → &quot;two&quot; …<br>&gt; $0==3 → &quot;three&quot; …<br>&gt; $0==4 → &quot;four&quot; …<br>&gt; &quot;other&quot;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Hmm… replacing -&gt; by ?, and … by : you get:<br>&gt;<br>&gt; str = depends( i ){<br>&gt;     $0==2 ? &quot;two&quot; :<br>&gt;     $0==3 ? &quot;three&quot; :<br>&gt;     $0==4 ? &quot;four&quot; :<br>&gt;     &quot;other&quot;<br>&gt; }<br>&gt;<br>&gt; which work as is without a need to define new operators.<br>&gt;<br>&gt; Dany<br>&gt;<br>&gt; /* Example using &quot;•&quot; operator as &quot;depends&quot; */<br>&gt;<br>&gt; enum People { case Kurtz, Popescu, Lime, Martins }<br>&gt; enum Order { case First, Second, Third, Unknown }<br>&gt;<br>&gt; let<br>&gt; order:Order,<br>&gt; person:People = .Lime<br>&gt;<br>&gt; order = person • {<br>&gt; $0 == .Kurtz → .First …<br>&gt; $0 == .Popescu → .Second …<br>&gt; $0 == .Lime → .Third …<br>&gt; .Unknown<br>&gt; }<br>&gt;<br>&gt;<br>&gt; I also have some trepidation about posting it here, because it might have<br>&gt; bugs. I wans&#39;t sure what &quot;precedence&quot; and &quot;associativity&quot; should be, for<br>&gt; example. But it does make it more convenient to test alternative characters<br>&gt; for operators, etc.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sat, Apr 9, 2016 at 12:05 AM, Vladimir.S via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On 09.04.2016 9:31, Brent Royal-Gordon wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; This design is still very much under development—it hasn&#39;t even been<br>&gt;&gt;&gt; reviewed, let alone added to the language. Here&#39;s the draft proposal:&lt;<br>&gt;&gt;&gt; https://github.com/jtbandes/swift-evolution/blob/case-enumerable/proposals/0000-derived-collection-of-enum-cases.md<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m not saying that this will necessarily be a solution that ends up<br>&gt;&gt;&gt; being accepted—I&#39;m merely saying that yes, it&#39;s something people are<br>&gt;&gt;&gt; thinking about and designing; it&#39;s just been inactive for a few weeks.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Oh, I see. Thank you for letting know. Just missed &quot;you would be able&quot; in<br>&gt;&gt; your previous message, did read it as &quot;you are able&quot;, so was trying to find<br>&gt;&gt; this in current Swift version. OK, glad to know that most likely we&#39;ll have<br>&gt;&gt; improvements in enums eterations for Swift 3.0.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/e34f9710/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>April  8, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Mar 23, 2016, at 5:13 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; * Allow you to attach member definitions to particular cases. It would be an error if they didn&#39;t all define the same members, unless there was a top-level catchall.<br>&gt; <br>&gt;    enum Suit: Int {<br>&gt;        var isRed: Bool { return false }<br>&gt; <br>&gt;        case Hearts {<br>&gt;            let description: String { return &quot;♥️&quot; }<br>&gt;            let isRed: Bool { return true }<br>&gt;        }<br>&gt;        case Spades {<br>&gt;            let description: String { return  &quot;♠️&quot; }<br>&gt;        }<br>&gt;        case Diamonds {<br>&gt;            let description: String { return  &quot;♦️&quot; }<br>&gt;            let isRed: Bool { return true }<br>&gt;        }<br>&gt;        case Clubs {<br>&gt;            let description: String { return  &quot;♣️&quot; }<br>&gt;        }<br>&gt; <br>&gt;        static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>&gt;    }<br></p><p>Oh my, I absolutely *love this.* This would be a godsend for making ErrorType enums that bridge nicely to NSErrors, with code and userInfo properties attached to each case.<br></p><p>+1.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160408/5a136682/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>[Idea] Find alternatives to `switch self`</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>April  8, 2016 at 03:00:00pm</p></header><div class="content"><p>Would this still be an issue if switch statements were less verbose? I<br>don&#39;t see why a &quot;switch&quot; statements should be so much more verbose than an<br>&quot;if statement&quot;.<br></p><p>Writing boiler plate for switch statements is by far my #1 irritation at<br>the moment (now that argument labels have been made beautiful - thanks! -<br>and Generics are being improved).<br></p><p>As Paul alluded to, this has been discussed with<br>https://github.com/cacruden/swift-evolution/blob/master/proposals/0024-Pattern-Matching-Partial-Function.md<br></p><p><br></p><p>On Fri, Apr 8, 2016 at 2:30 PM, Charles Srstka via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Mar 23, 2016, at 5:13 AM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; * Allow you to attach member definitions to particular cases. It would be<br>&gt; an error if they didn&#39;t all define the same members, unless there was a<br>&gt; top-level catchall.<br>&gt;<br>&gt;    enum Suit: Int {<br>&gt;        var isRed: Bool { return false }<br>&gt;<br>&gt;        case Hearts {<br>&gt;            let description: String { return &quot;♥️&quot; }<br>&gt;            let isRed: Bool { return true }<br>&gt;        }<br>&gt;        case Spades {<br>&gt;            let description: String { return  &quot;♠️&quot; }<br>&gt;        }<br>&gt;        case Diamonds {<br>&gt;            let description: String { return  &quot;♦️&quot; }<br>&gt;            let isRed: Bool { return true }<br>&gt;        }<br>&gt;        case Clubs {<br>&gt;            let description: String { return  &quot;♣️&quot; }<br>&gt;        }<br>&gt;<br>&gt;        static var all = [ Hearts, Spades, Diamonds, Clubs ]<br>&gt;    }<br>&gt;<br>&gt;<br>&gt; Oh my, I absolutely *love this.* This would be a godsend for making<br>&gt; ErrorType enums that bridge nicely to NSErrors, with code and userInfo<br>&gt; properties attached to each case.<br>&gt;<br>&gt; +1.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160408/1b0450f9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
