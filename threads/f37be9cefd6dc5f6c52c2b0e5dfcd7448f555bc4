<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be008d68993804f808aa56154ed5a4d1?s=50"></div><header><strong>Swift should support generics as arguments to closures in any context</strong> from <string>Spencer Kohan</string> &lt;spencerkohan at gmail.com&gt;<p>January 15, 2016 at 11:00:00am</p></header><div class="content"><p>New here, hope I&#39;m doing this right.<br></p><p>I recently found a use case which does not appear to be covered by the<br>swift language: it appears that there&#39;s no way to declare a closure type<br>with generic arguments.<br></p><p>For example, what if I&#39;m building an iOS app, and I want to define a<br>closure which operates on UIViewControllers which implement a particular<br>protocol?<br></p><p>In ObjectiveC, this would be possible with the following syntax:<br></p><p>    typedef void (^MyBlockType)(UIViewController&lt;MyProtocol&gt;)<br></p><p>In Swift you can do this in the context of a function, class or struct:<br></p><p>    func myFunction&lt;T: UIViewController where T:MyProtocol&gt;() {<br>        let x : (T) -&gt; () = { generic in<br>           ....<br>        }<br>    }<br></p><p>But what if you want to declare such a closure as a variable within the<br>protocol it&#39;s referring to?<br></p><p>    protocol MyProtocol {<br>        var protocolControllerCallback : (protocolController : ???? )-&gt;()<br>    }<br></p><p>It seems like Associated Types are the intended tool for this job, so you<br>could have something like:<br></p><p>    protocol MyProtocol {<br>        typealias ProtocolObservingController<br>        var protocolControllerCallback : (protocolController<br>: ProtocolObservingController )-&gt;() {get set}<br>    }<br></p><p>    class MyController : UIViewController, MyProtocol {<br>        typealias ProtocolObservingController = MyController<br>        ...<br>    }<br></p><p>But this doesn&#39;t quite solve the problem: we still can&#39;t have a closure<br>defined in this protocol which can operate on *any* implementations of the<br>protocol.  For instance, what if we wanted to pass a closure between two<br>different implementations?<br></p><p>    class MyChildController : UIViewController, MyProtocol {<br>        typealias ProtocolObservingController = MyChildController<br>        ...<br>    }<br></p><p>    class MyParentController : UIViewController, MyProtocol {<br>        typealias ProtocolObservingController = MyParentController<br>        ...<br></p><p>        func createChildController() -&gt; MyControllerChild {<br>            let child = MyChildController()<br>            child.protocolControllerCallback =<br>self.protocolControllerCallback<br>        }<br></p><p>    }<br></p><p>It doesn&#39;t work because the types of protocolControllerCallback are<br>inconsistent between the two classes.<br></p><p>This feels like a hole in the language.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/f37b5bc4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Swift should support generics as arguments to closures in any context</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 15, 2016 at 12:00:00pm</p></header><div class="content"><p>Are you sure that your problem is about generics on lambdas? Seems to me that you wouldn&#39;t need generic lambdas if you could solve your initial problem in a different way.<br></p><p>You can use Self in protocols, which refers to the implementing type:<br></p><p>&gt; protocol MyProtocol {<br>&gt; 	var protocolControllerCallback: Self -&gt; Void { get }<br>&gt; }<br>&gt; <br>&gt; class MyController: MyProtocol {<br>&gt; 	var protocolControllerCallback: MyController -&gt; Void<br>&gt; 	<br>&gt; 	init() {<br>&gt; 		protocolControllerCallback = { cnt in return }<br>&gt; 	}<br>&gt; }<br></p><p>That doesn&#39;t work right now because Swift will complain that the class must be `final` for reasons that sound bogus to me: &quot;it uses &#39;Self&#39; in a non-parameter, non-result type position&quot;. I don&#39;t know if there&#39;s a technical reason that it can&#39;t be in a closure parameter. Still seems to get you closer to what you want.<br></p><p>Félix<br></p><p>&gt; Le 15 janv. 2016 à 05:07:06, Spencer Kohan via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; New here, hope I&#39;m doing this right.<br>&gt; <br>&gt; I recently found a use case which does not appear to be covered by the swift language: it appears that there&#39;s no way to declare a closure type with generic arguments.<br>&gt; <br>&gt; For example, what if I&#39;m building an iOS app, and I want to define a closure which operates on UIViewControllers which implement a particular protocol?<br>&gt; <br>&gt; In ObjectiveC, this would be possible with the following syntax:<br>&gt; <br>&gt;     typedef void (^MyBlockType)(UIViewController&lt;MyProtocol&gt;)<br>&gt; <br>&gt; In Swift you can do this in the context of a function, class or struct:<br>&gt; <br>&gt;     func myFunction&lt;T: UIViewController where T:MyProtocol&gt;() {<br>&gt;         let x : (T) -&gt; () = { generic in<br>&gt;            ....<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; But what if you want to declare such a closure as a variable within the protocol it&#39;s referring to?<br>&gt; <br>&gt;     protocol MyProtocol {<br>&gt;         var protocolControllerCallback : (protocolController : ???? )-&gt;()<br>&gt;     }<br>&gt; <br>&gt; It seems like Associated Types are the intended tool for this job, so you could have something like:<br>&gt; <br>&gt;     protocol MyProtocol {<br>&gt;         typealias ProtocolObservingController<br>&gt;         var protocolControllerCallback : (protocolController : ProtocolObservingController )-&gt;() {get set}<br>&gt;     }<br>&gt; <br>&gt;     class MyController : UIViewController, MyProtocol {<br>&gt;         typealias ProtocolObservingController = MyController<br>&gt;         ...<br>&gt;     }<br>&gt; <br>&gt; But this doesn&#39;t quite solve the problem: we still can&#39;t have a closure defined in this protocol which can operate on *any* implementations of the protocol.  For instance, what if we wanted to pass a closure between two different implementations?<br>&gt; <br>&gt;     class MyChildController : UIViewController, MyProtocol {<br>&gt;         typealias ProtocolObservingController = MyChildController<br>&gt;         ...<br>&gt;     }<br>&gt; <br>&gt;     class MyParentController : UIViewController, MyProtocol {<br>&gt;         typealias ProtocolObservingController = MyParentController<br>&gt;         ...<br>&gt; <br>&gt;         func createChildController() -&gt; MyControllerChild {<br>&gt;             let child = MyChildController()<br>&gt;             child.protocolControllerCallback = self.protocolControllerCallback<br>&gt;         }<br>&gt; <br>&gt;     }<br>&gt; <br>&gt; It doesn&#39;t work because the types of protocolControllerCallback are inconsistent between the two classes.<br>&gt; <br>&gt; This feels like a hole in the language.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/20844f2c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be008d68993804f808aa56154ed5a4d1?s=50"></div><header><strong>Swift should support generics as arguments to closures in any context</strong> from <string>Spencer Kohan</string> &lt;spencerkohan at gmail.com&gt;<p>January 15, 2016 at 11:00:00pm</p></header><div class="content"><p>If I understand correctly, this still doesn&#39;t solve the problem exactly.<br>Wouldn&#39;t Self in this context refer to the class that implements MyProtocol?<br></p><p>The example I raised is just a single use-case I ran into, but I think the<br>more general point is that there isn&#39;t a good way to tell the compiler that<br>a closure parameter must belong to more than one protocol, or a type plus a<br>protocol.<br></p><p>Here&#39;s another (somewhat contrived) example:<br></p><p>Say I was writing an application like IMDB, and I had a protocol for<br>directors and another for writers:<br></p><p>    protocol Director {<br>        func directingCredits() -&gt; [Film]<br>    }<br></p><p>    protocol Writer {<br>        func writingCredits() -&gt; [Film]<br>    }<br></p><p>And I want to have a closure which returns all the movies written and<br>directed by the same person:<br></p><p>    var getWrittenAndDirectedFilms : (&lt;Writer, Director&gt;)-&gt;[Film] = {<br>writerDirector in<br>        return  writerDirector.writingCredits().filter {<br>writerDirector.directingCredits().contains($0) }<br>    }<br></p><p>Not all writers are directors, and not all directors are writers, but it&#39;s<br>perfectly reasonable to have an operation which only works on objects which<br>conform to those two protocols.<br></p><p>It&#39;s easy to write a plain function that handles this use case using<br>generics, but it&#39;s not possible with a closure.  It seems like an<br>unnecessary limitation.<br></p><p>On Fri, Jan 15, 2016 at 6:01 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br></p><p>&gt; Are you sure that your problem is about generics on lambdas? Seems to me<br>&gt; that you wouldn&#39;t need generic lambdas if you could solve your initial<br>&gt; problem in a different way.<br>&gt;<br>&gt; You can use Self in protocols, which refers to the implementing type:<br>&gt;<br>&gt; protocol MyProtocol {<br>&gt; var protocolControllerCallback: Self -&gt; Void { get }<br>&gt; }<br>&gt;<br>&gt; class MyController: MyProtocol {<br>&gt; var protocolControllerCallback: MyController -&gt; Void<br>&gt; init() {<br>&gt; protocolControllerCallback = { cnt in return }<br>&gt; }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; That doesn&#39;t work right now because Swift will complain that the class<br>&gt; must be `final` for reasons that sound bogus to me: &quot;it uses &#39;Self&#39; in a<br>&gt; non-parameter, non-result type position&quot;. I don&#39;t know if there&#39;s a<br>&gt; technical reason that it can&#39;t be in a closure parameter. Still seems to<br>&gt; get you closer to what you want.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 15 janv. 2016 à 05:07:06, Spencer Kohan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; New here, hope I&#39;m doing this right.<br>&gt;<br>&gt; I recently found a use case which does not appear to be covered by the<br>&gt; swift language: it appears that there&#39;s no way to declare a closure type<br>&gt; with generic arguments.<br>&gt;<br>&gt; For example, what if I&#39;m building an iOS app, and I want to define a<br>&gt; closure which operates on UIViewControllers which implement a particular<br>&gt; protocol?<br>&gt;<br>&gt; In ObjectiveC, this would be possible with the following syntax:<br>&gt;<br>&gt;     typedef void (^MyBlockType)(UIViewController&lt;MyProtocol&gt;)<br>&gt;<br>&gt; In Swift you can do this in the context of a function, class or struct:<br>&gt;<br>&gt;     func myFunction&lt;T: UIViewController where T:MyProtocol&gt;() {<br>&gt;         let x : (T) -&gt; () = { generic in<br>&gt;            ....<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt; But what if you want to declare such a closure as a variable within the<br>&gt; protocol it&#39;s referring to?<br>&gt;<br>&gt;     protocol MyProtocol {<br>&gt;         var protocolControllerCallback : (protocolController : ???? )-&gt;()<br>&gt;     }<br>&gt;<br>&gt; It seems like Associated Types are the intended tool for this job, so you<br>&gt; could have something like:<br>&gt;<br>&gt;     protocol MyProtocol {<br>&gt;         typealias ProtocolObservingController<br>&gt;         var protocolControllerCallback : (protocolController<br>&gt; : ProtocolObservingController )-&gt;() {get set}<br>&gt;     }<br>&gt;<br>&gt;     class MyController : UIViewController, MyProtocol {<br>&gt;         typealias ProtocolObservingController = MyController<br>&gt;         ...<br>&gt;     }<br>&gt;<br>&gt; But this doesn&#39;t quite solve the problem: we still can&#39;t have a closure<br>&gt; defined in this protocol which can operate on *any* implementations of the<br>&gt; protocol.  For instance, what if we wanted to pass a closure between two<br>&gt; different implementations?<br>&gt;<br>&gt;     class MyChildController : UIViewController, MyProtocol {<br>&gt;         typealias ProtocolObservingController = MyChildController<br>&gt;         ...<br>&gt;     }<br>&gt;<br>&gt;     class MyParentController : UIViewController, MyProtocol {<br>&gt;         typealias ProtocolObservingController = MyParentController<br>&gt;         ...<br>&gt;<br>&gt;         func createChildController() -&gt; MyControllerChild {<br>&gt;             let child = MyChildController()<br>&gt;             child.protocolControllerCallback =<br>&gt; self.protocolControllerCallback<br>&gt;         }<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; It doesn&#39;t work because the types of protocolControllerCallback are<br>&gt; inconsistent between the two classes.<br>&gt;<br>&gt; This feels like a hole in the language.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>Spencer Kohan<br>cell: 216 288 8258<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/481c1844/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Swift should support generics as arguments to closures in any context</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 15, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; there isn&#39;t a good way to tell the compiler that a closure parameter must belong to more than one protocol, or a type plus a protocol.<br></p><p>There is a way to do two protocols:<br></p><p>	protocol A {}<br>	protocol B {}<br>	let closure: (protocol&lt;A, B&gt; -&gt; Void) = { _ in }<br></p><p>I think this should probably be extended to allow one of the listed protocols to be a class. (There&#39;s no need to support structs or enums, since you know their conformances.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
