<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>[Pitch] Removing the empty initialiser requirement from RangeReplaceableCollection</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>July  7, 2016 at 07:00:00am</p></header><div class="content"><p>This is a follow up from this swift-users thread: https://lists.swift.org/pipermail/swift-users/Week-of-Mon-20160704/002489.html<br></p><p>As it stands, RangeReplaceableCollection requires an implementation for init(), which is used in the default implementations of (as far as I can tell) init(_:), init(repeating:count:) and removeAll(keepingCapacity:). The latter of these methods should be implementable with removeSubrange(_:) instead.<br></p><p>I would like to propose to *remove* all three initialisers from this protocol, because it makes it impossible for some collections to conform to it that need extra data for its initialisation, but are otherwise perfectly capable of having arbitrary subranges replaced by elements from another collection. Those three initialisers could either move to a new protocol or simply not be part of any protocol.<br></p><p>On a similar note, I’d like to have all initialisers of SetAlgebra removed as well, but that might need its own review.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Removing the empty initialiser requirement from RangeReplaceableCollection</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July  7, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 7 Jul 2016, at 06:50, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is a follow up from this swift-users thread: https://lists.swift.org/pipermail/swift-users/Week-of-Mon-20160704/002489.html<br>&gt; <br>&gt; As it stands, RangeReplaceableCollection requires an implementation for init(), which is used in the default implementations of (as far as I can tell) init(_:), init(repeating:count:) and removeAll(keepingCapacity:). The latter of these methods should be implementable with removeSubrange(_:) instead.<br>&gt; <br>&gt; I would like to propose to *remove* all three initialisers from this protocol, because it makes it impossible for some collections to conform to it that need extra data for its initialisation, but are otherwise perfectly capable of having arbitrary subranges replaced by elements from another collection. Those three initialisers could either move to a new protocol or simply not be part of any protocol.<br></p><p>+1 from me, if the ability to Self() initialise isn&#39;t absolutely required then these should be removed.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Removing the empty initialiser requirement from RangeReplaceableCollection</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July  7, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 7 Jul 2016, at 07:50, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is a follow up from this swift-users thread: https://lists.swift.org/pipermail/swift-users/Week-of-Mon-20160704/002489.html<br>&gt; <br>&gt; As it stands, RangeReplaceableCollection requires an implementation for init(), which is used in the default implementations of (as far as I can tell) init(_:), init(repeating:count:) and removeAll(keepingCapacity:). The latter of these methods should be implementable with removeSubrange(_:) instead.<br>&gt; <br>&gt; I would like to propose to *remove* all three initialisers from this protocol, because it makes it impossible for some collections to conform to it that need extra data for its initialisation, but are otherwise perfectly capable of having arbitrary subranges replaced by elements from another collection. Those three initialisers could either move to a new protocol or simply not be part of any protocol.<br>&gt; <br>&gt; On a similar note, I’d like to have all initialisers of SetAlgebra removed as well, but that might need its own review.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>I believe the idea of RRC is that all you need to implement is the empty initialiser and replaceSubrange(), and everything else (e.g. Append, insert) is implemented in terms of those. Even the initialiser which takes existing collection just initialises and empty one and appends the existing collection (I.e. Calling replaceSubrange).<br></p><p>If I understand you correctly, it will not be possible to initialise a generic RRC any more, will it? Because that RRC may need additional information (e.g. A maximum buffer size if it stores its data in multiple discrete buffers) which you can’t provide generically.<br></p><p>Maybe we could have a true copy-constructor instead? That is, replace init&lt;C:Collection&gt;(_:) with init(_: Self), so that it could take any additional arguments from that other instance?<br></p><p>Karl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Removing the empty initialiser requirement from RangeReplaceableCollection</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July  7, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 7 Jul 2016, at 16:57, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 7 Jul 2016, at 07:50, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is a follow up from this swift-users thread: https://lists.swift.org/pipermail/swift-users/Week-of-Mon-20160704/002489.html<br>&gt;&gt; <br>&gt;&gt; As it stands, RangeReplaceableCollection requires an implementation for init(), which is used in the default implementations of (as far as I can tell) init(_:), init(repeating:count:) and removeAll(keepingCapacity:). The latter of these methods should be implementable with removeSubrange(_:) instead.<br>&gt;&gt; <br>&gt;&gt; I would like to propose to *remove* all three initialisers from this protocol, because it makes it impossible for some collections to conform to it that need extra data for its initialisation, but are otherwise perfectly capable of having arbitrary subranges replaced by elements from another collection. Those three initialisers could either move to a new protocol or simply not be part of any protocol.<br>&gt;&gt; <br>&gt;&gt; On a similar note, I’d like to have all initialisers of SetAlgebra removed as well, but that might need its own review.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; I believe the idea of RRC is that all you need to implement is the empty initialiser and replaceSubrange(), and everything else (e.g. Append, insert) is implemented in terms of those. Even the initialiser which takes existing collection just initialises and empty one and appends the existing collection (I.e. Calling replaceSubrange).<br>&gt; <br>&gt; If I understand you correctly, it will not be possible to initialise a generic RRC any more, will it? Because that RRC may need additional information (e.g. A maximum buffer size if it stores its data in multiple discrete buffers) which you can’t provide generically.<br>&gt; <br>&gt; Maybe we could have a true copy-constructor instead? That is, replace init&lt;C:Collection&gt;(_:) with init(_: Self), so that it could take any additional arguments from that other instance?<br>&gt; <br>&gt; Karl<br></p><p>Actually, a real copy-constructor would be a huge improvement in any case. Sometimes you want to copy a collection, but new Swift users may just assign it to a new reference expecting copy-on-write semantics. That will work for standard-library collections, but perhaps not for a collection which is a class. A formal copy constructor would solve that, but may be getting out of scope (or not, depending on what you were using those existing initialisers for…)<br></p><p>Karl<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>[Pitch] Removing the empty initialiser requirement from RangeReplaceableCollection</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>July  7, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 7 Jul 2016, at 16:57, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 7 Jul 2016, at 07:50, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is a follow up from this swift-users thread: https://lists.swift.org/pipermail/swift-users/Week-of-Mon-20160704/002489.html<br>&gt;&gt; <br>&gt;&gt; As it stands, RangeReplaceableCollection requires an implementation for init(), which is used in the default implementations of (as far as I can tell) init(_:), init(repeating:count:) and removeAll(keepingCapacity:). The latter of these methods should be implementable with removeSubrange(_:) instead.<br>&gt;&gt; <br>&gt;&gt; I would like to propose to *remove* all three initialisers from this protocol, because it makes it impossible for some collections to conform to it that need extra data for its initialisation, but are otherwise perfectly capable of having arbitrary subranges replaced by elements from another collection. Those three initialisers could either move to a new protocol or simply not be part of any protocol.<br>&gt;&gt; <br>&gt;&gt; On a similar note, I’d like to have all initialisers of SetAlgebra removed as well, but that might need its own review.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; I believe the idea of RRC is that all you need to implement is the empty initialiser and replaceSubrange(), and everything else (e.g. Append, insert) is implemented in terms of those.<br></p><p>Right, but as it turns out, the empty initialiser is used in barely any of them.<br></p><p>&gt; Even the initialiser which takes existing collection just initialises and empty one and appends the existing collection (I.e. Calling replaceSubrange).<br>&gt; <br>&gt; If I understand you correctly, it will not be possible to initialise a generic RRC any more, will it? Because that RRC may need additional information (e.g. A maximum buffer size if it stores its data in multiple discrete buffers) which you can’t provide generically.<br></p><p>Correct. I haven’t come up with a use for initialising a generic RRC anyways, mostly because I think there are RRCs for which an empty init wouldn’t make any sense.<br></p><p>&gt; <br>&gt; Maybe we could have a true copy-constructor instead? That is, replace init&lt;C:Collection&gt;(_:) with init(_: Self), so that it could take any additional arguments from that other instance?<br></p><p>This is certainly an improvement over init(), but what would it be used for with regards to this particular protocol? It might certainly be useful, but the empty initialiser can be useful as well; it’s just a matter of how relevant that method is to this protocol. Wouldn’t a copy constructor make more sense in the more general Collection protocol?<br></p><p>&gt; <br>&gt; Karl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Removing the empty initialiser requirement from RangeReplaceableCollection</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July  7, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 7 Jul 2016, at 17:19, Tim Vermeulen &lt;tvermeulen at me.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 7 Jul 2016, at 16:57, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 7 Jul 2016, at 07:50, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a follow up from this swift-users thread: https://lists.swift.org/pipermail/swift-users/Week-of-Mon-20160704/002489.html<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As it stands, RangeReplaceableCollection requires an implementation for init(), which is used in the default implementations of (as far as I can tell) init(_:), init(repeating:count:) and removeAll(keepingCapacity:). The latter of these methods should be implementable with removeSubrange(_:) instead.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would like to propose to *remove* all three initialisers from this protocol, because it makes it impossible for some collections to conform to it that need extra data for its initialisation, but are otherwise perfectly capable of having arbitrary subranges replaced by elements from another collection. Those three initialisers could either move to a new protocol or simply not be part of any protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On a similar note, I’d like to have all initialisers of SetAlgebra removed as well, but that might need its own review.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; I believe the idea of RRC is that all you need to implement is the empty initialiser and replaceSubrange(), and everything else (e.g. Append, insert) is implemented in terms of those.<br>&gt; <br>&gt; Right, but as it turns out, the empty initialiser is used in barely any of them.<br>&gt; <br>&gt;&gt; Even the initialiser which takes existing collection just initialises and empty one and appends the existing collection (I.e. Calling replaceSubrange).<br>&gt;&gt; <br>&gt;&gt; If I understand you correctly, it will not be possible to initialise a generic RRC any more, will it? Because that RRC may need additional information (e.g. A maximum buffer size if it stores its data in multiple discrete buffers) which you can’t provide generically.<br>&gt; <br>&gt; Correct. I haven’t come up with a use for initialising a generic RRC anyways, mostly because I think there are RRCs for which an empty init wouldn’t make any sense.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Maybe we could have a true copy-constructor instead? That is, replace init&lt;C:Collection&gt;(_:) with init(_: Self), so that it could take any additional arguments from that other instance?<br>&gt; <br>&gt; This is certainly an improvement over init(), but what would it be used for with regards to this particular protocol? It might certainly be useful, but the empty initialiser can be useful as well; it’s just a matter of how relevant that method is to this protocol. Wouldn’t a copy constructor make more sense in the more general Collection protocol?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Karl<br></p><p>I have a use-case: I have a struct which wraps a RangeReplaceableCollection and allows you to tag ranges of indices with random objects (it’s actually pretty cool, it can automatically merge adjacent ranges of Equatables — sort of like a pure-Swift NSAttributedString). It needs to create a new collection (currently via the initialiser, but a copy-constructor would also be fine), because it needs to own the indexes for mutability guarantees.<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/abd57c48/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Removing the empty initialiser requirement from RangeReplaceableCollection</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July  7, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 7 Jul 2016, at 19:10, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 7 Jul 2016, at 17:19, Tim Vermeulen &lt;tvermeulen at me.com &lt;mailto:tvermeulen at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 7 Jul 2016, at 16:57, Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 7 Jul 2016, at 07:50, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a follow up from this swift-users thread: https://lists.swift.org/pipermail/swift-users/Week-of-Mon-20160704/002489.html &lt;https://lists.swift.org/pipermail/swift-users/Week-of-Mon-20160704/002489.html&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As it stands, RangeReplaceableCollection requires an implementation for init(), which is used in the default implementations of (as far as I can tell) init(_:), init(repeating:count:) and removeAll(keepingCapacity:). The latter of these methods should be implementable with removeSubrange(_:) instead.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would like to propose to *remove* all three initialisers from this protocol, because it makes it impossible for some collections to conform to it that need extra data for its initialisation, but are otherwise perfectly capable of having arbitrary subranges replaced by elements from another collection. Those three initialisers could either move to a new protocol or simply not be part of any protocol.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On a similar note, I’d like to have all initialisers of SetAlgebra removed as well, but that might need its own review.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe the idea of RRC is that all you need to implement is the empty initialiser and replaceSubrange(), and everything else (e.g. Append, insert) is implemented in terms of those.<br>&gt;&gt; <br>&gt;&gt; Right, but as it turns out, the empty initialiser is used in barely any of them.<br>&gt;&gt; <br>&gt;&gt;&gt; Even the initialiser which takes existing collection just initialises and empty one and appends the existing collection (I.e. Calling replaceSubrange).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If I understand you correctly, it will not be possible to initialise a generic RRC any more, will it? Because that RRC may need additional information (e.g. A maximum buffer size if it stores its data in multiple discrete buffers) which you can’t provide generically.<br>&gt;&gt; <br>&gt;&gt; Correct. I haven’t come up with a use for initialising a generic RRC anyways, mostly because I think there are RRCs for which an empty init wouldn’t make any sense.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe we could have a true copy-constructor instead? That is, replace init&lt;C:Collection&gt;(_:) with init(_: Self), so that it could take any additional arguments from that other instance?<br>&gt;&gt; <br>&gt;&gt; This is certainly an improvement over init(), but what would it be used for with regards to this particular protocol? It might certainly be useful, but the empty initialiser can be useful as well; it’s just a matter of how relevant that method is to this protocol. Wouldn’t a copy constructor make more sense in the more general Collection protocol?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Karl<br>&gt; <br>&gt; I have a use-case: I have a struct which wraps a RangeReplaceableCollection and allows you to tag ranges of indices with random objects (it’s actually pretty cool, it can automatically merge adjacent ranges of Equatables — sort of like a pure-Swift NSAttributedString). It needs to create a new collection (currently via the initialiser, but a copy-constructor would also be fine), because it needs to own the indexes for mutability guarantees.<br>&gt; <br>&gt; Karl<br></p><p><br>What I mean by that is that the wrapper needs to make sure that you never mutate the collection it references outside of its own replaceSubrange. Otherwise the parallel collection of tagged indexes would go out-of-sync.<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/0396b080/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Removing the empty initialiser requirement from RangeReplaceableCollection</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July  7, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 7 Jul 2016, at 15:57, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I believe the idea of RRC is that all you need to implement is the empty initialiser and replaceSubrange(), and everything else (e.g. Append, insert) is implemented in terms of those. Even the initialiser which takes existing collection just initialises and empty one and appends the existing collection (I.e. Calling replaceSubrange).<br>&gt; <br>&gt; If I understand you correctly, it will not be possible to initialise a generic RRC any more, will it? Because that RRC may need additional information (e.g. A maximum buffer size if it stores its data in multiple discrete buffers) which you can’t provide generically.<br>&gt; <br>&gt; Maybe we could have a true copy-constructor instead? That is, replace init&lt;C:Collection&gt;(_:) with init(_: Self), so that it could take any additional arguments from that other instance?<br></p><p>A copying initialiser could work, but it should probably have a parameter for the type of copy to create (empty, shallow copy and deep copy for example), as I suspect it&#39;s the empty copy that RangeReplaceableCollection needs more than anything. Otherwise it shouldn&#39;t need initialisers on the protocol. This however is something that could (and should) be moved out into its own protocol I think, with RangeReplaceableCollection simply conforming that.<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
