<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Discussion] Binary search, lower bound, upper bound, equal range</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 15, 2016 at 01:00:00pm</p></header><div class="content"><p>on Mon Feb 15 2016, Jeff Hajewski &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello,<br>&gt;<br>&gt; I am working on SR-368 &lt;https://bugs.swift.org/browse/SR-368&gt; and am hoping to get some feedback from the community.<br>&gt;<br>&gt; Description<br>&gt; Implement analogs to C++’s binary_search, lower_bound, upper_bound, and equal_range algorithms.<br>&gt;<br>&gt; Initial Proposal<br>&gt; I propose adding four methods for generic Array and adding four<br>&gt; methods for Arrays that conform to Comparable:<br>&gt;<br>&gt; Array<br>&gt; @warn_unused_result<br>&gt; func lowerBound(value: Array.Element, @noescape isOrderedBefore: (lhs:<br>&gt; Array.Element, rhs: Array.Element) -&gt; Bool) -&gt; Int?<br>&gt;<br>&gt; @warn_unused_result<br>&gt; func upperBound(value: Array.Element, @noescape isOrderedBefore: (lhs:<br>&gt; Array.Element, rhs: Array.Element) -&gt; Bool) -&gt; Int?<br>&gt;<br>&gt; @warn_unused_result<br>&gt; func binarySearch(value: Array.Element, @noescape<br>&gt; isOrderedBefore:(lhs: Array.Element, rhs: Array.Element) -&gt; Bool) -&gt;<br>&gt; Bool<br>&gt;<br>&gt; @warn_unused_result<br>&gt; func equalRange(value: Array.Element, @noescape isOrderedBefore: (lhs:<br>&gt; Array.Element, rhs: Array.Element) -&gt; Bool) -&gt; Range&lt;Int&gt;?<br>&gt;<br>&gt; Array: Comparable<br>&gt; @warn_unused_result<br>&gt; func lowerBound(value: Array.Element) -&gt; Int?<br>&gt;<br>&gt; @warn_unused_result<br>&gt; func upperBound(value: Array.Element) -&gt; Int?<br>&gt;<br>&gt; @warn_unused_result<br>&gt; func binarySearch(value: Array.Element) -&gt; Bool<br>&gt;<br>&gt; @warn_unused_result<br>&gt; func equalRange(value: Array.Element) -&gt; Range&lt;Int&gt;?<br>&gt;<br>&gt; Discussion<br>&gt; The main issue I’d like to discuss is how do we want to add these to Swift? My thoughts are as follows:<br>&gt;<br>&gt; These should be as generic as possible. I initially started at the<br>&gt; CollectionType level but it seemed that the problem was ultimately<br>&gt; reduced to an Array (through the use of various protocols, etc.). <br></p><p>These should be defined on CollectionType Note that you don&#39;t need<br>random access to get an advantage from binary search if the comparison<br>is sufficiently expensive.<br></p><p>&gt; For example, suppose we implemented these methods as an extension to<br>&gt; CollectionType, if we were to try and call binarySearch on a set, we<br>&gt; would first need to sort the set, which would return an array, and<br>&gt; then we would call binarySearch on that array. <br></p><p>It should work on any arbitrary collection.  The collections you know<br>are not the only ones that matter.  For examples, consider binary<br>searching the result of applying a lazy map or filter to some sorted<br>array.<br></p><p>&gt; Similarly, it seems at the SequenceType level the problem ultimately<br>&gt; reduces to using Array.<br></p><p>Sequences don&#39;t have indices; you can&#39;t binary search them.<br></p><p>&gt; Does it make sense to handle these as public functions? I tend to<br>&gt; think not as it seems less idiomatic.  I suggest eight implementations<br>&gt; similar to how sort() is handled. If the calling array’s elements<br>&gt; conform to Comparable, then no isOrderedBefore closure is required<br>&gt; since we can use “&lt;“, otherwise the user should supply a closure to<br>&gt; allow the algorithm determine how the array elements are ordered.<br></p><p>The general form takes a closure that partitions the collection; see<br>http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2001/n1313.html and<br>http://wg21.cmeerw.net/lwg/issue270<br></p><p>I would suggest avoiding the API choice that requires both a comparison<br>closure *and* an element against which to compare, as a unary<br>partitioning predicate is much simpler.<br></p><p>&gt; Similar to the C++ implementations, I avoid recursion and favor<br>&gt; while-loops.<br></p><p><br>Have an implementation is important as proof-of-concept and for<br>performance testing, but I don&#39;t consider the details important at this<br>stage.<br></p><p>&gt; These methods should be preconditioned on the calling<br>&gt; array be partitioned with respect to the passed value. <br>&gt; As far as I’m aware, there is no “isPartitioned(value:)” method<br>&gt; currently available. <br>&gt;<br>&gt; Should we add this as well? We could use this functionality and not<br>&gt; add a isPartitioned method but if we are adding this functionality is<br>&gt; there a good reason not to give the public access?  <br></p><p>Seems like a separable proposal.<br></p><p>&gt; The alternative is to not set a precondition and document that the<br>&gt; results may not be valid if the calling array is not partitioned with<br>&gt; respect to value. <br></p><p>That *is* a precondition.  Not all preconditions can or should be<br>verfied at runtime.  We would never make the caller pay to actually<br>verify at runtime that the collection is partitioned w.r.t. the closure;<br>that would make the whole operation O(N) and effectively discard any<br>benefit of binary-searching.<br></p><p>&gt; I favor the preconditioning approach.<br>&gt;<br>&gt; Any and all feedback is greatly appreciated!<br></p><p><br>HTH,<br>Dave<br></p><p><br>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30e4ca9ef73f6a84d52c26952c180bcd?s=50"></div><header><strong>[Discussion] Binary search, lower bound, upper bound, equal range</strong> from <string>Jeff Hajewski</string> &lt;jeff.hajewski at gmail.com&gt;<p>February 15, 2016 at 04:00:00pm</p></header><div class="content"><p>Dave,<br></p><p>Thanks a lot for the feedback - it is greatly appreciated. With respect to your comment about the unary partitioning predicate, I really like that idea and hadn’t thought of the problem like that. Excellent suggestion!<br></p><p>Thanks<br>Jeff<br></p><p>&gt; On Feb 15, 2016, at 4:34 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Feb 15 2016, Jeff Hajewski &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Hello,<br>&gt;&gt; <br>&gt;&gt; I am working on SR-368 &lt;https://bugs.swift.org/browse/SR-368&gt; and am hoping to get some feedback from the community.<br>&gt;&gt; <br>&gt;&gt; Description<br>&gt;&gt; Implement analogs to C++’s binary_search, lower_bound, upper_bound, and equal_range algorithms.<br>&gt;&gt; <br>&gt;&gt; Initial Proposal<br>&gt;&gt; I propose adding four methods for generic Array and adding four<br>&gt;&gt; methods for Arrays that conform to Comparable:<br>&gt;&gt; <br>&gt;&gt; Array<br>&gt;&gt; @warn_unused_result<br>&gt;&gt; func lowerBound(value: Array.Element, @noescape isOrderedBefore: (lhs:<br>&gt;&gt; Array.Element, rhs: Array.Element) -&gt; Bool) -&gt; Int?<br>&gt;&gt; <br>&gt;&gt; @warn_unused_result<br>&gt;&gt; func upperBound(value: Array.Element, @noescape isOrderedBefore: (lhs:<br>&gt;&gt; Array.Element, rhs: Array.Element) -&gt; Bool) -&gt; Int?<br>&gt;&gt; <br>&gt;&gt; @warn_unused_result<br>&gt;&gt; func binarySearch(value: Array.Element, @noescape<br>&gt;&gt; isOrderedBefore:(lhs: Array.Element, rhs: Array.Element) -&gt; Bool) -&gt;<br>&gt;&gt; Bool<br>&gt;&gt; <br>&gt;&gt; @warn_unused_result<br>&gt;&gt; func equalRange(value: Array.Element, @noescape isOrderedBefore: (lhs:<br>&gt;&gt; Array.Element, rhs: Array.Element) -&gt; Bool) -&gt; Range&lt;Int&gt;?<br>&gt;&gt; <br>&gt;&gt; Array: Comparable<br>&gt;&gt; @warn_unused_result<br>&gt;&gt; func lowerBound(value: Array.Element) -&gt; Int?<br>&gt;&gt; <br>&gt;&gt; @warn_unused_result<br>&gt;&gt; func upperBound(value: Array.Element) -&gt; Int?<br>&gt;&gt; <br>&gt;&gt; @warn_unused_result<br>&gt;&gt; func binarySearch(value: Array.Element) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; @warn_unused_result<br>&gt;&gt; func equalRange(value: Array.Element) -&gt; Range&lt;Int&gt;?<br>&gt;&gt; <br>&gt;&gt; Discussion<br>&gt;&gt; The main issue I’d like to discuss is how do we want to add these to Swift? My thoughts are as follows:<br>&gt;&gt; <br>&gt;&gt; These should be as generic as possible. I initially started at the<br>&gt;&gt; CollectionType level but it seemed that the problem was ultimately<br>&gt;&gt; reduced to an Array (through the use of various protocols, etc.). <br>&gt; <br>&gt; These should be defined on CollectionType Note that you don&#39;t need<br>&gt; random access to get an advantage from binary search if the comparison<br>&gt; is sufficiently expensive.<br>&gt; <br>&gt;&gt; For example, suppose we implemented these methods as an extension to<br>&gt;&gt; CollectionType, if we were to try and call binarySearch on a set, we<br>&gt;&gt; would first need to sort the set, which would return an array, and<br>&gt;&gt; then we would call binarySearch on that array. <br>&gt; <br>&gt; It should work on any arbitrary collection.  The collections you know<br>&gt; are not the only ones that matter.  For examples, consider binary<br>&gt; searching the result of applying a lazy map or filter to some sorted<br>&gt; array.<br>&gt; <br>&gt;&gt; Similarly, it seems at the SequenceType level the problem ultimately<br>&gt;&gt; reduces to using Array.<br>&gt; <br>&gt; Sequences don&#39;t have indices; you can&#39;t binary search them.<br>&gt; <br>&gt;&gt; Does it make sense to handle these as public functions? I tend to<br>&gt;&gt; think not as it seems less idiomatic.  I suggest eight implementations<br>&gt;&gt; similar to how sort() is handled. If the calling array’s elements<br>&gt;&gt; conform to Comparable, then no isOrderedBefore closure is required<br>&gt;&gt; since we can use “&lt;“, otherwise the user should supply a closure to<br>&gt;&gt; allow the algorithm determine how the array elements are ordered.<br>&gt; <br>&gt; The general form takes a closure that partitions the collection; see<br>&gt; http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2001/n1313.html and<br>&gt; http://wg21.cmeerw.net/lwg/issue270<br>&gt; <br>&gt; I would suggest avoiding the API choice that requires both a comparison<br>&gt; closure *and* an element against which to compare, as a unary<br>&gt; partitioning predicate is much simpler.<br>&gt; <br>&gt;&gt; Similar to the C++ implementations, I avoid recursion and favor<br>&gt;&gt; while-loops.<br>&gt; <br>&gt; <br>&gt; Have an implementation is important as proof-of-concept and for<br>&gt; performance testing, but I don&#39;t consider the details important at this<br>&gt; stage.<br>&gt; <br>&gt;&gt; These methods should be preconditioned on the calling<br>&gt;&gt; array be partitioned with respect to the passed value. <br>&gt;&gt; As far as I’m aware, there is no “isPartitioned(value:)” method<br>&gt;&gt; currently available. <br>&gt;&gt; <br>&gt;&gt; Should we add this as well? We could use this functionality and not<br>&gt;&gt; add a isPartitioned method but if we are adding this functionality is<br>&gt;&gt; there a good reason not to give the public access?  <br>&gt; <br>&gt; Seems like a separable proposal.<br>&gt; <br>&gt;&gt; The alternative is to not set a precondition and document that the<br>&gt;&gt; results may not be valid if the calling array is not partitioned with<br>&gt;&gt; respect to value. <br>&gt; <br>&gt; That *is* a precondition.  Not all preconditions can or should be<br>&gt; verfied at runtime.  We would never make the caller pay to actually<br>&gt; verify at runtime that the collection is partitioned w.r.t. the closure;<br>&gt; that would make the whole operation O(N) and effectively discard any<br>&gt; benefit of binary-searching.<br>&gt; <br>&gt;&gt; I favor the preconditioning approach.<br>&gt;&gt; <br>&gt;&gt; Any and all feedback is greatly appreciated!<br>&gt; <br>&gt; <br>&gt; HTH,<br>&gt; Dave<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Discussion] Binary search, lower bound, upper bound, equal range</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>February 16, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt; On Mon Feb 15 2016, Jeff Hajewski &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I am working on SR-368 &lt;https://bugs.swift.org/browse/SR-368&gt; and am hoping to get some feedback from the community.<br></p><p><br>Definitely +1!<br></p><p>Shameless plug:<br></p><p>I&#39;ve played with this idea in the past, implementing all of the four suggested binary searches as generic functions over index ranges or collections, using a custom 3-way comparator. The commented code and unit tests are found in https://github.com/knomi/Allsorts &lt;https://github.com/knomi/Allsorts&gt;. The library is also somewhat tested in production.<br></p><p>let i: Int        = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;,&quot;d&quot;,&quot;f&quot;,&quot;f&quot;].binarySearch(&quot;c&quot;)           //=&gt; 2, 3 or 4<br>let j: Int?       = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;,&quot;d&quot;,&quot;f&quot;,&quot;f&quot;].binaryFind(&quot;e&quot;)             //=&gt; nil<br>// Compare values to &quot;e&quot;. `a &lt;=&gt; b` performs a 3-way comparison, returning .LT, .EQ or .GT<br>let k: Int        = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;,&quot;d&quot;,&quot;f&quot;,&quot;f&quot;].lowerBound {x in x &lt;=&gt; &quot;e&quot;} //=&gt; 6<br>// Reverse order (the arguments of &lt;=&gt; are flipped):<br>let r: Range&lt;Int&gt; = [&quot;e&quot;,&quot;e&quot;,&quot;d&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;,&quot;b&quot;,&quot;a&quot;].equalRange {x in &quot;c&quot; &lt;=&gt; x} //=&gt; 3 ..&lt; 6<br></p><p>I&#39;d be happy to join forces in making the algorithms available in the standard library.<br></p><p>I believe that my code tackles many points Dave mentioned:<br></p><p>(1) You don&#39;t need to construct an element just to perform the search. You only need a function to tell if the search should proceed to the left or right, or if there&#39;s a match.<br></p><p>(2) You don&#39;t really need to a concrete collection either. A Range&lt;Int&gt; will do just as fine, as long as you&#39;re able to say how those indices should be compared to each other (usually by looking up somewhere else).<br></p><p>(3) The collection can be sorted by any comparator (which I call an &quot;ordering&quot;), as long as you pass that information along as the closure (the ordering).<br></p><p>(4) I use three-way comparisons to avoid extra work comparing e.g. strings.<br>Turns out comparisons defined that way also compose amazingly well, see first examples in README.<br>There&#39;s an operator &quot;x &lt;=&gt; y&quot; returning Ordering.LT, .EQ, or .GT instead of just Bool. However, that operator has little to do with the implementation of binary search.<br>(The topic of three-way comparisons was discussed earlier &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009127.html&gt; in swift-evolution. I think it should find its way into the Comparable protocol directly, as an alternative to defining &quot;&lt;&quot;.)<br>(5) By convention, I do not return nil just because an index wasn&#39;t found. You might still want to use the index for the insertion of new elements. For convenience, there&#39;s binaryFind which is guaranteed to return an index exactly when there&#39;s a match, otherwise nil.<br></p><p>(6) There are convenience overloads for sorted collections of Generator.Element : Comparable so that you can give a value to look up.<br></p><p>(7) The project also contains more experimental stuff like a working (but slow?) port of libc++&#39;s binary heap algorithms. Over time, those would be nice to port to Swift standard library as well.<br></p><p>The existing interface on GitHub is still preferring top-level functions. I&#39;m modernising the interface into the following (plus the usual public, @warn_unused_result, @noescape, throws and rethrows dance). An already working implementation can be found in the protocol-extensions branch &lt;https://github.com/knomi/Allsorts/blob/protocol-extensions/Allsorts/BinarySearch.swift&gt;:<br></p><p>enum Ordering : Int { case LT = -1, EQ, GT } // NSComparisonResult, basically<br></p><p>extension CollectionType where Index : RandomAccessIndexType {<br>    func binaryFind(ordering: Generator.Element -&gt; Ordering) -&gt; Self.Index?<br>    func binarySearch(ordering: Generator.Element -&gt; Ordering) -&gt; Self.Index<br>    func lowerBound(ordering: Generator.Element -&gt; Ordering) -&gt; Self.Index<br>    func upperBound(ordering: Generator.Element -&gt; Ordering) -&gt; Self.Index<br>    func equalRange(ordering: Generator.Element -&gt; Ordering) -&gt; Range&lt;Self.Index&gt;<br>}<br></p><p>extension CollectionType where Index : RandomAccessIndexType, Generator.Element : Comparable {<br>    func binaryFind(value: Generator.Element) -&gt; Self.Index?<br>    func binarySearch(value: Generator.Element) -&gt; Self.Index<br>    func lowerBound(value: Generator.Element) -&gt; Self.Index<br>    func upperBound(value: Generator.Element) -&gt; Self.Index<br>    func equalRange(value: Generator.Element) -&gt; Range&lt;Self.Index&gt;<br>}<br></p><p>&gt; On 15 Feb 2016, at 23:34, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; <br>&gt; Note that you don&#39;t need random access to get an advantage from binary search if the comparison is sufficiently expensive.<br></p><p><br>One current restriction is that I only define these functions over collections with random access. What it boils down to is the implementation of midIndex:<br></p><p>internal func midIndex&lt;Ix : RandomAccessIndexType&gt;(range: Range&lt;Ix&gt;) -&gt; Ix {<br>    let fullDistance = range.startIndex.distanceTo(range.endIndex)<br>    return range.startIndex.advancedBy(fullDistance / 2)<br>}<br></p><p>That could certainly be written with weaker constraints as well; I just haven&#39;t checked how it affects to the interface in terms of duplication of code, and to the performance of the random access version.<br></p><p>— Pyry Jahkola<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/8a5cd012/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30e4ca9ef73f6a84d52c26952c180bcd?s=50"></div><header><strong>[Discussion] Binary search, lower bound, upper bound, equal range</strong> from <string>Jeff Hajewski</string> &lt;jeff.hajewski at gmail.com&gt;<p>February 16, 2016 at 10:00:00am</p></header><div class="content"><p>Pyry - this is great work! I wonder if we can loosen the restriction of<br>conforming to RandomAccessIndexType. I will play around with this. I think<br>maybe the *Ordering* enum should be broken out into a separate proposal<br>since it&#39;s not currently part of the standard lib. That being said, it does<br>make for a clean implementation.<br></p><p>Thanks<br>Jeff<br></p><p>On Tue, Feb 16, 2016 at 7:12 AM, Pyry Jahkola via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Mon Feb 15 2016, Jeff Hajewski &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; I am working on SR-368 &lt;https://bugs.swift.org/browse/SR-368&gt; and am<br>&gt; hoping to get some feedback from the community.<br>&gt;<br>&gt;<br>&gt; Definitely +1!<br>&gt;<br>&gt; Shameless plug:<br>&gt;<br>&gt; I&#39;ve played with this idea in the past, implementing all of the four<br>&gt; suggested binary searches as generic functions over index ranges or<br>&gt; collections, using a custom 3-way comparator. The commented code and unit<br>&gt; tests are found in https://github.com/knomi/Allsorts. The library is also<br>&gt; somewhat tested in production.<br>&gt;<br>&gt; let i: Int        = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;,&quot;d&quot;,&quot;f&quot;,&quot;f&quot;].binarySearch(&quot;c&quot;)<br>&gt;         //=&gt; 2, 3 or 4<br>&gt; let j: Int?       = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;,&quot;d&quot;,&quot;f&quot;,&quot;f&quot;].binaryFind(&quot;e&quot;)<br>&gt;         //=&gt; nil<br>&gt; // Compare values to &quot;e&quot;. `a &lt;=&gt; b` performs a 3-way comparison,<br>&gt; returning .LT, .EQ or .GT<br>&gt; let k: Int        = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;,&quot;d&quot;,&quot;f&quot;,&quot;f&quot;].lowerBound {x in x<br>&gt; &lt;=&gt; &quot;e&quot;} //=&gt; 6<br>&gt; // Reverse order (the arguments of &lt;=&gt; are flipped):<br>&gt; let r: Range&lt;Int&gt; = [&quot;e&quot;,&quot;e&quot;,&quot;d&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;,&quot;b&quot;,&quot;a&quot;].equalRange {x in &quot;c&quot;<br>&gt; &lt;=&gt; x} //=&gt; 3 ..&lt; 6<br>&gt;<br>&gt; I&#39;d be happy to join forces in making the algorithms available in the<br>&gt; standard library.<br>&gt;<br>&gt; I believe that my code tackles many points Dave mentioned:<br>&gt;<br>&gt; (1) You don&#39;t need to construct an element just to perform the search. You<br>&gt; only need a function to tell if the search should proceed to the left or<br>&gt; right, or if there&#39;s a match.<br>&gt;<br>&gt; (2) You don&#39;t really need to a concrete collection either. A Range&lt;Int&gt; will<br>&gt; do just as fine, as long as you&#39;re able to say how those indices should be<br>&gt; compared to each other (usually by looking up somewhere else).<br>&gt;<br>&gt; (3) The collection can be sorted by any comparator (which I call an &quot;<br>&gt; ordering&quot;), as long as you pass that information along as the closure<br>&gt; (the ordering).<br>&gt;<br>&gt; (4) I use three-way comparisons to avoid extra work comparing e.g. strings.<br>&gt;<br>&gt;<br>&gt;    - Turns out comparisons defined that way also compose amazingly well,<br>&gt;       see first examples in README.<br>&gt;       - There&#39;s an operator &quot;x &lt;=&gt; y&quot; returning Ordering.LT, .EQ, or .GT instead<br>&gt;       of just Bool. However, that operator has little to do with the<br>&gt;       implementation of binary search.<br>&gt;       - (The topic of three-way comparisons was discussed earlier<br>&gt;       &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009127.html&gt; in<br>&gt;       swift-evolution. I think it should find its way into the Comparable protocol<br>&gt;       directly, as an alternative to defining &quot;&lt;&quot;.)<br>&gt;<br>&gt; (5) By convention, I *do not* return nil just because an index wasn&#39;t<br>&gt; found. You might still want to use the index for the insertion of new<br>&gt; elements. For convenience, there&#39;s binaryFind which is guaranteed to<br>&gt; return an index exactly when there&#39;s a match, otherwise nil.<br>&gt;<br>&gt; (6) There are convenience overloads for sorted collections of Generator.Element<br>&gt; : Comparable so that you can give a value to look up.<br>&gt;<br>&gt; (7) The project also contains more experimental stuff like a working (but<br>&gt; slow?) port of libc++&#39;s binary heap algorithms. Over time, those would be<br>&gt; nice to port to Swift standard library as well.<br>&gt;<br>&gt;<br>&gt; The existing interface on GitHub is still preferring top-level functions.<br>&gt; I&#39;m modernising the interface into the following (plus the usual public,<br>&gt; @warn_unused_result, @noescape, throws and rethrows dance). An already<br>&gt; working implementation can be found in the protocol-extensions branch<br>&gt; &lt;https://github.com/knomi/Allsorts/blob/protocol-extensions/Allsorts/BinarySearch.swift&gt;<br>&gt; :<br>&gt;<br>&gt; enum Ordering : Int { case LT = -1, EQ, GT } // NSComparisonResult,<br>&gt; basically<br>&gt;<br>&gt; extension CollectionType where Index : RandomAccessIndexType {<br>&gt;     func binaryFind(ordering: Generator.Element -&gt; Ordering) -&gt; Self.Index<br>&gt; ?<br>&gt;     func binarySearch(ordering: Generator.Element -&gt; Ordering) -&gt; Self.<br>&gt; Index<br>&gt;     func lowerBound(ordering: Generator.Element -&gt; Ordering) -&gt; Self.Index<br>&gt;     func upperBound(ordering: Generator.Element -&gt; Ordering) -&gt; Self.Index<br>&gt;     func equalRange(ordering: Generator.Element -&gt; Ordering) -&gt; Range&lt;Self<br>&gt; .Index&gt;<br>&gt; }<br>&gt;<br>&gt; extension CollectionType where Index : RandomAccessIndexType,<br>&gt; Generator.Element : Comparable {<br>&gt;     func binaryFind(value: Generator.Element) -&gt; Self.Index?<br>&gt;     func binarySearch(value: Generator.Element) -&gt; Self.Index<br>&gt;     func lowerBound(value: Generator.Element) -&gt; Self.Index<br>&gt;     func upperBound(value: Generator.Element) -&gt; Self.Index<br>&gt;     func equalRange(value: Generator.Element) -&gt; Range&lt;Self.Index&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; On 15 Feb 2016, at 23:34, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Note that you don&#39;t need random access to get an advantage from binary<br>&gt; search if the comparison is sufficiently expensive.<br>&gt;<br>&gt;<br>&gt; One current restriction is that I only define these functions over<br>&gt; collections with random access. What it boils down to is the implementation<br>&gt; of midIndex:<br>&gt;<br>&gt; internal func midIndex&lt;Ix : RandomAccessIndexType&gt;(range: Range&lt;Ix&gt;) -&gt; Ix<br>&gt;  {<br>&gt;     let fullDistance = range.startIndex.distanceTo(range.endIndex)<br>&gt;     return range.startIndex.advancedBy(fullDistance / 2)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; That could certainly be written with weaker constraints as well; I just<br>&gt; haven&#39;t checked how it affects to the interface in terms of duplication of<br>&gt; code, and to the performance of the random access version.<br>&gt;<br>&gt; — Pyry Jahkola<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/085bb0a0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Discussion] Binary search, lower bound, upper bound, equal range</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>February 16, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 16 Feb 2016, at 17:49, Jeff Hajewski &lt;jeff.hajewski at gmail.com&gt; wrote:<br>&gt; <br>&gt; I wonder if we can loosen the restriction of conforming to RandomAccessIndexType.<br></p><p>Yay, it turned out simpler than I thought!<br></p><p>I added a performance test to make sure there&#39;s no regression on RandomAccessIndexType&#39;s performance, then simply downgraded the RandomAccessIndexType requirement to ForwardIndexType (and used != instead of &lt; in a few places). The updated code &lt;https://github.com/knomi/Allsorts/commit/52e3d7abee2d01d90ecadea24e00c9067a64a327&gt; is in GitHub.<br></p><p>That appears to work because of protocol inheritance magic in the standard library. So, even though my search algorithm only knows about ForwardIndexType, whenever Index happens to implement O(1) versions of advancedBy(_:) and distanceTo(_:), then those get used instead of the O(N) default implementations (Index.swift &lt;https://github.com/apple/swift/blob/de253d9b6f21498704f96aac712cf1b02e612255/stdlib/public/core/Index.swift#L243-L262&gt; on the Swift repository). Cool!<br></p><p>There might still be place for improvement, since the internal use of midIndex still passes across the same index ranges several times during the search on ForwardIndexType. If I did my math right, the current implementation makes something like 3N index increments on ForwardIndexTypes, while probably at least 2N can be achieved without much memory use.<br></p><p>&gt; I think maybe the Ordering enum should be broken out into a separate proposal since it&#39;s not currently part of the standard lib. That being said, it does make for a clean implementation.<br></p><p>You&#39;re absolutely right. I should also paint the bikeshed of naming its cases (.LT, .EQ, and .GT) less obscurely before officially proposing it to swift-evolution. Maybe either  .ascending, .equivalent, and .descending, or simply .less, .equal, and .greater. And I expect there to be resistance against adding yet another comparison operator, even if there&#39;s precedent on the use of something like &quot;a &lt;=&gt; b&quot; in several other languages.<br></p><p>— Pyry Jahkola<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/1626d6db/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>[Discussion] Binary search, lower bound, upper bound, equal range</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>February 16, 2016 at 06:00:00pm</p></header><div class="content"><p>According to the aforementioned thread on the &lt;=&gt; operator (inclusive of<br>its addition to Comparable with the Ordered(Ascending|Descending|Equal)<br>enum), Dave Abrahams mentioned it was already slated for inclusion in Swift<br>3, and that sorting algorithms using it would be nifty. I&#39;ve thus assumed<br>there&#39;s no need to turn it into a formal proposal with a review. I&#39;ve not<br>seen any opposition to the idea yet.<br>If it does make it to a review I&#39;ll add my +1 though.<br></p><p>On Tue, Feb 16, 2016 at 5:58 PM, Pyry Jahkola via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On 16 Feb 2016, at 17:49, Jeff Hajewski &lt;jeff.hajewski at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; I wonder if we can loosen the restriction of conforming to<br>&gt; RandomAccessIndexType.<br>&gt;<br>&gt;<br>&gt; Yay, it turned out simpler than I thought!<br>&gt;<br>&gt; I added a performance test to make sure there&#39;s no regression on<br>&gt; RandomAccessIndexType&#39;s performance, then simply downgraded the<br>&gt; RandomAccessIndexType requirement to ForwardIndexType (and used != instead<br>&gt; of &lt; in a few places). The updated code<br>&gt; &lt;https://github.com/knomi/Allsorts/commit/52e3d7abee2d01d90ecadea24e00c9067a64a327&gt; is<br>&gt; in GitHub.<br>&gt;<br>&gt; That appears to work because of protocol inheritance magic in the standard<br>&gt; library. So, even though my search algorithm only knows about<br>&gt; ForwardIndexType, whenever Index happens to implement O(1) versions of<br>&gt; advancedBy(_:) and distanceTo(_:), then those get used instead of the<br>&gt; O(N) default implementations (Index.swift<br>&gt; &lt;https://github.com/apple/swift/blob/de253d9b6f21498704f96aac712cf1b02e612255/stdlib/public/core/Index.swift#L243-L262&gt; on<br>&gt; the Swift repository). Cool!<br>&gt;<br>&gt; There might still be place for improvement, since the internal use of<br>&gt; midIndex still passes across the same index ranges several times during<br>&gt; the search on ForwardIndexType. If I did my math right, the current<br>&gt; implementation makes something like 3N index increments on<br>&gt; ForwardIndexTypes, while probably at least 2N can be achieved without<br>&gt; much memory use.<br>&gt;<br>&gt; I think maybe the *Ordering* enum should be broken out into a separate<br>&gt; proposal since it&#39;s not currently part of the standard lib. That being<br>&gt; said, it does make for a clean implementation.<br>&gt;<br>&gt;<br>&gt; You&#39;re absolutely right. I should also paint the bikeshed of naming its<br>&gt; cases (.LT, .EQ, and .GT) less obscurely before officially proposing it<br>&gt; to swift-evolution. Maybe either  .ascending, .equivalent, and .descending,<br>&gt; or simply .less, .equal, and .greater. And I expect there to be<br>&gt; resistance against adding yet another comparison operator, even if there&#39;s<br>&gt; precedent on the use of something like &quot;a &lt;=&gt; b&quot; in several other<br>&gt; languages.<br>&gt;<br>&gt; — Pyry Jahkola<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/277a3568/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] Binary search, lower bound, upper bound, equal range</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 16, 2016 at 11:00:00am</p></header><div class="content"><p>No love though for the X-wing/Cat variation. &gt;=&lt; <br></p><p>-- E<br></p><p>&gt; On Feb 16, 2016, at 11:26 AM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; According to the aforementioned thread on the &lt;=&gt; operator (inclusive of its addition to Comparable with the Ordered(Ascending|Descending|Equal) enum), Dave Abrahams mentioned it was already slated for inclusion in Swift 3, and that sorting algorithms using it would be nifty. I&#39;ve thus assumed there&#39;s no need to turn it into a formal proposal with a review. I&#39;ve not seen any opposition to the idea yet.<br>&gt; If it does make it to a review I&#39;ll add my +1 though.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30e4ca9ef73f6a84d52c26952c180bcd?s=50"></div><header><strong>[Discussion] Binary search, lower bound, upper bound, equal range</strong> from <string>Jeff Hajewski</string> &lt;jeff.hajewski at gmail.com&gt;<p>February 16, 2016 at 01:00:00pm</p></header><div class="content"><p>Thanks for adding that info regarding &lt;=&gt; and Swift 3 - sounds like we<br>should include it in the proposal. Keeping up with all these<br>swift-evolution threads could be a full-time job!<br></p><p>Jeff<br></p><p>On Tue, Feb 16, 2016 at 1:26 PM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt;<br>wrote:<br></p><p>&gt; According to the aforementioned thread on the &lt;=&gt; operator (inclusive of<br>&gt; its addition to Comparable with the Ordered(Ascending|Descending|Equal)<br>&gt; enum), Dave Abrahams mentioned it was already slated for inclusion in Swift<br>&gt; 3, and that sorting algorithms using it would be nifty. I&#39;ve thus assumed<br>&gt; there&#39;s no need to turn it into a formal proposal with a review. I&#39;ve not<br>&gt; seen any opposition to the idea yet.<br>&gt; If it does make it to a review I&#39;ll add my +1 though.<br>&gt;<br>&gt; On Tue, Feb 16, 2016 at 5:58 PM, Pyry Jahkola via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On 16 Feb 2016, at 17:49, Jeff Hajewski &lt;jeff.hajewski at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I wonder if we can loosen the restriction of conforming to<br>&gt;&gt; RandomAccessIndexType.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yay, it turned out simpler than I thought!<br>&gt;&gt;<br>&gt;&gt; I added a performance test to make sure there&#39;s no regression on<br>&gt;&gt; RandomAccessIndexType&#39;s performance, then simply downgraded the<br>&gt;&gt; RandomAccessIndexType requirement to ForwardIndexType (and used != instead<br>&gt;&gt; of &lt; in a few places). The updated code<br>&gt;&gt; &lt;https://github.com/knomi/Allsorts/commit/52e3d7abee2d01d90ecadea24e00c9067a64a327&gt; is<br>&gt;&gt; in GitHub.<br>&gt;&gt;<br>&gt;&gt; That appears to work because of protocol inheritance magic in the<br>&gt;&gt; standard library. So, even though my search algorithm only knows about<br>&gt;&gt; ForwardIndexType, whenever Index happens to implement O(1) versions of<br>&gt;&gt; advancedBy(_:) and distanceTo(_:), then those get used instead of the<br>&gt;&gt; O(N) default implementations (Index.swift<br>&gt;&gt; &lt;https://github.com/apple/swift/blob/de253d9b6f21498704f96aac712cf1b02e612255/stdlib/public/core/Index.swift#L243-L262&gt; on<br>&gt;&gt; the Swift repository). Cool!<br>&gt;&gt;<br>&gt;&gt; There might still be place for improvement, since the internal use of<br>&gt;&gt; midIndex still passes across the same index ranges several times during<br>&gt;&gt; the search on ForwardIndexType. If I did my math right, the current<br>&gt;&gt; implementation makes something like 3N index increments on<br>&gt;&gt; ForwardIndexTypes, while probably at least 2N can be achieved without<br>&gt;&gt; much memory use.<br>&gt;&gt;<br>&gt;&gt; I think maybe the *Ordering* enum should be broken out into a separate<br>&gt;&gt; proposal since it&#39;s not currently part of the standard lib. That being<br>&gt;&gt; said, it does make for a clean implementation.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You&#39;re absolutely right. I should also paint the bikeshed of naming its<br>&gt;&gt; cases (.LT, .EQ, and .GT) less obscurely before officially proposing it<br>&gt;&gt; to swift-evolution. Maybe either  .ascending, .equivalent, and<br>&gt;&gt; .descending, or simply .less, .equal, and .greater. And I expect there<br>&gt;&gt; to be resistance against adding yet another comparison operator, even if<br>&gt;&gt; there&#39;s precedent on the use of something like &quot;a &lt;=&gt; b&quot; in several<br>&gt;&gt; other languages.<br>&gt;&gt;<br>&gt;&gt; — Pyry Jahkola<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/dd904732/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Discussion] Binary search, lower bound, upper bound, equal range</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February 16, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 16, 2016, at 11:58 AM, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On 16 Feb 2016, at 17:49, Jeff Hajewski &lt;jeff.hajewski at gmail.com &lt;mailto:jeff.hajewski at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I wonder if we can loosen the restriction of conforming to RandomAccessIndexType.<br>&gt; <br>&gt; Yay, it turned out simpler than I thought!<br>&gt; <br>&gt; I added a performance test to make sure there&#39;s no regression on RandomAccessIndexType&#39;s performance, then simply downgraded the RandomAccessIndexType requirement to ForwardIndexType (and used != instead of &lt; in a few places). The updated code &lt;https://github.com/knomi/Allsorts/commit/52e3d7abee2d01d90ecadea24e00c9067a64a327&gt; is in GitHub.<br>&gt; <br>&gt; That appears to work because of protocol inheritance magic in the standard library. So, even though my search algorithm only knows about ForwardIndexType, whenever Index happens to implement O(1) versions of advancedBy(_:) and distanceTo(_:), then those get used instead of the O(N) default implementations (Index.swift &lt;https://github.com/apple/swift/blob/de253d9b6f21498704f96aac712cf1b02e612255/stdlib/public/core/Index.swift#L243-L262&gt; on the Swift repository). Cool!<br>&gt; <br>&gt; There might still be place for improvement, since the internal use of midIndex still passes across the same index ranges several times during the search on ForwardIndexType. If I did my math right, the current implementation makes something like 3N index increments on ForwardIndexTypes, while probably at least 2N can be achieved without much memory use.<br></p><p>I was going to suggest earlier that the algorithms should perhaps switch to an internal representation of ~ `(index: Index, length: Index.Distance)` (instead of `Range&lt;Index&gt;`), which is an unnecessary change for `RandomAccessIndexType` but for a `ForwardIndexType` would eliminate the need to call `distanceTo` more than once.<br></p><p>The public API could of course stick with Range&lt;Index&gt;, the alternative representation would only be a private implementation detail.<br></p><p>I have some other thoughts but they’re still in progress.<br></p><p>&gt; <br>&gt;&gt; I think maybe the Ordering enum should be broken out into a separate proposal since it&#39;s not currently part of the standard lib. That being said, it does make for a clean implementation.<br>&gt; <br>&gt; You&#39;re absolutely right. I should also paint the bikeshed of naming its cases (.LT, .EQ, and .GT) less obscurely before officially proposing it to swift-evolution. Maybe either  .ascending, .equivalent, and .descending, or simply .less, .equal, and .greater. And I expect there to be resistance against adding yet another comparison operator, even if there&#39;s precedent on the use of something like &quot;a &lt;=&gt; b&quot; in several other languages.<br>&gt; <br>&gt; — Pyry Jahkola<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/78e471ca/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Discussion] Binary search, lower bound, upper bound, equal range</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 16, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; You&#39;re absolutely right. I should also paint the bikeshed of naming its cases (.LT, .EQ, and .GT) less obscurely before officially proposing it to swift-evolution. Maybe either  .ascending, .equivalent, and .descending, or simply .less, .equal, and .greater.<br></p><p>How exciting, another bikeshed! My color:<br></p><p>	enum Ordering {<br>		case leftSmaller, bothEqual, rightSmaller<br>	}<br></p><p>I always have trouble tying the case names back to the original expression; I *think* this might help me with that.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
