<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Generic parameters in &quot;as?&quot; checks</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 20, 2016 at 10:00:00pm</p></header><div class="content"><p>Currently, generic types can be hard to work with in certain cases; particularly if you want to check if an object belongs to a type that has generic parameters.<br></p><p>I’m wondering if it would be completely unreasonable to ask for the ability to introduce a generic parameter into an as? check, and have it treated the way a generic type would be treated in a generic function. Using Array as a convenient generic type that’s easy to create, let’s suppose we want to check if some random object is a array containing some type that we don’t care what type it is, as long as it’s a subclass of some type, conforms to some protocol, etc.<br></p><p>Something like this:<br></p><p>class Foo {<br>	required init() {}<br>	func doAFooThing() {}<br>}<br>class Bar: Foo {<br>	required init() { super.init() }<br>	func doABarThing() {}<br>}<br></p><p>if let arr = someObject as? Array&lt;T: Foo&gt; {<br>	for eachFoo in arr {<br>		T.doAFooThing()<br>		// but T.doABarThing() would not work<br>       }<br>	<br>	array.append(T())<br>}<br></p><p>Or perhaps, if we need angle brackets to be somewhere, something like this:<br></p><p>if let arr = someObject as? &lt;T: Foo&gt; Array&lt;T&gt; {<br>	…<br>}<br></p><p>Is this a feasible thing to ask for?<br></p><p>(Apologies if there’s already a way to do this; I was looking for one without success.)<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Generic parameters in &quot;as?&quot; checks</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>January 20, 2016 at 09:00:00pm</p></header><div class="content"><p>Here’s an attempt to implement this with existing language features:<br></p><p>&gt; protocol HasElementType {<br>&gt;   func getElement() -&gt; Any.Type?<br>&gt; }<br>&gt; <br>&gt; extension HasElementType {<br>&gt;   func getElement() -&gt; Any.Type? {<br>&gt;     return nil<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; extension Array : HasElementType {<br>&gt;   func getElement() -&gt; Any.Type? {<br>&gt;     return Element.self<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; func isArrayWithElementType&lt;T&gt;(a: Any, _ m: T.Type) -&gt; Bool {<br>&gt;   guard let aa = a as? HasElementType else { return false }<br>&gt;   guard let elt = aa.getElement() else { return false }<br>&gt;   return elt is T.Type<br>&gt; }<br>&gt; <br>&gt; protocol P {}<br>&gt; struct X : P {}<br>&gt; <br>&gt; print(isArrayWithElementType([1,2,3,4,5], Int.self))<br>&gt; print(isArrayWithElementType([1,2,3,4,5], Float.self))<br>&gt; print(isArrayWithElementType([&quot;a&quot;, &quot;b&quot;], String.self))<br>&gt; print(isArrayWithElementType([X()], X.self))<br>&gt; print(isArrayWithElementType([X()], P.self))<br></p><p>However, the limitation here is that when we do ‘elt is T.Type’, if elt is a metatype conforming to a protocol P, and T is P, the ‘is’ check just checks for metatype identity and not conformance.<br></p><p>So if a generic parameter T is bound to a concrete type C, then T.Type means C.Type. However, if C is a protocol type, then T.Type is really C.Protocol, not C.Type.<br></p><p>Here’s a silly idea:<br></p><p>- Switch P.Type and P.Protocol syntax where P is a protocol type, so that P.Type is the type of P.self, and P.Protocol is the existential metatype. This makes ‘P.Type’ consistent with ’T.Type’ where T is bound to a protocol type. It also makes ‘P.Protocol’ kind of like a protocol — types that conform to P have metatypes that conform to P.Protocol.<br></p><p>- Add a ‘: protocol’ generic constraint, asserting that the type parameter is some protocol existential type:<br></p><p>  func isArrayWithElementType&lt;T : protocol&gt;(…)<br></p><p>- For a generic type parameter T with an existential constraint, you would be able to write T.Protocol to refer to the existential metatype. T.self would not be an instance of T.Protocol, but the elements of your array that *conform* to T would be instances of T.Protocol.<br></p><p>Maybe also we want to allow casts with a metatype expression, rather than a type identifier, on the RHS.<br></p><p>&gt; Or perhaps, if we need angle brackets to be somewhere, something like this:<br>&gt; <br>&gt; if let arr = someObject as? &lt;T: Foo&gt; Array&lt;T&gt; {<br></p><p>Yeah, it’s going to have to be this, since &lt;T : Foo&gt; is shorthand for &lt;T where T : Foo&gt;, and in general the &lt;&gt; of a bound generic type reference are different from &lt;&gt; in a generic signature — the latter introduces new type variables for instance.<br></p><p>&gt; 	…<br>&gt; }<br>&gt; <br>&gt; Is this a feasible thing to ask for?<br></p><p>I think so, but we have to careful with the design. This ties in with some of the discussions on generalizing existential types, also.<br></p><p>&gt; <br>&gt; (Apologies if there’s already a way to do this; I was looking for one without success.)<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/286ab321/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Generic parameters in &quot;as?&quot; checks</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 20, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 11:26 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt; Here’s an attempt to implement this with existing language features:<br>&gt; <br>&gt;&gt; protocol HasElementType {<br>&gt;&gt;   func getElement() -&gt; Any.Type?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension HasElementType {<br>&gt;&gt;   func getElement() -&gt; Any.Type? {<br>&gt;&gt;     return nil<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Array : HasElementType {<br>&gt;&gt;   func getElement() -&gt; Any.Type? {<br>&gt;&gt;     return Element.self<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func isArrayWithElementType&lt;T&gt;(a: Any, _ m: T.Type) -&gt; Bool {<br>&gt;&gt;   guard let aa = a as? HasElementType else { return false }<br>&gt;&gt;   guard let elt = aa.getElement() else { return false }<br>&gt;&gt;   return elt is T.Type<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol P {}<br>&gt;&gt; struct X : P {}<br>&gt;&gt; <br>&gt;&gt; print(isArrayWithElementType([1,2,3,4,5], Int.self))<br>&gt;&gt; print(isArrayWithElementType([1,2,3,4,5], Float.self))<br>&gt;&gt; print(isArrayWithElementType([&quot;a&quot;, &quot;b&quot;], String.self))<br>&gt;&gt; print(isArrayWithElementType([X()], X.self))<br>&gt;&gt; print(isArrayWithElementType([X()], P.self))<br></p><p>Thanks for that. The trouble is that the problem I’m trying to solve is actually more complicated than the example; it’s not actually Array that I’m dealing with, but a custom type. I am looking for a way not just to see whether the thing contains a certain type, but actually to cast it to the generic type with ‘as?’ so that I can use it as the generic type, pass it to functions that want that generic type, etc., do things with its type T that require something somewhere knowing what the type is (in my example, I used arr.append(T()), an operation that needs to know what type T is, so that it can create the instance. Just creating a Foo() wouldn’t work, since the array could be of some Foo subclass and not take garden-variety Foos.<br></p><p>If we want to get *really* specific, I’m actually dealing with a protocol with associated types, not a generic struct. However, they both fall under the same umbrella of “need to use this as a generic constraint”, and “generic” is less obnoxious to type over and over when discussing things than “protocol with associated types”. :-P<br></p><p>&gt;&gt; if let arr = someObject as? &lt;T: Foo&gt; Array&lt;T&gt; {<br>&gt; <br>&gt; Yeah, it’s going to have to be this, since &lt;T : Foo&gt; is shorthand for &lt;T where T : Foo&gt;, and in general the &lt;&gt; of a bound generic type reference are different from &lt;&gt; in a generic signature — the latter introduces new type variables for instance.<br></p><p>Okay, in the example above, that leaves five places for the generic signature to go: after the “if”, after the “let”, after the variable name, after the equals sign, and after the “as?”. Or perhaps we could introduce some sort of new keyword in there to which to attach the generic signature.<br></p><p>&gt;&gt; Is this a feasible thing to ask for?<br>&gt; <br>&gt; I think so, but we have to careful with the design. This ties in with some of the discussions on generalizing existential types, also.<br></p><p><br>That’s good to hear. Is there any information on what the Swift team is planning to do with existentials?<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/7442b0cf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Generic parameters in &quot;as?&quot; checks</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>January 20, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 9:53 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br></p><p>&gt; If we want to get *really* specific, I’m actually dealing with a protocol with associated types, not a generic struct. However, they both fall under the same umbrella of “need to use this as a generic constraint”, and “generic” is less obnoxious to type over and over when discussing things than “protocol with associated types”. :-P<br></p><p>I think this falls under the “generalizing existentials to support protocols with associated types” bucket.<br> <br>&gt; <br>&gt; Okay, in the example above, that leaves five places for the generic signature to go: after the “if”, after the “let”, after the variable name, after the equals sign, and after the “as?”. Or perhaps we could introduce some sort of new keyword in there to which to attach the generic signature.<br></p><p>Various approaches have been discussed before. The one that’s closest to what you describe above is to have some kind of ‘open’ keyword,<br></p><p>func foo(p: SomeProto) {<br>  let t = open p as T {<br>    T.SomeAssocType.someStaticMethod(…)<br>  }<br>}<br></p><p>But another promising approach is path-dependent types, so that above you could write p.SomeAssocType for instance.<br></p><p>&gt; <br>&gt;&gt;&gt; Is this a feasible thing to ask for?<br>&gt;&gt; <br>&gt;&gt; I think so, but we have to careful with the design. This ties in with some of the discussions on generalizing existential types, also.<br>&gt; <br>&gt; <br>&gt; That’s good to hear. Is there any information on what the Swift team is planning to do with existentials?<br></p><p>Oh, I was just referring to the discussion on this list. No concrete proposals have been accepted so far, AFAIK.<br></p><p>Cheers,<br></p><p>Slava<br></p><p>&gt; <br>&gt; Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/5db68035/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Generic parameters in &quot;as?&quot; checks</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 21, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 11:56 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; Okay, in the example above, that leaves five places for the generic signature to go: after the “if”, after the “let”, after the variable name, after the equals sign, and after the “as?”. Or perhaps we could introduce some sort of new keyword in there to which to attach the generic signature.<br>&gt; <br>&gt; Various approaches have been discussed before. The one that’s closest to what you describe above is to have some kind of ‘open’ keyword,<br>&gt; <br>&gt; func foo(p: SomeProto) {<br>&gt;   let t = open p as T {<br>&gt;     T.SomeAssocType.someStaticMethod(…)<br>&gt;   }<br>&gt; }<br></p><p>Thanks, this looks good. Based on this, I found the earlier discussion where this came up, but it seems that the example above assumes you already know p is SomeProto. I assume there’d be a way to take p as something else, like an Any, and dynamically cast it to SomeProto using some combination of as? and open, right?<br></p><p>&gt;&gt;&gt;&gt; Is this a feasible thing to ask for?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think so, but we have to careful with the design. This ties in with some of the discussions on generalizing existential types, also.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; That’s good to hear. Is there any information on what the Swift team is planning to do with existentials?<br>&gt; <br>&gt; Oh, I was just referring to the discussion on this list. No concrete proposals have been accepted so far, AFAIK.<br></p><p><br>Well, if someone proposes one, it’ll get a +1 from me.<br></p><p>Thanks,<br>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/58cdcee8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7321934b88ca8da079d7b89926501a9c?s=50"></div><header><strong>Generic parameters in &quot;as?&quot; checks</strong> from <string>David Turnbull</string> &lt;dturnbull at gmail.com&gt;<p>January 21, 2016 at 01:00:00am</p></header><div class="content"><p>This sounds like it could lead down a path that would clean up some ugly<br>code I wrote recently.<br></p><p>public protocol VectorType : GLmathType {<br>    typealias FloatVector<br>    typealias DoubleVector<br>    typealias Int32Vector<br>    typealias UInt32Vector<br>    typealias BooleanVector<br></p><p>This is the protocol for vector2/3/4 types. Some functions need to return a<br>bool result. Others are an unsafe cast to another type. I&#39;m also using the<br>BooleanVector as a key where I need vectors of the same length which have<br>different elements.<br></p><p>public func notEqual&lt;genType:ScalarVectorType where<br>    genType.BooleanVector.Element == Bool,<br>    genType.BooleanVector == genType.BooleanVector.BooleanVector<br>    &gt;(x:genType, _ y:genType) -&gt; genType.BooleanVector {<br>        return genType.BooleanVector(x, y, !=)<br>}<br></p><p>Many times I went looking for any way to get back to the raw generic type.<br>I don&#39;t know if this makes sense out of context, so here&#39;s the full set of<br>prototypes:<br>https://github.com/AE9RB/SwiftGL/blob/master/Sources/SwiftGLmath/Types.swift<br></p><p>I hope this is helpful to those of you thinking about changes. It&#39;s really<br>far down on my wish list though. The &quot;expression too complex&quot; errors and<br>compile times are blocking me right now.<br></p><p>-david<br></p><p>On Wed, Jan 20, 2016 at 10:21 PM, Charles Srstka via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Jan 20, 2016, at 11:56 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Okay, in the example above, that leaves five places for the generic<br>&gt; signature to go: after the “if”, after the “let”, after the variable name,<br>&gt; after the equals sign, and after the “as?”. Or perhaps we could introduce<br>&gt; some sort of new keyword in there to which to attach the generic signature.<br>&gt;<br>&gt;<br>&gt; Various approaches have been discussed before. The one that’s closest to<br>&gt; what you describe above is to have some kind of ‘open’ keyword,<br>&gt;<br>&gt; func foo(p: SomeProto) {<br>&gt;   let t = open p as T {<br>&gt;     T.SomeAssocType.someStaticMethod(…)<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Thanks, this looks good. Based on this, I found the earlier discussion<br>&gt; where this came up, but it seems that the example above assumes you already<br>&gt; know p is SomeProto. I assume there’d be a way to take p as something else,<br>&gt; like an Any, and dynamically cast it to SomeProto using some combination of<br>&gt; as? and open, right?<br>&gt;<br>&gt; Is this a feasible thing to ask for?<br>&gt;<br>&gt;<br>&gt; I think so, but we have to careful with the design. This ties in with some<br>&gt; of the discussions on generalizing existential types, also.<br>&gt;<br>&gt;<br>&gt; That’s good to hear. Is there any information on what the Swift team is<br>&gt; planning to do with existentials?<br>&gt;<br>&gt;<br>&gt; Oh, I was just referring to the discussion on this list. No concrete<br>&gt; proposals have been accepted so far, AFAIK.<br>&gt;<br>&gt;<br>&gt; Well, if someone proposes one, it’ll get a +1 from me.<br>&gt;<br>&gt; Thanks,<br>&gt; Charles<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/ab42b43f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
