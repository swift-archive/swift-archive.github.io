<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d92e9730c561c120200f34e7e50ed46?s=50"></div><header><strong>Importing Empty C Structs</strong> from <string>Jeff Kelley</string> &lt;slaunchaman at gmail.com&gt;<p>February 12, 2016 at 12:00:00am</p></header><div class="content"><p>I’m trying to use the Swift Package Manager to import libgit2 and am running into some issues. I have libgit2 installed via Homebrew and have configured the module map thusly:<br></p><p>&gt; module CGit2 [system] {<br>&gt;     header &quot;/usr/local/include/git2.h&quot;<br>&gt;     link &quot;git2&quot;<br>&gt;     export *<br>&gt; }<br></p><p>I can then use this with the SPM to initialize the Git system:<br></p><p>&gt; import CGit2<br>&gt; <br>&gt; let result = git_libgit2_init()<br>&gt; <br>&gt; defer { git_libgit2_shutdown() }<br>&gt; <br>&gt; print(&quot;Result: \(result)&quot;)<br></p><p>This all works fine. When I start to try to use it—for instance, opening a repository:<br></p><p>&gt; var repo: git_repository = nil<br>&gt; <br>&gt; let error = git_repository_open(&amp;repo, &quot;/Users/jeff/Projects/CGit2&quot;)<br>&gt; <br>&gt; guard let repo = repo else { print(&quot;No repo!&quot;); exit(error) }<br></p><p>I get an error: “use of undeclared type ‘git_repository’”<br></p><p>Here’s how git_repository is declared in /usr/local/include/git2/types.h:<br></p><p>&gt; typedef struct git_repository git_repository;<br></p><p>An empty struct. Interesting. A quick sample project in Xcode shows that this line will not generate anything in the Swift generated interface. So it appears to me that this type is invisible to Swift.<br></p><p>Question: Is there a way to use libraries like this in Swift? Should I file a bug that typedef’d structs like this are not imported into the generated interface? Thanks in advance for any pointers!<br></p><p><br>Jeff Kelley<br></p><p>SlaunchaMan at gmail.com | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160212/7f318090/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>Importing Empty C Structs</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>February 12, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 12 Feb 2016, at 06:41, Jeff Kelley via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; typedef struct git_repository git_repository;<br>&gt; <br>&gt; An empty struct. Interesting. A quick sample project in Xcode shows that this line will not generate anything in the Swift generated interface. So it appears to me that this type is invisible to Swift.<br></p><p>This is not an empty struct, it is an example of an incomplete type. <br></p><p>https://en.wikipedia.org/wiki/C_syntax#Incomplete_types<br></p><p>It is a feature of C that you can specify that a struct type exists without giving any information about its internal structure or even size. Typically, a struct definition like the above is placed in a header file and it is redefined in a .c file with all of its internal structure. Compilation units other than the .c file in which the struct is fully defined have know knowledge of what the struct looks like or even how big it is, so all they can do is store pointers to such structs and pass them as parameters and return values. <br></p><p>Any code that manipulates the internals of the struct has to be defined in the implementation file that the struct is fully defined in. Other compilation units can only manipulate the struct through functions that form the API, usually defined in the same header as the incomplete type.<br></p><p>This is a very common pattern in C because it provides complete encapsulation. In fact, it provides better encapsulation than C++ classes.<br></p><p>&gt; <br>&gt; Jeff Kelley<br>&gt; <br>&gt; SlaunchaMan at gmail.com | @SlaunchaMan | jeffkelley.org<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d92e9730c561c120200f34e7e50ed46?s=50"></div><header><strong>Importing Empty C Structs</strong> from <string>Jeff Kelley</string> &lt;slaunchaman at gmail.com&gt;<p>February 12, 2016 at 10:00:00am</p></header><div class="content"><p>OK, that makes sense. I printed the dynamic type of git_repository_open() and the first parameter translates from git_repository* to UnsafeMutablePointer&lt;COpaquePointer&gt;. So I can make a typealias from git_repository to COpaquePointer. I’m wondering if I should submit a proposal to swift-evolution to automate that process.<br></p><p><br>Jeff Kelley<br></p><p>SlaunchaMan at gmail.com &lt;mailto:SlaunchaMan at gmail.com&gt; | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt; On Feb 12, 2016, at 4:42 AM, Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com &lt;mailto:jeremy.j.pereira at googlemail.com&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 12 Feb 2016, at 06:41, Jeff Kelley via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; typedef struct git_repository git_repository;<br>&gt;&gt; <br>&gt;&gt; An empty struct. Interesting. A quick sample project in Xcode shows that this line will not generate anything in the Swift generated interface. So it appears to me that this type is invisible to Swift.<br>&gt; <br>&gt; This is not an empty struct, it is an example of an incomplete type. <br>&gt; <br>&gt; https://en.wikipedia.org/wiki/C_syntax#Incomplete_types &lt;https://en.wikipedia.org/wiki/C_syntax#Incomplete_types&gt;<br>&gt; <br>&gt; It is a feature of C that you can specify that a struct type exists without giving any information about its internal structure or even size. Typically, a struct definition like the above is placed in a header file and it is redefined in a .c file with all of its internal structure. Compilation units other than the .c file in which the struct is fully defined have know knowledge of what the struct looks like or even how big it is, so all they can do is store pointers to such structs and pass them as parameters and return values. <br>&gt; <br>&gt; Any code that manipulates the internals of the struct has to be defined in the implementation file that the struct is fully defined in. Other compilation units can only manipulate the struct through functions that form the API, usually defined in the same header as the incomplete type.<br>&gt; <br>&gt; This is a very common pattern in C because it provides complete encapsulation. In fact, it provides better encapsulation than C++ classes.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Jeff Kelley<br>&gt;&gt; <br>&gt;&gt; SlaunchaMan at gmail.com | @SlaunchaMan | jeffkelley.org<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160212/af57b851/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Importing Empty C Structs</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 15, 2016 at 10:00:00am</p></header><div class="content"><p>The main reason we don&#39;t do this today is that in the REPL you might import the definition later, and then you can&#39;t update the existing type. We definitely need a better story here, though.<br></p><p>Jordan<br></p><p><br>&gt; On Feb 12, 2016, at 7:52, Jeff Kelley via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; OK, that makes sense. I printed the dynamic type of git_repository_open() and the first parameter translates from git_repository* to UnsafeMutablePointer&lt;COpaquePointer&gt;. So I can make a typealias from git_repository to COpaquePointer. I’m wondering if I should submit a proposal to swift-evolution to automate that process.<br>&gt; <br>&gt; <br>&gt; Jeff Kelley<br>&gt; <br>&gt; SlaunchaMan at gmail.com &lt;mailto:SlaunchaMan at gmail.com&gt; | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt;&gt; On Feb 12, 2016, at 4:42 AM, Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com &lt;mailto:jeremy.j.pereira at googlemail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 12 Feb 2016, at 06:41, Jeff Kelley via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; typedef struct git_repository git_repository;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An empty struct. Interesting. A quick sample project in Xcode shows that this line will not generate anything in the Swift generated interface. So it appears to me that this type is invisible to Swift.<br>&gt;&gt; <br>&gt;&gt; This is not an empty struct, it is an example of an incomplete type. <br>&gt;&gt; <br>&gt;&gt; https://en.wikipedia.org/wiki/C_syntax#Incomplete_types &lt;https://en.wikipedia.org/wiki/C_syntax#Incomplete_types&gt;<br>&gt;&gt; <br>&gt;&gt; It is a feature of C that you can specify that a struct type exists without giving any information about its internal structure or even size. Typically, a struct definition like the above is placed in a header file and it is redefined in a .c file with all of its internal structure. Compilation units other than the .c file in which the struct is fully defined have know knowledge of what the struct looks like or even how big it is, so all they can do is store pointers to such structs and pass them as parameters and return values. <br>&gt;&gt; <br>&gt;&gt; Any code that manipulates the internals of the struct has to be defined in the implementation file that the struct is fully defined in. Other compilation units can only manipulate the struct through functions that form the API, usually defined in the same header as the incomplete type.<br>&gt;&gt; <br>&gt;&gt; This is a very common pattern in C because it provides complete encapsulation. In fact, it provides better encapsulation than C++ classes.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jeff Kelley<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SlaunchaMan at gmail.com &lt;mailto:SlaunchaMan at gmail.com&gt; | @SlaunchaMan | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160215/9b3fce81/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Importing Empty C Structs</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 15, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 15, 2016, at 10:05 AM, Jordan Rose via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; The main reason we don&#39;t do this today is that in the REPL you might import the definition later, and then you can&#39;t update the existing type. We definitely need a better story here, though.<br></p><p>This could also potentially happen in a standalone executable image, which might have been compiled with the opaque declaration and then dlopen a dylib with the full definition. We&#39;d want Swift&#39;s runtime metadata for the C type to converge on the full definition when it&#39;s available.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Importing Empty C Structs</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 15, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 15, 2016, at 10:16, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 15, 2016, at 10:05 AM, Jordan Rose via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The main reason we don&#39;t do this today is that in the REPL you might import the definition later, and then you can&#39;t update the existing type. We definitely need a better story here, though.<br>&gt; <br>&gt; This could also potentially happen in a standalone executable image, which might have been compiled with the opaque declaration and then dlopen a dylib with the full definition. We&#39;d want Swift&#39;s runtime metadata for the C type to converge on the full definition when it&#39;s available.<br></p><p>Or consider them unique but distinct types that require an explicit conversion (a Worse Is Better answer if we can&#39;t come up with a full answer).<br></p><p>Jordan<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Importing Empty C Structs</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 12, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 9:41 PM, Jeff Kelley via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m trying to use the Swift Package Manager to import libgit2 and am running into some issues. I have libgit2 installed via Homebrew and have configured the module map thusly:<br>&gt; <br>&gt;&gt; module CGit2 [system] {<br>&gt;&gt;     header &quot;/usr/local/include/git2.h&quot;<br>&gt;&gt;     link &quot;git2&quot;<br>&gt;&gt;     export *<br>&gt;&gt; }<br>&gt; <br>&gt; I can then use this with the SPM to initialize the Git system:<br>&gt; <br>&gt;&gt; import CGit2<br>&gt;&gt; <br>&gt;&gt; let result = git_libgit2_init()<br>&gt;&gt; <br>&gt;&gt; defer { git_libgit2_shutdown() }<br>&gt;&gt; <br>&gt;&gt; print(&quot;Result: \(result)&quot;)<br>&gt; <br>&gt; This all works fine. When I start to try to use it—for instance, opening a repository:<br>&gt; <br>&gt;&gt; var repo: git_repository = nil<br>&gt;&gt; <br>&gt;&gt; let error = git_repository_open(&amp;repo, &quot;/Users/jeff/Projects/CGit2&quot;)<br>&gt;&gt; <br>&gt;&gt; guard let repo = repo else { print(&quot;No repo!&quot;); exit(error) }<br>&gt; <br>&gt; I get an error: “use of undeclared type ‘git_repository’”<br>&gt; <br>&gt; Here’s how git_repository is declared in /usr/local/include/git2/types.h:<br>&gt; <br>&gt;&gt; typedef struct git_repository git_repository;<br>&gt; <br>&gt; An empty struct. Interesting. A quick sample project in Xcode shows that this line will not generate anything in the Swift generated interface. So it appears to me that this type is invisible to Swift.<br>&gt; <br>&gt; Question: Is there a way to use libraries like this in Swift? Should I file a bug that typedef’d structs like this are not imported into the generated interface? Thanks in advance for any pointers!<br></p><p>If a struct is incomplete in C, it can only be manipulated via pointers. We don&#39;t import `git_repository`, but `git_repository*` should be imported as a typealias for COpaquePointer. We have plans to eventually improve the type safety here by importing the type, though even then, you would not be able to construct or pass around values of the incomplete type, only pointers.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160212/2bddaae1/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
