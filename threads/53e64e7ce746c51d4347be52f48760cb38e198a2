<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  4, 2016 at 11:00:00am</p></header><div class="content"><p>on Thu Feb 04 2016, plx &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Feb 4, 2016, at 12:17 AM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Okay, now I&#39;m finally giving this its due—sorry, too much pressure<br>&gt;&gt; earlier in the day…<br>&gt;<br>&gt; No need to apologize, you have a commendable dedication to replies.<br>&gt;<br>&gt; Especially now that the disagreements are getting to be increasingly-minor.<br>&gt;<br>&gt;&gt; on Wed Feb 03 2016, plx<br>&gt; &lt;swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; After reading these guidelines and seeing the responses I am glad to<br>&gt;&gt;&gt; see some consideration given to argument labeling.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After thinking it over, I think the rules *I* would like to see can be<br>&gt;&gt;&gt; expressed very straightforwardly much more can be made much A minor<br>&gt;&gt;&gt; point, but I think it’s important to distinguish between<br>&gt;&gt;&gt; single-argument functions and multi-argument functions; doing so seems<br>&gt;&gt;&gt; to simplify the rules (even if there are more of them).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Everything that follows is my preferences, but I generally agree with<br>&gt;&gt;&gt; Erica’s suggestions in the concrete cases. <br>&gt;&gt; <br>&gt;&gt; I&#39;ll have to go back and have a look at that<br>&gt;&gt; *goes back to have a look*<br>&gt;&gt; <br>&gt;&gt; Are there cases that add something significant to what I&#39;ve already<br>&gt;&gt; written?  I didn&#39;t see any.  If you&#39;re saying what I wrote can be<br>&gt;&gt; improved by covering specific examples, please tell me which ones.<br>&gt;&gt; <br>&gt;&gt;&gt; I also think the emphasis on quasi-grammatical rules-and-roles is<br>&gt;&gt;&gt; something of a dead-end for design guidelines and won’t include such<br>&gt;&gt;&gt; considerations in what follows.<br>&gt;&gt; <br>&gt;&gt; Characterizing what we&#39;ve done in the proposed guidelines as emphasizing<br>&gt;&gt; “quasi-grammatical rules-and-roles” seems like an unnecessary and<br>&gt;&gt; slightly muddled potshot.  The grammatical stuff in the current document<br>&gt;&gt; is not in any sense “quasi” and has no connection to the admonition to<br>&gt;&gt; clarify roles, which I consider to be important.  That said, I&#39;m not at<br>&gt;&gt; all attached to presenting the guidelines in terms of grammar, so I&#39;m<br>&gt;&gt; happy to see how your approach works.<br>&gt;<br>&gt; On a re-read your thread-starter has been toned-down enough from<br>&gt; before it’s a lot less in that direction, but see the main response<br>&gt; below.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; ## RULES<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### I. Single-Argument Functions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #### RULES:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - general rule: don’t label the first argument<br>&gt;&gt;&gt; - exceptions:<br>&gt;&gt;&gt;  - (a) the argument has a default value (`removeAll(keepCapacity: Bool = default)`)<br>&gt;&gt;&gt;  - (b) the function acts-like a constructor (covered in your rule 2)<br>&gt;&gt;&gt;  - (c) the “ecosystem rule” (see section III)<br>&gt;&gt;&gt;  - (d) the semantics of the argument are non-obvious (see below)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #### REMARKS:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not sure (d) actually exists, though; every concrete example I can<br>&gt;&gt;&gt; think up either falls under rule (b) or rule (c). It may not actually<br>&gt;&gt;&gt; need to be a rule (other than as, perhaps, the underlying motivation<br>&gt;&gt;&gt; for rules (b) and (c)).<br>&gt;&gt;&gt; My intent with (d) was to address a similar concern as in Erica’s<br>&gt;&gt;&gt; `init(truncating …)` and `init(saturating …)`: “if a reasonable reader<br>&gt;&gt;&gt; would be unclear which of N plausible implementation choices <br>&gt;&gt; <br>&gt;&gt; I think/hope you mean “semantic” rather than “implementation” here.<br>&gt;&gt; <br>&gt;&gt;&gt; you are making, you may wish to label the argument, even if you only<br>&gt;&gt;&gt; have a single such function”…but, again, it’s hard to find any<br>&gt;&gt;&gt; examples for (d) that aren’t also some mixture of (b) and/or (c).<br>&gt;&gt; <br>&gt;&gt; Okay, well the fewer (ahem) guidelines, the better.  Let&#39;s pretend you<br>&gt;&gt; didn&#39;t propose (d) and see how well it works.<br>&gt;&gt; <br>&gt;&gt;&gt; ### II. Multi-Argument Functions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #### RULES:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - general rule: label all arguments<br>&gt;&gt;&gt; - exceptions:<br>&gt;&gt;&gt;  - (a) omit the first label whenever the first argument is the<br>&gt;&gt;&gt;    semantic focus, and the other arguments are some mix of “details,<br>&gt;&gt;&gt;    adjustments, or modifiers”<br>&gt;&gt; <br>&gt;&gt; This seems to be a different way of expressing something I was getting<br>&gt;&gt; at with the guidelines I posted to start this thread.  I worry that what<br>&gt;&gt; it means for an argument to be “the semantic focus” is too vague.  Why<br>&gt;&gt; is it an improvement over what I wrote?<br>&gt;<br>&gt; I address this in the main response.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;  - (b) omit labels entirely whenever argument-ordering is irrelevant<br>&gt;&gt;&gt;    to the output (see below)<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think you mean this case:<br>&gt;&gt; <br>&gt;&gt; func f(answer answer: Int = 42, message: String = &quot;Hello, world&quot;) {       <br>&gt;&gt;  print(&quot;\(message)! The answer is \(answer)&quot;)                                  <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Why is this an improvement over the way it&#39;s phrased in the original<br>&gt;&gt; guidelines proposal: “when the arguments are peers that can&#39;t be<br>&gt;&gt; usefully distinguished”?<br>&gt;<br>&gt; My framing made more sense to me because “peers” and “can’t easily be<br>&gt; distinguished” seemed vaguer than what I *meant*, but based on the<br>&gt; counterexample you supplied my phrasing must indeed be too awful to<br>&gt; use.<br>&gt;<br>&gt; I was trying to replace “peers that can’t usefully be distinguished”<br>&gt; (what are peers? what does “can’t be usefully distinguished” actually<br>&gt; mean?) with something stronger (perhaps &quot;any permutation of arguments<br>&gt; produces indistinguishable results”), but that wouldn’t actually cover<br>&gt; all cases either (e.b. `isLessThan`).<br></p><p>We can always try to refine what I wrote to make it clearer, but in this<br>thread I&#39;d like to focus on the *substance* of the guidelines for first<br>argument labels.<br></p><p>&gt;&gt;&gt; #### REMARKS:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For (a), the assumption is that we have a general consensus that “in<br>&gt;&gt;&gt; methods for which one of the arguments is the semantic focus, that<br>&gt;&gt;&gt; argument should be the first argument”; this seems pretty widely<br>&gt;&gt;&gt; followed.<br>&gt;&gt; <br>&gt;&gt; I think using known and well-defined terms like “sentence” (or even<br>&gt;&gt; lesser-known but well-defined terms like “clause”) is probably much<br>&gt;&gt; better than using an ill-defined concept like “argument is the semantic<br>&gt;&gt; focus.”  Even if you can define this concept clearly, it would have to<br>&gt;&gt; offer some very compelling advantages to be an improvement over<br>&gt;&gt; something that is already well-established.  What are those?<br>&gt;<br>&gt; This is the main reply.<br>&gt;<br>&gt; First, I think it’s fair to say that, as-formulated, you can’t simultaneously:<br>&gt;<br>&gt; - (a) take the sentence/clause rule seriously (or “use it rigorously”)<br>&gt; - (b) justify many of the existing standard-library APIs (and the intended Cocoa imports)<br>&gt;<br>&gt; Consider the following examples:<br>&gt;<br>&gt; // today:<br>&gt; func rangeOfString(searchString: String, options mask: NSStringCompareOptions) -&gt; NSRange<br>&gt; func stringByTrimmingCharactersInSet(characterSet: NSCharacterSet) -&gt; String<br>&gt; func indexOf(element: Element) -&gt; Index?<br>&gt;<br>&gt; // ideal tomorrow, i assume:<br>&gt; func rangeOf(searchString: String, options: NSStringCompareOptions) -&gt;<br>&gt; NSRange<br></p><p>  s.find(subString, .ignoringCase | .ignoringDiacriticalMarks) -&gt; Range&lt;String.Index&gt;<br></p><p>&gt; func trimming(characterSet: NSCharacterSet) -&gt; String func<br></p><p>  s.trimming(.whitespaceAndNewlines)<br></p><p>Gah; you&#39;re right, here.  Keeping a linguistic basis requires backing<br>off all the way from “sentence” to “phrase.”  That&#39;s actually where I<br>started with this guideline, but thought I&#39;d be able to strengthen it.<br>Saying “sentence or noun phrase” (if it works) might be better than just<br>“phrase” because “noun phrase” is always a term of art, whereas “phrase”<br>might just be interpreted casually.<br></p><p>&gt; indexOf(element: Element) -&gt; Index?<br></p><p>Also a noun phrase.<br></p><p>&gt; …how do we (b) justify the lack of first-argument labels in that<br>&gt; “ideal tomorrow” while still also (a) actually applying the<br>&gt; sentence/clause rule?<br></p><p>Well, I think it&#39;s just that the rule needs a little adjusting.<br></p><p>&gt; At least to my eyes, “a, range of b”, “a, trimming b”, and “a, index<br>&gt; of b”, are questionable even as clauses, let alone as sentences.<br></p><p>Yes.  Phrases, though?<br></p><p>&gt; It seems hard to resolve the above without either:<br>&gt;<br>&gt; - introducing a *lot* of wiggle-room (“completes a sentence, or would<br>&gt; only require some vacuous filler words to complete a sentence”)<br>&gt; - complicating it tremendously (one rule for noun-like method names,<br>&gt; another for verb-like method names, another for -ing method names,<br>&gt; etc.)<br>&gt; - weakening the condition from an if-and-only-if *rule* to a “may<br>&gt; consider, but also remember other guidelines like ‘omit needless<br>&gt; words’&quot;<br>&gt;<br>&gt; …and thus although I generally agree with what I see as the *intent*<br>&gt; behind the sentence/clause rule, I’m not sure it’s actually a usable<br>&gt; rule as-formulated.<br></p><p>I agree.  But I think minor adjustments fix it.<br></p><p>&gt; If you accept that the “sentence/clause rule” is gone, what’s left of<br>&gt; the proposed guideline is the “describes the primary semantics”<br>&gt; aspect.<br>&gt;<br>&gt; Here, I prefer a formulation for “primary semantic focus” because it<br>&gt; seems it leads to easier dispute-resolution. EG, for `addObserver`, it<br>&gt; seems easier to get agreement that `playbackController` is somehow the<br>&gt; “focus” in uses like the below:<br>&gt;<br>&gt; // ignoring the `options:context:` part:<br>&gt; playerItem.addObserver(playbackController, forKeyPath: “status”)<br>&gt; playerItem.addObserver(playbackController, forKeyPath: “duration”)<br>&gt; playerItem.addObserver(playbackController, forKeyPath: “tracks”)<br></p><p>I would argue that the receiver is the obvious focus, so this seems much<br>less clear to me.<br></p><p>&gt; …than to win an argument over whether or not “add observer” describes<br>&gt; *enough* of the “primary semantics” of this method to fall under the<br>&gt; proposed guideline.<br></p><p>That seems less ambiguous to me than primary focus, and I believe a few<br>examples in the guidelines would be enough to settle most debates.<br></p><p>&gt;<br>&gt;<br>&gt; But that’s just an opinion, and on reflection I don’t think “primary<br>&gt; semantic focus” is the clearest formulation, either; I just don’t have<br>&gt; anything better.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; This rule seems to cover e.g. `addObserver(_:forKeyPath:)` and<br>&gt;&gt;&gt; `addObserver(_:selector:name:object:)` and `encodeObject(_:forKey:)`<br>&gt;&gt;&gt; and `present(_:animated:completion:)` (née<br>&gt;&gt;&gt; `presentViewController(_:animated:completion:)`), and so on.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A point to bring up is that under these rules, the “evolution” of a<br>&gt;&gt;&gt; name would be different: the just-so story for how<br>&gt;&gt;&gt; `addObserver(_:forKeyPath:)` came to be so-called is that it *began*<br>&gt;&gt;&gt; as `add(observer:forKeyPath:)`, but b/c the `observer` argument is the<br>&gt;&gt;&gt; semantic focus it &quot;made sense to move `observer` into the method<br>&gt;&gt;&gt; name”; that is, the assumption is that functions like<br>&gt;&gt;&gt; `addObserver(_:forKeyPath:)` are considered to be exceptions to the<br>&gt;&gt;&gt; &quot;base convention” and need to be justified.<br>&gt;&gt; <br>&gt;&gt; Okay, I understand it, but I&#39;m not sure why it&#39;s better.  Please explain<br>&gt;&gt; why this is an improvement over the other approach.<br>&gt;&gt; <br>&gt;&gt;&gt; Also note that &quot;counter-examples&quot; to rule (a) are anything for which<br>&gt;&gt;&gt; no one argument is easily-identifiable as the semantic focus.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; EG, in a function like:<br>&gt;&gt;&gt; `adjudicate(plaintiff:defendant:circumstances:)` we can colorably<br>&gt;&gt;&gt; claim `circumstances` is a modifier-type parameter, but we don’t—and<br>&gt;&gt;&gt; shouldn’t!—treat either `plaintiff` or `defendant` as the<br>&gt;&gt;&gt; semantic-focus. If you have two focuses then you have no focus, as it<br>&gt;&gt;&gt; were.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For (b), the intuition is that whenever argument-order is irrelevant,<br>&gt;&gt;&gt; arguments should be unlabelled; thus e.g.:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - min/max: don’t label the arguments<br>&gt;&gt;&gt; - hypot: don’t label the arguments<br>&gt;&gt;&gt; - copysign: ideally, label the arguments<br>&gt;&gt;&gt; - atan2: ideally, label the arguments<br>&gt;&gt; <br>&gt;&gt; Those last two may draw some quibbles from the math domain experts, but<br>&gt;&gt; I agree with the spirit.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …and so on. Note that these examples are all &quot;free functions”; there<br>&gt;&gt;&gt; don’t seem to be many natural examples that *aren’t* free<br>&gt;&gt;&gt; functions. <br>&gt;&gt; <br>&gt;&gt;  colorMixer.blend(color1, color2)<br>&gt;&gt;  track.fade(from: initialVolume, to: targetVolume)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Also, please don’t be mislead by your familiarity with<br>&gt;&gt;&gt; e.g. `copysign` and/or `atan2`; they are used here to illustrate a<br>&gt;&gt;&gt; general principle (argument-ordering) only, but in practice such<br>&gt;&gt;&gt; highly-familiar “legacy functions” might be best-off given<br>&gt;&gt;&gt; special-case handling.<br>&gt;&gt; <br>&gt;&gt; Right, so we&#39;d want different examples.<br>&gt;&gt; <br>&gt;&gt;&gt; ### III. Naming Functions/Ecosystem Rule<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The previous sections essentially assumed the function names are<br>&gt;&gt;&gt; already-chosen (in line with existing conventions) and voice specific<br>&gt;&gt;&gt; argument-labeling preferences.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This section deals with a few changes to how function names should be chosen.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The over-arching consideration is what I’ve been calling the<br>&gt;&gt;&gt; “Ecosystem rule”: whenever a method a member of a “method family&quot;—or<br>&gt;&gt;&gt; could foreseeably become a member of such—one should aim for<br>&gt;&gt;&gt; consistency in the base name, and use argument-labels as necessary;<br>&gt;&gt;&gt; note that method families need not *require* argument labels:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `contains(_: Point)`<br>&gt;&gt;&gt; `contains(_: Line)`<br>&gt;&gt;&gt; `contains(_: Shape)`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …but they *may* require them, as for example in the `login` function<br>&gt;&gt;&gt; that has already been discussed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The “ecosystem-rule&quot; can also be applied somewhat more-broadly;<br>&gt;&gt;&gt; consider the following name suggestions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `animate(duration:animations:)`<br>&gt;&gt;&gt; `animate(duration:animations:completion:)`<br>&gt;&gt;&gt; `animate(duration:delay:options:animations:completion:)`<br>&gt;&gt;&gt; `animateUsingKeyFrames(duration:delay:options:animations:completion:)`<br>&gt;&gt;&gt; `animateUsingSpring(duration:delay:damping:initialVelocity:options:animations:completion:)`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …where the first three form an obvious family, and the next two are<br>&gt;&gt;&gt; obvious “cousins” of that family due to choice of base names.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A corollary of this policy is that the rule (3) suggestion—of omitting<br>&gt;&gt;&gt; something like `…ForIdentifier...` or `(forIdentifier:…)`—will<br>&gt;&gt;&gt; sometimes be overruled out of ecosystem concerns, but I suspect this<br>&gt;&gt;&gt; will be somewhat rare in practice.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, consider the following naming suggestions for the “tracks” example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // solo method (not part of any family)<br>&gt;&gt;&gt; asset.trackWith(trackID)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // family<br>&gt;&gt;&gt; asset.allTracksWith(mediaCharacteristic: …)<br>&gt;&gt;&gt; asset.allTracksWith(mediaType: ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // the below, instead of `trackWith` or `track(<br>&gt;&gt;&gt; asset.firstTrackWith(mediaCharacteristic: ...)<br>&gt;&gt;&gt; asset.firstTrackWith(mediaType: …)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …or the same again, but perhaps dropping the `With` if that’s the overall preference.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In any case, the overall goal behind the &quot;ecosystem rule” is that<br>&gt;&gt;&gt; similar things should be named similarly, and when semantic<br>&gt;&gt;&gt; differences are small-enough it makes sense to use argument labels to<br>&gt;&gt;&gt; make distinctions; different base names should be for functions that<br>&gt;&gt;&gt; are at least a little different from each other.<br>&gt;&gt; <br>&gt;&gt; This “rule” seems pretty darned vague, even after all this explanation.<br>&gt;&gt; I don&#39;t see how it could possibly be stated succinctly,<br>&gt;&gt; <br>&gt;&gt; Furthermore, as I wrote to Erica, I have concerns about anything that<br>&gt;&gt; gives special treatment to method families, specifically:<br>&gt;&gt; <br>&gt;&gt; * I&#39;m wary of adding anything that encourages the creation of<br>&gt;&gt;  “method families,” which have a higher cognitive overhead than many of<br>&gt;&gt;  the alternatives.<br>&gt;&gt; * A guideline that forces you to change an existing non-overloaded API,<br>&gt;&gt;  just because you are adding an overload, is problematic.<br>&gt;<br>&gt; Understood, and noted, so I won’t press it, other than to point out<br>&gt; that method families have come up independently a few times, which may<br>&gt; deserve some consideration.<br>&gt;<br>&gt; My own sense is they are rather more common in application-level code<br>&gt; than would be ideal in standard library code.<br></p><p>They do occur.  I want them to look/feel good.  I just don&#39;t want to<br>make special rules for them, if possible.  Let&#39;s try to come up with<br>guidelines that work for everything with fewer exceptions.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>February  4, 2016 at 01:00:00pm</p></header><div class="content"><p>For the examples discussed below:<br></p><p>func indexOf(element: Element) -&gt; Index?<br>and:<br>func rangeOf(searchString: String, options: NSStringCompareOptions) -&gt;<br>NSRange<br></p><p>would conform to the guidelines given an “implied get” rule, would they not?<br></p><p>trimming() is the problem child.<br></p><p>—CK<br></p><p>&gt; On Feb 4, 2016, at 11:47 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Feb 04 2016, plx &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Feb 4, 2016, at 12:17 AM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Okay, now I&#39;m finally giving this its due—sorry, too much pressure<br>&gt;&gt;&gt; earlier in the day…<br>&gt;&gt; <br>&gt;&gt; No need to apologize, you have a commendable dedication to replies.<br>&gt;&gt; <br>&gt;&gt; Especially now that the disagreements are getting to be increasingly-minor.<br>&gt;&gt; <br>&gt;&gt;&gt; on Wed Feb 03 2016, plx<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; After reading these guidelines and seeing the responses I am glad to<br>&gt;&gt;&gt;&gt; see some consideration given to argument labeling.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; After thinking it over, I think the rules *I* would like to see can be<br>&gt;&gt;&gt;&gt; expressed very straightforwardly much more can be made much A minor<br>&gt;&gt;&gt;&gt; point, but I think it’s important to distinguish between<br>&gt;&gt;&gt;&gt; single-argument functions and multi-argument functions; doing so seems<br>&gt;&gt;&gt;&gt; to simplify the rules (even if there are more of them).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Everything that follows is my preferences, but I generally agree with<br>&gt;&gt;&gt;&gt; Erica’s suggestions in the concrete cases. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ll have to go back and have a look at that<br>&gt;&gt;&gt; *goes back to have a look*<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are there cases that add something significant to what I&#39;ve already<br>&gt;&gt;&gt; written?  I didn&#39;t see any.  If you&#39;re saying what I wrote can be<br>&gt;&gt;&gt; improved by covering specific examples, please tell me which ones.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I also think the emphasis on quasi-grammatical rules-and-roles is<br>&gt;&gt;&gt;&gt; something of a dead-end for design guidelines and won’t include such<br>&gt;&gt;&gt;&gt; considerations in what follows.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Characterizing what we&#39;ve done in the proposed guidelines as emphasizing<br>&gt;&gt;&gt; “quasi-grammatical rules-and-roles” seems like an unnecessary and<br>&gt;&gt;&gt; slightly muddled potshot.  The grammatical stuff in the current document<br>&gt;&gt;&gt; is not in any sense “quasi” and has no connection to the admonition to<br>&gt;&gt;&gt; clarify roles, which I consider to be important.  That said, I&#39;m not at<br>&gt;&gt;&gt; all attached to presenting the guidelines in terms of grammar, so I&#39;m<br>&gt;&gt;&gt; happy to see how your approach works.<br>&gt;&gt; <br>&gt;&gt; On a re-read your thread-starter has been toned-down enough from<br>&gt;&gt; before it’s a lot less in that direction, but see the main response<br>&gt;&gt; below.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## RULES<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ### I. Single-Argument Functions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; #### RULES:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - general rule: don’t label the first argument<br>&gt;&gt;&gt;&gt; - exceptions:<br>&gt;&gt;&gt;&gt; - (a) the argument has a default value (`removeAll(keepCapacity: Bool = default)`)<br>&gt;&gt;&gt;&gt; - (b) the function acts-like a constructor (covered in your rule 2)<br>&gt;&gt;&gt;&gt; - (c) the “ecosystem rule” (see section III)<br>&gt;&gt;&gt;&gt; - (d) the semantics of the argument are non-obvious (see below)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; #### REMARKS:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not sure (d) actually exists, though; every concrete example I can<br>&gt;&gt;&gt;&gt; think up either falls under rule (b) or rule (c). It may not actually<br>&gt;&gt;&gt;&gt; need to be a rule (other than as, perhaps, the underlying motivation<br>&gt;&gt;&gt;&gt; for rules (b) and (c)).<br>&gt;&gt;&gt;&gt; My intent with (d) was to address a similar concern as in Erica’s<br>&gt;&gt;&gt;&gt; `init(truncating …)` and `init(saturating …)`: “if a reasonable reader<br>&gt;&gt;&gt;&gt; would be unclear which of N plausible implementation choices <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think/hope you mean “semantic” rather than “implementation” here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; you are making, you may wish to label the argument, even if you only<br>&gt;&gt;&gt;&gt; have a single such function”…but, again, it’s hard to find any<br>&gt;&gt;&gt;&gt; examples for (d) that aren’t also some mixture of (b) and/or (c).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Okay, well the fewer (ahem) guidelines, the better.  Let&#39;s pretend you<br>&gt;&gt;&gt; didn&#39;t propose (d) and see how well it works.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ### II. Multi-Argument Functions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; #### RULES:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - general rule: label all arguments<br>&gt;&gt;&gt;&gt; - exceptions:<br>&gt;&gt;&gt;&gt; - (a) omit the first label whenever the first argument is the<br>&gt;&gt;&gt;&gt;   semantic focus, and the other arguments are some mix of “details,<br>&gt;&gt;&gt;&gt;   adjustments, or modifiers”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This seems to be a different way of expressing something I was getting<br>&gt;&gt;&gt; at with the guidelines I posted to start this thread.  I worry that what<br>&gt;&gt;&gt; it means for an argument to be “the semantic focus” is too vague.  Why<br>&gt;&gt;&gt; is it an improvement over what I wrote?<br>&gt;&gt; <br>&gt;&gt; I address this in the main response.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - (b) omit labels entirely whenever argument-ordering is irrelevant<br>&gt;&gt;&gt;&gt;   to the output (see below)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think you mean this case:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f(answer answer: Int = 42, message: String = &quot;Hello, world&quot;) {       <br>&gt;&gt;&gt; print(&quot;\(message)! The answer is \(answer)&quot;)                                  <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why is this an improvement over the way it&#39;s phrased in the original<br>&gt;&gt;&gt; guidelines proposal: “when the arguments are peers that can&#39;t be<br>&gt;&gt;&gt; usefully distinguished”?<br>&gt;&gt; <br>&gt;&gt; My framing made more sense to me because “peers” and “can’t easily be<br>&gt;&gt; distinguished” seemed vaguer than what I *meant*, but based on the<br>&gt;&gt; counterexample you supplied my phrasing must indeed be too awful to<br>&gt;&gt; use.<br>&gt;&gt; <br>&gt;&gt; I was trying to replace “peers that can’t usefully be distinguished”<br>&gt;&gt; (what are peers? what does “can’t be usefully distinguished” actually<br>&gt;&gt; mean?) with something stronger (perhaps &quot;any permutation of arguments<br>&gt;&gt; produces indistinguishable results”), but that wouldn’t actually cover<br>&gt;&gt; all cases either (e.b. `isLessThan`).<br>&gt; <br>&gt; We can always try to refine what I wrote to make it clearer, but in this<br>&gt; thread I&#39;d like to focus on the *substance* of the guidelines for first<br>&gt; argument labels.<br>&gt; <br>&gt;&gt;&gt;&gt; #### REMARKS:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For (a), the assumption is that we have a general consensus that “in<br>&gt;&gt;&gt;&gt; methods for which one of the arguments is the semantic focus, that<br>&gt;&gt;&gt;&gt; argument should be the first argument”; this seems pretty widely<br>&gt;&gt;&gt;&gt; followed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think using known and well-defined terms like “sentence” (or even<br>&gt;&gt;&gt; lesser-known but well-defined terms like “clause”) is probably much<br>&gt;&gt;&gt; better than using an ill-defined concept like “argument is the semantic<br>&gt;&gt;&gt; focus.”  Even if you can define this concept clearly, it would have to<br>&gt;&gt;&gt; offer some very compelling advantages to be an improvement over<br>&gt;&gt;&gt; something that is already well-established.  What are those?<br>&gt;&gt; <br>&gt;&gt; This is the main reply.<br>&gt;&gt; <br>&gt;&gt; First, I think it’s fair to say that, as-formulated, you can’t simultaneously:<br>&gt;&gt; <br>&gt;&gt; - (a) take the sentence/clause rule seriously (or “use it rigorously”)<br>&gt;&gt; - (b) justify many of the existing standard-library APIs (and the intended Cocoa imports)<br>&gt;&gt; <br>&gt;&gt; Consider the following examples:<br>&gt;&gt; <br>&gt;&gt; // today:<br>&gt;&gt; func rangeOfString(searchString: String, options mask: NSStringCompareOptions) -&gt; NSRange<br>&gt;&gt; func stringByTrimmingCharactersInSet(characterSet: NSCharacterSet) -&gt; String<br>&gt;&gt; func indexOf(element: Element) -&gt; Index?<br>&gt;&gt; <br>&gt;&gt; // ideal tomorrow, i assume:<br>&gt;&gt; func rangeOf(searchString: String, options: NSStringCompareOptions) -&gt;<br>&gt;&gt; NSRange<br>&gt; <br>&gt;  s.find(subString, .ignoringCase | .ignoringDiacriticalMarks) -&gt; Range&lt;String.Index&gt;<br>&gt; <br>&gt;&gt; func trimming(characterSet: NSCharacterSet) -&gt; String func<br>&gt; <br>&gt;  s.trimming(.whitespaceAndNewlines)<br>&gt; <br>&gt; Gah; you&#39;re right, here.  Keeping a linguistic basis requires backing<br>&gt; off all the way from “sentence” to “phrase.”  That&#39;s actually where I<br>&gt; started with this guideline, but thought I&#39;d be able to strengthen it.<br>&gt; Saying “sentence or noun phrase” (if it works) might be better than just<br>&gt; “phrase” because “noun phrase” is always a term of art, whereas “phrase”<br>&gt; might just be interpreted casually.<br>&gt; <br>&gt;&gt; indexOf(element: Element) -&gt; Index?<br>&gt; <br>&gt; Also a noun phrase.<br>&gt; <br>&gt;&gt; …how do we (b) justify the lack of first-argument labels in that<br>&gt;&gt; “ideal tomorrow” while still also (a) actually applying the<br>&gt;&gt; sentence/clause rule?<br>&gt; <br>&gt; Well, I think it&#39;s just that the rule needs a little adjusting.<br>&gt; <br>&gt;&gt; At least to my eyes, “a, range of b”, “a, trimming b”, and “a, index<br>&gt;&gt; of b”, are questionable even as clauses, let alone as sentences.<br>&gt; <br>&gt; Yes.  Phrases, though?<br>&gt; <br>&gt;&gt; It seems hard to resolve the above without either:<br>&gt;&gt; <br>&gt;&gt; - introducing a *lot* of wiggle-room (“completes a sentence, or would<br>&gt;&gt; only require some vacuous filler words to complete a sentence”)<br>&gt;&gt; - complicating it tremendously (one rule for noun-like method names,<br>&gt;&gt; another for verb-like method names, another for -ing method names,<br>&gt;&gt; etc.)<br>&gt;&gt; - weakening the condition from an if-and-only-if *rule* to a “may<br>&gt;&gt; consider, but also remember other guidelines like ‘omit needless<br>&gt;&gt; words’&quot;<br>&gt;&gt; <br>&gt;&gt; …and thus although I generally agree with what I see as the *intent*<br>&gt;&gt; behind the sentence/clause rule, I’m not sure it’s actually a usable<br>&gt;&gt; rule as-formulated.<br>&gt; <br>&gt; I agree.  But I think minor adjustments fix it.<br>&gt; <br>&gt;&gt; If you accept that the “sentence/clause rule” is gone, what’s left of<br>&gt;&gt; the proposed guideline is the “describes the primary semantics”<br>&gt;&gt; aspect.<br>&gt;&gt; <br>&gt;&gt; Here, I prefer a formulation for “primary semantic focus” because it<br>&gt;&gt; seems it leads to easier dispute-resolution. EG, for `addObserver`, it<br>&gt;&gt; seems easier to get agreement that `playbackController` is somehow the<br>&gt;&gt; “focus” in uses like the below:<br>&gt;&gt; <br>&gt;&gt; // ignoring the `options:context:` part:<br>&gt;&gt; playerItem.addObserver(playbackController, forKeyPath: “status”)<br>&gt;&gt; playerItem.addObserver(playbackController, forKeyPath: “duration”)<br>&gt;&gt; playerItem.addObserver(playbackController, forKeyPath: “tracks”)<br>&gt; <br>&gt; I would argue that the receiver is the obvious focus, so this seems much<br>&gt; less clear to me.<br>&gt; <br>&gt;&gt; …than to win an argument over whether or not “add observer” describes<br>&gt;&gt; *enough* of the “primary semantics” of this method to fall under the<br>&gt;&gt; proposed guideline.<br>&gt; <br>&gt; That seems less ambiguous to me than primary focus, and I believe a few<br>&gt; examples in the guidelines would be enough to settle most debates.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; But that’s just an opinion, and on reflection I don’t think “primary<br>&gt;&gt; semantic focus” is the clearest formulation, either; I just don’t have<br>&gt;&gt; anything better.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This rule seems to cover e.g. `addObserver(_:forKeyPath:)` and<br>&gt;&gt;&gt;&gt; `addObserver(_:selector:name:object:)` and `encodeObject(_:forKey:)`<br>&gt;&gt;&gt;&gt; and `present(_:animated:completion:)` (née<br>&gt;&gt;&gt;&gt; `presentViewController(_:animated:completion:)`), and so on.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A point to bring up is that under these rules, the “evolution” of a<br>&gt;&gt;&gt;&gt; name would be different: the just-so story for how<br>&gt;&gt;&gt;&gt; `addObserver(_:forKeyPath:)` came to be so-called is that it *began*<br>&gt;&gt;&gt;&gt; as `add(observer:forKeyPath:)`, but b/c the `observer` argument is the<br>&gt;&gt;&gt;&gt; semantic focus it &quot;made sense to move `observer` into the method<br>&gt;&gt;&gt;&gt; name”; that is, the assumption is that functions like<br>&gt;&gt;&gt;&gt; `addObserver(_:forKeyPath:)` are considered to be exceptions to the<br>&gt;&gt;&gt;&gt; &quot;base convention” and need to be justified.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Okay, I understand it, but I&#39;m not sure why it&#39;s better.  Please explain<br>&gt;&gt;&gt; why this is an improvement over the other approach.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also note that &quot;counter-examples&quot; to rule (a) are anything for which<br>&gt;&gt;&gt;&gt; no one argument is easily-identifiable as the semantic focus.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; EG, in a function like:<br>&gt;&gt;&gt;&gt; `adjudicate(plaintiff:defendant:circumstances:)` we can colorably<br>&gt;&gt;&gt;&gt; claim `circumstances` is a modifier-type parameter, but we don’t—and<br>&gt;&gt;&gt;&gt; shouldn’t!—treat either `plaintiff` or `defendant` as the<br>&gt;&gt;&gt;&gt; semantic-focus. If you have two focuses then you have no focus, as it<br>&gt;&gt;&gt;&gt; were.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For (b), the intuition is that whenever argument-order is irrelevant,<br>&gt;&gt;&gt;&gt; arguments should be unlabelled; thus e.g.:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - min/max: don’t label the arguments<br>&gt;&gt;&gt;&gt; - hypot: don’t label the arguments<br>&gt;&gt;&gt;&gt; - copysign: ideally, label the arguments<br>&gt;&gt;&gt;&gt; - atan2: ideally, label the arguments<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Those last two may draw some quibbles from the math domain experts, but<br>&gt;&gt;&gt; I agree with the spirit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …and so on. Note that these examples are all &quot;free functions”; there<br>&gt;&gt;&gt;&gt; don’t seem to be many natural examples that *aren’t* free<br>&gt;&gt;&gt;&gt; functions. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; colorMixer.blend(color1, color2)<br>&gt;&gt;&gt; track.fade(from: initialVolume, to: targetVolume)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, please don’t be mislead by your familiarity with<br>&gt;&gt;&gt;&gt; e.g. `copysign` and/or `atan2`; they are used here to illustrate a<br>&gt;&gt;&gt;&gt; general principle (argument-ordering) only, but in practice such<br>&gt;&gt;&gt;&gt; highly-familiar “legacy functions” might be best-off given<br>&gt;&gt;&gt;&gt; special-case handling.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right, so we&#39;d want different examples.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ### III. Naming Functions/Ecosystem Rule<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The previous sections essentially assumed the function names are<br>&gt;&gt;&gt;&gt; already-chosen (in line with existing conventions) and voice specific<br>&gt;&gt;&gt;&gt; argument-labeling preferences.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This section deals with a few changes to how function names should be chosen.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The over-arching consideration is what I’ve been calling the<br>&gt;&gt;&gt;&gt; “Ecosystem rule”: whenever a method a member of a “method family&quot;—or<br>&gt;&gt;&gt;&gt; could foreseeably become a member of such—one should aim for<br>&gt;&gt;&gt;&gt; consistency in the base name, and use argument-labels as necessary;<br>&gt;&gt;&gt;&gt; note that method families need not *require* argument labels:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `contains(_: Point)`<br>&gt;&gt;&gt;&gt; `contains(_: Line)`<br>&gt;&gt;&gt;&gt; `contains(_: Shape)`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …but they *may* require them, as for example in the `login` function<br>&gt;&gt;&gt;&gt; that has already been discussed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The “ecosystem-rule&quot; can also be applied somewhat more-broadly;<br>&gt;&gt;&gt;&gt; consider the following name suggestions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `animate(duration:animations:)`<br>&gt;&gt;&gt;&gt; `animate(duration:animations:completion:)`<br>&gt;&gt;&gt;&gt; `animate(duration:delay:options:animations:completion:)`<br>&gt;&gt;&gt;&gt; `animateUsingKeyFrames(duration:delay:options:animations:completion:)`<br>&gt;&gt;&gt;&gt; `animateUsingSpring(duration:delay:damping:initialVelocity:options:animations:completion:)`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …where the first three form an obvious family, and the next two are<br>&gt;&gt;&gt;&gt; obvious “cousins” of that family due to choice of base names.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A corollary of this policy is that the rule (3) suggestion—of omitting<br>&gt;&gt;&gt;&gt; something like `…ForIdentifier...` or `(forIdentifier:…)`—will<br>&gt;&gt;&gt;&gt; sometimes be overruled out of ecosystem concerns, but I suspect this<br>&gt;&gt;&gt;&gt; will be somewhat rare in practice.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example, consider the following naming suggestions for the “tracks” example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // solo method (not part of any family)<br>&gt;&gt;&gt;&gt; asset.trackWith(trackID)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // family<br>&gt;&gt;&gt;&gt; asset.allTracksWith(mediaCharacteristic: …)<br>&gt;&gt;&gt;&gt; asset.allTracksWith(mediaType: ...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // the below, instead of `trackWith` or `track(<br>&gt;&gt;&gt;&gt; asset.firstTrackWith(mediaCharacteristic: ...)<br>&gt;&gt;&gt;&gt; asset.firstTrackWith(mediaType: …)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …or the same again, but perhaps dropping the `With` if that’s the overall preference.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In any case, the overall goal behind the &quot;ecosystem rule” is that<br>&gt;&gt;&gt;&gt; similar things should be named similarly, and when semantic<br>&gt;&gt;&gt;&gt; differences are small-enough it makes sense to use argument labels to<br>&gt;&gt;&gt;&gt; make distinctions; different base names should be for functions that<br>&gt;&gt;&gt;&gt; are at least a little different from each other.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This “rule” seems pretty darned vague, even after all this explanation.<br>&gt;&gt;&gt; I don&#39;t see how it could possibly be stated succinctly,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Furthermore, as I wrote to Erica, I have concerns about anything that<br>&gt;&gt;&gt; gives special treatment to method families, specifically:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * I&#39;m wary of adding anything that encourages the creation of<br>&gt;&gt;&gt; “method families,” which have a higher cognitive overhead than many of<br>&gt;&gt;&gt; the alternatives.<br>&gt;&gt;&gt; * A guideline that forces you to change an existing non-overloaded API,<br>&gt;&gt;&gt; just because you are adding an overload, is problematic.<br>&gt;&gt; <br>&gt;&gt; Understood, and noted, so I won’t press it, other than to point out<br>&gt;&gt; that method families have come up independently a few times, which may<br>&gt;&gt; deserve some consideration.<br>&gt;&gt; <br>&gt;&gt; My own sense is they are rather more common in application-level code<br>&gt;&gt; than would be ideal in standard library code.<br>&gt; <br>&gt; They do occur.  I want them to look/feel good.  I just don&#39;t want to<br>&gt; make special rules for them, if possible.  Let&#39;s try to come up with<br>&gt; guidelines that work for everything with fewer exceptions.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February  4, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Feb 4, 2016, at 1:47 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt; <br>&gt;  s.find(subString, .ignoringCase | .ignoringDiacriticalMarks) -&gt; Range&lt;String.Index&gt;<br>&gt; <br>&gt;&gt; func trimming(characterSet: NSCharacterSet) -&gt; String func<br>&gt; <br>&gt;  s.trimming(.whitespaceAndNewlines)<br>&gt; <br>&gt; Gah; you&#39;re right, here.  Keeping a linguistic basis requires backing<br>&gt; off all the way from “sentence” to “phrase.”  That&#39;s actually where I<br>&gt; started with this guideline, but thought I&#39;d be able to strengthen it.<br>&gt; Saying “sentence or noun phrase” (if it works) might be better than just<br>&gt; “phrase” because “noun phrase” is always a term of art, whereas “phrase”<br>&gt; might just be interpreted casually.<br></p><p>I think sentence-or-noun-phrase covers things “linguistically&quot;, but it seems to carve out a pretty territory; other than special-cases (init, operators, label-less functions like `min`), I can’t think of anything that would be:<br></p><p>- reasonably-named (e.g. a name you’d actually want to use)<br>- *not* satisfying the proposed sentence-or-noun-phrase rule<br></p><p>…is there a good example of such?<br></p><p>Even if that’s right I’m not sure it’s a bad thing, but it’s still broad enough to give me a little pause; it may actually be the easiest way to carve out the non-init, non-operator, non-label-free-functions.<br></p><p>&gt;&gt; …than to win an argument over whether or not “add observer” describes<br>&gt;&gt; *enough* of the “primary semantics” of this method to fall under the<br>&gt;&gt; proposed guideline.<br>&gt; <br>&gt; That seems less ambiguous to me than primary focus, and I believe a few<br>&gt; examples in the guidelines would be enough to settle most debates.<br></p><p>Fair enough. There’s still a subtle ambiguity in &quot;primary semantics” (is it primary in the sense of “describing the most-important part&quot; of the semantics, or is it “primary semantics” in the sense of “describes the majority/most(/etc.) of the semantics”), but examples should be enough to clear it up.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; But that’s just an opinion, and on reflection I don’t think “primary<br>&gt;&gt; semantic focus” is the clearest formulation, either; I just don’t have<br>&gt;&gt; anything better.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This rule seems to cover e.g. `addObserver(_:forKeyPath:)` and<br>&gt;&gt;&gt;&gt; `addObserver(_:selector:name:object:)` and `encodeObject(_:forKey:)`<br>&gt;&gt;&gt;&gt; and `present(_:animated:completion:)` (née<br>&gt;&gt;&gt;&gt; `presentViewController(_:animated:completion:)`), and so on.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A point to bring up is that under these rules, the “evolution” of a<br>&gt;&gt;&gt;&gt; name would be different: the just-so story for how<br>&gt;&gt;&gt;&gt; `addObserver(_:forKeyPath:)` came to be so-called is that it *began*<br>&gt;&gt;&gt;&gt; as `add(observer:forKeyPath:)`, but b/c the `observer` argument is the<br>&gt;&gt;&gt;&gt; semantic focus it &quot;made sense to move `observer` into the method<br>&gt;&gt;&gt;&gt; name”; that is, the assumption is that functions like<br>&gt;&gt;&gt;&gt; `addObserver(_:forKeyPath:)` are considered to be exceptions to the<br>&gt;&gt;&gt;&gt; &quot;base convention” and need to be justified.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Okay, I understand it, but I&#39;m not sure why it&#39;s better.  Please explain<br>&gt;&gt;&gt; why this is an improvement over the other approach.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also note that &quot;counter-examples&quot; to rule (a) are anything for which<br>&gt;&gt;&gt;&gt; no one argument is easily-identifiable as the semantic focus.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; EG, in a function like:<br>&gt;&gt;&gt;&gt; `adjudicate(plaintiff:defendant:circumstances:)` we can colorably<br>&gt;&gt;&gt;&gt; claim `circumstances` is a modifier-type parameter, but we don’t—and<br>&gt;&gt;&gt;&gt; shouldn’t!—treat either `plaintiff` or `defendant` as the<br>&gt;&gt;&gt;&gt; semantic-focus. If you have two focuses then you have no focus, as it<br>&gt;&gt;&gt;&gt; were.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For (b), the intuition is that whenever argument-order is irrelevant,<br>&gt;&gt;&gt;&gt; arguments should be unlabelled; thus e.g.:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - min/max: don’t label the arguments<br>&gt;&gt;&gt;&gt; - hypot: don’t label the arguments<br>&gt;&gt;&gt;&gt; - copysign: ideally, label the arguments<br>&gt;&gt;&gt;&gt; - atan2: ideally, label the arguments<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Those last two may draw some quibbles from the math domain experts, but<br>&gt;&gt;&gt; I agree with the spirit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …and so on. Note that these examples are all &quot;free functions”; there<br>&gt;&gt;&gt;&gt; don’t seem to be many natural examples that *aren’t* free<br>&gt;&gt;&gt;&gt; functions. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; colorMixer.blend(color1, color2)<br>&gt;&gt;&gt; track.fade(from: initialVolume, to: targetVolume)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, please don’t be mislead by your familiarity with<br>&gt;&gt;&gt;&gt; e.g. `copysign` and/or `atan2`; they are used here to illustrate a<br>&gt;&gt;&gt;&gt; general principle (argument-ordering) only, but in practice such<br>&gt;&gt;&gt;&gt; highly-familiar “legacy functions” might be best-off given<br>&gt;&gt;&gt;&gt; special-case handling.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right, so we&#39;d want different examples.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ### III. Naming Functions/Ecosystem Rule<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The previous sections essentially assumed the function names are<br>&gt;&gt;&gt;&gt; already-chosen (in line with existing conventions) and voice specific<br>&gt;&gt;&gt;&gt; argument-labeling preferences.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This section deals with a few changes to how function names should be chosen.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The over-arching consideration is what I’ve been calling the<br>&gt;&gt;&gt;&gt; “Ecosystem rule”: whenever a method a member of a “method family&quot;—or<br>&gt;&gt;&gt;&gt; could foreseeably become a member of such—one should aim for<br>&gt;&gt;&gt;&gt; consistency in the base name, and use argument-labels as necessary;<br>&gt;&gt;&gt;&gt; note that method families need not *require* argument labels:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `contains(_: Point)`<br>&gt;&gt;&gt;&gt; `contains(_: Line)`<br>&gt;&gt;&gt;&gt; `contains(_: Shape)`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …but they *may* require them, as for example in the `login` function<br>&gt;&gt;&gt;&gt; that has already been discussed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The “ecosystem-rule&quot; can also be applied somewhat more-broadly;<br>&gt;&gt;&gt;&gt; consider the following name suggestions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `animate(duration:animations:)`<br>&gt;&gt;&gt;&gt; `animate(duration:animations:completion:)`<br>&gt;&gt;&gt;&gt; `animate(duration:delay:options:animations:completion:)`<br>&gt;&gt;&gt;&gt; `animateUsingKeyFrames(duration:delay:options:animations:completion:)`<br>&gt;&gt;&gt;&gt; `animateUsingSpring(duration:delay:damping:initialVelocity:options:animations:completion:)`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …where the first three form an obvious family, and the next two are<br>&gt;&gt;&gt;&gt; obvious “cousins” of that family due to choice of base names.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A corollary of this policy is that the rule (3) suggestion—of omitting<br>&gt;&gt;&gt;&gt; something like `…ForIdentifier...` or `(forIdentifier:…)`—will<br>&gt;&gt;&gt;&gt; sometimes be overruled out of ecosystem concerns, but I suspect this<br>&gt;&gt;&gt;&gt; will be somewhat rare in practice.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example, consider the following naming suggestions for the “tracks” example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // solo method (not part of any family)<br>&gt;&gt;&gt;&gt; asset.trackWith(trackID)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // family<br>&gt;&gt;&gt;&gt; asset.allTracksWith(mediaCharacteristic: …)<br>&gt;&gt;&gt;&gt; asset.allTracksWith(mediaType: ...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // the below, instead of `trackWith` or `track(<br>&gt;&gt;&gt;&gt; asset.firstTrackWith(mediaCharacteristic: ...)<br>&gt;&gt;&gt;&gt; asset.firstTrackWith(mediaType: …)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …or the same again, but perhaps dropping the `With` if that’s the overall preference.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In any case, the overall goal behind the &quot;ecosystem rule” is that<br>&gt;&gt;&gt;&gt; similar things should be named similarly, and when semantic<br>&gt;&gt;&gt;&gt; differences are small-enough it makes sense to use argument labels to<br>&gt;&gt;&gt;&gt; make distinctions; different base names should be for functions that<br>&gt;&gt;&gt;&gt; are at least a little different from each other.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This “rule” seems pretty darned vague, even after all this explanation.<br>&gt;&gt;&gt; I don&#39;t see how it could possibly be stated succinctly,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Furthermore, as I wrote to Erica, I have concerns about anything that<br>&gt;&gt;&gt; gives special treatment to method families, specifically:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * I&#39;m wary of adding anything that encourages the creation of<br>&gt;&gt;&gt; “method families,” which have a higher cognitive overhead than many of<br>&gt;&gt;&gt; the alternatives.<br>&gt;&gt;&gt; * A guideline that forces you to change an existing non-overloaded API,<br>&gt;&gt;&gt; just because you are adding an overload, is problematic.<br>&gt;&gt; <br>&gt;&gt; Understood, and noted, so I won’t press it, other than to point out<br>&gt;&gt; that method families have come up independently a few times, which may<br>&gt;&gt; deserve some consideration.<br>&gt;&gt; <br>&gt;&gt; My own sense is they are rather more common in application-level code<br>&gt;&gt; than would be ideal in standard library code.<br>&gt; <br>&gt; They do occur.  I want them to look/feel good.  I just don&#39;t want to<br>&gt; make special rules for them, if possible.  Let&#39;s try to come up with<br>&gt; guidelines that work for everything with fewer exceptions.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
