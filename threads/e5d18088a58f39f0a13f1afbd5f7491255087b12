<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Unsafe(Mutable)Pointer (suc)predecessor and advancedBy functions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 26, 2016 at 06:00:00pm</p></header><div class="content"><p>I’ve got one more questions about Unsafe(Mutable)Pointer. I know that I’m able to access memory that might not belong to me.<br></p><p>My question is:<br></p><p>Can I trust these functions that they will return a pointer to some memory when I allocate more than one object AND when I’m moving only inside that range?<br></p><p>public func successor() -&gt; UnsafeMutablePointer&lt;Memory&gt;<br>public func predecessor() -&gt; UnsafeMutablePointer&lt;Memory&gt;<br>public func advancedBy(n: Int) -&gt; UnsafeMutablePointer&lt;Memory&gt;<br>UnsafeMutablePointer&lt;Int&gt;.alloc(4) when I advance only in range of [0,1,2,3] am I safe or could I get a pointer to memory that does not belong to me?<br></p><p>Example:<br></p><p>// imagine this is some memory portion,<br>// where x is memory that does not belong to me<br>// and 0 is moemory free to use<br>     <br>[…, x, 0, 0, 0 x, 0, x, …]<br>     <br>// now I want to allocate 4 objects  <br>// variant A:<br>     <br>[…, x, MY1, MY2, MY3, x, MY4, x, …]<br>     <br>// my pointer will sit at `MY1` and if I advance by 2 I&#39;ll get `x`<br>// can this happen to me?<br>     <br>// variant B:<br>// Unsafe(Mutable)Pointer will ensure that I always get memory tied together  <br>// (or the above functions will skip memory that doesn&#39;t belong to me??):<br>     <br>     <br>[…, x, MY1, MY2, MY3, MY4 x, …]  <br>So which is right?<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160526/e5d17b12/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Unsafe(Mutable)Pointer (suc)predecessor and advancedBy functions</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May 26, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 26, 2016, at 9:59 AM, Adrian Zubarev via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve got one more questions about Unsafe(Mutable)Pointer. I know that I’m able to access memory that might not belong to me. <br>&gt; <br>&gt; My question is:<br>&gt; <br>&gt; Can I trust these functions that they will return a pointer to some memory when I allocate more than one object AND when I’m moving only inside that range?<br>&gt; <br>&gt; <br>Yes.<br>&gt; public func successor() -&gt; UnsafeMutablePointer&lt;Memory&gt;<br>&gt; public func predecessor() -&gt; UnsafeMutablePointer&lt;Memory&gt;<br>&gt; public func advancedBy(n: Int) -&gt; UnsafeMutablePointer&lt;Memory&gt;<br>&gt; UnsafeMutablePointer&lt;Int&gt;.alloc(4) when I advance only in range of [0,1,2,3] am I safe or could I get a pointer to memory that does not belong to me?<br>&gt; <br>&gt; <br>UnsafeMutablePointer&lt;T&gt;.alloc(N) creates a single object in memory that holds N consecutive T values. Each value resides at index*strideof(T.self) bytes beyond the allocated pointer where index is valid in the range 0..&lt;N.<br></p><p>-Andy<br>&gt; Example:<br>&gt; <br>&gt; // imagine this is some memory portion,<br>&gt; // where x is memory that does not belong to me<br>&gt; // and 0 is moemory free to use<br>&gt;      <br>&gt; […, x, 0, 0, 0 x, 0, x, …]<br>&gt;      <br>&gt; // now I want to allocate 4 objects  <br>&gt; // variant A:<br>&gt;      <br>&gt; […, x, MY1, MY2, MY3, x, MY4, x, …]<br>&gt;      <br>&gt; // my pointer will sit at `MY1` and if I advance by 2 I&#39;ll get `x`<br>&gt; // can this happen to me?<br>&gt;      <br>&gt; // variant B:<br>&gt; // Unsafe(Mutable)Pointer will ensure that I always get memory tied together  <br>&gt; // (or the above functions will skip memory that doesn&#39;t belong to me??):<br>&gt;      <br>&gt;      <br>&gt; […, x, MY1, MY2, MY3, MY4 x, …]  <br>&gt; So which is right?<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160526/7ab5c730/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Unsafe(Mutable)Pointer (suc)predecessor and advancedBy functions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 26, 2016 at 07:00:00pm</p></header><div class="content"><p>So theoretically I could build a wrapper type for Unsafe(Mutable)Pointer which will be safe to use and never exceed the allocated range!<br></p><p>public func successor() -&gt; UnsafeMutablePointer&lt;Memory&gt;? {<br>     <br>    // return `nil` if out of range<br>}<br>So why don’t we have safe pointers today?<br>Any technical reasons or do I miss something here?!<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 26. Mai 2016 bei 19:14:41, Andrew Trick (atrick at apple.com) schrieb:<br></p><p><br>On May 26, 2016, at 9:59 AM, Adrian Zubarev via swift-users &lt;swift-users at swift.org&gt; wrote:<br></p><p>I’ve got one more questions about Unsafe(Mutable)Pointer. I know that I’m able to access memory that might not belong to me. <br></p><p>My question is:<br></p><p>Can I trust these functions that they will return a pointer to some memory when I allocate more than one object AND when I’m moving only inside that range?<br></p><p><br>Yes.<br>public func successor() -&gt; UnsafeMutablePointer&lt;Memory&gt;<br>public func predecessor() -&gt; UnsafeMutablePointer&lt;Memory&gt;<br>public func advancedBy(n: Int) -&gt; UnsafeMutablePointer&lt;Memory&gt;<br></p><p>UnsafeMutablePointer&lt;Int&gt;.alloc(4) when I advance only in range of [0,1,2,3] am I safe or could I get a pointer to memory that does not belong to me?<br></p><p><br>UnsafeMutablePointer&lt;T&gt;.alloc(N) creates a single object in memory that holds N consecutive T values. Each value resides at index*strideof(T.self) bytes beyond the allocated pointer where index is valid in the range 0..&lt;N.<br></p><p>-Andy<br>Example:<br></p><p>// imagine this is some memory portion,<br>// where x is memory that does not belong to me<br>// and 0 is moemory free to use<br>      <br>[…, x, 0, 0, 0 x, 0, x, …]<br>      <br>// now I want to allocate 4 objects   <br>// variant A:<br>      <br>[…, x, MY1, MY2, MY3, x, MY4, x, …]<br>      <br>// my pointer will sit at `MY1` and if I advance by 2 I&#39;ll get `x`<br>// can this happen to me?<br>      <br>// variant B:<br>// Unsafe(Mutable)Pointer will ensure that I always get memory tied together   <br>// (or the above functions will skip memory that doesn&#39;t belong to me??):<br>      <br>      <br>[…, x, MY1, MY2, MY3, MY4 x, …]   <br></p><p>So which is right?<br></p><p><br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>_______________________________________________<br>swift-users mailing list<br>swift-users at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160526/08b97634/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Unsafe(Mutable)Pointer (suc)predecessor and advancedBy functions</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 26, 2016 at 11:00:00am</p></header><div class="content"><p>On Thu, May 26, 2016 at 10:31 AM, Adrian Zubarev via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; So theoretically I could build a wrapper type for Unsafe(Mutable)Pointer<br>&gt; which will be safe to use and never exceed the allocated range!<br>&gt;<br>Yeah, if I remember correctly this is actually how the Swift collections<br>are implemented.<br></p><p>&gt; public func successor() -&gt; UnsafeMutablePointer&lt;Memory&gt;? {<br>&gt;<br>&gt;     // return `nil` if out of range<br>&gt; }<br>&gt;<br>&gt;<br>&gt;    1. So why don’t we have safe pointers today?<br>&gt;    2. Any technical reasons or do I miss something here?!<br>&gt;<br>&gt; The check for safety imposes a performance cost, which may or may not be<br>okay.<br></p><p>It&#39;s also not clear sometimes exactly what &quot;out of bounds&quot; means - for<br>example, you might have a big chunk of memory representing an array, and<br>then you take a pointer to only part of that memory, representing a slice<br>of the array. In this case you can write &quot;out of bounds&quot; of the slice, but<br>the pointer type doesn&#39;t know that (because you are still within the range<br>of the chunk of memory that you got from `UnsafeMutablePointer.memory()`).<br></p><p>The way Swift has you do it is that you can do whatever you want with<br>pointers, but it&#39;s up to you to decide exactly what &quot;in bounds&quot; and &quot;out of<br>bounds&quot; means, and then wrap that all up in a wrapper type with the<br>appropriate checks. That way you can have the raw performance if you really<br>need it, and you can have safety otherwise.<br></p><p><br>&gt;<br>&gt;<br></p><p>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 26. Mai 2016 bei 19:14:41, Andrew Trick (atrick at apple.com) schrieb:<br>&gt;<br>&gt;<br>&gt; On May 26, 2016, at 9:59 AM, Adrian Zubarev via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; I’ve got one more questions about Unsafe(Mutable)Pointer. I know that I’m<br>&gt; able to access memory that might not belong to me.<br>&gt;<br>&gt; My question is:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Can I trust these functions that they will return a pointer to some<br>&gt;    memory when I allocate more than one object AND when I’m moving only inside<br>&gt;    that range?<br>&gt;<br>&gt;<br>&gt; Yes.<br>&gt;<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    public func successor() -&gt; UnsafeMutablePointer&lt;Memory&gt;<br>&gt;    public func predecessor() -&gt; UnsafeMutablePointer&lt;Memory&gt;<br>&gt;    public func advancedBy(n: Int) -&gt; UnsafeMutablePointer&lt;Memory&gt;<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    UnsafeMutablePointer&lt;Int&gt;.alloc(4) when I advance only in range of<br>&gt;    [0,1,2,3] am I safe or could I get a pointer to memory that does not<br>&gt;    belong to me?<br>&gt;<br>&gt;<br>&gt; UnsafeMutablePointer&lt;T&gt;.alloc(N) creates a single object in memory that<br>&gt; holds N consecutive T values. Each value resides at index*strideof(T.self)<br>&gt; bytes beyond the allocated pointer where index is valid in the range 0..&lt;N.<br>&gt;<br>&gt; -Andy<br>&gt;<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Example:<br>&gt;<br>&gt;    // imagine this is some memory portion,<br>&gt;    // where x is memory that does not belong to me<br>&gt;    // and 0 is moemory free to use<br>&gt;<br>&gt;    […, x, 0, 0, 0 x, 0, x, …]<br>&gt;<br>&gt;    // now I want to allocate 4 objects<br>&gt;    // variant A:<br>&gt;<br>&gt;    […, x, MY1, MY2, MY3, x, MY4, x, …]<br>&gt;<br>&gt;    // my pointer will sit at `MY1` and if I advance by 2 I&#39;ll get `x`<br>&gt;    // can this happen to me?<br>&gt;<br>&gt;    // variant B:<br>&gt;    // Unsafe(Mutable)Pointer will ensure that I always get memory tied together<br>&gt;    // (or the above functions will skip memory that doesn&#39;t belong to me??):<br>&gt;<br>&gt;<br>&gt;    […, x, MY1, MY2, MY3, MY4 x, …]<br>&gt;<br>&gt;<br>&gt; So which is right?<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160526/b9305065/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Unsafe(Mutable)Pointer (suc)predecessor and advancedBy functions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 26, 2016 at 08:00:00pm</p></header><div class="content"><p>It&#39;s also not clear sometimes exactly what &quot;out of bounds&quot; means - for example, you might have a big chunk of memory representing an array, and then you take a pointer to only part of that memory, representing a slice of the array. In this case you can write &quot;out of bounds&quot; of the slice, but the pointer type doesn&#39;t know that (because you are still within the range of the chunk of memory that you got from `UnsafeMutablePointer.memory()`). <br></p><p>True story. :D <br>Thank you for clarifying that to me, its a good example. Also the new pointer that I’ll get here won’t be a slice of an array just because `Memory` isn’t a slice. I’ll have to cast the pointer first, but I got the point here. ;)<br></p><p>One more thing:<br></p><p>- How does ARC work here when I create a new pointer to one of my allocated objects? <br>- Do I have 2 strong references to my main piece of memory?<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 26. Mai 2016 bei 20:07:36, Austin Zheng (austinzheng at gmail.com) schrieb:<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160526/61b9bf3f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Unsafe(Mutable)Pointer (suc)predecessor and advancedBy functions</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 26, 2016 at 11:00:00am</p></header><div class="content"><p>This is where it gets tricky.<br></p><p>When you create a chunk of memory using &#39;UnsafeMutablePointer.memory()&#39; or<br>&#39;alloc()&#39;, it&#39;s as if you are programming in C with &#39;malloc&#39; and &#39;free&#39;.<br>The memory you create and the objects you put in that memory don&#39;t<br>participate in ARC - the runtime will not track reference counts or<br>automatically free the memory. The memory will live on forever unless you<br>explicitly call &#39;dealloc()&#39; later.<br></p><p>Using these APIs correctly is quite hard. If you&#39;re not careful you can<br>leak memory (if you lose all pointers before you&#39;ve had a chance to call<br>dealloc), or access invalid memory (you called dealloc earlier, but<br>somewhere else you later access that memory). In a lot of cases a good<br>thing to do is to wrap your unsafe memory buffer inside a regular Swift<br>class, only allow the buffer to be accessed or modified through that class,<br>and have that class be responsible for deallocating the buffer when its<br>deinit is called. This way, you tie the lifetime of that buffer to your<br>Swift class and ARC handles the memory management for you.<br></p><p>Best,<br>Austin<br></p><p><br>On Thu, May 26, 2016 at 11:19 AM, Adrian Zubarev via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; It&#39;s also not clear sometimes exactly what &quot;out of bounds&quot; means - for<br>&gt; example, you might have a big chunk of memory representing an array, and<br>&gt; then you take a pointer to only part of that memory, representing a slice<br>&gt; of the array. In this case you can write &quot;out of bounds&quot; of the slice, but<br>&gt; the pointer type doesn&#39;t know that (because you are still within the range<br>&gt; of the chunk of memory that you got from `UnsafeMutablePointer.memory()`).<br>&gt;<br>&gt;<br>&gt; True story. :D<br>&gt; Thank you for clarifying that to me, its a good example. Also the new<br>&gt; pointer that I’ll get here won’t be a slice of an array just because<br>&gt; `Memory` isn’t a slice. I’ll have to cast the pointer first, but I got the<br>&gt; point here. ;)<br>&gt;<br>&gt; One more thing:<br>&gt;<br>&gt; - How does ARC work here when I create a new pointer to one of my<br>&gt; allocated objects?<br>&gt; - Do I have 2 strong references to my main piece of memory?<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 26. Mai 2016 bei 20:07:36, Austin Zheng (austinzheng at gmail.com)<br>&gt; schrieb:<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160526/53987ab0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[swift-users] Unsafe(Mutable)Pointer (suc)predecessor and advancedBy functions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 26, 2016 at 09:00:00pm</p></header><div class="content"><p>This is where it gets tricky.<br></p><p>When you create a chunk of memory using &#39;UnsafeMutablePointer.memory()&#39; or &#39;alloc()&#39;, it&#39;s as if you are programming in C with &#39;malloc&#39; and &#39;free&#39;. The memory you create and the objects you put in that memory don&#39;t participate in ARC - the runtime will not track reference counts or automatically free the memory. The memory will live on forever unless you explicitly call &#39;dealloc()&#39; later.<br>Check.<br></p><p>Using these APIs correctly is quite hard. If you&#39;re not careful you can leak memory (if you lose all pointers before you&#39;ve had a chance to call dealloc), or access invalid memory (you called dealloc earlier, but somewhere else you later access that memory). In a lot of cases a good thing to do is to wrap your unsafe memory buffer inside a regular Swift class, only allow the buffer to be accessed or modified through that class, and have that class be responsible for deallocating the buffer when its deinit is called. This way, you tie the lifetime of that buffer to your Swift class and ARC handles the memory management for you.<br>Exactly what I’m doing right now. :) But I’m still a little afraid when using these types.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/d8104221/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
