<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Pitch: Progress Tracking in Swift</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 20, 2016 at 10:00:00am</p></header><div class="content"><p>on Sun Jan 17 2016, Charles Srstka via swift-evolution &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg-AT-public.gmane.org&gt; wrote:<br></p><p>&gt; Introduction:<br>&gt;<br>&gt; This is a proposal for a native progress-tracking mechanism in Swift.<br>&gt;<br>&gt; Motivation:<br>&gt;<br>&gt; As most of us know, Foundation includes NSProgress, a class that makes<br>&gt; it fairly simple to implement progress tracking in complex<br>&gt; applications. What makes NSProgress nice is the way that it builds a<br>&gt; tree of progress objects, so that each method or function only needs<br>&gt; to take into account the work that needs to be done in that specific<br>&gt; context, and the parent NSProgress object can interpret that progress<br>&gt; in the context of its own work to be done. NSProgress also provides a<br>&gt; support for common issues like checking whether the user has cancelled<br>&gt; an operation. However, there are a few issues with NSProgress:<br>&gt;<br>&gt; 1. Because NSProgress relies on a thread-local global variable to<br>&gt; store the current progress object, it is impossible to know, outside<br>&gt; of documentation, whether any particular method supports NSProgress or<br>&gt; not, and if the documentation is inadequate, one must resort to<br>&gt; trial-and-error to determine whether NSProgress is supported (this has<br>&gt; been noted before: http://oleb.net/blog/2014/03/nsprogress/).<br>&gt;<br>&gt; 2. NSProgress relies on a paired register-deregister pattern in order<br>&gt; to obtain and release &quot;current&quot; status. One must balance every<br>&gt; becomeCurrentWithPendingUnitCount() call with a resignCurrent() call,<br>&gt; or Bad Thingsâ„¢ will happen. However, this pattern does not work well<br>&gt; with Swift&#39;s error handling mechanism:<br>&gt;<br>&gt; progress.becomeCurrentWithPendingUnitCount(1)<br>&gt; try self.doSomeThingThatMightThrow()<br>&gt; progress.resignCurrent() // If an error occurs, this will never be<br>&gt; called!<br>&gt;<br>&gt; 3. It is very easy to accidentally add a child NSProgress object if<br>&gt; one does not realize that a particular method supports NSProgress. A<br>&gt; couple ways this can happen:<br>&gt;<br>&gt; func doSomething() {<br>&gt;     let progress = NSProgress(totalUnitCount: 10)<br>&gt;<br>&gt;     progress.becomeCurrentWithPendingUnitCount(10)<br>&gt;     doSomethingThatSupportsNSProgress()<br>&gt;     doSomethingThatWeDontExpectSupportsNSProgressButDoes() // whoops,<br>&gt; we just picked up a child accidentally<br>&gt;     progress.resignCurrent()<br>&gt; }<br>&gt;<br>&gt; func doSomething() {<br>&gt;     let progress = NSProgress(totalUnitCount: 10)<br>&gt;<br>&gt;     progress.becomeCurrentWithPendingUnitCount(10)<br>&gt;     doSomethingThatSupportsNSProgress()<br>&gt;     progress.resignCurrent()<br>&gt;<br>&gt;     doSomethingThatWeDontExpectSupportsNSProgressButDoes() // whoops,<br>&gt; this one just picked up our parent&#39;s NSProgress and made it our<br>&gt; sibling<br>&gt; }<br>&gt;<br>&gt; This is particularly problematic when you consider the obvious<br>&gt; workaround for the problem described in #2:<br>&gt;<br>&gt; func doSomething() {<br>&gt;     let progress = NSProgress(totalUnitCount: 10)<br>&gt;<br>&gt;     progress.becomeCurrentWithPendingUnitCount(10)<br>&gt;     defer { progress.resignCurrent() }<br>&gt;<br>&gt;     doSomethingThatSupportsNSProgress()<br>&gt;     doSomethingThatWeDontExpectSupportsNSProgressButDoes() // whoops<br>&gt; }<br>&gt;<br>&gt; I haven&#39;t figured out exactly how to reproduce this reliably yet, but<br>&gt; I have noticed that NSProgress objects can sometimes end up with a<br>&gt; fractionCompleted larger than 1.0 when this occurs.<br>&gt;<br>&gt; 4. Because NSProgress uses a thread-local global variable for the<br>&gt; current progress, one must be vigilant about jumping through specific<br>&gt; hoops when spinning off a task in a new thread, or else the child<br>&gt; task&#39;s NSProgress object will not be properly connected to its parent.<br>&gt;<br>&gt; 5. NSProgress posts KVO notifications on the main thread. In addition<br>&gt; to complicating the interface and causing undefined behavior if one<br>&gt; mistakenly binds it to a UI element without inserting something in<br>&gt; between to forward the KVO notifications to the main thread, this also<br>&gt; hurts performance in the worker thread, since KVO notifications carry<br>&gt; a non-trivial performance penalty, involving not only message sends<br>&gt; but also packaging things into an NSDictionary for the &quot;change&quot;<br>&gt; parameter. Notifications for multiple properties are fired every time<br>&gt; completedUnitCount is changed, which then can cause similar KVO<br>&gt; notifications to occur up the family tree, depending on how many KVO<br>&gt; observers are installed. This can show up as a non-trivial performance<br>&gt; cost in Instruments if the NSProgress object is updated frequently<br>&gt; enough.<br>&gt;<br>&gt; Proposed Solution:<br>&gt;<br>&gt; I propose a system that follows the example of Swift&#39;s excellent<br>&gt; do/try/catch error-handling system. A &quot;reports&quot; keyword can be added<br>&gt; to a function or method&#39;s declaration, similar to &quot;throws&quot;:<br>&gt;<br>&gt; func myFunc() reports -&gt; () {<br>&gt;     ...<br>&gt; }<br>&gt;<br>&gt; By default, the &quot;reports&quot; keyword will introduce a &quot;let&quot; constant<br>&gt; named &quot;progress&quot; to the function&#39;s scope, much like &quot;catch&quot; implicitly<br>&gt; adds &quot;error&quot;. The name of this constant could be customized, if<br>&gt; desired:<br>&gt;<br>&gt; func myFunc() reports(myNiftyProgressObject) {<br>&gt;     ...<br>&gt; }<br>&gt;<br>&gt; The created progress object is automatically added as a child to the<br>&gt; progress object which is implicitly passed into the function by the<br>&gt; calling function or method.<br>&gt;<br>&gt; The interface to the progress object would be similar to NSProgress,<br>&gt; with a &quot;prepare&quot; method taking the total unit count, as well as a<br>&gt; &quot;cancelled&quot; property and a &quot;cancel()&quot; function helping keep track of<br>&gt; whether or not an operation is cancelled. However, the &quot;becomeCurrent&quot;<br>&gt; and &quot;resignCurrent&quot; methods are replaced with a &quot;report&quot; keyword which<br>&gt; precedes a function or method call, similar to &quot;try&quot;, although the<br>&gt; &quot;report&quot; keyword includes a parameter taking the number of units<br>&gt; corresponding to this operation:<br>&gt;<br>&gt; func myFunc() throws, reports {<br>&gt;     progress.prepare(10)<br>&gt;<br>&gt;     report(5) foo()<br>&gt;<br>&gt;     if progress.cancelled { throw NSCocoaError.UserCancelledError }<br>&gt;<br>&gt;     report(5) try bar() // yes, &quot;report&quot; can be combined with &quot;try&quot;<br>&gt; }<br>&gt;<br>&gt; Spinning off an operation onto another thread or queue is no problem:<br>&gt;<br>&gt; func myFunc() reports {<br>&gt;     progress.prepare(10)<br>&gt;<br>&gt;     dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<br>&gt; 0)) {<br>&gt;         report(10) foo() // the progress object is passed as a<br>&gt; parameter to the function, so no need to specially make it current on<br>&gt; this thread first<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Unlike &quot;try&quot;, &quot;report&quot; is not required. If we don&#39;t care about the<br>&gt; progress of a method or function, we can call it without &quot;report&quot; and<br>&gt; its progress will be ignored. In this example, the<br>&gt; &quot;someRelativelyTrivialOperationThatReports&quot;&#39;s progress object will<br>&gt; *not* be added as a child to &quot;progress&quot;:<br>&gt;<br>&gt; func myFunc() reports {<br>&gt;     progress.prepare(10)<br>&gt;<br>&gt;     someRelativelyTrivialOperationThatReports()<br>&gt;     report(10) someNonTrivialOperationThatReports()<br>&gt; }<br>&gt;<br>&gt; If a function calls only one reporting function, the &quot;prepare&quot; method<br>&gt; can be omitted and the parameter can be left off of &quot;report&quot;, and the<br>&gt; parent progress object will simply be passed through:<br>&gt;<br>&gt; func myFunc() reports {<br>&gt;     report doAllTheActualWork()<br>&gt; }<br>&gt;<br>&gt; To pass in a progress object other than the default progress object<br>&gt; (for example, when creating the object at the very top of the tree),<br>&gt; simply pass the progress object in as an optional second parameter to<br>&gt; &quot;reports&quot;:<br>&gt;<br>&gt; func startEverything() {<br>&gt;     let progress = Progress()<br>&gt;<br>&gt;     progress.prepare(10)<br>&gt;<br>&gt;     report(10, progress) someFuncThatReports()<br>&gt; }<br>&gt;<br>&gt; In the function that does the actual work, of course the progress<br>&gt; object has a &quot;completed&quot; property that tracks the completed units:<br>&gt;<br>&gt; func doTheActualWork() reports {<br>&gt;     let someArrayOfThings = ...<br>&gt;<br>&gt;     progress.prepare(someArrayOfThings.count)<br>&gt;<br>&gt;     for eachThing in someArrayOfThings {<br>&gt;         // do the work<br>&gt;<br>&gt;         progress.completed += 1<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Observing the progress object uses a closure-based system, containing<br>&gt; a &quot;willUpdateHandler&quot;, a &quot;didUpdateHandler&quot;, and a &quot;cancelHandler&quot;:<br>&gt;<br>&gt; progress.didUpdateHandler = { (completed: Int, total: Int) -&gt; () in<br>&gt;     print(&quot;\(completed) units complete out of \(total)&quot;)<br>&gt; }<br>&gt;<br>&gt; progress.cancelHandler = {<br>&gt;     print(&quot;the user cancelled the operation&quot;)<br>&gt; }<br>&gt;<br>&gt; The separation between will- and did- handlers is to facilitate<br>&gt; interoperability with NSProgressIndicator and other Objective-C<br>&gt; objects; one could call willChangeValueForKey() and<br>&gt; didChangeValueForKey() in the handlers to let the KVO system know<br>&gt; about the changes if needed. If desired, a small wrapper could be<br>&gt; added to Foundation to translate the progress object&#39;s notifications<br>&gt; into KVO notifications.<br>&gt;<br>&gt; The progress object also includes a property specifying the dispatch<br>&gt; queue on which the handlers will be run. By default this is the main<br>&gt; queue, but this can be customized as needed:<br>&gt;<br>&gt; progress.dispatchQueue = myDispatchQueue<br>&gt;<br>&gt; Of course, any changes to the &quot;completed&quot; property in a child progress<br>&gt; object would be bubbled up the family tree, causing any handlers on<br>&gt; the parent progress objects to fire, and any changes to the<br>&gt; &quot;cancelled&quot; property in a parent progress object would be propagated<br>&gt; to its children, similar to how NSProgress currently works.<br>&gt;<br>&gt; If there is interest in this, I could flesh out the interface and<br>&gt; implementation to the progress object a bit.<br>&gt;<br>&gt; What do you all think?<br></p><p>I think this is really out-of-scope for swift-evolution.  There&#39;s little<br>chance we&#39;d want something like this in the standard library in the near<br>term.  It&#39;s really Foundation&#39;s domain.<br></p><p>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
