<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] New mechanism to combine Types with/or Protocols</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 16, 2016 at 07:00:00pm</p></header><div class="content"><p>I open a new thread just for clarity. This proposal was started two weeks ago in a discussion thread where I talked to the community and refined the proposal over a few past days. The overall response was positive to this proposal.<br></p><p>Original thread: [Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;<br></p><p>This is my first proposal where I&#39;ll submit a pull request. Furthermore my English isn’t that great so please bear with me. If you spot any typos or other mistakes I’d be happy to look into your feedback. Feel free to send me such feedback in private.<br></p><p>Just for clarification: this proposal does not try to create type intersection in Swift, so please don’t ask me to change this. `Type intersection` is totally a different story and can have its own thread and proposal. ;)<br></p><p>Here is the formatted version of my proposal: https://github.com/DevAndArtist/swift-evolution/blob/master/proposals/nnnn-mechanism-to-combine-types-and-protocols.md<br></p><p>I hope to see your final feedback before I submit the proposal to the evolution repository.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>New mechanism to combine Types with/or Protocols<br></p><p>Proposal: SE-NNNN<br>Author(s): Adrian Zubarev<br>Status: Awaiting review<br>Review manager: TBD<br>Introduction<br></p><p>The current protocol&lt;&gt; mechanism defines the Any protocol to which all types implicitly conform. It also can combine distinct protocols to a new Protocol, whereas combinging SubProtocol with its BaseProtocol will be inferred as SubProtocol (the order withhin the angle brackets doesn’t matter). I propose to replace the current protocol&lt;&gt; mechanism with a new more powerful mechanism called All&lt;&gt;, which will allow combining Types with independent Protocols and enforce all constraints.<br></p><p>Swift-evolution thread: [Pitch] Merge Types and Protocols back together with type&lt;Type, Protocol, ...&gt;<br></p><p>Motivation<br></p><p>The motivation for this proposal comes from solving the missing Type issue (rdar://20990743) and combining the idea mentioned in the generics manifesto for Swift 3 in section Renaming protocol&lt;...&gt; to Any&lt;...&gt;.<br></p><p>The proposed mechanism will allow us to create a new Type from extendable distinct types - there are still some restrinctions you can read about below.<br></p><p>Proposed solution<br></p><p>First step to implement this proposal would need to rename protocol&lt;&gt; to All&lt;&gt; and configure the migration process to update code that used old style protocol&lt;&gt;.<br></p><p>Next the All&lt;&gt; mechanism would be extended to allow nesting and at most one extendable value or reference type. When all types within angle brackets are indepented/distinct to each other a new Type will be formed by All&lt;A, B, ...&gt;. This new Type can be used to store instances that conform to all constrains defined by All&lt;&gt; without any generic context (see Detailed design for more information).<br></p><p>Here only some subtype of UIView (dynamic type) conforms to SomeProtocol, but both types within angle brackets are distinct.<br></p><p>protocol SomeProtocol {}<br>extension SomeProtocol {<br>    func foo() { print(&quot;fooooo&quot;) }<br>}<br></p><p>// we&#39;ll be able to store the new type without generics<br>class A {<br>    var view: All&lt;UIView, SomeProtocol&gt;<br>    init(view: All&lt;UIView, SomeProtocol&gt;) {<br>        self.view = view<br>    }<br>     <br>    // `dynamicType` of the `view` might be `UIButton` for example<br>    // but we still be able to acces SomeProtocol which only UIButton conforms to<br>    func doSomeWork() {<br>        self.view.removeFromSuperview() // just for a simple example<br>        self.view.foo() // prints &quot;fooooo&quot;<br>    }<br>}<br></p><p>extension UIButton: SomeProtocol {}<br></p><p>let button: SomeProtocol = UIButton() // split types for the example<br></p><p>if let mergedValue = button as? All&lt;UIView, SomeProtocol&gt; {<br>    let a = A(view: mergedValue)<br>    a.doSomeWork()<br>}<br>Detailed design<br></p><p>Rules for All&lt;&gt;:<br></p><p>Empty All&lt;&gt; will be used as typealias Any = All&lt;&gt;. No constraints means it can accept any type or simply that all types implicitly conform to empty All&lt;&gt;. This is the logical replacement for typealias Any = protocol&lt;&gt;.<br></p><p>The order of Types within angle brackets doesn’t matter: All&lt;A, B&gt; == All&lt;B, A&gt;. (The compiler already reorders the types by its own will from protocol&lt;B, A&gt; to protocol&lt;A, B&gt;.)<br></p><p>All&lt;&gt; can be composed from protocols and by the mention of this rule fully replace protocol&lt;...&gt;<br></p><p>All&lt;ProtocolA, ...&gt; equals to old protocol&lt;ProtocolA, ...&gt;<br>All&lt;ProtocolX&gt; equals to old protocol&lt;ProtocolX&gt; or simply inferred as ProtocolX<br>All&lt;&gt; can contain at most one extendable value or reference type plus none or n protocols.<br></p><p>All&lt;ReferenceType&gt; or All&lt;ReferenceType, Protocol, ...&gt;<br>All&lt;ValueType&gt; or All&lt;ValueType, Protocol, ...&gt;<br>This rule will disallow All&lt;&gt; to contain unnecessary inheritance type branches from subtypeable types.<br>Furthermore will this rule ban confusion when using All&lt;T, U&gt; in a generic context.<br>Subtypeable Type from within angle brackets of All&lt;&gt; can be seen as the base type of the dynamic type.<br></p><p>Nesting All&lt;&gt; is allowed under special rules:<br></p><p>A: All&lt;&gt; can contain B: All&lt;&gt; if B is composed from protocols:<br>e.g. All&lt;AnyType, All&lt;ProtocolA, ProtocolB, ...&gt;&gt; will be inferred as All&lt;AnyType, ProtocolA, ProtocolB, ...&gt;<br>For subtypeable types A: All&lt;&gt; can contain B: All&lt;&gt; if B is composed from a possible base type of A and none or n protocols:<br>e.g. A = All&lt;All&lt;C, Protocol&gt;, SomeProtocol&gt; where B = All&lt;C, Protocol&gt; and C is some base Type of A which implies to A = All&lt;C, Protocol, SomeProtocol&gt;<br>Again nesting the inheritance type branch is not allowed, because of rule #4.<br>All types should be checked againts each other to find a simplified Type. At the end all type dependencies should be distinct and will form a new constrained type. These constraints are then tested against the dynamic type.<br></p><p>protocol X {}   protocol Y: X {}<br>class A: X {}   class B: Y {}<br>     <br>All&lt;A, X, Y&gt; /* inferred as */ All&lt;A, Y&gt;  <br>// e.g. will the above type accept `B` but not `A` as long `A` doesn&#39;t conform to `Y`<br>     <br>All&lt;B, X, Y&gt; /* inferred as */ All&lt;B&gt; /* or simply just */ B  <br>All&lt;&gt; can be an optional type All&lt;&gt;? or All&lt;&gt;!<br></p><p>Detailed design for All&lt;&gt; (below type is an extendable type):<br></p><p>type A can be applied to All&lt;A&gt; == A, All&lt;Any&gt; == Any == All&lt;&gt; or All&lt;GenericType&gt; == GenericType<br></p><p>type B: C:<br>class B: ProtocolC can be applied to:<br></p><p>Type	Equivalent inferred Type (** generic)<br>All&lt;ProtocolC&gt;	ProtocolC<br>All&lt;Any, ProtocolC&gt;	ProtocolC<br>All&lt;Any&gt;	Any or All&lt;&gt;<br>All&lt;GenericType, ProtocolC&gt;	**DynamicType: ProtocolC<br>All&lt;GenericType&gt;	**DynamicType <br>All&lt;B, ProtocolC&gt;	B<br>All&lt;B&gt;	B<br>class B: ClassC can be applied to:<br></p><p>One would not want to combine All&lt;ClassC, B&gt; even in a generic context like All&lt;T, U&gt; for example to union one value of B and another value of ClassC, because followed by rule #2 the compiler will reoder the types to All&lt;B, ClassC&gt; and infer that as B. B can not hold ClassC. This implies that All&lt;&gt; does not intersect types and the need of rule #4.<br>Type	Equivalent inferred Type (** generic)<br>All&lt;ClassC&gt;	ClassC<br>All&lt;B&gt;	B<br>All&lt;GenericType&gt;	**DynamicType<br>All&lt;Any&gt;	Any or All&lt;&gt;<br>struct B: ProtocolC is analogous to class B: ProtocolC.<br></p><p>enum B: ProtocolC is analogous to struct B: ProtocolC.<br></p><p>protocol B: C can be applied to:<br></p><p>Type	Equivalent inferred Type (** generic)<br>All&lt;Any, B&gt;	B<br>All&lt;Any, C&gt;	C<br>All&lt;Any&gt;	Any or All&lt;&gt;<br>All&lt;GenericType, B&gt;	**DynamicType: B<br>All&lt;GenericType, C&gt;	**DynamicType: C<br>All&lt;GenericType&gt;	**DynamicType<br>All&lt;B, C&gt;	B<br>All&lt;B&gt;	B<br>All&lt;C&gt;	C<br>type B distinct to C:<br>The following points will produce a new Type:<br>class B and protocol C can be combined to All&lt;B, C&gt;.<br>struct B and protocol C can be combined to All&lt;B, C&gt;.<br>enum B and protocol C can be combined to All&lt;B, C&gt;.<br>protocol B and protocol C can be combined to All&lt;B, C&gt;.<br>The following points should all raise an compilation error:<br>class B and class C can NOT be combined.<br>struct B and struct C can NOT be combined.<br>enum B and enum C can NOT be combined.<br>type D: E, F where E doesn’t conform to F:<br>class D: ClassE, ProtocolF type can be applied to:<br></p><p>Type	Equivalent inferred Type (** generic)<br>All&lt;ProtocolF&gt;	ProtocolF<br>All&lt;Any, ProtocolF&gt;	ProtocolF<br>All&lt;Any&gt;	Any or All&lt;&gt;<br>All&lt;GenericType, ProtocolF&gt;	**DynamicType: ProtocolF<br>All&lt;GenericType&gt;	**DynamicType<br>All&lt;D, ProtocolF&gt;	D<br>All&lt;D&gt;	D<br>All&lt;ClassE, ProtocolF&gt;	NEW: All&lt;ClassE, ProtocolF&gt;<br>All&lt;ClassE&gt;	ClassE<br>class D: ProtocolE, ProtocolF type can be applied to:<br></p><p>Type	Equivalent inferred Type (** generic)<br>All&lt;ProtocolE, ProtocolF&gt;	All&lt;ProtocolE, ProtocolF&gt;<br>All&lt;ProtocolE&gt;	ProtocolE<br>All&lt;ProtocolF&gt;	ProtocolF<br>All&lt;Any, ProtocolE, ProtocolF&gt;	All&lt;ProtocolE, ProtocolF&gt;<br>All&lt;Any, ProtocolE&gt;	ProtocolE<br>All&lt;Any, ProtocolF&gt;	ProtocolF<br>All&lt;Any&gt;	Any or All&lt;&gt;<br>All&lt;GenericType, ProtocolE, ProtocolF&gt;	**DynamicType: All&lt;ProtocolE, ProtocolF&gt;<br>All&lt;GenericType, ProtocolE&gt;	**DynamicType: ProtocolE<br>All&lt;GenericType, ProtocolF&gt;	**DynamicType: ProtocolF<br>All&lt;GenericType&gt;	**DynamicType<br>All&lt;D, ProtocolE, ProtocolF&gt;	D<br>All&lt;D, ProtocolE&gt;	D<br>All&lt;D, ProtocolF&gt;	D<br>All&lt;D&gt;	D<br>struct D: ProtocolE, ProtocolF is analogous to class D: ProtocolE, ProtocolF.<br></p><p>enum D: ProtocolE, ProtocolF is analogous to struct D: ProtocolE, ProtocolF.<br></p><p>protocol D: E, F type can be applied to:<br></p><p>Type	Equivalent inferred Type (** generic)<br>All&lt;GenericType, E, F&gt;	**DynamicType: All&lt;E, F&gt;<br>All&lt;GenericType, E&gt;	**DynamicType: E<br>All&lt;GenericType, F&gt;	**DynamicType: F<br>All&lt;GenericType&gt;	**DynamicType<br>All&lt;D, E, F&gt;	D<br>All&lt;D, E&gt;	D<br>All&lt;D, F&gt;	D<br>All&lt;E, F&gt;	All&lt;E, F&gt;<br>All&lt;E&gt;	E<br>All&lt;F&gt;	F<br>All&lt;D&gt;	D<br>Possible functions (just a few examples - solves rdar://problem/15873071 and rdar://20990743):<br></p><p>// with assumed generalized `class` and `AnyObject` typealias in mind<br>// current verion with unwanted `@objc` and possible bridging  <br>func woo&lt;T: AnyObject where T: SomeProtocol&gt;(value: T)<br></p><p>// rewritten without generics to accept only classes that conform to `SomeProtocol`<br>func woo(value: All&lt;AnyObject, SomeProtocol&gt;)<br></p><p>// more specific example which accepts all subtypes of `UIView` that conform  <br>// to `SomeProtocol` and one would drop generics here  <br>func woo(value: All&lt;UIView, SomeProtocol&gt;)<br>Impact on existing code<br></p><p>These changes will break existing code. Projects using old style protocol&lt;&gt; mechanism will need to migrate to the new All&lt;&gt; mechanism. The code using old style protocol&lt;&gt; won’t compile until updated to the new conventions.<br></p><p>Alternatives considered<br></p><p>This feature was orginally proposed as type&lt;&gt; but was renamed to All&lt;&gt; (idea provided by: Thorsten Seitz) to dodge possible confusion and serve its main purpose to enforce multiple/all constraints.<br></p><p>This proposal was overall updated to include any possible overlap with Generics Manifesto for Swift 3. The reason the mechanism in this proposal is called All&lt;&gt; instead of the suggested name Any&lt;&gt; from the manifesto is to reserve that name for future usage explained in Future directions below.<br></p><p>The mechanism still could be named Any&lt;&gt; and the described Any&lt;&gt; in Future directions could be named Either&lt;&gt;.<br></p><p>Any other rule changes for All&lt;&gt; are not considered.<br></p><p>Future directions<br></p><p>Generalize class constraints. This will create the possibility for AnyObject typealias.<br>typealias AnyObject = All&lt;class&gt; // @objc will be removed<br></p><p>// or  <br>typealias ClassInstance = All&lt;class&gt;<br></p><p>// and ban confusion with old `AnyClass` vs. `AnyObject`<br>typealias ClassType = ClassInstance.Type<br>Adding constraints for other extendable types like struct and enum and generalize these. This change will allo us to form more typealiases like:<br>typealias AnyStruct = All&lt;struct&gt;<br>typealias AnyEnum = All&lt;enum&gt;<br></p><p>// or<br>typealias StructInstance = All&lt;struct&gt;<br>typealias EnumInstance = All&lt;enum&gt;<br></p><p>// and<br>typealias StructType = StructInstance.Type<br>typealias EnumType = EnumInstance.Type<br>Possible functions (just a few more examples):<br></p><p>// to start with we should remember that we are already to do some syntax  <br>// magic with current`protocol&lt;&gt;`<br>protocol A { func zoo() }<br></p><p>// this is the base design that does not violate any rule<br>func boo(value: All&lt;A&gt;) { value.zoo() }<br></p><p>// this is the refined design that we all use today<br>func boo(value: A) { value.zoo() }<br></p><p>// we could constrain functions to accept only structs<br>// this might be seen as an enforcement to the library user to design a  <br>// struct in this scenario<br>func foo(value: StructInstance)<br>// structs that conforms to a specific protocol (from our library?)<br>func foo(value: All&lt;StructInstance, SomeProtocol&gt;)  <br>// one could use of ClassInstance and EnumInstance analogically<br></p><p>// generalized way with generics<br>func foo&lt;T: struct where T: SomeProtocol&gt;(value: T)  <br>// or<br>func foo&lt;T: StructInstance where T: SomeProtocol&gt;(value: T)  <br></p><p>// current only one verion for classes with unwanted `@objc` and possible bridging  <br>func woo&lt;T: AnyObject where T: SomeProtocol&gt;(value: T)<br>// better alternative might look like<br>func woo&lt;T: class where T: SomeProtocol&gt;(value: T)  <br>// or<br>func woo&lt;T: ClassInstance where T: SomeProtocol&gt;(value: T)  <br>// `All&lt;&gt;` combine with generics<br>func woo&lt;T: UIView&gt;(value: All&lt;T, SomeProtocol&gt;)  <br>// or simpler without generics<br>func woo(value: All&lt;UIView, SomeProtocol&gt;)<br></p><p>// non-generic approach to accept only reference-types which conforms to `SomeProtocol`<br>func zoo(value: All&lt;ClassInstance, SomeProtocol&gt;)<br>// or<br>func zoo(value: All&lt;class, SomeProtocol&gt;)<br>Possible scenarios:<br></p><p>// constrainted to accept only structs<br>struct A&lt;T: struct&gt; {<br>    var value: T  <br>}  <br></p><p>// or<br>struct A&lt;T: StructInstance&gt; {<br>    var value: T  <br>}  <br></p><p>protocol SomeProtocol { /* implement something shiny */ }<br></p><p>// lets say this array is filled with structs, classes and enums that conforms to `SomeProtocol`<br>let array: [SomeProtocol] = // fill<br></p><p>// this would be new<br>var classArray: [SomeProtocol] = array.filter { $0 is All&lt;class, SomeProtocol&gt; }<br>var structArray: [SomeProtocol] = array.filter { $0 is All&lt;struct, SomeProtocol&gt; }<br>var enumArray: [SomeProtocol] = array.filter { $0 is All&lt;enum, SomeProtocol&gt; }<br>// we still would have to convert these types<br>Flattened operators or even Type operators for All&lt;&gt;:<br></p><p>class B {<br>    var mainView: UIView &amp; SomeProtocol<br>     <br>    init(view: UIView &amp; SomeProtocol) {<br>        self. mainView = view<br>    }<br>}<br>The &amp; type operator would produce a “flattened&quot; All&lt;&gt; with its operands. It could be overloaded to accept either a concrete type or a protocol on the lhs and would produce Type for an lhs that is a type and all when lhs is a protocol. Type operators would be evaluated during compile time and would produce a type that is used where the expression was present in the code. This is a long-term idea, not something that needs to be considered right now.<br></p><p>Written by: Matthew Johnson<br>Adding Any&lt;&gt; or Either&lt;&gt; which can reduce overloading (idea provided by: Thorsten Seitz). Any&lt;&gt; or Either&lt;&gt; will pick the first type match from angle brackets with the dynamic type at compile time and proceed. One would then need to handle the value by own desire.<br></p><p>func foo(value: Any&lt;String, Int&gt;) {<br>     <br>    if let v = value as? String {<br>        // do some work<br>    } else if let v = value as? Int {<br>        // do some work<br>    }<br>}<br>     <br>// flattened version for `Any&lt;&gt;` or `Either&lt;&gt;`<br>func foo(value: String | Int)<br>Mix different types like All&lt;&gt; and Any&lt;&gt;:<br></p><p>// accept dynamic type constrained by  <br>// (`ClassA` AND `SomeProtocol`) OR (`ClassB` AND `SomeProtocol`)<br>func foo(value: All&lt;Any&lt;ClassA, ClassB&gt;, SomeProtocol&gt;)<br></p><p>// flattened version<br>func foo(value: (ClassA | ClassB) &amp; SomeProtocol)<br>Typealias AnyValue or ValueInstance (for extendable types only):<br></p><p>typealias AnyValue = Any&lt;All&lt;struct&gt;, All&lt;enum&gt;&gt; // magic isn&#39;t it?<br>typealias AnyValue = Any&lt;AnyStruct, AnyEnum&gt;<br></p><p>// or<br>typealias ValueInstance = Any&lt;All&lt;struct&gt;, All&lt;enum&gt;&gt;<br>typealias ValueInstance = Any&lt;StructInstance, EnumInstance&gt;<br></p><p>// and  <br>typealias ValueType = ValueInstance.Type<br></p><p>// flattened version<br>typealias AnyValue = All&lt;struct&gt; | All&lt;enum&gt;<br>typealias AnyValue = AnyStruct | AnyEnum<br>typealias ValueInstance = StructInstance | EnumInstance<br></p><p>// any value which conforms to `SomeProtocol`; reference types finally are out the way<br>func foo&lt;T&gt;(value: All&lt;AnyValue, SomeProtocol&gt;)  <br>func foo&lt;T&gt;(value: All&lt;ValueInstance, SomeProtocol&gt;)  <br></p><p>// flattened version<br>func foo&lt;T&gt;(value: AnyValue &amp; SomeProtocol)  <br>func foo&lt;T&gt;(value: ValueInstance &amp; SomeProtocol)  <br>New mechanism to combine Types with/or Protocols<br></p><p>Proposal: SE-NNNN<br>Author(s): Adrian Zubarev<br>Status: Awaiting review<br>Review manager: TBD<br>Introduction<br></p><p>The current protocol&lt;&gt; mechanism defines the Any protocol to which all types implicitly conform. It also can combine distinct protocols to a new Protocol, whereas combinging SubProtocol with its BaseProtocol will be inferred as SubProtocol (the order withhin the angle brackets doesn’t matter). I propose to replace the current protocol&lt;&gt; mechanism with a new more powerful mechanism called All&lt;&gt;, which will allow combining Types with independent Protocols and enforce all constraints.<br></p><p>Swift-evolution thread: [Pitch] Merge Types and Protocols back together with type&lt;Type, Protocol, ...&gt;<br></p><p>Motivation<br></p><p>The motivation for this proposal comes from solving the missing Type issue (rdar://20990743) and combining the idea mentioned in the generics manifesto for Swift 3 in section Renaming protocol&lt;...&gt; to Any&lt;...&gt;.<br></p><p>The proposed mechanism will allow us to create a new Type from extendable distinct types - there are still some restrinctions you can read about below.<br></p><p>Proposed solution<br></p><p>First step to implement this proposal would need to rename protocol&lt;&gt; to All&lt;&gt; and configure the migration process to update code that used old style protocol&lt;&gt;.<br></p><p>Next the All&lt;&gt; mechanism would be extended to allow nesting and at most one extendable value or reference type. When all types within angle brackets are indepented/distinct to each other a new Type will be formed by All&lt;A, B, ...&gt;. This new Type can be used to store instances that conform to all constrains defined by All&lt;&gt; without any generic context (see Detailed design for more information).<br></p><p>Here only some subtype of UIView (dynamic type) conforms to SomeProtocol, but both types within angle brackets are distinct.<br></p><p>protocol SomeProtocol {}<br>extension SomeProtocol {<br>    func foo() { print(&quot;fooooo&quot;) }<br>}<br></p><p>// we&#39;ll be able to store the new type without generics<br>class A {<br>    var view: All&lt;UIView, SomeProtocol&gt;<br>    init(view: All&lt;UIView, SomeProtocol&gt;) {<br>        self.view = view<br>    }<br>     <br>    // `dynamicType` of the `view` might be `UIButton` for example<br>    // but we still be able to acces SomeProtocol which only UIButton conforms to<br>    func doSomeWork() {<br>        self.view.removeFromSuperview() // just for a simple example<br>        self.view.foo() // prints &quot;fooooo&quot;<br>    }<br>}<br></p><p>extension UIButton: SomeProtocol {}<br></p><p>let button: SomeProtocol = UIButton() // split types for the example<br></p><p>if let mergedValue = button as? All&lt;UIView, SomeProtocol&gt; {<br>    let a = A(view: mergedValue)<br>    a.doSomeWork()<br>}<br>Detailed design<br></p><p>Rules for All&lt;&gt;:<br></p><p>Empty All&lt;&gt; will be used as typealias Any = All&lt;&gt;. No constraints means it can accept any type or simply that all types implicitly conform to empty All&lt;&gt;. This is the logical replacement for typealias Any = protocol&lt;&gt;.<br></p><p>The order of Types within angle brackets doesn’t matter: All&lt;A, B&gt; == All&lt;B, A&gt;. (The compiler already reorders the types by its own will from protocol&lt;B, A&gt; to protocol&lt;A, B&gt;.)<br></p><p>All&lt;&gt; can be composed from protocols and by the mention of this rule fully replace protocol&lt;...&gt;<br></p><p>All&lt;ProtocolA, ...&gt; equals to old protocol&lt;ProtocolA, ...&gt;<br>All&lt;ProtocolX&gt; equals to old protocol&lt;ProtocolX&gt; or simply inferred as ProtocolX<br>All&lt;&gt; can contain at most one extendable value or reference type plus none or n protocols.<br></p><p>All&lt;ReferenceType&gt; or All&lt;ReferenceType, Protocol, ...&gt;<br>All&lt;ValueType&gt; or All&lt;ValueType, Protocol, ...&gt;<br>This rule will disallow All&lt;&gt; to contain unnecessary inheritance type branches from subtypeable types.<br>Furthermore will this rule ban confusion when using All&lt;T, U&gt; in a generic context.<br>Subtypeable Type from within angle brackets of All&lt;&gt; can be seen as the base type of the dynamic type.<br></p><p>Nesting All&lt;&gt; is allowed under special rules:<br></p><p>A: All&lt;&gt; can contain B: All&lt;&gt; if B is composed from protocols:<br>e.g. All&lt;AnyType, All&lt;ProtocolA, ProtocolB, ...&gt;&gt; will be inferred as All&lt;AnyType, ProtocolA, ProtocolB, ...&gt;<br>For subtypeable types A: All&lt;&gt; can contain B: All&lt;&gt; if B is composed from a possible base type of A and none or n protocols:<br>e.g. A = All&lt;All&lt;C, Protocol&gt;, SomeProtocol&gt; where B = All&lt;C, Protocol&gt; and C is some base Type of A which implies to A = All&lt;C, Protocol, SomeProtocol&gt;<br>Again nesting the inheritance type branch is not allowed, because of rule #4.<br>All types should be checked againts each other to find a simplified Type. At the end all type dependencies should be distinct and will form a new constrained type. These constraints are then tested against the dynamic type.<br></p><p>protocol X {}   protocol Y: X {}<br>class A: X {}   class B: Y {}<br>     <br>All&lt;A, X, Y&gt; /* inferred as */ All&lt;A, Y&gt;  <br>// e.g. will the above type accept `B` but not `A` as long `A` doesn&#39;t conform to `Y`<br>     <br>All&lt;B, X, Y&gt; /* inferred as */ All&lt;B&gt; /* or simply just */ B  <br>All&lt;&gt; can be an optional type All&lt;&gt;? or All&lt;&gt;!<br></p><p>Detailed design for All&lt;&gt; (below type is an extendable type):<br></p><p>type A can be applied to All&lt;A&gt; == A, All&lt;Any&gt; == Any == All&lt;&gt; or All&lt;GenericType&gt; == GenericType<br></p><p>type B: C:<br>class B: ProtocolC can be applied to:<br></p><p>Type	Equivalent inferred Type (** generic)<br>All&lt;ProtocolC&gt;	ProtocolC<br>All&lt;Any, ProtocolC&gt;	ProtocolC<br>All&lt;Any&gt;	Any or All&lt;&gt;<br>All&lt;GenericType, ProtocolC&gt;	**DynamicType: ProtocolC<br>All&lt;GenericType&gt;	**DynamicType <br>All&lt;B, ProtocolC&gt;	B<br>All&lt;B&gt;	B<br>class B: ClassC can be applied to:<br></p><p>One would not want to combine All&lt;ClassC, B&gt; even in a generic context like All&lt;T, U&gt; for example to union one value of B and another value of ClassC, because followed by rule #2 the compiler will reoder the types to All&lt;B, ClassC&gt; and infer that as B. B can not hold ClassC. This implies that All&lt;&gt; does not intersect types and the need of rule #4.<br>Type	Equivalent inferred Type (** generic)<br>All&lt;ClassC&gt;	ClassC<br>All&lt;B&gt;	B<br>All&lt;GenericType&gt;	**DynamicType<br>All&lt;Any&gt;	Any or All&lt;&gt;<br>struct B: ProtocolC is analogous to class B: ProtocolC.<br></p><p>enum B: ProtocolC is analogous to struct B: ProtocolC.<br></p><p>protocol B: C can be applied to:<br></p><p>Type	Equivalent inferred Type (** generic)<br>All&lt;Any, B&gt;	B<br>All&lt;Any, C&gt;	C<br>All&lt;Any&gt;	Any or All&lt;&gt;<br>All&lt;GenericType, B&gt;	**DynamicType: B<br>All&lt;GenericType, C&gt;	**DynamicType: C<br>All&lt;GenericType&gt;	**DynamicType<br>All&lt;B, C&gt;	B<br>All&lt;B&gt;	B<br>All&lt;C&gt;	C<br>type B distinct to C:<br>The following points will produce a new Type:<br>class B and protocol C can be combined to All&lt;B, C&gt;.<br>struct B and protocol C can be combined to All&lt;B, C&gt;.<br>enum B and protocol C can be combined to All&lt;B, C&gt;.<br>protocol B and protocol C can be combined to All&lt;B, C&gt;.<br>The following points should all raise an compilation error:<br>class B and class C can NOT be combined.<br>struct B and struct C can NOT be combined.<br>enum B and enum C can NOT be combined.<br>type D: E, F where E doesn’t conform to F:<br>class D: ClassE, ProtocolF type can be applied to:<br></p><p>Type	Equivalent inferred Type (** generic)<br>All&lt;ProtocolF&gt;	ProtocolF<br>All&lt;Any, ProtocolF&gt;	ProtocolF<br>All&lt;Any&gt;	Any or All&lt;&gt;<br>All&lt;GenericType, ProtocolF&gt;	**DynamicType: ProtocolF<br>All&lt;GenericType&gt;	**DynamicType<br>All&lt;D, ProtocolF&gt;	D<br>All&lt;D&gt;	D<br>All&lt;ClassE, ProtocolF&gt;	NEW: All&lt;ClassE, ProtocolF&gt;<br>All&lt;ClassE&gt;	ClassE<br>class D: ProtocolE, ProtocolF type can be applied to:<br></p><p>Type	Equivalent inferred Type (** generic)<br>All&lt;ProtocolE, ProtocolF&gt;	All&lt;ProtocolE, ProtocolF&gt;<br>All&lt;ProtocolE&gt;	ProtocolE<br>All&lt;ProtocolF&gt;	ProtocolF<br>All&lt;Any, ProtocolE, ProtocolF&gt;	All&lt;ProtocolE, ProtocolF&gt;<br>All&lt;Any, ProtocolE&gt;	ProtocolE<br>All&lt;Any, ProtocolF&gt;	ProtocolF<br>All&lt;Any&gt;	Any or All&lt;&gt;<br>All&lt;GenericType, ProtocolE, ProtocolF&gt;	**DynamicType: All&lt;ProtocolE, ProtocolF&gt;<br>All&lt;GenericType, ProtocolE&gt;	**DynamicType: ProtocolE<br>All&lt;GenericType, ProtocolF&gt;	**DynamicType: ProtocolF<br>All&lt;GenericType&gt;	**DynamicType<br>All&lt;D, ProtocolE, ProtocolF&gt;	D<br>All&lt;D, ProtocolE&gt;	D<br>All&lt;D, ProtocolF&gt;	D<br>All&lt;D&gt;	D<br>struct D: ProtocolE, ProtocolF is analogous to class D: ProtocolE, ProtocolF.<br></p><p>enum D: ProtocolE, ProtocolF is analogous to struct D: ProtocolE, ProtocolF.<br></p><p>protocol D: E, F type can be applied to:<br></p><p>Type	Equivalent inferred Type (** generic)<br>All&lt;GenericType, E, F&gt;	**DynamicType: All&lt;E, F&gt;<br>All&lt;GenericType, E&gt;	**DynamicType: E<br>All&lt;GenericType, F&gt;	**DynamicType: F<br>All&lt;GenericType&gt;	**DynamicType<br>All&lt;D, E, F&gt;	D<br>All&lt;D, E&gt;	D<br>All&lt;D, F&gt;	D<br>All&lt;E, F&gt;	All&lt;E, F&gt;<br>All&lt;E&gt;	E<br>All&lt;F&gt;	F<br>All&lt;D&gt;	D<br>Possible functions (just a few examples - solves rdar://problem/15873071 and rdar://20990743):<br></p><p>// with assumed generalized `class` and `AnyObject` typealias in mind<br>// current verion with unwanted `@objc` and possible bridging  <br>func woo&lt;T: AnyObject where T: SomeProtocol&gt;(value: T)<br></p><p>// rewritten without generics to accept only classes that conform to `SomeProtocol`<br>func woo(value: All&lt;AnyObject, SomeProtocol&gt;)<br></p><p>// more specific example which accepts all subtypes of `UIView` that conform  <br>// to `SomeProtocol` and one would drop generics here  <br>func woo(value: All&lt;UIView, SomeProtocol&gt;)<br>Impact on existing code<br></p><p>These changes will break existing code. Projects using old style protocol&lt;&gt; mechanism will need to migrate to the new All&lt;&gt; mechanism. The code using old style protocol&lt;&gt; won’t compile until updated to the new conventions.<br></p><p>Alternatives considered<br></p><p>This feature was orginally proposed as type&lt;&gt; but was renamed to All&lt;&gt; (idea provided by: Thorsten Seitz) to dodge possible confusion and serve its main purpose to enforce multiple/all constraints.<br></p><p>This proposal was overall updated to include any possible overlap with Generics Manifesto for Swift 3. The reason the mechanism in this proposal is called All&lt;&gt; instead of the suggested name Any&lt;&gt; from the manifesto is to reserve that name for future usage explained in Future directions below.<br></p><p>The mechanism still could be named Any&lt;&gt; and the described Any&lt;&gt; in Future directions could be named Either&lt;&gt;.<br></p><p>Any other rule changes for All&lt;&gt; are not considered.<br></p><p>Future directions<br></p><p>Generalize class constraints. This will create the possibility for AnyObject typealias.<br>typealias AnyObject = All&lt;class&gt; // @objc will be removed<br></p><p>// or  <br>typealias ClassInstance = All&lt;class&gt;<br></p><p>// and ban confusion with old `AnyClass` vs. `AnyObject`<br>typealias ClassType = ClassInstance.Type<br>Adding constraints for other extendable types like struct and enum and generalize these. This change will allo us to form more typealiases like:<br>typealias AnyStruct = All&lt;struct&gt;<br>typealias AnyEnum = All&lt;enum&gt;<br></p><p>// or<br>typealias StructInstance = All&lt;struct&gt;<br>typealias EnumInstance = All&lt;enum&gt;<br></p><p>// and<br>typealias StructType = StructInstance.Type<br>typealias EnumType = EnumInstance.Type<br>Possible functions (just a few more examples):<br></p><p>// to start with we should remember that we are already to do some syntax  <br>// magic with current`protocol&lt;&gt;`<br>protocol A { func zoo() }<br></p><p>// this is the base design that does not violate any rule<br>func boo(value: All&lt;A&gt;) { value.zoo() }<br></p><p>// this is the refined design that we all use today<br>func boo(value: A) { value.zoo() }<br></p><p>// we could constrain functions to accept only structs<br>// this might be seen as an enforcement to the library user to design a  <br>// struct in this scenario<br>func foo(value: StructInstance)<br>// structs that conforms to a specific protocol (from our library?)<br>func foo(value: All&lt;StructInstance, SomeProtocol&gt;)  <br>// one could use of ClassInstance and EnumInstance analogically<br></p><p>// generalized way with generics<br>func foo&lt;T: struct where T: SomeProtocol&gt;(value: T)  <br>// or<br>func foo&lt;T: StructInstance where T: SomeProtocol&gt;(value: T)  <br></p><p>// current only one verion for classes with unwanted `@objc` and possible bridging  <br>func woo&lt;T: AnyObject where T: SomeProtocol&gt;(value: T)<br>// better alternative might look like<br>func woo&lt;T: class where T: SomeProtocol&gt;(value: T)  <br>// or<br>func woo&lt;T: ClassInstance where T: SomeProtocol&gt;(value: T)  <br>// `All&lt;&gt;` combine with generics<br>func woo&lt;T: UIView&gt;(value: All&lt;T, SomeProtocol&gt;)  <br>// or simpler without generics<br>func woo(value: All&lt;UIView, SomeProtocol&gt;)<br></p><p>// non-generic approach to accept only reference-types which conforms to `SomeProtocol`<br>func zoo(value: All&lt;ClassInstance, SomeProtocol&gt;)<br>// or<br>func zoo(value: All&lt;class, SomeProtocol&gt;)<br>Possible scenarios:<br></p><p>// constrainted to accept only structs<br>struct A&lt;T: struct&gt; {<br>    var value: T  <br>}  <br></p><p>// or<br>struct A&lt;T: StructInstance&gt; {<br>    var value: T  <br>}  <br></p><p>protocol SomeProtocol { /* implement something shiny */ }<br></p><p>// lets say this array is filled with structs, classes and enums that conforms to `SomeProtocol`<br>let array: [SomeProtocol] = // fill<br></p><p>// this would be new<br>var classArray: [SomeProtocol] = array.filter { $0 is All&lt;class, SomeProtocol&gt; }<br>var structArray: [SomeProtocol] = array.filter { $0 is All&lt;struct, SomeProtocol&gt; }<br>var enumArray: [SomeProtocol] = array.filter { $0 is All&lt;enum, SomeProtocol&gt; }<br>// we still would have to convert these types<br>Flattened operators or even Type operators for All&lt;&gt;:<br></p><p>class B {<br>    var mainView: UIView &amp; SomeProtocol<br>     <br>    init(view: UIView &amp; SomeProtocol) {<br>        self. mainView = view<br>    }<br>}<br>The &amp; type operator would produce a “flattened&quot; All&lt;&gt; with its operands. It could be overloaded to accept either a concrete type or a protocol on the lhs and would produce Type for an lhs that is a type and all when lhs is a protocol. Type operators would be evaluated during compile time and would produce a type that is used where the expression was present in the code. This is a long-term idea, not something that needs to be considered right now.<br></p><p>Written by: Matthew Johnson<br>Adding Any&lt;&gt; or Either&lt;&gt; which can reduce overloading (idea provided by: Thorsten Seitz). Any&lt;&gt; or Either&lt;&gt; will pick the first type match from angle brackets with the dynamic type at compile time and proceed. One would then need to handle the value by own desire.<br></p><p>func foo(value: Any&lt;String, Int&gt;) {<br>     <br>    if let v = value as? String {<br>        // do some work<br>    } else if let v = value as? Int {<br>        // do some work<br>    }<br>}<br>     <br>// flattened version for `Any&lt;&gt;` or `Either&lt;&gt;`<br>func foo(value: String | Int)<br>Mix different types like All&lt;&gt; and Any&lt;&gt;:<br></p><p>// accept dynamic type constrained by  <br>// (`ClassA` AND `SomeProtocol`) OR (`ClassB` AND `SomeProtocol`)<br>func foo(value: All&lt;Any&lt;ClassA, ClassB&gt;, SomeProtocol&gt;)<br></p><p>// flattened version<br>func foo(value: (ClassA | ClassB) &amp; SomeProtocol)<br>Typealias AnyValue or ValueInstance (for extendable types only):<br></p><p>typealias AnyValue = Any&lt;All&lt;struct&gt;, All&lt;enum&gt;&gt; // magic isn&#39;t it?<br>typealias AnyValue = Any&lt;AnyStruct, AnyEnum&gt;<br></p><p>// or<br>typealias ValueInstance = Any&lt;All&lt;struct&gt;, All&lt;enum&gt;&gt;<br>typealias ValueInstance = Any&lt;StructInstance, EnumInstance&gt;<br></p><p>// and  <br>typealias ValueType = ValueInstance.Type<br></p><p>// flattened version<br>typealias AnyValue = All&lt;struct&gt; | All&lt;enum&gt;<br>typealias AnyValue = AnyStruct | AnyEnum<br>typealias ValueInstance = StructInstance | EnumInstance<br></p><p>// any value which conforms to `SomeProtocol`; reference types finally are out the way<br>func foo&lt;T&gt;(value: All&lt;AnyValue, SomeProtocol&gt;)  <br>func foo&lt;T&gt;(value: All&lt;ValueInstance, SomeProtocol&gt;)  <br></p><p>// flattened version<br>func foo&lt;T&gt;(value: AnyValue &amp; SomeProtocol)  <br>func foo&lt;T&gt;(value: ValueInstance &amp; SomeProtocol)  <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/696ff982/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
