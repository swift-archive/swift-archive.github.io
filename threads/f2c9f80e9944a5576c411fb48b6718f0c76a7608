<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>API Guidelines Update</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 19, 2016 at 06:00:00pm</p></header><div class="content"><p>on Fri Feb 19 2016, Craig Cruden &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Neither really feel right - I am not against long names, but sometimes<br>&gt; people have long names because they are unfocused and the API to a<br>&gt; class/type has too many unfocused methods on it.  Then it gets applied<br>&gt; to other classes/types with less methods since it is more consistent<br>&gt; with the naming of the class/types that they have already completed.<br>&gt;<br>&gt; Whereas “ing”/“ed” <br></p><p>Wrong order; “ed”/“ing” please!  ;-)<br></p><p>&gt; is against all the naming conventions (closer to<br>&gt; opposite of what was acceptable) of any development environment I have<br>&gt; worked in the last 30 years.  It is not that I don’t accept and<br>&gt; embrace change — if that were the case I would not be constantly<br>&gt; learning.<br>&gt;<br>&gt; “ing” (the worst of the two) to me infers that something is in<br>&gt; progress… i.e. “process”.isRunning or “process”.running.<br></p><p>Ah; I understand.  The guidelines specify that for this purpose the<br>above should read like an assertion about the receiver,<br>e.g. “process.isRunning,” and heretofore Cocoa has always used<br>“process.running.”  So I can see why it might be hard to re-train your<br>instincts on this.<br></p><p>&gt; “ed” (least worst) to me infers that you are querying the state of<br>&gt; something “process”.completed.<br></p><p>Same applies here.<br></p><p>&gt; Both mutable and immutable execute and complete and results are either<br>&gt; returned or applied.<br>&gt; <br>&gt; I have generally (maybe always) kept things that “mutate” separate<br>&gt; from things that don’t (unless I am working in a system where<br>&gt; immutable vs mutable never entered the mind of the developer).  It<br>&gt; feels more focused.  In most cases it is fairly easy to do, and<br>&gt; cleaner.  I don’t know if there is some performance reason why the<br>&gt; mixing of the two (across the whole API) is more advantageous.  <br></p><p>Let&#39;s just consider sets, for example.  If an in-place<br>intersection suits what you&#39;re trying to do, then<br></p><p>  x.intersectWith(y) // or however you spell it; mutating<br></p><p>can avoid doing any new allocations and most of the data copying that<br>would otherwise be result from<br></p><p>  x = x.intersection(y) // or however you spell it; non-mutating<br></p><p>It&#39;s certainly possible to argue that sets should only have mutating<br>operations, but that seems like a really harsh break with tradition, and<br>would make combining sets that are immutable due to “let” bindings quite<br>awkward.<br></p><p>&gt; But even in that case it will constantly be nagging me, and giving me<br>&gt; the feeling that something went horribly wrong and it is something<br>&gt; that needs to be looked at to see if it needs to be refactored and<br>&gt; simplified.<br>&gt;<br>&gt; So for me it is not just that it is grammatically awkward, it will<br>&gt; constantly be giving me a feeling that something went horribly wrong<br>&gt; and that it needs to be looked at again to see if it could have been<br>&gt; done in a more simplified and focused way.<br></p><p>Hmm, I understand that... But maybe you should watch<br>https://developer.apple.com/videos/play/wwdc2015-414/ (again).  We want<br>programmers to be really comfortable with mutation.  The premise behind<br>our emphasis on value types is that the real underlying problem that<br>drives people to create immutable data structures is usually implicit<br>sharing, rather than mutation.<br></p><p><br>&gt;&gt; <br>&gt;&gt; As I think you’ve said previously, it’s probably just a case where<br>&gt;&gt; people (including me) need to get used to the idiom. There is a huge<br>&gt;&gt; leap from:<br>&gt;&gt; <br>&gt;&gt; a.stringByTrimmingCharactersInSet(b)<br>&gt;&gt; to:<br>&gt;&gt; a.trimming(b)<br>&gt;&gt; <br>&gt;&gt; A couple of cognitive crutches that people have depended on are gone. <br>&gt;&gt; <br>&gt;&gt; There are things that make “-ing” function names more of an adjustment for some people, I think:<br>&gt;&gt; <br>&gt;&gt; - It’s an idiom (if that’s the right word) for function naming that a lot of people haven’t been exposed to before.<br>&gt;&gt; <br>&gt;&gt; - The expression at the call-site is grammatical, but perhaps not<br>&gt;&gt; common usage, so people might still have to stop and think about<br>&gt;&gt; what the function is doing until they get used to it.<br>&gt;&gt; <br>&gt;&gt; - Though not a problem unique to “-ing”s, the function&#39;s primary<br>&gt;&gt; purpose is to return something, but the function name by itself<br>&gt;&gt; doesn’t reflect that (though the full expression at the call site<br>&gt;&gt; does).<br>&gt;&gt; <br>&gt;&gt; None of these are necessarily flaws, just things that people react<br>&gt;&gt; to. So it might be reasonable to conclude there isn’t actually a<br>&gt;&gt; problem. ;-)<br>&gt;&gt; <br>&gt;&gt;&gt; ? Are they hard to read?<br>&gt;&gt; <br>&gt;&gt; In the limited sense of being unfamiliar usage for some people. It doesn’t seem grammatically awkward to me.<br>&gt;&gt; <br>&gt;&gt;&gt; Is it hard to arrive at these names, somehow?<br>&gt;&gt; <br>&gt;&gt; Not IMO.<br>&gt;&gt; <br>&gt;&gt;&gt; Are the guidelines simply not clear enough about the procedure for<br>&gt;&gt;&gt; producing names mutating/non-mutating pairs?<br>&gt;&gt; <br>&gt;&gt; I think the people who have raised concerns are reacting to the<br>&gt;&gt; aesthetics of particular examples and not to the difficultly of<br>&gt;&gt; using the naming conventions.<br>&gt;&gt; <br>&gt;&gt;&gt; Is it too easy to confuse that part of the guidelines with the<br>&gt;&gt;&gt; general direction regarding methods with/without side-effects?<br>&gt;&gt; <br>&gt;&gt; Without the examples, I think it might be confusing because you’re<br>&gt;&gt; sorting through grammar rules. The examples provide the clarity.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
