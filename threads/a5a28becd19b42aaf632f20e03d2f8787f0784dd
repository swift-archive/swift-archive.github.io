<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>December 11, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; I do not support the addition of Either. As far as I am aware, the only<br>&gt; compelling argument in favor of an Either type is &quot;because Haskell has<br>&gt; one&quot;, but I believe it&#39;s commonly recognized that Haskell&#39;s Either is<br>&gt; not particularly good. <br>I have yet to read counterarguments about the addition of Either to the Haskell base library.  And though it may be tempting to assume, because TypeLift is oriented towards declarative programming, that we wish to see Swift and Haskell enter some kind of unholy union (excuse the pun), I based this proposal not off of a desire to see more FP, but to see less duplicate implementations (https://github.com/search?utf8=✓&amp;q=Either+language%3Aswift&amp;type=Code&amp;ref=searchresults).  If GitHub is any indicator, the Swift community wants an Either, and it seems fitting to me that the language standardize on one and allow the community to instead focus their efforts on writing interesting extensions to such a common type. <br></p><p>If you need a less anecdotal argument, consider the type of program `throws` can represent versus the type of program `Either` can represent.  On the one hand, yes, the latter does have certain conventions that encourage it to duplicate cases that the former already provides, but Either is supposed to properly represent a computation that can produce multiple discrete results - an if-else as a value.  If you wish to support more arities, nest down the left or right lobe of the type as you would nest branches.  If you want to start supporting higher-order variants, you start to run into inclusion-exclusion problems (see how we implemented a `Those` type https://github.com/typelift/Swiftz/blob/master/Swiftz/Those.swift &lt;https://github.com/typelift/Swiftz/blob/master/Swiftz/Those.swift&gt;)  <br>&gt; It&#39;s a weird name for results (which Result<br>&gt; covers), and for other cases it&#39;s usually better just to define your own<br>&gt; two-variant enum anyway. Rust provides some evidence in favor of this,<br>&gt; as this was the rationale for why Rust has a Result&lt;T,E&gt; but no Either,<br>&gt; and it turns out there has been no need to add an Either.<br>I’ll admit, the name is definitely less than ideal, but it should be a simple thing to change (I’m only interested in the structure here): XOr, Choice, Variant, Alternative, V come to mind.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/a5a284dd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 11, 2015 at 10:00:00pm</p></header><div class="content"><p>Can you provide any examples where you think it&#39;s demonstrably better to<br>have an Either than to just implement your own two-variant type,<br>assuming that we do already have a Result type to handle results?<br></p><p>I haven&#39;t gone trawling through GitHub for Either, but glancing through<br>that search you provided, it looks like it&#39;s basically just people<br>trying to reproduce Haskell concepts in Swift, which isn&#39;t particularly<br>meaningful. The only non-FP justification I saw was robrix/Either which<br>demonstrated using an Either to hold the results of a computation, which<br>of course is what Result does, and really the only reason it&#39;s called<br>Either is because of FP anyway.<br></p><p>-Kevin Ballard<br></p><p>On Fri, Dec 11, 2015, at 08:09 PM, Developer via swift-evolution wrote:<br>&gt;<br>&gt;&gt; I do not support the addition of Either. As far as I am aware,<br>&gt;&gt; the only<br>compelling argument in favor of an Either type is &quot;because Haskell has<br>one&quot;, but I believe it&#39;s commonly recognized that Haskell&#39;s Either is<br>not particularly good.<br>&gt; I have yet to read counterarguments about the addition of Either to<br>&gt; the Haskell base library.  And though it may be tempting to assume,<br>&gt; because TypeLift is oriented towards declarative programming, that we<br>&gt; wish to see Swift and Haskell enter some kind of unholy union (excuse<br>&gt; the pun), I based this proposal not off of a desire to see more FP,<br>&gt; but to see less duplicate implementations<br>&gt; (https://github.com/search?utf8=✓&amp;q=Either+language%3Aswift&amp;type=Code&amp;ref=searchresults)<br>&gt; .  If GitHub is any indicator, the Swift community wants an Either,<br>&gt; and it seems fitting to me that the language standardize on one and<br>&gt; allow the community to instead focus their efforts on writing<br>&gt; interesting extensions to such a common type.<br>&gt;<br>&gt; If you need a less anecdotal argument, consider the type of program<br>&gt; `throws` can represent versus the type of program `Either` can<br>&gt; represent.  On the one hand, yes, the latter does have certain<br>&gt; conventions that encourage it to duplicate cases that the former<br>&gt; already provides, but Either is supposed to properly represent a<br>&gt; computation that can produce multiple discrete results - an if-else as<br>&gt; a value.  If you wish to support more arities, nest down the left or<br>&gt; right lobe of the type as you would nest branches.  If you want to<br>&gt; start supporting higher-order variants, you start to run into inclusion-<br>&gt; exclusion problems (see how we implemented a `Those` type<br>&gt; https://github.com/typelift/Swiftz/blob/master/Swiftz/Those.swift)<br>&gt;&gt; It&#39;s a weird name for results (which Result<br>covers), and for other cases it&#39;s usually better just to define your own<br>two-variant enum anyway. Rust provides some evidence in favor of this,<br>as this was the rationale for why Rust has a Result&lt;T,E&gt; but no Either,<br>and it turns out there has been no need to add an Either.<br>&gt; I’ll admit, the name is definitely less than ideal, but it should be a<br>&gt; simple thing to change (I’m only interested in the structure here):<br>&gt; XOr, Choice, Variant, Alternative, V come to mind.<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/cb51ebcb/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Proposal: An Either Type in the STL</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December 12, 2015 at 10:00:00am</p></header><div class="content"><p>On Sat, Dec 12, 2015 at 7:43 AM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Can you provide any examples where you think it&#39;s demonstrably better to<br>&gt; have an Either than to just implement your own two-variant type, assuming<br>&gt; that we do already have a Result type to handle results?<br>&gt;<br></p><p>Any time there are specifically two discrete choices or states. Yes, &quot;if<br>you have three then you should make a custom enum&quot; but–if you only have<br>two–the benefit of using Either *instead* of a custom enum is that you can<br>leverage all of the same machinery without much extra effort. You can reply<br>to every possible example with &quot;you could make a custom enum with two<br>cases&quot; but, for every one of those, you would get nothing for free. If<br>Either makes it into the standard library and you *don&#39;t* want that<br>machinery, you can create your own custom enum.<br></p><p>As for a concrete example, Scales are, typically symmetrical (ascending and<br>descending) or asymmetrical. Ideally, I would like to wrap Either in a<br>newtype and call it a day. .Left is not an error case so the argument about<br>that being counterintuitive is moot. I simply have two possibilities to<br>choose from and I am fairly certain that that will not change in the future.<br></p><p><br></p><p>&gt;<br>&gt; I haven&#39;t gone trawling through GitHub for Either, but glancing through<br>&gt; that search you provided, it looks like it&#39;s basically just people trying<br>&gt; to reproduce Haskell concepts in Swift, which isn&#39;t particularly<br>&gt; meaningful. The only non-FP justification I saw was robrix/Either which<br>&gt; demonstrated using an Either to hold the results of a computation, which of<br>&gt; course is what Result does, and really the only reason it&#39;s called Either<br>&gt; is because of FP anyway.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Fri, Dec 11, 2015, at 08:09 PM, Developer via swift-evolution wrote:<br>&gt;<br>&gt;<br>&gt; I do not support the addition of Either. As far as I am aware, the only<br>&gt; compelling argument in favor of an Either type is &quot;because Haskell has<br>&gt; one&quot;, but I believe it&#39;s commonly recognized that Haskell&#39;s Either is<br>&gt; not particularly good.<br>&gt;<br>&gt; I have yet to read counterarguments about the addition of Either to the<br>&gt; Haskell base library.  And though it may be tempting to assume, because<br>&gt; TypeLift is oriented towards declarative programming, that we wish to see<br>&gt; Swift and Haskell enter some kind of unholy union (excuse the pun), I based<br>&gt; this proposal not off of a desire to see more FP, but to see less duplicate<br>&gt; implementations (<br>&gt; https://github.com/search?utf8=✓&amp;q=Either+language%3Aswift&amp;type=Code&amp;ref=searchresults).<br>&gt; If GitHub is any indicator, the Swift community wants an Either, and it<br>&gt; seems fitting to me that the language standardize on one and allow the<br>&gt; community to instead focus their efforts on writing interesting extensions<br>&gt; to such a common type.<br>&gt;<br>&gt; If you need a less anecdotal argument, consider the type of program<br>&gt; `throws` can represent versus the type of program `Either` can represent.<br>&gt; On the one hand, yes, the latter does have certain conventions that<br>&gt; encourage it to duplicate cases that the former already provides, but<br>&gt; Either is supposed to properly represent a computation that can produce<br>&gt; multiple discrete results - an if-else as a value.  If you wish to support<br>&gt; more arities, nest down the left or right lobe of the type as you would<br>&gt; nest branches.  If you want to start supporting higher-order variants, you<br>&gt; start to run into inclusion-exclusion problems (see how we implemented a<br>&gt; `Those` type<br>&gt; https://github.com/typelift/Swiftz/blob/master/Swiftz/Those.swift)<br>&gt;<br>&gt; It&#39;s a weird name for results (which Result<br>&gt; covers), and for other cases it&#39;s usually better just to define your own<br>&gt; two-variant enum anyway. Rust provides some evidence in favor of this,<br>&gt; as this was the rationale for why Rust has a Result&lt;T,E&gt; but no Either,<br>&gt; and it turns out there has been no need to add an Either.<br>&gt;<br>&gt; I’ll admit, the name is definitely less than ideal, but it should be a<br>&gt; simple thing to change (I’m only interested in the structure here): XOr,<br>&gt; Choice, Variant, Alternative, V come to mind.<br>&gt;<br>&gt; *_______________________________________________*<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/334d0bbc/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
