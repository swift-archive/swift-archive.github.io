<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Location of &quot;indirect&quot; declaration modifier</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 11, 2015 at 12:00:00pm</p></header><div class="content"><p>Hey guys,<br></p><p>I&#39;m working on a proposal and the question arose why the declaration<br>modifier indirect can only be specified for the whole enum case and the<br>whole enum but not for the actual parameter which is indirect.<br></p><p>I.e. is there any technical reason which would prevent something like the<br>following?<br></p><p><br>   1. enum ArithmeticExpression {<br>   2. case Number(Int)<br>   3. case Addition(indirect ArithmeticExpression, indirect<br>   ArithmeticExpression)<br>   4. case Multiplication(indirect ArithmeticExpression, indirect<br>   ArithmeticExpression)<br>   5. }<br></p><p><br>Also is there any technical reason which would prevent indirect from being<br>used for structs?<br></p><p>Thanks,<br>  Marc<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151211/48d824c9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Location of &quot;indirect&quot; declaration modifier</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>December 11, 2015 at 07:00:00am</p></header><div class="content"><p>Hi Marc,<br></p><p>&gt; On Dec 11, 2015, at 3:06 AM, Marc Knaup via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; Hey guys,<br>&gt; <br>&gt; I&#39;m working on a proposal and the question arose why the declaration modifier indirect can only be specified for the whole enum case and the whole enum but not for the actual parameter which is indirect.<br>&gt; <br>&gt; I.e. is there any technical reason which would prevent something like the following?<br>&gt; <br>&gt; enum ArithmeticExpression {<br>&gt;     case Number(Int)<br>&gt;     case Addition(indirect ArithmeticExpression, indirect ArithmeticExpression)<br>&gt;     case Multiplication(indirect ArithmeticExpression, indirect ArithmeticExpression)<br>&gt; }<br></p><p>Right now, notice that direct and indirect cases look the same from the perspective of the type system.<br></p><p>With your proposal, the fact that the entire tuple payload can be matched by a pattern implies that ‘indirect’ has to become a formal type in the language, since you will now be able to write down a value of type &#39;(indirect ArithmeticExpression, Int)’, for example. It also raises the issue of how these indirect values are wrapped and unwrapped, since now the ‘indirect ArithmeticExpression’ is itself a value.<br></p><p>An alternative is to make ‘indirect’ a non-materializable type, like ‘inout’. ‘inout’ can appear inside tuple types, but is not a first class value. This creates lots of special cases for ‘inout’ and you can imagine it will be equally difficult for ‘indirect’.<br></p><p>If you want an ‘indirect’ that can be nested inside a tuple type, you could just define ‘class Box&lt;T&gt; { let payload: T }’ and tolerate a bit of verbosity when wrapping and unwrapping values. As long as the payload is immutable, you will still have value semantics using this trick.<br></p><p>&gt; <br>&gt; Also is there any technical reason which would prevent indirect from being used for structs?<br></p><p>Like an ‘indirect’ modifier for stored properties on structs? Yes, this should be possible, however note that right now enum payloads are not themselves lvalues, which means that assignment of indirect enum cases only has to update the reference count of the box to maintain value semantics, since the contents of the box will never change. Presumably for structs you would need to be able to define an ‘indirect var’ with a mutable payload — immutable-only indirect stored properties don’t seem very useful.<br></p><p>Making the indirect payload mutable will require either copying the box upon assignment, or alternatively, a copy-on-write scheme could be used. The SIL @box type that implements indirect cases isn’t set up to support either of those right now. Also, unlike enums, indirect fields of structs won’t give you any new generality that was not possible before — its just a performance change. A value type that contains a cycle through an ‘indirect’ struct field is still invalid, for example, because the resulting type is still infinite.<br></p><p>Slava<br></p><p>&gt; <br>&gt; Thanks,<br>&gt;   Marc<br>&gt;  _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151211/4b8de86f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Location of &quot;indirect&quot; declaration modifier</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 11, 2015 at 05:00:00pm</p></header><div class="content"><p>Thank you for your thorough answer.<br></p><p>So when direct and indirect cases already look the same for the type system<br>then why is there the indirect modifier in the first place?<br>Couldn&#39;t the compiler just automatically box variables which would cause a<br>recursion? For structs, enums and probably tuples.<br></p><p>&gt;From what I understand in indirected enum cases the compiler will basically<br>just box either<br></p><p>   - the case value as a whole or<br>   - just the associative values which cause the recursion.<br></p><p>What is boxed?<br></p><p>I do not intend to propose to make indirect part of the type itself. I&#39;m<br>checking whether the modifier can be moved closer to the declaration of the<br>variables which cause the indirections.<br>What I need for my proposal is indeed indirection on structs and for that<br>I&#39;d like to understand how indirections work under the hood and what their<br>limitations are.<br>Your answer already gives a lot of insight there.<br></p><p>Actually I once needed to design a recursive struct<br>&lt;https://gist.github.com/fluidsonic/6a8f1c1def2a92416519&gt; and did so by<br>just wrapping the recursive variable in an indirect enum case. Works fine<br>in Swift 2.1<br>I could have done it differently - e.g. by storing an array of parents<br>instead of using recursion - but the approach worked.<br></p><p>How can a recursive struct using indirection be an infinite type? Since the<br>indirect variables are just boxes which have a fixed size (just a pointer?)<br>independent of the struct&#39;s size the type is no longer infinite.<br></p><p>Thanks,<br>  Marc<br></p><p><br>On Fri, Dec 11, 2015 at 4:03 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br></p><p>&gt; Hi Marc,<br>&gt;<br>&gt; On Dec 11, 2015, at 3:06 AM, Marc Knaup via swift-dev &lt;swift-dev at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Hey guys,<br>&gt;<br>&gt; I&#39;m working on a proposal and the question arose why the declaration<br>&gt; modifier indirect can only be specified for the whole enum case and the<br>&gt; whole enum but not for the actual parameter which is indirect.<br>&gt;<br>&gt; I.e. is there any technical reason which would prevent something like the<br>&gt; following?<br>&gt;<br>&gt;<br>&gt;    1. enum ArithmeticExpression {<br>&gt;    2. case Number(Int)<br>&gt;    3. case Addition(indirect ArithmeticExpression, indirect<br>&gt;    ArithmeticExpression)<br>&gt;    4. case Multiplication(indirect ArithmeticExpression, indirect<br>&gt;    ArithmeticExpression)<br>&gt;    5. }<br>&gt;<br>&gt;<br>&gt; Right now, notice that direct and indirect cases look the same from the<br>&gt; perspective of the type system.<br>&gt;<br>&gt; With your proposal, the fact that the entire tuple payload can be matched<br>&gt; by a pattern implies that ‘indirect’ has to become a formal type in the<br>&gt; language, since you will now be able to write down a value of type<br>&gt; &#39;(indirect ArithmeticExpression, Int)’, for example. It also raises the<br>&gt; issue of how these indirect values are wrapped and unwrapped, since now the<br>&gt; ‘indirect ArithmeticExpression’ is itself a value.<br>&gt;<br>&gt; An alternative is to make ‘indirect’ a non-materializable type, like<br>&gt; ‘inout’. ‘inout’ can appear inside tuple types, but is not a first class<br>&gt; value. This creates lots of special cases for ‘inout’ and you can imagine<br>&gt; it will be equally difficult for ‘indirect’.<br>&gt;<br>&gt; If you want an ‘indirect’ that can be nested inside a tuple type, you<br>&gt; could just define ‘class Box&lt;T&gt; { let payload: T }’ and tolerate a bit of<br>&gt; verbosity when wrapping and unwrapping values. As long as the payload is<br>&gt; immutable, you will still have value semantics using this trick.<br>&gt;<br>&gt;<br>&gt; Also is there any technical reason which would prevent indirect from<br>&gt; being used for structs?<br>&gt;<br>&gt;<br>&gt; Like an ‘indirect’ modifier for stored properties on structs? Yes, this<br>&gt; should be possible, however note that right now enum payloads are not<br>&gt; themselves lvalues, which means that assignment of indirect enum cases only<br>&gt; has to update the reference count of the box to maintain value semantics,<br>&gt; since the contents of the box will never change. Presumably for structs you<br>&gt; would need to be able to define an ‘indirect var’ with a mutable payload —<br>&gt; immutable-only indirect stored properties don’t seem very useful.<br>&gt;<br>&gt; Making the indirect payload mutable will require either copying the box<br>&gt; upon assignment, or alternatively, a copy-on-write scheme could be used.<br>&gt; The SIL @box type that implements indirect cases isn’t set up to support<br>&gt; either of those right now. Also, unlike enums, indirect fields of structs<br>&gt; won’t give you any new generality that was not possible before — its just a<br>&gt; performance change. A value type that contains a cycle through an<br>&gt; ‘indirect’ struct field is still invalid, for example, because the<br>&gt; resulting type is still infinite.<br>&gt;<br>&gt; Slava<br>&gt;<br>&gt;<br>&gt; Thanks,<br>&gt;   Marc<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151211/e8fb18a3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Location of &quot;indirect&quot; declaration modifier</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>December 11, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 8:01 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt; <br>&gt; Thank you for your thorough answer.<br>&gt; <br>&gt; So when direct and indirect cases already look the same for the type system then why is there the indirect modifier in the first place?<br>&gt; Couldn&#39;t the compiler just automatically box variables which would cause a recursion? For structs, enums and probably tuples.<br></p><p>The compiler could certainly infer ‘indirect’ if there is a cycle of unsubstituted types, eg,<br></p><p>enum A {<br>	case X<br>	case Y(S) // could infer indirect here<br>}<br></p><p>struct S {<br>	let a: A<br>}<br></p><p>However, the circularity might be introduced by a generic type substitution:<br></p><p>enum A&lt;T, U&gt; {<br>	case X<br>	case Y(T)<br>	case Z(U)<br>}<br></p><p>struct R {}<br></p><p>struct S {<br>	let a: A&lt;S, R&gt;<br>}<br></p><p>Here, A&lt;S, R&gt; needs Y to be indirect, but A&lt;R, S&gt; needs Z to be indirect. This would put the indirectness on different cases for different substitutions of the same generic type, which would complicate code generation for functions which manipulate A&lt;T, U&gt; generically.<br></p><p>Also even if ‘indirect’ could always be inferred, it seems like a good idea to give the user control over where the indirection occurs — this can have an effect on the size of the enum value for instance.<br></p><p>&gt; <br>&gt; From what I understand in indirected enum cases the compiler will basically just box either<br>&gt; the case value as a whole or<br>&gt; just the associative values which cause the recursion.<br>&gt; What is boxed?<br></p><p>Applying the ‘indirect’ keyword to the enum has the same effect as applying it to all payload cases. In both instances, the enum case discriminator is stored as part of the value, and not inside the box.<br></p><p>&gt; <br>&gt; I do not intend to propose to make indirect part of the type itself. I&#39;m checking whether the modifier can be moved closer to the declaration of the variables which cause the indirections.<br></p><p>Basically, the problem is the type of an enum payload is a single value, which may be a tuple. So if indirect can appear inside this tuple, it’s part of the type, because it becomes possible to get a value whose type is the type of the payload, with the indirect and all.<br></p><p>&gt; What I need for my proposal is indeed indirection on structs and for that I&#39;d like to understand how indirections work under the hood and what their limitations are.<br>&gt; Your answer already gives a lot of insight there.<br>&gt; <br>&gt; Actually I once needed to design a recursive struct &lt;https://gist.github.com/fluidsonic/6a8f1c1def2a92416519&gt; and did so by just wrapping the recursive variable in an indirect enum case. Works fine in Swift 2.1<br>&gt; I could have done it differently - e.g. by storing an array of parents instead of using recursion - but the approach worked.<br>&gt; <br>&gt; How can a recursive struct using indirection be an infinite type? Since the indirect variables are just boxes which have a fixed size (just a pointer?) independent of the struct&#39;s size the type is no longer infinite.<br></p><p>Yes, but each indirect box has to have a value. So for example, this is invalid, whether or not the property is ‘indirect’ — DI would require S.s be initialized to a value of type S in the constructor, which in turn has to be initialized, leading to an infinite chain S.s.s.s.s… of values.<br></p><p>struct S {<br>	let s: S<br>}<br></p><p>&gt; <br>&gt; Thanks,<br>&gt;   Marc<br>&gt; <br>&gt; <br>&gt; On Fri, Dec 11, 2015 at 4:03 PM, Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt; Hi Marc,<br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 3:06 AM, Marc Knaup via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey guys,<br>&gt;&gt; <br>&gt;&gt; I&#39;m working on a proposal and the question arose why the declaration modifier indirect can only be specified for the whole enum case and the whole enum but not for the actual parameter which is indirect.<br>&gt;&gt; <br>&gt;&gt; I.e. is there any technical reason which would prevent something like the following?<br>&gt;&gt; <br>&gt;&gt; enum ArithmeticExpression {<br>&gt;&gt;     case Number(Int)<br>&gt;&gt;     case Addition(indirect ArithmeticExpression, indirect ArithmeticExpression)<br>&gt;&gt;     case Multiplication(indirect ArithmeticExpression, indirect ArithmeticExpression)<br>&gt;&gt; }<br>&gt; <br>&gt; Right now, notice that direct and indirect cases look the same from the perspective of the type system.<br>&gt; <br>&gt; With your proposal, the fact that the entire tuple payload can be matched by a pattern implies that ‘indirect’ has to become a formal type in the language, since you will now be able to write down a value of type &#39;(indirect ArithmeticExpression, Int)’, for example. It also raises the issue of how these indirect values are wrapped and unwrapped, since now the ‘indirect ArithmeticExpression’ is itself a value.<br>&gt; <br>&gt; An alternative is to make ‘indirect’ a non-materializable type, like ‘inout’. ‘inout’ can appear inside tuple types, but is not a first class value. This creates lots of special cases for ‘inout’ and you can imagine it will be equally difficult for ‘indirect’.<br>&gt; <br>&gt; If you want an ‘indirect’ that can be nested inside a tuple type, you could just define ‘class Box&lt;T&gt; { let payload: T }’ and tolerate a bit of verbosity when wrapping and unwrapping values. As long as the payload is immutable, you will still have value semantics using this trick.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Also is there any technical reason which would prevent indirect from being used for structs?<br>&gt; <br>&gt; Like an ‘indirect’ modifier for stored properties on structs? Yes, this should be possible, however note that right now enum payloads are not themselves lvalues, which means that assignment of indirect enum cases only has to update the reference count of the box to maintain value semantics, since the contents of the box will never change. Presumably for structs you would need to be able to define an ‘indirect var’ with a mutable payload — immutable-only indirect stored properties don’t seem very useful.<br>&gt; <br>&gt; Making the indirect payload mutable will require either copying the box upon assignment, or alternatively, a copy-on-write scheme could be used. The SIL @box type that implements indirect cases isn’t set up to support either of those right now. Also, unlike enums, indirect fields of structs won’t give you any new generality that was not possible before — its just a performance change. A value type that contains a cycle through an ‘indirect’ struct field is still invalid, for example, because the resulting type is still infinite.<br>&gt; <br>&gt; Slava<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt;   Marc<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151211/012d9b6f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Location of &quot;indirect&quot; declaration modifier</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 11, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; Also even if ‘indirect’ could always be inferred, it seems like a good idea to give the user control over where the indirection occurs — this can have an effect on the size of the enum value for instance.<br></p><p>+1.  Requiring it to be specified also prevents unintentional indirection.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Location of &quot;indirect&quot; declaration modifier</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 11, 2015 at 05:00:00pm</p></header><div class="content"><p>I also agree that requiring the developer to specify the modifier does make<br>sense esp. with the performance downsides and the generic issue described<br>by Slava.<br></p><p>The example with the recursive struct makes sense! I forgot that in my<br>cases either an enum, an Optional (so an enum) or a protocol were breaking<br>that init cycle for recursive variables.<br>lazy private(set) var will probably also work although it&#39;s use is likely<br>limited.<br></p><p>Now I do have a good sense what is possible and how.<br>Thank you very much, Slava!<br></p><p><br>On Fri, Dec 11, 2015 at 5:32 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; &gt; Also even if ‘indirect’ could always be inferred, it seems like a good<br>&gt; idea to give the user control over where the indirection occurs — this can<br>&gt; have an effect on the size of the enum value for instance.<br>&gt;<br>&gt; +1.  Requiring it to be specified also prevents unintentional indirection.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151211/d2efec1c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Location of &quot;indirect&quot; declaration modifier</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 13, 2015 at 01:00:00pm</p></header><div class="content"><p>On Dec 11, 2015, at 7:03 AM, Slava Pestov via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; With your proposal, the fact that the entire tuple payload can be matched by a pattern implies that ‘indirect’ has to become a formal type in the language, since you will now be able to write down a value of type &#39;(indirect ArithmeticExpression, Int)’, for example. It also raises the issue of how these indirect values are wrapped and unwrapped, since now the ‘indirect ArithmeticExpression’ is itself a value.<br></p><p>Yes.<br></p><p>&gt; An alternative is to make ‘indirect’ a non-materializable type, like ‘inout’. ‘inout’ can appear inside tuple types, but is not a first class value. This creates lots of special cases for ‘inout’ and you can imagine it will be equally difficult for ‘indirect’.<br></p><p>Incidentally, I’m of the opinion that we’re modeling this wrong, on both the call and the declaration side.  <br></p><p>Decl side: because we historically allowed arbitrary irrefutable patterns in argument lists, the argument list of a AbstractFunctionDecl is represented as a Pattern.  This doesn’t make sense because we’ve since realized that that was a bad idea, and now argument lists have their own parsing logic and can only support specific trivial kinds of patterns.  It is also annoying because general patterns cannot use “inout” or internal vs external parameter names, so argument lists are making real patterns more complicated.  I plan to fix this by splitting AbstractFunctionDecl onto a custom data structure, allowing this to be simplified.<br></p><p>On the call side, we have analogous representation damage, where ApplyExpr takes a function and an argument, and the argument is usually a tuple, sometimes a parenexpr, or sometimes neither!  This makes a lot of stuff more complicated, and forces “&amp;” in argument lists to be represented as InOutExpr, and that Expr needs a type (InOutType).  If we changed ApplyExpr to take a structured argument list, we could dispel this complexity (eliminating InOutType and InOutExpr completely, along with a ton of corner case bugs).  This would lead to a lot simpler code throughout the compiler as well.<br></p><p>Fixing these are on my todo list somewhere :-) and I’ve heard that ChrisW is also interested in this area.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
