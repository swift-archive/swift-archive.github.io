<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/16b684a72bf6d9c58f534aa525253030?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Will Fancher</string> &lt;willfancher38 at gmail.com&gt;<p>December 16, 2015 at 06:00:00am</p></header><div class="content"><p>Hello,<br></p><p>A potent problem in my experience with Swift has been the lack of a way to generalize code that is repetitive on the basis of higher kinded types. For the uninitiated, higher kinded types are the ability to reason about generic types with their type parameters as variable. For example, the Haskell definition for Functor, and a corresponding definition for Maybe (Haskell&#39;s equivalent to Optional)<br></p><p>    typeclass Functor f where<br>        fmap :: (a -&gt; b) -&gt; f a -&gt; f b<br></p><p>    instance Functor Maybe where<br>        fmap f (Just a) = Just (f a)<br>        fmap f Nothing = Nothing<br></p><p>This makes it possible to build functions which operate not just on Maybe, but on any Functor.<br></p><p>    fstrlen :: Functor f =&gt; f String -&gt; f Int<br>    fstrlen fstr = fmap length fstr<br>    <br>    &gt; -- In the Haskell REPL<br>    &gt; fstrlen (Just &quot;Hello&quot;) -- prints &quot;Just 5&quot;<br></p><p>In Swift, such an abstract function is not possible. There simply is no way to express that your function would like to accept a type that wraps something, and returns that same type wrapping something else.<br></p><p>I propose a new where clause in Swift&#39;s generics system that would allow for higher kinded type equality. The syntax would be some operator meant to appear to say &quot;like&quot; or &quot;approximately equal&quot;, such as ~=. This operator would mean that the two operands are the same type, but with potentially different type parameters / typealiases. As an example, Functor could be implemented like this:<br></p><p>    protocol Functor {<br>        typealias A<br>        func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>    }<br></p><p>The map function declaration says<br></p><p>    A function, fmap, on the Self type (where Self is a Functor with typealias A)<br>    With type parameter FB, that is the same kind of Functor as Self, with an arbitrarily different A typealias.<br></p><p>This ensures at the type level that given a Functor f, calling f.fmap will result in the same type of Functor. For example, here is both an implementation of Functor, as well as a function which uses a Functor<br></p><p>    extension Optional: Functor {<br>        func fmap&lt;Mapped&gt;(f: Wrapped -&gt; Mapped) -&gt; Mapped? {<br>            if let wrapped = self {<br>                return f(wrapped)<br>            } else {<br>                return nil<br>            }<br>        }<br>    }<br>    <br>    func fstrlen&lt;<br>            FString: Functor, FInt<br>        where<br>            FInt ~= FString, FString.A == String, FInt.A == Int&gt;<br>    (str: FString) -&gt; FInt {<br>        return str.fmap { $0.characters.count }<br>    }<br></p><p>As another example, the infamous Monad. Monads are everywhere. Countless data types can be expressed as Monads. It is useful to have an abstraction over them, as it provides a means to implement common operations on all of them without repetitive code.<br></p><p>    protocol Monad {<br>        typealias A<br>        static func point(a: A) -&gt; Self<br>        func flatMap&lt;MB where MB ~= Self&gt;(f: A -&gt; MB) -&gt; MB<br>    }<br></p><p>A function which is relatively useful, join, can be implemented like this:<br></p><p>    func join&lt;M: Monad, MM where MM ~= M, MM.A == M&gt;(mm: MM) -&gt; M {<br>        return mm.flatMap { $0 }<br>    }<br></p><p>There&#39;s a whole host of functions and theories that higher kinded types enable. This proposal fits nicely with Swift 3&#39;s goal of completing generics, and as far as I can see, there are no obvious conflicts with the Swift language. I imagine the implementation might be far from trivial, but that sounds like a discussion worth having.<br></p><p>I look forward to your feedback. Thank you for reading,<br></p><p>- Will Fancher<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/16b684a72bf6d9c58f534aa525253030?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Will Fancher</string> &lt;willfancher38 at gmail.com&gt;<p>December 16, 2015 at 06:00:00am</p></header><div class="content"><p>As a quick addendum, I&#39;d like to point out that implementing Monad, Applicative, and Functor allows for some &quot;free&quot; code reuse. Functor can be defined expressly in terms of Applicative, which can be defined in terms of Monad.<br></p><p>    protocol Monad {<br>        typealias MonadType<br>        static func point(a: MonadType) -&gt; Self<br>        func flatMap&lt;MB where MB ~= Self&gt;(f: MonadType -&gt; MB) -&gt; MB<br>    }<br></p><p>    protocol Applicative {<br>        typealias ApplicativeType<br>        static func pure(a: ApplicativeType) -&gt; Self<br>        func apply&lt;<br>                Func, Return<br>            where<br>                Func ~= Self, Return ~= Self,<br>                Func.ApplicativeType == (ApplicativeType -&gt; Return.ApplicativeType)&gt;<br>        (f: Func) -&gt; Return<br>    }<br></p><p>    protocol Functor {<br>        typealias FunctorType<br>        func fmap&lt;Return where Return ~= Self&gt;(f: FunctorType -&gt; Return.FunctorType) -&gt; Return<br>    }<br></p><p>    extension Monad: Applicative {<br>        static func pure(a: MonadType) -&gt; Self {<br>            return point(a)<br>        }<br></p><p>        func apply&lt;<br>                Func, Return<br>            where<br>                Func ~= Self, Return ~= Self,<br>                Func.MonadType == (MonadType -&gt; Return.MonadType)&gt;<br>        (f: Func) -&gt; Return {<br>            return f.flatMap { fn in<br>                return self.flatMap { m in<br>                    return point(fn(m))<br>                }<br>            }<br>        }<br>    }<br></p><p>    extension Applicative: Functor {<br>        func fmap&lt;Return where Return ~= Self&gt;(f: ApplicativeType -&gt; Return.ApplicativeType) -&gt; Return {<br>            return apply(pure(f))<br>        }<br>    }<br></p><p>The effect here is that just defining an implementation of Monad on a type gets Applicative and Functor for &quot;free&quot;. Granted, those implementations are far from optimized, but they&#39;re free, and can be overridden for optimization. The point is, the higher kinded types in use here drastically reduce repetitive code by allowing common patterns like these definitions of Applicative and Functor to be abstracted.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December 16, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On 16 Dec 2015, at 11:11, Will Fancher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello,<br>&gt; <br>&gt; A potent problem in my experience with Swift has been the lack of a way to generalize code that is repetitive on the basis of higher kinded types. For the uninitiated, higher kinded types are the ability to reason about generic types with their type parameters as variable. <br></p><p>For those thinking, “Hmm… What’s the benefit of all this crazy sounding stuff?”, there’s a rather good practical talk about Functors.<br></p><p>How I Learned to Stop Worrying and Love the Functor:<br>https://vimeo.com/132657092<br></p><p><br>Here’s an example that is used:<br></p><p>func sayHello(name: Optional&lt;String&gt;) -&gt; Optional&lt;String&gt; {<br>  return name.map { &quot;Hello \($0)&quot; }<br>}<br></p><p>func sayHello(name: Array&lt;String&gt;) -&gt; Array&lt;String&gt; {<br>  return name.map { &quot;Hello \($0)&quot; }<br>}<br></p><p>It doesn’t use the usual syntax sugar for Optionals and Array, to make it clear that the only difference between the 2 functions is the type signature. If were possible to express the concept of a Functor, we could write one function that would accept both Optionals and Arrays as parameters – and not just those 2, but any Functor (Result, Future, Signal…).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/a9901450/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 17, 2015 at 12:00:00am</p></header><div class="content"><p>+100 to this.<br></p><p>I&#39;m not a huge fan of ~= syntax, but higher kinded types are something<br>swift would benefit greatly from, particularly with stronger more concise<br>type constraints, more code reuse.<br></p><p>Another example, one I&#39;m very keen on achieving, is this:<br></p><p>With Swift 1.2 how do you implement map on CollectionType that returns the<br>same type of collection?<br></p><p>Give it a go, I learnt a lot failing! You&#39;re aiming to be able to do this:<br></p><p>extension CollectionType {<br>    func myMap ....<br>}<br></p><p>let myDictionary: [String:Int] = [&quot;test&quot;: 1]<br>var otherDictionary = myDictionary.myMap { ($0, Float($1)) }<br></p><p>// does not fail:<br></p><p>assert(otherDictionary is [String:Float])<br></p><p>let myArray: [Int] = [1]<br></p><p>// error: cannot convert &#39;[Float]&#39; to specified type &#39;[String : Float]&#39;<br></p><p>otherDictionary = myOptional.myMap { Float($0) }<br></p><p><br>The caveats are:<br> *  it has to work regardless of what is implementing CollectionType, and<br> * it can&#39;t have an ambiguous return type<br></p><p>With higher kinded types you could do something like this:<br></p><p>extension CollectionType {<br>    func myMap&lt;G: GeneratorType&gt;(transform: Generator.Element-&gt;G.Element)<br>-&gt; Self&lt;G&gt; {<br>        return Self(sequence: AnySequence(self).forEach(transform))<br>    }<br>}<br></p><p><br></p><p>On Wed, Dec 16, 2015 at 11:39 PM, Al Skipp via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On 16 Dec 2015, at 11:11, Will Fancher via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hello,<br>&gt;<br>&gt; A potent problem in my experience with Swift has been the lack of a way to<br>&gt; generalize code that is repetitive on the basis of higher kinded types. For<br>&gt; the uninitiated, higher kinded types are the ability to reason about<br>&gt; generic types with their type parameters as variable.<br>&gt;<br>&gt;<br>&gt; For those thinking, “Hmm… What’s the benefit of all this crazy sounding<br>&gt; stuff?”, there’s a rather good practical talk about Functors.<br>&gt;<br>&gt; *How I Learned to Stop Worrying and Love the Functor:*<br>&gt; https://vimeo.com/132657092<br>&gt;<br>&gt;<br>&gt; Here’s an example that is used:<br>&gt;<br>&gt; func sayHello(name: Optional&lt;String&gt;) -&gt; Optional&lt;String&gt; {<br>&gt;   return name.map { &quot;Hello \($0)&quot; }<br>&gt; }<br>&gt;<br>&gt; func sayHello(name: Array&lt;String&gt;) -&gt; Array&lt;String&gt; {<br>&gt;   return name.map { &quot;Hello \($0)&quot; }<br>&gt; }<br>&gt;<br>&gt; It doesn’t use the usual syntax sugar for Optionals and Array, to make it<br>&gt; clear that the only difference between the 2 functions is the type<br>&gt; signature. If were possible to express the concept of a Functor, we could<br>&gt; write one function that would accept both Optionals and Arrays as<br>&gt; parameters – and not just those 2, but any Functor (Result, Future,<br>&gt; Signal…).<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/d8a1dc4e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December 16, 2015 at 09:00:00am</p></header><div class="content"><p>I am for this but I am sure that we won&#39;t get it in Swift 3. I do hope that<br>we at least consider it enough to ensure that the ABI supports it to some<br>extent.<br></p><p>TJ<br></p><p>On Wed, Dec 16, 2015 at 8:36 AM, Andrew Bennett via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +100 to this.<br>&gt;<br>&gt; I&#39;m not a huge fan of ~= syntax, but higher kinded types are something<br>&gt; swift would benefit greatly from, particularly with stronger more concise<br>&gt; type constraints, more code reuse.<br>&gt;<br>&gt; Another example, one I&#39;m very keen on achieving, is this:<br>&gt;<br>&gt; With Swift 1.2 how do you implement map on CollectionType that returns the<br>&gt; same type of collection?<br>&gt;<br>&gt; Give it a go, I learnt a lot failing! You&#39;re aiming to be able to do this:<br>&gt;<br>&gt; extension CollectionType {<br>&gt;     func myMap ....<br>&gt; }<br>&gt;<br>&gt; let myDictionary: [String:Int] = [&quot;test&quot;: 1]<br>&gt; var otherDictionary = myDictionary.myMap { ($0, Float($1)) }<br>&gt;<br>&gt; // does not fail:<br>&gt;<br>&gt; assert(otherDictionary is [String:Float])<br>&gt;<br>&gt; let myArray: [Int] = [1]<br>&gt;<br>&gt; // error: cannot convert &#39;[Float]&#39; to specified type &#39;[String : Float]&#39;<br>&gt;<br>&gt; otherDictionary = myOptional.myMap { Float($0) }<br>&gt;<br>&gt;<br>&gt; The caveats are:<br>&gt;  *  it has to work regardless of what is implementing CollectionType, and<br>&gt;  * it can&#39;t have an ambiguous return type<br>&gt;<br>&gt; With higher kinded types you could do something like this:<br>&gt;<br>&gt; extension CollectionType {<br>&gt;     func myMap&lt;G: GeneratorType&gt;(transform: Generator.Element-&gt;G.Element)<br>&gt; -&gt; Self&lt;G&gt; {<br>&gt;         return Self(sequence: AnySequence(self).forEach(transform))<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 11:39 PM, Al Skipp via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On 16 Dec 2015, at 11:11, Will Fancher via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hello,<br>&gt;&gt;<br>&gt;&gt; A potent problem in my experience with Swift has been the lack of a way<br>&gt;&gt; to generalize code that is repetitive on the basis of higher kinded types.<br>&gt;&gt; For the uninitiated, higher kinded types are the ability to reason about<br>&gt;&gt; generic types with their type parameters as variable.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; For those thinking, “Hmm… What’s the benefit of all this crazy sounding<br>&gt;&gt; stuff?”, there’s a rather good practical talk about Functors.<br>&gt;&gt;<br>&gt;&gt; *How I Learned to Stop Worrying and Love the Functor:*<br>&gt;&gt; https://vimeo.com/132657092<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Here’s an example that is used:<br>&gt;&gt;<br>&gt;&gt; func sayHello(name: Optional&lt;String&gt;) -&gt; Optional&lt;String&gt; {<br>&gt;&gt;   return name.map { &quot;Hello \($0)&quot; }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; func sayHello(name: Array&lt;String&gt;) -&gt; Array&lt;String&gt; {<br>&gt;&gt;   return name.map { &quot;Hello \($0)&quot; }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; It doesn’t use the usual syntax sugar for Optionals and Array, to make it<br>&gt;&gt; clear that the only difference between the 2 functions is the type<br>&gt;&gt; signature. If were possible to express the concept of a Functor, we could<br>&gt;&gt; write one function that would accept both Optionals and Arrays as<br>&gt;&gt; parameters – and not just those 2, but any Functor (Result, Future,<br>&gt;&gt; Signal…).<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/41f8b8ad/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December 16, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; let myDictionary: [String:Int] = [&quot;test&quot;: 1]<br>&gt; var otherDictionary = myDictionary.myMap { ($0, Float($1)) }<br>&gt; // does not fail:<br>&gt; assert(otherDictionary is [String:Float])<br></p><p>The trouble with Dictionary is that peculiar things can happen if we can map over keys and return a Dictionary.<br></p><p>let dict = [&quot;a&quot;:1, &quot;b&quot;:2, &quot;c&quot;:3]<br>let dict2 = dict.map { (&quot;x&quot;, $1 * 2) } // [“x”:6]<br></p><p>We start with a Dictionary with 3 keys and end up with a Dictionary with 1 key! As the order of the keys is unknown, we have no idea what the value of the key will be either, it might be 6, 4 or 2. <br></p><p>Swift currently avoids this bedlam by returning an Array of tuples when ‘mapping’ a Dictionary. Strictly speaking this isn’t ‘map’ in the Functor sense, but then again Dictionary is a rogue that refuses to obey the Functor laws anyway.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/bb75f090/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 17, 2015 at 01:00:00am</p></header><div class="content"><p>Good point Al, I avoided Set for similar reasons. Feel free to substitute<br>Dictionary for String.CharacterView in my example. Unrelated to this<br>proposal I would like to see a mapValues method on Dictionary.<br></p><p>The main point though was that you can&#39;t unambiguously resolve the return<br>type. A similar example to yours, is that without higher kind types myMap<br>on CollectionType could allow this to compile:<br></p><p>let oops: String? = [1,2,3].myMap {&quot;\($0)&quot;}<br></p><p><br></p><p>On Thu, Dec 17, 2015 at 1:13 AM, Al Skipp &lt;al_skipp at fastmail.fm&gt; wrote:<br></p><p>&gt; let myDictionary: [String:Int] = [&quot;test&quot;: 1]<br>&gt; var otherDictionary = myDictionary.myMap { ($0, Float($1)) }<br>&gt;<br>&gt; // does not fail:<br>&gt;<br>&gt; assert(otherDictionary is [String:Float])<br>&gt;<br>&gt;<br>&gt; The trouble with Dictionary is that peculiar things can happen if we can<br>&gt; map over keys and return a Dictionary.<br>&gt;<br>&gt; let dict = [&quot;a&quot;:1, &quot;b&quot;:2, &quot;c&quot;:3]<br>&gt; let dict2 = dict.map { (&quot;x&quot;, $1 * 2) } // [“x”:6]<br>&gt;<br>&gt; We start with a Dictionary with 3 keys and end up with a Dictionary with 1<br>&gt; key! As the order of the keys is unknown, we have no idea what the value of<br>&gt; the key will be either, it might be 6, 4 or 2.<br>&gt;<br>&gt; Swift currently avoids this bedlam by returning an Array of tuples when<br>&gt; ‘mapping’ a Dictionary. Strictly speaking this isn’t ‘map’ in the Functor<br>&gt; sense, but then again Dictionary is a rogue that refuses to obey the<br>&gt; Functor laws anyway.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/43b94b9a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 11:00:00am</p></header><div class="content"><p>IMO the keys in a dictionary are not part of the contained values and therefore not part of the Functor mapping for Dictionary (obviously a map with different semantics is possible as exhibited by the standard library).  Dictionary should implement Functor by mapping over the values while preserving the keys.<br></p><p>A similar problem has been noted for Set.  In that case it is not possible to uphold the usual Functor laws.  IMO that points to the need for a protocol with weaker semantics than Functor.  It would preserve the essential structure without preserving the 1 to 1 projection.  There are likely a number of cases where this would make sense.  Functor could inherit from that protocol adding additional semantic requirements but no additional syntactic requirements.<br></p><p>Matthew<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 16, 2015, at 8:13 AM, Al Skipp via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; let myDictionary: [String:Int] = [&quot;test&quot;: 1]<br>&gt;&gt; var otherDictionary = myDictionary.myMap { ($0, Float($1)) }<br>&gt;&gt; // does not fail:<br>&gt;&gt; assert(otherDictionary is [String:Float])<br>&gt; <br>&gt; The trouble with Dictionary is that peculiar things can happen if we can map over keys and return a Dictionary.<br>&gt; <br>&gt; let dict = [&quot;a&quot;:1, &quot;b&quot;:2, &quot;c&quot;:3]<br>&gt; let dict2 = dict.map { (&quot;x&quot;, $1 * 2) } // [“x”:6]<br>&gt; <br>&gt; We start with a Dictionary with 3 keys and end up with a Dictionary with 1 key! As the order of the keys is unknown, we have no idea what the value of the key will be either, it might be 6, 4 or 2. <br>&gt; <br>&gt; Swift currently avoids this bedlam by returning an Array of tuples when ‘mapping’ a Dictionary. Strictly speaking this isn’t ‘map’ in the Functor sense, but then again Dictionary is a rogue that refuses to obey the Functor laws anyway.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/946b7706/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>December 16, 2015 at 09:00:00am</p></header><div class="content"><p>+1 on HKTs. By the way, there were a couple of people discussing the same<br>here (https://github.com/typelift/swift/issues/1); you may or may not want<br>to swap ideas with them and see if you can work together towards a formal<br>proposal. (However, since it doesn&#39;t seem HKTs are in scope for Swift 3, a<br>proposal might be deferred until next year.)<br></p><p>Austin<br></p><p>On Wed, Dec 16, 2015 at 9:08 AM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; IMO the keys in a dictionary are not part of the contained values and<br>&gt; therefore not part of the Functor mapping for Dictionary (obviously a map<br>&gt; with different semantics is possible as exhibited by the standard<br>&gt; library).  Dictionary should implement Functor by mapping over the values<br>&gt; while preserving the keys.<br>&gt;<br>&gt; A similar problem has been noted for Set.  In that case it is not possible<br>&gt; to uphold the usual Functor laws.  IMO that points to the need for a<br>&gt; protocol with weaker semantics than Functor.  It would preserve the<br>&gt; essential structure without preserving the 1 to 1 projection.  There are<br>&gt; likely a number of cases where this would make sense.  Functor could<br>&gt; inherit from that protocol adding additional semantic requirements but no<br>&gt; additional syntactic requirements.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Dec 16, 2015, at 8:13 AM, Al Skipp via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; let myDictionary: [String:Int] = [&quot;test&quot;: 1]<br>&gt; var otherDictionary = myDictionary.myMap { ($0, Float($1)) }<br>&gt;<br>&gt; // does not fail:<br>&gt;<br>&gt; assert(otherDictionary is [String:Float])<br>&gt;<br>&gt;<br>&gt; The trouble with Dictionary is that peculiar things can happen if we can<br>&gt; map over keys and return a Dictionary.<br>&gt;<br>&gt; let dict = [&quot;a&quot;:1, &quot;b&quot;:2, &quot;c&quot;:3]<br>&gt; let dict2 = dict.map { (&quot;x&quot;, $1 * 2) } // [“x”:6]<br>&gt;<br>&gt; We start with a Dictionary with 3 keys and end up with a Dictionary with 1<br>&gt; key! As the order of the keys is unknown, we have no idea what the value of<br>&gt; the key will be either, it might be 6, 4 or 2.<br>&gt;<br>&gt; Swift currently avoids this bedlam by returning an Array of tuples when<br>&gt; ‘mapping’ a Dictionary. Strictly speaking this isn’t ‘map’ in the Functor<br>&gt; sense, but then again Dictionary is a rogue that refuses to obey the<br>&gt; Functor laws anyway.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/f60a6d9b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 16, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 3:11 AM, Will Fancher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello,<br>&gt; <br>&gt; A potent problem in my experience with Swift has been the lack of a way to generalize code that is repetitive on the basis of higher kinded types. For the uninitiated, higher kinded types are the ability to reason about generic types with their type parameters as variable. For example, the Haskell definition for Functor, and a corresponding definition for Maybe (Haskell&#39;s equivalent to Optional)<br>&gt; <br>&gt;    typeclass Functor f where<br>&gt;        fmap :: (a -&gt; b) -&gt; f a -&gt; f b<br>&gt; <br>&gt;    instance Functor Maybe where<br>&gt;        fmap f (Just a) = Just (f a)<br>&gt;        fmap f Nothing = Nothing<br>&gt; <br>&gt; This makes it possible to build functions which operate not just on Maybe, but on any Functor.<br>&gt; <br>&gt;    fstrlen :: Functor f =&gt; f String -&gt; f Int<br>&gt;    fstrlen fstr = fmap length fstr<br>&gt; <br>&gt;&gt; -- In the Haskell REPL<br>&gt;&gt; fstrlen (Just &quot;Hello&quot;) -- prints &quot;Just 5&quot;<br>&gt; <br>&gt; In Swift, such an abstract function is not possible. There simply is no way to express that your function would like to accept a type that wraps something, and returns that same type wrapping something else.<br>&gt; <br>&gt; I propose a new where clause in Swift&#39;s generics system that would allow for higher kinded type equality. The syntax would be some operator meant to appear to say &quot;like&quot; or &quot;approximately equal&quot;, such as ~=. This operator would mean that the two operands are the same type, but with potentially different type parameters / typealiases. As an example, Functor could be implemented like this:<br>&gt; <br>&gt;    protocol Functor {<br>&gt;        typealias A<br>&gt;        func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt;    }<br>&gt; <br>&gt; The map function declaration says<br>&gt; <br>&gt;    A function, fmap, on the Self type (where Self is a Functor with typealias A)<br>&gt;    With type parameter FB, that is the same kind of Functor as Self, with an arbitrarily different A typealias.<br>&gt; <br>&gt; This ensures at the type level that given a Functor f, calling f.fmap will result in the same type of Functor. For example, here is both an implementation of Functor, as well as a function which uses a Functor<br>&gt; <br>&gt;    extension Optional: Functor {<br>&gt;        func fmap&lt;Mapped&gt;(f: Wrapped -&gt; Mapped) -&gt; Mapped? {<br>&gt;            if let wrapped = self {<br>&gt;                return f(wrapped)<br>&gt;            } else {<br>&gt;                return nil<br>&gt;            }<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt;    func fstrlen&lt;<br>&gt;            FString: Functor, FInt<br>&gt;        where<br>&gt;            FInt ~= FString, FString.A == String, FInt.A == Int&gt;<br>&gt;    (str: FString) -&gt; FInt {<br>&gt;        return str.fmap { $0.characters.count }<br>&gt;    }<br>&gt; <br>&gt; As another example, the infamous Monad. Monads are everywhere. Countless data types can be expressed as Monads. It is useful to have an abstraction over them, as it provides a means to implement common operations on all of them without repetitive code.<br>&gt; <br>&gt;    protocol Monad {<br>&gt;        typealias A<br>&gt;        static func point(a: A) -&gt; Self<br>&gt;        func flatMap&lt;MB where MB ~= Self&gt;(f: A -&gt; MB) -&gt; MB<br>&gt;    }<br>&gt; <br>&gt; A function which is relatively useful, join, can be implemented like this:<br>&gt; <br>&gt;    func join&lt;M: Monad, MM where MM ~= M, MM.A == M&gt;(mm: MM) -&gt; M {<br>&gt;        return mm.flatMap { $0 }<br>&gt;    }<br>&gt; <br>&gt; There&#39;s a whole host of functions and theories that higher kinded types enable. This proposal fits nicely with Swift 3&#39;s goal of completing generics, and as far as I can see, there are no obvious conflicts with the Swift language. I imagine the implementation might be far from trivial, but that sounds like a discussion worth having.<br>&gt; <br>&gt; I look forward to your feedback. Thank you for reading,<br></p><p>Without going into any specifics of higher-kinded types, I sent out a note last night about what the “Swift 3 Generics” effort entails, here:<br></p><p>	https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002718.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002718.html&gt;<br></p><p>One comment there is that I consider higher-kinded types out-of-scope for Swift 3. There is a *lot* of intended churn in generics already in Swift 3, and we will not be able to handle either the design or the implementation of higher-kinded types as well.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/c19ced77/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/16b684a72bf6d9c58f534aa525253030?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Will Fancher</string> &lt;willfancher38 at gmail.com&gt;<p>December 16, 2015 at 03:00:00pm</p></header><div class="content"><p>Could you elaborate on why you think it&#39;s out of scope? Maybe it&#39;s just me, but it seems like a very pressing feature. Being unable to write higher kinded abstractions has been a big issue with using Swift generics. It has been impossible to do various kinds of abstractions. It makes generics feel very incomplete, so I feel that it lines up well with the &quot;complete generics&quot; goal.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 16, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 12:15 PM, Will Fancher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Could you elaborate on why you think it&#39;s out of scope? Maybe it&#39;s just me, but it seems like a very pressing feature. Being unable to write higher kinded abstractions has been a big issue with using Swift generics. It has been impossible to do various kinds of abstractions.<br></p><p>I would like to better understand which abstractions you are blocked from implementing (other than the basic HKTs themselves).  I understand how HKTs enable some more code reuse, but most of the abstractions that HKTs enable seem to be based on the structure of types rather than on semantics, which makes them:<br></p><p>a) hard to understand<br>b) hard to document<br>c) hard to compose into big “towers” of useful semantics. <br></p><p>What I mean here is that there don’t seem to be many useful abstractions out there that can be built upon a “Monad” constraint (for example), and because “Monad” is such a general concept, when you *do* encounter such an abstraction it’s hard to understand what to do with it.<br> <br>Therefore I have always thought that the costs in language and conceptual complexity vs benefits for HKTs is at least highly debatable.  I have occasionally bumped up against the lack of HKTs, but IMO broadly speaking our users are not suffering from the inability to express “Monad” but many of the other generics features we are lacking prevent even the components we *do* provide from functioning completely and properly (e.g. Arrays are never Equatable).<br></p><p>&gt; It makes generics feel very incomplete, so I feel that it lines up well with the &quot;complete generics&quot; goal.<br></p><p>It does, but—just my personal opinion—it would probably be the first thing I would cut from the list when considering resource constraints.<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/16b684a72bf6d9c58f534aa525253030?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Will Fancher</string> &lt;willfancher38 at gmail.com&gt;<p>December 16, 2015 at 04:00:00pm</p></header><div class="content"><p>With respect specifically to Monads, there are numerous useful abstractions. For one, Applicative and Functor can be derived for free, requiring the no effort on the Monad instance&#39;s part. This alone eliminates a lot of code repetition. Additionally, the large majority of functions described for Haskell here are very useful:<br></p><p>https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html.<br></p><p>Those functions come as abstractions over monads which can be easily understood (if you understand monads) and which eliminate a lot of code repetition. The existence of these abstractions makes any Monad type much more robust that it would be on its own.<br></p><p>There are plenty of typeclasses in Haskell that could be implemented in Swift and would be useful if we had HKTs. Foldables and Traversables, for example, are simple and powerful abstractions that would be well worth having. And there are various simpler things besides Haskell typeclasses that can&#39;t be done in Swift as it stands. For example, you can&#39;t currently take a collection of type C1: CollectionType, and return a value of type C2 where C2 ~= C1, which means you can&#39;t perform arbitrary transformations on arbitrary collections. You have to choose an implementation type and use that one.<br></p><p>This isn&#39;t to say this should all be in the standard library. I think most of these protocols would be best off in a separate package, to keep the standard simple for newcomers and for those who don&#39;t need these features. So I&#39;m not suggesting that the Swift team create Monad, Functor, etc. in the standard library and then extend all the appropriate types to implement those (although it&#39;d be a bonus if the team wanted to). That job would be up to whoever wants to write the package for it. But, in my opinion, the ability for such a package to exist seems very important.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 16, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 1:10 PM, Will Fancher &lt;willfancher38 at gmail.com&gt; wrote:<br>&gt; <br>&gt; With respect specifically to Monads, there are numerous useful abstractions. For one, Applicative and Functor can be derived for free, requiring the no effort on the Monad instance&#39;s part. This alone eliminates a lot of code repetition. Additionally, the large majority of functions described for Haskell here are very useful:<br>&gt; <br>&gt; https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html.<br>&gt; <br>&gt; Those functions come as abstractions over monads which can be easily understood (if you understand monads) and which eliminate a lot of code repetition. The existence of these abstractions makes any Monad type much more robust that it would be on its own.<br></p><p>To make this argument, you’ll need to make it more concrete and more relevant to more Swift programmers. Haskell is an amazing language in which one can express some truly beautiful abstractions… but Swift is not Haskell, and it caters to a different audience. If we’re to bring in more advanced type system features from Haskell, they need to be justified in the context of how this helps a significant population of Swift programmers in their everyday programming.<br></p><p>&gt; There are plenty of typeclasses in Haskell that could be implemented in Swift and would be useful if we had HKTs. Foldables and Traversables, for example, are simple and powerful abstractions that would be well worth having. And there are various simpler things besides Haskell typeclasses that can&#39;t be done in Swift as it stands. For example, you can&#39;t currently take a collection of type C1: CollectionType, and return a value of type C2 where C2 ~= C1, which means you can&#39;t perform arbitrary transformations on arbitrary collections. You have to choose an implementation type and use that one.<br></p><p><br>*I* know what you mean here, but make it concrete. For example, our primary map operation currently returns an array:<br></p><p>  extension SequenceType {<br>    @warn_unused_result<br>    func map&lt;T&gt;(<br>      @noescape includeElement: (Generator.Element) throws -&gt; T<br>    ) rethrows -&gt; [T]<br></p><p>With higher-kinded types, one could potentially [*] produce a collection of the same kind as Self but with the element type T. So, mapping a Set produces a Set, mapping an Array produces an Array, etc. That’s a <br></p><p>And you’re going to hear me say this a lot, but we are severely bandwidth-limited on design of major features, especially in the generics system because of it’s complexity.<br></p><p>	- Doug<br></p><p>[*] You wouldn’t actually be able to do this on SequenceType, because you can’t necessarily construct it.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/16b684a72bf6d9c58f534aa525253030?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Will Fancher</string> &lt;willfancher38 at gmail.com&gt;<p>December 16, 2015 at 05:00:00pm</p></header><div class="content"><p>Admittedly, the majority of my reasoning for higher kinded types comes from wanting Monads to be an available abstraction. I&#39;ve been writing a lot of generic code, and finding that a lot of my types are Monads, which leads me to repeat many functions for each of these types, when those functions could be abstracted.<br></p><p>The fact is, most generic types can be Functors, and a lot of them can be Monads. Therefore, having generics at all suggests that the language will have a lot of these kinds of types. The standard library doesn&#39;t have many. Optionals and the various collection protocols make up the majority of them. So developers who can rely mostly on the standard library using concrete types probably have everything they need in this area. But creating one&#39;s own generic types will very often lead to reimplementing the same Monad / Applicative / Functor utility functions. I can&#39;t tell you how many times I&#39;ve copy-pasted my sequence function and changed only the type signature. Futures, Eithers, and Streams are three examples of types I&#39;ve been implementing as Monads, which has lead to a lot of repetition.<br></p><p>It is my personal opinion that Monads come up often enough that having proper support for them would be worthwhile. But I suppose the average Swift programmer may not run into these things as often as I do, so it makes sense that HKTs are low on the Swift team&#39;s priorities.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December 16, 2015 at 05:00:00pm</p></header><div class="content"><p>The ideal situation would involve being able to represent monad and being<br>able to type alias the behavior that that would afford us &#39;for free&#39; to<br>specific named functions methods for our specific types, I think.<br></p><p>The concrete example of a HKT&#39;s usefullness that I am after is captured<br>here with [Causal Commutative Arrows](<br>http://cs.yale.edu/c2/images/uploads/ICFP-CCA.pdf). I admit that the big<br>win has to do with the compile time optimization afforded, but I will argue<br>that the syntax&#39;s similarity to audio related pseudocode is just as big of<br>a win. [These slides](<br>http://static1.squarespace.com/static/53e04d59e4b0c0da377d20b1/t/541cb6eee4b0be37af62e23f/1411167982496/nichoiceICFP2014Presentation.pdf)<br>give a hint at what I am talking about. I agree that using &quot;Monad&quot;<br>everywhere is not generally descriptive but I think that that is simply an<br>issue of being able to document intent.<br></p><p>TJ<br></p><p>On Wed, Dec 16, 2015 at 5:11 PM, Will Fancher via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Admittedly, the majority of my reasoning for higher kinded types comes<br>&gt; from wanting Monads to be an available abstraction. I&#39;ve been writing a lot<br>&gt; of generic code, and finding that a lot of my types are Monads, which leads<br>&gt; me to repeat many functions for each of these types, when those functions<br>&gt; could be abstracted.<br>&gt;<br>&gt; The fact is, most generic types can be Functors, and a lot of them can be<br>&gt; Monads. Therefore, having generics at all suggests that the language will<br>&gt; have a lot of these kinds of types. The standard library doesn&#39;t have many.<br>&gt; Optionals and the various collection protocols make up the majority of<br>&gt; them. So developers who can rely mostly on the standard library using<br>&gt; concrete types probably have everything they need in this area. But<br>&gt; creating one&#39;s own generic types will very often lead to reimplementing the<br>&gt; same Monad / Applicative / Functor utility functions. I can&#39;t tell you how<br>&gt; many times I&#39;ve copy-pasted my sequence function and changed only the type<br>&gt; signature. Futures, Eithers, and Streams are three examples of types I&#39;ve<br>&gt; been implementing as Monads, which has lead to a lot of repetition.<br>&gt;<br>&gt; It is my personal opinion that Monads come up often enough that having<br>&gt; proper support for them would be worthwhile. But I suppose the average<br>&gt; Swift programmer may not run into these things as often as I do, so it<br>&gt; makes sense that HKTs are low on the Swift team&#39;s priorities.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/d17c63f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 16, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 2:40 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; The ideal situation would involve being able to represent monad and being able to type alias the behavior that that would afford us &#39;for free&#39; to specific named functions methods for our specific types, I think.<br>&gt; <br>&gt; The concrete example of a HKT&#39;s usefullness that I am after is captured here with [Causal Commutative Arrows](http://cs.yale.edu/c2/images/uploads/ICFP-CCA.pdf &lt;http://cs.yale.edu/c2/images/uploads/ICFP-CCA.pdf&gt;). I admit that the big win has to do with the compile time optimization afforded, but I will argue that the syntax&#39;s similarity to audio related pseudocode is just as big of a win. [These slides](http://static1.squarespace.com/static/53e04d59e4b0c0da377d20b1/t/541cb6eee4b0be37af62e23f/1411167982496/nichoiceICFP2014Presentation.pdf &lt;http://static1.squarespace.com/static/53e04d59e4b0c0da377d20b1/t/541cb6eee4b0be37af62e23f/1411167982496/nichoiceICFP2014Presentation.pdf&gt;) give a hint at what I am talking about. I agree that using &quot;Monad&quot; everywhere is not generally descriptive but I think that that is simply an issue of being able to document intent.<br></p><p>I’d just like to point out that I’ve been asking for concrete examples of how Swift programmers would benefit from higher-kinded types in their daily development, but I’ve received links to ICFP papers and lists of Haskell abstractions (Monad, Functor, Applicative) that only a type-theorist can understand. At best, this is a public-relations problem for higher-kinded types, because the vast majority of Swift developers—and also of members of this list—won’t be able to readily translate the content behind those links into “how does this improve my Swift code?” At worst, it’s a signal that this feature might not be of practical relevance to Swift, either because it solves problems Swift programmers don’t have or because it requires a thorough reading of TaPL to understand.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/2e2968a7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/16b684a72bf6d9c58f534aa525253030?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Will Fancher</string> &lt;willfancher38 at gmail.com&gt;<p>December 16, 2015 at 07:00:00pm</p></header><div class="content"><p>I mentioned several examples in passing, but I suppose I could flesh one or two out.<br></p><p>Futures are a concept used in a lot of web development frameworks as a method of asynchronously representing a value that doesn&#39;t exist, but eventually will. Naturally, you represent this with the type Future&lt;T&gt;. You make a Promise&lt;T&gt; object, then pass around and use the associated future values. Here&#39;s a very quick example code.<br></p><p>    public class Promise&lt;T&gt; {<br>        private var handlers: [T -&gt; ()] = []<br>        private var completed: T? = nil<br>        <br>        public init() {<br>        }<br>        <br>        private func onComplete(handler: T -&gt; ()) {<br>            if let completed = completed {<br>                handler(completed)<br>            } else {<br>                handlers.append(handler)<br>            }<br>        }<br>        <br>        public func complete(t: T) {<br>            completed = t<br>            for handler in handlers {<br>                handler(t)<br>            }<br>            handlers = []<br>        }<br>        <br>        public var future: Future&lt;T&gt; {<br>            return Future(promise: self)<br>        }<br>    }<br></p><p>    public struct Future&lt;T&gt; {<br>        private let promise: Promise&lt;T&gt;<br>        <br>        private init(promise: Promise&lt;T&gt;) {<br>            self.promise = promise<br>        }<br>        <br>        public func onComplete(handler: T -&gt; ()) {<br>            promise.onComplete(handler)<br>        }<br>    }<br></p><p>Using this, you can create a promise, return its future, complete that promise asynchronously, and be sure that any number of arbitrary handlers definitely get called with the completed value.<br></p><p>    let future: Future&lt;SomeType&gt; = someFutureCalculation()<br>    future.onComplete { someValue in<br>        doThing(someValue)<br>    }<br></p><p>But what about transforming those values outside of the handler, in the context where you received the future? This is where Monad, Applicative and Functor come in.<br></p><p>    // Monad<br></p><p>    public extension Future: Monad {<br>        public static func point&lt;T&gt;(t: T) -&gt; Future&lt;T&gt; {<br>            let promise = Promise&lt;T&gt;()<br>            promise.complete(t)<br>            return promise.future<br>        }<br>        <br>        public func flatMap&lt;U&gt;(f: T -&gt; Future&lt;U&gt;) -&gt; Future&lt;U&gt; {<br>            let uPromise = Promise&lt;U&gt;()<br>            <br>            onComplete { t in<br>                f(t).onComplete { u in<br>                    uPromise.complete(u)<br>                }<br>            }<br>            <br>            return uPromise.future<br>        }<br>    }<br></p><p>Now, we can do interesting manipulations like this<br></p><p>    let future: Future&lt;SomeType&gt; = someFutureCalculation()<br>    future.flatMap { someValue in<br>        return otherFutureCalc(someValue)<br>    }.onComplete { otherValue in<br>        print(otherValue)<br>    }<br></p><p>That alone is marginally useful. What&#39;s really useful is that if we have the &quot;free&quot; definitions of Functor and Applicative I described in a previous message, we can use those methods by just having implemented the Monad protocol.<br></p><p>    let future: Future&lt;String&gt; = someFutureCalculation()<br>    future.map(stringToInt).flatMap { i in<br>        return otherFuture(i)<br>    }.apply(functionFuture).onComplete { val in<br>        print(val)<br>    }<br></p><p>There&#39;s a lot going on here, and it comes from free Functor and Applicative definitions that currently aren&#39;t possible.<br></p><p>Additionally, if I have been given an array of Futures, I don&#39;t have to re-implement sequence to turn that into a Future of an array. I just get this for free.<br></p><p>    let array: [Future&lt;A&gt;] = ...<br>    let farr: Future&lt;[A]&gt; = sequence(array)<br></p><p>That&#39;s super useful.<br></p><p>Having Monads also means that if you would write code which deals with Futures, you can instead write code which deals with Monads or Functors. So this<br></p><p>    func changeFuture(future: Future&lt;String&gt;) -&gt; Future&lt;Int&gt; {<br>        return future.map { s in<br>            // create Int from s<br>        }<br>    }<br></p><p>can become this<br></p><p>    func changeSomething&lt;FString: Functor, FInt where FInt ~= FString, FInt.FunctorType == Int&gt;<br>    (functor: FString) -&gt; FInt {<br>        return functor.map { s in<br>            // create Int from s<br>        }<br>    }<br></p><p>Now, it works with anything, not just Futures.<br></p><p>The point of HKTs isn&#39;t to make a specific task easier. The point is that it makes it possible for any types which conform to a HKT protocol to use all the same functions. Thus, you can write a host of functions that operate on HKTs instead of rewriting them for specialized types. In the case of futures, I&#39;d like to remind you that this is all the code it took to make Futures capable of the countless Functor / Monad functions<br></p><p>    public extension Future: Monad {<br>        public static func point&lt;T&gt;(t: T) -&gt; Future&lt;T&gt; {<br>            let promise = Promise&lt;T&gt;()<br>            promise.complete(t)<br>            return promise.future<br>        }<br>        <br>        public func flatMap&lt;U&gt;(f: T -&gt; Future&lt;U&gt;) -&gt; Future&lt;U&gt; {<br>            let uPromise = Promise&lt;U&gt;()<br>            <br>            onComplete { t in<br>                f(t).onComplete { u in<br>                    uPromise.complete(u)<br>                }<br>            }<br>            <br>            return uPromise.future<br>        }<br>    }<br></p><p>Those few lines open up a world of possibilities on the Future type so that I can avoid boilerplate and repetition.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December 16, 2015 at 07:00:00pm</p></header><div class="content"><p>The concrete example in those links is a DSL for audio related programming.<br>I thought that I presented the point in that paragraph but I will try to<br>summarize.<br></p><p>Using Arrows, which are a specific HKT, allows us to write audio code which<br>resembles the description of certain audio operations more closely than<br>typical procedural code. This, all by itself, is a big win. Certain<br>optimizations are proven safe if we use a controlled subset of arrows.<br>These optimizations allow the code–which tends to represent many loops–to<br>be rewritten as one loop accepting a ball of coalesced state. This<br>optimized code is exceptionally fast and provides the second win.<br></p><p>TLDR, Audio signal flow code benefits greatly from specific HKT.<br></p><p>On Wed, Dec 16, 2015 at 6:49 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 16, 2015, at 2:40 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;<br>&gt; The ideal situation would involve being able to represent monad and being<br>&gt; able to type alias the behavior that that would afford us &#39;for free&#39; to<br>&gt; specific named functions methods for our specific types, I think.<br>&gt;<br>&gt; The concrete example of a HKT&#39;s usefullness that I am after is captured<br>&gt; here with [Causal Commutative Arrows](<br>&gt; http://cs.yale.edu/c2/images/uploads/ICFP-CCA.pdf). I admit that the big<br>&gt; win has to do with the compile time optimization afforded, but I will argue<br>&gt; that the syntax&#39;s similarity to audio related pseudocode is just as big of<br>&gt; a win. [These slides](<br>&gt; http://static1.squarespace.com/static/53e04d59e4b0c0da377d20b1/t/541cb6eee4b0be37af62e23f/1411167982496/nichoiceICFP2014Presentation.pdf)<br>&gt; give a hint at what I am talking about. I agree that using &quot;Monad&quot;<br>&gt; everywhere is not generally descriptive but I think that that is simply an<br>&gt; issue of being able to document intent.<br>&gt;<br>&gt;<br>&gt; I’d just like to point out that I’ve been asking for concrete examples of<br>&gt; how Swift programmers would benefit from higher-kinded types in their daily<br>&gt; development, but I’ve received links to ICFP papers and lists of Haskell<br>&gt; abstractions (Monad, Functor, Applicative) that only a type-theorist can<br>&gt; understand. At best, this is a public-relations problem for higher-kinded<br>&gt; types, because the vast majority of Swift developers—and also of members of<br>&gt; this list—won’t be able to readily translate the content behind those links<br>&gt; into “how does this improve my Swift code?” At worst, it’s a signal that<br>&gt; this feature might not be of practical relevance to Swift, either because<br>&gt; it solves problems Swift programmers don’t have or because it requires a<br>&gt; thorough reading of TaPL to understand.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/17aae816/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 09:00:00pm</p></header><div class="content"><p>Do these papers contain examples of generic use of HKTs that wouldn’t be possible with a little bit of copy and paste boilerplate?  Or do they mostly contain use of concrete types that implement some typeclasses?<br></p><p><br>&gt; On Dec 16, 2015, at 4:40 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The ideal situation would involve being able to represent monad and being able to type alias the behavior that that would afford us &#39;for free&#39; to specific named functions methods for our specific types, I think.<br>&gt; <br>&gt; The concrete example of a HKT&#39;s usefullness that I am after is captured here with [Causal Commutative Arrows](http://cs.yale.edu/c2/images/uploads/ICFP-CCA.pdf &lt;http://cs.yale.edu/c2/images/uploads/ICFP-CCA.pdf&gt;). I admit that the big win has to do with the compile time optimization afforded, but I will argue that the syntax&#39;s similarity to audio related pseudocode is just as big of a win. [These slides](http://static1.squarespace.com/static/53e04d59e4b0c0da377d20b1/t/541cb6eee4b0be37af62e23f/1411167982496/nichoiceICFP2014Presentation.pdf &lt;http://static1.squarespace.com/static/53e04d59e4b0c0da377d20b1/t/541cb6eee4b0be37af62e23f/1411167982496/nichoiceICFP2014Presentation.pdf&gt;) give a hint at what I am talking about. I agree that using &quot;Monad&quot; everywhere is not generally descriptive but I think that that is simply an issue of being able to document intent.<br>&gt; <br>&gt; TJ<br>&gt; <br>&gt; On Wed, Dec 16, 2015 at 5:11 PM, Will Fancher via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Admittedly, the majority of my reasoning for higher kinded types comes from wanting Monads to be an available abstraction. I&#39;ve been writing a lot of generic code, and finding that a lot of my types are Monads, which leads me to repeat many functions for each of these types, when those functions could be abstracted.<br>&gt; <br>&gt; The fact is, most generic types can be Functors, and a lot of them can be Monads. Therefore, having generics at all suggests that the language will have a lot of these kinds of types. The standard library doesn&#39;t have many. Optionals and the various collection protocols make up the majority of them. So developers who can rely mostly on the standard library using concrete types probably have everything they need in this area. But creating one&#39;s own generic types will very often lead to reimplementing the same Monad / Applicative / Functor utility functions. I can&#39;t tell you how many times I&#39;ve copy-pasted my sequence function and changed only the type signature. Futures, Eithers, and Streams are three examples of types I&#39;ve been implementing as Monads, which has lead to a lot of repetition.<br>&gt; <br>&gt; It is my personal opinion that Monads come up often enough that having proper support for them would be worthwhile. But I suppose the average Swift programmer may not run into these things as often as I do, so it makes sense that HKTs are low on the Swift team&#39;s priorities.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/dc355d2a/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; With higher-kinded types, one could potentially [*] produce a collection of the same kind as Self but with the element type T. So, mapping a Set produces a Set, mapping an Array produces an Array, etc. <br></p><p>I think structure preserving map is a great example and one I hope will eventually make it into the standard library someday.  I would really like to see HKTs in Swift but I agree that they are a much lower priority for day-to-day development than filling out the holes in the existing generics features.  <br></p><p>That is especially true for the majority of Swift developers who haven’t spent a lot of time studying functional programming, Haskell, reading academic papers, etc.  This stuff takes significant time and thought investment to understand and become fluent in.  Most developers will not devote the time to do that without a compelling reason.  Doug’s request for concrete examples applicable to the average Swift developer is very reasonable.<br></p><p>Will, if you have ideas for libraries you would like to write that would require HKTs to implement (beyond just saving some boilerplate in the implementation), are tractable to an average Swift developer (for some reasonable definition of average), and provide compelling advantages over alternatives please do share them!  I’m sure I would learn something useful and you might be able to make some headway towards motivating a higher priority for HKTs.<br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 16, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 4:04 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; With higher-kinded types, one could potentially [*] produce a collection of the same kind as Self but with the element type T. So, mapping a Set produces a Set, mapping an Array produces an Array, etc. <br>&gt; <br>&gt; I think structure preserving map is a great example and one I hope will eventually make it into the standard library someday.  <br></p><p>How, specifically, would you use it?  To which types would it apply, and how would the change benefit users?<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>December 16, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 4:26 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 4:04 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; With higher-kinded types, one could potentially [*] produce a collection of the same kind as Self but with the element type T. So, mapping a Set produces a Set, mapping an Array produces an Array, etc. <br>&gt;&gt; <br>&gt;&gt; I think structure preserving map is a great example and one I hope will eventually make it into the standard library someday.  <br>&gt; <br>&gt; How, specifically, would you use it?  To which types would it apply, and how would the change benefit users?<br></p><p>I think Haskell is lovely, and I’ve bookmarked the Causal Commutative Arrows paper to read for later, but I think… not at all?<br></p><p>I think the part that benefits users is the ideas behind functional programming as made explicit in the standard library. For instance, having all the structures be mappable and foldable in appropriate ways. That this may require some extra boilerplate by the people writing the library implementing that structure is too bad, but not a huge loss, because there just aren’t that many structures that we programmers will use, so the libraries to be written are fairly limited.<br></p><p>I don’t think in my day job as a Swift &amp; Obj-C programmer that I’ve ever had the desire to write code that maps and folds AND is generic in kind of structure and type over which it does so. I generally actually do care and am quite specific about whether it’s an Array or a Set, much less something less generic like a B*-Tree or AST.<br></p><p>	- Greg<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 6:26 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 4:04 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; With higher-kinded types, one could potentially [*] produce a collection of the same kind as Self but with the element type T. So, mapping a Set produces a Set, mapping an Array produces an Array, etc. <br>&gt;&gt; <br>&gt;&gt; I think structure preserving map is a great example and one I hope will eventually make it into the standard library someday.  <br>&gt; <br>&gt; How, specifically, would you use it?  To which types would it apply, and how would the change benefit users?<br></p><p>A lot of the uses don’t necessarily require HKTs as you can get a lot of mileage out of a structure preserving map with code written against the specific type.  For example, we already have structure preserving maps in the standard library for Array, Optional, and ImplicitlyUnwrappedOptional.  <br></p><p>It would be nice if Set and Dictionary also had a structure preserving map today (mapping over values in the dictionary leaving the keys untouched).  I have seen people pick on Set a bit in regards to this because it can&#39;t conform the the usual functor laws so I’ll offer an example of using it there.  Imagine we have a set of people and we want to know the set of dates where at least one person has a birthday (maybe to provide an indicator in a UI).  Structure preserving map is exactly what we need and is quite useful even when the semantics are a bit less strict than the mathematical / categorical definition of a Functor.<br></p><p>I think it’s fair to say that types which *implement* the usual HKT typeclasses / protocols are extremely useful when used in a concrete setting.  Even if you can’t express the protocol or conformance directly in the language the concepts and signatures are valuable as a pattern.<br></p><p>Of course in a thread about HKTs I’m sure you’re looking for examples where the code needs to be generic over the structure.  The most common examples I can think of are “do notation” as well as various methods of effect handling and effect composition.  Swift is clearly taking a different (and better IMO) approach to effects at the language level.  <br></p><p>However it doesn’t (yet anyway) offer all of the control over effects that could be useful.  This may be an area where HKTs would be useful although I don’t have a concrete example ready at hand.  I have been thinking about and experimenting with some architectural ideas for managing (iOS) application state, data flow, event flow, etc using inspiration from reader, writer, state, and continuation monads.  I may eventually find examples here, although it is also quite possible that generic use of HKTs won&#39;t really necessary.  It’s hard to say for sure as I haven’t spent enough time on this yet.<br></p><p>So I suppose where I land is that I know the patterns that can only be expressed in a language by HKTs are very useful and practical.  The Swift library already implements these patterns in some areas and they are widely useful.  The library should be consistent in application of the HKT patterns it implements (such as structure preserving map).  <br></p><p>Because it is possible (theoretically) to express the patterns directly in the language it makes sense to eventually be able to do that.  If / when that happens all the library would need to do is declare the corresponding protocols and conformances to enable them to be used generically.<br></p><p>I have an intuition that practical uses for Swift programmers (especially library implementers) would emerge but are hard to find without experimentation and experience.  Because we cannot actually use them today we don’t spend too much time thinking about how to apply them in our immediate context so it’s a bit of a catch-22.  Of course this is a pretty weak argument which is why I am in strong agreement that this is not an immediate or high priority.  But I do hope we have the chance to experiment and find practical uses for HKTs in Swift someday.<br></p><p>Matthew<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 16, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 1:34 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; With higher-kinded types, one could potentially [*] produce a collection of the same kind as Self but with the element type T. So, mapping a Set produces a Set, mapping an Array produces an Array, etc. <br></p><p>Yeah, but Set can’t follow the functor laws, so that map won’t apply to it.  That’s why, while I agree that this kind of constraint is helpful and important for completing the generics picture, IMO it is probably less helpful/important than many people think.<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/16b684a72bf6d9c58f534aa525253030?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Will Fancher</string> &lt;willfancher38 at gmail.com&gt;<p>December 16, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; while I agree that this kind of constraint is helpful and important for completing the generics picture, IMO it is probably less helpful/important than many people think.<br></p><p>While I would love to see HKTs in Swift as soon as possible, and I personally would really appreciate a good Monad setup, I have to say I agree with this. It&#39;d be great to have, but it&#39;s not as important as anything else on Swift 3&#39;s todo list.<br></p><p>So this brings me to a question: If the community were to write HKTs into the language and submit a pull request, what is the likelihood that it would be accepted, despite the fact that the Swift team feels it is out of scope for their own Swift 3 efforts?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 17, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 5:18 PM, Will Fancher &lt;willfancher38 at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; while I agree that this kind of constraint is helpful and important for completing the generics picture, IMO it is probably less helpful/important than many people think.<br>&gt; <br>&gt; While I would love to see HKTs in Swift as soon as possible, and I personally would really appreciate a good Monad setup, I have to say I agree with this. It&#39;d be great to have, but it&#39;s not as important as anything else on Swift 3&#39;s todo list.<br>&gt; <br>&gt; So this brings me to a question: If the community were to write HKTs into the language and submit a pull request, what is the likelihood that it would be accepted, despite the fact that the Swift team feels it is out of scope for their own Swift 3 efforts?<br></p><p><br>If the Swift core team decides that a feature is out of scope for Swift 3, the proposal will be deferred and will not come up for a public review. Discussion, design, and even out-of-tree implementation can proceed, but you can expect that the core team won’t be deeply involved because they have to focus on making Swift 3 happen.<br></p><p>One natural question that pops out of this is, “what if the feature was effectively ‘perfect’, with a detailed design proposal, complete implementation, updated standard library, examples showing how other external projects could benefit from this feature, etc?” Even then, the time it takes to carefully review a design—especially one as wide-ranging as higher-kinded types—for its interactions with the rest of the language, runtime, standard library, and Swift ecosystem is significant, and we’ve found that in many cases our time is more constrained by design review than it is even by implementation concerns.<br></p><p>	- Doug<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 16, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 5:10 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 1:34 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; With higher-kinded types, one could potentially [*] produce a collection of the same kind as Self but with the element type T. So, mapping a Set produces a Set, mapping an Array produces an Array, etc. <br>&gt; <br>&gt; Yeah, but Set can’t follow the functor laws, so that map won’t apply to it.  That’s why, while I agree that this kind of constraint is helpful and important for completing the generics picture, IMO it is probably less helpful/important than many people think.<br></p><p>Looking beyond functional programming abstractions, higher-kinded types are a fancy way of saying &quot;template template parameters&quot;. A textbook motivation for those from C++ land is Andrei Alexandrescu&#39;s &quot;policy pattern&quot;, stuff like this:<br></p><p>protocol RefStoragePolicy: &lt;*: class&gt; {<br>  typealias Ref: class<br>  init(ref: Ref)<br>  var ref: Ref<br>}<br></p><p>struct Weak&lt;T: class&gt;: RefStoragePolicy { weak var ref: T }<br>struct Unowned&lt;T: class&gt;: RefStoragePolicy { unowned var ref: T }<br>struct Strong&lt;T: class&gt;: RefStoragePolicy { var ref: T }<br></p><p>class HeterogeneousRefConsumer&lt;Storage: RefStoragePolicy&gt; {<br>  func consumeRef&lt;T: class&gt;(ref: T) {<br>    let storage = Storage&lt;T&gt;(ref: ref)<br>    doStuffWith(storage)<br>  }<br>}<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; Looking beyond functional programming abstractions, higher-kinded types are a fancy way of saying &quot;template template parameters”.<br></p><p>Thanks for bringing that up.  I almost mentioned it.  I didn’t because I know the Swift team wants to avoid a lot of what has been done with templates and am not sure exactly where you draw the line.  :)<br></p><p>&gt; A textbook motivation for those from C++ land is Andrei Alexandrescu&#39;s &quot;policy pattern&quot;, stuff like this:<br>&gt; <br>&gt; protocol RefStoragePolicy: &lt;*: class&gt; {<br>&gt;  typealias Ref: class<br>&gt;  init(ref: Ref)<br>&gt;  var ref: Ref<br>&gt; }<br>&gt; <br>&gt; struct Weak&lt;T: class&gt;: RefStoragePolicy { weak var ref: T }<br>&gt; struct Unowned&lt;T: class&gt;: RefStoragePolicy { unowned var ref: T }<br>&gt; struct Strong&lt;T: class&gt;: RefStoragePolicy { var ref: T }<br>&gt; <br>&gt; class HeterogeneousRefConsumer&lt;Storage: RefStoragePolicy&gt; {<br>&gt;  func consumeRef&lt;T: class&gt;(ref: T) {<br>&gt;    let storage = Storage&lt;T&gt;(ref: ref)<br>&gt;    doStuffWith(storage)<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>December 17, 2015 at 09:00:00am</p></header><div class="content"><p>I&#39;ve been bumping into (what I&#39;ve found out to be) the need for HKT a lot<br>while trying to write highly composable yet optimizable code for<br>exploratory image (and audio (and video)) processing.<br></p><p>Using Core Image, vImage, vDSP, Metal, etc. directly is not an option here,<br>since they are much too low level / specialized / non-composable. What I&#39;m<br>writing is a system that will let me try out new ideas very quickly by<br>reusing as much code and concepts as possible. Ie I don&#39;t want to write<br>specialized code for every slight variant of a concept. So a separable<br>convolution should be _one_ generic implementation, and the compiler (not<br>the programmer) should take care of specializing it for any given value<br>type and dimensionality, same thing with positions, a position in space is<br>no different from a position in a color space or a position in space&amp;time,<br>so they should share a common implementation. I need it to be as<br>optimizable as possible, because it would be unusable even for just<br>experimentation otherwise. If something needs to get faster still, we can<br>then write a Metal version of it.<br></p><p>With the latest improvements in the optimizer (esp. loop unrolling) I have<br>managed to get the basics of this working, the compiler will generate SIMD<br>code from my high level code constructs (when possible of course, eg when<br>doing separable convolution (in any number of dimensions) and the<br>components are 4 or 4x4 Floats etc).<br></p><p>But I currently have to jump through hoops in order to write simple things<br>like &quot;static array types&quot; with type-level count and specific memory<br>footprint. I&#39;m using Peano-esque natural-numbers-as-types for the Count,<br>and a similar nested-structs-thing to get the proper storage of Count x<br>Element. But it is impossible to parameterize them for both Count and<br>Element, so I have to do eg this:<br></p><p>typealias MyFloat4 = StaticArrayOf&lt;Float&gt;.WithCount4<br></p><p>instead of the more straight forward:<br></p><p>typealias MyFloat4 = StaticArray&lt;Float, Count4&gt;<br></p><p>So I wish it was possible to implement it like this:<br>struct StaticArray&lt;Element, Count&gt; { ... }<br>where<br>strideof(StaticArray&lt;Float, Count4&gt;) == 4 * strideof(Float) ==<br>strideof(float4)<br></p><p>But I&#39;ve given up and accepted that such parameterization is not possible<br>without HKT.<br></p><p>Perhaps it would become possible with the proposed generic typealiases, at<br>least if that implied generic associated types (which I guess would be the<br>same as HKT?).<br></p><p>Anyway, I&#39;m very impressed by (open source master) Swift&#39;s ability to<br>optimize very high level generic code. I just wish some of my abstractions<br>could be written in a more straight forward way. I think HKT would make<br>them simpler. (Sorry for not being more specific).<br></p><p>/Jens<br></p><p><br></p><p>On Thu, Dec 17, 2015 at 6:22 AM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Looking beyond functional programming abstractions, higher-kinded types<br>&gt; are a fancy way of saying &quot;template template parameters”.<br>&gt;<br>&gt; Thanks for bringing that up.  I almost mentioned it.  I didn’t because I<br>&gt; know the Swift team wants to avoid a lot of what has been done with<br>&gt; templates and am not sure exactly where you draw the line.  :)<br>&gt;<br>&gt; &gt; A textbook motivation for those from C++ land is Andrei Alexandrescu&#39;s<br>&gt; &quot;policy pattern&quot;, stuff like this:<br>&gt; &gt;<br>&gt; &gt; protocol RefStoragePolicy: &lt;*: class&gt; {<br>&gt; &gt;  typealias Ref: class<br>&gt; &gt;  init(ref: Ref)<br>&gt; &gt;  var ref: Ref<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; struct Weak&lt;T: class&gt;: RefStoragePolicy { weak var ref: T }<br>&gt; &gt; struct Unowned&lt;T: class&gt;: RefStoragePolicy { unowned var ref: T }<br>&gt; &gt; struct Strong&lt;T: class&gt;: RefStoragePolicy { var ref: T }<br>&gt; &gt;<br>&gt; &gt; class HeterogeneousRefConsumer&lt;Storage: RefStoragePolicy&gt; {<br>&gt; &gt;  func consumeRef&lt;T: class&gt;(ref: T) {<br>&gt; &gt;    let storage = Storage&lt;T&gt;(ref: ref)<br>&gt; &gt;    doStuffWith(storage)<br>&gt; &gt;  }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/c5a535e8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 16, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 1:10 PM, Will Fancher &lt;willfancher38 at gmail.com&gt; wrote:<br>&gt; <br>&gt; With respect specifically to Monads, there are numerous useful abstractions. For one, Applicative and Functor can be derived for free, <br></p><p>This is the “other than implementing the basic HKTs themselves” case I was specifically trying to exclude.  The fact that I can build HKTs on HKTs is not relevant to the question of the usefulness of HKTs for solving the real problems of Swift programmers.<br></p><p>&gt; requiring the no effort on the Monad instance&#39;s part. This alone eliminates a lot of code repetition. Additionally, the large majority of functions described for Haskell here are very useful:<br>&gt; <br>&gt; https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html.<br>&gt; <br>&gt; Those functions come as abstractions over monads which can be easily understood (if you understand monads) and which eliminate a lot of code repetition.<br></p><p>I have spent significant hours of my life studying and working with Haskell, Monads, et al., and I still don’t think  these abstractions are “easily understood.”  For example, mapM: &quot;Map each element of a structure to a monadic action, evaluate these actions from left to right, and collect the results.”  <br></p><p>It raises these questions.  Understand please that I’m not asking for the answers to the questions; I know them already (or how to discover them if I want to).  The answers are never either easy or crisp, in my experience.<br></p><p>• What does “element of a structure” mean for an arbitrary monad?  Take the I/O monad for example.  What structure?!<br>• What is a “monadic action?”  In fact, how can we even talk about “action,” which is a very imperative idea, in a purely-functional context?<br>• What does “collect the results” mean?<br></p><p>In general, the meaning each of these phrases depends on the specific monad since there is no common semantic basis for the Monad abstraction (other than its laws), only a structural one.  That makes the whole exercise of understanding what a Monad is, what it’s for, and what these functions like mapM mean, a highly circular one.<br></p><p>&gt; The existence of these abstractions makes any Monad type much more robust that it would be on its own.<br>&gt; <br>&gt; There are plenty of typeclasses in Haskell that could be implemented in Swift and would be useful if we had HKTs. Foldables and Traversables, for example, are simple and powerful abstractions that would be well worth having.<br></p><p>What problems would these solve for our users?<br></p><p>&gt; And there are various simpler things besides Haskell typeclasses that can&#39;t be done in Swift as it stands. For example, you can&#39;t currently take a collection of type C1: CollectionType, and return a value of type C2 where C2 ~= C1, which means you can&#39;t perform arbitrary transformations on arbitrary collections. You have to choose an implementation type and use that one.<br></p><p>Yes, it would be nice to be able to represent that constraint, and that’s an HKT thing.  <br></p><p>&gt; This isn&#39;t to say this should all be in the standard library. I think most of these protocols would be best off in a separate package, to keep the standard simple for newcomers and for those who don&#39;t need these features.<br></p><p>Mmm, I don’t know.  Do you want the map that comes from CollectionType, or the one array will get from its conformance to Monad, which will only be in an extension you load with a separate package?  Shouldn&#39;t every CollectionType be a Functor?  I haven’t thought this through deeply but I’d be surprised if it these abstractions can be useful without also being woven into the foundations of the library.<br></p><p>&gt; So I&#39;m not suggesting that the Swift team create Monad, Functor, etc. in the standard library and then extend all the appropriate types to implement those (although it&#39;d be a bonus if the team wanted to). That job would be up to whoever wants to write the package for it. But, in my opinion, the ability for such a package to exist seems very important.<br></p><p>If it’s truly important and general-purpose, I would have no problem putting it in the standard library.  My concern is that it may not be important enough, to enough people, to warrant the attendant language complication.<br></p><p>-Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 17, 2015 at 05:00:00pm</p></header><div class="content"><p>A tentative -1, based on the following two personal opinions:<br></p><p>First, I consider myself a smart person with a very broad experience with non-functional languages, but reading this makes my mind hurt, a lot:<br></p><p>&gt;    typeclass Functor f where<br>&gt;        fmap :: (a -&gt; b) -&gt; f a -&gt; f b<br>&lt;snip&gt;<br>&gt; This makes it possible to build functions which operate not just on Maybe, but on any Functor.<br>&gt; <br>&gt;    fstrlen :: Functor f =&gt; f String -&gt; f Int<br>&gt;    fstrlen fstr = fmap length faster<br>&lt;snip&gt;<br>&gt;    protocol Functor {<br>&gt;        typealias A<br>&gt;        func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt;    }<br></p><p>I understand what&#39;s going on here, but I never, ever want to see this code anywhere near (my) Swift.<br></p><p><br>Second, I consider this an anti-pattern:<br></p><p>&gt; func sayHello(name: Optional&lt;String&gt;) -&gt; Optional&lt;String&gt; {<br>&gt; func sayHello(name: Array&lt;String&gt;) -&gt; Array&lt;String&gt; {<br>&gt; It doesn’t use the usual syntax sugar for Optionals and Array, to make it clear that the only difference between the 2 functions is the type signature. If were possible to express the concept of a Functor, we could write one function that would accept both Optionals and Arrays as parameters – and not just those 2, but any Functor (Result, Future, Signal…).<br></p><p>Optional.map and Array.map do different things, and unifying them seems harmful.<br></p><p><br>I&#39;m yet to see a compelling case where monads are useful either, for a real job (and not as a workaround for the idiosyncrasies of the type system).<br></p><p><br>I believe the way to convince the rest of us (and I would love to be convinced) is to provide a few real, “end-user” app-level use cases and explain the benefit in plain language. In particular, I don&#39;t understand the example by Jens Persson, although it seems like a valuable one.<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/ccb3dc92/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: open.gif<br>Type: image/gif<br>Size: 43 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/ccb3dc92/attachment.gif&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 17, 2015 at 03:00:00am</p></header><div class="content"><p>&gt; Optional.map and Array.map do different things, and unifying them seems harmful.<br></p><p>They actually don’t do different things. Optional can be thought of as an array of zero or one elements; from that point of view, operations like `map` and `flatMap` which are supported on both actually do the same thing.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 17, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt;&gt; Optional.map and Array.map do different things, and unifying them seems harmful.<br>&gt; <br>&gt; They actually don’t do different things. Optional can be thought of as an array of zero or one elements; from that point of view, operations like `map` and `flatMap` which are supported on both actually do the same thing.<br></p><p>I understand that reasoning, but it&#39;s completely contrary to how I (and presumably many other people) normally think. To me, optional is not a 0..1 array, it&#39;s just an optional. I don&#39;t want a flatMap on optionals (which, I believe, was thankfully removed in Swift 2).<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December 17, 2015 at 11:00:00am</p></header><div class="content"><p>&gt;&gt;&gt; Optional.map and Array.map do different things, and unifying them seems harmful.<br>&gt;&gt; <br>&gt;&gt; They actually don’t do different things. Optional can be thought of as an array of zero or one elements; from that point of view, operations like `map` and `flatMap` which are supported on both actually do the same thing.<br>&gt; <br>&gt; I understand that reasoning, but it&#39;s completely contrary to how I (and presumably many other people) normally think. To me, optional is not a 0..1 array, it&#39;s just an optional.<br></p><p>&gt; I don&#39;t want a flatMap on optionals (which, I believe, was thankfully removed in Swift 2).<br></p><p>Thankfully it lives : )<br></p><p>// useless function: return arg if less than 10, otherwise .None<br>func f(x:Int) -&gt; Int? {<br>  return x &lt; 10 ? x : .None<br>}<br></p><p>Int(&quot;9&quot;).map(f) // .Some(.Some(9))<br>Int(&quot;9&quot;).flatMap(f) // .Some(9)<br></p><p>Int(&quot;10&quot;).map(f) // .Some(.None)<br>Int(&quot;10&quot;).flatMap(f) // .None<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/ae64919b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/16b684a72bf6d9c58f534aa525253030?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Will Fancher</string> &lt;willfancher38 at gmail.com&gt;<p>December 17, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; Optional.map and Array.map do different things, and unifying them seems harmful.<br></p><p>In terms of category theory, they&#39;re not different. They are both arrows from a to b in the Functor category. Obviously that&#39;s horribly abstract, so I&#39;ll put it this way: If you think of these map functions not as operations on Optional and Array, and instead think of them simply as ways to compose an arbitrary data structure, they are in fact doing the same thing. On an implementation level, and on a runtime level, they perform differently. But on a type level, a theoretical level, and a categorical level, they are the same. You merely need to accept that when using this abstraction without knowledge of the concrete type, you have no reason to make any assumptions about how the implementation and runtime will behave. At that point, all you need is to be sure that the Functor being passed in abides by the Functor laws, and that&#39;s just a matter of convention.<br></p><p>&gt; First, I consider myself a smart person with a very broad experience with non-functional languages, but reading this makes my mind hurt, a lot:<br>&gt; <br>&gt;&gt;    typeclass Functor f where<br>&gt;&gt;        fmap :: (a -&gt; b) -&gt; f a -&gt; f b<br>&gt; &lt;snip&gt;<br>&gt;&gt; This makes it possible to build functions which operate not just on Maybe, but on any Functor.<br>&gt;&gt; <br>&gt;&gt;    fstrlen :: Functor f =&gt; f String -&gt; f Int<br>&gt;&gt;    fstrlen fstr = fmap length faster<br>&gt; &lt;snip&gt;<br>&gt;&gt;    protocol Functor {<br>&gt;&gt;        typealias A<br>&gt;&gt;        func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt;&gt;    }<br>&gt; <br>&gt; I understand what&#39;s going on here, but I never, ever want to see this code anywhere near (my) Swift.<br></p><p>HKTs that come from category theory tend to have this effect. They are hard to understand by reading the protocol definition. Admittedly, this is a big flaw with Monads and with Haskell. It takes a reasonable understanding of category theory for the purpose of this code to be obvious to the reader.<br></p><p>(I will point out that in those code examples, I used absolutely abysmal naming conventions. It could be made marginally more readable and understandable if the naming were better)<br></p><p>I&#39;ll take this time to make the point that just because you don&#39;t like the way the Functor protocol looks, doesn&#39;t mean Array and Optional aren&#39;t both Functors and Monads. As a matter of mathematics, if the Monad functions can exist on a type, and they would follow the Monad laws, that type is a Monad whether the implementor likes it or not. Of course it still needs manual implementing, but regardless, the type is theoretically a Monad. (This realization is the reason that the Java team decided to implement flatMap for Java 8&#39;s Optional class.)<br></p><p>&gt; I believe the way to convince the rest of us (and I would love to be convinced) is to provide a few real, “end-user” app-level use cases and explain the benefit in plain language. In particular, I don&#39;t understand the example by Jens Persson, although it seems like a valuable one.<br></p><p>I can (again) link to just a few of the abstract Monadic functions, all of which are very useful in practical applications.<br></p><p>https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html &lt;https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html&gt;<br></p><p>But perhaps it would also help to describe the architectural decisions that abiding by Monad imposes.<br></p><p>Being Monadic makes you think about data composition, which cleans up the way you design your code. Going back to the Futures example, I could implement future, and subsequently use it, like this:<br></p><p>    public class Promise&lt;T&gt; {<br>        private var handlers: [T -&gt; ()] = []<br>        private var completed: T? = nil<br>        <br>        public init() {<br>        }<br>        <br>        private func onComplete(handler: T -&gt; ()) {<br>            if let completed = completed {<br>                handler(completed)<br>            } else {<br>                handlers.append(handler)<br>            }<br>        }<br>        <br>        public func complete(t: T) {<br>            completed = t<br>            for handler in handlers {<br>                handler(t)<br>            }<br>            handlers = []<br>        }<br>        <br>        public var future: Future&lt;T&gt; {<br>            return Future(promise: self)<br>        }<br>    }<br></p><p>    public struct Future&lt;T&gt; {<br>        private let promise: Promise&lt;T&gt;<br>        <br>        private init(promise: Promise&lt;T&gt;) {<br>            self.promise = promise<br>        }<br>        <br>        public func onComplete(handler: T -&gt; ()) {<br>            promise.onComplete(handler)<br>        }<br>    }<br></p><p>    public func useFutures() {<br>        downloadURLInFuture().onComplete { content in<br>            processContentAsync(content).onComplete { processed in<br>                processed.calculateSomethingAsync().onComplete {<br>                    ...<br>                        ...<br>                            print(finalProduct)<br>                        ...<br>                    ...<br>                }<br>            }<br>        }<br>    }<br></p><p>You can see how this resembles the infamous Node.js issue of callback hell, and how the nesting could quickly get out of hand. If only we had some form of composition... Arrows between Futures... Luckily, Future is a Monad (whether I like it or not!)<br></p><p>    // Monad<br></p><p>    public extension Future {<br>        public static func point&lt;T&gt;(t: T) -&gt; Future&lt;T&gt; {<br>            let promise = Promise&lt;T&gt;()<br>            promise.complete(t)<br>            return promise.future<br>        }<br>        <br>        public func flatMap&lt;U&gt;(f: T -&gt; Future&lt;U&gt;) -&gt; Future&lt;U&gt; {<br>            let uPromise = Promise&lt;U&gt;()<br>            <br>            onComplete { t in<br>                f(t).onComplete { u in<br>                    uPromise.complete(u)<br>                }<br>            }<br>            <br>            return uPromise.future<br>        }<br>    }<br></p><p>Not only do I now get map and apply for free, but I also get a great method of composing Futures. The example from above can now be rewritten to be much more well composed.<br></p><p>    public func useFutures() {<br>        downloadURLInFuture()<br>            .flatMap(processContentAsync)<br>            .flatMap { $0.calculateSomethingAsync() }<br>            ...<br>            .onComplete { finalProduct in<br>                print(finalProduct)<br>            }<br>    }<br></p><p>The important thing here is that thinking about Monads helped me discover a better composition model. Now my code can be more readable and well composed.<br></p><p>And again, I&#39;ll mention the enormous world of functions and capabilities that can be gotten for free for the sake of even more well-composed code.<br></p><p>&gt; I don&#39;t want a flatMap on optionals (which, I believe, was thankfully removed in Swift 2).<br></p><p>And why on Earth not? The concrete implementation of it on Optional is very simple and easy to understand, and the method is incredibly useful. Personally, I use it all the time (it was not removed). And again, just because you don&#39;t like using flatMap doesn&#39;t mean Optional isn&#39;t a Monad.<br></p><p>Finally, I&#39;d like to point out that it doesn&#39;t hurt any end users not familiar with Monads if Array implements a higher kinded Monad protocol. As far as they have to be concerned, Array just has these useful map and flatMap functions. Meanwhile, those of us who wish to abstract over Monads in general can write our abstract code and implement Monad on our various types which mathematically have to be Monads. It&#39;s a layer of robustness and improvement that unconcerned end users don&#39;t have to bother themselves with.<br></p><p>While I understand that the Swift team doesn&#39;t have the resources to implement everything that everyone wants, and that HKTs aren&#39;t very high on their list of priorities, it seems unreasonable to me that one could think of HKTs and Monads as somehow detrimental to the language.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/6d20a1c9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/16b684a72bf6d9c58f534aa525253030?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Will Fancher</string> &lt;willfancher38 at gmail.com&gt;<p>December 17, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; As long as the underlying theory is not widely adopted, I think HKTs should be provided by third-party libraries (like swiftz).<br></p><p>I wholeheartedly agree that protocols like Monad and Functor shouldn&#39;t be in the standard library. I really think they need their own external package.<br></p><p>But HKTs can&#39;t be provided by third party libraries! HKTs are a language level feature! HKTs aren&#39;t a collection of types we wish were implemented. HKTs are the language level construct that allows for generic types to be re-parameterized. An HKT proposal would NOT insist that Monad and co. be written into the standard library. It would simply insist that HKTs become physically possible, which they currently are not.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2ff1daab58cd5e44a457908d1905c322?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Krzysztof Siejkowski</string> &lt;krzysztof at siejkowski.net&gt;<p>December 17, 2015 at 01:00:00pm</p></header><div class="content"><p>Oh, thanks for clarification, I misunderstood you at first. If the proposal is about improving the type system so that HKTs are expressible (or more easily expressible) than I definitely support it :)<br></p><p><br>On 17 December 2015 at 13:16:39, Will Fancher (willfancher38 at gmail.com) wrote:<br></p><p>&gt; As long as the underlying theory is not widely adopted, I think HKTs should be provided by third-party libraries (like swiftz). <br></p><p>I wholeheartedly agree that protocols like Monad and Functor shouldn&#39;t be in the standard library. I really think they need their own external package. <br></p><p>But HKTs can&#39;t be provided by third party libraries! HKTs are a language level feature! HKTs aren&#39;t a collection of types we wish were implemented. HKTs are the language level construct that allows for generic types to be re-parameterized. An HKT proposal would NOT insist that Monad and co. be written into the standard library. It would simply insist that HKTs become physically possible, which they currently are not.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/671a0fb0/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 17, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; That’s why, when I wrote a Result type, I didn’t give it `map` and `flatMap` operations; I called them `convert` and `then`, to at least try to give some indication of what they actually mean in your code.<br></p><p>Now we&#39;re talking.<br></p><p>The stupid names are my biggest beef with FP. (The second biggest one is having to deal with mundane details of something outside of the problem domain.)<br></p><p>This, for example:<br></p><p>&gt;     public func useFutures() {<br>&gt;         downloadURLInFuture()<br>&gt;             .flatMap(processContentAsync)<br>&gt;             .flatMap { $0.calculateSomethingAsync() }<br>&gt;             ...<br>&gt;             .onComplete { finalProduct in<br>&gt;                 print(finalProduct)<br>&gt;             }<br>&gt;     }<br></p><p>should use &#39;then&#39; or &#39;after&#39; or whatever.<br></p><p>Yes, I can understand that FP is powerful because you get some operation implementations for free (and you can have entire libraries of things that compose well). At the same time, the end result is, to me, subpar, because instead of domain-specific operations you&#39;re now using generic ones.<br></p><p>I don&#39;t want Swift to encourage this style; I don&#39;t want the most common promises library to use flatMap instead of then, just because Swift give them tools to do it more easily. The prevalence of those stupid operations in Rx-style libraries is already bad enough.<br></p><p>&gt; It’s my understanding that these unruly double-Optionals are required in various parts of the Swift library. In particular with generators – a generator knows it’s got to the end when it encounters nil (.None). If it were only possible to have one level of Optional it would be impossible to enumerate an Array of Optionals. For example<br>&gt; <br>&gt; [1,2,nil,4,5]<br>&gt; <br>&gt; Without the ability to represent .Some(nil), the generator would reach the end after ‘2’ in the Array and would never get to ‘4’, ‘5’.<br></p><p>This, by the way, is the inherent conflict between the generic, metaprogramming-enabling language and an applications language. I want the distinction in generic code, but I don&#39;t really want that distinction in my normal code.<br></p><p>I&#39;m concerned that the more meta stuff we add, the more profound this effect will be.<br></p><p>But if you guys promise to not apply the crazy FP stuff to every single computing task, I&#39;m ready to vote neutral. (This voting is meaningless, of course, because we&#39;re likely more than a year away from considering these changes seriously.)<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 17, 2015 at 07:00:00pm</p></header><div class="content"><p>...But I really do believe that this proposal needs a good list of very specific real-world use cases where FP enables something that isn&#39;t easily enabled otherwise.<br></p><p>The Future example could just implement it&#39;s own flatMap with a better name, so I don&#39;t see it as being a valid case. The image processing example is still unclear. I&#39;m sure we can find 5 cases where FP really makes the code much smaller or easier to understand?<br></p><p>A.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/16b684a72bf6d9c58f534aa525253030?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Will Fancher</string> &lt;willfancher38 at gmail.com&gt;<p>December 17, 2015 at 08:00:00am</p></header><div class="content"><p>I do think that the use case of HKTs is limited mostly to those of us who really want to use Monads and the like. HKTs are a feature that I think round out Swift&#39;s generics&#39; completeness, but the main application would be some niche third party packages that have various FP programming elements. If those libraries take off and become mainstream Swift, that&#39;s a sign that those libraries are a good thing to begin with. Otherwise, I doubt the horrible naming conventions of FP (and they are horrible) would be invasive to the Swift language as a whole.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 17, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; I do think that the use case of HKTs is limited mostly to those of us who really want to use Monads and the like. HKTs are a feature that I think round out Swift&#39;s generics&#39; completeness, but the main application would be some niche third party packages that have various FP programming elements. If those libraries take off and become mainstream Swift, that&#39;s a sign that those libraries are a good thing to begin with. Otherwise, I doubt the horrible naming conventions of FP (and they are horrible) would be invasive to the Swift language as a whole.<br></p><p><br>Yes, but to consider including this into the language, surely we can imagine (at the client code level) specifics of several libraries/niches that are enabled by HKTs?<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/16b684a72bf6d9c58f534aa525253030?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Will Fancher</string> &lt;willfancher38 at gmail.com&gt;<p>December 17, 2015 at 08:00:00am</p></header><div class="content"><p>I&#39;m not sure I follow? Are you suggesting that having HKTs at all will encourage Swift programmers to use bad naming conventions? I don&#39;t think the two are related unless you&#39;re talking about people using a Monad library, in which case it will be the Monad library using and encouraging bad naming conventions, not HKTs themselves.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>December 17, 2015 at 03:00:00pm</p></header><div class="content"><p>This is directed to the thread/discussion in general, not any specific<br>person: I think it was said before but it is probably worth<br>repeating: Whether the type system should allow HKT or not doesn&#39;t<br>necessarily have anything to do with the names and data structures of<br>the stdlib.<br></p><p>For example, a Mappable protocol (let&#39;s call it that rather<br>than Functor) is currently not even _possible_ to write, and I believe this<br>is the question to consider, i.e. whether Swift&#39;s type system should be<br>allowed to express types that are parameterized not only by concrete types<br>but also by parameterized types, for example if a return type could<br>be Self&lt;T&gt; or just Self.<br></p><p>It would be sad if the question about HKT turned into yet another fruitless<br>and meaningless functional vs imperative debate (see the talk *-Oriented<br>Programming by Graham Lee).<br></p><p>/Jens<br></p><p>On Thursday, December 17, 2015, Will Fancher via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;m not sure I follow? Are you suggesting that having HKTs at all will<br>&gt; encourage Swift programmers to use bad naming conventions? I don&#39;t think<br>&gt; the two are related unless you&#39;re talking about people using a Monad<br>&gt; library, in which case it will be the Monad library using and encouraging<br>&gt; bad naming conventions, not HKTs themselves.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/1dc06b8a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2ff1daab58cd5e44a457908d1905c322?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Krzysztof Siejkowski</string> &lt;krzysztof at siejkowski.net&gt;<p>December 17, 2015 at 03:00:00pm</p></header><div class="content"><p>This is directed to the thread/discussion in general, not any specific person: I think it was said before but it is probably worth repeating: Whether the type system should allow HKT or not doesn&#39;t necessarily have anything to do with the names and data structures of the stdlib.<br></p><p><br>Well said! Could we steer the discussion in the right direction by identifying what exact features of type system are needed?<br></p><p><br></p><p>Some questions that come to mind:<br></p><p>1) Do we need ability to express covariance and contravariance of generic types?<br></p><p>2) Do we need a better mechanism for ad-hoc polymorphism, similar to Haskell&#39;s typeclasses?<br></p><p>3) How should type constraints (`where` clause) be extended?<br></p><p><br></p><p>Some of those questions are already discussed in other threads, so it’s mainly a matter of ensuring that the upcoming proposals are powerful enough.<br></p><p><br>Krzysztof<br></p><p><br></p><p><br></p><p>For example, a Mappable protocol (let&#39;s call it that rather than Functor) is currently not even _possible_ to write, and I believe this is the question to consider, i.e. whether Swift&#39;s type system should be allowed to express types that are parameterized not only by concrete types but also by parameterized types, for example if a return type could be Self&lt;T&gt; or just Self.<br></p><p>It would be sad if the question about HKT turned into yet another fruitless and meaningless functional vs imperative debate (see the talk *-Oriented Programming by Graham Lee).<br></p><p>/Jens<br></p><p>On Thursday, December 17, 2015, Will Fancher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>I&#39;m not sure I follow? Are you suggesting that having HKTs at all will encourage Swift programmers to use bad naming conventions? I don&#39;t think the two are related unless you&#39;re talking about people using a Monad library, in which case it will be the Monad library using and encouraging bad naming conventions, not HKTs themselves.<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>--<br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br></p><p><br> _______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/c87d61b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 18, 2015 at 02:00:00am</p></header><div class="content"><p>There&#39;s a lot of passionate Swift people here, it&#39;s great to see, and I<br>think with some clarification we could reach a consensus.<br></p><p>Lots of interesting discussion here for different proposals:<br> * Supporting Monads, Functors in the Standard Library<br> * Renaming flatMap, map, etc. ...<br></p><p>I think the second would be really interesting as a separate discussion in<br>another proposal (ie. map/reduce is probably Term of Art<br>https://swift.org/documentation/api-design-guidelines.html).<br></p><p>The current proposal is, to paraphrase:<br> * A more expressive type system through more flexible generics (HKT)<br></p><p>I want Swift and the Standard Library to be clean, consistent, expressive,<br>safe, and approachable. I believe that HKTs are a necessary step to achieve<br>all of these things.<br></p><p>Going back over the posts, for those talking about the proposal, this seems<br>to be the votes so far:<br></p><p>*Clear Votes for/against HKTs:*<br></p><p>   - Will Fancher +1<br>   - Al Skipp +1<br>   - Austin Zheng +1<br>   - Dave Abrahams -1<br>   - T.J. Usiyan +1<br>   - Greg Titus -1<br>   - Joe Groff +1<br>   - Jens Persson +1<br>   - Brent Royal-Gordon +1<br>   - Krzysztof Siejkowski + 1<br></p><p>*Neutral about HKTs (expressed opinions on needing concrete examples, or<br>FP):*<br></p><p>   - Matthew Johnson +0<br>   - Douglas Gregor +0<br>   - Andrey Tarantsov +0<br></p><p>Noteworthy is Dave and Douglas from Apple, who basically say that either<br>they need more examples of how this will benefit many users, or that they<br>don&#39;t think it will.<br></p><p>We have collected a few examples of where this would benefit. They are<br>mainly for generating DSLs, a DSL is by definition domain-specific, so it&#39;s<br>going to be niche. However, DSLs in general are applicable to most apps, so<br>perhaps there&#39;s something in that.<br></p><p>I think Krzysztof Siejkowski&#39;s three points are great, and we should look<br>at and support those other threads.<br></p><p>We could get a representative sample of Swift code from github. Then find<br>which of those benefit from higher kinded types:<br> * turning runtime bugs into compile-time errors<br> * reducing code-duplication, etc.<br></p><p>A good place to look is popular Swift libraries (top 5 on github), and see<br>if they (and by extension their users) would benefit from HKTs:<br></p><p>   - https://github.com/Alamofire/Alamofire (possibly, DSL)<br>   - https://github.com/SwiftyJSON/SwiftyJSON (very likely, DSL / type<br>   constraints)<br>   - https://github.com/SnapKit/SnapKit (very likely, chained DSL)<br>   - https://github.com/MengTo/Spring (probably not in their DSL, maybe in<br>   their implementation)<br>   - https://github.com/ochococo/Design-Patterns-In-Swift (probably, but<br>   I&#39;m biased)<br></p><p>Likewise there&#39;s two more cases:<br></p><p>   - https://github.com/Quick/Quick<br>   - https://github.com/Quick/Nimble<br></p><p>They&#39;re testing frameworks, their implementation DSL could really benefit<br>from HKTs last time I looked at it. Likewise, I&#39;m not 100% sure but HKTs<br>may be the building blocks upon which Swift&#39;s first convenient mocking<br>framework could be built. Testing, and testing DSLs are things that all<br>swift users can benefit from, the question is whether that needs HKTs.<br></p><p><br>On Fri, Dec 18, 2015 at 1:43 AM, Krzysztof Siejkowski via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This is directed to the thread/discussion in general, not any specific<br>&gt; person: I think it was said before but it is probably worth<br>&gt; repeating: Whether the type system should allow HKT or not doesn&#39;t<br>&gt; necessarily have anything to do with the names and data structures of<br>&gt; the stdlib.<br>&gt;<br>&gt;<br>&gt; Well said! Could we steer the discussion in the right direction by<br>&gt; identifying what exact features of type system are needed?<br>&gt;<br>&gt;<br>&gt; Some questions that come to mind:<br>&gt;<br>&gt; 1) Do we need ability to express covariance and contravariance of generic<br>&gt; types?<br>&gt;<br>&gt; 2) Do we need a better mechanism for ad-hoc polymorphism, similar to<br>&gt; Haskell&#39;s typeclasses?<br>&gt;<br>&gt; 3) How should type constraints (`where` clause) be extended?<br>&gt;<br>&gt;<br>&gt; Some of those questions are already discussed in other threads, so it’s<br>&gt; mainly a matter of ensuring that the upcoming proposals are powerful enough.<br>&gt;<br>&gt;<br>&gt; Krzysztof<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; For example, a Mappable protocol (let&#39;s call it that rather<br>&gt; than Functor) is currently not even _possible_ to write, and I believe this<br>&gt; is the question to consider, i.e. whether Swift&#39;s type system should be<br>&gt; allowed to express types that are parameterized not only by concrete types<br>&gt; but also by parameterized types, for example if a return type could<br>&gt; be Self&lt;T&gt; or just Self.<br>&gt;<br>&gt; It would be sad if the question about HKT turned into yet<br>&gt; another fruitless and meaningless functional vs imperative debate (see the<br>&gt; talk *-Oriented Programming by Graham Lee).<br>&gt;<br>&gt; /Jens<br>&gt;<br>&gt; On Thursday, December 17, 2015, Will Fancher via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I&#39;m not sure I follow? Are you suggesting that having HKTs at all will<br>&gt;&gt; encourage Swift programmers to use bad naming conventions? I don&#39;t think<br>&gt;&gt; the two are related unless you&#39;re talking about people using a Monad<br>&gt;&gt; library, in which case it will be the Monad library using and encouraging<br>&gt;&gt; bad naming conventions, not HKTs themselves.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; http://www.bitcycle.com/<br>&gt; Phone: +46-73-753 24 62<br>&gt; E-mail: jens at bitcycle.com<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/3e608915/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5c9df42e3c293e3cdb5f3e1b34d44ef9?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Step C</string> &lt;schristopher at bignerdranch.com&gt;<p>December 17, 2015 at 10:00:00am</p></header><div class="content"><p>I am in favor of HKT eventually, but agree that they are lower priority for<br>now. I do think some of these kinds of abstractions and thinking will be<br>more fluent for the next generation of programmers, but Swift has already<br>harvested the major wins in that arena by embracing enough of the power<br>from functional programming styles to allow us significant productivity and<br>expressivity wins. HKT allows more code sharing but does not prevent us<br>from making the practical types we need, like Future/Promise (<br>https://github.com/bignerdranch/Deferred for a in-the-wild implementation<br>that I’m involved with).<br></p><p>Step Christopher<br>Big Nerd Ranch, LLC<br>schristopher at bignerdranch.com<br></p><p><br>On Thu, Dec 17, 2015 at 10:40 AM, Andrew Bennett via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; There&#39;s a lot of passionate Swift people here, it&#39;s great to see, and I<br>&gt; think with some clarification we could reach a consensus.<br>&gt;<br>&gt; Lots of interesting discussion here for different proposals:<br>&gt;  * Supporting Monads, Functors in the Standard Library<br>&gt;  * Renaming flatMap, map, etc. ...<br>&gt;<br>&gt; I think the second would be really interesting as a separate discussion in<br>&gt; another proposal (ie. map/reduce is probably Term of Art<br>&gt; https://swift.org/documentation/api-design-guidelines.html).<br>&gt;<br>&gt; The current proposal is, to paraphrase:<br>&gt;  * A more expressive type system through more flexible generics (HKT)<br>&gt;<br>&gt; I want Swift and the Standard Library to be clean, consistent, expressive,<br>&gt; safe, and approachable. I believe that HKTs are a necessary step to achieve<br>&gt; all of these things.<br>&gt;<br>&gt; Going back over the posts, for those talking about the proposal, this<br>&gt; seems to be the votes so far:<br>&gt;<br>&gt; *Clear Votes for/against HKTs:*<br>&gt;<br>&gt;    - Will Fancher +1<br>&gt;    - Al Skipp +1<br>&gt;    - Austin Zheng +1<br>&gt;    - Dave Abrahams -1<br>&gt;    - T.J. Usiyan +1<br>&gt;    - Greg Titus -1<br>&gt;    - Joe Groff +1<br>&gt;    - Jens Persson +1<br>&gt;    - Brent Royal-Gordon +1<br>&gt;    - Krzysztof Siejkowski + 1<br>&gt;<br>&gt; *Neutral about HKTs (expressed opinions on needing concrete examples, or<br>&gt; FP):*<br>&gt;<br>&gt;    - Matthew Johnson +0<br>&gt;    - Douglas Gregor +0<br>&gt;    - Andrey Tarantsov +0<br>&gt;<br>&gt; Noteworthy is Dave and Douglas from Apple, who basically say that either<br>&gt; they need more examples of how this will benefit many users, or that they<br>&gt; don&#39;t think it will.<br>&gt;<br>&gt; We have collected a few examples of where this would benefit. They are<br>&gt; mainly for generating DSLs, a DSL is by definition domain-specific, so it&#39;s<br>&gt; going to be niche. However, DSLs in general are applicable to most apps, so<br>&gt; perhaps there&#39;s something in that.<br>&gt;<br>&gt; I think Krzysztof Siejkowski&#39;s three points are great, and we should look<br>&gt; at and support those other threads.<br>&gt;<br>&gt; We could get a representative sample of Swift code from github. Then find<br>&gt; which of those benefit from higher kinded types:<br>&gt;  * turning runtime bugs into compile-time errors<br>&gt;  * reducing code-duplication, etc.<br>&gt;<br>&gt; A good place to look is popular Swift libraries (top 5 on github), and see<br>&gt; if they (and by extension their users) would benefit from HKTs:<br>&gt;<br>&gt;    - https://github.com/Alamofire/Alamofire (possibly, DSL)<br>&gt;    - https://github.com/SwiftyJSON/SwiftyJSON (very likely, DSL / type<br>&gt;    constraints)<br>&gt;    - https://github.com/SnapKit/SnapKit (very likely, chained DSL)<br>&gt;    - https://github.com/MengTo/Spring (probably not in their DSL, maybe<br>&gt;    in their implementation)<br>&gt;    - https://github.com/ochococo/Design-Patterns-In-Swift (probably, but<br>&gt;    I&#39;m biased)<br>&gt;<br>&gt; Likewise there&#39;s two more cases:<br>&gt;<br>&gt;    - https://github.com/Quick/Quick<br>&gt;    - https://github.com/Quick/Nimble<br>&gt;<br>&gt; They&#39;re testing frameworks, their implementation DSL could really benefit<br>&gt; from HKTs last time I looked at it. Likewise, I&#39;m not 100% sure but HKTs<br>&gt; may be the building blocks upon which Swift&#39;s first convenient mocking<br>&gt; framework could be built. Testing, and testing DSLs are things that all<br>&gt; swift users can benefit from, the question is whether that needs HKTs.<br>&gt;<br>&gt;<br>&gt; On Fri, Dec 18, 2015 at 1:43 AM, Krzysztof Siejkowski via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; This is directed to the thread/discussion in general, not any specific<br>&gt;&gt; person: I think it was said before but it is probably worth<br>&gt;&gt; repeating: Whether the type system should allow HKT or not doesn&#39;t<br>&gt;&gt; necessarily have anything to do with the names and data structures of<br>&gt;&gt; the stdlib.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Well said! Could we steer the discussion in the right direction by<br>&gt;&gt; identifying what exact features of type system are needed?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Some questions that come to mind:<br>&gt;&gt;<br>&gt;&gt; 1) Do we need ability to express covariance and contravariance of generic<br>&gt;&gt; types?<br>&gt;&gt;<br>&gt;&gt; 2) Do we need a better mechanism for ad-hoc polymorphism, similar to<br>&gt;&gt; Haskell&#39;s typeclasses?<br>&gt;&gt;<br>&gt;&gt; 3) How should type constraints (`where` clause) be extended?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Some of those questions are already discussed in other threads, so it’s<br>&gt;&gt; mainly a matter of ensuring that the upcoming proposals are powerful enough.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Krzysztof<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; For example, a Mappable protocol (let&#39;s call it that rather<br>&gt;&gt; than Functor) is currently not even _possible_ to write, and I believe this<br>&gt;&gt; is the question to consider, i.e. whether Swift&#39;s type system should be<br>&gt;&gt; allowed to express types that are parameterized not only by concrete types<br>&gt;&gt; but also by parameterized types, for example if a return type could<br>&gt;&gt; be Self&lt;T&gt; or just Self.<br>&gt;&gt;<br>&gt;&gt; It would be sad if the question about HKT turned into yet<br>&gt;&gt; another fruitless and meaningless functional vs imperative debate (see the<br>&gt;&gt; talk *-Oriented Programming by Graham Lee).<br>&gt;&gt;<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt; On Thursday, December 17, 2015, Will Fancher via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I&#39;m not sure I follow? Are you suggesting that having HKTs at all will<br>&gt;&gt;&gt; encourage Swift programmers to use bad naming conventions? I don&#39;t think<br>&gt;&gt;&gt; the two are related unless you&#39;re talking about people using a Monad<br>&gt;&gt;&gt; library, in which case it will be the Monad library using and encouraging<br>&gt;&gt;&gt; bad naming conventions, not HKTs themselves.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt; E-mail: jens at bitcycle.com<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/8b9dc88e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 17, 2015 at 10:00:00am</p></header><div class="content"><p>I am actually +1 on adding HKTs eventually.  I would really like to see them in Swift.<br></p><p>I also think fleshing out the existing generics features is a much more immediate concern.  It&#39;s pretty clear we won&#39;t see every generics feature we can imagine in Swift 3 so we need to choose.  I would prefer to see the existing features fully fleshed out and limitations removed before we start introducing more sophisticated features into the type system.<br></p><p>Collecting a list of libraries you think might benefit from HKTs is a good start for providing more concrete motivation in the context of Swift.  I think a good next step would be to imagine how those libraries might look different if Swift had HKTs.  The API should ideally be comfortable for users whether they understand HKTs or not (or even know they exist).  <br></p><p>How would the implementations be better and the interfaces more composable and / or safer?  For the DSL examples, how would the HKT approach be superior to other approaches?  Answering these questions with hypothetical but concrete examples will do a lot to change the conversation and maybe also increase the priority.<br></p><p>Matthew<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 17, 2015, at 9:40 AM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There&#39;s a lot of passionate Swift people here, it&#39;s great to see, and I think with some clarification we could reach a consensus.<br>&gt; <br>&gt; Lots of interesting discussion here for different proposals:<br>&gt;  * Supporting Monads, Functors in the Standard Library<br>&gt;  * Renaming flatMap, map, etc. ...<br>&gt; <br>&gt; I think the second would be really interesting as a separate discussion in another proposal (ie. map/reduce is probably Term of Art https://swift.org/documentation/api-design-guidelines.html).<br>&gt; <br>&gt; The current proposal is, to paraphrase:<br>&gt;  * A more expressive type system through more flexible generics (HKT)<br>&gt; <br>&gt; I want Swift and the Standard Library to be clean, consistent, expressive, safe, and approachable. I believe that HKTs are a necessary step to achieve all of these things.<br>&gt; <br>&gt; Going back over the posts, for those talking about the proposal, this seems to be the votes so far:<br>&gt; <br>&gt; Clear Votes for/against HKTs:<br>&gt; Will Fancher +1<br>&gt; Al Skipp +1<br>&gt; Austin Zheng +1<br>&gt; Dave Abrahams -1<br>&gt; T.J. Usiyan +1<br>&gt; Greg Titus -1<br>&gt; Joe Groff +1<br>&gt; Jens Persson +1<br>&gt; Brent Royal-Gordon +1<br>&gt; Krzysztof Siejkowski + 1<br>&gt; Neutral about HKTs (expressed opinions on needing concrete examples, or FP):<br>&gt; Matthew Johnson +0<br>&gt; Douglas Gregor +0<br>&gt; Andrey Tarantsov +0<br>&gt; Noteworthy is Dave and Douglas from Apple, who basically say that either they need more examples of how this will benefit many users, or that they don&#39;t think it will.<br>&gt; <br>&gt; We have collected a few examples of where this would benefit. They are mainly for generating DSLs, a DSL is by definition domain-specific, so it&#39;s going to be niche. However, DSLs in general are applicable to most apps, so perhaps there&#39;s something in that.<br>&gt; <br>&gt; I think Krzysztof Siejkowski&#39;s three points are great, and we should look at and support those other threads.<br>&gt; <br>&gt; We could get a representative sample of Swift code from github. Then find which of those benefit from higher kinded types:<br>&gt;  * turning runtime bugs into compile-time errors<br>&gt;  * reducing code-duplication, etc.<br>&gt; <br>&gt; A good place to look is popular Swift libraries (top 5 on github), and see if they (and by extension their users) would benefit from HKTs:<br>&gt; https://github.com/Alamofire/Alamofire (possibly, DSL)<br>&gt; https://github.com/SwiftyJSON/SwiftyJSON (very likely, DSL / type constraints)<br>&gt; https://github.com/SnapKit/SnapKit (very likely, chained DSL)<br>&gt; https://github.com/MengTo/Spring (probably not in their DSL, maybe in their implementation)<br>&gt; https://github.com/ochococo/Design-Patterns-In-Swift (probably, but I&#39;m biased)<br>&gt; Likewise there&#39;s two more cases:<br>&gt; https://github.com/Quick/Quick<br>&gt; https://github.com/Quick/Nimble<br>&gt; They&#39;re testing frameworks, their implementation DSL could really benefit from HKTs last time I looked at it. Likewise, I&#39;m not 100% sure but HKTs may be the building blocks upon which Swift&#39;s first convenient mocking framework could be built. Testing, and testing DSLs are things that all swift users can benefit from, the question is whether that needs HKTs.<br>&gt; <br>&gt; <br>&gt; On Fri, Dec 18, 2015 at 1:43 AM, Krzysztof Siejkowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; This is directed to the thread/discussion in general, not any specific person: I think it was said before but it is probably worth repeating: Whether the type system should allow HKT or not doesn&#39;t necessarily have anything to do with the names and data structures of the stdlib.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Well said! Could we steer the discussion in the right direction by identifying what exact features of type system are needed?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Some questions that come to mind:<br>&gt;&gt; <br>&gt;&gt; 1) Do we need ability to express covariance and contravariance of generic types?<br>&gt;&gt; <br>&gt;&gt; 2) Do we need a better mechanism for ad-hoc polymorphism, similar to Haskell&#39;s typeclasses?<br>&gt;&gt; <br>&gt;&gt; 3) How should type constraints (`where` clause) be extended?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Some of those questions are already discussed in other threads, so it’s mainly a matter of ensuring that the upcoming proposals are powerful enough.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Krzysztof<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, a Mappable protocol (let&#39;s call it that rather than Functor) is currently not even _possible_ to write, and I believe this is the question to consider, i.e. whether Swift&#39;s type system should be allowed to express types that are parameterized not only by concrete types but also by parameterized types, for example if a return type could be Self&lt;T&gt; or just Self.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would be sad if the question about HKT turned into yet another fruitless and meaningless functional vs imperative debate (see the talk *-Oriented Programming by Graham Lee).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thursday, December 17, 2015, Will Fancher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; I&#39;m not sure I follow? Are you suggesting that having HKTs at all will encourage Swift programmers to use bad naming conventions? I don&#39;t think the two are related unless you&#39;re talking about people using a Monad library, in which case it will be the Monad library using and encouraging bad naming conventions, not HKTs themselves.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt; E-mail: jens at bitcycle.com<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/bcc1aedf/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 18, 2015 at 12:00:00am</p></header><div class="content"><p>An excellent summary, Andrew.<br></p><p>I feel that people voting +1 here all have some specific use case in mind. But unlike in other proposals, here, for the love of god, I cannot imagine what it is.<br>&gt; Will Fancher +1<br>&gt; Al Skipp +1<br>&gt; Austin Zheng +1<br>&gt; T.J. Usiyan +1<br>&gt; Joe Groff +1<br>&gt; Jens Persson +1<br>&gt; Brent Royal-Gordon +1<br>&gt; Krzysztof Siejkowski + 1<br>Can each of you guys just write a bit of code that you want to be made possible, something that is substantially better than alternatives?<br></p><p>Really, it may seem obvious to you, but it&#39;s a complete mystery to me and others like me.<br></p><p>&gt; A good place to look is popular Swift libraries (top 5 on github), and see if they (and by extension their users) would benefit from HKTs:<br>&gt; https://github.com/Alamofire/Alamofire &lt;https://github.com/Alamofire/Alamofire&gt; (possibly, DSL)<br>&gt; https://github.com/SwiftyJSON/SwiftyJSON &lt;https://github.com/SwiftyJSON/SwiftyJSON&gt; (very likely, DSL / type constraints)<br>&gt; https://github.com/SnapKit/SnapKit &lt;https://github.com/SnapKit/SnapKit&gt; (very likely, chained DSL)<br>&gt; https://github.com/MengTo/Spring &lt;https://github.com/MengTo/Spring&gt; (probably not in their DSL, maybe in their implementation)<br>&gt; https://github.com/ochococo/Design-Patterns-In-Swift &lt;https://github.com/ochococo/Design-Patterns-In-Swift&gt; (probably, but I&#39;m biased)<br>&gt; Likewise there&#39;s two more cases:<br>&gt; https://github.com/Quick/Quick &lt;https://github.com/Quick/Quick&gt;<br>&gt; https://github.com/Quick/Nimble &lt;https://github.com/Quick/Nimble&gt;<br>Would *love* this, DSLs especially.<br></p><p>Common, don&#39;t just vote +1 — give examples!<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/51570482/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 17, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; I feel that people voting +1 here all have some specific use case in mind. But unlike in other proposals, here, for the love of god, I cannot imagine what it is.<br>&gt;&gt; 	• Brent Royal-Gordon +1<br>&gt; Can each of you guys just write a bit of code that you want to be made possible, something that is substantially better than alternatives?<br>&gt; <br>&gt; Really, it may seem obvious to you, but it&#39;s a complete mystery to me and others like me.<br></p><p>Well, for one thing, I’ve already earned 605 reputation on Stack Overflow because of this particular weakness in the type system. I’d like that to stop. &lt;http://stackoverflow.com/questions/24116271/whats-the-cleanest-way-of-applying-map-to-a-dictionary-in-swift&gt;<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 17, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 7:40 AM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Joe Groff +1<br>&gt; <br></p><p>I&#39;m +0 as well, to be clear. I only wanted to steer the discussion away from functional abstractions and toward more concrete applications of HKT that come up in practice in industrial languages like C++.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/4f2a4925/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 18, 2015 at 10:00:00am</p></header><div class="content"><p>Sorry Joe, I misinterpreted your position - I may have interpreted<br>supportive of the discourse with supportive of the proposal. Also sorry I<br>left you off the Apple people list!<br></p><p>On Friday, 18 December 2015, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 17, 2015, at 7:40 AM, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt;    - Joe Groff +1<br>&gt;<br>&gt;<br>&gt;<br>&gt; I&#39;m +0 as well, to be clear. I only wanted to steer the discussion away<br>&gt; from functional abstractions and toward more concrete applications of HKT<br>&gt; that come up in practice in industrial languages like C++.<br>&gt;<br>&gt; -Joe<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/03c3bc30/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December 17, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On 17 Dec 2015, at 13:16, Will Fancher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I do think that the use case of HKTs is limited mostly to those of us who really want to use Monads and the like. HKTs are a feature that I think round out Swift&#39;s generics&#39; completeness, but the main application would be some niche third party packages that have various FP programming elements. If those libraries take off and become mainstream Swift, that&#39;s a sign that those libraries are a good thing to begin with. Otherwise, I doubt the horrible naming conventions of FP (and they are horrible) would be invasive to the Swift language as a whole.<br></p><p>Whatever names are decided upon for the general cases, ‘flatMap’, ‘bind’, ‘map’, ‘unit’, ‘pure’, or whatever, it’ll be impossible to have something that sounds appropriate for each particular instance. I suppose a Futures library could provide &#39;then’ and ‘after’ functions (or whatever is deemed best), these functions would themselves simply call into ‘map’ and ‘flatMap’.<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 17, 2015 at 05:00:00pm</p></header><div class="content"><p>Big +1 for HKTs from me!<br></p><p>-Thorsten <br></p><p>&gt; Am 17.12.2015 um 13:10 schrieb Will Fancher via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; Optional.map and Array.map do different things, and unifying them seems harmful.<br>&gt; <br>&gt; In terms of category theory, they&#39;re not different. They are both arrows from a to b in the Functor category. Obviously that&#39;s horribly abstract, so I&#39;ll put it this way: If you think of these map functions not as operations on Optional and Array, and instead think of them simply as ways to compose an arbitrary data structure, they are in fact doing the same thing. On an implementation level, and on a runtime level, they perform differently. But on a type level, a theoretical level, and a categorical level, they are the same. You merely need to accept that when using this abstraction without knowledge of the concrete type, you have no reason to make any assumptions about how the implementation and runtime will behave. At that point, all you need is to be sure that the Functor being passed in abides by the Functor laws, and that&#39;s just a matter of convention.<br>&gt; <br>&gt;&gt; First, I consider myself a smart person with a very broad experience with non-functional languages, but reading this makes my mind hurt, a lot:<br>&gt;&gt; <br>&gt;&gt;&gt;    typeclass Functor f where<br>&gt;&gt;&gt;        fmap :: (a -&gt; b) -&gt; f a -&gt; f b<br>&gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt; This makes it possible to build functions which operate not just on Maybe, but on any Functor.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    fstrlen :: Functor f =&gt; f String -&gt; f Int<br>&gt;&gt;&gt;    fstrlen fstr = fmap length faster<br>&gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt;    protocol Functor {<br>&gt;&gt;&gt;        typealias A<br>&gt;&gt;&gt;        func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt;&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; I understand what&#39;s going on here, but I never, ever want to see this code anywhere near (my) Swift.<br>&gt; <br>&gt; HKTs that come from category theory tend to have this effect. They are hard to understand by reading the protocol definition. Admittedly, this is a big flaw with Monads and with Haskell. It takes a reasonable understanding of category theory for the purpose of this code to be obvious to the reader.<br>&gt; <br>&gt; (I will point out that in those code examples, I used absolutely abysmal naming conventions. It could be made marginally more readable and understandable if the naming were better)<br>&gt; <br>&gt; I&#39;ll take this time to make the point that just because you don&#39;t like the way the Functor protocol looks, doesn&#39;t mean Array and Optional aren&#39;t both Functors and Monads. As a matter of mathematics, if the Monad functions can exist on a type, and they would follow the Monad laws, that type is a Monad whether the implementor likes it or not. Of course it still needs manual implementing, but regardless, the type is theoretically a Monad. (This realization is the reason that the Java team decided to implement flatMap for Java 8&#39;s Optional class.)<br>&gt; <br>&gt;&gt; I believe the way to convince the rest of us (and I would love to be convinced) is to provide a few real, “end-user” app-level use cases and explain the benefit in plain language. In particular, I don&#39;t understand the example by Jens Persson, although it seems like a valuable one.<br>&gt; <br>&gt; I can (again) link to just a few of the abstract Monadic functions, all of which are very useful in practical applications.<br>&gt; <br>&gt; https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html<br>&gt; <br>&gt; But perhaps it would also help to describe the architectural decisions that abiding by Monad imposes.<br>&gt; <br>&gt; Being Monadic makes you think about data composition, which cleans up the way you design your code. Going back to the Futures example, I could implement future, and subsequently use it, like this:<br>&gt; <br>&gt;     public class Promise&lt;T&gt; {<br>&gt;         private var handlers: [T -&gt; ()] = []<br>&gt;         private var completed: T? = nil<br>&gt;         <br>&gt;         public init() {<br>&gt;         }<br>&gt;         <br>&gt;         private func onComplete(handler: T -&gt; ()) {<br>&gt;             if let completed = completed {<br>&gt;                 handler(completed)<br>&gt;             } else {<br>&gt;                 handlers.append(handler)<br>&gt;             }<br>&gt;         }<br>&gt;         <br>&gt;         public func complete(t: T) {<br>&gt;             completed = t<br>&gt;             for handler in handlers {<br>&gt;                 handler(t)<br>&gt;             }<br>&gt;             handlers = []<br>&gt;         }<br>&gt;         <br>&gt;         public var future: Future&lt;T&gt; {<br>&gt;             return Future(promise: self)<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt;     public struct Future&lt;T&gt; {<br>&gt;         private let promise: Promise&lt;T&gt;<br>&gt;         <br>&gt;         private init(promise: Promise&lt;T&gt;) {<br>&gt;             self.promise = promise<br>&gt;         }<br>&gt;         <br>&gt;         public func onComplete(handler: T -&gt; ()) {<br>&gt;             promise.onComplete(handler)<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt;     public func useFutures() {<br>&gt;         downloadURLInFuture().onComplete { content in<br>&gt;             processContentAsync(content).onComplete { processed in<br>&gt;                 processed.calculateSomethingAsync().onComplete {<br>&gt;                     ...<br>&gt;                         ...<br>&gt;                             print(finalProduct)<br>&gt;                         ...<br>&gt;                     ...<br>&gt;                 }<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; You can see how this resembles the infamous Node.js issue of callback hell, and how the nesting could quickly get out of hand. If only we had some form of composition... Arrows between Futures... Luckily, Future is a Monad (whether I like it or not!)<br>&gt; <br>&gt;     // Monad<br>&gt; <br>&gt;     public extension Future {<br>&gt;         public static func point&lt;T&gt;(t: T) -&gt; Future&lt;T&gt; {<br>&gt;             let promise = Promise&lt;T&gt;()<br>&gt;             promise.complete(t)<br>&gt;             return promise.future<br>&gt;         }<br>&gt;         <br>&gt;         public func flatMap&lt;U&gt;(f: T -&gt; Future&lt;U&gt;) -&gt; Future&lt;U&gt; {<br>&gt;             let uPromise = Promise&lt;U&gt;()<br>&gt;             <br>&gt;             onComplete { t in<br>&gt;                 f(t).onComplete { u in<br>&gt;                     uPromise.complete(u)<br>&gt;                 }<br>&gt;             }<br>&gt;             <br>&gt;             return uPromise.future<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; Not only do I now get map and apply for free, but I also get a great method of composing Futures. The example from above can now be rewritten to be much more well composed.<br>&gt; <br>&gt;     public func useFutures() {<br>&gt;         downloadURLInFuture()<br>&gt;             .flatMap(processContentAsync)<br>&gt;             .flatMap { $0.calculateSomethingAsync() }<br>&gt;             ...<br>&gt;             .onComplete { finalProduct in<br>&gt;                 print(finalProduct)<br>&gt;             }<br>&gt;     }<br>&gt; <br>&gt; The important thing here is that thinking about Monads helped me discover a better composition model. Now my code can be more readable and well composed.<br>&gt; <br>&gt; And again, I&#39;ll mention the enormous world of functions and capabilities that can be gotten for free for the sake of even more well-composed code.<br>&gt; <br>&gt;&gt; I don&#39;t want a flatMap on optionals (which, I believe, was thankfully removed in Swift 2).<br>&gt; <br>&gt; And why on Earth not? The concrete implementation of it on Optional is very simple and easy to understand, and the method is incredibly useful. Personally, I use it all the time (it was not removed). And again, just because you don&#39;t like using flatMap doesn&#39;t mean Optional isn&#39;t a Monad.<br>&gt; <br>&gt; Finally, I&#39;d like to point out that it doesn&#39;t hurt any end users not familiar with Monads if Array implements a higher kinded Monad protocol. As far as they have to be concerned, Array just has these useful map and flatMap functions. Meanwhile, those of us who wish to abstract over Monads in general can write our abstract code and implement Monad on our various types which mathematically have to be Monads. It&#39;s a layer of robustness and improvement that unconcerned end users don&#39;t have to bother themselves with.<br>&gt; <br>&gt; While I understand that the Swift team doesn&#39;t have the resources to implement everything that everyone wants, and that HKTs aren&#39;t very high on their list of priorities, it seems unreasonable to me that one could think of HKTs and Monads as somehow detrimental to the language.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/ff2e6f7b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f5228ad4a1fad94f1a7d3d05b0c0ff6a?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Donnacha Oisín Kidney</string> &lt;oisin.kidney at gmail.com&gt;<p>December 17, 2015 at 06:00:00pm</p></header><div class="content"><p>While I’d love to see HKTs in Swift in the future, and it’s definitely the feature I’m most excited about, I think I’m -1 on this proposal for Swift 3.<br></p><p>I’m not sure if I’m formally correct here, but here’s my understanding so far: Swift’s current type system is powerful enough to express all of the individual Monads that we’re interested in, but it is not capable of a Monad protocol. (or a functor, or applicative, etc.)<br></p><p>If that’s the case, then I can see only two advantages to HKTs:<br></p><p>Code reuse for monadic functions, such as mapM, sequence, etc.<br>The ability to reason and code about monads generally, rather than about specific monads.<br></p><p>I think the first advantage is the “getting functions for free” idea. However, I’m not sure how much of an advantage it really is: the minimal complete definition for Monad is map, flatMap, and pure. Is mapM and sequence really such an extra hassle? Don’t get me wrong: not having to define them is obviously preferable. I’m just not sure how preferable.<br></p><p>The second advantage, while it’s something I’m certainly interested in, seems much more difficult to justify as an investment of the Swift team’s time.  As someone who’s been learning Haskell for 6-ish months now, I’m only just beginning to grasp those more abstract concepts, and even then it’s still just fun and interesting, rather than useful. I can’t imagine a lot of Comonadic Costate Coalgebra whatever making it into production code.<br></p><p>I feel like right now Swift can get 80% of the benefits from Monadic code, since we can already write Optional, Gen, Parser, State, Par, etc.<br></p><p>&gt; On 17 Dec 2015, at 16:44, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Big +1 for HKTs from me!<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 17.12.2015 um 13:10 schrieb Will Fancher via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt;&gt; Optional.map and Array.map do different things, and unifying them seems harmful.<br>&gt;&gt; <br>&gt;&gt; In terms of category theory, they&#39;re not different. They are both arrows from a to b in the Functor category. Obviously that&#39;s horribly abstract, so I&#39;ll put it this way: If you think of these map functions not as operations on Optional and Array, and instead think of them simply as ways to compose an arbitrary data structure, they are in fact doing the same thing. On an implementation level, and on a runtime level, they perform differently. But on a type level, a theoretical level, and a categorical level, they are the same. You merely need to accept that when using this abstraction without knowledge of the concrete type, you have no reason to make any assumptions about how the implementation and runtime will behave. At that point, all you need is to be sure that the Functor being passed in abides by the Functor laws, and that&#39;s just a matter of convention.<br>&gt;&gt; <br>&gt;&gt;&gt; First, I consider myself a smart person with a very broad experience with non-functional languages, but reading this makes my mind hurt, a lot:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    typeclass Functor f where<br>&gt;&gt;&gt;&gt;        fmap :: (a -&gt; b) -&gt; f a -&gt; f b<br>&gt;&gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt;&gt; This makes it possible to build functions which operate not just on Maybe, but on any Functor.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    fstrlen :: Functor f =&gt; f String -&gt; f Int<br>&gt;&gt;&gt;&gt;    fstrlen fstr = fmap length faster<br>&gt;&gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt;&gt;    protocol Functor {<br>&gt;&gt;&gt;&gt;        typealias A<br>&gt;&gt;&gt;&gt;        func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I understand what&#39;s going on here, but I never, ever want to see this code anywhere near (my) Swift.<br>&gt;&gt; <br>&gt;&gt; HKTs that come from category theory tend to have this effect. They are hard to understand by reading the protocol definition. Admittedly, this is a big flaw with Monads and with Haskell. It takes a reasonable understanding of category theory for the purpose of this code to be obvious to the reader.<br>&gt;&gt; <br>&gt;&gt; (I will point out that in those code examples, I used absolutely abysmal naming conventions. It could be made marginally more readable and understandable if the naming were better)<br>&gt;&gt; <br>&gt;&gt; I&#39;ll take this time to make the point that just because you don&#39;t like the way the Functor protocol looks, doesn&#39;t mean Array and Optional aren&#39;t both Functors and Monads. As a matter of mathematics, if the Monad functions can exist on a type, and they would follow the Monad laws, that type is a Monad whether the implementor likes it or not. Of course it still needs manual implementing, but regardless, the type is theoretically a Monad. (This realization is the reason that the Java team decided to implement flatMap for Java 8&#39;s Optional class.)<br>&gt;&gt; <br>&gt;&gt;&gt; I believe the way to convince the rest of us (and I would love to be convinced) is to provide a few real, “end-user” app-level use cases and explain the benefit in plain language. In particular, I don&#39;t understand the example by Jens Persson, although it seems like a valuable one.<br>&gt;&gt; <br>&gt;&gt; I can (again) link to just a few of the abstract Monadic functions, all of which are very useful in practical applications.<br>&gt;&gt; <br>&gt;&gt; https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html &lt;https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html&gt;<br>&gt;&gt; <br>&gt;&gt; But perhaps it would also help to describe the architectural decisions that abiding by Monad imposes.<br>&gt;&gt; <br>&gt;&gt; Being Monadic makes you think about data composition, which cleans up the way you design your code. Going back to the Futures example, I could implement future, and subsequently use it, like this:<br>&gt;&gt; <br>&gt;&gt;     public class Promise&lt;T&gt; {<br>&gt;&gt;         private var handlers: [T -&gt; ()] = []<br>&gt;&gt;         private var completed: T? = nil<br>&gt;&gt;         <br>&gt;&gt;         public init() {<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         private func onComplete(handler: T -&gt; ()) {<br>&gt;&gt;             if let completed = completed {<br>&gt;&gt;                 handler(completed)<br>&gt;&gt;             } else {<br>&gt;&gt;                 handlers.append(handler)<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         public func complete(t: T) {<br>&gt;&gt;             completed = t<br>&gt;&gt;             for handler in handlers {<br>&gt;&gt;                 handler(t)<br>&gt;&gt;             }<br>&gt;&gt;             handlers = []<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         public var future: Future&lt;T&gt; {<br>&gt;&gt;             return Future(promise: self)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     public struct Future&lt;T&gt; {<br>&gt;&gt;         private let promise: Promise&lt;T&gt;<br>&gt;&gt;         <br>&gt;&gt;         private init(promise: Promise&lt;T&gt;) {<br>&gt;&gt;             self.promise = promise<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         public func onComplete(handler: T -&gt; ()) {<br>&gt;&gt;             promise.onComplete(handler)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     public func useFutures() {<br>&gt;&gt;         downloadURLInFuture().onComplete { content in<br>&gt;&gt;             processContentAsync(content).onComplete { processed in<br>&gt;&gt;                 processed.calculateSomethingAsync().onComplete {<br>&gt;&gt;                     ...<br>&gt;&gt;                         ...<br>&gt;&gt;                             print(finalProduct)<br>&gt;&gt;                         ...<br>&gt;&gt;                     ...<br>&gt;&gt;                 }<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; You can see how this resembles the infamous Node.js issue of callback hell, and how the nesting could quickly get out of hand. If only we had some form of composition... Arrows between Futures... Luckily, Future is a Monad (whether I like it or not!)<br>&gt;&gt; <br>&gt;&gt;     // Monad<br>&gt;&gt; <br>&gt;&gt;     public extension Future {<br>&gt;&gt;         public static func point&lt;T&gt;(t: T) -&gt; Future&lt;T&gt; {<br>&gt;&gt;             let promise = Promise&lt;T&gt;()<br>&gt;&gt;             promise.complete(t)<br>&gt;&gt;             return promise.future<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         public func flatMap&lt;U&gt;(f: T -&gt; Future&lt;U&gt;) -&gt; Future&lt;U&gt; {<br>&gt;&gt;             let uPromise = Promise&lt;U&gt;()<br>&gt;&gt;             <br>&gt;&gt;             onComplete { t in<br>&gt;&gt;                 f(t).onComplete { u in<br>&gt;&gt;                     uPromise.complete(u)<br>&gt;&gt;                 }<br>&gt;&gt;             }<br>&gt;&gt;             <br>&gt;&gt;             return uPromise.future<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; Not only do I now get map and apply for free, but I also get a great method of composing Futures. The example from above can now be rewritten to be much more well composed.<br>&gt;&gt; <br>&gt;&gt;     public func useFutures() {<br>&gt;&gt;         downloadURLInFuture()<br>&gt;&gt;             .flatMap(processContentAsync)<br>&gt;&gt;             .flatMap { $0.calculateSomethingAsync() }<br>&gt;&gt;             ...<br>&gt;&gt;             .onComplete { finalProduct in<br>&gt;&gt;                 print(finalProduct)<br>&gt;&gt;             }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; The important thing here is that thinking about Monads helped me discover a better composition model. Now my code can be more readable and well composed.<br>&gt;&gt; <br>&gt;&gt; And again, I&#39;ll mention the enormous world of functions and capabilities that can be gotten for free for the sake of even more well-composed code.<br>&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t want a flatMap on optionals (which, I believe, was thankfully removed in Swift 2).<br>&gt;&gt; <br>&gt;&gt; And why on Earth not? The concrete implementation of it on Optional is very simple and easy to understand, and the method is incredibly useful. Personally, I use it all the time (it was not removed). And again, just because you don&#39;t like using flatMap doesn&#39;t mean Optional isn&#39;t a Monad.<br>&gt;&gt; <br>&gt;&gt; Finally, I&#39;d like to point out that it doesn&#39;t hurt any end users not familiar with Monads if Array implements a higher kinded Monad protocol. As far as they have to be concerned, Array just has these useful map and flatMap functions. Meanwhile, those of us who wish to abstract over Monads in general can write our abstract code and implement Monad on our various types which mathematically have to be Monads. It&#39;s a layer of robustness and improvement that unconcerned end users don&#39;t have to bother themselves with.<br>&gt;&gt; <br>&gt;&gt; While I understand that the Swift team doesn&#39;t have the resources to implement everything that everyone wants, and that HKTs aren&#39;t very high on their list of priorities, it seems unreasonable to me that one could think of HKTs and Monads as somehow detrimental to the language.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/6a6a480a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cc5859def5f2690572483d8baaa29a23?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>André Videla</string> &lt;zephyz at icloud.com&gt;<p>December 17, 2015 at 07:00:00pm</p></header><div class="content"><p>I&#39;m extremely excited about HKT. Huge +1 for me as well. <br></p><p>Moreover, In addition to lots of code reuse, this would allow to extend the language with very expressive and useful syntax for monadic types. <br>Monadic comprehension are very useful and generic. <br>We could imagine something the for-comprehension in scala and use it with list comprehension as well as parser combinators. <br></p><p>I sincerely hope this feature will see the day. <br></p><p><br></p><p>Sent from my iPod<br>&gt; On 2015/12/17, at 17:44, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Big +1 for HKTs from me!<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt;&gt; Am 17.12.2015 um 13:10 schrieb Will Fancher via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; Optional.map and Array.map do different things, and unifying them seems harmful.<br>&gt;&gt; <br>&gt;&gt; In terms of category theory, they&#39;re not different. They are both arrows from a to b in the Functor category. Obviously that&#39;s horribly abstract, so I&#39;ll put it this way: If you think of these map functions not as operations on Optional and Array, and instead think of them simply as ways to compose an arbitrary data structure, they are in fact doing the same thing. On an implementation level, and on a runtime level, they perform differently. But on a type level, a theoretical level, and a categorical level, they are the same. You merely need to accept that when using this abstraction without knowledge of the concrete type, you have no reason to make any assumptions about how the implementation and runtime will behave. At that point, all you need is to be sure that the Functor being passed in abides by the Functor laws, and that&#39;s just a matter of convention.<br>&gt;&gt; <br>&gt;&gt;&gt; First, I consider myself a smart person with a very broad experience with non-functional languages, but reading this makes my mind hurt, a lot:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    typeclass Functor f where<br>&gt;&gt;&gt;&gt;        fmap :: (a -&gt; b) -&gt; f a -&gt; f b<br>&gt;&gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt;&gt; This makes it possible to build functions which operate not just on Maybe, but on any Functor.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    fstrlen :: Functor f =&gt; f String -&gt; f Int<br>&gt;&gt;&gt;&gt;    fstrlen fstr = fmap length faster<br>&gt;&gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt;&gt;    protocol Functor {<br>&gt;&gt;&gt;&gt;        typealias A<br>&gt;&gt;&gt;&gt;        func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I understand what&#39;s going on here, but I never, ever want to see this code anywhere near (my) Swift.<br>&gt;&gt; <br>&gt;&gt; HKTs that come from category theory tend to have this effect. They are hard to understand by reading the protocol definition. Admittedly, this is a big flaw with Monads and with Haskell. It takes a reasonable understanding of category theory for the purpose of this code to be obvious to the reader.<br>&gt;&gt; <br>&gt;&gt; (I will point out that in those code examples, I used absolutely abysmal naming conventions. It could be made marginally more readable and understandable if the naming were better)<br>&gt;&gt; <br>&gt;&gt; I&#39;ll take this time to make the point that just because you don&#39;t like the way the Functor protocol looks, doesn&#39;t mean Array and Optional aren&#39;t both Functors and Monads. As a matter of mathematics, if the Monad functions can exist on a type, and they would follow the Monad laws, that type is a Monad whether the implementor likes it or not. Of course it still needs manual implementing, but regardless, the type is theoretically a Monad. (This realization is the reason that the Java team decided to implement flatMap for Java 8&#39;s Optional class.)<br>&gt;&gt; <br>&gt;&gt;&gt; I believe the way to convince the rest of us (and I would love to be convinced) is to provide a few real, “end-user” app-level use cases and explain the benefit in plain language. In particular, I don&#39;t understand the example by Jens Persson, although it seems like a valuable one.<br>&gt;&gt; <br>&gt;&gt; I can (again) link to just a few of the abstract Monadic functions, all of which are very useful in practical applications.<br>&gt;&gt; <br>&gt;&gt; https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html<br>&gt;&gt; <br>&gt;&gt; But perhaps it would also help to describe the architectural decisions that abiding by Monad imposes.<br>&gt;&gt; <br>&gt;&gt; Being Monadic makes you think about data composition, which cleans up the way you design your code. Going back to the Futures example, I could implement future, and subsequently use it, like this:<br>&gt;&gt; <br>&gt;&gt;     public class Promise&lt;T&gt; {<br>&gt;&gt;         private var handlers: [T -&gt; ()] = []<br>&gt;&gt;         private var completed: T? = nil<br>&gt;&gt;         <br>&gt;&gt;         public init() {<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         private func onComplete(handler: T -&gt; ()) {<br>&gt;&gt;             if let completed = completed {<br>&gt;&gt;                 handler(completed)<br>&gt;&gt;             } else {<br>&gt;&gt;                 handlers.append(handler)<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         public func complete(t: T) {<br>&gt;&gt;             completed = t<br>&gt;&gt;             for handler in handlers {<br>&gt;&gt;                 handler(t)<br>&gt;&gt;             }<br>&gt;&gt;             handlers = []<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         public var future: Future&lt;T&gt; {<br>&gt;&gt;             return Future(promise: self)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     public struct Future&lt;T&gt; {<br>&gt;&gt;         private let promise: Promise&lt;T&gt;<br>&gt;&gt;         <br>&gt;&gt;         private init(promise: Promise&lt;T&gt;) {<br>&gt;&gt;             self.promise = promise<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         public func onComplete(handler: T -&gt; ()) {<br>&gt;&gt;             promise.onComplete(handler)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     public func useFutures() {<br>&gt;&gt;         downloadURLInFuture().onComplete { content in<br>&gt;&gt;             processContentAsync(content).onComplete { processed in<br>&gt;&gt;                 processed.calculateSomethingAsync().onComplete {<br>&gt;&gt;                     ...<br>&gt;&gt;                         ...<br>&gt;&gt;                             print(finalProduct)<br>&gt;&gt;                         ...<br>&gt;&gt;                     ...<br>&gt;&gt;                 }<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; You can see how this resembles the infamous Node.js issue of callback hell, and how the nesting could quickly get out of hand. If only we had some form of composition... Arrows between Futures... Luckily, Future is a Monad (whether I like it or not!)<br>&gt;&gt; <br>&gt;&gt;     // Monad<br>&gt;&gt; <br>&gt;&gt;     public extension Future {<br>&gt;&gt;         public static func point&lt;T&gt;(t: T) -&gt; Future&lt;T&gt; {<br>&gt;&gt;             let promise = Promise&lt;T&gt;()<br>&gt;&gt;             promise.complete(t)<br>&gt;&gt;             return promise.future<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         public func flatMap&lt;U&gt;(f: T -&gt; Future&lt;U&gt;) -&gt; Future&lt;U&gt; {<br>&gt;&gt;             let uPromise = Promise&lt;U&gt;()<br>&gt;&gt;             <br>&gt;&gt;             onComplete { t in<br>&gt;&gt;                 f(t).onComplete { u in<br>&gt;&gt;                     uPromise.complete(u)<br>&gt;&gt;                 }<br>&gt;&gt;             }<br>&gt;&gt;             <br>&gt;&gt;             return uPromise.future<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; Not only do I now get map and apply for free, but I also get a great method of composing Futures. The example from above can now be rewritten to be much more well composed.<br>&gt;&gt; <br>&gt;&gt;     public func useFutures() {<br>&gt;&gt;         downloadURLInFuture()<br>&gt;&gt;             .flatMap(processContentAsync)<br>&gt;&gt;             .flatMap { $0.calculateSomethingAsync() }<br>&gt;&gt;             ...<br>&gt;&gt;             .onComplete { finalProduct in<br>&gt;&gt;                 print(finalProduct)<br>&gt;&gt;             }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; The important thing here is that thinking about Monads helped me discover a better composition model. Now my code can be more readable and well composed.<br>&gt;&gt; <br>&gt;&gt; And again, I&#39;ll mention the enormous world of functions and capabilities that can be gotten for free for the sake of even more well-composed code.<br>&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t want a flatMap on optionals (which, I believe, was thankfully removed in Swift 2).<br>&gt;&gt; <br>&gt;&gt; And why on Earth not? The concrete implementation of it on Optional is very simple and easy to understand, and the method is incredibly useful. Personally, I use it all the time (it was not removed). And again, just because you don&#39;t like using flatMap doesn&#39;t mean Optional isn&#39;t a Monad.<br>&gt;&gt; <br>&gt;&gt; Finally, I&#39;d like to point out that it doesn&#39;t hurt any end users not familiar with Monads if Array implements a higher kinded Monad protocol. As far as they have to be concerned, Array just has these useful map and flatMap functions. Meanwhile, those of us who wish to abstract over Monads in general can write our abstract code and implement Monad on our various types which mathematically have to be Monads. It&#39;s a layer of robustness and improvement that unconcerned end users don&#39;t have to bother themselves with.<br>&gt;&gt; <br>&gt;&gt; While I understand that the Swift team doesn&#39;t have the resources to implement everything that everyone wants, and that HKTs aren&#39;t very high on their list of priorities, it seems unreasonable to me that one could think of HKTs and Monads as somehow detrimental to the language.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/53cebb67/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 21, 2016 at 10:00:00pm</p></header><div class="content"><p>Did anything become of this…. This seemed to die out with no proposal.<br></p><p>I would think having a common protocol for types that support monadic operations (regardless if they fulfill all the monadic operations) would generally be helpful — even if they were not implemented theoretically as a Functor / Monad separate protocol definitions.  <br></p><p>Scala seems to just treat them as one set of operations (MonadOps : map, flatMap, filter, withFilter).  `filter` copies the contents into a new set, `withFilter` is just an on-demand filter for any later functions such as map/flatmap (BTW, Is swift filter on-demand, copy, or a combination???). I do notice that several different implement of the Monad protocol have been done in different repositories - by third parties.  <br></p><p>And yes, Optionals are monads - and as such can be used in comprehension clauses.<br></p><p>I know that for-comprehension has been stated as probably not a Swift 3 thing (Felix indicated this but I don’t know where it is stated) - but I am wondering if they are thinking it is larger than it actually is (being that it is just a more friendly way to state existing map/flatmap combinations). If the worry is `for` having dual purpose — but if that is the case maybe making a new keyword for comprehensions like `all`.<br></p><p>Even if the proposal were drawn up - and it was `Deferred` at least it would potentially be on the radar.<br></p><p><br>&gt; On 2015-12-18, at 1:01:21, André Videla via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m extremely excited about HKT. Huge +1 for me as well. <br>&gt; <br>&gt; Moreover, In addition to lots of code reuse, this would allow to extend the language with very expressive and useful syntax for monadic types. <br>&gt; Monadic comprehension are very useful and generic. <br>&gt; We could imagine something the for-comprehension in scala and use it with list comprehension as well as parser combinators. <br>&gt; <br>&gt; I sincerely hope this feature will see the day. <br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPod<br>&gt; On 2015/12/17, at 17:44, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Big +1 for HKTs from me!<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; Am 17.12.2015 um 13:10 schrieb Will Fancher via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Optional.map and Array.map do different things, and unifying them seems harmful.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In terms of category theory, they&#39;re not different. They are both arrows from a to b in the Functor category. Obviously that&#39;s horribly abstract, so I&#39;ll put it this way: If you think of these map functions not as operations on Optional and Array, and instead think of them simply as ways to compose an arbitrary data structure, they are in fact doing the same thing. On an implementation level, and on a runtime level, they perform differently. But on a type level, a theoretical level, and a categorical level, they are the same. You merely need to accept that when using this abstraction without knowledge of the concrete type, you have no reason to make any assumptions about how the implementation and runtime will behave. At that point, all you need is to be sure that the Functor being passed in abides by the Functor laws, and that&#39;s just a matter of convention.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; First, I consider myself a smart person with a very broad experience with non-functional languages, but reading this makes my mind hurt, a lot:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    typeclass Functor f where<br>&gt;&gt;&gt;&gt;&gt;        fmap :: (a -&gt; b) -&gt; f a -&gt; f b<br>&gt;&gt;&gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt;&gt;&gt; This makes it possible to build functions which operate not just on Maybe, but on any Functor.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    fstrlen :: Functor f =&gt; f String -&gt; f Int<br>&gt;&gt;&gt;&gt;&gt;    fstrlen fstr = fmap length faster<br>&gt;&gt;&gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt;&gt;&gt;    protocol Functor {<br>&gt;&gt;&gt;&gt;&gt;        typealias A<br>&gt;&gt;&gt;&gt;&gt;        func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I understand what&#39;s going on here, but I never, ever want to see this code anywhere near (my) Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; HKTs that come from category theory tend to have this effect. They are hard to understand by reading the protocol definition. Admittedly, this is a big flaw with Monads and with Haskell. It takes a reasonable understanding of category theory for the purpose of this code to be obvious to the reader.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (I will point out that in those code examples, I used absolutely abysmal naming conventions. It could be made marginally more readable and understandable if the naming were better)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ll take this time to make the point that just because you don&#39;t like the way the Functor protocol looks, doesn&#39;t mean Array and Optional aren&#39;t both Functors and Monads. As a matter of mathematics, if the Monad functions can exist on a type, and they would follow the Monad laws, that type is a Monad whether the implementor likes it or not. Of course it still needs manual implementing, but regardless, the type is theoretically a Monad. (This realization is the reason that the Java team decided to implement flatMap for Java 8&#39;s Optional class.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I believe the way to convince the rest of us (and I would love to be convinced) is to provide a few real, “end-user” app-level use cases and explain the benefit in plain language. In particular, I don&#39;t understand the example by Jens Persson, although it seems like a valuable one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can (again) link to just a few of the abstract Monadic functions, all of which are very useful in practical applications.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html &lt;https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But perhaps it would also help to describe the architectural decisions that abiding by Monad imposes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Being Monadic makes you think about data composition, which cleans up the way you design your code. Going back to the Futures example, I could implement future, and subsequently use it, like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public class Promise&lt;T&gt; {<br>&gt;&gt;&gt;         private var handlers: [T -&gt; ()] = []<br>&gt;&gt;&gt;         private var completed: T? = nil<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;         public init() {<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;         private func onComplete(handler: T -&gt; ()) {<br>&gt;&gt;&gt;             if let completed = completed {<br>&gt;&gt;&gt;                 handler(completed)<br>&gt;&gt;&gt;             } else {<br>&gt;&gt;&gt;                 handlers.append(handler)<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;         public func complete(t: T) {<br>&gt;&gt;&gt;             completed = t<br>&gt;&gt;&gt;             for handler in handlers {<br>&gt;&gt;&gt;                 handler(t)<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;             handlers = []<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;         public var future: Future&lt;T&gt; {<br>&gt;&gt;&gt;             return Future(promise: self)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public struct Future&lt;T&gt; {<br>&gt;&gt;&gt;         private let promise: Promise&lt;T&gt;<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;         private init(promise: Promise&lt;T&gt;) {<br>&gt;&gt;&gt;             self.promise = promise<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;         public func onComplete(handler: T -&gt; ()) {<br>&gt;&gt;&gt;             promise.onComplete(handler)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public func useFutures() {<br>&gt;&gt;&gt;         downloadURLInFuture().onComplete { content in<br>&gt;&gt;&gt;             processContentAsync(content).onComplete { processed in<br>&gt;&gt;&gt;                 processed.calculateSomethingAsync().onComplete {<br>&gt;&gt;&gt;                     ...<br>&gt;&gt;&gt;                         ...<br>&gt;&gt;&gt;                             print(finalProduct)<br>&gt;&gt;&gt;                         ...<br>&gt;&gt;&gt;                     ...<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can see how this resembles the infamous Node.js issue of callback hell, and how the nesting could quickly get out of hand. If only we had some form of composition... Arrows between Futures... Luckily, Future is a Monad (whether I like it or not!)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // Monad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public extension Future {<br>&gt;&gt;&gt;         public static func point&lt;T&gt;(t: T) -&gt; Future&lt;T&gt; {<br>&gt;&gt;&gt;             let promise = Promise&lt;T&gt;()<br>&gt;&gt;&gt;             promise.complete(t)<br>&gt;&gt;&gt;             return promise.future<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;         public func flatMap&lt;U&gt;(f: T -&gt; Future&lt;U&gt;) -&gt; Future&lt;U&gt; {<br>&gt;&gt;&gt;             let uPromise = Promise&lt;U&gt;()<br>&gt;&gt;&gt;             <br>&gt;&gt;&gt;             onComplete { t in<br>&gt;&gt;&gt;                 f(t).onComplete { u in<br>&gt;&gt;&gt;                     uPromise.complete(u)<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;             <br>&gt;&gt;&gt;             return uPromise.future<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not only do I now get map and apply for free, but I also get a great method of composing Futures. The example from above can now be rewritten to be much more well composed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public func useFutures() {<br>&gt;&gt;&gt;         downloadURLInFuture()<br>&gt;&gt;&gt;             .flatMap(processContentAsync)<br>&gt;&gt;&gt;             .flatMap { $0.calculateSomethingAsync() }<br>&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;             .onComplete { finalProduct in<br>&gt;&gt;&gt;                 print(finalProduct)<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The important thing here is that thinking about Monads helped me discover a better composition model. Now my code can be more readable and well composed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And again, I&#39;ll mention the enormous world of functions and capabilities that can be gotten for free for the sake of even more well-composed code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t want a flatMap on optionals (which, I believe, was thankfully removed in Swift 2).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And why on Earth not? The concrete implementation of it on Optional is very simple and easy to understand, and the method is incredibly useful. Personally, I use it all the time (it was not removed). And again, just because you don&#39;t like using flatMap doesn&#39;t mean Optional isn&#39;t a Monad.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, I&#39;d like to point out that it doesn&#39;t hurt any end users not familiar with Monads if Array implements a higher kinded Monad protocol. As far as they have to be concerned, Array just has these useful map and flatMap functions. Meanwhile, those of us who wish to abstract over Monads in general can write our abstract code and implement Monad on our various types which mathematically have to be Monads. It&#39;s a layer of robustness and improvement that unconcerned end users don&#39;t have to bother themselves with.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While I understand that the Swift team doesn&#39;t have the resources to implement everything that everyone wants, and that HKTs aren&#39;t very high on their list of priorities, it seems unreasonable to me that one could think of HKTs and Monads as somehow detrimental to the language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/4089ac63/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 21, 2016 at 10:00:00am</p></header><div class="content"><p>It never died, the proposal draft is still published for you to comment on before we submit it.  We&#39;d like to have at least a partial implementation to go along with the change because it is so massive, so it&#39;s going to take longer than your average proposal:<br></p><p>https://github.com/typelift/swift/issues/1<br></p><p>~Robert Widmann<br></p><p>2016/01/21 10:36、Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; Did anything become of this…. This seemed to die out with no proposal.<br>&gt; <br>&gt; I would think having a common protocol for types that support monadic operations (regardless if they fulfill all the monadic operations) would generally be helpful — even if they were not implemented theoretically as a Functor / Monad separate protocol definitions.  <br>&gt; <br>&gt; Scala seems to just treat them as one set of operations (MonadOps : map, flatMap, filter, withFilter).  `filter` copies the contents into a new set, `withFilter` is just an on-demand filter for any later functions such as map/flatmap (BTW, Is swift filter on-demand, copy, or a combination???). I do notice that several different implement of the Monad protocol have been done in different repositories - by third parties.  <br>&gt; <br>&gt; And yes, Optionals are monads - and as such can be used in comprehension clauses.<br>&gt; <br>&gt; I know that for-comprehension has been stated as probably not a Swift 3 thing (Felix indicated this but I don’t know where it is stated) - but I am wondering if they are thinking it is larger than it actually is (being that it is just a more friendly way to state existing map/flatmap combinations). If the worry is `for` having dual purpose — but if that is the case maybe making a new keyword for comprehensions like `all`.<br>&gt; <br>&gt; Even if the proposal were drawn up - and it was `Deferred` at least it would potentially be on the radar.<br>&gt; <br>&gt; <br>&gt;&gt; On 2015-12-18, at 1:01:21, André Videla via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m extremely excited about HKT. Huge +1 for me as well. <br>&gt;&gt; <br>&gt;&gt; Moreover, In addition to lots of code reuse, this would allow to extend the language with very expressive and useful syntax for monadic types. <br>&gt;&gt; Monadic comprehension are very useful and generic. <br>&gt;&gt; We could imagine something the for-comprehension in scala and use it with list comprehension as well as parser combinators. <br>&gt;&gt; <br>&gt;&gt; I sincerely hope this feature will see the day. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPod<br>&gt;&gt; On 2015/12/17, at 17:44, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Big +1 for HKTs from me!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 17.12.2015 um 13:10 schrieb Will Fancher via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Optional.map and Array.map do different things, and unifying them seems harmful.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In terms of category theory, they&#39;re not different. They are both arrows from a to b in the Functor category. Obviously that&#39;s horribly abstract, so I&#39;ll put it this way: If you think of these map functions not as operations on Optional and Array, and instead think of them simply as ways to compose an arbitrary data structure, they are in fact doing the same thing. On an implementation level, and on a runtime level, they perform differently. But on a type level, a theoretical level, and a categorical level, they are the same. You merely need to accept that when using this abstraction without knowledge of the concrete type, you have no reason to make any assumptions about how the implementation and runtime will behave. At that point, all you need is to be sure that the Functor being passed in abides by the Functor laws, and that&#39;s just a matter of convention.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; First, I consider myself a smart person with a very broad experience with non-functional languages, but reading this makes my mind hurt, a lot:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    typeclass Functor f where<br>&gt;&gt;&gt;&gt;&gt;&gt;        fmap :: (a -&gt; b) -&gt; f a -&gt; f b<br>&gt;&gt;&gt;&gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; This makes it possible to build functions which operate not just on Maybe, but on any Functor.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    fstrlen :: Functor f =&gt; f String -&gt; f Int<br>&gt;&gt;&gt;&gt;&gt;&gt;    fstrlen fstr = fmap length faster<br>&gt;&gt;&gt;&gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;    protocol Functor {<br>&gt;&gt;&gt;&gt;&gt;&gt;        typealias A<br>&gt;&gt;&gt;&gt;&gt;&gt;        func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I understand what&#39;s going on here, but I never, ever want to see this code anywhere near (my) Swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; HKTs that come from category theory tend to have this effect. They are hard to understand by reading the protocol definition. Admittedly, this is a big flaw with Monads and with Haskell. It takes a reasonable understanding of category theory for the purpose of this code to be obvious to the reader.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (I will point out that in those code examples, I used absolutely abysmal naming conventions. It could be made marginally more readable and understandable if the naming were better)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ll take this time to make the point that just because you don&#39;t like the way the Functor protocol looks, doesn&#39;t mean Array and Optional aren&#39;t both Functors and Monads. As a matter of mathematics, if the Monad functions can exist on a type, and they would follow the Monad laws, that type is a Monad whether the implementor likes it or not. Of course it still needs manual implementing, but regardless, the type is theoretically a Monad. (This realization is the reason that the Java team decided to implement flatMap for Java 8&#39;s Optional class.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I believe the way to convince the rest of us (and I would love to be convinced) is to provide a few real, “end-user” app-level use cases and explain the benefit in plain language. In particular, I don&#39;t understand the example by Jens Persson, although it seems like a valuable one.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can (again) link to just a few of the abstract Monadic functions, all of which are very useful in practical applications.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But perhaps it would also help to describe the architectural decisions that abiding by Monad imposes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Being Monadic makes you think about data composition, which cleans up the way you design your code. Going back to the Futures example, I could implement future, and subsequently use it, like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     public class Promise&lt;T&gt; {<br>&gt;&gt;&gt;&gt;         private var handlers: [T -&gt; ()] = []<br>&gt;&gt;&gt;&gt;         private var completed: T? = nil<br>&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;         public init() {<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;         private func onComplete(handler: T -&gt; ()) {<br>&gt;&gt;&gt;&gt;             if let completed = completed {<br>&gt;&gt;&gt;&gt;                 handler(completed)<br>&gt;&gt;&gt;&gt;             } else {<br>&gt;&gt;&gt;&gt;                 handlers.append(handler)<br>&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;         public func complete(t: T) {<br>&gt;&gt;&gt;&gt;             completed = t<br>&gt;&gt;&gt;&gt;             for handler in handlers {<br>&gt;&gt;&gt;&gt;                 handler(t)<br>&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;             handlers = []<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;         public var future: Future&lt;T&gt; {<br>&gt;&gt;&gt;&gt;             return Future(promise: self)<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     public struct Future&lt;T&gt; {<br>&gt;&gt;&gt;&gt;         private let promise: Promise&lt;T&gt;<br>&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;         private init(promise: Promise&lt;T&gt;) {<br>&gt;&gt;&gt;&gt;             self.promise = promise<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;         public func onComplete(handler: T -&gt; ()) {<br>&gt;&gt;&gt;&gt;             promise.onComplete(handler)<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     public func useFutures() {<br>&gt;&gt;&gt;&gt;         downloadURLInFuture().onComplete { content in<br>&gt;&gt;&gt;&gt;             processContentAsync(content).onComplete { processed in<br>&gt;&gt;&gt;&gt;                 processed.calculateSomethingAsync().onComplete {<br>&gt;&gt;&gt;&gt;                     ...<br>&gt;&gt;&gt;&gt;                         ...<br>&gt;&gt;&gt;&gt;                             print(finalProduct)<br>&gt;&gt;&gt;&gt;                         ...<br>&gt;&gt;&gt;&gt;                     ...<br>&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You can see how this resembles the infamous Node.js issue of callback hell, and how the nesting could quickly get out of hand. If only we had some form of composition... Arrows between Futures... Luckily, Future is a Monad (whether I like it or not!)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     // Monad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     public extension Future {<br>&gt;&gt;&gt;&gt;         public static func point&lt;T&gt;(t: T) -&gt; Future&lt;T&gt; {<br>&gt;&gt;&gt;&gt;             let promise = Promise&lt;T&gt;()<br>&gt;&gt;&gt;&gt;             promise.complete(t)<br>&gt;&gt;&gt;&gt;             return promise.future<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;         public func flatMap&lt;U&gt;(f: T -&gt; Future&lt;U&gt;) -&gt; Future&lt;U&gt; {<br>&gt;&gt;&gt;&gt;             let uPromise = Promise&lt;U&gt;()<br>&gt;&gt;&gt;&gt;             <br>&gt;&gt;&gt;&gt;             onComplete { t in<br>&gt;&gt;&gt;&gt;                 f(t).onComplete { u in<br>&gt;&gt;&gt;&gt;                     uPromise.complete(u)<br>&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;             <br>&gt;&gt;&gt;&gt;             return uPromise.future<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not only do I now get map and apply for free, but I also get a great method of composing Futures. The example from above can now be rewritten to be much more well composed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     public func useFutures() {<br>&gt;&gt;&gt;&gt;         downloadURLInFuture()<br>&gt;&gt;&gt;&gt;             .flatMap(processContentAsync)<br>&gt;&gt;&gt;&gt;             .flatMap { $0.calculateSomethingAsync() }<br>&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;             .onComplete { finalProduct in<br>&gt;&gt;&gt;&gt;                 print(finalProduct)<br>&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The important thing here is that thinking about Monads helped me discover a better composition model. Now my code can be more readable and well composed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And again, I&#39;ll mention the enormous world of functions and capabilities that can be gotten for free for the sake of even more well-composed code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t want a flatMap on optionals (which, I believe, was thankfully removed in Swift 2).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And why on Earth not? The concrete implementation of it on Optional is very simple and easy to understand, and the method is incredibly useful. Personally, I use it all the time (it was not removed). And again, just because you don&#39;t like using flatMap doesn&#39;t mean Optional isn&#39;t a Monad.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Finally, I&#39;d like to point out that it doesn&#39;t hurt any end users not familiar with Monads if Array implements a higher kinded Monad protocol. As far as they have to be concerned, Array just has these useful map and flatMap functions. Meanwhile, those of us who wish to abstract over Monads in general can write our abstract code and implement Monad on our various types which mathematically have to be Monads. It&#39;s a layer of robustness and improvement that unconcerned end users don&#39;t have to bother themselves with.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While I understand that the Swift team doesn&#39;t have the resources to implement everything that everyone wants, and that HKTs aren&#39;t very high on their list of priorities, it seems unreasonable to me that one could think of HKTs and Monads as somehow detrimental to the language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/8dec6124/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 21, 2016 at 10:00:00pm</p></header><div class="content"><p>Great, Thanks!<br></p><p>&gt; On 2016-01-21, at 22:52:46, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; It never died, the proposal draft is still published for you to comment on before we submit it.  We&#39;d like to have at least a partial implementation to go along with the change because it is so massive, so it&#39;s going to take longer than your average proposal:<br>&gt; <br>&gt; https://github.com/typelift/swift/issues/1 &lt;https://github.com/typelift/swift/issues/1&gt;<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/01/21 10:36、Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; Did anything become of this…. This seemed to die out with no proposal.<br>&gt;&gt; <br>&gt;&gt; I would think having a common protocol for types that support monadic operations (regardless if they fulfill all the monadic operations) would generally be helpful — even if they were not implemented theoretically as a Functor / Monad separate protocol definitions.  <br>&gt;&gt; <br>&gt;&gt; Scala seems to just treat them as one set of operations (MonadOps : map, flatMap, filter, withFilter).  `filter` copies the contents into a new set, `withFilter` is just an on-demand filter for any later functions such as map/flatmap (BTW, Is swift filter on-demand, copy, or a combination???). I do notice that several different implement of the Monad protocol have been done in different repositories - by third parties.  <br>&gt;&gt; <br>&gt;&gt; And yes, Optionals are monads - and as such can be used in comprehension clauses.<br>&gt;&gt; <br>&gt;&gt; I know that for-comprehension has been stated as probably not a Swift 3 thing (Felix indicated this but I don’t know where it is stated) - but I am wondering if they are thinking it is larger than it actually is (being that it is just a more friendly way to state existing map/flatmap combinations). If the worry is `for` having dual purpose — but if that is the case maybe making a new keyword for comprehensions like `all`.<br>&gt;&gt; <br>&gt;&gt; Even if the proposal were drawn up - and it was `Deferred` at least it would potentially be on the radar.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 2015-12-18, at 1:01:21, André Videla via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m extremely excited about HKT. Huge +1 for me as well. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Moreover, In addition to lots of code reuse, this would allow to extend the language with very expressive and useful syntax for monadic types. <br>&gt;&gt;&gt; Monadic comprehension are very useful and generic. <br>&gt;&gt;&gt; We could imagine something the for-comprehension in scala and use it with list comprehension as well as parser combinators. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I sincerely hope this feature will see the day. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPod<br>&gt;&gt;&gt; On 2015/12/17, at 17:44, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Big +1 for HKTs from me!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 17.12.2015 um 13:10 schrieb Will Fancher via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Optional.map and Array.map do different things, and unifying them seems harmful.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In terms of category theory, they&#39;re not different. They are both arrows from a to b in the Functor category. Obviously that&#39;s horribly abstract, so I&#39;ll put it this way: If you think of these map functions not as operations on Optional and Array, and instead think of them simply as ways to compose an arbitrary data structure, they are in fact doing the same thing. On an implementation level, and on a runtime level, they perform differently. But on a type level, a theoretical level, and a categorical level, they are the same. You merely need to accept that when using this abstraction without knowledge of the concrete type, you have no reason to make any assumptions about how the implementation and runtime will behave. At that point, all you need is to be sure that the Functor being passed in abides by the Functor laws, and that&#39;s just a matter of convention.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; First, I consider myself a smart person with a very broad experience with non-functional languages, but reading this makes my mind hurt, a lot:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    typeclass Functor f where<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;        fmap :: (a -&gt; b) -&gt; f a -&gt; f b<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This makes it possible to build functions which operate not just on Maybe, but on any Functor.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    fstrlen :: Functor f =&gt; f String -&gt; f Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    fstrlen fstr = fmap length faster<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    protocol Functor {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;        typealias A<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;        func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I understand what&#39;s going on here, but I never, ever want to see this code anywhere near (my) Swift.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; HKTs that come from category theory tend to have this effect. They are hard to understand by reading the protocol definition. Admittedly, this is a big flaw with Monads and with Haskell. It takes a reasonable understanding of category theory for the purpose of this code to be obvious to the reader.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (I will point out that in those code examples, I used absolutely abysmal naming conventions. It could be made marginally more readable and understandable if the naming were better)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;ll take this time to make the point that just because you don&#39;t like the way the Functor protocol looks, doesn&#39;t mean Array and Optional aren&#39;t both Functors and Monads. As a matter of mathematics, if the Monad functions can exist on a type, and they would follow the Monad laws, that type is a Monad whether the implementor likes it or not. Of course it still needs manual implementing, but regardless, the type is theoretically a Monad. (This realization is the reason that the Java team decided to implement flatMap for Java 8&#39;s Optional class.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I believe the way to convince the rest of us (and I would love to be convinced) is to provide a few real, “end-user” app-level use cases and explain the benefit in plain language. In particular, I don&#39;t understand the example by Jens Persson, although it seems like a valuable one.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I can (again) link to just a few of the abstract Monadic functions, all of which are very useful in practical applications.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html &lt;https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But perhaps it would also help to describe the architectural decisions that abiding by Monad imposes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Being Monadic makes you think about data composition, which cleans up the way you design your code. Going back to the Futures example, I could implement future, and subsequently use it, like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     public class Promise&lt;T&gt; {<br>&gt;&gt;&gt;&gt;&gt;         private var handlers: [T -&gt; ()] = []<br>&gt;&gt;&gt;&gt;&gt;         private var completed: T? = nil<br>&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;         public init() {<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;         private func onComplete(handler: T -&gt; ()) {<br>&gt;&gt;&gt;&gt;&gt;             if let completed = completed {<br>&gt;&gt;&gt;&gt;&gt;                 handler(completed)<br>&gt;&gt;&gt;&gt;&gt;             } else {<br>&gt;&gt;&gt;&gt;&gt;                 handlers.append(handler)<br>&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;         public func complete(t: T) {<br>&gt;&gt;&gt;&gt;&gt;             completed = t<br>&gt;&gt;&gt;&gt;&gt;             for handler in handlers {<br>&gt;&gt;&gt;&gt;&gt;                 handler(t)<br>&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;             handlers = []<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;         public var future: Future&lt;T&gt; {<br>&gt;&gt;&gt;&gt;&gt;             return Future(promise: self)<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     public struct Future&lt;T&gt; {<br>&gt;&gt;&gt;&gt;&gt;         private let promise: Promise&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;         private init(promise: Promise&lt;T&gt;) {<br>&gt;&gt;&gt;&gt;&gt;             self.promise = promise<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;         public func onComplete(handler: T -&gt; ()) {<br>&gt;&gt;&gt;&gt;&gt;             promise.onComplete(handler)<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     public func useFutures() {<br>&gt;&gt;&gt;&gt;&gt;         downloadURLInFuture().onComplete { content in<br>&gt;&gt;&gt;&gt;&gt;             processContentAsync(content).onComplete { processed in<br>&gt;&gt;&gt;&gt;&gt;                 processed.calculateSomethingAsync().onComplete {<br>&gt;&gt;&gt;&gt;&gt;                     ...<br>&gt;&gt;&gt;&gt;&gt;                         ...<br>&gt;&gt;&gt;&gt;&gt;                             print(finalProduct)<br>&gt;&gt;&gt;&gt;&gt;                         ...<br>&gt;&gt;&gt;&gt;&gt;                     ...<br>&gt;&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You can see how this resembles the infamous Node.js issue of callback hell, and how the nesting could quickly get out of hand. If only we had some form of composition... Arrows between Futures... Luckily, Future is a Monad (whether I like it or not!)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     // Monad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     public extension Future {<br>&gt;&gt;&gt;&gt;&gt;         public static func point&lt;T&gt;(t: T) -&gt; Future&lt;T&gt; {<br>&gt;&gt;&gt;&gt;&gt;             let promise = Promise&lt;T&gt;()<br>&gt;&gt;&gt;&gt;&gt;             promise.complete(t)<br>&gt;&gt;&gt;&gt;&gt;             return promise.future<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;         public func flatMap&lt;U&gt;(f: T -&gt; Future&lt;U&gt;) -&gt; Future&lt;U&gt; {<br>&gt;&gt;&gt;&gt;&gt;             let uPromise = Promise&lt;U&gt;()<br>&gt;&gt;&gt;&gt;&gt;             <br>&gt;&gt;&gt;&gt;&gt;             onComplete { t in<br>&gt;&gt;&gt;&gt;&gt;                 f(t).onComplete { u in<br>&gt;&gt;&gt;&gt;&gt;                     uPromise.complete(u)<br>&gt;&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;             <br>&gt;&gt;&gt;&gt;&gt;             return uPromise.future<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Not only do I now get map and apply for free, but I also get a great method of composing Futures. The example from above can now be rewritten to be much more well composed.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     public func useFutures() {<br>&gt;&gt;&gt;&gt;&gt;         downloadURLInFuture()<br>&gt;&gt;&gt;&gt;&gt;             .flatMap(processContentAsync)<br>&gt;&gt;&gt;&gt;&gt;             .flatMap { $0.calculateSomethingAsync() }<br>&gt;&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;&gt;             .onComplete { finalProduct in<br>&gt;&gt;&gt;&gt;&gt;                 print(finalProduct)<br>&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The important thing here is that thinking about Monads helped me discover a better composition model. Now my code can be more readable and well composed.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And again, I&#39;ll mention the enormous world of functions and capabilities that can be gotten for free for the sake of even more well-composed code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t want a flatMap on optionals (which, I believe, was thankfully removed in Swift 2).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And why on Earth not? The concrete implementation of it on Optional is very simple and easy to understand, and the method is incredibly useful. Personally, I use it all the time (it was not removed). And again, just because you don&#39;t like using flatMap doesn&#39;t mean Optional isn&#39;t a Monad.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Finally, I&#39;d like to point out that it doesn&#39;t hurt any end users not familiar with Monads if Array implements a higher kinded Monad protocol. As far as they have to be concerned, Array just has these useful map and flatMap functions. Meanwhile, those of us who wish to abstract over Monads in general can write our abstract code and implement Monad on our various types which mathematically have to be Monads. It&#39;s a layer of robustness and improvement that unconcerned end users don&#39;t have to bother themselves with.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; While I understand that the Swift team doesn&#39;t have the resources to implement everything that everyone wants, and that HKTs aren&#39;t very high on their list of priorities, it seems unreasonable to me that one could think of HKTs and Monads as somehow detrimental to the language.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/3d6feda4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2ff1daab58cd5e44a457908d1905c322?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Krzysztof Siejkowski</string> &lt;krzysztof at siejkowski.net&gt;<p>December 17, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; Optional.map and Array.map do different things, and unifying them seems harmful.<br></p><p>They actually don’t do different things. Optional can be thought of as an array of zero or one elements; from that point of view, operations like `map` and `flatMap` which are supported on both actually do the same thing.<br></p><p><br>This discussion convinces me to vote -1 for the HKTs in standard library. <br></p><p><br></p><p>For the programmers without functional programming background HKTs gonna be misleading and non-readable. A thousand similar analogies: &quot;&lt;OneMonad&gt; can be seen as &lt;OtherMonad&gt;&quot; will need to be made. Those analogies are gonna break (for example, how would one explain monad transformers in those terms?) and lead to even more confusion. <br></p><p><br></p><p>As long as the underlying theory is not widely adopted, I think HKTs should be provided by third-party libraries (like swiftz). Swift should just provide generics sophisticated enough to express the those concepts. Scala language uses similar approach (no HKTs in standard library, great generics) with success (scalaz, shapeless libraries).<br></p><p><br></p><p><br></p><p>Krzysztof<br></p><p><br></p><p><br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/45459e9d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Higher Kinded Types (Monads, Functors, etc.)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 17, 2015 at 04:00:00am</p></header><div class="content"><p>&gt; For the programmers without functional programming background HKTs gonna be misleading and non-readable. A thousand similar analogies: &quot;&lt;OneMonad&gt; can be seen as &lt;OtherMonad&gt;&quot; will need to be made. Those analogies are gonna break (for example, how would one explain monad transformers in those terms?) and lead to even more confusion. <br></p><p>Believe it or not, I’m actually *not* one of the functional astronauts who believes everything is a `map`. I can sometimes understand what they’re getting at, usually after reading about a dozen different “simple” explanations of a concept, but I think the human factors on the foundations of functional programming are an unmitigated disaster, and that many functional programmers are in deep denial about that. That’s why, when I wrote a Result type, I didn’t give it `map` and `flatMap` operations; I called them `convert` and `then`, to at least try to give some indication of what they actually mean in your code.<br></p><p>Nevertheless, I think the functional view is *useful* and *powerful* so long as it’s also *optional*. Swift should not start emitting sarcastic error messages about monoids in the category of endofunctors, but that doesn’t mean it shouldn’t *permit* people to use these things when they want to.<br></p><p>Support for higher-kinded types merely means that Swift will permit people to do weird abstract functional programming—and a few neat tricks that are more down-to-earth, like a collection-type-preserving `map`—if they want to. It won’t mean *you* will have to. I don’t think this feature is urgent, but I hope it’s supported eventually.<br></p><p>And I hope someone figures out a better name than “monad”. Ugh.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
