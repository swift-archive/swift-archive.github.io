<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[Idea] Passing an Array to Variadic Functions</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>April 18, 2016 at 06:00:00pm</p></header><div class="content"><p>Justin Jia via swift-evolution &lt;swift-evolution at ...&gt; writes:<br></p><p>&gt; <br>&gt; Hi!Currently, we can’t call a variadic function with an array of arguments.<br></p><p>IMO, this would be a useful addition. Here are my thoughts on the thread so<br>far as an imaginary Q&amp;A.<br></p><p>&quot;Why not remove vararg instead?&quot;<br></p><p>As others have mentioned, this feature enable us to write cleaner code. I<br>first learned to appreciate it in C, where some books would introduce it as the<br>way to implement printf(). I really prefer not to create an array on unrelated<br>items just to print() them in Swift.<br></p><p>&quot;Will it be useful in real life?&quot;<br></p><p>If we keep vararg, then enhancing it with a splat feature will make it far<br>more useful than it is today. One of my colleague (hi Scott!) encountered its<br>limits just last week: once the varadic argumntes becomes an array, there&#39;s no<br>way to get them &quot;back&quot; as arguments. This becomes an issue if our function<br>needs to forward part of its received arguments recursively to itself. Either<br>of the following would be great:<br></p><p>func foo(a: Int...) {<br>    if !a.isEmpty() {<br>        apply(foo, a.dropFirst()) // imaginary apply function.<br>        foo(a: #splat(a.dropFirst())) // imaginary splat, syntax TBD.<br>    }<br>}<br></p><p><br>Therefore, +1.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Idea] Passing an Array to Variadic Functions</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 18, 2016 at 10:00:00pm</p></header><div class="content"><p>About print() and similar: this should be (in case we remove variadic <br>params) overloaded functions with different number of params.<br></p><p>func print()<br>func print(v1: Any)<br>func pring(v1, v2: Any) etc<br></p><p>As for #splat. Should we have such problems in working with params or <br>should we introduce one more layer of &quot;collection of params&quot; and methods <br>for it, instead of explicit use of array of params?<br></p><p>And do you like implicit tuple splat in method/functions? ;-)<br></p><p>In case the most of us supports variadic params : Should we introduce some <br>special marker to mark them in code? I feel that we just need such a way to <br>tell that &quot;we are calling this method with variadic params&quot;, this will be <br>in Swift way.<br>For example select(: id, name, count) or in some other way.<br>(or select(* id, name, count) or select(# id, name, count).. hm.. just like <br>in &quot;Alternatives considered&quot; in SE-0029 with comment:<br>foo(*x)    // NOT a serious syntax proposal)<br></p><p>P.S. As currently we did remove C-like for(;;) loops and ++ - don&#39;t think <br>that this &quot;variadic params&quot; feature that is coming from the same C should <br>exists in language. Otherwise I can&#39;t feel that Swift team is consistent.<br></p><p><br>On 18.04.2016 21:14, Daniel Duan via swift-evolution wrote:<br>&gt; Justin Jia via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Hi!Currently, we can’t call a variadic function with an array of arguments.<br>&gt;<br>&gt; IMO, this would be a useful addition. Here are my thoughts on the thread so<br>&gt; far as an imaginary Q&amp;A.<br>&gt;<br>&gt; &quot;Why not remove vararg instead?&quot;<br>&gt;<br>&gt; As others have mentioned, this feature enable us to write cleaner code. I<br>&gt; first learned to appreciate it in C, where some books would introduce it as the<br>&gt; way to implement printf(). I really prefer not to create an array on unrelated<br>&gt; items just to print() them in Swift.<br>&gt;<br>&gt; &quot;Will it be useful in real life?&quot;<br>&gt;<br>&gt; If we keep vararg, then enhancing it with a splat feature will make it far<br>&gt; more useful than it is today. One of my colleague (hi Scott!) encountered its<br>&gt; limits just last week: once the varadic argumntes becomes an array, there&#39;s no<br>&gt; way to get them &quot;back&quot; as arguments. This becomes an issue if our function<br>&gt; needs to forward part of its received arguments recursively to itself. Either<br>&gt; of the following would be great:<br>&gt;<br>&gt; func foo(a: Int...) {<br>&gt;     if !a.isEmpty() {<br>&gt;         apply(foo, a.dropFirst()) // imaginary apply function.<br>&gt;         foo(a: #splat(a.dropFirst())) // imaginary splat, syntax TBD.<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Therefore, +1.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Idea] Passing an Array to Variadic Functions</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>April 18, 2016 at 07:00:00pm</p></header><div class="content"><p>I would also be supportive of removing varargs for now, in favor of a<br>rethought design when generics are completed.<br></p><p>In their current form, varargs are fairly limited—because they&#39;re mapped<br>onto an array, the argument types must be homogeneous, so either your<br>function can only usefully take a single type of argument, or you<br>potentially lose information because they have to be upcast to a common<br>supertype or Any in order to build the array.<br></p><p>I&#39;m not convinced that varargs produce code that is much cleaner than the<br>array version. Is this:<br></p><p>  String(format: &quot;%@ is %d years old&quot;, name, age)<br></p><p>that much cleaner than:<br></p><p>  String(format: &quot;%@ is %d years old&quot;, arguments: [name, age])<br></p><p>Perhaps slightly, but I&#39;m not sure it&#39;s worth the special case. The<br>function implementor can even get rid of the second argument name if they<br>wanted to make it cleaner. And if the function you&#39;re calling takes varargs<br>as its sole argument, the only difference is two brackets.<br></p><p>Varargs in their current form seem like a historical vestige from languages<br>like C and Java where there was no syntax to cleanly create an anonymous<br>array literal. Swift doesn&#39;t have that limitation.<br></p><p>That being said, where varargs *do* become considerably more useful is when<br>generics are completed and you can have variadic type argument lists. But<br>in that case, the implementation is completely different because (if Swift<br>followed C++&#39;s design) you&#39;d be working with a parameter pack instead of an<br>array, and you would have operations that let you manipulate that pack<br>while preserving the compile-time type information of those arguments.<br></p><p>IMO, handling it that way seems like a better approach than trying to graft<br>something to bridge varargs and arrays.<br></p><p><br></p><p>On Mon, Apr 18, 2016 at 11:14 AM Daniel Duan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Justin Jia via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;<br>&gt; &gt;<br>&gt; &gt; Hi!Currently, we can’t call a variadic function with an array of<br>&gt; arguments.<br>&gt;<br>&gt; IMO, this would be a useful addition. Here are my thoughts on the thread so<br>&gt; far as an imaginary Q&amp;A.<br>&gt;<br>&gt; &quot;Why not remove vararg instead?&quot;<br>&gt;<br>&gt; As others have mentioned, this feature enable us to write cleaner code. I<br>&gt; first learned to appreciate it in C, where some books would introduce it<br>&gt; as the<br>&gt; way to implement printf(). I really prefer not to create an array on<br>&gt; unrelated<br>&gt; items just to print() them in Swift.<br>&gt;<br>&gt; &quot;Will it be useful in real life?&quot;<br>&gt;<br>&gt; If we keep vararg, then enhancing it with a splat feature will make it far<br>&gt; more useful than it is today. One of my colleague (hi Scott!) encountered<br>&gt; its<br>&gt; limits just last week: once the varadic argumntes becomes an array,<br>&gt; there&#39;s no<br>&gt; way to get them &quot;back&quot; as arguments. This becomes an issue if our function<br>&gt; needs to forward part of its received arguments recursively to itself.<br>&gt; Either<br>&gt; of the following would be great:<br>&gt;<br>&gt; func foo(a: Int...) {<br>&gt;     if !a.isEmpty() {<br>&gt;         apply(foo, a.dropFirst()) // imaginary apply function.<br>&gt;         foo(a: #splat(a.dropFirst())) // imaginary splat, syntax TBD.<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Therefore, +1.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160418/7305af10/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Idea] Passing an Array to Variadic Functions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 18, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Apr 18, 2016, at 1:01 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would also be supportive of removing varargs for now, in favor of a rethought design when generics are completed.<br>&gt; <br>&gt; In their current form, varargs are fairly limited—because they&#39;re mapped onto an array, the argument types must be homogeneous, so either your function can only usefully take a single type of argument, or you potentially lose information because they have to be upcast to a common supertype or Any in order to build the array.<br>&gt; <br>&gt; I&#39;m not convinced that varargs produce code that is much cleaner than the array version. Is this:<br>&gt; <br>&gt;   String(format: &quot;%@ is %d years old&quot;, name, age)<br>&gt; <br>&gt; that much cleaner than:<br>&gt; <br>&gt;   String(format: &quot;%@ is %d years old&quot;, arguments: [name, age])<br></p><p>I would like to see format strings go away and be replace with safer inline annotations.<br></p><p>-- E, somewhat agnostic on variadics<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Idea] Passing an Array to Variadic Functions</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>April 18, 2016 at 08:00:00pm</p></header><div class="content"><p>Let&#39;s build strings the same way we log.... String(&quot;\(authorOfAutoLayoutMasterBook) could you please show \(canICountHowMany) times more love to \(ToolThatBuildsInterfaces) :)&quot;) ^_^ ?<br></p><p><br></p><p>[[iOS messageWithData:ideas] broadcast]<br></p><p>&gt; On 18 Apr 2016, at 20:06, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 18, 2016, at 1:01 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I would also be supportive of removing varargs for now, in favor of a rethought design when generics are completed.<br>&gt;&gt; <br>&gt;&gt; In their current form, varargs are fairly limited—because they&#39;re mapped onto an array, the argument types must be homogeneous, so either your function can only usefully take a single type of argument, or you potentially lose information because they have to be upcast to a common supertype or Any in order to build the array.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not convinced that varargs produce code that is much cleaner than the array version. Is this:<br>&gt;&gt; <br>&gt;&gt;  String(format: &quot;%@ is %d years old&quot;, name, age)<br>&gt;&gt; <br>&gt;&gt; that much cleaner than:<br>&gt;&gt; <br>&gt;&gt;  String(format: &quot;%@ is %d years old&quot;, arguments: [name, age])<br>&gt; <br>&gt; I would like to see format strings go away and be replace with safer inline annotations.<br>&gt; <br>&gt; -- E, somewhat agnostic on variadics<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Idea] Passing an Array to Variadic Functions</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>April 18, 2016 at 03:00:00pm</p></header><div class="content"><p>What would that look like?<br></p><p><br></p><p>&gt; On Apr 18, 2016, at 3:06 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 18, 2016, at 1:01 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I would also be supportive of removing varargs for now, in favor of a rethought design when generics are completed.<br>&gt;&gt; <br>&gt;&gt; In their current form, varargs are fairly limited—because they&#39;re mapped onto an array, the argument types must be homogeneous, so either your function can only usefully take a single type of argument, or you potentially lose information because they have to be upcast to a common supertype or Any in order to build the array.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not convinced that varargs produce code that is much cleaner than the array version. Is this:<br>&gt;&gt; <br>&gt;&gt;  String(format: &quot;%@ is %d years old&quot;, name, age)<br>&gt;&gt; <br>&gt;&gt; that much cleaner than:<br>&gt;&gt; <br>&gt;&gt;  String(format: &quot;%@ is %d years old&quot;, arguments: [name, age])<br>&gt; <br>&gt; I would like to see format strings go away and be replace with safer inline annotations.<br>&gt; <br>&gt; -- E, somewhat agnostic on variadics<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Idea] Passing an Array to Variadic Functions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 18, 2016 at 01:00:00pm</p></header><div class="content"><p>This is why god gave us bike sheds.<br></p><p>Maybe &quot;My earned interest rate this year is \({02.2}theRate)%!&quot;<br></p><p>-- E<br></p><p><br>&gt; On Apr 18, 2016, at 1:23 PM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt; <br>&gt; What would that look like?<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Apr 18, 2016, at 3:06 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 18, 2016, at 1:01 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would also be supportive of removing varargs for now, in favor of a rethought design when generics are completed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In their current form, varargs are fairly limited—because they&#39;re mapped onto an array, the argument types must be homogeneous, so either your function can only usefully take a single type of argument, or you potentially lose information because they have to be upcast to a common supertype or Any in order to build the array.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not convinced that varargs produce code that is much cleaner than the array version. Is this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; String(format: &quot;%@ is %d years old&quot;, name, age)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; that much cleaner than:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; String(format: &quot;%@ is %d years old&quot;, arguments: [name, age])<br>&gt;&gt; <br>&gt;&gt; I would like to see format strings go away and be replace with safer inline annotations.<br>&gt;&gt; <br>&gt;&gt; -- E, somewhat agnostic on variadics<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Idea] Passing an Array to Variadic Functions</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>April 18, 2016 at 07:00:00pm</p></header><div class="content"><p>Part of me regrets using String(format:) as my go to example of a varargs<br>invocation now. :)<br></p><p>But while the train is off the rails, why introduce a special syntax at<br>all? Since interpolation can include any expression, users can just write<br>small formatting functions and call them there.<br></p><p>Pros: We can standardize a few in stdlib, and it would be more extensible<br>than learning yet another string formatting language.<br>Cons: Likely to be more verbose than printf-like descriptors.<br></p><p><br>On Mon, Apr 18, 2016 at 12:27 PM Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This is why god gave us bike sheds.<br>&gt;<br>&gt; Maybe &quot;My earned interest rate this year is \({02.2}theRate)%!&quot;<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; &gt; On Apr 18, 2016, at 1:23 PM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; What would that look like?<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Apr 18, 2016, at 3:06 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Apr 18, 2016, at 1:01 PM, Tony Allevato via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I would also be supportive of removing varargs for now, in favor of a<br>&gt; rethought design when generics are completed.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; In their current form, varargs are fairly limited—because they&#39;re<br>&gt; mapped onto an array, the argument types must be homogeneous, so either<br>&gt; your function can only usefully take a single type of argument, or you<br>&gt; potentially lose information because they have to be upcast to a common<br>&gt; supertype or Any in order to build the array.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I&#39;m not convinced that varargs produce code that is much cleaner than<br>&gt; the array version. Is this:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; String(format: &quot;%@ is %d years old&quot;, name, age)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; that much cleaner than:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; String(format: &quot;%@ is %d years old&quot;, arguments: [name, age])<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I would like to see format strings go away and be replace with safer<br>&gt; inline annotations.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -- E, somewhat agnostic on variadics<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160418/d2d282f5/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Idea] Passing an Array to Variadic Functions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 18, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; I would like to see format strings go away and be replace with safer inline annotations.<br></p><p>The main problem is doing localized strings with printf-style formats well, but I actually have a pretty sweet solution for that: https://gist.github.com/brentdax/79fa038c0af0cafb52dd<br></p><p>&gt; -- E, somewhat agnostic on variadics<br></p><p>Variadics are eventually important as a generic function feature; you really want to be able to write a version of zip() which can take any number of sequences, for instance, and the only reasonable way to do that is to pass a variable number of parameters and return a sequence with a matchingly variable number of type parameters.<br></p><p>Today, they are important in that they bootstrap ArrayLiteralConvertible and DictionaryLiteralConvertible by (at least theoretically) acting as a pass-N-items mechanism that doesn&#39;t depend on one of the standard library types defined in terms of it. (If we convert them to show up as tuples once we have tuple subscripting syntax, that will even become true.) Less esoterically, they&#39;re used in several places where an Array would be inconvenient or break traditions:<br></p><p>* The `print` function&#39;s list of items to print is variadic. An array equivalent would look like `print([one, two, three])`.<br>* The `min` and `max` functions are more convenient than explicitly constructing an array and calling their `min()` and `max()` methods.<br>* And, yes, `String.init(format:_:)`, which we will probably never be quite rid of for compatibility reasons.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec8a60462a511e833c5c4a83b424c958?s=50"></div><header><strong>[Idea] Passing an Array to Variadic Functions</strong> from <string>Dennis Weissmann</string> &lt;dennis at dennisweissmann.me&gt;<p>April 18, 2016 at 10:00:00pm</p></header><div class="content"><p>- Dennis<br></p><p>&gt; On Apr 18, 2016, at 9:55 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I would like to see format strings go away and be replace with safer inline annotations.<br>&gt; <br>&gt; The main problem is doing localized strings with printf-style formats well, but I actually have a pretty sweet solution for that: https://gist.github.com/brentdax/79fa038c0af0cafb52dd<br>&gt; <br>&gt;&gt; -- E, somewhat agnostic on variadics<br>&gt; <br>&gt; Variadics are eventually important as a generic function feature; you really want to be able to write a version of zip() which can take any number of sequences, for instance, and the only reasonable way to do that is to pass a variable number of parameters and return a sequence with a matchingly variable number of type parameters.<br>&gt; <br>Which brings us to dependent types :)<br></p><p>&gt; Today, they are important in that they bootstrap ArrayLiteralConvertible and DictionaryLiteralConvertible by (at least theoretically) acting as a pass-N-items mechanism that doesn&#39;t depend on one of the standard library types defined in terms of it. (If we convert them to show up as tuples once we have tuple subscripting syntax, that will even become true.) Less esoterically, they&#39;re used in several places where an Array would be inconvenient or break traditions:<br>&gt; <br>&gt; * The `print` function&#39;s list of items to print is variadic. An array equivalent would look like `print([one, two, three])`.<br>&gt; * The `min` and `max` functions are more convenient than explicitly constructing an array and calling their `min()` and `max()` methods.<br>&gt; * And, yes, `String.init(format:_:)`, which we will probably never be quite rid of for compatibility reasons.<br>&gt; <br>All those points are also perfectly solved by dependent types (which is definitely not in the time frame of Swift 3 or even Swift 4).<br>But I think in the long term we should get rid of varargs and Swift 3 (as far as I remember) is the last version of Swift to remove functionality from the language (is that actually correct?).<br></p><p>Short-term solutions:<br></p><p>I very very rarely use the print function with multiple parameters. Most of the time I build a single string and use string interpolation to insert values. If there really is a need for multiple arguments to print, like others said, overloads could be generated.<br>min and max: I think most the time they are used to compare 2 values. If there are more than 2 values (or let’s say 3) I think an array is better suited.<br>String.init(format:_:) … I think if all C APIs would get imported by converting varargs to arrays we could get rid of it.<br></p><p>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Idea] Passing an Array to Variadic Functions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; All those points are also perfectly solved by dependent types<br></p><p>How? What does print() or max() or ArrayLiteralConvertible have to do with dependent types?<br></p><p>And what makes you think we&#39;re going to get dependent types, anyway?<br></p><p>&gt; I very very rarely use the print function with multiple parameters. Most of the time I build a single string and use string interpolation to insert values. If there really is a need for multiple arguments to print, like others said, overloads could be generated.<br></p><p>How many? What will that do to the type checker, which can go exponential on the number of overloads?<br></p><p>&gt; min and max: I think most the time they are used to compare 2 values. If there are more than 2 values (or let’s say 3) I think an array is better suited.<br></p><p>Why do you think an array is better suited?<br></p><p>&gt; String.init(format:_:) … I think if all C APIs would get imported by converting varargs to arrays we could get rid of it.<br></p><p>Are you sure that&#39;s actually possible?<br></p><p>And ultimately, why are you so eager to remove this feature? Is there something wrong with it?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Idea] Passing an Array to Variadic Functions</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 19, 2016 at 11:00:00am</p></header><div class="content"><p>Just annotenhere: String intepolation is ok for logging purposes but not for creating user messages which have to be localized (with possibly having to reorder the parameters).<br></p><p>-Thorsten <br></p><p>&gt; Am 18.04.2016 um 22:56 schrieb Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; - Dennis<br>&gt; <br>&gt;&gt;&gt; On Apr 18, 2016, at 9:55 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would like to see format strings go away and be replace with safer inline annotations.<br>&gt;&gt; <br>&gt;&gt; The main problem is doing localized strings with printf-style formats well, but I actually have a pretty sweet solution for that: https://gist.github.com/brentdax/79fa038c0af0cafb52dd<br>&gt;&gt; <br>&gt;&gt;&gt; -- E, somewhat agnostic on variadics<br>&gt;&gt; <br>&gt;&gt; Variadics are eventually important as a generic function feature; you really want to be able to write a version of zip() which can take any number of sequences, for instance, and the only reasonable way to do that is to pass a variable number of parameters and return a sequence with a matchingly variable number of type parameters.<br>&gt;&gt; <br>&gt; Which brings us to dependent types :)<br>&gt; <br>&gt;&gt; Today, they are important in that they bootstrap ArrayLiteralConvertible and DictionaryLiteralConvertible by (at least theoretically) acting as a pass-N-items mechanism that doesn&#39;t depend on one of the standard library types defined in terms of it. (If we convert them to show up as tuples once we have tuple subscripting syntax, that will even become true.) Less esoterically, they&#39;re used in several places where an Array would be inconvenient or break traditions:<br>&gt;&gt; <br>&gt;&gt; * The `print` function&#39;s list of items to print is variadic. An array equivalent would look like `print([one, two, three])`.<br>&gt;&gt; * The `min` and `max` functions are more convenient than explicitly constructing an array and calling their `min()` and `max()` methods.<br>&gt;&gt; * And, yes, `String.init(format:_:)`, which we will probably never be quite rid of for compatibility reasons.<br>&gt;&gt; <br>&gt; All those points are also perfectly solved by dependent types (which is definitely not in the time frame of Swift 3 or even Swift 4).<br>&gt; But I think in the long term we should get rid of varargs and Swift 3 (as far as I remember) is the last version of Swift to remove functionality from the language (is that actually correct?).<br>&gt; <br>&gt; Short-term solutions:<br>&gt; <br>&gt; I very very rarely use the print function with multiple parameters. Most of the time I build a single string and use string interpolation to insert values. If there really is a need for multiple arguments to print, like others said, overloads could be generated.<br>&gt; min and max: I think most the time they are used to compare 2 values. If there are more than 2 values (or let’s say 3) I think an array is better suited.<br>&gt; String.init(format:_:) … I think if all C APIs would get imported by converting varargs to arrays we could get rid of it.<br>&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Idea] Passing an Array to Variadic Functions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 19, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; Just annotenhere: String intepolation is ok for logging purposes but not for creating user messages which have to be localized (with possibly having to reorder the parameters).<br></p><p>Clever use of StringInterpolationConvertible, as demonstrated in my example code, can make it suitable. <br></p><p>Sent from my iPad<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160419/26cc1c58/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[Idea] Passing an Array to Variadic Functions</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>April 19, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 19 Apr 2016, at 10:41, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Just annotenhere: String intepolation is ok for logging purposes but not for creating user messages which have to be localized (with possibly having to reorder the parameters).<br>&gt; <br></p><p>Reordering is not a problem<br></p><p>if language == “fr&quot;<br>{<br>    object = “me”<br>    verb = “lance&quot;<br>}<br>else<br>{<br>    object = “myself”<br>    verb = “throw&quot;<br></p><p>}<br></p><p>“Je \(object) \(verb) vers la gloire”<br>“I \(verb) \(object) towards glory&quot;<br></p><p>There are other issues though (e.g. format should be in the hands of the translator) which mean I would not want to lose format strings.<br></p><p>&gt; -Thorsten <br>&gt; <br>&gt;&gt; Am 18.04.2016 um 22:56 schrieb Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; - Dennis<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 18, 2016, at 9:55 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would like to see format strings go away and be replace with safer inline annotations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The main problem is doing localized strings with printf-style formats well, but I actually have a pretty sweet solution for that: https://gist.github.com/brentdax/79fa038c0af0cafb52dd<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E, somewhat agnostic on variadics<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Variadics are eventually important as a generic function feature; you really want to be able to write a version of zip() which can take any number of sequences, for instance, and the only reasonable way to do that is to pass a variable number of parameters and return a sequence with a matchingly variable number of type parameters.<br>&gt;&gt;&gt; <br>&gt;&gt; Which brings us to dependent types :)<br>&gt;&gt; <br>&gt;&gt;&gt; Today, they are important in that they bootstrap ArrayLiteralConvertible and DictionaryLiteralConvertible by (at least theoretically) acting as a pass-N-items mechanism that doesn&#39;t depend on one of the standard library types defined in terms of it. (If we convert them to show up as tuples once we have tuple subscripting syntax, that will even become true.) Less esoterically, they&#39;re used in several places where an Array would be inconvenient or break traditions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * The `print` function&#39;s list of items to print is variadic. An array equivalent would look like `print([one, two, three])`.<br>&gt;&gt;&gt; * The `min` and `max` functions are more convenient than explicitly constructing an array and calling their `min()` and `max()` methods.<br>&gt;&gt;&gt; * And, yes, `String.init(format:_:)`, which we will probably never be quite rid of for compatibility reasons.<br>&gt;&gt;&gt; <br>&gt;&gt; All those points are also perfectly solved by dependent types (which is definitely not in the time frame of Swift 3 or even Swift 4).<br>&gt;&gt; But I think in the long term we should get rid of varargs and Swift 3 (as far as I remember) is the last version of Swift to remove functionality from the language (is that actually correct?).<br>&gt;&gt; <br>&gt;&gt; Short-term solutions:<br>&gt;&gt; <br>&gt;&gt; I very very rarely use the print function with multiple parameters. Most of the time I build a single string and use string interpolation to insert values. If there really is a need for multiple arguments to print, like others said, overloads could be generated.<br>&gt;&gt; min and max: I think most the time they are used to compare 2 values. If there are more than 2 values (or let’s say 3) I think an array is better suited.<br>&gt;&gt; String.init(format:_:) … I think if all C APIs would get imported by converting varargs to arrays we could get rid of it.<br>&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Idea] Passing an Array to Variadic Functions</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 19, 2016 at 11:00:00pm</p></header><div class="content"><p>I thought that strings containing interpolation expressions did require the interpolated expression to be available in the local context. I just checked with IBM&#39;s Swift sandbox and indeed got an error when defining a string before the interpolated value, i.e.<br></p><p>let str = &quot;x = \(x)&quot;<br>let x = 1<br></p><p>Therefore I wouldn&#39;t expect strings containing interpolation expressions to work when loaded from a file (can&#39;t check that in the sandbox, though).<br></p><p>-Thorsten <br></p><p>&gt; Am 19.04.2016 um 18:42 schrieb Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On 19 Apr 2016, at 10:41, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Just annotenhere: String intepolation is ok for logging purposes but not for creating user messages which have to be localized (with possibly having to reorder the parameters).<br>&gt; <br>&gt; Reordering is not a problem<br>&gt; <br>&gt; if language == “fr&quot;<br>&gt; {<br>&gt;    object = “me”<br>&gt;    verb = “lance&quot;<br>&gt; }<br>&gt; else<br>&gt; {<br>&gt;    object = “myself”<br>&gt;    verb = “throw&quot;<br>&gt; <br>&gt; }<br>&gt; <br>&gt; “Je \(object) \(verb) vers la gloire”<br>&gt; “I \(verb) \(object) towards glory&quot;<br>&gt; <br>&gt; There are other issues though (e.g. format should be in the hands of the translator) which mean I would not want to lose format strings.<br>&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt;&gt; Am 18.04.2016 um 22:56 schrieb Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dennis<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Apr 18, 2016, at 9:55 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would like to see format strings go away and be replace with safer inline annotations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The main problem is doing localized strings with printf-style formats well, but I actually have a pretty sweet solution for that: https://gist.github.com/brentdax/79fa038c0af0cafb52dd<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- E, somewhat agnostic on variadics<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Variadics are eventually important as a generic function feature; you really want to be able to write a version of zip() which can take any number of sequences, for instance, and the only reasonable way to do that is to pass a variable number of parameters and return a sequence with a matchingly variable number of type parameters.<br>&gt;&gt;&gt; Which brings us to dependent types :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Today, they are important in that they bootstrap ArrayLiteralConvertible and DictionaryLiteralConvertible by (at least theoretically) acting as a pass-N-items mechanism that doesn&#39;t depend on one of the standard library types defined in terms of it. (If we convert them to show up as tuples once we have tuple subscripting syntax, that will even become true.) Less esoterically, they&#39;re used in several places where an Array would be inconvenient or break traditions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * The `print` function&#39;s list of items to print is variadic. An array equivalent would look like `print([one, two, three])`.<br>&gt;&gt;&gt;&gt; * The `min` and `max` functions are more convenient than explicitly constructing an array and calling their `min()` and `max()` methods.<br>&gt;&gt;&gt;&gt; * And, yes, `String.init(format:_:)`, which we will probably never be quite rid of for compatibility reasons.<br>&gt;&gt;&gt; All those points are also perfectly solved by dependent types (which is definitely not in the time frame of Swift 3 or even Swift 4).<br>&gt;&gt;&gt; But I think in the long term we should get rid of varargs and Swift 3 (as far as I remember) is the last version of Swift to remove functionality from the language (is that actually correct?).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Short-term solutions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I very very rarely use the print function with multiple parameters. Most of the time I build a single string and use string interpolation to insert values. If there really is a need for multiple arguments to print, like others said, overloads could be generated.<br>&gt;&gt;&gt; min and max: I think most the time they are used to compare 2 values. If there are more than 2 values (or let’s say 3) I think an array is better suited.<br>&gt;&gt;&gt; String.init(format:_:) … I think if all C APIs would get imported by converting varargs to arrays we could get rid of it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
