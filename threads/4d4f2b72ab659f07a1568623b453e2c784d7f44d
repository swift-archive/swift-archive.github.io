<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Representation of natural numbers with a distinct type</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  3, 2016 at 04:00:00pm</p></header><div class="content"><p>on Wed Feb 03 2016, David Turnbull &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; You can have a collection with a negative count. There&#39;s uses for this too.<br>&gt; For example, importing data. You can import whatever garbage in one pass,<br>&gt; and validate in a second. That way you don&#39;t have to mix concerns in your<br>&gt; code.<br></p><p>I think the semantic requirements on CollectionType&#39;s count prevent it<br>from ever being negative.  If they don&#39;t, they should.<br></p><p>&gt; -david<br>&gt;<br>&gt; On Wed, Feb 3, 2016 at 12:35 PM, &lt;davesweeris at mac.com&gt; wrote:<br>&gt;<br>&gt;&gt; What about .count? Is it possible for that to be negative? *If* we change<br>&gt;&gt; how count is represented, I think it should be switched to size_t, rather<br>&gt;&gt; that UInt. I’m aware that they’re currently the same thing, but that might<br>&gt;&gt; not always be the case, and, at least the way I understand things, the max<br>&gt;&gt; value of a platform’s “pointer” type is more directly tied to the maximum<br>&gt;&gt; possible element count than the max value of its native uint type. I know<br>&gt;&gt; of at least one platform in development which uses 64 bits for pointers,<br>&gt;&gt; but the address space is only 61 bits because the CPU &amp; memory system use 3<br>&gt;&gt; bits for flags.<br>&gt;&gt;<br>&gt;&gt; - Dave Sweeris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Feb 3, 2016, at 11:58, David Turnbull via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; -1  CollectionType and it&#39;s ilk, contrary to what you believe, were<br>&gt;&gt; designed to handle negative indexes just fine. Or even indexes that aren&#39;t<br>&gt;&gt; numeric. And there&#39;s plenty of real use cases for this.<br>&gt;&gt;<br>&gt;&gt; class GraphRow : MutableCollectionType {<br>&gt;&gt;     var values = [Int](count: 201, repeatedValue: 0)<br>&gt;&gt;     var startIndex: Int { return -100 }<br>&gt;&gt;     var endIndex: Int { return 100 }<br>&gt;&gt;     subscript(column: Int) -&gt; Int {<br>&gt;&gt;         get {<br>&gt;&gt;             return values[column+100]<br>&gt;&gt;         }<br>&gt;&gt;         set {<br>&gt;&gt;             values[column+100] = newValue<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; var r = GraphRow()<br>&gt;&gt; r[-3] = 12<br>&gt;&gt; r[9] = 2<br>&gt;&gt; print(r[-3])<br>&gt;&gt; print(r.reduce(0, combine: +))<br>&gt;&gt;<br>&gt;&gt; -david<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, Feb 3, 2016 at 9:31 AM, James Froggatt via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; In the standard library, there are methods (notably array subscripts,<br>&gt;&gt;&gt; CollectionType&#39;s .count and the dimensions of CGSize) which are designed to<br>&gt;&gt;&gt; deal only with natural (non-negative) numbers. Functions either throw an<br>&gt;&gt;&gt; error if a parameter is negative, or else ignore the possibility of a<br>&gt;&gt;&gt; negative value finding its way into these functions.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; By updating the standard library with a natural number type to represent<br>&gt;&gt;&gt; these values (and potentially the Swift interfaces for Foundation and other<br>&gt;&gt;&gt; frameworks), there is no way a negative number can be passed to these<br>&gt;&gt;&gt; functions. This eliminates the need for many preconditions, allowing them<br>&gt;&gt;&gt; to eliminate the possibility of a crash, and it would be clear that values<br>&gt;&gt;&gt; such as count will never be negative.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If this change were accepted, the user would have to explicitly convert<br>&gt;&gt;&gt; between the types at some points in their code. This could be seen as a<br>&gt;&gt;&gt; burden, but requiring a cast encourages the programmer to check for<br>&gt;&gt;&gt; negative values, keeping negatives out of natural number functions, and<br>&gt;&gt;&gt; moving checks to the source of the data, similar to how Optionals eliminate<br>&gt;&gt;&gt; nil values early on.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The parallel to Optionals is, in my opinion, the most appealing aspect of<br>&gt;&gt;&gt; this idea. With Swift&#39;s focus on type safety, the lack of distinction<br>&gt;&gt;&gt; between natural numbers and potentially negative ones seems like an<br>&gt;&gt;&gt; omission, given how commonly both kinds of number are used. Enabling this<br>&gt;&gt;&gt; level of integral safety would add additional clarity and reduce potential<br>&gt;&gt;&gt; errors. Use cases include not just indexes, but in sizes such as<br>&gt;&gt;&gt; collections&#39; count and CG dimensions, for both clarity when getting values,<br>&gt;&gt;&gt; and enforcing valid values at initialisation.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; UInt is the obvious candidate to represent integer natural numbers, but<br>&gt;&gt;&gt; is hazardous in edge cases: UInt allows an extra bit for magnitude, so has<br>&gt;&gt;&gt; the possibility of overflow when converting back to Int. I assume this<br>&gt;&gt;&gt; hazard is the primary reason UInt currently isn&#39;t used. If this a concern,<br>&gt;&gt;&gt; a separate collection of types for natural integers (NInt?) could be<br>&gt;&gt;&gt; created, which could be a strict subset of the correspondingly sized Int<br>&gt;&gt;&gt; values (using n-1 bits).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This would mean adding a new collection of integer types in the standard<br>&gt;&gt;&gt; library, which is undesirable. However, for high level applications which<br>&gt;&gt;&gt; Swift is primarily used for, this would arguably be a more useful type than<br>&gt;&gt;&gt; UInt, considering the near absence of UInt in current APIs, and its tiny<br>&gt;&gt;&gt; increase (1 bit?) in precision compared to using an Int of a larger size.<br>&gt;&gt;&gt; An unsigned Integer subset would allow safe conversion back to Int, and the<br>&gt;&gt;&gt; conversion from Int is relatively simple, from the design perspective -<br>&gt;&gt;&gt; ignore the sign bit, throw an error, or round up to 0, as appropriate.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Alternatives include:<br>&gt;&gt;&gt; • A generic wrapper for Int which constrains its possible values. This<br>&gt;&gt;&gt; would allow inherent support for use with existing operators, but would be<br>&gt;&gt;&gt; rather clunky in cases where only natural numbers are being dealt with.<br>&gt;&gt;&gt; • In a future version of Swift, the addition of type parameters<br>&gt;&gt;&gt; constraining possible values may enable this to be added, but even if this<br>&gt;&gt;&gt; does get added it may be too late to make such a major change.<br>&gt;&gt;&gt; • Leaving the APIs as they are and require every function dealing with<br>&gt;&gt;&gt; natural numbers to either throw a runtime error when a negative is passed.<br>&gt;&gt;&gt; If the user forgets to follow this rule (or wont put in the extra effort to<br>&gt;&gt;&gt; add the check), their functions will have unspecified behaviour.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This ended up longer than I would like, sorry about that. I don&#39;t think<br>&gt;&gt;&gt; this issue has been covered here.<br>&gt;&gt;&gt; I&#39;d be interested to hear responses and opinions, and while I&#39;m confident<br>&gt;&gt;&gt; this change would be beneficial if done correctly, doing it correctly is<br>&gt;&gt;&gt; easier said that done.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - James<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7321934b88ca8da079d7b89926501a9c?s=50"></div><header><strong>Representation of natural numbers with a distinct type</strong> from <string>David Turnbull</string> &lt;dturnbull at gmail.com&gt;<p>February  3, 2016 at 05:00:00pm</p></header><div class="content"><p>On Wed, Feb 3, 2016 at 4:35 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think the semantic requirements on CollectionType&#39;s count prevent it<br>&gt; from ever being negative.  If they don&#39;t, they should.<br></p><p><br>Only when you actually try to iterate will it fail. It&#39;s useful to have<br>this invalid state where start&gt;end. You might have one thread finding<br>minima and another finding maxima. That&#39;s how it is today anyways. Which I<br>think is nice.<br></p><p>-david<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/e0a2e1ab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Representation of natural numbers with a distinct type</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  4, 2016 at 12:00:00am</p></header><div class="content"><p>on Wed Feb 03 2016, David Turnbull &lt;dturnbull-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Wed, Feb 3, 2016 at 4:35 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I think the semantic requirements on CollectionType&#39;s count prevent it<br>&gt;&gt; from ever being negative.  If they don&#39;t, they should.<br>&gt;<br>&gt; Only when you actually try to iterate will it fail. <br></p><p>That&#39;s not what I&#39;m saying.  <br></p><p>  /// Returns the number of elements.<br>  /// ...<br>  var count: Index.Distance { get }<br></p><p>Awkward wording aside, this says that count is the number of elements in<br>the collection.  Once you have that, it&#39;s automatically non-negative.<br>There&#39;s no way for a collection to hold less than zero elements.<br></p><p>&gt; It&#39;s useful to have this invalid state where start&gt;end. You might have<br>&gt; one thread finding minima and another finding maxima. That&#39;s how it is<br>&gt; today anyways. Which I think is nice.<br></p><p>I have no idea what you mean here, sorry.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
