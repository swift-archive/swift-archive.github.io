<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of	declaration</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>May 15, 2016 at 10:00:00am</p></header><div class="content"><p>David Hart via swift-evolution &lt;swift-evolution at ...&gt; writes:<br></p><p>&gt; <br>&gt; <br>&gt; Hi Karl,<br>&gt; <br>&gt; As author of this proposal, the one about constraints on associated types,<br>and the one on type-aliases in protocols (all from the Generics Manifesto -<br>original authorship to Douglas Gregor) I’d like to provide additional<br>reasoning behind my wish to push this proposal through, as a whole.<br>&gt; <br>&gt; First of all, there is a personal preference. I’ve used C# for many many<br>years, which has its where clause at the end of the declaration (like this<br>proposal), and I’ve used Swift since its unveiling. The experience with<br>using both styles for several years makes me favour this proposal’s syntax<br>because I find it much easier to read and format for readability.<br>&gt; <br>&gt; Constraints on associated type will provide more expressivity but I doubt<br>it will greatly reduce protocol constraint clauses in a majority of cases.<br>And yes, type-aliases in protocols will shorten clauses, but I still think<br>they will more readable with the where clause at the end.<br>&gt; <br>&gt; For example, here is a method I took (as-is) from the Standard Library<br>which has a few constraints, and which I further simplified if we imagine<br>that Sequence has an Element typealias for Iterator.Element:<br>&gt; <br>&gt; <br>&gt; internal func _arrayOutOfPlaceReplace&lt;<br>&gt;  B : _ArrayBufferProtocol, C : Collection<br>&gt;  where  C.Element == B.Element,<br>&gt;  B.Index == Int<br>&gt; &gt;(  _ source: inout B, _ bounds: Range&lt;Int&gt;, _ newValues:<br>&gt; C, _ insertCount: Int) {<br>&gt; <br>&gt; See how the Standard Library authors formatted it for readability and how<br>as a consequence arguments which use the generic types are further apart<br>from the declaration of those generic types. But with this proposal, the<br>declaration might be formatted to:<br>&gt; <br>&gt; internal func _arrayOutOfPlaceReplace&lt;B,C&gt;(_ source: inout B,<br>&gt; _ bounds: Range&lt;Int&gt;, _ newValues: C, _ insertCount: Int)<br>&gt;  where<br>&gt;  B : _ArrayBufferProtocol,<br>&gt;  C : Collection,<br>&gt;  C.Iterator.Element == B.Element,<br>&gt;  B.Index == Int<br>&gt; {<br>&gt; <br>&gt; Do you need believe this is now more readable?<br>&gt; <br>&gt; David.<br></p><p>Thanks for the real world example!<br></p><p>I think that the second arguably *looks* better. But is it more *readable*?<br>Not for me.<br></p><p>Let me try to do a brain dump while I mentally parse the declaration.<br></p><p>&gt; internal func _arrayOutOfPlaceReplace&lt;B,C&gt;(<br></p><p>Mmm, here we have a function that has something to do with arrays, generic<br>on two types. Maybe it will take an Array&lt;B&gt; and output an Array&lt;C&gt;?<br></p><p>&gt; _ source: inout B,<br></p><p>Ah, the first argument is a B that will be changed. Maybe the function deals<br>with Array&lt;B&gt; and will replace occurrences of &#39;source&#39; with something else?<br></p><p>&gt; _ bounds: Range&lt;Int&gt;,<br></p><p>Ok, this surely must be the range of the Array to operate on.<br></p><p>&gt; _ newValues: C,<br></p><p>Oh, this parameter is called &#39;newValues&#39;, so C can&#39;t be a single value. It<br>must be a Collection, surely.<br></p><p>&gt; _ insertCount: Int)<br></p><p>... I can&#39;t figure out what this could be.<br></p><p>&gt;  where<br>&gt;  B : _ArrayBufferProtocol,<br></p><p>Oh, B was some kind of buffer. OK so the function probably takes this<br>buffer, and replaces &#39;range&#39; with &#39;newValues&#39;<br></p><p>&gt;  C : Collection,<br>&gt;  C.Iterator.Element == B.Element,<br></p><p>Good, this confirms what I thought.<br></p><p>&gt;  B.Index == Int<br></p><p>Looks like an implementation detail, I guess that&#39;s why &#39;range&#39; is a<br>Range&lt;Int&gt; and &#39;insertCount&#39; is an Int. Presumably the function needs to do<br>some operations that the generic Index doesn&#39;t guarantee.<br></p><p>So that&#39;s the end of it. I have a vague idea of what the function might do,<br>and had to revise my expectations a few times while reading its declaration.<br></p><p><br>Let&#39;s try again with the original declaration.<br></p><p>&gt; internal func _arrayOutOfPlaceReplace&lt;<br>&gt;  B : _ArrayBufferProtocol, C : Collection<br></p><p>OK, here we have a function that deals with Arrays, generic on some buffer<br>thing and on a Collection. B is presumably what it needs to operate on, and<br>C will be the thing to replace with.<br></p><p>&gt;  where  C.Element == B.Element,<br></p><p>Indeed thic confirms that B and C must be compatible.<br></p><p>&gt;  B.Index == Int<br></p><p>Looks like an implementation detail, presumably we need to indicate the<br>position in the array where to do the replace.<br></p><p>&gt; &gt;(  _ source: inout B,<br></p><p>OK so this is a mutating function, and B is a buffer that will be modified.<br></p><p>&gt; _ bounds: Range&lt;Int&gt;,<br></p><p>This is probably the range of the buffer that needs to be replaced, indeed<br>we had B.Index == Int.<br></p><p>&gt; _ newValues: C,<br></p><p>And this collection contains what we need to insert in the buffer.<br></p><p>&gt; _ insertCount: Int) {<br></p><p>Not sure what this might be, maybe the function will copy only the first<br>&#39;insertCount&#39; elements of C.<br></p><p>There we are. I read the declaration of the function from beginning to end<br>and gradually formed a rough understanding of it without needing to change<br>my expectations halfway through. I still have doubts about &#39;insertCount&#39;,<br>but I was at least able to formulate an hypothesis about its use.<br></p><p>YMMV, but as far as I&#39;m concerned, the original declaration was much easier<br>to understand.<br></p><p>Now if we had generic typealiases, we could do something like<br></p><p>typealias CollectionOf&lt;T&gt; = protocol&lt;Collection&gt; where Collection.Element == T<br></p><p>and if my intuition about B.Index is right, the declaration could be further<br>simplified to something like this<br></p><p>internal func _arrayOutOfPlaceReplace&lt;<br>  B : _ArrayBufferProtocol, C : CollectionOf&lt;B.Element&gt;<br>  where B.Index == Int<br>&gt;(  _ source: inout B, _ bounds: Range&lt;B.Index&gt;, _ newValues: C, _<br>insertCount: B.Index) {<br></p><p>Now *that* is more readable.<br></p><p><br>Nicola<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 15, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; There we are. I read the declaration of the function from beginning to end<br>&gt; and gradually formed a rough understanding of it without needing to change<br>&gt; my expectations halfway through. I still have doubts about &#39;insertCount&#39;,<br>&gt; but I was at least able to formulate an hypothesis about its use.<br>&gt; <br>&gt; YMMV, but as far as I&#39;m concerned, the original declaration was much easier<br>&gt; to understand.<br></p><p>I actually agree with you for this case, but not *all* type information *has* to be moved to the end. Try this on for size, which is actually still the most natural way to write this declaration in SE-0081:<br></p><p>internal func _arrayOutOfPlaceReplace<br> &lt;B: _ArrayBufferProtocol, C: Collection&gt;<br> (_ source: inout B, _ bounds: Range&lt;Int&gt;, _ newValues: C, _ insertCount: Int)<br>  where<br>  C.Iterator.Element == B.Element,<br>  B.Index == Int<br>{<br></p><p>Now only the relatively unimportant details—that the buffer and collection must have elements of the same type, and that the buffer must have integer indices—are at the end, whereas the basic conformances required to make any sense at all of the declaration are still inline.<br></p><p>This proposal *permits* you to hollow out the generic parameter list to the point of vacuousness, but that doesn&#39;t mean it&#39;s the right thing to do. It might make sense to ban a direct `X: Foo` requirement unless there was already an `X: Bar` in the generic parameter list. Or we might simply need to paraphrase the Perl manual page: &quot;There are several ways to write a generic requirement, so consider picking the most readable one.&quot;<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 15, 2016 at 03:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>On 15 May 2016, at 15:05, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; There we are. I read the declaration of the function from beginning to end<br>&gt;&gt; and gradually formed a rough understanding of it without needing to change<br>&gt;&gt; my expectations halfway through. I still have doubts about &#39;insertCount&#39;,<br>&gt;&gt; but I was at least able to formulate an hypothesis about its use.<br>&gt;&gt; <br>&gt;&gt; YMMV, but as far as I&#39;m concerned, the original declaration was much easier<br>&gt;&gt; to understand.<br>&gt; <br>&gt; I actually agree with you for this case, but not *all* type information *has* to be moved to the end. Try this on for size, which is actually still the most natural way to write this declaration in SE-0081:<br>&gt; <br>&gt; internal func _arrayOutOfPlaceReplace<br>&gt; &lt;B: _ArrayBufferProtocol, C: Collection&gt;<br>&gt; (_ source: inout B, _ bounds: Range&lt;Int&gt;, _ newValues: C, _ insertCount: Int)<br>&gt;  where<br>&gt;  C.Iterator.Element == B.Element,<br>&gt;  B.Index == Int<br>&gt; {<br>&gt; <br>&gt; Now only the relatively unimportant details—that the buffer and collection must have elements of the same type, and that the buffer must have integer indices—are at the end, whereas the basic conformances required to make any sense at all of the declaration are still inline.<br>&gt; <br>&gt; This proposal *permits* you to hollow out the generic parameter list to the point of vacuousness, but that doesn&#39;t mean it&#39;s the right thing to do. It might make sense to ban a direct `X: Foo` requirement unless there was already an `X: Bar` in the generic parameter list. Or we might simply need to paraphrase the Perl manual page: &quot;There are several ways to write a generic requirement, so consider picking the most readable one.&quot;<br></p><p>I think you hit the nail on the head. Being able to let the developer decide how to place relevant type information with the freedom of being able to keep some/all/none type information local and some/none/all extra information moved to the end of the declaration. Don&#39;t we allow the same kind of freedom with protocols and extensions in a way?<br></p><p><br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 15, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Being able to let the developer decide how to place relevant type information with the freedom of being able to keep some/all/none type information local and some/none/all extra information moved to the end of the declaration.<br></p><p>To be clear, I do think it makes sense to move *all* `where` clauses to the end of the parameter list, not allow them both within the angle brackets and at the end of the definition. And I&#39;m not convinced it makes sense to support moving all conformance information to the `where` clause, either. A generic parameter list like `&lt;T, U&gt;` is vacuous; when you&#39;re dealing with something like this:<br></p><p>	public func transcode<br>	    &lt;Input: IteratorProtocol, InputEncoding: UnicodeCodec, OutputEncoding: UnicodeCodec&gt;<br>	    (_ input: Input, from inputEncoding: InputEncoding.Type, to outputEncoding: OutputEncoding.Type, stoppingOnError stopOnError: Bool, sendingOutputTo processCodeUnit: @noescape (OutputEncoding.CodeUnit) -&gt; Void) -&gt; Bool<br>	    where InputEncoding.CodeUnit == Input.Element<br></p><p>The detail in the `where` clause really is of secondary importance, especially compared to how much syntax it takes to specify, while this:<br></p><p>	public func transcode<br>	    &lt;Input, InputEncoding, OutputEncoding&gt;(_ input: Input, from inputEncoding: InputEncoding.Type, to outputEncoding: OutputEncoding.Type, stoppingOnError stopOnError: Bool, sendingOutputTo processCodeUnit: @noescape (OutputEncoding.CodeUnit) -&gt; Void) -&gt; Bool<br>	    where Input: IteratorProtocol, InputEncoding: UnicodeCodec, OutputEncoding: UnicodeCodec, InputEncoding.CodeUnit == Input.Element<br></p><p>Leaves far too much unspecified until the end.<br></p><p>I&#39;m actually tempted to suggest that a conformance should be *mandatory* and you should have to specify `Any` if you don&#39;t have anything more specific to say about the generic parameter:<br></p><p>	func map&lt;T: Any&gt;(@noescape transform: (Element) throws -&gt; T) rethrows -&gt; [T]<br></p><p>That would penalize the &quot;leave everything until the end&quot; style without actually introducing any arbitrary rules forbidding it.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 15, 2016 at 11:00:00pm</p></header><div class="content"><p>Makes sense, I would not mind the mandatory conformance actually.<br></p><p>Sent from my iPhone<br></p><p>On 15 May 2016, at 23:45, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; Being able to let the developer decide how to place relevant type information with the freedom of being able to keep some/all/none type information local and some/none/all extra information moved to the end of the declaration.<br>&gt; <br>&gt; To be clear, I do think it makes sense to move *all* `where` clauses to the end of the parameter list, not allow them both within the angle brackets and at the end of the definition. And I&#39;m not convinced it makes sense to support moving all conformance information to the `where` clause, either. A generic parameter list like `&lt;T, U&gt;` is vacuous; when you&#39;re dealing with something like this:<br>&gt; <br>&gt;    public func transcode<br>&gt;        &lt;Input: IteratorProtocol, InputEncoding: UnicodeCodec, OutputEncoding: UnicodeCodec&gt;<br>&gt;        (_ input: Input, from inputEncoding: InputEncoding.Type, to outputEncoding: OutputEncoding.Type, stoppingOnError stopOnError: Bool, sendingOutputTo processCodeUnit: @noescape (OutputEncoding.CodeUnit) -&gt; Void) -&gt; Bool<br>&gt;        where InputEncoding.CodeUnit == Input.Element<br>&gt; <br>&gt; The detail in the `where` clause really is of secondary importance, especially compared to how much syntax it takes to specify, while this:<br>&gt; <br>&gt;    public func transcode<br>&gt;        &lt;Input, InputEncoding, OutputEncoding&gt;(_ input: Input, from inputEncoding: InputEncoding.Type, to outputEncoding: OutputEncoding.Type, stoppingOnError stopOnError: Bool, sendingOutputTo processCodeUnit: @noescape (OutputEncoding.CodeUnit) -&gt; Void) -&gt; Bool<br>&gt;        where Input: IteratorProtocol, InputEncoding: UnicodeCodec, OutputEncoding: UnicodeCodec, InputEncoding.CodeUnit == Input.Element<br>&gt; <br>&gt; Leaves far too much unspecified until the end.<br>&gt; <br>&gt; I&#39;m actually tempted to suggest that a conformance should be *mandatory* and you should have to specify `Any` if you don&#39;t have anything more specific to say about the generic parameter:<br>&gt; <br>&gt;    func map&lt;T: Any&gt;(@noescape transform: (Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt; <br>&gt; That would penalize the &quot;leave everything until the end&quot; style without actually introducing any arbitrary rules forbidding it.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>May 16, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 16 May 2016, at 01:45, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m actually tempted to suggest that a conformance should be *mandatory* and you should have to specify `Any` if you don&#39;t have anything more specific to say about the generic parameter:<br>&gt; <br>&gt; 	func map&lt;T: Any&gt;(@noescape transform: (Element) throws -&gt; T) rethrows -&gt; [T]<br></p><p>That&#39;s a good idea indeed if we ever intend to have other kinds of generic arguments (in particular, constant values like `length: Int`).<br></p><p>Even so, I wouldn&#39;t want to prohibit adding more protocol constraints in the where clause even if you can introduce all constaints of `T` at once as `T: protocol&lt;A, B&gt;`.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/5b48fded/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 16, 2016 at 11:00:00am</p></header><div class="content"><p>Having to declare conformance to `Any` is just noise and should *not* be mandatory IMHO.<br></p><p>-Thorsten<br></p><p><br>&gt; Am 16.05.2016 um 07:59 schrieb Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On 16 May 2016, at 01:45, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m actually tempted to suggest that a conformance should be *mandatory* and you should have to specify `Any` if you don&#39;t have anything more specific to say about the generic parameter:<br>&gt;&gt; <br>&gt;&gt; 	func map&lt;T: Any&gt;(@noescape transform: (Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt; <br>&gt; That&#39;s a good idea indeed if we ever intend to have other kinds of generic arguments (in particular, constant values like `length: Int`).<br>&gt; <br>&gt; Even so, I wouldn&#39;t want to prohibit adding more protocol constraints in the where clause even if you can introduce all constaints of `T` at once as `T: protocol&lt;A, B&gt;`.<br>&gt; <br>&gt; — Pyry<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/96b1fac9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 16, 2016 at 02:00:00am</p></header><div class="content"><p>+1. Non-type generic parameters can be handled if/when they are proposed after Swift 3. There have to be better ways to encourage proper organization of the elements of a method header than forcing a redundant and non-obvious conformance to &#39;Any&#39;; if this is mandatory the proposal is fatally flawed and should be taken back to the drawing board.<br></p><p>Austin<br></p><p>&gt; On May 16, 2016, at 2:36 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Having to declare conformance to `Any` is just noise and should *not* be mandatory IMHO.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; Am 16.05.2016 um 07:59 schrieb Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 16 May 2016, at 01:45, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m actually tempted to suggest that a conformance should be *mandatory* and you should have to specify `Any` if you don&#39;t have anything more specific to say about the generic parameter:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	func map&lt;T: Any&gt;(@noescape transform: (Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt;&gt; <br>&gt;&gt; That&#39;s a good idea indeed if we ever intend to have other kinds of generic arguments (in particular, constant values like `length: Int`).<br>&gt;&gt; <br>&gt;&gt; Even so, I wouldn&#39;t want to prohibit adding more protocol constraints in the where clause even if you can introduce all constaints of `T` at once as `T: protocol&lt;A, B&gt;`.<br>&gt;&gt; <br>&gt;&gt; — Pyry<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/e44246d7/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 16, 2016 at 09:00:00am</p></header><div class="content"><p>On May 16, 2016, at 12:45 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; Being able to let the developer decide how to place relevant type information with the freedom of being able to keep some/all/none type information local and some/none/all extra information moved to the end of the declaration.<br>&gt; <br>&gt; To be clear, I do think it makes sense to move *all* `where` clauses to the end of the parameter list, not allow them both within the angle brackets and at the end of the definition. And I&#39;m not convinced it makes sense to support moving all conformance information to the `where` clause, either. A generic parameter list like `&lt;T, U&gt;` is vacuous; when you&#39;re dealing with something like this:<br>&gt; <br>&gt;    public func transcode<br>&gt;        &lt;Input: IteratorProtocol, InputEncoding: UnicodeCodec, OutputEncoding: UnicodeCodec&gt;<br>&gt;        (_ input: Input, from inputEncoding: InputEncoding.Type, to outputEncoding: OutputEncoding.Type, stoppingOnError stopOnError: Bool, sendingOutputTo processCodeUnit: @noescape (OutputEncoding.CodeUnit) -&gt; Void) -&gt; Bool<br>&gt;        where InputEncoding.CodeUnit == Input.Element<br>&gt; <br>&gt; The detail in the `where` clause really is of secondary importance, especially compared to how much syntax it takes to specify, while this:<br>&gt; <br>&gt;    public func transcode<br>&gt;        &lt;Input, InputEncoding, OutputEncoding&gt;(_ input: Input, from inputEncoding: InputEncoding.Type, to outputEncoding: OutputEncoding.Type, stoppingOnError stopOnError: Bool, sendingOutputTo processCodeUnit: @noescape (OutputEncoding.CodeUnit) -&gt; Void) -&gt; Bool<br>&gt;        where Input: IteratorProtocol, InputEncoding: UnicodeCodec, OutputEncoding: UnicodeCodec, InputEncoding.CodeUnit == Input.Element<br>&gt; <br>&gt; Leaves far too much unspecified until the end.<br></p><p>Purely a matter of opinion... I&#39;m fine with it.<br></p><p>&gt; <br>&gt; I&#39;m actually tempted to suggest that a conformance should be *mandatory* and you should have to specify `Any` if you don&#39;t have anything more specific to say about the generic parameter:<br>&gt; <br>&gt;    func map&lt;T: Any&gt;(@noescape transform: (Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt; <br>&gt; That would penalize the &quot;leave everything until the end&quot; style without actually introducing any arbitrary rules forbidding it.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>May 16, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; internal func _arrayOutOfPlaceReplace<br>&gt; &lt;B: _ArrayBufferProtocol, C: Collection&gt;<br>&gt; (_ source: inout B, _ bounds: Range&lt;Int&gt;, _ newValues: C, _ insertCount: Int)<br>&gt;  where<br>&gt;  C.Iterator.Element == B.Element,<br>&gt;  B.Index == Int<br>&gt; {<br>&gt; <br>&gt; Now only the relatively unimportant details—that the buffer and collection must have elements of the same type, and that the buffer must have integer indices—are at the end, whereas the basic conformances required to make any sense at all of the declaration are still inline.<br></p><p>You see, I’m of the complete opposite opinion - I don’t think those details are “relatively unimportant”; I think they’re absolutely critical.<br></p><p>If you try and call it when your C.Iterator.Element is not equal to B.Element, the function does not exist. You’re talking about some other function in that case, not this one.<br></p><p>Same goes if B.Index is not an Int. If that was an unimportant detail, they would have given ‘bounds’ the type Range&lt;B.Index&gt; and not specified any constraints at all. The function requires the index be an Int - maybe it’s doing some mathematical operations which wouldn’t make sense for a more complex index type, such as DictionaryIndex.<br></p><p>Basically that is it - the ‘where’ clause is a vital part of the function declaration; it defines the specification under which the function exists at all (along with the function name, arguments and return type). If you don’t match every single part of that specification, the type checker won’t match your call to this function - if you don’t meet the constraints, you’re not talking about this function; imagine you have several overloaded function declarations which differ only by ‘where’ condition:<br></p><p>func insert&lt;T&gt;(contentsOf:T) where T:RandomAccessCollection, T.Element == Element<br>func insert&lt;T&gt;(contentsOf:T) where T:Collection, T.Element == Element<br>func insert&lt;T&gt;(contentsOf:T) where T:Sequence, T.Element == Element<br>… etc<br></p><p>the ‘where’ clause isn’t incidental here - it’s the only disambiguating feature between these declarations. I think it’s critical information and shouldn’t be stuffed at the end because you think it’s not important; it is important. If it hinders initial readability of the declaration so much, you can wrap it behind a typealias:<br></p><p>func insert&lt;T: RandomAccessCollectionOf&lt;Element&gt;&gt;(contentsOf: T)<br>func insert&lt;T: CollectionOf&lt;Element&gt;&gt;(contentsOf: T)<br>func insert&lt;T: SequenceOf&lt;Element&gt;&gt;(contentsOf: T)<br>… etc<br></p><p>I think that’s much easier to follow, and attempts to reduces the length and verbosity of the where clauses (i.e. like the fact that Collection’s associated type referring to its element is called ‘Element’; ‘CollectionOf’ encodes an equivalent constraint in less characters). This proposal just feels kind of lazy - we’ll just tack them on the end so we can ignore them a bit more easily, even though they’re still going to be monstrously long and difficult-to-read.<br></p><p>Are there any other languages that do this? Or anything even similar? It seems to me that the context-switching is something that human beings in general are not going to find very legible; like if you insert too many commas in a sentence.<br></p><p>&gt; On 15 May 2016, at 16:05, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; There we are. I read the declaration of the function from beginning to end<br>&gt;&gt; and gradually formed a rough understanding of it without needing to change<br>&gt;&gt; my expectations halfway through. I still have doubts about &#39;insertCount&#39;,<br>&gt;&gt; but I was at least able to formulate an hypothesis about its use.<br>&gt;&gt; <br>&gt;&gt; YMMV, but as far as I&#39;m concerned, the original declaration was much easier<br>&gt;&gt; to understand.<br>&gt; <br>&gt; I actually agree with you for this case, but not *all* type information *has* to be moved to the end. Try this on for size, which is actually still the most natural way to write this declaration in SE-0081:<br>&gt; <br>&gt; <br>&gt; This proposal *permits* you to hollow out the generic parameter list to the point of vacuousness, but that doesn&#39;t mean it&#39;s the right thing to do. It might make sense to ban a direct `X: Foo` requirement unless there was already an `X: Bar` in the generic parameter list. Or we might simply need to paraphrase the Perl manual page: &quot;There are several ways to write a generic requirement, so consider picking the most readable one.&quot;<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 16, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Am 16.05.2016 um 17:04 schrieb Karl via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; internal func _arrayOutOfPlaceReplace<br>&gt;&gt; &lt;B: _ArrayBufferProtocol, C: Collection&gt;<br>&gt;&gt; (_ source: inout B, _ bounds: Range&lt;Int&gt;, _ newValues: C, _ insertCount: Int)<br>&gt;&gt; where<br>&gt;&gt; C.Iterator.Element == B.Element,<br>&gt;&gt; B.Index == Int<br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; Now only the relatively unimportant details—that the buffer and collection must have elements of the same type, and that the buffer must have integer indices—are at the end, whereas the basic conformances required to make any sense at all of the declaration are still inline.<br>&gt; <br>&gt; You see, I’m of the complete opposite opinion - I don’t think those details are “relatively unimportant”; I think they’re absolutely critical.<br>&gt; <br>&gt; If you try and call it when your C.Iterator.Element is not equal to B.Element, the function does not exist. You’re talking about some other function in that case, not this one.<br>&gt; <br>&gt; Same goes if B.Index is not an Int. If that was an unimportant detail, they would have given ‘bounds’ the type Range&lt;B.Index&gt; and not specified any constraints at all. The function requires the index be an Int - maybe it’s doing some mathematical operations which wouldn’t make sense for a more complex index type, such as DictionaryIndex.<br>&gt; <br>&gt; Basically that is it - the ‘where’ clause is a vital part of the function declaration; it defines the specification under which the function exists at all (along with the function name, arguments and return type). If you don’t match every single part of that specification, the type checker won’t match your call to this function - if you don’t meet the constraints, you’re not talking about this function; imagine you have several overloaded function declarations which differ only by ‘where’ condition:<br>&gt; <br>&gt; func insert&lt;T&gt;(contentsOf:T) where T:RandomAccessCollection, T.Element == Element<br>&gt; func insert&lt;T&gt;(contentsOf:T) where T:Collection, T.Element == Element<br>&gt; func insert&lt;T&gt;(contentsOf:T) where T:Sequence, T.Element == Element<br>&gt; … etc<br>&gt; <br>&gt; the ‘where’ clause isn’t incidental here - it’s the only disambiguating feature between these declarations. I think it’s critical information and shouldn’t be stuffed at the end because you think it’s not important; it is important. If it hinders initial readability of the declaration so much, you can wrap it behind a typealias:<br>&gt; <br>&gt; func insert&lt;T: RandomAccessCollectionOf&lt;Element&gt;&gt;(contentsOf: T)<br>&gt; func insert&lt;T: CollectionOf&lt;Element&gt;&gt;(contentsOf: T)<br>&gt; func insert&lt;T: SequenceOf&lt;Element&gt;&gt;(contentsOf: T)<br>&gt; … etc<br></p><p>Either you have the constraints first and the parameter list last or the other way around. Fact is that *both* decide whether it is the function you need.<br>So just their order cannot help with that.<br>I would still argue that the proposed version is more readable: just look at your example above where the first part up to the where is identical at one glance, so that the disambiguating part stands out whereas your other example looks much more unstructured because of the different lengths of the generic type list which makes the congruence of the parameter lists difficult to see because they do not align anymore.<br></p><p>&gt; <br>&gt; I think that’s much easier to follow, and attempts to reduces the length and verbosity of the where clauses (i.e. like the fact that Collection’s associated type referring to its element is called ‘Element’; ‘CollectionOf’ encodes an equivalent constraint in less characters). This proposal just feels kind of lazy - we’ll just tack them on the end so we can ignore them a bit more easily, even though they’re still going to be monstrously long and difficult-to-read.<br></p><p>The typealias idea can be combined with the where clause at the end:<br></p><p>func insert&lt;T&gt;(contentsOf:T) where T:RandomAccessCollectionOf&lt;Element&gt;<br>func insert&lt;T&gt;(contentsOf:T) where T:CollectionOf&lt;Element&gt;<br>func insert&lt;T&gt;(contentsOf:T) where T:SequenceOf&lt;Element&gt;<br></p><p>Much easier to discern (at least IMO) because everything is aligned.<br></p><p>&gt; <br>&gt; Are there any other languages that do this? Or anything even similar? It seems to me that the context-switching is something that human beings in general are not going to find very legible; like if you insert too many commas in a sentence.<br></p><p>Yes, Ceylon places all constraints (it only knows inheritance constraints) at the end:<br></p><p>shared Value sum&lt;Value&gt;({Value+} values) <br>        given Value satisfies Summable&lt;Value&gt; { ... }<br>shared &lt;Key-&gt;Item&gt;[] zip&lt;Key,Item&gt;({Key*} keys, {Item*} items)<br>        given Key satisfies Object<br>        given Item satisfies Object { ... }<br></p><p>It does the same for type definitions:<br>shared class Singleton&lt;out Element&gt;(Element element)<br>        extends Object()<br>        satisfies [Element+]<br>        given Element satisfies Object { ... }<br></p><p>-Thorsten<br></p><p>&gt; <br>&gt;&gt; On 15 May 2016, at 16:05, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; There we are. I read the declaration of the function from beginning to end<br>&gt;&gt;&gt; and gradually formed a rough understanding of it without needing to change<br>&gt;&gt;&gt; my expectations halfway through. I still have doubts about &#39;insertCount&#39;,<br>&gt;&gt;&gt; but I was at least able to formulate an hypothesis about its use.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; YMMV, but as far as I&#39;m concerned, the original declaration was much easier<br>&gt;&gt;&gt; to understand.<br>&gt;&gt; <br>&gt;&gt; I actually agree with you for this case, but not *all* type information *has* to be moved to the end. Try this on for size, which is actually still the most natural way to write this declaration in SE-0081:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This proposal *permits* you to hollow out the generic parameter list to the point of vacuousness, but that doesn&#39;t mean it&#39;s the right thing to do. It might make sense to ban a direct `X: Foo` requirement unless there was already an `X: Bar` in the generic parameter list. Or we might simply need to paraphrase the Perl manual page: &quot;There are several ways to write a generic requirement, so consider picking the most readable one.&quot;<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/6f59a187/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 17, 2016 at 12:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On May 16, 2016, at 8:16 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; Am 16.05.2016 um 17:04 schrieb Karl via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; internal func _arrayOutOfPlaceReplace<br>&gt;&gt;&gt; &lt;B: _ArrayBufferProtocol, C: Collection&gt;<br>&gt;&gt;&gt; (_ source: inout B, _ bounds: Range&lt;Int&gt;, _ newValues: C, _ insertCount: Int)<br>&gt;&gt;&gt; where<br>&gt;&gt;&gt; C.Iterator.Element == B.Element,<br>&gt;&gt;&gt; B.Index == Int<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now only the relatively unimportant details—that the buffer and collection must have elements of the same type, and that the buffer must have integer indices—are at the end, whereas the basic conformances required to make any sense at all of the declaration are still inline.<br>&gt;&gt; <br>&gt;&gt; You see, I’m of the complete opposite opinion - I don’t think those details are “relatively unimportant”; I think they’re absolutely critical.<br>&gt;&gt; <br>&gt;&gt; If you try and call it when your C.Iterator.Element is not equal to B.Element, the function does not exist. You’re talking about some other function in that case, not this one.<br>&gt;&gt; <br>&gt;&gt; Same goes if B.Index is not an Int. If that was an unimportant detail, they would have given ‘bounds’ the type Range&lt;B.Index&gt; and not specified any constraints at all. The function requires the index be an Int - maybe it’s doing some mathematical operations which wouldn’t make sense for a more complex index type, such as DictionaryIndex.<br>&gt;&gt; <br>&gt;&gt; Basically that is it - the ‘where’ clause is a vital part of the function declaration; it defines the specification under which the function exists at all (along with the function name, arguments and return type). If you don’t match every single part of that specification, the type checker won’t match your call to this function - if you don’t meet the constraints, you’re not talking about this function; imagine you have several overloaded function declarations which differ only by ‘where’ condition:<br>&gt;&gt; <br>&gt;&gt; func insert&lt;T&gt;(contentsOf:T) where T:RandomAccessCollection, T.Element == Element<br>&gt;&gt; func insert&lt;T&gt;(contentsOf:T) where T:Collection, T.Element == Element<br>&gt;&gt; func insert&lt;T&gt;(contentsOf:T) where T:Sequence, T.Element == Element<br>&gt;&gt; … etc<br>&gt;&gt; <br>&gt;&gt; the ‘where’ clause isn’t incidental here - it’s the only disambiguating feature between these declarations. I think it’s critical information and shouldn’t be stuffed at the end because you think it’s not important; it is important. If it hinders initial readability of the declaration so much, you can wrap it behind a typealias:<br>&gt;&gt; <br>&gt;&gt; func insert&lt;T: RandomAccessCollectionOf&lt;Element&gt;&gt;(contentsOf: T)<br>&gt;&gt; func insert&lt;T: CollectionOf&lt;Element&gt;&gt;(contentsOf: T)<br>&gt;&gt; func insert&lt;T: SequenceOf&lt;Element&gt;&gt;(contentsOf: T)<br>&gt;&gt; … etc<br>&gt; <br>&gt; Either you have the constraints first and the parameter list last or the other way around. Fact is that *both* decide whether it is the function you need.<br>&gt; So just their order cannot help with that.<br>&gt; I would still argue that the proposed version is more readable: just look at your example above where the first part up to the where is identical at one glance, so that the disambiguating part stands out whereas your other example looks much more unstructured because of the different lengths of the generic type list which makes the congruence of the parameter lists difficult to see because they do not align anymore.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I think that’s much easier to follow, and attempts to reduces the length and verbosity of the where clauses (i.e. like the fact that Collection’s associated type referring to its element is called ‘Element’; ‘CollectionOf’ encodes an equivalent constraint in less characters). This proposal just feels kind of lazy - we’ll just tack them on the end so we can ignore them a bit more easily, even though they’re still going to be monstrously long and difficult-to-read.<br>&gt; <br>&gt; The typealias idea can be combined with the where clause at the end:<br>&gt; <br>&gt; func insert&lt;T&gt;(contentsOf:T) where T:RandomAccessCollectionOf&lt;Element&gt;<br>&gt; func insert&lt;T&gt;(contentsOf:T) where T:CollectionOf&lt;Element&gt;<br>&gt; func insert&lt;T&gt;(contentsOf:T) where T:SequenceOf&lt;Element&gt;<br>&gt; <br>&gt; Much easier to discern (at least IMO) because everything is aligned.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Are there any other languages that do this? Or anything even similar? It seems to me that the context-switching is something that human beings in general are not going to find very legible; like if you insert too many commas in a sentence.<br>&gt; <br>&gt; Yes, Ceylon places all constraints (it only knows inheritance constraints) at the end:<br>&gt; <br>&gt; shared Value sum&lt;Value&gt;({Value+} values) <br>&gt;         given Value satisfies Summable&lt;Value&gt; { ... }<br>&gt; shared &lt;Key-&gt;Item&gt;[] zip&lt;Key,Item&gt;({Key*} keys, {Item*} items)<br>&gt;         given Key satisfies Object<br>&gt;         given Item satisfies Object { ... }<br>&gt; <br>&gt; It does the same for type definitions:<br>&gt; shared class Singleton&lt;out Element&gt;(Element element)<br>&gt;         extends Object()<br>&gt;         satisfies [Element+]<br>&gt;         given Element satisfies Object { ... }<br>&gt; <br></p><p>This confirms my impression that WHERE does not fit as well at the end as if the information was inlined. WITH is my preferred replacement, which IMO has a similar connotation as ceylon&#39;s GIVEN.<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On 15 May 2016, at 16:05, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There we are. I read the declaration of the function from beginning to end<br>&gt;&gt;&gt;&gt; and gradually formed a rough understanding of it without needing to change<br>&gt;&gt;&gt;&gt; my expectations halfway through. I still have doubts about &#39;insertCount&#39;,<br>&gt;&gt;&gt;&gt; but I was at least able to formulate an hypothesis about its use.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; YMMV, but as far as I&#39;m concerned, the original declaration was much easier<br>&gt;&gt;&gt;&gt; to understand.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I actually agree with you for this case, but not *all* type information *has* to be moved to the end. Try this on for size, which is actually still the most natural way to write this declaration in SE-0081:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal *permits* you to hollow out the generic parameter list to the point of vacuousness, but that doesn&#39;t mean it&#39;s the right thing to do. It might make sense to ban a direct `X: Foo` requirement unless there was already an `X: Bar` in the generic parameter list. Or we might simply need to paraphrase the Perl manual page: &quot;There are several ways to write a generic requirement, so consider picking the most readable one.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/1db065b7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 16, 2016 at 10:00:00am</p></header><div class="content"><p>Funny, for me reading a function is quite the other way around:<br>I prefer to first look at the function name and parameter list to give me an idea of what the function will do (the parameter names help a lot).<br>Having instead first to memorize a list of types with all their constraints just builds up the cognitive load without helping much, because their usage is yet unknown.<br></p><p>So, for me reading the signature would look like (with the proposal in place):<br></p><p>&gt;&gt; internal func _arrayOutOfPlaceReplace&lt;B,C&gt;(_ source: inout B, _ bounds: Range&lt;Int&gt;, _ newValues: C, _ insertCount: Int)<br></p><p>Ah, this function does some replacement within a source which is mutated. The replacement seems to affect a range within the source and there are some new values given together with their count.<br>Now I have already a feeling what the method does and can look at the types to get more details.<br></p><p>If I would have to read the types first I would not have been able to extract as much information from them to guess what the function does, so trying to interpret them would just have been a waste of time and I would have to look them up again after reading the parameter list anyway.<br></p><p>-Thorsten<br></p><p><br></p><p>&gt; Am 15.05.2016 um 12:38 schrieb Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; David Hart via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Hi Karl,<br>&gt;&gt; <br>&gt;&gt; As author of this proposal, the one about constraints on associated types,<br>&gt; and the one on type-aliases in protocols (all from the Generics Manifesto -<br>&gt; original authorship to Douglas Gregor) I’d like to provide additional<br>&gt; reasoning behind my wish to push this proposal through, as a whole.<br>&gt;&gt; <br>&gt;&gt; First of all, there is a personal preference. I’ve used C# for many many<br>&gt; years, which has its where clause at the end of the declaration (like this<br>&gt; proposal), and I’ve used Swift since its unveiling. The experience with<br>&gt; using both styles for several years makes me favour this proposal’s syntax<br>&gt; because I find it much easier to read and format for readability.<br>&gt;&gt; <br>&gt;&gt; Constraints on associated type will provide more expressivity but I doubt<br>&gt; it will greatly reduce protocol constraint clauses in a majority of cases.<br>&gt; And yes, type-aliases in protocols will shorten clauses, but I still think<br>&gt; they will more readable with the where clause at the end.<br>&gt;&gt; <br>&gt;&gt; For example, here is a method I took (as-is) from the Standard Library<br>&gt; which has a few constraints, and which I further simplified if we imagine<br>&gt; that Sequence has an Element typealias for Iterator.Element:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; internal func _arrayOutOfPlaceReplace&lt;<br>&gt;&gt;   B : _ArrayBufferProtocol, C : Collection<br>&gt;&gt;   where  C.Element == B.Element,<br>&gt;&gt;   B.Index == Int<br>&gt;&gt;&gt; (  _ source: inout B, _ bounds: Range&lt;Int&gt;, _ newValues:<br>&gt;&gt; C, _ insertCount: Int) {<br>&gt;&gt; <br>&gt;&gt; See how the Standard Library authors formatted it for readability and how<br>&gt; as a consequence arguments which use the generic types are further apart<br>&gt; from the declaration of those generic types. But with this proposal, the<br>&gt; declaration might be formatted to:<br>&gt;&gt; <br>&gt;&gt; internal func _arrayOutOfPlaceReplace&lt;B,C&gt;(_ source: inout B,<br>&gt;&gt;  _ bounds: Range&lt;Int&gt;, _ newValues: C, _ insertCount: Int)<br>&gt;&gt;   where<br>&gt;&gt; B : _ArrayBufferProtocol,<br>&gt;&gt;   C : Collection,<br>&gt;&gt;   C.Iterator.Element == B.Element,<br>&gt;&gt;   B.Index == Int<br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; Do you need believe this is now more readable?<br>&gt;&gt; <br>&gt;&gt; David.<br>&gt; <br>&gt; Thanks for the real world example!<br>&gt; <br>&gt; I think that the second arguably *looks* better. But is it more *readable*?<br>&gt; Not for me.<br>&gt; <br>&gt; Let me try to do a brain dump while I mentally parse the declaration.<br>&gt; <br>&gt;&gt; internal func _arrayOutOfPlaceReplace&lt;B,C&gt;(<br>&gt; <br>&gt; Mmm, here we have a function that has something to do with arrays, generic<br>&gt; on two types. Maybe it will take an Array&lt;B&gt; and output an Array&lt;C&gt;?<br>&gt; <br>&gt;&gt; _ source: inout B,<br>&gt; <br>&gt; Ah, the first argument is a B that will be changed. Maybe the function deals<br>&gt; with Array&lt;B&gt; and will replace occurrences of &#39;source&#39; with something else?<br>&gt; <br>&gt;&gt; _ bounds: Range&lt;Int&gt;,<br>&gt; <br>&gt; Ok, this surely must be the range of the Array to operate on.<br>&gt; <br>&gt;&gt; _ newValues: C,<br>&gt; <br>&gt; Oh, this parameter is called &#39;newValues&#39;, so C can&#39;t be a single value. It<br>&gt; must be a Collection, surely.<br>&gt; <br>&gt;&gt; _ insertCount: Int)<br>&gt; <br>&gt; ... I can&#39;t figure out what this could be.<br>&gt; <br>&gt;&gt; where<br>&gt;&gt; B : _ArrayBufferProtocol,<br>&gt; <br>&gt; Oh, B was some kind of buffer. OK so the function probably takes this<br>&gt; buffer, and replaces &#39;range&#39; with &#39;newValues&#39;<br>&gt; <br>&gt;&gt; C : Collection,<br>&gt;&gt; C.Iterator.Element == B.Element,<br>&gt; <br>&gt; Good, this confirms what I thought.<br>&gt; <br>&gt;&gt; B.Index == Int<br>&gt; <br>&gt; Looks like an implementation detail, I guess that&#39;s why &#39;range&#39; is a<br>&gt; Range&lt;Int&gt; and &#39;insertCount&#39; is an Int. Presumably the function needs to do<br>&gt; some operations that the generic Index doesn&#39;t guarantee.<br>&gt; <br>&gt; So that&#39;s the end of it. I have a vague idea of what the function might do,<br>&gt; and had to revise my expectations a few times while reading its declaration.<br>&gt; <br>&gt; <br>&gt; Let&#39;s try again with the original declaration.<br>&gt; <br>&gt;&gt; internal func _arrayOutOfPlaceReplace&lt;<br>&gt;&gt; B : _ArrayBufferProtocol, C : Collection<br>&gt; <br>&gt; OK, here we have a function that deals with Arrays, generic on some buffer<br>&gt; thing and on a Collection. B is presumably what it needs to operate on, and<br>&gt; C will be the thing to replace with.<br>&gt; <br>&gt;&gt; where  C.Element == B.Element,<br>&gt; <br>&gt; Indeed thic confirms that B and C must be compatible.<br>&gt; <br>&gt;&gt; B.Index == Int<br>&gt; <br>&gt; Looks like an implementation detail, presumably we need to indicate the<br>&gt; position in the array where to do the replace.<br>&gt; <br>&gt;&gt;&gt; (  _ source: inout B,<br>&gt; <br>&gt; OK so this is a mutating function, and B is a buffer that will be modified.<br>&gt; <br>&gt;&gt; _ bounds: Range&lt;Int&gt;,<br>&gt; <br>&gt; This is probably the range of the buffer that needs to be replaced, indeed<br>&gt; we had B.Index == Int.<br>&gt; <br>&gt;&gt; _ newValues: C,<br>&gt; <br>&gt; And this collection contains what we need to insert in the buffer.<br>&gt; <br>&gt;&gt; _ insertCount: Int) {<br>&gt; <br>&gt; Not sure what this might be, maybe the function will copy only the first<br>&gt; &#39;insertCount&#39; elements of C.<br>&gt; <br>&gt; There we are. I read the declaration of the function from beginning to end<br>&gt; and gradually formed a rough understanding of it without needing to change<br>&gt; my expectations halfway through. I still have doubts about &#39;insertCount&#39;,<br>&gt; but I was at least able to formulate an hypothesis about its use.<br>&gt; <br>&gt; YMMV, but as far as I&#39;m concerned, the original declaration was much easier<br>&gt; to understand.<br>&gt; <br>&gt; Now if we had generic typealiases, we could do something like<br>&gt; <br>&gt; typealias CollectionOf&lt;T&gt; = protocol&lt;Collection&gt; where Collection.Element == T<br>&gt; <br>&gt; and if my intuition about B.Index is right, the declaration could be further<br>&gt; simplified to something like this<br>&gt; <br>&gt; internal func _arrayOutOfPlaceReplace&lt;<br>&gt;  B : _ArrayBufferProtocol, C : CollectionOf&lt;B.Element&gt;<br>&gt;  where B.Index == Int<br>&gt;&gt; (  _ source: inout B, _ bounds: Range&lt;B.Index&gt;, _ newValues: C, _<br>&gt; insertCount: B.Index) {<br>&gt; <br>&gt; Now *that* is more readable.<br>&gt; <br>&gt; <br>&gt; Nicola<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Review] SE-0081: Move where clause to end of declaration</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>May 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 16 May 2016, Thorsten Seitz wrote:<br>&gt; <br>&gt; Funny, for me reading a function is quite the other way around:<br>&gt; I prefer to first look at the function name and parameter list to give me an idea of what the function will do (the parameter names help a lot).<br>&gt; Having instead first to memorize a list of types with all their constraints just builds up the cognitive load without helping much, because their usage is yet unknown.<br></p><p>This is also my biggest motivation for the proposal: keeping the function name and arguments close to each other.<br></p><p>&gt; So, for me reading the signature would look like (with the proposal in place):<br>&gt; <br>&gt;&gt;&gt; internal func _arrayOutOfPlaceReplace&lt;B,C&gt;(_ source: inout B, _ bounds: Range&lt;Int&gt;, _ newValues: C, _ insertCount: Int)<br></p><p><br>^ Agreed! That&#39;s essentially what I&#39;m trying to find too when skimming through code.<br></p><p>An alternative approach with the same desired outcome would be moving the parameter list before the function name, either `func&lt;...&gt; someFunction(...)`, or even before the `func` keyword. But since we already use `where`, it seems more natural to me for Swift to place the constraints list to the end.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/deda6a47/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
