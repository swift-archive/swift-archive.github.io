<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/597f3bd365c8874248b0e30ea502ad6d?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>David Cordero</string> &lt;dcorderoramirez at gmail.com&gt;<p>August 22, 2016 at 11:00:00pm</p></header><div class="content"><p>*The problem:*<br>At the moment, looking at the code of a class or a struct implementing a<br>protocol, it is hard to know what methods are actually implementing the<br>protocol and what other methods are just part of the code of the class or<br>struct.<br></p><p>People are trying to fix this problem with pragma marks or moving the code<br>conforming the protocol to a separate extension, but they are just specific<br>good practices or code styles.<br></p><p>*Proposal:*<br>Adding a keyword to the methods conforming protocols. As an example please<br>check the following piece of code which uses the keyword `conform` to<br>explicitly indicate that `myMethod` is a method conforming a protocol.<br></p><p>```<br>protocol MyProtocol {<br>    func myMethod() -&gt; String<br>}<br></p><p>class MyClass: MyProtocol {<br></p><p>    *conform* func myMethod() -&gt; String {<br>        return &quot;Yuhuuu,I am conforming \\o//&quot;<br>    }<br></p><p>    func whatever() {<br>        print(&quot;I am a boring method and I don&#39;t conform anything&quot;)<br>    }<br>}<br>```<br></p><p>It would be something similar to the current keyword `override` but for<br>protocols.<br></p><p>Apart from improving code readability, It would allow the detection, in<br>compilation time, of errors due to code evolution. For example redundant<br>methods that no longer conform anything once the requirement is removed<br>from the protocol for whatever reason.<br></p><p>Looking forward your opinions and comments.<br></p><p>Kind Regards<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160822/8b4e67bd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 22, 2016 at 10:00:00pm</p></header><div class="content"><p>This has been proposed before in the past by several others (myself being<br>one of them).<br></p><p>The key problem is that it cannot accommodate retroactive modeling. That<br>is, you would not be able to conform existing types, the code for which you<br>do not control, to a protocol of your own design. Retroactive modeling is<br>an essential feature of Swift protocol-oriented programming.<br>On Mon, Aug 22, 2016 at 4:30 PM David Cordero via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; *The problem:*<br>&gt; At the moment, looking at the code of a class or a struct implementing a<br>&gt; protocol, it is hard to know what methods are actually implementing the<br>&gt; protocol and what other methods are just part of the code of the class or<br>&gt; struct.<br>&gt;<br>&gt; People are trying to fix this problem with pragma marks or moving the code<br>&gt; conforming the protocol to a separate extension, but they are just specific<br>&gt; good practices or code styles.<br>&gt;<br>&gt; *Proposal:*<br>&gt; Adding a keyword to the methods conforming protocols. As an example please<br>&gt; check the following piece of code which uses the keyword `conform` to<br>&gt; explicitly indicate that `myMethod` is a method conforming a protocol.<br>&gt;<br>&gt; ```<br>&gt; protocol MyProtocol {<br>&gt;     func myMethod() -&gt; String<br>&gt; }<br>&gt;<br>&gt; class MyClass: MyProtocol {<br>&gt;<br>&gt;     *conform* func myMethod() -&gt; String {<br>&gt;         return &quot;Yuhuuu,I am conforming \\o//&quot;<br>&gt;     }<br>&gt;<br>&gt;     func whatever() {<br>&gt;         print(&quot;I am a boring method and I don&#39;t conform anything&quot;)<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; It would be something similar to the current keyword `override` but for<br>&gt; protocols.<br>&gt;<br>&gt; Apart from improving code readability, It would allow the detection, in<br>&gt; compilation time, of errors due to code evolution. For example redundant<br>&gt; methods that no longer conform anything once the requirement is removed<br>&gt; from the protocol for whatever reason.<br>&gt;<br>&gt; Looking forward your opinions and comments.<br>&gt;<br>&gt; Kind Regards<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160822/5755fdf8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 22, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Aug 22, 2016, at 5:19 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This has been proposed before in the past by several others (myself being one of them).<br>&gt; <br>&gt; The key problem is that it cannot accommodate retroactive modeling. That is, you would not be able to conform existing types, the code for which you do not control, to a protocol of your own design. Retroactive modeling is an essential feature of Swift protocol-oriented programming.<br></p><p>Then how about making the keyword optional? A method or property with the keyword before it would throw an error if it didn’t exist in one of the protocols your type implements. This way, if you intended a method to satisfy a protocol but left a typo in it, or you changed the protocol’s signature in a refactoring or something, you’d get notified instead of not finding out about it until runtime.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160822/56103cd0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 22, 2016 at 10:00:00pm</p></header><div class="content"><p>There&#39;s been agreement even from the core team that the quality of<br>diagnostics when conforming to a protocol is sub-par.<br></p><p>The modified rule you propose has also been suggested before. The reason it<br>doesn&#39;t help is that (1) if a method signature is mismatched accidentally<br>due to a typo, you get a compilation error already because your type<br>doesn&#39;t conform to the protocol (it&#39;s the quality of the error message that<br>needs improvement); (2) otherwise, if your type fulfills all protocol<br>requirements but also implements an additional method unnecessary for<br>conformance, what is the harm that is being prevented by a compiler error?<br></p><p>On Mon, Aug 22, 2016 at 17:30 Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 22, 2016, at 5:19 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; This has been proposed before in the past by several others (myself being<br>&gt; one of them).<br>&gt;<br>&gt; The key problem is that it cannot accommodate retroactive modeling. That<br>&gt; is, you would not be able to conform existing types, the code for which you<br>&gt; do not control, to a protocol of your own design. Retroactive modeling is<br>&gt; an essential feature of Swift protocol-oriented programming.<br>&gt;<br>&gt;<br>&gt; Then how about making the keyword optional? A method or property with the<br>&gt; keyword before it would throw an error if it didn’t exist in one of the<br>&gt; protocols your type implements. This way, if you intended a method to<br>&gt; satisfy a protocol but left a typo in it, or you changed the protocol’s<br>&gt; signature in a refactoring or something, you’d get notified instead of not<br>&gt; finding out about it until runtime.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160822/99bee93e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 22, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Aug 22, 2016, at 5:41 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; There&#39;s been agreement even from the core team that the quality of diagnostics when conforming to a protocol is sub-par.<br>&gt; <br>&gt; The modified rule you propose has also been suggested before. The reason it doesn&#39;t help is that (1) if a method signature is mismatched accidentally due to a typo, you get a compilation error already because your type doesn&#39;t conform to the protocol (it&#39;s the quality of the error message that needs improvement);<br></p><p>You don’t get any error at all if there’s a default value.<br></p><p>protocol P {<br>	func doSomething()<br>}<br></p><p>extension P {<br>	func doSomething() { print(“Do This Thing”) }<br>}<br></p><p>struct S: P {<br>	func doSomthing() { print(“Do This Instead”) } // Whoops, doesn’t get called. And we don’t find out until mysterious behavior occurs at runtime.<br>}<br></p><p>If there were a way to tell the compiler that the function was meant to satisfy a protocol, we could prevent the mistake above from occurring.<br></p><p>&gt; (2) otherwise, if your type fulfills all protocol requirements but also implements an additional method unnecessary for conformance, what is the harm that is being prevented by a compiler error?<br></p><p>The fact that implementing protocol requirements that have default values is, in effect, stringly typed.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160822/76bef78d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 22, 2016 at 11:00:00pm</p></header><div class="content"><p>That&#39;s a good point. Since you&#39;re proposing an optional keyword, though,<br>aren&#39;t you describing a linter functionality?<br>On Mon, Aug 22, 2016 at 18:25 Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 22, 2016, at 5:41 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; There&#39;s been agreement even from the core team that the quality of<br>&gt; diagnostics when conforming to a protocol is sub-par.<br>&gt;<br>&gt; The modified rule you propose has also been suggested before. The reason<br>&gt; it doesn&#39;t help is that (1) if a method signature is mismatched<br>&gt; accidentally due to a typo, you get a compilation error already because<br>&gt; your type doesn&#39;t conform to the protocol (it&#39;s the quality of the error<br>&gt; message that needs improvement);<br>&gt;<br>&gt;<br>&gt; You don’t get any error at all if there’s a default value.<br>&gt;<br>&gt; protocol P {<br>&gt; func doSomething()<br>&gt; }<br>&gt;<br>&gt; extension P {<br>&gt; func doSomething() { print(“Do This Thing”) }<br>&gt; }<br>&gt;<br>&gt; struct S: P {<br>&gt; func doSomthing() { print(“Do This Instead”) } // Whoops, doesn’t get<br>&gt; called. And we don’t find out until mysterious behavior occurs at runtime.<br>&gt; }<br>&gt;<br>&gt; If there were a way to tell the compiler that the function was meant to<br>&gt; satisfy a protocol, we could prevent the mistake above from occurring.<br>&gt;<br>&gt; (2) otherwise, if your type fulfills all protocol requirements but also<br>&gt; implements an additional method unnecessary for conformance, what is the<br>&gt; harm that is being prevented by a compiler error?<br>&gt;<br>&gt;<br>&gt; The fact that implementing protocol requirements that have default values<br>&gt; is, in effect, stringly typed.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160822/8ea0db41/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 22, 2016 at 07:00:00pm</p></header><div class="content"><p>On Aug 22, 2016, at 6:33 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; That&#39;s a good point. Since you&#39;re proposing an optional keyword, though, aren&#39;t you describing a linter functionality?<br></p><p>If the optionality of the keyword bothers you, there are multiple ways to do it:<br></p><p>Solution #1: Optional keyword.<br></p><p>protocol P {<br>	func giveUpTheFunc()<br>}<br></p><p>struct S: P {<br>	implement func giveUpTheFunc()<br>}<br></p><p>Solution #2: Required keyword, but with a manual override for protocols that need to be retroactive.<br></p><p>protocol P {<br>	@retro func giveUpTheFunc()<br>}<br></p><p>struct S {<br>	func giveUpTheFunc()<br>}<br></p><p>extension S: P {}<br></p><p>Solution #3: No keyword, but extensions that conform to protocols can’t have anything other than protocol conformances unless they’re private.<br></p><p>protocol P {<br>	func giveUpTheFunc()<br>}<br></p><p>struct S {}<br></p><p>extension S: P {<br>	func giveUpTheFunc() {}<br>	func tearTheRoofOffTheSucker() {} // error!<br>}<br></p><p>but this is okay:<br></p><p>extension S: P {<br>	func giveUpTheFunc() {<br>		tearTheRoofOffTheSucker()<br>	}<br></p><p>	private func tearTheRoofOffTheSucker() {} // works :-)<br>}<br></p><p>There are definitely a range of ways to make protocol conformance more explicit. Which one is the best, I’m not sure, but we could probably flesh out the pros and cons of these, as well as any other options that I haven’t thought of, with some discussion.<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 22, 2016 at 07:00:00pm</p></header><div class="content"><p>On Mon, Aug 22, 2016 at 7:02 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 22, 2016, at 6:33 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; That&#39;s a good point. Since you&#39;re proposing an optional keyword, though,<br>&gt; aren&#39;t you describing a linter functionality?<br>&gt;<br>&gt; If the optionality of the keyword bothers you, there are multiple ways to<br>&gt; do it:<br>&gt;<br>&gt; Solution #1: Optional keyword.<br>&gt;<br>&gt; protocol P {<br>&gt;         func giveUpTheFunc()<br>&gt; }<br>&gt;<br>&gt; struct S: P {<br>&gt;         implement func giveUpTheFunc()<br>&gt; }<br>&gt;<br>&gt; Solution #2: Required keyword, but with a manual override for protocols<br>&gt; that need to be retroactive.<br>&gt;<br>&gt; protocol P {<br>&gt;         @retro func giveUpTheFunc()<br>&gt; }<br>&gt;<br>&gt; struct S {<br>&gt;         func giveUpTheFunc()<br>&gt; }<br>&gt;<br>&gt; extension S: P {}<br>&gt;<br>&gt; Solution #3: No keyword, but extensions that conform to protocols can’t<br>&gt; have anything other than protocol conformances unless they’re private.<br>&gt;<br>&gt; protocol P {<br>&gt;         func giveUpTheFunc()<br>&gt; }<br>&gt;<br>&gt; struct S {}<br>&gt;<br>&gt; extension S: P {<br>&gt;         func giveUpTheFunc() {}<br>&gt;         func tearTheRoofOffTheSucker() {} // error!<br>&gt; }<br>&gt;<br>&gt; but this is okay:<br>&gt;<br>&gt; extension S: P {<br>&gt;         func giveUpTheFunc() {<br>&gt;                 tearTheRoofOffTheSucker()<br>&gt;         }<br>&gt;<br>&gt;         private func tearTheRoofOffTheSucker() {} // works :-)<br>&gt; }<br>&gt;<br>&gt; There are definitely a range of ways to make protocol conformance more<br>&gt; explicit. Which one is the best, I’m not sure, but we could probably flesh<br>&gt; out the pros and cons of these, as well as any other options that I haven’t<br>&gt; thought of, with some discussion.<br>&gt;<br>&gt; Charles<br>&gt;<br></p><p><br>Sure, I too am not convinced we&#39;ve exhausted all the design possibilities.<br>Here are some previous related threads (including one launched by a core<br>team member):<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005380.html<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160229/011792.html<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/015920.html<br></p><p>Somewhat related, but definitely a different topic:<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018286.html<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160822/d63d079b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>August 23, 2016 at 07:00:00am</p></header><div class="content"><p>I don&#39;t see it as sub-par in this example (this actually happened to me):<br></p><p>@objc protocol Foo {<br>	optional func bar()<br>}<br></p><p>class FooImpl: Foo {<br>	func bar() { ... }<br>}<br></p><p>Now imagine that bar() gets renamed in the protocol to baz(). You get no warnings, nothing - since the bar() was optional (or can have default implementation as Chalers mentioned). FooImpl still conforms to Foo and bar() can live on there happily.<br></p><p>Yes, this could be solved by Xcode having a refactoring feature that works for Swift, or that you search &amp; replace when renaming, but still doesn&#39;t solve when a 3rd party library does this and suddenly the behavior of your app changes completely. This goes against the compile-time safety Swift is about.<br></p><p>Currently, when you mark a method on a protocol as<br></p><p>@available(*, unavailable, renamed=&quot;baz&quot;)<br></p><p>you do not get any warnings either - perhaps that&#39;s the issue here. On the other hand, the naming may be completely coincidental and you can already have a method called bar() and it would then be impossible to conform to Foo unless you rename bar().<br></p><p>What I&#39;d propose is not to make keyword optional. In case you implement the members declared by the protocol, mark it as @conforming (or conforming keyword?).<br></p><p>If it&#39;s retroactive modeling, redeclare the members. E.g.:<br></p><p>extension Bar: Foo {<br>	// The implementation will be taken from Bar&#39;s main implementation<br>	@conforming func bar()<br>}<br></p><p>But yeah, it&#39;s a bit of boilerplate...<br></p><p>&gt; On Aug 23, 2016, at 12:41 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There&#39;s been agreement even from the core team that the quality of diagnostics when conforming to a protocol is sub-par.<br>&gt; <br>&gt; The modified rule you propose has also been suggested before. The reason it doesn&#39;t help is that (1) if a method signature is mismatched accidentally due to a typo, you get a compilation error already because your type doesn&#39;t conform to the protocol (it&#39;s the quality of the error message that needs improvement); (2) otherwise, if your type fulfills all protocol requirements but also implements an additional method unnecessary for conformance, what is the harm that is being prevented by a compiler error?<br>&gt; <br>&gt; On Mon, Aug 22, 2016 at 17:30 Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; On Aug 22, 2016, at 5:19 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This has been proposed before in the past by several others (myself being one of them).<br>&gt;&gt; <br>&gt;&gt; The key problem is that it cannot accommodate retroactive modeling. That is, you would not be able to conform existing types, the code for which you do not control, to a protocol of your own design. Retroactive modeling is an essential feature of Swift protocol-oriented programming.<br>&gt; <br>&gt; Then how about making the keyword optional? A method or property with the keyword before it would throw an error if it didn’t exist in one of the protocols your type implements. This way, if you intended a method to satisfy a protocol but left a typo in it, or you changed the protocol’s signature in a refactoring or something, you’d get notified instead of not finding out about it until runtime.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/ffdeefd3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/597f3bd365c8874248b0e30ea502ad6d?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>David Cordero</string> &lt;dcorderoramirez at gmail.com&gt;<p>August 23, 2016 at 08:00:00am</p></header><div class="content"><p>I agree with Charlie Monroe. I think it would improve the compile time<br>safety of Swift, making the keyword non optional.<br></p><p>The main issue with retroactive modelling is that it is applied to code to<br>which we might have no control at all. So this boilerplate definition would<br>allow the detection of changes on method signatures on this non controlled<br>code.<br></p><p>It might be easier to read having two different keywords for the 2<br>different cases. Something like the following code using `implement` when<br>implementing the protocol and `conform` when retroactive modeling<br></p><p>protocol MyProtocol {<br>    func method() -&gt; String<br>}<br></p><p>class MyClass {<br></p><p>    implement func method() -&gt; String {<br>        return &quot;World&quot;<br>    }<br>}<br></p><p>class MyNonControlledClass {<br></p><p>    func method() -&gt; String {<br>        return &quot;Hello&quot;<br>    }<br>}<br></p><p><br>extension MyNonControlledClass: MyProtocol {<br>    conform method() -&gt; String<br>}<br></p><p><br>Or even with a general way to declare a full conformance of a protocol:<br></p><p>extension MyNonControlledClass: conform(MyProtocol) {<br>}<br></p><p><br>On 23 August 2016 at 07:11, Charlie Monroe via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I don&#39;t see it as sub-par in this example (this actually happened to me):<br>&gt;<br>&gt; @objc protocol Foo {<br>&gt; optional func bar()<br>&gt; }<br>&gt;<br>&gt; class FooImpl: Foo {<br>&gt; func bar() { ... }<br>&gt; }<br>&gt;<br>&gt; Now imagine that bar() gets renamed in the protocol to baz(). You get no<br>&gt; warnings, nothing - since the bar() was optional (or can have default<br>&gt; implementation as Chalers mentioned). FooImpl still conforms to Foo and<br>&gt; bar() can live on there happily.<br>&gt;<br>&gt; Yes, this could be solved by Xcode having a refactoring feature that works<br>&gt; for Swift, or that you search &amp; replace when renaming, but still doesn&#39;t<br>&gt; solve when a 3rd party library does this and suddenly the behavior of your<br>&gt; app changes completely. This goes against the compile-time safety Swift is<br>&gt; about.<br>&gt;<br>&gt; Currently, when you mark a method on a protocol as<br>&gt;<br>&gt; @available(*, unavailable, renamed=&quot;baz&quot;)<br>&gt;<br>&gt; you do not get any warnings either - perhaps that&#39;s the issue here. On the<br>&gt; other hand, the naming may be completely coincidental and you can already<br>&gt; have a method called bar() and it would then be impossible to conform to<br>&gt; Foo unless you rename bar().<br>&gt;<br>&gt; What I&#39;d propose is not to make keyword optional. In case you implement<br>&gt; the members declared by the protocol, mark it as @conforming (or conforming<br>&gt; keyword?).<br>&gt;<br>&gt; If it&#39;s retroactive modeling, redeclare the members. E.g.:<br>&gt;<br>&gt; extension Bar: Foo {<br>&gt; // The implementation will be taken from Bar&#39;s main implementation<br>&gt; @conforming func bar()<br>&gt; }<br>&gt;<br>&gt; But yeah, it&#39;s a bit of boilerplate...<br>&gt;<br>&gt; On Aug 23, 2016, at 12:41 AM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; There&#39;s been agreement even from the core team that the quality of<br>&gt; diagnostics when conforming to a protocol is sub-par.<br>&gt;<br>&gt; The modified rule you propose has also been suggested before. The reason<br>&gt; it doesn&#39;t help is that (1) if a method signature is mismatched<br>&gt; accidentally due to a typo, you get a compilation error already because<br>&gt; your type doesn&#39;t conform to the protocol (it&#39;s the quality of the error<br>&gt; message that needs improvement); (2) otherwise, if your type fulfills all<br>&gt; protocol requirements but also implements an additional method unnecessary<br>&gt; for conformance, what is the harm that is being prevented by a compiler<br>&gt; error?<br>&gt;<br>&gt; On Mon, Aug 22, 2016 at 17:30 Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Aug 22, 2016, at 5:19 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This has been proposed before in the past by several others (myself being<br>&gt;&gt; one of them).<br>&gt;&gt;<br>&gt;&gt; The key problem is that it cannot accommodate retroactive modeling. That<br>&gt;&gt; is, you would not be able to conform existing types, the code for which you<br>&gt;&gt; do not control, to a protocol of your own design. Retroactive modeling is<br>&gt;&gt; an essential feature of Swift protocol-oriented programming.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Then how about making the keyword optional? A method or property with the<br>&gt;&gt; keyword before it would throw an error if it didn’t exist in one of the<br>&gt;&gt; protocols your type implements. This way, if you intended a method to<br>&gt;&gt; satisfy a protocol but left a typo in it, or you changed the protocol’s<br>&gt;&gt; signature in a refactoring or something, you’d get notified instead of not<br>&gt;&gt; finding out about it until runtime.<br>&gt;&gt;<br>&gt;&gt; Charles<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/d3b11b02/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 23, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On Aug 23, 2016, at 12:11 AM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt; I don&#39;t see it as sub-par in this example (this actually happened to me):<br>&gt; <br>&gt; @objc protocol Foo {<br>&gt; 	optional func bar()<br>&gt; }<br>&gt; <br>&gt; class FooImpl: Foo {<br>&gt; 	func bar() { ... }<br>&gt; }<br>&gt; <br>&gt; Now imagine that bar() gets renamed in the protocol to baz(). You get no warnings, nothing - since the bar() was optional (or can have default implementation as Chalers mentioned). FooImpl still conforms to Foo and bar() can live on there happily.<br></p><p>Had that happen to me a bunch of times, especially when I realize that the method needs to have one more argument and then forget to add it everywhere (which is harder to use search-and-replace for, as well).<br></p><p>Here’s another case where this can bite you:<br></p><p>In file P.swift:<br></p><p>protocol P {<br>	func foo()<br>}<br></p><p>extension P {<br>	func foo()<br>}<br></p><p>In another file, S.swift:<br></p><p>struct S: P {}<br></p><p>Imagine I rename foo in the protocol, but forget to rename it in the extension. The method no longer has a default implementation, and we do indeed get an error, but the error’s in S.swift, in the wrong place. S complains that it doesn’t conform to the protocol. If there were a keyword on foo() in the extension, the compiler warning would be right where the problem is as soon as I renamed the method in the protocol, and it’d be a 2-second fix.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/a824896b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>August 23, 2016 at 09:00:00am</p></header><div class="content"><p>Just want to add my voice to the chorus of “this has happened to me too.”<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Aug 23, 2016, at 2:13 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 23, 2016, at 12:11 AM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see it as sub-par in this example (this actually happened to me):<br>&gt;&gt; <br>&gt;&gt; @objc protocol Foo {<br>&gt;&gt; 	optional func bar()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class FooImpl: Foo {<br>&gt;&gt; 	func bar() { ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Now imagine that bar() gets renamed in the protocol to baz(). You get no warnings, nothing - since the bar() was optional (or can have default implementation as Chalers mentioned). FooImpl still conforms to Foo and bar() can live on there happily.<br>&gt; <br>&gt; Had that happen to me a bunch of times, especially when I realize that the method needs to have one more argument and then forget to add it everywhere (which is harder to use search-and-replace for, as well).<br>&gt; <br>&gt; Here’s another case where this can bite you:<br>&gt; <br>&gt; In file P.swift:<br>&gt; <br>&gt; protocol P {<br>&gt; 	func foo()<br>&gt; }<br>&gt; <br>&gt; extension P {<br>&gt; 	func foo()<br>&gt; }<br>&gt; <br>&gt; In another file, S.swift:<br>&gt; <br>&gt; struct S: P {}<br>&gt; <br>&gt; Imagine I rename foo in the protocol, but forget to rename it in the extension. The method no longer has a default implementation, and we do indeed get an error, but the error’s in S.swift, in the wrong place. S complains that it doesn’t conform to the protocol. If there were a keyword on foo() in the extension, the compiler warning would be right where the problem is as soon as I renamed the method in the protocol, and it’d be a 2-second fix.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 23, 2016 at 10:00:00am</p></header><div class="content"><p>On Tue, Aug 23, 2016 at 2:13 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 23, 2016, at 12:11 AM, Charlie Monroe &lt;charlie at charliemonroe.net&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; I don&#39;t see it as sub-par in this example (this actually happened to me):<br>&gt;<br>&gt; @objc protocol Foo {<br>&gt; optional func bar()<br>&gt; }<br>&gt;<br>&gt; class FooImpl: Foo {<br>&gt; func bar() { ... }<br>&gt; }<br>&gt;<br>&gt; Now imagine that bar() gets renamed in the protocol to baz(). You get no<br>&gt; warnings, nothing - since the bar() was optional (or can have default<br>&gt; implementation as Chalers mentioned). FooImpl still conforms to Foo and<br>&gt; bar() can live on there happily.<br>&gt;<br>&gt;<br>&gt; Had that happen to me a bunch of times, especially when I realize that the<br>&gt; method needs to have one more argument and then forget to add it everywhere<br>&gt; (which is harder to use search-and-replace for, as well).<br>&gt;<br>&gt; Here’s another case where this can bite you:<br>&gt;<br>&gt; In file P.swift:<br>&gt;<br>&gt; protocol P {<br>&gt; func foo()<br>&gt; }<br>&gt;<br>&gt; extension P {<br>&gt; func foo()<br>&gt; }<br>&gt;<br>&gt; In another file, S.swift:<br>&gt;<br>&gt; struct S: P {}<br>&gt;<br>&gt; Imagine I rename foo in the protocol, but forget to rename it in the<br>&gt; extension. The method no longer has a default implementation, and we do<br>&gt; indeed get an error, but the error’s in S.swift, in the wrong place. S<br>&gt; complains that it doesn’t conform to the protocol. If there were a keyword<br>&gt; on foo() in the extension, the compiler warning would be right where the<br>&gt; problem is as soon as I renamed the method in the protocol, and it’d be a<br>&gt; 2-second fix.<br>&gt;<br></p><p>This is a great motivating example, I think. I&#39;m convinced that we need<br>some way to improve this scenario.<br></p><p>That said, it&#39;d probably have to be opt-in because major source-breaking<br>changes are going to be frowned upon for Swift 4, and changing the syntax<br>for every single protocol conformance would be hugely source-breaking. That<br>said, I think an opt-in level of safety, where you mark particular<br>declarations or even entire extensions as `@conforming` (or some similar<br>syntax) would give the user most or all of these benefits while maintaining<br>source compatibility. I would be +1 on a proposal like that.<br></p><p><br></p><p>&gt; Charles<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/b2e00f44/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/597f3bd365c8874248b0e30ea502ad6d?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>David Cordero</string> &lt;dcorderoramirez at gmail.com&gt;<p>August 24, 2016 at 12:00:00am</p></header><div class="content"><p>It sounds to me.<br></p><p>In fact it looks like we already have quite interesting information to<br>prepare a rough Draft to summarise all these scenarios in a real proposal.<br></p><p><br></p><p><br>On 23 August 2016 at 17:50, Xiaodi Wu via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Tue, Aug 23, 2016 at 2:13 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Aug 23, 2016, at 12:11 AM, Charlie Monroe &lt;charlie at charliemonroe.net&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don&#39;t see it as sub-par in this example (this actually happened to me):<br>&gt;&gt;<br>&gt;&gt; @objc protocol Foo {<br>&gt;&gt; optional func bar()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class FooImpl: Foo {<br>&gt;&gt; func bar() { ... }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Now imagine that bar() gets renamed in the protocol to baz(). You get no<br>&gt;&gt; warnings, nothing - since the bar() was optional (or can have default<br>&gt;&gt; implementation as Chalers mentioned). FooImpl still conforms to Foo and<br>&gt;&gt; bar() can live on there happily.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Had that happen to me a bunch of times, especially when I realize that<br>&gt;&gt; the method needs to have one more argument and then forget to add it<br>&gt;&gt; everywhere (which is harder to use search-and-replace for, as well).<br>&gt;&gt;<br>&gt;&gt; Here’s another case where this can bite you:<br>&gt;&gt;<br>&gt;&gt; In file P.swift:<br>&gt;&gt;<br>&gt;&gt; protocol P {<br>&gt;&gt; func foo()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension P {<br>&gt;&gt; func foo()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; In another file, S.swift:<br>&gt;&gt;<br>&gt;&gt; struct S: P {}<br>&gt;&gt;<br>&gt;&gt; Imagine I rename foo in the protocol, but forget to rename it in the<br>&gt;&gt; extension. The method no longer has a default implementation, and we do<br>&gt;&gt; indeed get an error, but the error’s in S.swift, in the wrong place. S<br>&gt;&gt; complains that it doesn’t conform to the protocol. If there were a keyword<br>&gt;&gt; on foo() in the extension, the compiler warning would be right where the<br>&gt;&gt; problem is as soon as I renamed the method in the protocol, and it’d be a<br>&gt;&gt; 2-second fix.<br>&gt;&gt;<br>&gt;<br>&gt; This is a great motivating example, I think. I&#39;m convinced that we need<br>&gt; some way to improve this scenario.<br>&gt;<br>&gt; That said, it&#39;d probably have to be opt-in because major source-breaking<br>&gt; changes are going to be frowned upon for Swift 4, and changing the syntax<br>&gt; for every single protocol conformance would be hugely source-breaking. That<br>&gt; said, I think an opt-in level of safety, where you mark particular<br>&gt; declarations or even entire extensions as `@conforming` (or some similar<br>&gt; syntax) would give the user most or all of these benefits while maintaining<br>&gt; source compatibility. I would be +1 on a proposal like that.<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; Charles<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/0d9bb02e/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 23, 2016 at 10:00:00am</p></header><div class="content"><p>On Tue, Aug 23, 2016 at 12:11 AM, Charlie Monroe &lt;charlie at charliemonroe.net&gt;<br>wrote:<br></p><p>&gt; I don&#39;t see it as sub-par in this example (this actually happened to me):<br>&gt;<br>&gt; @objc protocol Foo {<br>&gt; optional func bar()<br>&gt; }<br>&gt;<br>&gt; class FooImpl: Foo {<br>&gt; func bar() { ... }<br>&gt; }<br>&gt;<br>&gt; Now imagine that bar() gets renamed in the protocol to baz(). You get no<br>&gt; warnings, nothing - since the bar() was optional (or can have default<br>&gt; implementation as Chalers mentioned). FooImpl still conforms to Foo and<br>&gt; bar() can live on there happily.<br>&gt;<br></p><p>I think we&#39;re having a language barrier here :) Sub-par means inadequate,<br>and I think we&#39;re all in agreement that this behavior is inadequate.<br></p><p><br>&gt;<br>&gt; Yes, this could be solved by Xcode having a refactoring feature that works<br>&gt; for Swift, or that you search &amp; replace when renaming, but still doesn&#39;t<br>&gt; solve when a 3rd party library does this and suddenly the behavior of your<br>&gt; app changes completely. This goes against the compile-time safety Swift is<br>&gt; about.<br>&gt;<br>&gt; Currently, when you mark a method on a protocol as<br>&gt;<br>&gt; @available(*, unavailable, renamed=&quot;baz&quot;)<br>&gt;<br>&gt; you do not get any warnings either - perhaps that&#39;s the issue here.<br>&gt;<br></p><p>I think we should separate out the discussion about library evolution and<br>versioning. There&#39;s a huge amount of proposed and (I think) planned work<br>about that. Maybe the core team could chime in on how up-to-date this<br>document is:<br></p><p>https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst<br></p><p>If the true motivating problem here has to do with library evolution, then<br>we should probably study that document and wait to see how that planned<br>work turns out.<br></p><p>But if I understand it correctly, the true motivating problem here is the<br>poor experience of conforming to a protocol, the errors caused by typos<br>that effectively make protocol requirements stringily typed, and the<br>resultant unanticipated behaviors that arise, then we can have a useful<br>discussion about these issues without also trying to solve library<br>evolution with a single keyword.<br></p><p><br>&gt; On the other hand, the naming may be completely coincidental and you can<br>&gt; already have a method called bar() and it would then be impossible to<br>&gt; conform to Foo unless you rename bar().<br>&gt;<br>&gt; What I&#39;d propose is not to make keyword optional. In case you implement<br>&gt; the members declared by the protocol, mark it as @conforming (or conforming<br>&gt; keyword?).<br>&gt;<br>&gt; If it&#39;s retroactive modeling, redeclare the members. E.g.:<br>&gt;<br>&gt; extension Bar: Foo {<br>&gt; // The implementation will be taken from Bar&#39;s main implementation<br>&gt; @conforming func bar()<br>&gt; }<br>&gt;<br>&gt; But yeah, it&#39;s a bit of boilerplate...<br>&gt;<br>&gt; On Aug 23, 2016, at 12:41 AM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; There&#39;s been agreement even from the core team that the quality of<br>&gt; diagnostics when conforming to a protocol is sub-par.<br>&gt;<br>&gt; The modified rule you propose has also been suggested before. The reason<br>&gt; it doesn&#39;t help is that (1) if a method signature is mismatched<br>&gt; accidentally due to a typo, you get a compilation error already because<br>&gt; your type doesn&#39;t conform to the protocol (it&#39;s the quality of the error<br>&gt; message that needs improvement); (2) otherwise, if your type fulfills all<br>&gt; protocol requirements but also implements an additional method unnecessary<br>&gt; for conformance, what is the harm that is being prevented by a compiler<br>&gt; error?<br>&gt;<br>&gt; On Mon, Aug 22, 2016 at 17:30 Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Aug 22, 2016, at 5:19 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This has been proposed before in the past by several others (myself being<br>&gt;&gt; one of them).<br>&gt;&gt;<br>&gt;&gt; The key problem is that it cannot accommodate retroactive modeling. That<br>&gt;&gt; is, you would not be able to conform existing types, the code for which you<br>&gt;&gt; do not control, to a protocol of your own design. Retroactive modeling is<br>&gt;&gt; an essential feature of Swift protocol-oriented programming.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Then how about making the keyword optional? A method or property with the<br>&gt;&gt; keyword before it would throw an error if it didn’t exist in one of the<br>&gt;&gt; protocols your type implements. This way, if you intended a method to<br>&gt;&gt; satisfy a protocol but left a typo in it, or you changed the protocol’s<br>&gt;&gt; signature in a refactoring or something, you’d get notified instead of not<br>&gt;&gt; finding out about it until runtime.<br>&gt;&gt;<br>&gt;&gt; Charles<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/73ec6d32/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>August 23, 2016 at 12:00:00pm</p></header><div class="content"><p>~Robert Widmann<br></p><p>2016/08/22 14:30、David Cordero via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; <br>&gt; The problem:<br>&gt; At the moment, looking at the code of a class or a struct implementing a protocol, it is hard to know what methods are actually implementing the protocol and what other methods are just part of the code of the class or struct.<br>&gt; <br></p><p>That seems like a feature, not a bug.  Why should I as an author care whether a method contributes to a protocol conformance or not if the compiler can tell me that kind of information itself?<br></p><p><br>&gt; People are trying to fix this problem with pragma marks or moving the code conforming the protocol to a separate extension, but they are just specific good practices or code styles.<br>&gt; <br></p><p>Hm?  I haven&#39;t seen anything like this used.  If you mean doc comments explaining which protocol things are tied to, then that just seems like a style choice.<br></p><p>&gt; Proposal:<br>&gt; Adding a keyword to the methods conforming protocols. As an example please check the following piece of code which uses the keyword `conform` to explicitly indicate that `myMethod` is a method conforming a protocol.<br></p><p>Please, no more keywords.<br></p><p>&gt; <br>&gt; ```<br>&gt; protocol MyProtocol {<br>&gt;     func myMethod() -&gt; String<br>&gt; }<br>&gt; <br>&gt; class MyClass: MyProtocol {<br>&gt; <br>&gt;     conform func myMethod() -&gt; String {<br>&gt;         return &quot;Yuhuuu,I am conforming \\o//&quot;<br>&gt;     }<br>&gt; <br>&gt;     func whatever() {<br>&gt;         print(&quot;I am a boring method and I don&#39;t conform anything&quot;)<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; It would be something similar to the current keyword `override` but for protocols. <br>&gt; <br>&gt; Apart from improving code readability, It would allow the detection, in compilation time, of errors due to code evolution. For example redundant methods that no longer conform anything once the requirement is removed from the protocol for whatever reason.<br></p><p>If you make a breaking change to a protocol like this, you should have gone through a deprecation cycle to indicate to your clients the appropriate changes you&#39;re going to make to the protocol.  This aspect of the change seems to if not encourage, highlight, bad behavior.<br></p><p>&gt; <br>&gt; Looking forward your opinions and comments.<br>&gt; <br>&gt; Kind Regards<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/cd3a78f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 23, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Aug 23, 2016, at 2:33 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 2016/08/22 14:30、David Cordero via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; The problem:<br>&gt;&gt; At the moment, looking at the code of a class or a struct implementing a protocol, it is hard to know what methods are actually implementing the protocol and what other methods are just part of the code of the class or struct.<br>&gt;&gt; <br>&gt; <br>&gt; That seems like a feature, not a bug.  Why should I as an author care whether a method contributes to a protocol conformance or not if the compiler can tell me that kind of information itself?<br></p><p>Being able to reason about your code, what it does, and what it’s for is undesirable?<br></p><p>&gt;&gt; ```<br>&gt;&gt; protocol MyProtocol {<br>&gt;&gt;     func myMethod() -&gt; String<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class MyClass: MyProtocol {<br>&gt;&gt; <br>&gt;&gt;     conform func myMethod() -&gt; String {<br>&gt;&gt;         return &quot;Yuhuuu,I am conforming \\o//&quot;<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func whatever() {<br>&gt;&gt;         print(&quot;I am a boring method and I don&#39;t conform anything&quot;)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; It would be something similar to the current keyword `override` but for protocols. <br>&gt;&gt; <br>&gt;&gt; Apart from improving code readability, It would allow the detection, in compilation time, of errors due to code evolution. For example redundant methods that no longer conform anything once the requirement is removed from the protocol for whatever reason.<br>&gt; <br>&gt; If you make a breaking change to a protocol like this, you should have gone through a deprecation cycle to indicate to your clients the appropriate changes you&#39;re going to make to the protocol.  This aspect of the change seems to if not encourage, highlight, bad behavior.<br></p><p>What if it’s your own code and all the callers are internal? What if you’re still developing the protocol and haven’t released the API interface yet?<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/e611c268/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>August 23, 2016 at 08:00:00pm</p></header><div class="content"><p>~Robert Widmann<br></p><p>2016/08/23 15:29、Charles Srstka &lt;cocoadev at charlessoft.com&gt; のメッセージ:<br></p><p>&gt;&gt; On Aug 23, 2016, at 2:33 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 2016/08/22 14:30、David Cordero via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem:<br>&gt;&gt;&gt; At the moment, looking at the code of a class or a struct implementing a protocol, it is hard to know what methods are actually implementing the protocol and what other methods are just part of the code of the class or struct.<br>&gt;&gt; <br>&gt;&gt; That seems like a feature, not a bug.  Why should I as an author care whether a method contributes to a protocol conformance or not if the compiler can tell me that kind of information itself?<br>&gt; <br>&gt; Being able to reason about your code, what it does, and what it’s for is undesirable?<br></p><p>That&#39;s not an answer to the question I asked.  Why is this significant enough to warrant an entire keyword?  The clutter of a whole keyword that does nothing but wait for a developer to make a source-compatible binary-breaking change to an interface does not seem worth it.  Maybe you can convince me otherwise. <br></p><p>&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; protocol MyProtocol {<br>&gt;&gt;&gt;     func myMethod() -&gt; String<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class MyClass: MyProtocol {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     conform func myMethod() -&gt; String {<br>&gt;&gt;&gt;         return &quot;Yuhuuu,I am conforming \\o//&quot;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func whatever() {<br>&gt;&gt;&gt;         print(&quot;I am a boring method and I don&#39;t conform anything&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would be something similar to the current keyword `override` but for protocols. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Apart from improving code readability, It would allow the detection, in compilation time, of errors due to code evolution. For example redundant methods that no longer conform anything once the requirement is removed from the protocol for whatever reason.<br>&gt;&gt; <br>&gt;&gt; If you make a breaking change to a protocol like this, you should have gone through a deprecation cycle to indicate to your clients the appropriate changes you&#39;re going to make to the protocol.  This aspect of the change seems to if not encourage, highlight, bad behavior.<br>&gt; <br>&gt; What if it’s your own code and all the callers are internal? What if you’re still developing the protocol and haven’t released the API interface yet?<br></p><p>Then your concerns are local enough that you know where all implementations of the protocol lie and whether they require deletion or not.  The point about deprecation cycles still stands in all the cases you mention.  Just because the interface is private doesn&#39;t mean you can&#39;t take responsibility for keeping it as clean as you can.<br></p><p>&gt; <br>&gt; Charles<br>&gt; <br></p><p>tl;dr It seems like all of this can be subsumed by us warning about dead code.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/1df0b3f9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 23, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Aug 23, 2016, at 10:34 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; 2016/08/23 15:29、Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt;&gt; On Aug 23, 2016, at 2:33 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/08/22 14:30、David Cordero via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The problem:<br>&gt;&gt;&gt;&gt; At the moment, looking at the code of a class or a struct implementing a protocol, it is hard to know what methods are actually implementing the protocol and what other methods are just part of the code of the class or struct.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That seems like a feature, not a bug.  Why should I as an author care whether a method contributes to a protocol conformance or not if the compiler can tell me that kind of information itself?<br>&gt;&gt; <br>&gt;&gt; Being able to reason about your code, what it does, and what it’s for is undesirable?<br>&gt; <br>&gt; That&#39;s not an answer to the question I asked.  Why is this significant enough to warrant an entire keyword?  The clutter of a whole keyword that does nothing but wait for a developer to make a source-compatible binary-breaking change to an interface does not seem worth it.  Maybe you can convince me otherwise. <br></p><p>Same reason overriding a class method warrants a keyword. It expresses the purpose more clearly, and allows the compiler to catch mistakes for us.<br></p><p>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; protocol MyProtocol {<br>&gt;&gt;&gt;&gt;     func myMethod() -&gt; String<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class MyClass: MyProtocol {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     conform func myMethod() -&gt; String {<br>&gt;&gt;&gt;&gt;         return &quot;Yuhuuu,I am conforming \\o// &lt;smb://o//&gt;&quot;<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     func whatever() {<br>&gt;&gt;&gt;&gt;         print(&quot;I am a boring method and I don&#39;t conform anything&quot;)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It would be something similar to the current keyword `override` but for protocols. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Apart from improving code readability, It would allow the detection, in compilation time, of errors due to code evolution. For example redundant methods that no longer conform anything once the requirement is removed from the protocol for whatever reason.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you make a breaking change to a protocol like this, you should have gone through a deprecation cycle to indicate to your clients the appropriate changes you&#39;re going to make to the protocol.  This aspect of the change seems to if not encourage, highlight, bad behavior.<br>&gt;&gt; <br>&gt;&gt; What if it’s your own code and all the callers are internal? What if you’re still developing the protocol and haven’t released the API interface yet?<br>&gt; <br>&gt; Then your concerns are local enough that you know where all implementations of the protocol lie and whether they require deletion or not.  The point about deprecation cycles still stands in all the cases you mention.  Just because the interface is private doesn&#39;t mean you can&#39;t take responsibility for keeping it as clean as you can.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt; <br>&gt; tl;dr It seems like all of this can be subsumed by us warning about dead code.<br></p><p>Did you look at my examples earlier in the thread? Neither of those would be caught by warning about dead code.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/3e7d2b1c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>August 23, 2016 at 09:00:00pm</p></header><div class="content"><p>These are legitimate benefits of adding the keyword. <br></p><p>However, one of the earlier examples from the thread is solving a issue specific to Objective-C. The other seems to be an issue of convenience and can be solved by better compiler error reporting.<br></p><p>Do we really think these small gains justify the hefty price of a keyword added to the language?<br></p><p>&gt; On Aug 23, 2016, at 8:52 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 23, 2016, at 10:34 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 2016/08/23 15:29、Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 23, 2016, at 2:33 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/08/22 14:30、David Cordero via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The problem:<br>&gt;&gt;&gt;&gt;&gt; At the moment, looking at the code of a class or a struct implementing a protocol, it is hard to know what methods are actually implementing the protocol and what other methods are just part of the code of the class or struct.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That seems like a feature, not a bug.  Why should I as an author care whether a method contributes to a protocol conformance or not if the compiler can tell me that kind of information itself?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Being able to reason about your code, what it does, and what it’s for is undesirable?<br>&gt;&gt; <br>&gt;&gt; That&#39;s not an answer to the question I asked.  Why is this significant enough to warrant an entire keyword?  The clutter of a whole keyword that does nothing but wait for a developer to make a source-compatible binary-breaking change to an interface does not seem worth it.  Maybe you can convince me otherwise. <br>&gt; <br>&gt; Same reason overriding a class method warrants a keyword. It expresses the purpose more clearly, and allows the compiler to catch mistakes for us.<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; protocol MyProtocol {<br>&gt;&gt;&gt;&gt;&gt;     func myMethod() -&gt; String<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class MyClass: MyProtocol {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     conform func myMethod() -&gt; String {<br>&gt;&gt;&gt;&gt;&gt;         return &quot;Yuhuuu,I am conforming \\o// &lt;smb://o//&gt;&quot;<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     func whatever() {<br>&gt;&gt;&gt;&gt;&gt;         print(&quot;I am a boring method and I don&#39;t conform anything&quot;)<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It would be something similar to the current keyword `override` but for protocols. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Apart from improving code readability, It would allow the detection, in compilation time, of errors due to code evolution. For example redundant methods that no longer conform anything once the requirement is removed from the protocol for whatever reason.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you make a breaking change to a protocol like this, you should have gone through a deprecation cycle to indicate to your clients the appropriate changes you&#39;re going to make to the protocol.  This aspect of the change seems to if not encourage, highlight, bad behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if it’s your own code and all the callers are internal? What if you’re still developing the protocol and haven’t released the API interface yet?<br>&gt;&gt; <br>&gt;&gt; Then your concerns are local enough that you know where all implementations of the protocol lie and whether they require deletion or not.  The point about deprecation cycles still stands in all the cases you mention.  Just because the interface is private doesn&#39;t mean you can&#39;t take responsibility for keeping it as clean as you can.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; tl;dr It seems like all of this can be subsumed by us warning about dead code.<br>&gt; <br>&gt; Did you look at my examples earlier in the thread? Neither of those would be caught by warning about dead code.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/e2e78071/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>August 23, 2016 at 11:00:00pm</p></header><div class="content"><p>~Robert Widmann<br></p><p>2016/08/23 20:52、Charles Srstka &lt;cocoadev at charlessoft.com&gt; のメッセージ:<br></p><p>&gt;&gt; On Aug 23, 2016, at 10:34 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 2016/08/23 15:29、Charles Srstka &lt;cocoadev at charlessoft.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 23, 2016, at 2:33 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/08/22 14:30、David Cordero via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The problem:<br>&gt;&gt;&gt;&gt;&gt; At the moment, looking at the code of a class or a struct implementing a protocol, it is hard to know what methods are actually implementing the protocol and what other methods are just part of the code of the class or struct.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That seems like a feature, not a bug.  Why should I as an author care whether a method contributes to a protocol conformance or not if the compiler can tell me that kind of information itself?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Being able to reason about your code, what it does, and what it’s for is undesirable?<br>&gt;&gt; <br>&gt;&gt; That&#39;s not an answer to the question I asked.  Why is this significant enough to warrant an entire keyword?  The clutter of a whole keyword that does nothing but wait for a developer to make a source-compatible binary-breaking change to an interface does not seem worth it.  Maybe you can convince me otherwise. <br>&gt; <br>&gt; Same reason overriding a class method warrants a keyword. It expresses the purpose more clearly, and allows the compiler to catch mistakes for us.<br></p><p>That&#39;s just it: The class of mistakes one can make by not being explicit about overrides is significantly more dangerous than the class of mistakes caused by dead code leftover from trimming protocols.<br></p><p>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; protocol MyProtocol {<br>&gt;&gt;&gt;&gt;&gt;     func myMethod() -&gt; String<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class MyClass: MyProtocol {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     conform func myMethod() -&gt; String {<br>&gt;&gt;&gt;&gt;&gt;         return &quot;Yuhuuu,I am conforming \\o//&quot;<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     func whatever() {<br>&gt;&gt;&gt;&gt;&gt;         print(&quot;I am a boring method and I don&#39;t conform anything&quot;)<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It would be something similar to the current keyword `override` but for protocols. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Apart from improving code readability, It would allow the detection, in compilation time, of errors due to code evolution. For example redundant methods that no longer conform anything once the requirement is removed from the protocol for whatever reason.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you make a breaking change to a protocol like this, you should have gone through a deprecation cycle to indicate to your clients the appropriate changes you&#39;re going to make to the protocol.  This aspect of the change seems to if not encourage, highlight, bad behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if it’s your own code and all the callers are internal? What if you’re still developing the protocol and haven’t released the API interface yet?<br>&gt;&gt; <br>&gt;&gt; Then your concerns are local enough that you know where all implementations of the protocol lie and whether they require deletion or not.  The point about deprecation cycles still stands in all the cases you mention.  Just because the interface is private doesn&#39;t mean you can&#39;t take responsibility for keeping it as clean as you can.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt; tl;dr It seems like all of this can be subsumed by us warning about dead code.<br>&gt; <br>&gt; Did you look at my examples earlier in the thread? Neither of those would be caught by warning about dead code.<br></p><p>The example involving the default implementation is most compelling, but it indicates that your proposed solution should focus on the protocol extension and not the implementing declaration.  Perhaps reusing one of our existing keywords can help here<br></p><p>protocol P {<br>  func foo() {}<br>}<br></p><p>extension P {<br>  default func foo() {}<br>}<br></p><p>struct S: P {}<br></p><p>Of course, this change would be potentially source-breaking either way - I don&#39;t like the sound of an &quot;optional keyword&quot;.  <br></p><p>Either way, we can all agree we need better diagnostics around these cases.<br></p><p>&gt; <br>&gt; Charles<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/dbda6297/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 24, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Aug 24, 2016, at 1:20 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; 2016/08/23 20:52、Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt;&gt; On Aug 23, 2016, at 10:34 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/08/23 15:29、Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 23, 2016, at 2:33 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016/08/22 14:30、David Cordero via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The problem:<br>&gt;&gt;&gt;&gt;&gt;&gt; At the moment, looking at the code of a class or a struct implementing a protocol, it is hard to know what methods are actually implementing the protocol and what other methods are just part of the code of the class or struct.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That seems like a feature, not a bug.  Why should I as an author care whether a method contributes to a protocol conformance or not if the compiler can tell me that kind of information itself?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Being able to reason about your code, what it does, and what it’s for is undesirable?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s not an answer to the question I asked.  Why is this significant enough to warrant an entire keyword?  The clutter of a whole keyword that does nothing but wait for a developer to make a source-compatible binary-breaking change to an interface does not seem worth it.  Maybe you can convince me otherwise. <br>&gt;&gt; <br>&gt;&gt; Same reason overriding a class method warrants a keyword. It expresses the purpose more clearly, and allows the compiler to catch mistakes for us.<br>&gt;&gt; <br>&gt; <br>&gt; That&#39;s just it: The class of mistakes one can make by not being explicit about overrides is significantly more dangerous than the class of mistakes caused by dead code leftover from trimming protocols.<br></p><p>I am in the middle of a large refactor of code that was originally Objective-C and then Swift written like Objective-C, to more idiomatic protocol-oriented Swift. I am finding that in Swift’s POP idiom, protocols with overrides are serving very nearly the same purpose that overrides were serving in the old design; hence, I don’t really think either is more or less dangerous than the other.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol MyProtocol {<br>&gt;&gt;&gt;&gt;&gt;&gt;     func myMethod() -&gt; String<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class MyClass: MyProtocol {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     conform func myMethod() -&gt; String {<br>&gt;&gt;&gt;&gt;&gt;&gt;         return &quot;Yuhuuu,I am conforming \\o// &lt;smb://o//&gt;&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     func whatever() {<br>&gt;&gt;&gt;&gt;&gt;&gt;         print(&quot;I am a boring method and I don&#39;t conform anything&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It would be something similar to the current keyword `override` but for protocols. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Apart from improving code readability, It would allow the detection, in compilation time, of errors due to code evolution. For example redundant methods that no longer conform anything once the requirement is removed from the protocol for whatever reason.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you make a breaking change to a protocol like this, you should have gone through a deprecation cycle to indicate to your clients the appropriate changes you&#39;re going to make to the protocol.  This aspect of the change seems to if not encourage, highlight, bad behavior.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What if it’s your own code and all the callers are internal? What if you’re still developing the protocol and haven’t released the API interface yet?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then your concerns are local enough that you know where all implementations of the protocol lie and whether they require deletion or not.  The point about deprecation cycles still stands in all the cases you mention.  Just because the interface is private doesn&#39;t mean you can&#39;t take responsibility for keeping it as clean as you can.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; tl;dr It seems like all of this can be subsumed by us warning about dead code.<br>&gt;&gt; <br>&gt;&gt; Did you look at my examples earlier in the thread? Neither of those would be caught by warning about dead code.<br>&gt; <br>&gt; The example involving the default implementation is most compelling, but it indicates that your proposed solution should focus on the protocol extension and not the implementing declaration.  Perhaps reusing one of our existing keywords can help here<br>&gt; <br>&gt; protocol P {<br>&gt;   func foo() {}<br>&gt; }<br>&gt; <br>&gt; extension P {<br>&gt;   default func foo() {}<br>&gt; }<br>&gt; <br>&gt; struct S: P {}<br>&gt; <br>&gt; Of course, this change would be potentially source-breaking either way - I don&#39;t like the sound of an &quot;optional keyword”.  <br></p><p>I can come up with a similar example without the mistake being in the extension, though:<br></p><p>protocol P {<br>	func foo() {}<br>}<br></p><p>extension P {<br>	func foo() { print(“Default Behavior”) }<br>}<br></p><p>struct S: P {<br>	func foo() { print(“Specific Behavior”) }<br>}<br></p><p>So far, so good. But now I realize that the original protocol needs an argument:<br></p><p>protocol P {<br>	func foo(bar: String) {}<br>}<br></p><p>extension P {<br>	func foo(bar: String) { print(“Default Behavior; bar is \(bar)”) }<br>}<br></p><p>struct S: P {<br>	func foo() { print(“Specific Behavior”) } // Whoops, forgot to update this method, and now it won’t get called—and we of course won’t see the carnage until runtime.<br>}<br></p><p>&gt; Either way, we can all agree we need better diagnostics around these cases.<br></p><p>No doubt.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/236737b0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>August 24, 2016 at 11:00:00am</p></header><div class="content"><p>Requiring &quot;override&quot; when anything overrides a method defined in a protocol extension should be added - structure and enumerated included, of course.<br></p><p>Protocol extensions added inheritance to structs and enums and this should be made explicit.<br></p><p>Sent from my iPad<br></p><p>&gt; On Aug 24, 2016, at 12:55 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 24, 2016, at 1:20 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; 2016/08/23 20:52、Charles Srstka &lt;cocoadev at charlessoft.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 23, 2016, at 10:34 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/08/23 15:29、Charles Srstka &lt;cocoadev at charlessoft.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Aug 23, 2016, at 2:33 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2016/08/22 14:30、David Cordero via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The problem:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; At the moment, looking at the code of a class or a struct implementing a protocol, it is hard to know what methods are actually implementing the protocol and what other methods are just part of the code of the class or struct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That seems like a feature, not a bug.  Why should I as an author care whether a method contributes to a protocol conformance or not if the compiler can tell me that kind of information itself?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Being able to reason about your code, what it does, and what it’s for is undesirable?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s not an answer to the question I asked.  Why is this significant enough to warrant an entire keyword?  The clutter of a whole keyword that does nothing but wait for a developer to make a source-compatible binary-breaking change to an interface does not seem worth it.  Maybe you can convince me otherwise. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Same reason overriding a class method warrants a keyword. It expresses the purpose more clearly, and allows the compiler to catch mistakes for us.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; That&#39;s just it: The class of mistakes one can make by not being explicit about overrides is significantly more dangerous than the class of mistakes caused by dead code leftover from trimming protocols.<br>&gt; <br>&gt; I am in the middle of a large refactor of code that was originally Objective-C and then Swift written like Objective-C, to more idiomatic protocol-oriented Swift. I am finding that in Swift’s POP idiom, protocols with overrides are serving very nearly the same purpose that overrides were serving in the old design; hence, I don’t really think either is more or less dangerous than the other.<br>&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol MyProtocol {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     func myMethod() -&gt; String<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class MyClass: MyProtocol {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     conform func myMethod() -&gt; String {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         return &quot;Yuhuuu,I am conforming \\o//&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     func whatever() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         print(&quot;I am a boring method and I don&#39;t conform anything&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It would be something similar to the current keyword `override` but for protocols. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Apart from improving code readability, It would allow the detection, in compilation time, of errors due to code evolution. For example redundant methods that no longer conform anything once the requirement is removed from the protocol for whatever reason.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If you make a breaking change to a protocol like this, you should have gone through a deprecation cycle to indicate to your clients the appropriate changes you&#39;re going to make to the protocol.  This aspect of the change seems to if not encourage, highlight, bad behavior.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What if it’s your own code and all the callers are internal? What if you’re still developing the protocol and haven’t released the API interface yet?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Then your concerns are local enough that you know where all implementations of the protocol lie and whether they require deletion or not.  The point about deprecation cycles still stands in all the cases you mention.  Just because the interface is private doesn&#39;t mean you can&#39;t take responsibility for keeping it as clean as you can.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; tl;dr It seems like all of this can be subsumed by us warning about dead code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Did you look at my examples earlier in the thread? Neither of those would be caught by warning about dead code.<br>&gt;&gt; <br>&gt;&gt; The example involving the default implementation is most compelling, but it indicates that your proposed solution should focus on the protocol extension and not the implementing declaration.  Perhaps reusing one of our existing keywords can help here<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   func foo() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt;   default func foo() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: P {}<br>&gt;&gt; <br>&gt;&gt; Of course, this change would be potentially source-breaking either way - I don&#39;t like the sound of an &quot;optional keyword”.  <br>&gt; <br>&gt; I can come up with a similar example without the mistake being in the extension, though:<br>&gt; <br>&gt; protocol P {<br>&gt; 	func foo() {}<br>&gt; }<br>&gt; <br>&gt; extension P {<br>&gt; 	func foo() { print(“Default Behavior”) }<br>&gt; }<br>&gt; <br>&gt; struct S: P {<br>&gt; 	func foo() { print(“Specific Behavior”) }<br>&gt; }<br>&gt; <br>&gt; So far, so good. But now I realize that the original protocol needs an argument:<br>&gt; <br>&gt; protocol P {<br>&gt; 	func foo(bar: String) {}<br>&gt; }<br>&gt; <br>&gt; extension P {<br>&gt; 	func foo(bar: String) { print(“Default Behavior; bar is \(bar)”) }<br>&gt; }<br>&gt; <br>&gt; struct S: P {<br>&gt; 	func foo() { print(“Specific Behavior”) } // Whoops, forgot to update this method, and now it won’t get called—and we of course won’t see the carnage until runtime.<br>&gt; }<br>&gt; <br>&gt;&gt; Either way, we can all agree we need better diagnostics around these cases.<br>&gt; <br>&gt; No doubt.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/2401e5e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>August 25, 2016 at 04:00:00pm</p></header><div class="content"><p>I hope that my brief email wasn’t the final word on this :(<br></p><p>Does anyone think that a proposal to require “override” for overrides of protocol extension methods and variables (?) would be worth exploring?<br></p><p>This would address a number of the issues raised in this thread, but not all.<br></p><p>My intention is not to derail this thread, and I believe that the original topic of this thread, explicit protocol conformance, is worth exploring. I respond here because of these topics are strongly related. I will start a new thread, if there is interest.<br></p><p>It is possible that tooling could address the remaining issues with overrides. JetBrains products, for example, provide navigable icons to overridden methods. There is no reason that Xcode and other tools could not automatically insert indicators like:<br></p><p>```<br>class MyClass: MyProtocol {<br></p><p>	&lt; conforms &gt;<br>	func myMethod() -&gt; String {<br>        	return “...&quot;<br>   	}<br></p><p>class MyClass2: MyProtocol1, MyProtocol2 {<br></p><p>	&lt; conforms MyProtocol2 &gt;<br>	func myMethod() -&gt; String {<br>        	return “...&quot;<br>    	}<br>```<br>Of course, there is no reason that tooling can’t replace “override” completely:<br></p><p>```<br>class MyClass: MyOtherClass, MyProtocol1, MyProtocol2 {<br></p><p>	&lt; conforms MyProtocol2 &gt;<br>	&lt; overrides TheParentClassOfMyOtherClass&gt;<br>	func myMethod() -&gt; String {<br>        	return “...&quot;<br>    	}<br>```<br></p><p>Replace &quot;&lt;…&gt;” with the navigable graphic of your choice and assume that user preferences would exist to show/hide these indicators.<br></p><p><br>&gt; On Aug 24, 2016, at 11:13 AM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Requiring &quot;override&quot; when anything overrides a method defined in a protocol extension should be added - structure and enumerated included, of course.<br>&gt; <br>&gt; Protocol extensions added inheritance to structs and enums and this should be made explicit.<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Aug 24, 2016, at 12:55 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Aug 24, 2016, at 1:20 AM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; 2016/08/23 20:52、Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 23, 2016, at 10:34 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016/08/23 15:29、Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 23, 2016, at 2:33 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/08/22 14:30、David Cordero via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The problem:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; At the moment, looking at the code of a class or a struct implementing a protocol, it is hard to know what methods are actually implementing the protocol and what other methods are just part of the code of the class or struct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That seems like a feature, not a bug.  Why should I as an author care whether a method contributes to a protocol conformance or not if the compiler can tell me that kind of information itself?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Being able to reason about your code, what it does, and what it’s for is undesirable?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That&#39;s not an answer to the question I asked.  Why is this significant enough to warrant an entire keyword?  The clutter of a whole keyword that does nothing but wait for a developer to make a source-compatible binary-breaking change to an interface does not seem worth it.  Maybe you can convince me otherwise. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Same reason overriding a class method warrants a keyword. It expresses the purpose more clearly, and allows the compiler to catch mistakes for us.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s just it: The class of mistakes one can make by not being explicit about overrides is significantly more dangerous than the class of mistakes caused by dead code leftover from trimming protocols.<br>&gt;&gt; <br>&gt;&gt; I am in the middle of a large refactor of code that was originally Objective-C and then Swift written like Objective-C, to more idiomatic protocol-oriented Swift. I am finding that in Swift’s POP idiom, protocols with overrides are serving very nearly the same purpose that overrides were serving in the old design; hence, I don’t really think either is more or less dangerous than the other.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol MyProtocol {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     func myMethod() -&gt; String<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class MyClass: MyProtocol {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     conform func myMethod() -&gt; String {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         return &quot;Yuhuuu,I am conforming \\o// &lt;smb://o//&gt;&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     func whatever() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         print(&quot;I am a boring method and I don&#39;t conform anything&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It would be something similar to the current keyword `override` but for protocols. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Apart from improving code readability, It would allow the detection, in compilation time, of errors due to code evolution. For example redundant methods that no longer conform anything once the requirement is removed from the protocol for whatever reason.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you make a breaking change to a protocol like this, you should have gone through a deprecation cycle to indicate to your clients the appropriate changes you&#39;re going to make to the protocol.  This aspect of the change seems to if not encourage, highlight, bad behavior.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What if it’s your own code and all the callers are internal? What if you’re still developing the protocol and haven’t released the API interface yet?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Then your concerns are local enough that you know where all implementations of the protocol lie and whether they require deletion or not.  The point about deprecation cycles still stands in all the cases you mention.  Just because the interface is private doesn&#39;t mean you can&#39;t take responsibility for keeping it as clean as you can.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; tl;dr It seems like all of this can be subsumed by us warning about dead code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Did you look at my examples earlier in the thread? Neither of those would be caught by warning about dead code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The example involving the default implementation is most compelling, but it indicates that your proposed solution should focus on the protocol extension and not the implementing declaration.  Perhaps reusing one of our existing keywords can help here<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;   func foo() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension P {<br>&gt;&gt;&gt;   default func foo() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S: P {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course, this change would be potentially source-breaking either way - I don&#39;t like the sound of an &quot;optional keyword”.  <br>&gt;&gt; <br>&gt;&gt; I can come up with a similar example without the mistake being in the extension, though:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt; 	func foo() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt; 	func foo() { print(“Default Behavior”) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: P {<br>&gt;&gt; 	func foo() { print(“Specific Behavior”) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; So far, so good. But now I realize that the original protocol needs an argument:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt; 	func foo(bar: String) {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt; 	func foo(bar: String) { print(“Default Behavior; bar is \(bar)”) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: P {<br>&gt;&gt; 	func foo() { print(“Specific Behavior”) } // Whoops, forgot to update this method, and now it won’t get called—and we of course won’t see the carnage until runtime.<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt;&gt; Either way, we can all agree we need better diagnostics around these cases.<br>&gt;&gt; <br>&gt;&gt; No doubt.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/f418b3eb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>August 25, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Aug 25, 2016, at 4:32 PM, Christopher Kornher &lt;ckornher at me.com&gt; wrote:<br>&gt; <br>&gt; I hope that my brief email wasn’t the final word on this :(<br>&gt; <br>&gt; Does anyone think that a proposal to require “override” for overrides of protocol extension methods and variables (?) would be worth exploring?<br>&gt; <br>&gt; This would address a number of the issues raised in this thread, but not all.<br>&gt; <br>&gt; My intention is not to derail this thread, and I believe that the original topic of this thread, explicit protocol conformance, is worth exploring. I respond here because of these topics are strongly related. I will start a new thread, if there is interest.<br>&gt; <br>&gt; It is possible that tooling could address the remaining issues with overrides. JetBrains products, for example, provide navigable icons to overridden methods. There is no reason that Xcode and other tools could not automatically insert indicators like:<br>&gt; <br>&gt; ```<br>&gt; class MyClass: MyProtocol {<br>&gt; <br>&gt; 	&lt; conforms &gt;<br>&gt; 	func myMethod() -&gt; String {<br>&gt;         	return “...&quot;<br>&gt;    	}<br>&gt; <br>&gt; class MyClass2: MyProtocol1, MyProtocol2 {<br>&gt; <br>&gt; 	&lt; conforms MyProtocol2 &gt;<br>&gt; 	func myMethod() -&gt; String {<br>&gt;         	return “...&quot;<br>&gt;     	}<br>&gt; ```<br>&gt; Of course, there is no reason that tooling can’t replace “override” completely:<br>&gt; <br>&gt; ```<br>&gt; class MyClass: MyOtherClass, MyProtocol1, MyProtocol2 {<br>&gt; <br>&gt; 	&lt; conforms MyProtocol2 &gt;<br>&gt; 	&lt; overrides TheParentClassOfMyOtherClass&gt;<br>&gt; 	func myMethod() -&gt; String {<br>&gt;         	return “...&quot;<br>&gt;     	}<br>&gt; ```<br>&gt; <br>&gt; Replace &quot;&lt;…&gt;” with the navigable graphic of your choice and assume that user preferences would exist to show/hide these indicators.<br>&gt; <br>&gt; <br></p><p>My cut and paste error left out this part:<br></p><p>The roles of language and tooling in making code understandable is largely a matter of opinion. I personally like the current use of “override” since overriding is a common cause of serious programming errors and a mechanism for protecting against them should be built into the language and now, extended to overrides of protocol extensions.<br></p><p>It is interesting that adding “override” to structs and enums would help to open the door to true inheritance (not polymorphism) for structs and possibly even enums, if anyone knows of a use for that. This is a feature that I could have used on a few projects, but there are far more important features in the queue, and that discussion should probably wait until after Swift 4, if it happens at all.<br></p><p><br>- Chris K<br></p><p><br></p><p>&gt;&gt; On Aug 24, 2016, at 11:13 AM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Requiring &quot;override&quot; when anything overrides a method defined in a protocol extension should be added - structure and enumerated included, of course.<br>&gt;&gt; <br>&gt;&gt; Protocol extensions added inheritance to structs and enums and this should be made explicit.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On Aug 24, 2016, at 12:55 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 24, 2016, at 1:20 AM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; 2016/08/23 20:52、Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Aug 23, 2016, at 10:34 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2016/08/23 15:29、Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 23, 2016, at 2:33 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/08/22 14:30、David Cordero via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The problem:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; At the moment, looking at the code of a class or a struct implementing a protocol, it is hard to know what methods are actually implementing the protocol and what other methods are just part of the code of the class or struct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That seems like a feature, not a bug.  Why should I as an author care whether a method contributes to a protocol conformance or not if the compiler can tell me that kind of information itself?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Being able to reason about your code, what it does, and what it’s for is undesirable?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s not an answer to the question I asked.  Why is this significant enough to warrant an entire keyword?  The clutter of a whole keyword that does nothing but wait for a developer to make a source-compatible binary-breaking change to an interface does not seem worth it.  Maybe you can convince me otherwise. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Same reason overriding a class method warrants a keyword. It expresses the purpose more clearly, and allows the compiler to catch mistakes for us.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s just it: The class of mistakes one can make by not being explicit about overrides is significantly more dangerous than the class of mistakes caused by dead code leftover from trimming protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am in the middle of a large refactor of code that was originally Objective-C and then Swift written like Objective-C, to more idiomatic protocol-oriented Swift. I am finding that in Swift’s POP idiom, protocols with overrides are serving very nearly the same purpose that overrides were serving in the old design; hence, I don’t really think either is more or less dangerous than the other.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol MyProtocol {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     func myMethod() -&gt; String<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class MyClass: MyProtocol {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     conform func myMethod() -&gt; String {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         return &quot;Yuhuuu,I am conforming \\o// &lt;smb://o//&gt;&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     func whatever() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         print(&quot;I am a boring method and I don&#39;t conform anything&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It would be something similar to the current keyword `override` but for protocols. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Apart from improving code readability, It would allow the detection, in compilation time, of errors due to code evolution. For example redundant methods that no longer conform anything once the requirement is removed from the protocol for whatever reason.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you make a breaking change to a protocol like this, you should have gone through a deprecation cycle to indicate to your clients the appropriate changes you&#39;re going to make to the protocol.  This aspect of the change seems to if not encourage, highlight, bad behavior.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What if it’s your own code and all the callers are internal? What if you’re still developing the protocol and haven’t released the API interface yet?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Then your concerns are local enough that you know where all implementations of the protocol lie and whether they require deletion or not.  The point about deprecation cycles still stands in all the cases you mention.  Just because the interface is private doesn&#39;t mean you can&#39;t take responsibility for keeping it as clean as you can.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; tl;dr It seems like all of this can be subsumed by us warning about dead code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Did you look at my examples earlier in the thread? Neither of those would be caught by warning about dead code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The example involving the default implementation is most compelling, but it indicates that your proposed solution should focus on the protocol extension and not the implementing declaration.  Perhaps reusing one of our existing keywords can help here<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;   func foo() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension P {<br>&gt;&gt;&gt;&gt;   default func foo() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct S: P {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Of course, this change would be potentially source-breaking either way - I don&#39;t like the sound of an &quot;optional keyword”.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can come up with a similar example without the mistake being in the extension, though:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt; 	func foo() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension P {<br>&gt;&gt;&gt; 	func foo() { print(“Default Behavior”) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S: P {<br>&gt;&gt;&gt; 	func foo() { print(“Specific Behavior”) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So far, so good. But now I realize that the original protocol needs an argument:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt; 	func foo(bar: String) {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension P {<br>&gt;&gt;&gt; 	func foo(bar: String) { print(“Default Behavior; bar is \(bar)”) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S: P {<br>&gt;&gt;&gt; 	func foo() { print(“Specific Behavior”) } // Whoops, forgot to update this method, and now it won’t get called—and we of course won’t see the carnage until runtime.<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Either way, we can all agree we need better diagnostics around these cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No doubt.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/361401f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 25, 2016 at 06:00:00pm</p></header><div class="content"><p>Chris, as I wrote above, this idea has been discussed previously on several<br>occasions, and the principal reason why it has been abandoned each time is<br>that it cannot accommodate retroactive modeling. I&#39;ll refer you again to<br>three previous threads discussing this and closely related matters:<br></p><p>https://lists.swift.org/pipermail/swift-evolution/<br>Week-of-Mon-20160104/005380.html<br>https://lists.swift.org/pipermail/swift-evolution/<br>Week-of-Mon-20160229/011792.html<br>https://lists.swift.org/pipermail/swift-evolution/<br>Week-of-Mon-20160425/015920.html<br></p><p>If, after familiarizing yourself with the previous discussions, you feel<br>like there is an aspect of the topic that has not yet been considered, then<br>of course feel free to start another discussion.<br></p><p><br>On Thu, Aug 25, 2016 at 5:36 PM, Christopher Kornher via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Aug 25, 2016, at 4:32 PM, Christopher Kornher &lt;ckornher at me.com&gt; wrote:<br>&gt;<br>&gt; I hope that my brief email wasn’t the final word on this :(<br>&gt;<br>&gt; Does anyone think that a proposal to require “override” for overrides of<br>&gt; protocol extension methods and variables (?) would be worth exploring?<br>&gt;<br>&gt; This would address a number of the issues raised in this thread, but not<br>&gt; all.<br>&gt;<br>&gt; My intention is not to derail this thread, and I believe that the original<br>&gt; topic of this thread, explicit protocol conformance, is worth exploring. I<br>&gt; respond here because of these topics are strongly related. I will start a<br>&gt; new thread, if there is interest.<br>&gt;<br>&gt; It is possible that tooling could address the remaining issues with<br>&gt; overrides. JetBrains products, for example, provide navigable icons to<br>&gt; overridden methods. There is no reason that Xcode and other tools could not<br>&gt; automatically insert indicators like:<br>&gt;<br>&gt; ```<br>&gt; class MyClass: MyProtocol {<br>&gt;<br>&gt; &lt; conforms &gt;<br>&gt; func myMethod() -&gt; String {<br>&gt;          return “...&quot;<br>&gt;     }<br>&gt;<br>&gt; class MyClass2: MyProtocol1, MyProtocol2 {<br>&gt;<br>&gt; &lt; conforms MyProtocol2 &gt;<br>&gt; func myMethod() -&gt; String {<br>&gt;         return “...&quot;<br>&gt;     }<br>&gt; ```<br>&gt; Of course, there is no reason that tooling can’t replace “override”<br>&gt; completely:<br>&gt;<br>&gt; ```<br>&gt; class MyClass: MyOtherClass, MyProtocol1, MyProtocol2 {<br>&gt;<br>&gt; &lt; conforms MyProtocol2 &gt;<br>&gt; &lt; overrides TheParentClassOfMyOtherClass&gt;<br>&gt; func myMethod() -&gt; String {<br>&gt;         return “...&quot;<br>&gt;     }<br>&gt; ```<br>&gt;<br>&gt; Replace &quot;&lt;…&gt;” with the navigable graphic of your choice and assume that<br>&gt; user preferences would exist to show/hide these indicators.<br>&gt;<br>&gt;<br>&gt;<br>&gt; My cut and paste error left out this part:<br>&gt;<br>&gt; The roles of language and tooling in making code understandable is largely<br>&gt; a matter of opinion. I personally like the current use of “override” since<br>&gt; overriding is a common cause of serious programming errors and a mechanism<br>&gt; for protecting against them should be built into the language and now,<br>&gt; extended to overrides of protocol extensions.<br>&gt;<br>&gt; It is interesting that adding “override” to structs and enums would help<br>&gt; to open the door to true inheritance (not polymorphism) for structs and<br>&gt; possibly even enums, if anyone knows of a use for that. This is a feature<br>&gt; that I could have used on a few projects, but there are far more important<br>&gt; features in the queue, and that discussion should probably wait until after<br>&gt; Swift 4, if it happens at all.<br>&gt;<br>&gt;<br>&gt; - Chris K<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Aug 24, 2016, at 11:13 AM, Christopher Kornher via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Requiring &quot;override&quot; when anything overrides a method defined in a<br>&gt; protocol extension should be added - structure and enumerated included, of<br>&gt; course.<br>&gt;<br>&gt; Protocol extensions added inheritance to structs and enums and this should<br>&gt; be made explicit.<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Aug 24, 2016, at 12:55 AM, Charles Srstka via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Aug 24, 2016, at 1:20 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; 2016/08/23 20:52、Charles Srstka &lt;cocoadev at charlessoft.com&gt; のメッセージ:<br>&gt;<br>&gt; On Aug 23, 2016, at 10:34 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; 2016/08/23 15:29、Charles Srstka &lt;cocoadev at charlessoft.com&gt; のメッセージ:<br>&gt;<br>&gt; On Aug 23, 2016, at 2:33 PM, Robert Widmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; 2016/08/22 14:30、David Cordero via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; のメッセージ:<br>&gt;<br>&gt;<br>&gt; *The problem:*<br>&gt; At the moment, looking at the code of a class or a struct implementing a<br>&gt; protocol, it is hard to know what methods are actually implementing the<br>&gt; protocol and what other methods are just part of the code of the class or<br>&gt; struct.<br>&gt;<br>&gt;<br>&gt; That seems like a feature, not a bug.  Why should I as an author care<br>&gt; whether a method contributes to a protocol conformance or not if the<br>&gt; compiler can tell me that kind of information itself?<br>&gt;<br>&gt;<br>&gt; Being able to reason about your code, what it does, and what it’s for is<br>&gt; undesirable?<br>&gt;<br>&gt;<br>&gt; That&#39;s not an answer to the question I asked.  Why is this significant<br>&gt; enough to warrant an entire keyword?  The clutter of a whole keyword that<br>&gt; does nothing but wait for a developer to make a source-compatible<br>&gt; binary-breaking change to an interface does not seem worth it.  Maybe you<br>&gt; can convince me otherwise.<br>&gt;<br>&gt;<br>&gt; Same reason overriding a class method warrants a keyword. It expresses the<br>&gt; purpose more clearly, and allows the compiler to catch mistakes for us.<br>&gt;<br>&gt;<br>&gt; That&#39;s just it: The class of mistakes one can make by not being explicit<br>&gt; about overrides is significantly more dangerous than the class of mistakes<br>&gt; caused by dead code leftover from trimming protocols.<br>&gt;<br>&gt;<br>&gt; I am in the middle of a large refactor of code that was originally<br>&gt; Objective-C and then Swift written like Objective-C, to more idiomatic<br>&gt; protocol-oriented Swift. I am finding that in Swift’s POP idiom, protocols<br>&gt; with overrides are serving very nearly the same purpose that overrides were<br>&gt; serving in the old design; hence, I don’t really think either is more or<br>&gt; less dangerous than the other.<br>&gt;<br>&gt; ```<br>&gt;<br>&gt; protocol MyProtocol {<br>&gt;     func myMethod() -&gt; String<br>&gt; }<br>&gt;<br>&gt; class MyClass: MyProtocol {<br>&gt;<br>&gt;     *conform* func myMethod() -&gt; String {<br>&gt;         return &quot;Yuhuuu,I am conforming \\o//&quot;<br>&gt;     }<br>&gt;<br>&gt;     func whatever() {<br>&gt;         print(&quot;I am a boring method and I don&#39;t conform anything&quot;)<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; It would be something similar to the current keyword `override` but for<br>&gt; protocols.<br>&gt;<br>&gt; Apart from improving code readability, It would allow the detection, in<br>&gt; compilation time, of errors due to code evolution. For example redundant<br>&gt; methods that no longer conform anything once the requirement is removed<br>&gt; from the protocol for whatever reason.<br>&gt;<br>&gt;<br>&gt; If you make a breaking change to a protocol like this, you should have<br>&gt; gone through a deprecation cycle to indicate to your clients the<br>&gt; appropriate changes you&#39;re going to make to the protocol.  This aspect of<br>&gt; the change seems to if not encourage, highlight, bad behavior.<br>&gt;<br>&gt;<br>&gt; What if it’s your own code and all the callers are internal? What if<br>&gt; you’re still developing the protocol and haven’t released the API interface<br>&gt; yet?<br>&gt;<br>&gt;<br>&gt; Then your concerns are local enough that you know where *all* implementations<br>&gt; of the protocol lie and whether they require deletion or not.  The point<br>&gt; about deprecation cycles still stands in all the cases you mention.  Just<br>&gt; because the interface is private doesn&#39;t mean you can&#39;t take responsibility<br>&gt; for keeping it as clean as you can.<br>&gt;<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>&gt; tl;dr It seems like all of this can be subsumed by us warning about dead<br>&gt; code.<br>&gt;<br>&gt;<br>&gt; Did you look at my examples earlier in the thread? Neither of those would<br>&gt; be caught by warning about dead code.<br>&gt;<br>&gt;<br>&gt; The example involving the default implementation is most compelling, but<br>&gt; it indicates that your proposed solution should focus on the protocol<br>&gt; extension and not the implementing declaration.  Perhaps reusing one of our<br>&gt; existing keywords can help here<br>&gt;<br>&gt; protocol P {<br>&gt;   func foo() {}<br>&gt; }<br>&gt;<br>&gt; extension P {<br>&gt;   default func foo() {}<br>&gt; }<br>&gt;<br>&gt; struct S: P {}<br>&gt;<br>&gt; Of course, this change would be potentially source-breaking either way - I<br>&gt; don&#39;t like the sound of an &quot;optional keyword”.<br>&gt;<br>&gt;<br>&gt; I can come up with a similar example without the mistake being in the<br>&gt; extension, though:<br>&gt;<br>&gt; protocol P {<br>&gt; func foo() {}<br>&gt; }<br>&gt;<br>&gt; extension P {<br>&gt; func foo() { print(“Default Behavior”) }<br>&gt; }<br>&gt;<br>&gt; struct S: P {<br>&gt; func foo() { print(“Specific Behavior”) }<br>&gt; }<br>&gt;<br>&gt; So far, so good. But now I realize that the original protocol needs an<br>&gt; argument:<br>&gt;<br>&gt; protocol P {<br>&gt; func foo(bar: String) {}<br>&gt; }<br>&gt;<br>&gt; extension P {<br>&gt; func foo(bar: String) { print(“Default Behavior; bar is \(bar)”) }<br>&gt; }<br>&gt;<br>&gt; struct S: P {<br>&gt; func foo() { print(“Specific Behavior”) } // Whoops, forgot to update this<br>&gt; method, and now it won’t get called—and we of course won’t see the<br>&gt; carnage until runtime.<br>&gt; }<br>&gt;<br>&gt; Either way, we can all agree we need better diagnostics around these cases.<br>&gt;<br>&gt;<br>&gt; No doubt.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/0649a58d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 25, 2016 at 10:00:00pm</p></header><div class="content"><p>Is there a reason that adding a “retro” keyword on extensions meant to retroactively apply a protocol is unacceptable?<br></p><p>Charles<br></p><p>&gt; On Aug 25, 2016, at 6:44 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Chris, as I wrote above, this idea has been discussed previously on several occasions, and the principal reason why it has been abandoned each time is that it cannot accommodate retroactive modeling. I&#39;ll refer you again to three previous threads discussing this and closely related matters:<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/05b4a418/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 25, 2016 at 10:00:00pm</p></header><div class="content"><p>Yes, and it&#39;s covered in those previous threads. In brief, not all<br>retroactive modeling involves extending a type:<br></p><p>* A vendor supplies you with a closed-source library with a struct S that<br>conforms to standard library protocol P.<br></p><p>* Protocol P requires a method named foo(), so struct S has its own<br>implementation of foo().<br></p><p>* You extend protocol P by adding a new default implementation of foo().<br></p><p>This cannot be done if a keyword is required for overriding a default<br>implementation. There is also nowhere for you to append any sort of &quot;retro&quot;<br>keyword anywhere, because no part of your own code extends S in any way.<br></p><p>Please, please take the time to study the previous threads; we should not<br>be re-playing existing discussions four or five times on this list.<br></p><p><br>On Thu, Aug 25, 2016 at 10:06 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; Is there a reason that adding a “retro” keyword on extensions meant to<br>&gt; retroactively apply a protocol is unacceptable?<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; On Aug 25, 2016, at 6:44 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Chris, as I wrote above, this idea has been discussed previously on<br>&gt; several occasions, and the principal reason why it has been abandoned each<br>&gt; time is that it cannot accommodate retroactive modeling. I&#39;ll refer you<br>&gt; again to three previous threads discussing this and closely related matters:<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/354924f2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 25, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Aug 25, 2016, at 10:24 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Yes, and it&#39;s covered in those previous threads. In brief, not all retroactive modeling involves extending a type:<br>&gt; <br>&gt; * A vendor supplies you with a closed-source library with a struct S that conforms to standard library protocol P.<br>&gt; <br>&gt; * Protocol P requires a method named foo(), so struct S has its own implementation of foo().<br>&gt; <br>&gt; * You extend protocol P by adding a new default implementation of foo().<br>&gt; <br>&gt; This cannot be done if a keyword is required for overriding a default implementation. There is also nowhere for you to append any sort of &quot;retro&quot; keyword anywhere, because no part of your own code extends S in any way.<br>&gt; <br>&gt; Please, please take the time to study the previous threads; we should not be re-playing existing discussions four or five times on this list.<br></p><p>How is this a problem, though? The implementation of foo() in S will not break, because it’s already been compiled in. The change will only affect code that is subsequently compiled with your extension of P in place. And it’ll be doing its job; making sure that your code to implement the protocol is there deliberately, and preventing you from accidentally mistyping the method name and thus silently failing to override the default implementation.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/29fede0f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 25, 2016 at 11:00:00pm</p></header><div class="content"><p>On Thu, Aug 25, 2016 at 11:05 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 25, 2016, at 10:24 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Yes, and it&#39;s covered in those previous threads. In brief, not all<br>&gt; retroactive modeling involves extending a type:<br>&gt;<br>&gt; * A vendor supplies you with a closed-source library with a struct S that<br>&gt; conforms to standard library protocol P.<br>&gt;<br>&gt; * Protocol P requires a method named foo(), so struct S has its own<br>&gt; implementation of foo().<br>&gt;<br>&gt; * You extend protocol P by adding a new default implementation of foo().<br>&gt;<br>&gt; This cannot be done if a keyword is required for overriding a default<br>&gt; implementation. There is also nowhere for you to append any sort of &quot;retro&quot;<br>&gt; keyword anywhere, because no part of your own code extends S in any way.<br>&gt;<br>&gt; Please, please take the time to study the previous threads; we should not<br>&gt; be re-playing existing discussions four or five times on this list.<br>&gt;<br>&gt;<br>&gt; How is this a problem, though? The implementation of foo() in S will not<br>&gt; break, because it’s already been compiled in. The change will only affect<br>&gt; code that is subsequently compiled with your extension of P in place. And<br>&gt; it’ll be doing its job; making sure that your code to implement the<br>&gt; protocol is there deliberately, and preventing you from accidentally<br>&gt; mistyping the method name and thus silently failing to override the default<br>&gt; implementation.<br>&gt;<br></p><p>So you&#39;re saying that the compiler should let you compile your extension of<br>P, even though it knows that the default implementation of `foo()` is not<br>explicitly overridden by S. Fine.<br>Now suppose the library is not closed-source; you&#39;re including it in your<br>project and compiling it along with your own code. Are you supposed to fork<br>the library?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/af9a1cfc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 26, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Aug 25, 2016, at 11:48 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Thu, Aug 25, 2016 at 11:05 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; On Aug 25, 2016, at 10:24 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yes, and it&#39;s covered in those previous threads. In brief, not all retroactive modeling involves extending a type:<br>&gt;&gt; <br>&gt;&gt; * A vendor supplies you with a closed-source library with a struct S that conforms to standard library protocol P.<br>&gt;&gt; <br>&gt;&gt; * Protocol P requires a method named foo(), so struct S has its own implementation of foo().<br>&gt;&gt; <br>&gt;&gt; * You extend protocol P by adding a new default implementation of foo().<br>&gt;&gt; <br>&gt;&gt; This cannot be done if a keyword is required for overriding a default implementation. There is also nowhere for you to append any sort of &quot;retro&quot; keyword anywhere, because no part of your own code extends S in any way.<br>&gt;&gt; <br>&gt;&gt; Please, please take the time to study the previous threads; we should not be re-playing existing discussions four or five times on this list.<br>&gt; <br>&gt; How is this a problem, though? The implementation of foo() in S will not break, because it’s already been compiled in. The change will only affect code that is subsequently compiled with your extension of P in place. And it’ll be doing its job; making sure that your code to implement the protocol is there deliberately, and preventing you from accidentally mistyping the method name and thus silently failing to override the default implementation.<br>&gt; <br>&gt; So you&#39;re saying that the compiler should let you compile your extension of P, even though it knows that the default implementation of `foo()` is not explicitly overridden by S. Fine.<br>&gt; Now suppose the library is not closed-source; you&#39;re including it in your project and compiling it along with your own code. Are you supposed to fork the library?<br></p><p>Even if the library is open-source, you&#39;ll presumably be building in as its own target, which will be including only library code and not your extension, and linking it into the application in a later stage of the build process.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/a2cd4edd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 26, 2016 at 02:00:00am</p></header><div class="content"><p>On Fri, Aug 26, 2016 at 1:53 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 25, 2016, at 11:48 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Thu, Aug 25, 2016 at 11:05 PM, Charles Srstka &lt;cocoadev at charlessoft.com<br>&gt; &gt; wrote:<br>&gt;<br>&gt;&gt; On Aug 25, 2016, at 10:24 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, and it&#39;s covered in those previous threads. In brief, not all<br>&gt;&gt; retroactive modeling involves extending a type:<br>&gt;&gt;<br>&gt;&gt; * A vendor supplies you with a closed-source library with a struct S that<br>&gt;&gt; conforms to standard library protocol P.<br>&gt;&gt;<br>&gt;&gt; * Protocol P requires a method named foo(), so struct S has its own<br>&gt;&gt; implementation of foo().<br>&gt;&gt;<br>&gt;&gt; * You extend protocol P by adding a new default implementation of foo().<br>&gt;&gt;<br>&gt;&gt; This cannot be done if a keyword is required for overriding a default<br>&gt;&gt; implementation. There is also nowhere for you to append any sort of &quot;retro&quot;<br>&gt;&gt; keyword anywhere, because no part of your own code extends S in any way.<br>&gt;&gt;<br>&gt;&gt; Please, please take the time to study the previous threads; we should not<br>&gt;&gt; be re-playing existing discussions four or five times on this list.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; How is this a problem, though? The implementation of foo() in S will not<br>&gt;&gt; break, because it’s already been compiled in. The change will only affect<br>&gt;&gt; code that is subsequently compiled with your extension of P in place. And<br>&gt;&gt; it’ll be doing its job; making sure that your code to implement the<br>&gt;&gt; protocol is there deliberately, and preventing you from accidentally<br>&gt;&gt; mistyping the method name and thus silently failing to override the default<br>&gt;&gt; implementation.<br>&gt;&gt;<br>&gt;<br>&gt; So you&#39;re saying that the compiler should let you compile your extension<br>&gt; of P, even though it knows that the default implementation of `foo()` is<br>&gt; not explicitly overridden by S. Fine.<br>&gt; Now suppose the library is not closed-source; you&#39;re including it in your<br>&gt; project and compiling it along with your own code. Are you supposed to fork<br>&gt; the library?<br>&gt;<br>&gt;<br>&gt; Even if the library is open-source, you&#39;ll presumably be building in as<br>&gt; its own target, which will be including only library code and not your<br>&gt; extension, and linking it into the application in a later stage of the<br>&gt; build process.<br>&gt;<br></p><p>I made the same argument eight months ago:<br></p><p>&gt;<br>&gt; * Another option might be to allow imported definitions to be used by a<br>&gt; conformance without the `override` marking to support retroactive modeling<br>&gt; while requiring definitions in the same module as the conformance to<br>&gt; explicitly specify the `override`.*<br></p><p><br> But Brent Royal-Gordon had a good point:<br></p><p>But the same problem exists if you want to do this to `internal` types<br>&gt; using a `private` protocol. There you *could* make the protocol `internal`<br>&gt; and call `override` in all the right places, but if the protocol is an<br>&gt; implementation detail of one particular file, why should you?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/833ea1a1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 26, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On Aug 26, 2016, at 2:22 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Aug 26, 2016 at 1:53 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; On Aug 25, 2016, at 11:48 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Thu, Aug 25, 2016 at 11:05 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Aug 25, 2016, at 10:24 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, and it&#39;s covered in those previous threads. In brief, not all retroactive modeling involves extending a type:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * A vendor supplies you with a closed-source library with a struct S that conforms to standard library protocol P.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Protocol P requires a method named foo(), so struct S has its own implementation of foo().<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * You extend protocol P by adding a new default implementation of foo().<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This cannot be done if a keyword is required for overriding a default implementation. There is also nowhere for you to append any sort of &quot;retro&quot; keyword anywhere, because no part of your own code extends S in any way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please, please take the time to study the previous threads; we should not be re-playing existing discussions four or five times on this list.<br>&gt;&gt; <br>&gt;&gt; How is this a problem, though? The implementation of foo() in S will not break, because it’s already been compiled in. The change will only affect code that is subsequently compiled with your extension of P in place. And it’ll be doing its job; making sure that your code to implement the protocol is there deliberately, and preventing you from accidentally mistyping the method name and thus silently failing to override the default implementation.<br>&gt;&gt; <br>&gt;&gt; So you&#39;re saying that the compiler should let you compile your extension of P, even though it knows that the default implementation of `foo()` is not explicitly overridden by S. Fine.<br>&gt;&gt; Now suppose the library is not closed-source; you&#39;re including it in your project and compiling it along with your own code. Are you supposed to fork the library?<br>&gt; <br>&gt; Even if the library is open-source, you&#39;ll presumably be building in as its own target, which will be including only library code and not your extension, and linking it into the application in a later stage of the build process.<br>&gt; <br>&gt; I made the same argument eight months ago:<br>&gt; <br>&gt; &gt; Another option might be to allow imported definitions to be used by a conformance without the `override` marking to support retroactive modeling while requiring definitions in the same module as the conformance to explicitly specify the `override`.<br>&gt; <br>&gt;  But Brent Royal-Gordon had a good point: <br>&gt; <br>&gt; But the same problem exists if you want to do this to `internal` types using a `private` protocol. There you *could* make the protocol `internal` and call `override` in all the right places, but if the protocol is an implementation detail of one particular file, why should you?<br></p><p>If the protocol is private, than to code outside that file, the protocol effectively doesn’t exist, since code in protocol extensions is statically dispatched (this is also true to code in your hypothetical library). So no need for “override” there.<br></p><p>If the protocol is internal, than code elsewhere in your app can see it, and thus they should have to override, for the same reason that if you added a superclass method that some subclass was already using, you’d need to add “override”.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/59397563/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 26, 2016 at 03:00:00am</p></header><div class="content"><p>On Fri, Aug 26, 2016 at 2:30 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 26, 2016, at 2:22 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Fri, Aug 26, 2016 at 1:53 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt;  wrote:<br>&gt;<br>&gt;&gt; On Aug 25, 2016, at 11:48 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Thu, Aug 25, 2016 at 11:05 PM, Charles Srstka &lt;cocoadev at charlessoft.c<br>&gt;&gt; om&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Aug 25, 2016, at 10:24 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, and it&#39;s covered in those previous threads. In brief, not all<br>&gt;&gt;&gt; retroactive modeling involves extending a type:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * A vendor supplies you with a closed-source library with a struct S<br>&gt;&gt;&gt; that conforms to standard library protocol P.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Protocol P requires a method named foo(), so struct S has its own<br>&gt;&gt;&gt; implementation of foo().<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * You extend protocol P by adding a new default implementation of foo().<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This cannot be done if a keyword is required for overriding a default<br>&gt;&gt;&gt; implementation. There is also nowhere for you to append any sort of &quot;retro&quot;<br>&gt;&gt;&gt; keyword anywhere, because no part of your own code extends S in any way.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Please, please take the time to study the previous threads; we should<br>&gt;&gt;&gt; not be re-playing existing discussions four or five times on this list.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; How is this a problem, though? The implementation of foo() in S will not<br>&gt;&gt;&gt; break, because it’s already been compiled in. The change will only affect<br>&gt;&gt;&gt; code that is subsequently compiled with your extension of P in place. And<br>&gt;&gt;&gt; it’ll be doing its job; making sure that your code to implement the<br>&gt;&gt;&gt; protocol is there deliberately, and preventing you from accidentally<br>&gt;&gt;&gt; mistyping the method name and thus silently failing to override the default<br>&gt;&gt;&gt; implementation.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; So you&#39;re saying that the compiler should let you compile your extension<br>&gt;&gt; of P, even though it knows that the default implementation of `foo()` is<br>&gt;&gt; not explicitly overridden by S. Fine.<br>&gt;&gt; Now suppose the library is not closed-source; you&#39;re including it in your<br>&gt;&gt; project and compiling it along with your own code. Are you supposed to fork<br>&gt;&gt; the library?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Even if the library is open-source, you&#39;ll presumably be building in as<br>&gt;&gt; its own target, which will be including only library code and not your<br>&gt;&gt; extension, and linking it into the application in a later stage of the<br>&gt;&gt; build process.<br>&gt;&gt;<br>&gt;<br>&gt; I made the same argument eight months ago:<br>&gt;<br>&gt; &gt;<br>&gt;&gt; * Another option might be to allow imported definitions to be used by a<br>&gt;&gt; conformance without the `override` marking to support retroactive modeling<br>&gt;&gt; while requiring definitions in the same module as the conformance to<br>&gt;&gt; explicitly specify the `override`.*<br>&gt;<br>&gt;<br>&gt;  But Brent Royal-Gordon had a good point:<br>&gt;<br>&gt; But the same problem exists if you want to do this to `internal` types<br>&gt;&gt; using a `private` protocol. There you *could* make the protocol `internal`<br>&gt;&gt; and call `override` in all the right places, but if the protocol is an<br>&gt;&gt; implementation detail of one particular file, why should you?<br>&gt;<br>&gt;<br>&gt; If the protocol is private, than to code outside that file, the protocol<br>&gt; effectively doesn’t exist, since code in protocol extensions is statically<br>&gt; dispatched (this is also true to code in your hypothetical library). So no<br>&gt; need for “override” there.<br>&gt;<br></p><p>That is incorrect. If it&#39;s a protocol requirement, it&#39;s dynamically<br>dispatched. If I conform an internal type to a private protocol and use<br>that type in the same file where the protocol is defined, that type<br>conforms to the protocol. You would have no way of appending the `override`<br>keyword to the relevant overrides without making the protocol internally<br>visible.<br></p><p>If the protocol is internal, than code elsewhere in your app can see it,<br>&gt; and thus they should have to override, for the same reason that if you<br>&gt; added a superclass method that some subclass was already using, you’d need<br>&gt; to add “override”.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/5957322c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 26, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Aug 26, 2016, at 3:39 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Aug 26, 2016 at 2:30 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; On Aug 26, 2016, at 2:22 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Fri, Aug 26, 2016 at 1:53 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Aug 25, 2016, at 11:48 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Aug 25, 2016 at 11:05 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Aug 25, 2016, at 10:24 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, and it&#39;s covered in those previous threads. In brief, not all retroactive modeling involves extending a type:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * A vendor supplies you with a closed-source library with a struct S that conforms to standard library protocol P.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Protocol P requires a method named foo(), so struct S has its own implementation of foo().<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * You extend protocol P by adding a new default implementation of foo().<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This cannot be done if a keyword is required for overriding a default implementation. There is also nowhere for you to append any sort of &quot;retro&quot; keyword anywhere, because no part of your own code extends S in any way.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Please, please take the time to study the previous threads; we should not be re-playing existing discussions four or five times on this list.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How is this a problem, though? The implementation of foo() in S will not break, because it’s already been compiled in. The change will only affect code that is subsequently compiled with your extension of P in place. And it’ll be doing its job; making sure that your code to implement the protocol is there deliberately, and preventing you from accidentally mistyping the method name and thus silently failing to override the default implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So you&#39;re saying that the compiler should let you compile your extension of P, even though it knows that the default implementation of `foo()` is not explicitly overridden by S. Fine.<br>&gt;&gt;&gt; Now suppose the library is not closed-source; you&#39;re including it in your project and compiling it along with your own code. Are you supposed to fork the library?<br>&gt;&gt; <br>&gt;&gt; Even if the library is open-source, you&#39;ll presumably be building in as its own target, which will be including only library code and not your extension, and linking it into the application in a later stage of the build process.<br>&gt;&gt; <br>&gt;&gt; I made the same argument eight months ago:<br>&gt;&gt; <br>&gt;&gt; &gt; Another option might be to allow imported definitions to be used by a conformance without the `override` marking to support retroactive modeling while requiring definitions in the same module as the conformance to explicitly specify the `override`.<br>&gt;&gt; <br>&gt;&gt;  But Brent Royal-Gordon had a good point: <br>&gt;&gt; <br>&gt;&gt; But the same problem exists if you want to do this to `internal` types using a `private` protocol. There you *could* make the protocol `internal` and call `override` in all the right places, but if the protocol is an implementation detail of one particular file, why should you?<br>&gt; <br>&gt; If the protocol is private, than to code outside that file, the protocol effectively doesn’t exist, since code in protocol extensions is statically dispatched (this is also true to code in your hypothetical library). So no need for “override” there.<br>&gt; <br>&gt; That is incorrect. If it&#39;s a protocol requirement, it&#39;s dynamically dispatched. If I conform an internal type to a private protocol and use that type in the same file where the protocol is defined, that type conforms to the protocol. You would have no way of appending the `override` keyword to the relevant overrides without making the protocol internally visible.<br></p><p><br>We were speaking of extending a protocol. This means that either 1) the method we add lives only in the extension, is statically dispatched, and thus does not exist to code that cannot see the extension, or 2) the code that cannot see the extension has been written as if the extension did not exist, and thus must already have another implementation of the method. In neither case does the extension affect the behavior of code that cannot see it.<br></p><p>If the protocol is private, then your internal type cannot see it. The internal type, which lives in complete blissful ignorance of the private protocol, can coincidentally implement one of the methods, but it is not conforming to the protocol in doing so, and thus does not have any need of adding a keyword to indicate that it is so conforming. If the match in nomenclature is more than coincidental, the intention falls on the private protocol, not the internal type.<br></p><p>The point of the keyword is to clarify *intentions.* If I am declaring my type as conforming to a protocol, and I am implementing methods that are required by the protocol, I should tell the compiler that the purpose of these methods is to satisfy the protocol. If I am implementing a protocol method that already has a default, I should indicate that I’m doing that on purpose, as well. If I *am not conforming* to the protocol and somebody *else* is adding conformance in an extension, then it’s not my problem and the person doing the conforming should be the one to declare their intent.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/51ab3a07/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 26, 2016 at 04:00:00am</p></header><div class="content"><p>On Fri, Aug 26, 2016 at 3:55 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 26, 2016, at 3:39 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Fri, Aug 26, 2016 at 2:30 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt;  wrote:<br>&gt;<br>&gt;&gt; On Aug 26, 2016, at 2:22 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Fri, Aug 26, 2016 at 1:53 AM, Charles Srstka &lt;cocoadev at charlessoft.com<br>&gt;&gt; &gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Aug 25, 2016, at 11:48 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Thu, Aug 25, 2016 at 11:05 PM, Charles Srstka &lt;cocoadev at charlessoft.c<br>&gt;&gt;&gt; om&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Aug 25, 2016, at 10:24 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Yes, and it&#39;s covered in those previous threads. In brief, not all<br>&gt;&gt;&gt;&gt; retroactive modeling involves extending a type:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * A vendor supplies you with a closed-source library with a struct S<br>&gt;&gt;&gt;&gt; that conforms to standard library protocol P.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * Protocol P requires a method named foo(), so struct S has its own<br>&gt;&gt;&gt;&gt; implementation of foo().<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * You extend protocol P by adding a new default implementation of foo().<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This cannot be done if a keyword is required for overriding a default<br>&gt;&gt;&gt;&gt; implementation. There is also nowhere for you to append any sort of &quot;retro&quot;<br>&gt;&gt;&gt;&gt; keyword anywhere, because no part of your own code extends S in any way.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Please, please take the time to study the previous threads; we should<br>&gt;&gt;&gt;&gt; not be re-playing existing discussions four or five times on this list.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; How is this a problem, though? The implementation of foo() in S will<br>&gt;&gt;&gt;&gt; not break, because it’s already been compiled in. The change will only<br>&gt;&gt;&gt;&gt; affect code that is subsequently compiled with your extension of P in<br>&gt;&gt;&gt;&gt; place. And it’ll be doing its job; making sure that your code to implement<br>&gt;&gt;&gt;&gt; the protocol is there deliberately, and preventing you from accidentally<br>&gt;&gt;&gt;&gt; mistyping the method name and thus silently failing to override the default<br>&gt;&gt;&gt;&gt; implementation.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So you&#39;re saying that the compiler should let you compile your extension<br>&gt;&gt;&gt; of P, even though it knows that the default implementation of `foo()` is<br>&gt;&gt;&gt; not explicitly overridden by S. Fine.<br>&gt;&gt;&gt; Now suppose the library is not closed-source; you&#39;re including it in<br>&gt;&gt;&gt; your project and compiling it along with your own code. Are you supposed to<br>&gt;&gt;&gt; fork the library?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Even if the library is open-source, you&#39;ll presumably be building in as<br>&gt;&gt;&gt; its own target, which will be including only library code and not your<br>&gt;&gt;&gt; extension, and linking it into the application in a later stage of the<br>&gt;&gt;&gt; build process.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I made the same argument eight months ago:<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt;&gt; * Another option might be to allow imported definitions to be used by a<br>&gt;&gt;&gt; conformance without the `override` marking to support retroactive modeling<br>&gt;&gt;&gt; while requiring definitions in the same module as the conformance to<br>&gt;&gt;&gt; explicitly specify the `override`.*<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  But Brent Royal-Gordon had a good point:<br>&gt;&gt;<br>&gt;&gt; But the same problem exists if you want to do this to `internal` types<br>&gt;&gt;&gt; using a `private` protocol. There you *could* make the protocol `internal`<br>&gt;&gt;&gt; and call `override` in all the right places, but if the protocol is an<br>&gt;&gt;&gt; implementation detail of one particular file, why should you?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If the protocol is private, than to code outside that file, the protocol<br>&gt;&gt; effectively doesn’t exist, since code in protocol extensions is statically<br>&gt;&gt; dispatched (this is also true to code in your hypothetical library). So no<br>&gt;&gt; need for “override” there.<br>&gt;&gt;<br>&gt;<br>&gt; That is incorrect. If it&#39;s a protocol requirement, it&#39;s dynamically<br>&gt; dispatched. If I conform an internal type to a private protocol and use<br>&gt; that type in the same file where the protocol is defined, that type<br>&gt; conforms to the protocol. You would have no way of appending the `override`<br>&gt; keyword to the relevant overrides without making the protocol internally<br>&gt; visible.<br>&gt;<br>&gt;<br>&gt; We were speaking of extending a protocol.<br>&gt;<br></p><p>That is not exactly what Brent was speaking of. We are talking about this<br>scenario:<br></p><p>File A:<br></p><p>```<br>internal struct S {<br>  func foo() { }<br>}<br>```<br></p><p>File B:<br></p><p>```<br>private protocol P {<br>  func foo()<br>}<br></p><p>extension P {<br>  func foo() { }<br>}<br></p><p>// With your proposal, I can&#39;t write the following line:<br>extension S : P { }<br>// In file A, S.foo() isn&#39;t overriding anything, so I can&#39;t add `override`<br>// But in file B, S can&#39;t conform to P,<br>// because S.foo() isn&#39;t overriding P.foo() without `override` in file A<br>```<br></p><p>This means that either 1) the method we add lives only in the extension, is<br>&gt; statically dispatched, and thus does not exist to code that cannot see the<br>&gt; extension, or 2) the code that cannot see the extension has been written as<br>&gt; if the extension did not exist, and thus must already have another<br>&gt; implementation of the method. In neither case does the extension affect the<br>&gt; behavior of code that cannot see it.<br>&gt;<br>&gt; If the protocol is private, then your internal type cannot see it. The<br>&gt; internal type, which lives in complete blissful ignorance of the private<br>&gt; protocol, can coincidentally implement one of the methods, but it is not<br>&gt; conforming to the protocol in doing so, and thus does not have any need of<br>&gt; adding a keyword to indicate that it is so conforming. If the match in<br>&gt; nomenclature is more than coincidental, the intention falls on the private<br>&gt; protocol, not the internal type.<br>&gt;<br>&gt; The point of the keyword is to clarify *intentions.* If I am declaring my<br>&gt; type as conforming to a protocol, and I am implementing methods that are<br>&gt; required by the protocol, I should tell the compiler that the purpose of<br>&gt; these methods is to satisfy the protocol. If I am implementing a protocol<br>&gt; method that already has a default, I should indicate that I’m doing that on<br>&gt; purpose, as well. If I *am not conforming* to the protocol and somebody<br>&gt; *else* is adding conformance in an extension, then it’s not my problem and<br>&gt; the person doing the conforming should be the one to declare their intent.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/c1607359/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 26, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On Aug 26, 2016, at 4:02 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; That is not exactly what Brent was speaking of. We are talking about this scenario:<br>&gt; <br>&gt; File A:<br>&gt; <br>&gt; ```<br>&gt; internal struct S {<br>&gt;   func foo() { }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; File B:<br>&gt; <br>&gt; ```<br>&gt; private protocol P {<br>&gt;   func foo()<br>&gt; }<br>&gt; <br>&gt; extension P {<br>&gt;   func foo() { }<br>&gt; }<br>&gt; <br>&gt; // With your proposal, I can&#39;t write the following line:<br>&gt; extension S : P { }<br>&gt; // In file A, S.foo() isn&#39;t overriding anything, so I can&#39;t add `override`<br>&gt; // But in file B, S can&#39;t conform to P,<br>&gt; // because S.foo() isn&#39;t overriding P.foo() without `override` in file A<br></p><p>First of all, I cannot take credit for the proposal, as the thread was started by David, not me, so if the proposal is anyone’s, it’s his. With that said, what he proposes is:<br></p><p>&gt; On Aug 22, 2016, at 4:30 PM, David Cordero via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Proposal:<br>&gt; Adding a keyword to the methods conforming protocols. As an example please check the following piece of code which uses the keyword `conform` to explicitly indicate that `myMethod` is a method conforming a protocol.<br></p><p><br>The wording here is that the keyword is needed for methods conforming to protocols. My reading of that is that:<br></p><p>File A:<br></p><p>protocol P {<br>	func foo()<br>}<br></p><p>struct S: P {<br>	conform func foo() {<br>		// I am declared as conforming to P, so in adding this method I am doing so to conform to P. Thus, I need the keyword.<br>	}<br>}<br></p><p>- - whereas: - -<br></p><p>File A:<br></p><p>struct S {<br>	func foo() {<br>		// I am not declared as conforming to any protocol; I just think that being able to foo is an ability that I need to have.<br>	}<br>}<br></p><p>File B:<br></p><p>private protocol P {<br>	func foo()<br>}<br></p><p>extension S: P {<br>	// The area of contention.<br>}<br></p><p>- - - - - -<br></p><p>The proposal doesn’t really mention what to do here, so we can argue a bit about it. There are multiple viewpoints one could take on this. A few could be:<br></p><p>1. The extension should get some kind of keyword, “retro” or “@retro” or something better-sounding that someone smarter than I comes up with.<br></p><p>2. The extension is unmarked, but declares foo() inside it with some sort of annotation to indicate that it represents a method that already exists.<br></p><p>3. Just leave the extension exactly as written, since it’s not declaring any methods, and thus doesn’t have to indicate what those nonexistent method declarations conform to.<br></p><p>I began this discussion leaning toward #1, but now I’m starting to consider #3, since the purpose of the keyword is to declare one’s intentions. The intentions of an empty extension that does nothing but conform to a protocol is actually quite clear; the methods have to be already declared somewhere else, or it makes no sense. At any rate, the “problem” in your scenario is entirely confined to File B, so if any annotations are necessary, that is where they belong. File A does not know about the protocol, it does not know that it is conforming to the protocol, and indeed, the protocol is none of File A’s business. So since File A is not intending to conform to the protocol, File A does not have to declare its intent to conform to the protocol. If we require that, it’s all in File B’s court.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/c7559f04/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 26, 2016 at 04:00:00am</p></header><div class="content"><p>On Fri, Aug 26, 2016 at 4:24 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 26, 2016, at 4:02 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; That is not exactly what Brent was speaking of. We are talking about this<br>&gt; scenario:<br>&gt;<br>&gt; File A:<br>&gt;<br>&gt; ```<br>&gt; internal struct S {<br>&gt;   func foo() { }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; File B:<br>&gt;<br>&gt; ```<br>&gt; private protocol P {<br>&gt;   func foo()<br>&gt; }<br>&gt;<br>&gt; extension P {<br>&gt;   func foo() { }<br>&gt; }<br>&gt;<br>&gt; // With your proposal, I can&#39;t write the following line:<br>&gt; extension S : P { }<br>&gt; // In file A, S.foo() isn&#39;t overriding anything, so I can&#39;t add `override`<br>&gt; // But in file B, S can&#39;t conform to P,<br>&gt; // because S.foo() isn&#39;t overriding P.foo() without `override` in file A<br>&gt;<br>&gt;<br>&gt; First of all, I cannot take credit for the proposal, as the thread was<br>&gt; started by David, not me, so if the proposal is anyone’s, it’s his. With<br>&gt; that said, what he proposes is:<br>&gt;<br>&gt; On Aug 22, 2016, at 4:30 PM, David Cordero via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; *Proposal:*<br>&gt; Adding a keyword to the methods conforming protocols. As an example please<br>&gt; check the following piece of code which uses the keyword `conform` to<br>&gt; explicitly indicate that `myMethod` is a method conforming a protocol.<br>&gt;<br>&gt;<br>&gt; The wording here is that the keyword is needed for methods conforming to<br>&gt; protocols. My reading of that is that:<br>&gt;<br>&gt; File A:<br>&gt;<br>&gt; protocol P {<br>&gt; func foo()<br>&gt; }<br>&gt;<br>&gt; struct S: P {<br>&gt; conform func foo() {<br>&gt; // I am declared as conforming to P, so in adding this method I am doing<br>&gt; so to conform to P. Thus, I need the keyword.<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; - - whereas: - -<br>&gt;<br>&gt; File A:<br>&gt;<br>&gt; struct S {<br>&gt; func foo() {<br>&gt; // I am not declared as conforming to any protocol; I just think that<br>&gt; being able to foo is an ability that I need to have.<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; File B:<br>&gt;<br>&gt; private protocol P {<br>&gt; func foo()<br>&gt; }<br>&gt;<br>&gt; extension S: P {<br>&gt; // The area of contention.<br>&gt; }<br>&gt;<br>&gt; - - - - - -<br>&gt;<br>&gt; The proposal doesn’t really mention what to do here, so we can argue a bit<br>&gt; about it. There are multiple viewpoints one could take on this. A few could<br>&gt; be:<br>&gt;<br>&gt; 1. The extension should get some kind of keyword, “retro” or “@retro” or<br>&gt; something better-sounding that someone smarter than I comes up with.<br>&gt;<br>&gt; 2. The extension is unmarked, but declares foo() inside it with some sort<br>&gt; of annotation to indicate that it represents a method that already exists.<br>&gt;<br>&gt; 3. Just leave the extension exactly as written, since it’s not declaring<br>&gt; any methods, and thus doesn’t have to indicate what those nonexistent<br>&gt; method declarations conform to.<br>&gt;<br>&gt; I began this discussion leaning toward #1, but now I’m starting to<br>&gt; consider #3, since the purpose of the keyword is to declare one’s<br>&gt; intentions. The intentions of an empty extension that does nothing but<br>&gt; conform to a protocol is actually quite clear; the methods have to be<br>&gt; already declared somewhere else, or it makes no sense. At any rate, the<br>&gt; “problem” in your scenario is entirely confined to File B, so if any<br>&gt; annotations are necessary, that is where they belong. File A does not know<br>&gt; about the protocol, it does not know that it is conforming to the protocol,<br>&gt; and indeed, the protocol is none of File A’s business. So since File A is<br>&gt; not intending to conform to the protocol, File A does not have to declare<br>&gt; its intent to conform to the protocol. If we require that, it’s all in File<br>&gt; B’s court.<br>&gt;<br></p><p>As I said, this discussion has already happened several times. I&#39;m<br>literally just repeating what people said eight months ago, six months ago,<br>and four months ago. There&#39;s not a good answer to this and perhaps several<br>other issues, which is why I don&#39;t see a way forward for the proposal.<br>After all, I was the one proposing the same idea last winter, so I&#39;ve had a<br>few months to think about it.<br></p><p>If option (3) were allowed, then no keyword could ever be mandatory; it&#39;s<br>always possible to refactor so that a conformance declaration is an empty<br>extension. So we&#39;re back at an optional keyword, which has its own<br>problems. This kind of thinking is how I&#39;ve come to the conclusion that the<br>status quo, with better diagnostics, is the least bad solution.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/e463cbca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 26, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; On Aug 26, 2016, at 4:34 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Aug 26, 2016 at 4:24 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; On Aug 26, 2016, at 4:02 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That is not exactly what Brent was speaking of. We are talking about this scenario:<br>&gt;&gt; <br>&gt;&gt; File A:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; internal struct S {<br>&gt;&gt;   func foo() { }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; File B:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; private protocol P {<br>&gt;&gt;   func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt;   func foo() { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // With your proposal, I can&#39;t write the following line:<br>&gt;&gt; extension S : P { }<br>&gt;&gt; // In file A, S.foo() isn&#39;t overriding anything, so I can&#39;t add `override`<br>&gt;&gt; // But in file B, S can&#39;t conform to P,<br>&gt;&gt; // because S.foo() isn&#39;t overriding P.foo() without `override` in file A<br>&gt; <br>&gt; First of all, I cannot take credit for the proposal, as the thread was started by David, not me, so if the proposal is anyone’s, it’s his. With that said, what he proposes is:<br>&gt; <br>&gt;&gt; On Aug 22, 2016, at 4:30 PM, David Cordero via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Proposal:<br>&gt;&gt; Adding a keyword to the methods conforming protocols. As an example please check the following piece of code which uses the keyword `conform` to explicitly indicate that `myMethod` is a method conforming a protocol.<br>&gt; <br>&gt; <br>&gt; The wording here is that the keyword is needed for methods conforming to protocols. My reading of that is that:<br>&gt; <br>&gt; File A:<br>&gt; <br>&gt; protocol P {<br>&gt; 	func foo()<br>&gt; }<br>&gt; <br>&gt; struct S: P {<br>&gt; 	conform func foo() {<br>&gt; 		// I am declared as conforming to P, so in adding this method I am doing so to conform to P. Thus, I need the keyword.<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; - - whereas: - -<br>&gt; <br>&gt; File A:<br>&gt; <br>&gt; struct S {<br>&gt; 	func foo() {<br>&gt; 		// I am not declared as conforming to any protocol; I just think that being able to foo is an ability that I need to have.<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; File B:<br>&gt; <br>&gt; private protocol P {<br>&gt; 	func foo()<br>&gt; }<br>&gt; <br>&gt; extension S: P {<br>&gt; 	// The area of contention.<br>&gt; }<br>&gt; <br>&gt; - - - - - -<br>&gt; <br>&gt; The proposal doesn’t really mention what to do here, so we can argue a bit about it. There are multiple viewpoints one could take on this. A few could be:<br>&gt; <br>&gt; 1. The extension should get some kind of keyword, “retro” or “@retro” or something better-sounding that someone smarter than I comes up with.<br>&gt; <br>&gt; 2. The extension is unmarked, but declares foo() inside it with some sort of annotation to indicate that it represents a method that already exists.<br>&gt; <br>&gt; 3. Just leave the extension exactly as written, since it’s not declaring any methods, and thus doesn’t have to indicate what those nonexistent method declarations conform to.<br>&gt; <br>&gt; I began this discussion leaning toward #1, but now I’m starting to consider #3, since the purpose of the keyword is to declare one’s intentions. The intentions of an empty extension that does nothing but conform to a protocol is actually quite clear; the methods have to be already declared somewhere else, or it makes no sense. At any rate, the “problem” in your scenario is entirely confined to File B, so if any annotations are necessary, that is where they belong. File A does not know about the protocol, it does not know that it is conforming to the protocol, and indeed, the protocol is none of File A’s business. So since File A is not intending to conform to the protocol, File A does not have to declare its intent to conform to the protocol. If we require that, it’s all in File B’s court.<br>&gt; <br>&gt; As I said, this discussion has already happened several times. I&#39;m literally just repeating what people said eight months ago, six months ago, and four months ago. There&#39;s not a good answer to this and perhaps several other issues, which is why I don&#39;t see a way forward for the proposal. After all, I was the one proposing the same idea last winter, so I&#39;ve had a few months to think about it.<br>&gt; <br>&gt; If option (3) were allowed, then no keyword could ever be mandatory; it&#39;s always possible to refactor so that a conformance declaration is an empty extension. So we&#39;re back at an optional keyword, which has its own problems. This kind of thinking is how I&#39;ve come to the conclusion that the status quo, with better diagnostics, is the least bad solution.<br></p><p><br>Two responses to that thought:<br></p><p>1) In general, I look at these things under the assumption that most developers are not going to be making efforts to deliberately break the system, and not to try to expend excessive amounts of time in preventing them from doing so. Because really, just about *anything* can be worked around. I can work around the “override” keyword and override things without it, but that doesn’t mean that I think we should remove the “override” keyword. For that matter, just about *everything* in Objective-C was workaroundable, and usually rather trivially at that, but that didn’t make us all go back to typing everything as ‘id’ just because the explicit types could be spoofed.<br></p><p>2) Even if you disagree with everything I just said, that’s just as much an argument for option #1 as for the status quo.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/145d9ec4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 26, 2016 at 11:00:00am</p></header><div class="content"><p>On Fri, Aug 26, 2016 at 5:08 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 26, 2016, at 4:34 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Fri, Aug 26, 2016 at 4:24 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt;  wrote:<br>&gt;<br>&gt;&gt; On Aug 26, 2016, at 4:02 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That is not exactly what Brent was speaking of. We are talking about this<br>&gt;&gt; scenario:<br>&gt;&gt;<br>&gt;&gt; File A:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; internal struct S {<br>&gt;&gt;   func foo() { }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; File B:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; private protocol P {<br>&gt;&gt;   func foo()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension P {<br>&gt;&gt;   func foo() { }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // With your proposal, I can&#39;t write the following line:<br>&gt;&gt; extension S : P { }<br>&gt;&gt; // In file A, S.foo() isn&#39;t overriding anything, so I can&#39;t add `override`<br>&gt;&gt; // But in file B, S can&#39;t conform to P,<br>&gt;&gt; // because S.foo() isn&#39;t overriding P.foo() without `override` in file A<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; First of all, I cannot take credit for the proposal, as the thread was<br>&gt;&gt; started by David, not me, so if the proposal is anyone’s, it’s his. With<br>&gt;&gt; that said, what he proposes is:<br>&gt;&gt;<br>&gt;&gt; On Aug 22, 2016, at 4:30 PM, David Cordero via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; *Proposal:*<br>&gt;&gt; Adding a keyword to the methods conforming protocols. As an example<br>&gt;&gt; please check the following piece of code which uses the keyword `conform`<br>&gt;&gt; to explicitly indicate that `myMethod` is a method conforming a protocol.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The wording here is that the keyword is needed for methods conforming to<br>&gt;&gt; protocols. My reading of that is that:<br>&gt;&gt;<br>&gt;&gt; File A:<br>&gt;&gt;<br>&gt;&gt; protocol P {<br>&gt;&gt; func foo()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct S: P {<br>&gt;&gt; conform func foo() {<br>&gt;&gt; // I am declared as conforming to P, so in adding this method I am doing<br>&gt;&gt; so to conform to P. Thus, I need the keyword.<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; - - whereas: - -<br>&gt;&gt;<br>&gt;&gt; File A:<br>&gt;&gt;<br>&gt;&gt; struct S {<br>&gt;&gt; func foo() {<br>&gt;&gt; // I am not declared as conforming to any protocol; I just think that<br>&gt;&gt; being able to foo is an ability that I need to have.<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; File B:<br>&gt;&gt;<br>&gt;&gt; private protocol P {<br>&gt;&gt; func foo()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension S: P {<br>&gt;&gt; // The area of contention.<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; - - - - - -<br>&gt;&gt;<br>&gt;&gt; The proposal doesn’t really mention what to do here, so we can argue a<br>&gt;&gt; bit about it. There are multiple viewpoints one could take on this. A few<br>&gt;&gt; could be:<br>&gt;&gt;<br>&gt;&gt; 1. The extension should get some kind of keyword, “retro” or “@retro” or<br>&gt;&gt; something better-sounding that someone smarter than I comes up with.<br>&gt;&gt;<br>&gt;&gt; 2. The extension is unmarked, but declares foo() inside it with some sort<br>&gt;&gt; of annotation to indicate that it represents a method that already exists.<br>&gt;&gt;<br>&gt;&gt; 3. Just leave the extension exactly as written, since it’s not declaring<br>&gt;&gt; any methods, and thus doesn’t have to indicate what those nonexistent<br>&gt;&gt; method declarations conform to.<br>&gt;&gt;<br>&gt;&gt; I began this discussion leaning toward #1, but now I’m starting to<br>&gt;&gt; consider #3, since the purpose of the keyword is to declare one’s<br>&gt;&gt; intentions. The intentions of an empty extension that does nothing but<br>&gt;&gt; conform to a protocol is actually quite clear; the methods have to be<br>&gt;&gt; already declared somewhere else, or it makes no sense. At any rate, the<br>&gt;&gt; “problem” in your scenario is entirely confined to File B, so if any<br>&gt;&gt; annotations are necessary, that is where they belong. File A does not know<br>&gt;&gt; about the protocol, it does not know that it is conforming to the protocol,<br>&gt;&gt; and indeed, the protocol is none of File A’s business. So since File A is<br>&gt;&gt; not intending to conform to the protocol, File A does not have to declare<br>&gt;&gt; its intent to conform to the protocol. If we require that, it’s all in File<br>&gt;&gt; B’s court.<br>&gt;&gt;<br>&gt;<br>&gt; As I said, this discussion has already happened several times. I&#39;m<br>&gt; literally just repeating what people said eight months ago, six months ago,<br>&gt; and four months ago. There&#39;s not a good answer to this and perhaps several<br>&gt; other issues, which is why I don&#39;t see a way forward for the proposal.<br>&gt; After all, I was the one proposing the same idea last winter, so I&#39;ve had a<br>&gt; few months to think about it.<br>&gt;<br>&gt; If option (3) were allowed, then no keyword could ever be mandatory; it&#39;s<br>&gt; always possible to refactor so that a conformance declaration is an empty<br>&gt; extension. So we&#39;re back at an optional keyword, which has its own<br>&gt; problems. This kind of thinking is how I&#39;ve come to the conclusion that the<br>&gt; status quo, with better diagnostics, is the least bad solution.<br>&gt;<br>&gt;<br>&gt; Two responses to that thought:<br>&gt;<br>&gt; 1) In general, I look at these things under the assumption that most<br>&gt; developers are not going to be making efforts to deliberately break the<br>&gt; system, and not to try to expend excessive amounts of time in preventing<br>&gt; them from doing so. Because really, just about *anything* can be worked<br>&gt; around. I can work around the “override” keyword and override things<br>&gt; without it, but that doesn’t mean that I think we should remove the<br>&gt; “override” keyword.<br>&gt;<br></p><p>Really? I wasn&#39;t aware that you could work around the `override` keyword<br>(the one that&#39;s required for classes). How do you do that?<br></p><p><br>&gt; For that matter, just about *everything* in Objective-C was<br>&gt; workaroundable, and usually rather trivially at that, but that didn’t make<br>&gt; us all go back to typing everything as ‘id’ just because the explicit types<br>&gt; could be spoofed.<br>&gt;<br></p><p>Swift, by design, is rather different from Objective-C; it makes rather<br>stronger guarantees about the facilities it provides. I don&#39;t know of very<br>many (any?) keywords that attempt to enforce safety but are optional. Are<br>you?<br></p><p>2) Even if you disagree with everything I just said, that’s just as much an<br>&gt; argument for option #1 as for the status quo.<br>&gt;<br></p><p>The status quo has the benefit of not being source breaking, and simpler.<br></p><p><br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/551fcc6d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 26, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Aug 26, 2016, at 11:02 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Really? I wasn&#39;t aware that you could work around the `override` keyword (the one that&#39;s required for classes). How do you do that?<br></p><p>By implementing the subclass’s method before the superclass’s. You can try this yourself:<br></p><p>- - - Library code: - - -<br></p><p>open class Superclass {<br>    public init() {}<br>    public func foo() {<br>        print(&quot;foo called in library&quot;)<br>    }<br>}<br></p><p>- - - App code: - - -<br></p><p>import FooLibrary<br></p><p>class Subclass: Superclass {<br>    func bar() { print(&quot;bar called in the app&quot;) }<br>}<br></p><p>let obj = Subclass()<br></p><p>obj.foo()<br></p><p>- - - output: - - -<br></p><p>foo called in library<br>Program ended with exit code: 0<br></p><p>- - - - - -<br></p><p>Now: Change the library code to:<br></p><p>open class Superclass {<br>    public init() {}<br>    public func foo() {<br>        print(&quot;foo called in library&quot;)<br>        bar()<br>    }<br>    <br>    // Hey look, I didn&#39;t even use that stupid new &#39;open&#39; keyword.<br>    public func bar() { print(&quot;bar called in library&quot;) }<br>}<br></p><p>- - - Run the app again without compiling it, and: - - -<br></p><p>foo called in library<br>bar called in the app<br>Program ended with exit code: 0<br></p><p>- - -<br></p><p>Voilà: I overrode a method (a supposedly non-overridable one, at that) with no “override” keyword. Just as File A in your earlier example can implement a protocol method without realizing it, Subclass here has unintentionally overridden a superclass method. This is because ‘override’ does not, to the best of my knowledge, mean anything to the actual machine code that is produced; rather, it signals the developer’s *intent,* thus allowing the compiler to assist in making sure the developer does the right thing.<br></p><p>I’d actually argue that the example above is a much, much bigger problem than the objection you raised, as it can actually produce unintended behavior at runtime, whereas the example with protocols can’t.<br></p><p>As for the protocol example, I’d like to refine Option 3 from last night slightly:<br></p><p>Option 4: A keyword is required on a method declaration if and only if the containing type is declared as conforming to its protocol, either in its definition or in an extension that is visible within the current scope. This allows the extension to remain empty in your example, but puts the responsibility on the developer to declare conforming methods when it is reasonable to know that they will satisfy a protocol.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/9b0ac559/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 26, 2016 at 01:00:00pm</p></header><div class="content"><p>On Fri, Aug 26, 2016 at 1:27 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 26, 2016, at 11:02 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Really? I wasn&#39;t aware that you could work around the `override` keyword<br>&gt; (the one that&#39;s required for classes). How do you do that?<br>&gt;<br>&gt;<br>&gt; By implementing the subclass’s method before the superclass’s. You can try<br>&gt; this yourself:<br>&gt;<br>&gt; - - - Library code: - - -<br>&gt;<br>&gt; open class Superclass {<br>&gt;     public init() {}<br>&gt;     public func foo() {<br>&gt;         print(&quot;foo called in library&quot;)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; - - - App code: - - -<br>&gt;<br>&gt; import FooLibrary<br>&gt;<br>&gt; class Subclass: Superclass {<br>&gt;     func bar() { print(&quot;bar called in the app&quot;) }<br>&gt; }<br>&gt;<br>&gt; let obj = Subclass()<br>&gt;<br>&gt; obj.foo()<br>&gt;<br>&gt; - - - output: - - -<br>&gt;<br>&gt; *foo called in library*<br>&gt; *Program ended with exit code: 0*<br>&gt;<br>&gt; - - - - - -<br>&gt;<br>&gt; Now: Change the library code to:<br>&gt;<br>&gt; open class Superclass {<br>&gt;     public init() {}<br>&gt;     public func foo() {<br>&gt;         print(&quot;foo called in library&quot;)<br>&gt;         bar()<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     // Hey look, I didn&#39;t even use that stupid new &#39;open&#39; keyword.<br>&gt;     public func bar() { print(&quot;bar called in library&quot;) }<br>&gt; }<br>&gt;<br>&gt; - - - Run the app again without compiling it, and: - - -<br>&gt;<br>&gt; *foo called in library*<br>&gt; *bar called in the app*<br>&gt; *Program ended with exit code: 0*<br>&gt;<br>&gt; - - -<br>&gt;<br>&gt; Voilà: I overrode a method (a supposedly non-overridable one, at that)<br>&gt; with no “override” keyword.<br>&gt;<br></p><p>This is clearly a bug in the implementation, not part of the design. Expect<br>it to be fixed as the code for `open` matures. It&#39;s certainly not a<br>precedent to be emulated for designing another feature.<br></p><p><br>&gt; Just as File A in your earlier example can implement a protocol method<br>&gt; without realizing it, Subclass here has unintentionally overridden a<br>&gt; superclass method. This is because ‘override’ does not, to the best of my<br>&gt; knowledge, mean anything to the actual machine code that is produced;<br>&gt; rather, it signals the developer’s *intent,* thus allowing the compiler to<br>&gt; assist in making sure the developer does the right thing.<br>&gt;<br>&gt; I’d actually argue that the example above is a much, much bigger problem<br>&gt; than the objection you raised, as it can actually produce unintended<br>&gt; behavior at runtime, whereas the example with protocols can’t.<br>&gt;<br>&gt; As for the protocol example, I’d like to refine Option 3 from last night<br>&gt; slightly:<br>&gt;<br>&gt; Option 4: A keyword is required on a method declaration if and only if the<br>&gt; containing type is declared as conforming to its protocol, either in its<br>&gt; definition or in an extension that is visible within the current scope.<br>&gt;<br></p><p>Extensions are not first-class entities and have no visibility of their<br>own. In any case, you have not solved the problem, which has nothing to do<br>with whether something is &quot;reasonable to know&quot;: when a default<br>implementation A is overridden by implementation B, implementation A may be<br>visible only in a *more restricted* access scope than implementation B.<br>(This is not the case with overriding superclass members in subclasses.) It<br>can be perfectly &quot;reasonable to know&quot; about both A and B, but there is<br>still no way you can indicate this knowledge by appending a keyword to the<br>declaration for implementation B if the access scope for implementation A<br>is unutterable where B is declared.<br></p><p><br>&gt; This allows the extension to remain empty in your example, but puts the<br>&gt; responsibility on the developer to declare conforming methods when it is<br>&gt; reasonable to know that they will satisfy a protocol.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/48f11b9d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 26, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Aug 26, 2016, at 1:45 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Aug 26, 2016 at 1:27 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; On Aug 26, 2016, at 11:02 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Really? I wasn&#39;t aware that you could work around the `override` keyword (the one that&#39;s required for classes). How do you do that?<br>&gt; <br>&gt; By implementing the subclass’s method before the superclass’s. You can try this yourself:<br>&gt; <br>&gt; - - - Library code: - - -<br>&gt; <br>&gt; open class Superclass {<br>&gt;     public init() {}<br>&gt;     public func foo() {<br>&gt;         print(&quot;foo called in library&quot;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; - - - App code: - - -<br>&gt; <br>&gt; import FooLibrary<br>&gt; <br>&gt; class Subclass: Superclass {<br>&gt;     func bar() { print(&quot;bar called in the app&quot;) }<br>&gt; }<br>&gt; <br>&gt; let obj = Subclass()<br>&gt; <br>&gt; obj.foo()<br>&gt; <br>&gt; - - - output: - - -<br>&gt; <br>&gt; foo called in library<br>&gt; Program ended with exit code: 0<br>&gt; <br>&gt; - - - - - -<br>&gt; <br>&gt; Now: Change the library code to:<br>&gt; <br>&gt; open class Superclass {<br>&gt;     public init() {}<br>&gt;     public func foo() {<br>&gt;         print(&quot;foo called in library&quot;)<br>&gt;         bar()<br>&gt;     }<br>&gt;     <br>&gt;     // Hey look, I didn&#39;t even use that stupid new &#39;open&#39; keyword.<br>&gt;     public func bar() { print(&quot;bar called in library&quot;) }<br>&gt; }<br>&gt; <br>&gt; - - - Run the app again without compiling it, and: - - -<br>&gt; <br>&gt; foo called in library<br>&gt; bar called in the app<br>&gt; Program ended with exit code: 0<br>&gt; <br>&gt; - - -<br>&gt; <br>&gt; Voilà: I overrode a method (a supposedly non-overridable one, at that) with no “override” keyword.<br>&gt; <br>&gt; This is clearly a bug in the implementation, not part of the design. Expect it to be fixed as the code for `open` matures. It&#39;s certainly not a precedent to be emulated for designing another feature.<br></p><p>It’s a side effect of using straight string equality for conformance, which is the status quo that several proposals here have been hoping to change with protocols.<br></p><p>&gt; Just as File A in your earlier example can implement a protocol method without realizing it, Subclass here has unintentionally overridden a superclass method. This is because ‘override’ does not, to the best of my knowledge, mean anything to the actual machine code that is produced; rather, it signals the developer’s *intent,* thus allowing the compiler to assist in making sure the developer does the right thing.<br>&gt; <br>&gt; I’d actually argue that the example above is a much, much bigger problem than the objection you raised, as it can actually produce unintended behavior at runtime, whereas the example with protocols can’t.<br>&gt; <br>&gt; As for the protocol example, I’d like to refine Option 3 from last night slightly:<br>&gt; <br>&gt; Option 4: A keyword is required on a method declaration if and only if the containing type is declared as conforming to its protocol, either in its definition or in an extension that is visible within the current scope.<br>&gt; <br>&gt; Extensions are not first-class entities and have no visibility of their own.<br></p><p>I didn’t express that very well. Let me clarify what I mean:<br></p><p>internal struct S {}<br></p><p>private protocol P {<br>    func foo()<br>}<br></p><p>extension S: P {<br>    func foo() {}<br>}<br></p><p>- - - choose “Generated Interface” and you get: - - -<br></p><p>internal struct S {<br>}<br></p><p><br>extension S {<br></p><p>    internal func foo()<br>}<br></p><p>- - -<br></p><p>While the extension is visible, the fact that it adds conformance to P is not. Therefore, as far as code outside this file is concerned, there is no conformance to P.<br></p><p>&gt; In any case, you have not solved the problem, which has nothing to do with whether something is &quot;reasonable to know&quot;: when a default implementation A is overridden by implementation B, implementation A may be visible only in a *more restricted* access scope than implementation B. (This is not the case with overriding superclass members in subclasses.) It can be perfectly &quot;reasonable to know&quot; about both A and B, but there is still no way you can indicate this knowledge by appending a keyword to the declaration for implementation B if the access scope for implementation A is unutterable where B is declared.<br></p><p><br>Could you provide an example of code where this would present a problem?<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/a2c35347/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 26, 2016 at 02:00:00pm</p></header><div class="content"><p>On Fri, Aug 26, 2016 at 2:29 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 26, 2016, at 1:45 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Fri, Aug 26, 2016 at 1:27 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt;  wrote:<br>&gt;<br>&gt;&gt; On Aug 26, 2016, at 11:02 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Really? I wasn&#39;t aware that you could work around the `override` keyword<br>&gt;&gt; (the one that&#39;s required for classes). How do you do that?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; By implementing the subclass’s method before the superclass’s. You can<br>&gt;&gt; try this yourself:<br>&gt;&gt;<br>&gt;&gt; - - - Library code: - - -<br>&gt;&gt;<br>&gt;&gt; open class Superclass {<br>&gt;&gt;     public init() {}<br>&gt;&gt;     public func foo() {<br>&gt;&gt;         print(&quot;foo called in library&quot;)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; - - - App code: - - -<br>&gt;&gt;<br>&gt;&gt; import FooLibrary<br>&gt;&gt;<br>&gt;&gt; class Subclass: Superclass {<br>&gt;&gt;     func bar() { print(&quot;bar called in the app&quot;) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let obj = Subclass()<br>&gt;&gt;<br>&gt;&gt; obj.foo()<br>&gt;&gt;<br>&gt;&gt; - - - output: - - -<br>&gt;&gt;<br>&gt;&gt; *foo called in library*<br>&gt;&gt; *Program ended with exit code: 0*<br>&gt;&gt;<br>&gt;&gt; - - - - - -<br>&gt;&gt;<br>&gt;&gt; Now: Change the library code to:<br>&gt;&gt;<br>&gt;&gt; open class Superclass {<br>&gt;&gt;     public init() {}<br>&gt;&gt;     public func foo() {<br>&gt;&gt;         print(&quot;foo called in library&quot;)<br>&gt;&gt;         bar()<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     // Hey look, I didn&#39;t even use that stupid new &#39;open&#39; keyword.<br>&gt;&gt;     public func bar() { print(&quot;bar called in library&quot;) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; - - - Run the app again without compiling it, and: - - -<br>&gt;&gt;<br>&gt;&gt; *foo called in library*<br>&gt;&gt; *bar called in the app*<br>&gt;&gt; *Program ended with exit code: 0*<br>&gt;&gt;<br>&gt;&gt; - - -<br>&gt;&gt;<br>&gt;&gt; Voilà: I overrode a method (a supposedly non-overridable one, at that)<br>&gt;&gt; with no “override” keyword.<br>&gt;&gt;<br>&gt;<br>&gt; This is clearly a bug in the implementation, not part of the design.<br>&gt; Expect it to be fixed as the code for `open` matures. It&#39;s certainly not a<br>&gt; precedent to be emulated for designing another feature.<br>&gt;<br>&gt;<br>&gt; It’s a side effect of using straight string equality for conformance,<br>&gt; which is the status quo that several proposals here have been hoping to<br>&gt; change with protocols.<br>&gt;<br>&gt; Just as File A in your earlier example can implement a protocol method<br>&gt;&gt; without realizing it, Subclass here has unintentionally overridden a<br>&gt;&gt; superclass method. This is because ‘override’ does not, to the best of my<br>&gt;&gt; knowledge, mean anything to the actual machine code that is produced;<br>&gt;&gt; rather, it signals the developer’s *intent,* thus allowing the compiler to<br>&gt;&gt; assist in making sure the developer does the right thing.<br>&gt;&gt;<br>&gt;&gt; I’d actually argue that the example above is a much, much bigger problem<br>&gt;&gt; than the objection you raised, as it can actually produce unintended<br>&gt;&gt; behavior at runtime, whereas the example with protocols can’t.<br>&gt;&gt;<br>&gt;&gt; As for the protocol example, I’d like to refine Option 3 from last night<br>&gt;&gt; slightly:<br>&gt;&gt;<br>&gt;&gt; Option 4: A keyword is required on a method declaration if and only if<br>&gt;&gt; the containing type is declared as conforming to its protocol, either in<br>&gt;&gt; its definition or in an extension that is visible within the current scope.<br>&gt;&gt;<br>&gt;<br>&gt; Extensions are not first-class entities and have no visibility of their<br>&gt; own.<br>&gt;<br>&gt;<br>&gt; I didn’t express that very well. Let me clarify what I mean:<br>&gt;<br>&gt; internal struct S {}<br>&gt;<br>&gt; private protocol P {<br>&gt;     func foo()<br>&gt; }<br>&gt;<br>&gt; extension S: P {<br>&gt;     func foo() {}<br>&gt; }<br>&gt;<br>&gt; - - - choose “Generated Interface” and you get: - - -<br>&gt;<br>&gt; internal struct S {<br>&gt; }<br>&gt;<br>&gt;<br>&gt; extension S {<br>&gt;<br>&gt;     internal func foo()<br>&gt; }<br>&gt;<br>&gt; - - -<br>&gt;<br>&gt; While the extension is visible, the fact that it adds conformance to P is<br>&gt; not. Therefore, as far as code outside this file is concerned, there is no<br>&gt; conformance to P.<br>&gt;<br></p><p>That&#39;s correct, but why should the compiler accept the code in this file,<br>when both S and P are visible, and S is not overriding default<br>implementations in P as it should?<br></p><p>&gt;<br>&gt; In any case, you have not solved the problem, which has nothing to do with<br>&gt; whether something is &quot;reasonable to know&quot;: when a default implementation A<br>&gt; is overridden by implementation B, implementation A may be visible only in<br>&gt; a *more restricted* access scope than implementation B. (This is not the<br>&gt; case with overriding superclass members in subclasses.) It can be perfectly<br>&gt; &quot;reasonable to know&quot; about both A and B, but there is still no way you can<br>&gt; indicate this knowledge by appending a keyword to the declaration for<br>&gt; implementation B if the access scope for implementation A is unutterable<br>&gt; where B is declared.<br>&gt;<br>&gt;<br>&gt; Could you provide an example of code where this would present a problem?<br>&gt;<br></p><p>I&#39;m still talking about the same example. How do you rationalize your<br>statement that no keyword is needed because it&#39;s not &quot;reasonable to know&quot;<br>about both S and P when compiling the file in which P is declared?<br></p><p><br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/b477d002/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 26, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Aug 26, 2016, at 2:34 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; internal struct S {}<br>&gt; <br>&gt; private protocol P {<br>&gt;     func foo()<br>&gt; }<br>&gt; <br>&gt; extension S: P {<br>&gt;     func foo() {}<br>&gt; }<br>&gt; <br>&gt; - - - choose “Generated Interface” and you get: - - -<br>&gt; <br>&gt; internal struct S {<br>&gt; }<br>&gt; <br>&gt; <br>&gt; extension S {<br>&gt; <br>&gt;     internal func foo()<br>&gt; }<br>&gt; <br>&gt; - - -<br>&gt; <br>&gt; While the extension is visible, the fact that it adds conformance to P is not. Therefore, as far as code outside this file is concerned, there is no conformance to P.<br>&gt;  <br>&gt; That&#39;s correct, but why should the compiler accept the code in this file, when both S and P are visible, and S is not overriding default implementations in P as it should? <br></p><p>I am confused. Why should S, above, be required to override P’s default implementation of foo()?<br></p><p>&gt; <br>&gt;&gt; In any case, you have not solved the problem, which has nothing to do with whether something is &quot;reasonable to know&quot;: when a default implementation A is overridden by implementation B, implementation A may be visible only in a *more restricted* access scope than implementation B. (This is not the case with overriding superclass members in subclasses.) It can be perfectly &quot;reasonable to know&quot; about both A and B, but there is still no way you can indicate this knowledge by appending a keyword to the declaration for implementation B if the access scope for implementation A is unutterable where B is declared.<br>&gt; <br>&gt; <br>&gt; Could you provide an example of code where this would present a problem?<br>&gt; <br>&gt; I&#39;m still talking about the same example. How do you rationalize your statement that no keyword is needed because it&#39;s not &quot;reasonable to know&quot; about both S and P when compiling the file in which P is declared?<br></p><p>When compiling the file in which P is declared, you would add the keyword. Code outside this file that happened to define methods named foo() would not, since they would not be consciously conforming to the protocol.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/2bd0cc52/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 26, 2016 at 02:00:00pm</p></header><div class="content"><p>On Fri, Aug 26, 2016 at 2:42 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 26, 2016, at 2:34 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; internal struct S {}<br>&gt;&gt;<br>&gt;&gt; private protocol P {<br>&gt;&gt;     func foo()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension S: P {<br>&gt;&gt;     func foo() {}<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; - - - choose “Generated Interface” and you get: - - -<br>&gt;&gt;<br>&gt;&gt; internal struct S {<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; extension S {<br>&gt;&gt;<br>&gt;&gt;     internal func foo()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; - - -<br>&gt;&gt;<br>&gt;&gt; While the extension is visible, the fact that it adds conformance to P is<br>&gt;&gt; not. Therefore, as far as code outside this file is concerned, there is no<br>&gt;&gt; conformance to P.<br>&gt;&gt;<br>&gt;<br>&gt; That&#39;s correct, but why should the compiler accept the code in this file,<br>&gt; when both S and P are visible, and S is not overriding default<br>&gt; implementations in P as it should?<br>&gt;<br>&gt;<br>&gt; I am confused. Why should S, above, be required to override P’s default<br>&gt; implementation of foo()?<br>&gt;<br></p><p>Sorry, I was referring to my original example: S is in a different file<br>from P and has its own implementation of foo(), and P has its own default<br>implementation of foo(). I assumed you simplified the example above to<br>discuss the generated interface. I didn&#39;t realize you were moving on to a<br>different example.<br></p><p><br>&gt;&gt; In any case, you have not solved the problem, which has nothing to do<br>&gt;&gt; with whether something is &quot;reasonable to know&quot;: when a default<br>&gt;&gt; implementation A is overridden by implementation B, implementation A may be<br>&gt;&gt; visible only in a *more restricted* access scope than implementation B.<br>&gt;&gt; (This is not the case with overriding superclass members in subclasses.) It<br>&gt;&gt; can be perfectly &quot;reasonable to know&quot; about both A and B, but there is<br>&gt;&gt; still no way you can indicate this knowledge by appending a keyword to the<br>&gt;&gt; declaration for implementation B if the access scope for implementation A<br>&gt;&gt; is unutterable where B is declared.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Could you provide an example of code where this would present a problem?<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;m still talking about the same example. How do you rationalize your<br>&gt; statement that no keyword is needed because it&#39;s not &quot;reasonable to know&quot;<br>&gt; about both S and P when compiling the file in which P is declared?<br>&gt;<br>&gt;<br>&gt; When compiling the file in which P is declared, you would add the keyword.<br>&gt; Code outside this file that happened to define methods named foo() would<br>&gt; not, since they would not be consciously conforming to the protocol.<br>&gt;<br></p><p>What keyword could you add to P, when the overriding member is in S?<br></p><p>File A:<br>```<br>internal struct S {<br>  func foo() { }<br>}<br>```<br></p><p>File B:<br>```<br>private protocol P {<br>  func foo()<br>}<br></p><p>extension P {<br>  func foo() { }<br>}<br></p><p>extension S : P { }<br>```<br></p><p>Where do I append your proposed keyword? Or, how do you rationalize its not<br>being required on the basis of &quot;reasonable to know&quot;?<br></p><p>Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/d897ea0a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 26, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Aug 26, 2016, at 2:49 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Sorry, I was referring to my original example: S is in a different file from P and has its own implementation of foo(), and P has its own default implementation of foo(). I assumed you simplified the example above to discuss the generated interface. I didn&#39;t realize you were moving on to a different example.<br></p><p>You are correct; it was a simplified example to discuss the generated interface. I was confused by your objection’s proximity to it; sorry for the noise.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; In any case, you have not solved the problem, which has nothing to do with whether something is &quot;reasonable to know&quot;: when a default implementation A is overridden by implementation B, implementation A may be visible only in a *more restricted* access scope than implementation B. (This is not the case with overriding superclass members in subclasses.) It can be perfectly &quot;reasonable to know&quot; about both A and B, but there is still no way you can indicate this knowledge by appending a keyword to the declaration for implementation B if the access scope for implementation A is unutterable where B is declared.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Could you provide an example of code where this would present a problem?<br>&gt;&gt; <br>&gt;&gt; I&#39;m still talking about the same example. How do you rationalize your statement that no keyword is needed because it&#39;s not &quot;reasonable to know&quot; about both S and P when compiling the file in which P is declared?<br>&gt; <br>&gt; When compiling the file in which P is declared, you would add the keyword. Code outside this file that happened to define methods named foo() would not, since they would not be consciously conforming to the protocol.<br>&gt; <br>&gt; What keyword could you add to P, when the overriding member is in S?<br>&gt; <br>&gt; File A:<br>&gt; ```<br>&gt; internal struct S {<br>&gt;   func foo() { }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; File B:<br>&gt; ```<br>&gt; private protocol P {<br>&gt;   func foo()<br>&gt; }<br>&gt; <br>&gt; extension P {<br>&gt;   func foo() { }<br>&gt; }<br>&gt; <br>&gt; extension S : P { }<br>&gt; ```<br>&gt; <br>&gt; Where do I append your proposed keyword? Or, how do you rationalize its not being required on the basis of &quot;reasonable to know&quot;?<br></p><p>File A does not need the keyword, since it is not implementing P by adding foo() and cannot be expected to know about it, and thus it’s rather arguable to say that it is “overriding” anything. The extension that conforms S to P declares no methods, so it is clear that this is meant to be retroactively conforming, so I am not convinced a keyword is needed here. However, there is room for debate here, and if we determined that a keyword should be required, then I would say it should go in the extension that conforms S to P, since that is where the “problem” occurs.<br></p><p>If S had been declared in File B, however, there would be a keyword attached to its declaration of foo(), since the information that S conforms to P, as well as the fact that foo() is a requirement of said protocol, would all be visible in the current scope.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/ab5b6787/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 26, 2016 at 03:00:00pm</p></header><div class="content"><p>On Fri, Aug 26, 2016 at 2:57 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 26, 2016, at 2:49 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Sorry, I was referring to my original example: S is in a different file<br>&gt; from P and has its own implementation of foo(), and P has its own default<br>&gt; implementation of foo(). I assumed you simplified the example above to<br>&gt; discuss the generated interface. I didn&#39;t realize you were moving on to a<br>&gt; different example.<br>&gt;<br>&gt;<br>&gt; You are correct; it was a simplified example to discuss the generated<br>&gt; interface. I was confused by your objection’s proximity to it; sorry for<br>&gt; the noise.<br>&gt;<br>&gt;<br>&gt;&gt;&gt; In any case, you have not solved the problem, which has nothing to do<br>&gt;&gt;&gt; with whether something is &quot;reasonable to know&quot;: when a default<br>&gt;&gt;&gt; implementation A is overridden by implementation B, implementation A may be<br>&gt;&gt;&gt; visible only in a *more restricted* access scope than implementation B.<br>&gt;&gt;&gt; (This is not the case with overriding superclass members in subclasses.) It<br>&gt;&gt;&gt; can be perfectly &quot;reasonable to know&quot; about both A and B, but there is<br>&gt;&gt;&gt; still no way you can indicate this knowledge by appending a keyword to the<br>&gt;&gt;&gt; declaration for implementation B if the access scope for implementation A<br>&gt;&gt;&gt; is unutterable where B is declared.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Could you provide an example of code where this would present a problem?<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;m still talking about the same example. How do you rationalize your<br>&gt;&gt; statement that no keyword is needed because it&#39;s not &quot;reasonable to know&quot;<br>&gt;&gt; about both S and P when compiling the file in which P is declared?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; When compiling the file in which P is declared, you would add the<br>&gt;&gt; keyword. Code outside this file that happened to define methods named foo()<br>&gt;&gt; would not, since they would not be consciously conforming to the protocol.<br>&gt;&gt;<br>&gt;<br>&gt; What keyword could you add to P, when the overriding member is in S?<br>&gt;<br>&gt; File A:<br>&gt; ```<br>&gt; internal struct S {<br>&gt;   func foo() { }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; File B:<br>&gt; ```<br>&gt; private protocol P {<br>&gt;   func foo()<br>&gt; }<br>&gt;<br>&gt; extension P {<br>&gt;   func foo() { }<br>&gt; }<br>&gt;<br>&gt; extension S : P { }<br>&gt; ```<br>&gt;<br>&gt; Where do I append your proposed keyword? Or, how do you rationalize its<br>&gt; not being required on the basis of &quot;reasonable to know&quot;?<br>&gt;<br>&gt;<br>&gt; File A does not need the keyword, since it is not implementing P by adding<br>&gt; foo() and cannot be expected to know about it, and thus it’s rather<br>&gt; arguable to say that it is “overriding” anything. The extension that<br>&gt; conforms S to P declares no methods, so it is clear that this is meant to<br>&gt; be retroactively conforming, so I am not convinced a keyword is needed<br>&gt; here. However, there is room for debate here, and if we determined that a<br>&gt; keyword should be required, then I would say it should go in the extension<br>&gt; that conforms S to P, since that is where the “problem” occurs.<br>&gt;<br>&gt; If S had been declared in File B, however, there would be a keyword<br>&gt; attached to its declaration of foo(), since the information that S conforms<br>&gt; to P, as well as the fact that foo() is a requirement of said protocol,<br>&gt; would all be visible in the current scope.<br>&gt;<br></p><p>Why? S.foo() is visible throughout the module, but outside this file,<br>S.foo() doesn&#39;t override anything. Why should it be marked as an `override`<br>when, as you say, the generated interface shows no sign of conformance to P?<br>In addition, how would you justify a requirement to fiddle with these<br>keywords when someone simply refactors an internally visible type with no<br>private members from one file to another? Your proposed rule just broke<br>copy-and-paste...<br></p><p><br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/264050c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 26, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Aug 26, 2016, at 3:02 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Aug 26, 2016 at 2:57 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; On Aug 26, 2016, at 2:49 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Sorry, I was referring to my original example: S is in a different file from P and has its own implementation of foo(), and P has its own default implementation of foo(). I assumed you simplified the example above to discuss the generated interface. I didn&#39;t realize you were moving on to a different example.<br>&gt; <br>&gt; You are correct; it was a simplified example to discuss the generated interface. I was confused by your objection’s proximity to it; sorry for the noise.<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In any case, you have not solved the problem, which has nothing to do with whether something is &quot;reasonable to know&quot;: when a default implementation A is overridden by implementation B, implementation A may be visible only in a *more restricted* access scope than implementation B. (This is not the case with overriding superclass members in subclasses.) It can be perfectly &quot;reasonable to know&quot; about both A and B, but there is still no way you can indicate this knowledge by appending a keyword to the declaration for implementation B if the access scope for implementation A is unutterable where B is declared.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Could you provide an example of code where this would present a problem?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m still talking about the same example. How do you rationalize your statement that no keyword is needed because it&#39;s not &quot;reasonable to know&quot; about both S and P when compiling the file in which P is declared?<br>&gt;&gt; <br>&gt;&gt; When compiling the file in which P is declared, you would add the keyword. Code outside this file that happened to define methods named foo() would not, since they would not be consciously conforming to the protocol.<br>&gt;&gt; <br>&gt;&gt; What keyword could you add to P, when the overriding member is in S?<br>&gt;&gt; <br>&gt;&gt; File A:<br>&gt;&gt; ```<br>&gt;&gt; internal struct S {<br>&gt;&gt;   func foo() { }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; File B:<br>&gt;&gt; ```<br>&gt;&gt; private protocol P {<br>&gt;&gt;   func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt;   func foo() { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension S : P { }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Where do I append your proposed keyword? Or, how do you rationalize its not being required on the basis of &quot;reasonable to know&quot;?<br>&gt; <br>&gt; File A does not need the keyword, since it is not implementing P by adding foo() and cannot be expected to know about it, and thus it’s rather arguable to say that it is “overriding” anything. The extension that conforms S to P declares no methods, so it is clear that this is meant to be retroactively conforming, so I am not convinced a keyword is needed here. However, there is room for debate here, and if we determined that a keyword should be required, then I would say it should go in the extension that conforms S to P, since that is where the “problem” occurs.<br>&gt; <br>&gt; If S had been declared in File B, however, there would be a keyword attached to its declaration of foo(), since the information that S conforms to P, as well as the fact that foo() is a requirement of said protocol, would all be visible in the current scope.<br>&gt; <br>&gt; Why? S.foo() is visible throughout the module, but outside this file, S.foo() doesn&#39;t override anything. Why should it be marked as an `override` when, as you say, the generated interface shows no sign of conformance to P?<br>&gt; In addition, how would you justify a requirement to fiddle with these keywords when someone simply refactors an internally visible type with no private members from one file to another? Your proposed rule just broke copy-and-paste...<br></p><p><br>Because it indicates the programmer’s *intent.* If the protocol is visible at the time you’re writing the declaration for S.foo(), then you should have to tell the compiler what you mean by that and what you’re doing with it.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/9f580268/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 26, 2016 at 03:00:00pm</p></header><div class="content"><p>On Fri, Aug 26, 2016 at 3:10 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 26, 2016, at 3:02 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Fri, Aug 26, 2016 at 2:57 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt;  wrote:<br>&gt;<br>&gt;&gt; On Aug 26, 2016, at 2:49 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sorry, I was referring to my original example: S is in a different file<br>&gt;&gt; from P and has its own implementation of foo(), and P has its own default<br>&gt;&gt; implementation of foo(). I assumed you simplified the example above to<br>&gt;&gt; discuss the generated interface. I didn&#39;t realize you were moving on to a<br>&gt;&gt; different example.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You are correct; it was a simplified example to discuss the generated<br>&gt;&gt; interface. I was confused by your objection’s proximity to it; sorry for<br>&gt;&gt; the noise.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;&gt; In any case, you have not solved the problem, which has nothing to do<br>&gt;&gt;&gt;&gt; with whether something is &quot;reasonable to know&quot;: when a default<br>&gt;&gt;&gt;&gt; implementation A is overridden by implementation B, implementation A may be<br>&gt;&gt;&gt;&gt; visible only in a *more restricted* access scope than implementation B.<br>&gt;&gt;&gt;&gt; (This is not the case with overriding superclass members in subclasses.) It<br>&gt;&gt;&gt;&gt; can be perfectly &quot;reasonable to know&quot; about both A and B, but there is<br>&gt;&gt;&gt;&gt; still no way you can indicate this knowledge by appending a keyword to the<br>&gt;&gt;&gt;&gt; declaration for implementation B if the access scope for implementation A<br>&gt;&gt;&gt;&gt; is unutterable where B is declared.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Could you provide an example of code where this would present a problem?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m still talking about the same example. How do you rationalize your<br>&gt;&gt;&gt; statement that no keyword is needed because it&#39;s not &quot;reasonable to know&quot;<br>&gt;&gt;&gt; about both S and P when compiling the file in which P is declared?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When compiling the file in which P is declared, you would add the<br>&gt;&gt;&gt; keyword. Code outside this file that happened to define methods named foo()<br>&gt;&gt;&gt; would not, since they would not be consciously conforming to the protocol.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; What keyword could you add to P, when the overriding member is in S?<br>&gt;&gt;<br>&gt;&gt; File A:<br>&gt;&gt; ```<br>&gt;&gt; internal struct S {<br>&gt;&gt;   func foo() { }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; File B:<br>&gt;&gt; ```<br>&gt;&gt; private protocol P {<br>&gt;&gt;   func foo()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension P {<br>&gt;&gt;   func foo() { }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension S : P { }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; Where do I append your proposed keyword? Or, how do you rationalize its<br>&gt;&gt; not being required on the basis of &quot;reasonable to know&quot;?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; File A does not need the keyword, since it is not implementing P by<br>&gt;&gt; adding foo() and cannot be expected to know about it, and thus it’s rather<br>&gt;&gt; arguable to say that it is “overriding” anything. The extension that<br>&gt;&gt; conforms S to P declares no methods, so it is clear that this is meant to<br>&gt;&gt; be retroactively conforming, so I am not convinced a keyword is needed<br>&gt;&gt; here. However, there is room for debate here, and if we determined that a<br>&gt;&gt; keyword should be required, then I would say it should go in the extension<br>&gt;&gt; that conforms S to P, since that is where the “problem” occurs.<br>&gt;&gt;<br>&gt;&gt; If S had been declared in File B, however, there would be a keyword<br>&gt;&gt; attached to its declaration of foo(), since the information that S conforms<br>&gt;&gt; to P, as well as the fact that foo() is a requirement of said protocol,<br>&gt;&gt; would all be visible in the current scope.<br>&gt;&gt;<br>&gt;<br>&gt; Why? S.foo() is visible throughout the module, but outside this file,<br>&gt; S.foo() doesn&#39;t override anything. Why should it be marked as an `override`<br>&gt; when, as you say, the generated interface shows no sign of conformance to P?<br>&gt; In addition, how would you justify a requirement to fiddle with these<br>&gt; keywords when someone simply refactors an internally visible type with no<br>&gt; private members from one file to another? Your proposed rule just broke<br>&gt; copy-and-paste...<br>&gt;<br>&gt;<br>&gt; Because it indicates the programmer’s *intent.* If the protocol is visible<br>&gt; at the time you’re writing the declaration for S.foo(), then you should<br>&gt; have to tell the compiler what you mean by that and what you’re doing with<br>&gt; it.<br>&gt;<br></p><p>Where a type is located in relation to a protocol is a poor proxy for<br>whether one was written _before_ the other. And while the writer&#39;s most<br>likely intent might differ depending on the order in which two things are<br>written, how one declares members on a type should not be determined by a<br>set of arbitrary rules for the compiler to guess whether the type or<br>protocol was written first. This kind of functionality, if you want it,<br>might be appropriate for a linter. It could probably even look at last<br>modified dates, or with a git repo, go line by line to see when each piece<br>of the code was written.<br></p><p><br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/87d81dde/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 26, 2016 at 02:00:00pm</p></header><div class="content"><p>On Fri, Aug 26, 2016 at 1:45 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; On Fri, Aug 26, 2016 at 1:27 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Aug 26, 2016, at 11:02 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Really? I wasn&#39;t aware that you could work around the `override` keyword<br>&gt;&gt; (the one that&#39;s required for classes). How do you do that?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; By implementing the subclass’s method before the superclass’s. You can<br>&gt;&gt; try this yourself:<br>&gt;&gt;<br>&gt;&gt; - - - Library code: - - -<br>&gt;&gt;<br>&gt;&gt; open class Superclass {<br>&gt;&gt;     public init() {}<br>&gt;&gt;     public func foo() {<br>&gt;&gt;         print(&quot;foo called in library&quot;)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; - - - App code: - - -<br>&gt;&gt;<br>&gt;&gt; import FooLibrary<br>&gt;&gt;<br>&gt;&gt; class Subclass: Superclass {<br>&gt;&gt;     func bar() { print(&quot;bar called in the app&quot;) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let obj = Subclass()<br>&gt;&gt;<br>&gt;&gt; obj.foo()<br>&gt;&gt;<br>&gt;&gt; - - - output: - - -<br>&gt;&gt;<br>&gt;&gt; *foo called in library*<br>&gt;&gt; *Program ended with exit code: 0*<br>&gt;&gt;<br>&gt;&gt; - - - - - -<br>&gt;&gt;<br>&gt;&gt; Now: Change the library code to:<br>&gt;&gt;<br>&gt;&gt; open class Superclass {<br>&gt;&gt;     public init() {}<br>&gt;&gt;     public func foo() {<br>&gt;&gt;         print(&quot;foo called in library&quot;)<br>&gt;&gt;         bar()<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     // Hey look, I didn&#39;t even use that stupid new &#39;open&#39; keyword.<br>&gt;&gt;     public func bar() { print(&quot;bar called in library&quot;) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; - - - Run the app again without compiling it, and: - - -<br>&gt;&gt;<br>&gt;&gt; *foo called in library*<br>&gt;&gt; *bar called in the app*<br>&gt;&gt; *Program ended with exit code: 0*<br>&gt;&gt;<br>&gt;&gt; - - -<br>&gt;&gt;<br>&gt;&gt; Voilà: I overrode a method (a supposedly non-overridable one, at that)<br>&gt;&gt; with no “override” keyword.<br>&gt;&gt;<br>&gt;<br>&gt; This is clearly a bug in the implementation, not part of the design.<br>&gt; Expect it to be fixed as the code for `open` matures. It&#39;s certainly not a<br>&gt; precedent to be emulated for designing another feature.<br>&gt;<br></p><p>I misread your example. You have to run the app *without compiling*; your<br>two versions of the library have a compatible ABI. The Swift compiler won&#39;t<br>compile your app code, so how&#39;s that an example of &quot;working around&quot;<br>anything in the language?<br></p><p>Just as File A in your earlier example can implement a protocol method<br>&gt;&gt; without realizing it, Subclass here has unintentionally overridden a<br>&gt;&gt; superclass method. This is because ‘override’ does not, to the best of my<br>&gt;&gt; knowledge, mean anything to the actual machine code that is produced;<br>&gt;&gt; rather, it signals the developer’s *intent,* thus allowing the compiler to<br>&gt;&gt; assist in making sure the developer does the right thing.<br>&gt;&gt;<br>&gt;&gt; I’d actually argue that the example above is a much, much bigger problem<br>&gt;&gt; than the objection you raised, as it can actually produce unintended<br>&gt;&gt; behavior at runtime, whereas the example with protocols can’t.<br>&gt;&gt;<br>&gt;&gt; As for the protocol example, I’d like to refine Option 3 from last night<br>&gt;&gt; slightly:<br>&gt;&gt;<br>&gt;&gt; Option 4: A keyword is required on a method declaration if and only if<br>&gt;&gt; the containing type is declared as conforming to its protocol, either in<br>&gt;&gt; its definition or in an extension that is visible within the current scope.<br>&gt;&gt;<br>&gt;<br>&gt; Extensions are not first-class entities and have no visibility of their<br>&gt; own. In any case, you have not solved the problem, which has nothing to do<br>&gt; with whether something is &quot;reasonable to know&quot;: when a default<br>&gt; implementation A is overridden by implementation B, implementation A may be<br>&gt; visible only in a *more restricted* access scope than implementation B.<br>&gt; (This is not the case with overriding superclass members in subclasses.) It<br>&gt; can be perfectly &quot;reasonable to know&quot; about both A and B, but there is<br>&gt; still no way you can indicate this knowledge by appending a keyword to the<br>&gt; declaration for implementation B if the access scope for implementation A<br>&gt; is unutterable where B is declared.<br>&gt;<br>&gt;<br>&gt;&gt; This allows the extension to remain empty in your example, but puts the<br>&gt;&gt; responsibility on the developer to declare conforming methods when it is<br>&gt;&gt; reasonable to know that they will satisfy a protocol.<br>&gt;&gt;<br>&gt;&gt; Charles<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/19ef1d55/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 26, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Aug 26, 2016, at 2:29 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; I misread your example. You have to run the app *without compiling*; your two versions of the library have a compatible ABI. The Swift compiler won&#39;t compile your app code, so how&#39;s that an example of &quot;working around&quot; anything in the language?<br></p><p>It is an example of an override occurring without the “override” keyword, and a demonstration that the “override” keyword’s purpose is to indicate programmer intent rather than do anything to the actual generated machine code (otherwise, the override here wouldn’t have happened). Despite this, no one argues against the existence of the “override” keyword.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/83d04d2e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 26, 2016 at 02:00:00pm</p></header><div class="content"><p>On Fri, Aug 26, 2016 at 2:34 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 26, 2016, at 2:29 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; I misread your example. You have to run the app *without compiling*; your<br>&gt; two versions of the library have a compatible ABI. The Swift compiler won&#39;t<br>&gt; compile your app code, so how&#39;s that an example of &quot;working around&quot;<br>&gt; anything in the language?<br>&gt;<br>&gt;<br>&gt; It is an example of an override occurring without the “override” keyword,<br>&gt; and a demonstration that the “override” keyword’s purpose is to indicate<br>&gt; programmer intent rather than do anything to the actual generated machine<br>&gt; code (otherwise, the override here wouldn’t have happened). Despite this,<br>&gt; no one argues against the existence of the “override” keyword.<br>&gt;<br></p><p>This is not an example of that at all. You can&#39;t get the Swift compiler to<br>compile the code. Failure to use `override` is a compile-time error, and<br>compile-time errors don&#39;t happen at runtime. Why are we talking about<br>&#39;generated machine code&#39;?<br></p><p><br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/d7592963/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 26, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Aug 26, 2016, at 2:38 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Aug 26, 2016 at 2:34 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; On Aug 26, 2016, at 2:29 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I misread your example. You have to run the app *without compiling*; your two versions of the library have a compatible ABI. The Swift compiler won&#39;t compile your app code, so how&#39;s that an example of &quot;working around&quot; anything in the language?<br>&gt; <br>&gt; It is an example of an override occurring without the “override” keyword, and a demonstration that the “override” keyword’s purpose is to indicate programmer intent rather than do anything to the actual generated machine code (otherwise, the override here wouldn’t have happened). Despite this, no one argues against the existence of the “override” keyword.<br>&gt; <br>&gt; This is not an example of that at all. You can&#39;t get the Swift compiler to compile the code. Failure to use `override` is a compile-time error, and compile-time errors don&#39;t happen at runtime. Why are we talking about &#39;generated machine code&#39;?<br></p><p>Exactly; compile-time errors are intended to enforce correct behavior on the part of the developer. Your objection, as I understand it, is that a type that declares a method, which another file retroactively conforms to a private protocol that the original type can’t see, can’t indicate conformance in its original declaration, and that this would, in some way, cause a practical problem. I am failing to see what the problem is: the keywords, if properly designed, can allow all parties to be clear as to what they mean and catch any mistakes involved in doing so, which is all we need here. Once compiled, everything will behave identically to how it behaves today.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/45298ac7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 26, 2016 at 02:00:00pm</p></header><div class="content"><p>On Fri, Aug 26, 2016 at 2:48 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 26, 2016, at 2:38 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Fri, Aug 26, 2016 at 2:34 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt;  wrote:<br>&gt;<br>&gt;&gt; On Aug 26, 2016, at 2:29 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I misread your example. You have to run the app *without compiling*; your<br>&gt;&gt; two versions of the library have a compatible ABI. The Swift compiler won&#39;t<br>&gt;&gt; compile your app code, so how&#39;s that an example of &quot;working around&quot;<br>&gt;&gt; anything in the language?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It is an example of an override occurring without the “override” keyword,<br>&gt;&gt; and a demonstration that the “override” keyword’s purpose is to indicate<br>&gt;&gt; programmer intent rather than do anything to the actual generated machine<br>&gt;&gt; code (otherwise, the override here wouldn’t have happened). Despite this,<br>&gt;&gt; no one argues against the existence of the “override” keyword.<br>&gt;&gt;<br>&gt;<br>&gt; This is not an example of that at all. You can&#39;t get the Swift compiler to<br>&gt; compile the code. Failure to use `override` is a compile-time error, and<br>&gt; compile-time errors don&#39;t happen at runtime. Why are we talking about<br>&gt; &#39;generated machine code&#39;?<br>&gt;<br>&gt;<br>&gt; Exactly; compile-time errors are intended to enforce correct behavior on<br>&gt; the part of the developer. Your objection, as I understand it, is that a<br>&gt; type that declares a method, which another file retroactively conforms to a<br>&gt; private protocol that the original type can’t see, can’t indicate<br>&gt; conformance in its original declaration, and that this would, in some way,<br>&gt; cause a practical problem. I am failing to see what the problem is:<br>&gt;<br></p><p>We were discussing your option (3), which would mean that trivial<br>refactoring would lead to a lack of compile-time errors even if no one ever<br>used your proposed keyword, effectively making the keyword optional. You<br>wrote: &#39;I can work around the “override” keyword and override things<br>without it, but that doesn’t mean that I think we should remove the<br>“override” keyword.&#39; This was surprising to me, because if it were possible<br>to avoid using `override` without a compile-time error, I would indeed<br>argue that we should remove the `override` keyword. However, you gave an<br>example where *not compiling* means you don&#39;t get a *compile-time error*,<br>which is not a workaround at all.<br></p><p><br>&gt; the keywords, if properly designed, can allow all parties to be clear as<br>&gt; to what they mean and catch any mistakes involved in doing so, which is all<br>&gt; we need here. Once compiled, everything will behave identically to how it<br>&gt; behaves today.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/717dc657/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 26, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Aug 26, 2016, at 2:58 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Aug 26, 2016 at 2:48 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; On Aug 26, 2016, at 2:38 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Fri, Aug 26, 2016 at 2:34 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Aug 26, 2016, at 2:29 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I misread your example. You have to run the app *without compiling*; your two versions of the library have a compatible ABI. The Swift compiler won&#39;t compile your app code, so how&#39;s that an example of &quot;working around&quot; anything in the language?<br>&gt;&gt; <br>&gt;&gt; It is an example of an override occurring without the “override” keyword, and a demonstration that the “override” keyword’s purpose is to indicate programmer intent rather than do anything to the actual generated machine code (otherwise, the override here wouldn’t have happened). Despite this, no one argues against the existence of the “override” keyword.<br>&gt;&gt; <br>&gt;&gt; This is not an example of that at all. You can&#39;t get the Swift compiler to compile the code. Failure to use `override` is a compile-time error, and compile-time errors don&#39;t happen at runtime. Why are we talking about &#39;generated machine code&#39;?<br>&gt; <br>&gt; Exactly; compile-time errors are intended to enforce correct behavior on the part of the developer. Your objection, as I understand it, is that a type that declares a method, which another file retroactively conforms to a private protocol that the original type can’t see, can’t indicate conformance in its original declaration, and that this would, in some way, cause a practical problem. I am failing to see what the problem is:<br>&gt; <br>&gt; We were discussing your option (3), which would mean that trivial refactoring would lead to a lack of compile-time errors even if no one ever used your proposed keyword, effectively making the keyword optional. You wrote: &#39;I can work around the “override” keyword and override things without it, but that doesn’t mean that I think we should remove the “override” keyword.&#39; This was surprising to me, because if it were possible to avoid using `override` without a compile-time error, I would indeed argue that we should remove the `override` keyword. However, you gave an example where *not compiling* means you don&#39;t get a *compile-time error*, which is not a workaround at all.<br></p><p>We were talking about retroactive modeling, and the effects that adding things after the fact can have on previously-existing code. This was, I think, a pretty close analogue for classes. The original app compiles, the library compiles, the refactored library compiles.<br></p><p>If you want it all to compile at the same time, well, we’ve still got access to all the Objective-C runtime functions in Swift. One can also write the assembly by hand. Things like “override” aren’t security features; they’re there to help you do the right thing. If you’re deliberately trying to do the wrong thing, I don’t think that can strictly be prevented.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/682c487e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 26, 2016 at 03:00:00pm</p></header><div class="content"><p>On Fri, Aug 26, 2016 at 3:09 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 26, 2016, at 2:58 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Fri, Aug 26, 2016 at 2:48 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt;  wrote:<br>&gt;<br>&gt;&gt; On Aug 26, 2016, at 2:38 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Fri, Aug 26, 2016 at 2:34 PM, Charles Srstka &lt;cocoadev at charlessoft.com<br>&gt;&gt; &gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Aug 26, 2016, at 2:29 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I misread your example. You have to run the app *without compiling*;<br>&gt;&gt;&gt; your two versions of the library have a compatible ABI. The Swift compiler<br>&gt;&gt;&gt; won&#39;t compile your app code, so how&#39;s that an example of &quot;working around&quot;<br>&gt;&gt;&gt; anything in the language?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It is an example of an override occurring without the “override”<br>&gt;&gt;&gt; keyword, and a demonstration that the “override” keyword’s purpose is to<br>&gt;&gt;&gt; indicate programmer intent rather than do anything to the actual generated<br>&gt;&gt;&gt; machine code (otherwise, the override here wouldn’t have happened). Despite<br>&gt;&gt;&gt; this, no one argues against the existence of the “override” keyword.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This is not an example of that at all. You can&#39;t get the Swift compiler<br>&gt;&gt; to compile the code. Failure to use `override` is a compile-time error, and<br>&gt;&gt; compile-time errors don&#39;t happen at runtime. Why are we talking about<br>&gt;&gt; &#39;generated machine code&#39;?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Exactly; compile-time errors are intended to enforce correct behavior on<br>&gt;&gt; the part of the developer. Your objection, as I understand it, is that a<br>&gt;&gt; type that declares a method, which another file retroactively conforms to a<br>&gt;&gt; private protocol that the original type can’t see, can’t indicate<br>&gt;&gt; conformance in its original declaration, and that this would, in some way,<br>&gt;&gt; cause a practical problem. I am failing to see what the problem is:<br>&gt;&gt;<br>&gt;<br>&gt; We were discussing your option (3), which would mean that trivial<br>&gt; refactoring would lead to a lack of compile-time errors even if no one ever<br>&gt; used your proposed keyword, effectively making the keyword optional. You<br>&gt; wrote: &#39;I can work around the “override” keyword and override things<br>&gt; without it, but that doesn’t mean that I think we should remove the<br>&gt; “override” keyword.&#39; This was surprising to me, because if it were possible<br>&gt; to avoid using `override` without a compile-time error, I would indeed<br>&gt; argue that we should remove the `override` keyword. However, you gave an<br>&gt; example where *not compiling* means you don&#39;t get a *compile-time error*,<br>&gt; which is not a workaround at all.<br>&gt;<br>&gt;<br>&gt; We were talking about retroactive modeling, and the effects that adding<br>&gt; things after the fact can have on previously-existing code. This was, I<br>&gt; think, a pretty close analogue for classes. The original app compiles, the<br>&gt; library compiles, the refactored library compiles.<br>&gt;<br></p><p>We were talking about language design and rules to be enforced at compile<br>time; there is simply no analog here because your example was about the<br>runtime behavior of apps that call into libraries.<br></p><p>If you want it all to compile at the same time, well, we’ve still got<br>&gt; access to all the Objective-C runtime functions in Swift. One can also<br>&gt; write the assembly by hand. Things like “override” aren’t security<br>&gt; features; they’re there to help you do the right thing. If you’re<br>&gt; deliberately trying to do the wrong thing, I don’t think that can strictly<br>&gt; be prevented.<br>&gt;<br></p><p>The current syntax is not the &quot;wrong thing&quot;--and a future language feature<br>shouldn&#39;t leave a loophole where someone can choose either one or another<br>totally different set of rules for conforming a type to a protocol; there<br>should be one syntax for doing that in Swift.<br></p><p><br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/4f97195b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 26, 2016 at 03:00:00pm</p></header><div class="content"><p>On Aug 26, 2016, at 3:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt;&gt; Why? S.foo() is visible throughout the module, but outside this file, S.foo() doesn&#39;t override anything. Why should it be marked as an `override` when, as you say, the generated interface shows no sign of conformance to P?<br>&gt;&gt; In addition, how would you justify a requirement to fiddle with these keywords when someone simply refactors an internally visible type with no private members from one file to another? Your proposed rule just broke copy-and-paste...<br>&gt; <br>&gt; <br>&gt; Because it indicates the programmer’s *intent.* If the protocol is visible at the time you’re writing the declaration for S.foo(), then you should have to tell the compiler what you mean by that and what you’re doing with it.<br>&gt; <br>&gt; Where a type is located in relation to a protocol is a poor proxy for whether one was written _before_ the other. And while the writer&#39;s most likely intent might differ depending on the order in which two things are written, how one declares members on a type should not be determined by a set of arbitrary rules for the compiler to guess whether the type or protocol was written first. This kind of functionality, if you want it, might be appropriate for a linter. It could probably even look at last modified dates, or with a git repo, go line by line to see when each piece of the code was written.<br></p><p>Why should it matter when the programmer wrote it? One is the declaration, the other is an add-on to it. Conceptually, the type is constructed first, and then things are bolted on (and in Objective-C, that’s literally what happened; I don’t know how it is implemented in Swift, but conceptually this is how the mental model works).<br></p><p>Should I not have to add an “override” keyword to a subclass method simply because I wrote that method first and only refactored it into a superclass method after the fact?<br></p><p>This seems like a fairly silly objection, IMO.<br></p><p>&gt; On Aug 26, 2016, at 3:23 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; If you want it all to compile at the same time, well, we’ve still got access to all the Objective-C runtime functions in Swift. One can also write the assembly by hand. Things like “override” aren’t security features; they’re there to help you do the right thing. If you’re deliberately trying to do the wrong thing, I don’t think that can strictly be prevented.<br>&gt; <br>&gt; The current syntax is not the &quot;wrong thing&quot;--and a future language feature shouldn&#39;t leave a loophole where someone can choose either one or another totally different set of rules for conforming a type to a protocol; there should be one syntax for doing that in Swift.<br></p><p>The current syntax allows many opportunities to do the wrong thing.<br></p><p>This is the wrong thing:<br></p><p>protocol P {<br>	func foo(bar: Baz)<br>}<br></p><p>extension P {<br>	func foo(bar: Baz) {}<br>}<br></p><p>struct S: P {<br>	func foo(baz: Baz) {}<br>}<br></p><p>Refactoring this can result in another wrong thing:<br></p><p>protocol P {<br>	func foo(bar: Baz, qux: Quux)<br>}<br></p><p>extension P {<br>	func foo(bar: Baz) {}<br>}<br></p><p>etc. etc. etc.<br></p><p>Currently it’s hard for a linter to catch things like this, because there’s no way to know that I *didn’t* mean to define a similarly, but not exactly, named function, just as there’s no way to know that I *didn’t* mean to provide a simplified version of the function in the extension. And etc. If I could tell the compiler what I mean by those declarations, suddenly they it becomes possible to check them for accuracy.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/70d55fcc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 26, 2016 at 03:00:00pm</p></header><div class="content"><p>On Fri, Aug 26, 2016 at 3:43 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Aug 26, 2016, at 3:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; Why? S.foo() is visible throughout the module, but outside this file,<br>&gt;&gt; S.foo() doesn&#39;t override anything. Why should it be marked as an `override`<br>&gt;&gt; when, as you say, the generated interface shows no sign of conformance to P?<br>&gt;&gt; In addition, how would you justify a requirement to fiddle with these<br>&gt;&gt; keywords when someone simply refactors an internally visible type with no<br>&gt;&gt; private members from one file to another? Your proposed rule just broke<br>&gt;&gt; copy-and-paste...<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Because it indicates the programmer’s *intent.* If the protocol is<br>&gt;&gt; visible at the time you’re writing the declaration for S.foo(), then you<br>&gt;&gt; should have to tell the compiler what you mean by that and what you’re<br>&gt;&gt; doing with it.<br>&gt;&gt;<br>&gt;<br>&gt; Where a type is located in relation to a protocol is a poor proxy for<br>&gt; whether one was written _before_ the other. And while the writer&#39;s most<br>&gt; likely intent might differ depending on the order in which two things are<br>&gt; written, how one declares members on a type should not be determined by a<br>&gt; set of arbitrary rules for the compiler to guess whether the type or<br>&gt; protocol was written first. This kind of functionality, if you want it,<br>&gt; might be appropriate for a linter. It could probably even look at last<br>&gt; modified dates, or with a git repo, go line by line to see when each piece<br>&gt; of the code was written.<br>&gt;<br>&gt;<br>&gt; Why should it matter when the programmer wrote it?<br>&gt;<br></p><p>I don&#39;t know--that&#39;s your suggestion, not mine: &quot;If the protocol is visible<br>at the time you’re writing the declaration for S.foo(), then you should<br>have to tell the compiler what you mean by that...&quot;<br></p><p><br>&gt; One is the declaration, the other is an add-on to it. Conceptually, the<br>&gt; type is constructed first, and then things are bolted on (and in<br>&gt; Objective-C, that’s literally what happened; I don’t know how it is<br>&gt; implemented in Swift, but conceptually this is how the mental model works).<br>&gt;<br>&gt; Should I not have to add an “override” keyword to a subclass method simply<br>&gt; because I wrote that method first and only refactored it into a superclass<br>&gt; method after the fact?<br>&gt;<br>&gt; This seems like a fairly silly objection, IMO.<br>&gt;<br>&gt; I agree, it seems silly. Can you explain what you meant?<br></p><p>&gt; On Aug 26, 2016, at 3:23 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; If you want it all to compile at the same time, well, we’ve still got<br>&gt;&gt; access to all the Objective-C runtime functions in Swift. One can also<br>&gt;&gt; write the assembly by hand. Things like “override” aren’t security<br>&gt;&gt; features; they’re there to help you do the right thing. If you’re<br>&gt;&gt; deliberately trying to do the wrong thing, I don’t think that can strictly<br>&gt;&gt; be prevented.<br>&gt;&gt;<br>&gt;<br>&gt; The current syntax is not the &quot;wrong thing&quot;--and a future language feature<br>&gt; shouldn&#39;t leave a loophole where someone can choose either one or another<br>&gt; totally different set of rules for conforming a type to a protocol; there<br>&gt; should be one syntax for doing that in Swift.<br>&gt;<br>&gt;<br>&gt; The current syntax allows many opportunities to do the wrong thing.<br>&gt;<br>&gt; This is the wrong thing:<br>&gt;<br>&gt; protocol P {<br>&gt; func foo(bar: Baz)<br>&gt; }<br>&gt;<br>&gt; extension P {<br>&gt; func foo(bar: Baz) {}<br>&gt; }<br>&gt;<br>&gt; struct S: P {<br>&gt; func foo(baz: Baz) {}<br>&gt; }<br>&gt;<br>&gt; Refactoring this can result in another wrong thing:<br>&gt;<br>&gt; protocol P {<br>&gt; func foo(bar: Baz, qux: Quux)<br>&gt; }<br>&gt;<br>&gt; extension P {<br>&gt; func foo(bar: Baz) {}<br>&gt; }<br>&gt;<br>&gt; etc. etc. etc.<br>&gt;<br>&gt; Currently it’s hard for a linter to catch things like this, because<br>&gt; there’s no way to know that I *didn’t* mean to define a similarly, but not<br>&gt; exactly, named function, just as there’s no way to know that I *didn’t*<br>&gt; mean to provide a simplified version of the function in the extension. And<br>&gt; etc. If I could tell the compiler what I mean by those declarations,<br>&gt; suddenly they it becomes possible to check them for accuracy.<br>&gt;<br></p><p>Or, instead, you could tell a linter these things if you choose; I&#39;m saying<br>your proposal of having distinct before-the-fact and after-the-fact syntax<br>for protocol conformance doesn&#39;t make for a good language feature, IMO.<br></p><p><br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/d2000227/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 26, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Aug 26, 2016, at 3:58 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Aug 26, 2016 at 3:43 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt; <br>&gt; On Aug 26, 2016, at 3:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Why? S.foo() is visible throughout the module, but outside this file, S.foo() doesn&#39;t override anything. Why should it be marked as an `override` when, as you say, the generated interface shows no sign of conformance to P?<br>&gt;&gt;&gt; In addition, how would you justify a requirement to fiddle with these keywords when someone simply refactors an internally visible type with no private members from one file to another? Your proposed rule just broke copy-and-paste...<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Because it indicates the programmer’s *intent.* If the protocol is visible at the time you’re writing the declaration for S.foo(), then you should have to tell the compiler what you mean by that and what you’re doing with it.<br>&gt;&gt; <br>&gt;&gt; Where a type is located in relation to a protocol is a poor proxy for whether one was written _before_ the other. And while the writer&#39;s most likely intent might differ depending on the order in which two things are written, how one declares members on a type should not be determined by a set of arbitrary rules for the compiler to guess whether the type or protocol was written first. This kind of functionality, if you want it, might be appropriate for a linter. It could probably even look at last modified dates, or with a git repo, go line by line to see when each piece of the code was written.<br>&gt; <br>&gt; Why should it matter when the programmer wrote it?<br>&gt; <br>&gt; I don&#39;t know--that&#39;s your suggestion, not mine: &quot;If the protocol is visible at the time you’re writing the declaration for S.foo(), then you should have to tell the compiler what you mean by that...&quot;<br>&gt;  <br>&gt; One is the declaration, the other is an add-on to it. Conceptually, the type is constructed first, and then things are bolted on (and in Objective-C, that’s literally what happened; I don’t know how it is implemented in Swift, but conceptually this is how the mental model works).<br>&gt; <br>&gt; Should I not have to add an “override” keyword to a subclass method simply because I wrote that method first and only refactored it into a superclass method after the fact?<br>&gt; <br>&gt; This seems like a fairly silly objection, IMO.<br>&gt; <br>&gt; I agree, it seems silly. Can you explain what you meant?<br></p><p>Think of it—even if you wrote the whole thing—as if each file were written by a different person. The programmer who wrote File A defines the type. The programmer who wrote File B added conformance to a protocol to the type. Conceptually, one comes before the other, since the type has to be made before it can be extended, yes?<br></p><p>And I don’t know about you, but when I add methods to a type whose purpose are to satisfy a protocol, I put them near the declaration of conformance, not somewhere on the other side of the universe. If I’m retroactively adding conformance to something in a different translation unit, then the methods involved originally served some other purpose independent of the protocol. Otherwise, it’s just terrible design, IMO.<br></p><p>&gt;&gt; On Aug 26, 2016, at 3:23 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If you want it all to compile at the same time, well, we’ve still got access to all the Objective-C runtime functions in Swift. One can also write the assembly by hand. Things like “override” aren’t security features; they’re there to help you do the right thing. If you’re deliberately trying to do the wrong thing, I don’t think that can strictly be prevented.<br>&gt;&gt; <br>&gt;&gt; The current syntax is not the &quot;wrong thing&quot;--and a future language feature shouldn&#39;t leave a loophole where someone can choose either one or another totally different set of rules for conforming a type to a protocol; there should be one syntax for doing that in Swift.<br>&gt; <br>&gt; The current syntax allows many opportunities to do the wrong thing.<br>&gt; <br>&gt; This is the wrong thing:<br>&gt; <br>&gt; protocol P {<br>&gt; 	func foo(bar: Baz)<br>&gt; }<br>&gt; <br>&gt; extension P {<br>&gt; 	func foo(bar: Baz) {}<br>&gt; }<br>&gt; <br>&gt; struct S: P {<br>&gt; 	func foo(baz: Baz) {}<br>&gt; }<br>&gt; <br>&gt; Refactoring this can result in another wrong thing:<br>&gt; <br>&gt; protocol P {<br>&gt; 	func foo(bar: Baz, qux: Quux)<br>&gt; }<br>&gt; <br>&gt; extension P {<br>&gt; 	func foo(bar: Baz) {}<br>&gt; }<br>&gt; <br>&gt; etc. etc. etc.<br>&gt; <br>&gt; Currently it’s hard for a linter to catch things like this, because there’s no way to know that I *didn’t* mean to define a similarly, but not exactly, named function, just as there’s no way to know that I *didn’t* mean to provide a simplified version of the function in the extension. And etc. If I could tell the compiler what I mean by those declarations, suddenly they it becomes possible to check them for accuracy.<br>&gt; <br>&gt; Or, instead, you could tell a linter these things if you choose; I&#39;m saying your proposal of having distinct before-the-fact and after-the-fact syntax for protocol conformance doesn&#39;t make for a good language feature, IMO.<br></p><p><br>But that was only one of a set of four options which I presented, of which more are assuredly possible. If you want the syntax to be exactly the same, we could even do that, just by declaring the methods in the extension with no bodies:<br></p><p>extension S: P {<br>	conform func foo()<br>}<br></p><p>Honestly, I’m not married to any one syntax for retroactive conformances; the typical kind are the ones I’m more concerned with, because they offer a great potential for mistakes as compared with the traditional inheritance model, and I’m finding that the increased brittleness is the biggest drawback I’m noticing in refactoring an old Objective-C hierarchy to the Swift protocol-oriented model.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/0ac2d476/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 26, 2016 at 04:00:00pm</p></header><div class="content"><p>On Fri, Aug 26, 2016 at 4:19 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 26, 2016, at 3:58 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Fri, Aug 26, 2016 at 3:43 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt;  wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Aug 26, 2016, at 3:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Why? S.foo() is visible throughout the module, but outside this file,<br>&gt;&gt;&gt; S.foo() doesn&#39;t override anything. Why should it be marked as an `override`<br>&gt;&gt;&gt; when, as you say, the generated interface shows no sign of conformance to P?<br>&gt;&gt;&gt; In addition, how would you justify a requirement to fiddle with these<br>&gt;&gt;&gt; keywords when someone simply refactors an internally visible type with no<br>&gt;&gt;&gt; private members from one file to another? Your proposed rule just broke<br>&gt;&gt;&gt; copy-and-paste...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Because it indicates the programmer’s *intent.* If the protocol is<br>&gt;&gt;&gt; visible at the time you’re writing the declaration for S.foo(), then you<br>&gt;&gt;&gt; should have to tell the compiler what you mean by that and what you’re<br>&gt;&gt;&gt; doing with it.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Where a type is located in relation to a protocol is a poor proxy for<br>&gt;&gt; whether one was written _before_ the other. And while the writer&#39;s most<br>&gt;&gt; likely intent might differ depending on the order in which two things are<br>&gt;&gt; written, how one declares members on a type should not be determined by a<br>&gt;&gt; set of arbitrary rules for the compiler to guess whether the type or<br>&gt;&gt; protocol was written first. This kind of functionality, if you want it,<br>&gt;&gt; might be appropriate for a linter. It could probably even look at last<br>&gt;&gt; modified dates, or with a git repo, go line by line to see when each piece<br>&gt;&gt; of the code was written.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Why should it matter when the programmer wrote it?<br>&gt;&gt;<br>&gt;<br>&gt; I don&#39;t know--that&#39;s your suggestion, not mine: &quot;If the protocol is<br>&gt; visible at the time you’re writing the declaration for S.foo(), then you<br>&gt; should have to tell the compiler what you mean by that...&quot;<br>&gt;<br>&gt;<br>&gt;&gt; One is the declaration, the other is an add-on to it. Conceptually, the<br>&gt;&gt; type is constructed first, and then things are bolted on (and in<br>&gt;&gt; Objective-C, that’s literally what happened; I don’t know how it is<br>&gt;&gt; implemented in Swift, but conceptually this is how the mental model works).<br>&gt;&gt;<br>&gt;&gt; Should I not have to add an “override” keyword to a subclass method<br>&gt;&gt; simply because I wrote that method first and only refactored it into a<br>&gt;&gt; superclass method after the fact?<br>&gt;&gt;<br>&gt;&gt; This seems like a fairly silly objection, IMO.<br>&gt;&gt;<br>&gt;&gt; I agree, it seems silly. Can you explain what you meant?<br>&gt;<br>&gt;<br>&gt; Think of it—even if you wrote the whole thing—as if each file were written<br>&gt; by a different person. The programmer who wrote File A defines the type.<br>&gt; The programmer who wrote File B added conformance to a protocol to the<br>&gt; type. Conceptually, one comes before the other, since the type has to be<br>&gt; made before it can be extended, yes?<br>&gt;<br></p><p>And you argue that if both parts were in the same file, then conceptually<br>the type no longer &quot;comes before&quot; its protocol conformance? That seems like<br>an arbitrary distinction to me.<br>Surely, if I subscribed to your notion that types &quot;come before&quot; their<br>conformance to a protocol, then it doesn&#39;t matter if they&#39;re separated in<br>different files or not: no keyword should be necessary for a declaration to<br>override a default protocol implementation, because the type conceptually<br>&quot;comes before&quot; that default implementation.<br></p><p><br>&gt; And I don’t know about you, but when I add methods to a type whose purpose<br>&gt; are to satisfy a protocol, I put them near the declaration of conformance,<br>&gt; not somewhere on the other side of the universe. If I’m retroactively<br>&gt; adding conformance to something in a different translation unit, then the<br>&gt; methods involved originally served some other purpose independent of the<br>&gt; protocol. Otherwise, it’s just terrible design, IMO.<br>&gt;<br>&gt; On Aug 26, 2016, at 3:23 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; If you want it all to compile at the same time, well, we’ve still got<br>&gt;&gt;&gt; access to all the Objective-C runtime functions in Swift. One can also<br>&gt;&gt;&gt; write the assembly by hand. Things like “override” aren’t security<br>&gt;&gt;&gt; features; they’re there to help you do the right thing. If you’re<br>&gt;&gt;&gt; deliberately trying to do the wrong thing, I don’t think that can strictly<br>&gt;&gt;&gt; be prevented.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The current syntax is not the &quot;wrong thing&quot;--and a future language<br>&gt;&gt; feature shouldn&#39;t leave a loophole where someone can choose either one or<br>&gt;&gt; another totally different set of rules for conforming a type to a protocol;<br>&gt;&gt; there should be one syntax for doing that in Swift.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The current syntax allows many opportunities to do the wrong thing.<br>&gt;&gt;<br>&gt;&gt; This is the wrong thing:<br>&gt;&gt;<br>&gt;&gt; protocol P {<br>&gt;&gt; func foo(bar: Baz)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension P {<br>&gt;&gt; func foo(bar: Baz) {}<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct S: P {<br>&gt;&gt; func foo(baz: Baz) {}<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Refactoring this can result in another wrong thing:<br>&gt;&gt;<br>&gt;&gt; protocol P {<br>&gt;&gt; func foo(bar: Baz, qux: Quux)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension P {<br>&gt;&gt; func foo(bar: Baz) {}<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; etc. etc. etc.<br>&gt;&gt;<br>&gt;&gt; Currently it’s hard for a linter to catch things like this, because<br>&gt;&gt; there’s no way to know that I *didn’t* mean to define a similarly, but not<br>&gt;&gt; exactly, named function, just as there’s no way to know that I *didn’t*<br>&gt;&gt; mean to provide a simplified version of the function in the extension. And<br>&gt;&gt; etc. If I could tell the compiler what I mean by those declarations,<br>&gt;&gt; suddenly they it becomes possible to check them for accuracy.<br>&gt;&gt;<br>&gt;<br>&gt; Or, instead, you could tell a linter these things if you choose; I&#39;m<br>&gt; saying your proposal of having distinct before-the-fact and after-the-fact<br>&gt; syntax for protocol conformance doesn&#39;t make for a good language feature,<br>&gt; IMO.<br>&gt;<br>&gt;<br>&gt; But that was only one of a set of four options which I presented, of which<br>&gt; more are assuredly possible. If you want the syntax to be exactly the same,<br>&gt; we could even do that, just by declaring the methods in the extension with<br>&gt; no bodies:<br>&gt;<br>&gt; extension S: P {<br>&gt; conform func foo()<br>&gt; }<br>&gt;<br>&gt; Honestly, I’m not married to any one syntax for retroactive conformances;<br>&gt;<br></p><p>Then let me convince you that perhaps what you want is a linter that parses<br>structured comments, which can be used to say whether this or that method<br>is intended to override a particular default protocol implementation or<br>whether some conformance is a retroactive one. There&#39;s enormous flexibility<br>there, and none of it impacts people who have retroactive modeling needs<br>that don&#39;t neatly fit into this sort of &quot;comes before&quot; and &quot;comes after&quot;<br>model.<br></p><p>the typical kind are the ones I’m more concerned with, because they offer a<br>&gt; great potential for mistakes as compared with the traditional inheritance<br>&gt; model, and I’m finding that the increased brittleness is the biggest<br>&gt; drawback I’m noticing in refactoring an old Objective-C hierarchy to the<br>&gt; Swift protocol-oriented model.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/313690e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 27, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Aug 26, 2016, at 4:27 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Aug 26, 2016 at 4:19 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; On Aug 26, 2016, at 3:58 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, Aug 26, 2016 at 3:43 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Aug 26, 2016, at 3:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Why? S.foo() is visible throughout the module, but outside this file, S.foo() doesn&#39;t override anything. Why should it be marked as an `override` when, as you say, the generated interface shows no sign of conformance to P?<br>&gt;&gt;&gt;&gt; In addition, how would you justify a requirement to fiddle with these keywords when someone simply refactors an internally visible type with no private members from one file to another? Your proposed rule just broke copy-and-paste...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Because it indicates the programmer’s *intent.* If the protocol is visible at the time you’re writing the declaration for S.foo(), then you should have to tell the compiler what you mean by that and what you’re doing with it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Where a type is located in relation to a protocol is a poor proxy for whether one was written _before_ the other. And while the writer&#39;s most likely intent might differ depending on the order in which two things are written, how one declares members on a type should not be determined by a set of arbitrary rules for the compiler to guess whether the type or protocol was written first. This kind of functionality, if you want it, might be appropriate for a linter. It could probably even look at last modified dates, or with a git repo, go line by line to see when each piece of the code was written.<br>&gt;&gt; <br>&gt;&gt; Why should it matter when the programmer wrote it?<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know--that&#39;s your suggestion, not mine: &quot;If the protocol is visible at the time you’re writing the declaration for S.foo(), then you should have to tell the compiler what you mean by that...&quot;<br>&gt;&gt;  <br>&gt;&gt; One is the declaration, the other is an add-on to it. Conceptually, the type is constructed first, and then things are bolted on (and in Objective-C, that’s literally what happened; I don’t know how it is implemented in Swift, but conceptually this is how the mental model works).<br>&gt;&gt; <br>&gt;&gt; Should I not have to add an “override” keyword to a subclass method simply because I wrote that method first and only refactored it into a superclass method after the fact?<br>&gt;&gt; <br>&gt;&gt; This seems like a fairly silly objection, IMO.<br>&gt;&gt; <br>&gt;&gt; I agree, it seems silly. Can you explain what you meant?<br>&gt; <br>&gt; Think of it—even if you wrote the whole thing—as if each file were written by a different person. The programmer who wrote File A defines the type. The programmer who wrote File B added conformance to a protocol to the type. Conceptually, one comes before the other, since the type has to be made before it can be extended, yes?<br>&gt; <br>&gt; And you argue that if both parts were in the same file, then conceptually the type no longer &quot;comes before&quot; its protocol conformance? That seems like an arbitrary distinction to me.<br>&gt; Surely, if I subscribed to your notion that types &quot;come before&quot; their conformance to a protocol, then it doesn&#39;t matter if they&#39;re separated in different files or not: no keyword should be necessary for a declaration to override a default protocol implementation, because the type conceptually &quot;comes before&quot; that default implementation.<br></p><p>The point is what information is available to you at the time you declare the type. Either you can see what conformances you will need at the time, or you can’t.<br></p><p>&gt; And I don’t know about you, but when I add methods to a type whose purpose are to satisfy a protocol, I put them near the declaration of conformance, not somewhere on the other side of the universe. If I’m retroactively adding conformance to something in a different translation unit, then the methods involved originally served some other purpose independent of the protocol. Otherwise, it’s just terrible design, IMO.<br>&gt; <br>&gt;&gt;&gt; On Aug 26, 2016, at 3:23 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you want it all to compile at the same time, well, we’ve still got access to all the Objective-C runtime functions in Swift. One can also write the assembly by hand. Things like “override” aren’t security features; they’re there to help you do the right thing. If you’re deliberately trying to do the wrong thing, I don’t think that can strictly be prevented.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The current syntax is not the &quot;wrong thing&quot;--and a future language feature shouldn&#39;t leave a loophole where someone can choose either one or another totally different set of rules for conforming a type to a protocol; there should be one syntax for doing that in Swift.<br>&gt;&gt; <br>&gt;&gt; The current syntax allows many opportunities to do the wrong thing.<br>&gt;&gt; <br>&gt;&gt; This is the wrong thing:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt; 	func foo(bar: Baz)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt; 	func foo(bar: Baz) {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: P {<br>&gt;&gt; 	func foo(baz: Baz) {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Refactoring this can result in another wrong thing:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt; 	func foo(bar: Baz, qux: Quux)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt; 	func foo(bar: Baz) {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; etc. etc. etc.<br>&gt;&gt; <br>&gt;&gt; Currently it’s hard for a linter to catch things like this, because there’s no way to know that I *didn’t* mean to define a similarly, but not exactly, named function, just as there’s no way to know that I *didn’t* mean to provide a simplified version of the function in the extension. And etc. If I could tell the compiler what I mean by those declarations, suddenly they it becomes possible to check them for accuracy.<br>&gt;&gt; <br>&gt;&gt; Or, instead, you could tell a linter these things if you choose; I&#39;m saying your proposal of having distinct before-the-fact and after-the-fact syntax for protocol conformance doesn&#39;t make for a good language feature, IMO.<br>&gt; <br>&gt; <br>&gt; But that was only one of a set of four options which I presented, of which more are assuredly possible. If you want the syntax to be exactly the same, we could even do that, just by declaring the methods in the extension with no bodies:<br>&gt; <br>&gt; extension S: P {<br>&gt; 	conform func foo()<br>&gt; }<br>&gt; <br>&gt; Honestly, I’m not married to any one syntax for retroactive conformances;<br>&gt; <br>&gt; Then let me convince you that perhaps what you want is a linter that parses structured comments, which can be used to say whether this or that method is intended to override a particular default protocol implementation or whether some conformance is a retroactive one. There&#39;s enormous flexibility there, and none of it impacts people who have retroactive modeling needs that don&#39;t neatly fit into this sort of &quot;comes before&quot; and &quot;comes after&quot; model.<br></p><p>The idea of having to have *comments* be meaningful on protocols just to get the same kind of checking you’d get with inheritance or even procedural code, via a linter that does not and probably never will exist, seems incredibly distasteful.<br></p><p>At this point, I feel like Swift should stop advertising itself as a “protocol-oriented” language, when designing around protocols loses so much safety compared to older patterns. :-/<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160827/f0aba7a1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>August 26, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Xiaodi and Charles,<br></p><p>&gt; As I said, this discussion has already happened several times. I&#39;m literally just repeating what people said eight months ago, six months ago, and four months ago. There&#39;s not a good answer to this and perhaps several other issues, which is why I don&#39;t see a way forward for the proposal. After all, I was the one proposing the same idea last winter, so I&#39;ve had a few months to think about it.<br></p><p><br>I&#39;ve been following the discussion from the side both now and before. Without being able to cover everything that&#39;s been said, I hope this message brings at least a bit of new air into the discussion.<br></p><p>— — —<br></p><p>Here&#39;s one more approach that, AFAICT, would enable both retroactive modelling and fairly good error diagnostics: bring the full protocol conformance together with a dedicated definition block which can both define implementations and refer to implementations defined elsewhere.<br></p><p>Details:<br></p><p>1. Allow marking the conformance to a given protocol with a block of code. This could be nested inside a struct/enum/class body or its extension:<br></p><p>    struct Vector {<br>      conformance Hashable { /* TBD, read on… */ }<br>    }<br>    extension Vector {<br>      conformance CustomStringConvertible { /* … */ }<br>    }<br></p><p>or at the top level, as a clearly marked single-conformance extension:<br></p><p>    conformance Vector : CustomDebugStringConvertible { /* … */ }<br></p><p>2. Inside the body of that block, all protocol (non-extension) methods must be marked with `override`. That includes both the required interface and the customisable interface with library-provided default implementations:<br></p><p>    struct Vector {<br>      conformance Hashable {<br>        override static func ==(lhs: Self, rhs: Self) -&gt; Bool { /* … */ }<br>        // Ok.<br></p><p>        var hashValue: Int { /* … */ }<br>        // error: property &#39;hashValue&#39; is required by Hashable.<br>        // (Fixit: mark with &#39;override&#39;)<br></p><p>        override static func &lt; (lhs: Self, rhs: Self) -&gt; Bool { /* … */ }<br>        // error: protocol Hashable does not require &#39;static func &lt;&#39;.<br>        // (Fixit #1: remove override. Etc.)<br>      }<br>    }<br></p><p>3. When conformance is made explicit as described above, no other part of code is allowed to interfere with that type&#39;s conformance to the protocol under question:<br></p><p>    conformance Vector : Collection {<br>      override var startIndex: Int { return 0 }<br>      override var endIndex: Int { return _count }<br>      override subscript(index: Int) -&gt; Double { return _elements[index] }<br>      override func index(after i: Int) -&gt; Int { return i + 1 }<br>    }<br>    extension Vector {<br>      var count: Int { return _count }<br>      // error: property &#39;count&#39; was introduced by explicit conformance to Collection.<br>      // (Fixit: Add explicit override to the conformance block.)<br>    }<br></p><p>4a. When using a `conformance` block for retroactive modelling, or to explicitly include methods, properties etc. defined elsewhere, it is enough to list those in the body of the `conformance` block:<br></p><p>    protocol CountHaving {<br>      associatedtype Count : Integer<br>      var count: Count<br>    }<br>    conformance Array : HasCount {<br>      override var count: Int // Ok, explicit retroactive modelling.<br>    }<br></p><p>4b. Any override declarations without a body within an explicit `conformance` block are requirements for the definitions to exist elsewhere. That includes overridden properties without getters and setters. For example, here&#39;s an alternative way of fixing the error in #4:<br></p><p>    conformance Vector : Collection {<br>      override var startIndex: Int { return 0 }<br>      override var endIndex: Int { return _count }<br>      override subscript(index: Int) -&gt; Double { return _elements[index] }<br>      override func index(after i: Int) -&gt; Int { return i + 1 }<br>      override var count: Int // No body; defined elsewhere.<br>    }<br>    extension Vector {<br>      var count: Int { return _count } // Ok.<br>    }<br></p><p>5. Just like any other extensions, `conformance` blocks could introduce other non-`override` methods etc. to its needs, but they probably should keep it at minimum.<br></p><p>— — —<br></p><p>Downsides. Now, there are obvious reasons not to introduce this complexity to the language:<br></p><p>− It adds quite a bit of boilerplate to the conformance definition. (OTOH, programmers in a hurry would still be able to use the existing implicit conformance syntax, thereby avoiding the boilerplate on the one hand, and the better diagnostics on the other.)<br></p><p>− It would make it harder to add new required methods with default implementations without breaking code elsewhere. Because explicitly conforming types which already happened to have a matching function, property, or subscript would need to include it in the explicit conformance block. (OTOH, maybe that&#39;s what they indeed asked for by making the conformance explicit!)<br></p><p>− It would add yet another keyword to the language, context-specific but regardless. And the amount of `override` noise isn&#39;t looking very pretty.<br></p><p>− It possibly complicates some other convenient use of protocols that I can&#39;t think of right now. Discuss.<br></p><p>On the plus sides,<br></p><p>+ There are precedents of explicit conformances in other languages: Haskell&#39;s type classes &lt;https://en.wikibooks.org/wiki/Haskell/Classes_and_types#Classes_and_instances&gt; and Clojure&#39;s protocols &lt;http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/extend&gt; come to mind as most similar.<br></p><p>+ It better documents how exactly the type conforms to the protocol, without leaving any missing &quot;magic&quot; elsewhere in the codebase. And it would become a compiler-enforced way to the already existing practice of keeping a conformance interface together within an extension block.<br></p><p>Alternatives to consider:<br></p><p>A. Instead of nesting `conformance ProtocolName`, we could say `conformance Self : ProtocolName`.<br></p><p>B. Instead of introducing a new keyword `conformance` for top-level single-conformance extensions, we could state that `private/internal/public` in front of the `extension` keyword is used to define an explicit conformance of one protocol:<br></p><p>    internal extension Vector : Collection { /* just Collection things */ }<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/c0004e68/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 842 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/c0004e68/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 26, 2016 at 12:00:00pm</p></header><div class="content"><p>On Fri, Aug 26, 2016 at 6:35 AM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br></p><p>&gt; Hi Xiaodi and Charles,<br>&gt;<br>&gt; As I said, this discussion has already happened several times. I&#39;m<br>&gt; literally just repeating what people said eight months ago, six months ago,<br>&gt; and four months ago. There&#39;s not a good answer to this and perhaps several<br>&gt; other issues, which is why I don&#39;t see a way forward for the proposal.<br>&gt; After all, I was the one proposing the same idea last winter, so I&#39;ve had a<br>&gt; few months to think about it.<br>&gt;<br>&gt;<br>&gt; I&#39;ve been following the discussion from the side both now and before.<br>&gt; Without being able to cover everything that&#39;s been said, I hope this<br>&gt; message brings at least a bit of new air into the discussion.<br>&gt;<br>&gt; — — —<br>&gt;<br>&gt; Here&#39;s one more approach that, AFAICT, would enable both retroactive<br>&gt; modelling and fairly good error diagnostics: *bring the full protocol<br>&gt; conformance together with a dedicated definition block* which can both<br>&gt; define implementations and refer to implementations defined elsewhere.<br>&gt;<br></p><p>This is a very well explained proposal. Thanks for taking the time to write<br>it out. But I don&#39;t think it solves the problem, and I&#39;ll respond inline.<br></p><p><br>&gt; *Details:*<br>&gt;<br>&gt; 1. Allow marking the conformance to a given protocol with a block of code.<br>&gt; This could be nested inside a struct/enum/class body or its extension:<br>&gt;<br>&gt;     *struct* Vector {<br>&gt;       *conformance* Hashable { /* TBD, read on… */ }<br>&gt;     }<br>&gt;     *extension* Vector {<br>&gt;       *conformance* CustomStringConvertible { /* … */ }<br>&gt;     }<br>&gt;<br></p><p>In general, I think there is an opposition to organizing nested blocks of<br>members like this (there was strong opposition to proposals for access<br>level grouping, for instance). But besides that somewhat subjective<br>opinion, there might also be difficulty in terms of `private` scoping.<br>These are minor, more speculative points.<br></p><p>Mainly, I think it is confusing because it looks like a nested type and<br>invites proposals to namespace protocol conforming members (i.e.<br>`Vector.Hashable.hashValue`), which is not what is going on and definitely<br>not the direction in which I would want to take this proposal.<br></p><p>or at the top level, as a clearly marked *single-conformance extension*:<br>&gt;<br>&gt;     *conformance* Vector : CustomDebugStringConvertible { /* … */ }<br>&gt;<br></p><p>This is an improvement. But, you are introducing a second keyword,<br>`conformance` without justification. The same purpose that you outline<br>later could be served by the existing spelling `extension Vector :<br>CustomDebugStringConvertible`, and this has been proposed earlier in this<br>thread and also in previous threads.<br></p><p><br>&gt; 2. Inside the body of that block, all protocol (non-extension) methods<br>&gt; *must* be marked with `override`. That includes both the required<br>&gt; interface and the customisable interface with library-provided default<br>&gt; implementations:<br>&gt;<br>&gt;     *struct* Vector {<br>&gt;       *conformance* Hashable {<br>&gt;         *override static func* ==(lhs: *Self*, rhs: *Self*) -&gt; Bool { /*<br>&gt; … */ }<br>&gt;         // Ok.<br>&gt;<br>&gt;         *var* hashValue: Int { /* … */ }<br>&gt;         // *error:* property &#39;hashValue&#39; is required by Hashable.<br>&gt;         // (Fixit: mark with &#39;override&#39;)<br>&gt;<br>&gt;         *override static func* &lt; (lhs: *Self*, rhs: *Self*) -&gt; Bool { /*<br>&gt; … */ }<br>&gt;         // *error:* protocol Hashable does not require &#39;static func &lt;&#39;.<br>&gt;         // (Fixit #1: remove override. Etc.)<br>&gt;       }<br>&gt;     }<br>&gt;<br></p><p>This is similar to a previous proposal that any member declared in<br>extensions that add a conformance must, if that member has the same or<br>greater visibility than the lesser of the type and protocol, implement a<br>protocol requirement. However, in your proposal, there&#39;s a pervasive<br>requirement for `override`, which adds noise but doesn&#39;t provide an<br>advantage over that alternative proposal. Moreover, I have a problem with<br>your proposed spelling: if there is no default implementation, why should<br>an implementation be said to `override` anything?<br></p><p><br>&gt; 3. When conformance is made explicit as described above, no other part of<br>&gt; code is allowed to interfere with that type&#39;s conformance to the protocol<br>&gt; under question:<br>&gt;<br>&gt;     *conformance* Vector : Collection {<br>&gt;       *override var *startIndex: Int { *return* 0 }<br>&gt;       *override **var* endIndex: Int { *return* _count }<br>&gt;       *override **subscript*(index: Int) -&gt; Double { *return*<br>&gt; _elements[index] }<br>&gt;       *override **func* index(after i: Int) -&gt; Int { *return* i + 1 }<br>&gt;     }<br>&gt;     *extension* Vector {<br>&gt;       *var* count: Int { *return* _count }<br>&gt;       // *error:* property &#39;count&#39; was introduced by explicit conformance to<br>&gt; Collection.<br>&gt;       // (Fixit: Add explicit override to the conformance block.)<br>&gt;     }<br>&gt;<br></p><p>I&#39;m not sure what safety is gained by this particular rule. The language<br>should make the most simple cases the most straightforward. In the scenario<br>where a struct S, with only a small number of methods, conforms to protocol<br>P, which has only a small number of requirements and no default<br>implementations, it is not confusing at all to put all requirements in the<br>same block of code. Your proposed syntax, if made mandatory [see below<br>about mandatory vs. optional], would greatly increase the visual clutter<br>and difficulty of correctly conforming one simple struct to one simple<br>protocol.<br></p><p>4a. When using a `conformance` block for retroactive modelling, or to<br>&gt; explicitly include methods, properties etc. defined elsewhere, it is enough<br>&gt; to list those in the body of the `conformance` block:<br>&gt;<br>&gt;     *protocol* CountHaving {<br>&gt;       *associatedtype* Count : Integer<br>&gt;       *var* count: Count<br>&gt;     }<br>&gt;     *conformance* Array : HasCount {<br>&gt;       *override var* count: Int // Ok, explicit retroactive modelling.<br>&gt;     }<br>&gt;<br></p><p>This might be unworkable for certain types of retroactive modeling. If I<br>add a new default implementation to a requirement of `Collection`, I would<br>have to write out conformance statements for *every single Collection type*<br>in the standard library, probably Foundation and Dispatch also, plus any<br>other libraries I use, in addition to my own Collection types. The only way<br>to solve this issue, as far as I can tell, is to say that none of these<br>keywords are required across module boundaries, which carves out an<br>exception (which might be justifiable, but it&#39;s still an exception to the<br>rule).<br></p><p><br>&gt; 4b. Any override declarations without a body within an explicit<br>&gt; `conformance` block are requirements for the definitions to exist<br>&gt; elsewhere. That includes overridden properties without getters and setters.<br>&gt; For example, here&#39;s an alternative way of fixing the error in #4:<br>&gt;<br>&gt;     *conformance* Vector : Collection {<br>&gt;       *override var *startIndex: Int { *return* 0 }<br>&gt;       *override **var* endIndex: Int { *return* _count }<br>&gt;       *override **subscript*(index: Int) -&gt; Double { *return* _elements[index]<br>&gt; }<br>&gt;       *override **func* index(after i: Int) -&gt; Int { *return* i + 1 }<br>&gt;       *override var* count: Int // No body; defined elsewhere.<br>&gt;     }<br>&gt;     *extension* Vector {<br>&gt;       *var* count: Int { *return* _count } // Ok.<br>&gt;     }<br>&gt;<br></p><p>This is clever, but also confusing (IMO) because you&#39;ve now introduced more<br>than one way of splitting up code that fulfills protocol requirements, when<br>your stated goal is to improve the situation by putting all requirements in<br>the same place.<br></p><p>Although you&#39;ve insisted on a central location where there&#39;s a catalog of<br>overrides, it might increase rather than decrease confusion about where<br>these requirements are being implemented, because now there&#39;s at least two<br>declarations. For derived classes that conform to protocols but inherit<br>their implementation from a base class, there are additional difficulties:<br>Does `override` mean you&#39;re overriding the base class implementation, or<br>are you using `override` to say that the base class implementation (which<br>you&#39;re not overriding in the derived class) should override the protocol&#39;s<br>default implementation? Also, even though I see a declaration of a protocol<br>requirement with no body, I might not find the implementation anywhere in<br>the derived class, because it&#39;s in another file, and I may not even have<br>access to that source code. In general, it&#39;s exceedingly weird that the<br>derived class would have to re-declare an inherited method with the word<br>`override`, then never override or mention that method again.<br></p><p>5. Just like any other extensions, `conformance` blocks could introduce<br>&gt; other non-`override` methods etc. to its needs, but they probably should<br>&gt; keep it at minimum.<br>&gt;<br></p><p>As mentioned earlier, I think a more preferable and terse rule was proposed<br>earlier, where extensions that add conformance are not allowed to have<br>public members (or members equal or more visible than the protocol or type)<br>that don&#39;t implement a requirement.<br></p><p>— — —<br>&gt;<br>&gt; *Downsides. *Now, there are obvious reasons not to introduce this<br>&gt; complexity to the language:<br>&gt;<br>&gt; − It adds quite a bit of boilerplate to the conformance definition. (OTOH,<br>&gt; programmers in a hurry would still be able to use the existing implicit<br>&gt; conformance syntax, thereby avoiding the boilerplate on the one hand, and<br>&gt; the better diagnostics on the other.)<br>&gt;<br></p><p>It does add quite a bit of boilerplate; the idea of having this boilerplate<br>has been pitched before, though not with the `conformance` keyword. It&#39;s<br>not great, but it might not in and of itself be a deal-breaker.<br></p><p>However, the key weakness here IMO is that you are trying to address the<br>weaknesses above by saying that this whole new syntax is _optional_. This<br>is, IMO, a critical flaw. I could _maybe_ get behind a single opt-in<br>keyword or attribute; but I think a whole new alternative syntax for<br>something as fundamental as conformance is a non-starter. This is a very,<br>very essential part of Swift; there should be *one* syntax for protocol<br>conformance, not two. We should find the one best syntax, though obviously<br>we are now constrained by backwards compatibility issues.<br></p><p><br>&gt; − It would make it harder to add new required methods with default<br>&gt; implementations without breaking code elsewhere. Because explicitly<br>&gt; conforming types which already happened to have a matching function,<br>&gt; property, or subscript would need to include it in the explicit conformance<br>&gt; block. (OTOH, maybe that&#39;s what they indeed asked for by making the<br>&gt; conformance explicit!)<br>&gt;<br>&gt; − It would add yet another keyword to the language, context-specific but<br>&gt; regardless. And the amount of `override` noise isn&#39;t looking very pretty.<br>&gt;<br></p><p>Yes, these two weaknesses are definitely issues. In general, from the<br>perspective of library evolution, there&#39;s a key question to be answered: if<br>the library vendor adds a new default implementation to a protocol, should<br>they need to be concerned that it could cause existing code using a<br>previous version of the library to stop compiling?<br></p><p>Currently, the answer is no, and I think it is the right answer most (if<br>not all) of the the time. I have this opinion because types that conform to<br>the protocol using a previous version of the library cannot possibly change<br>their behavior if a new default implementation is supplied, since these<br>types necessarily have their own implementation of the same requirement and<br>since protocol requirements are dynamically dispatched and there&#39;s no way<br>to break that encapsulation. Therefore, it is unnecessarily disruptive to<br>stop compiling that code in order to force the end user to acknowledge a<br>change that cannot have any effect on their own code. I conclude that any<br>keyword should be _optional_ (if you _want_ your code to break<br>unnecessarily, I guess that can be up to you...), but then see above about<br>my reasoning regarding an optional syntax for protocol conformance.<br></p><p>− It possibly complicates some other convenient use of protocols that I<br>&gt; can&#39;t think of right now. Discuss.<br>&gt;<br>&gt; *On the plus sides,*<br>&gt;<br>&gt; + There are precedents of explicit conformances in other languages: Haskell&#39;s<br>&gt; type classes<br>&gt; &lt;https://en.wikibooks.org/wiki/Haskell/Classes_and_types#Classes_and_instances&gt;<br>&gt;  and Clojure&#39;s protocols<br>&gt; &lt;http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/extend&gt; come<br>&gt; to mind as most similar.<br>&gt;<br>&gt; + It better documents how exactly the type conforms to the protocol,<br>&gt; without leaving any missing &quot;magic&quot; elsewhere in the codebase. And it would<br>&gt; become a compiler-enforced way to the already existing practice of keeping<br>&gt; a conformance interface together within an extension block.<br>&gt;<br>&gt; *Alternatives to consider:*<br>&gt;<br>&gt; A. Instead of nesting `conformance ProtocolName`, we could say<br>&gt; `conformance Self : ProtocolName`.<br>&gt;<br>&gt; B. Instead of introducing a new keyword `conformance` for top-level<br>&gt; single-conformance extensions, we could state that<br>&gt; `private/internal/public` in front of the `extension` keyword is used to<br>&gt; define an explicit conformance of one protocol:<br>&gt;<br>&gt; *    internal extension* Vector : Collection { /* just Collection things<br>&gt; */ }<br>&gt;<br>&gt; — Pyry<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/8dc75da2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e95942f1fe843f007ef5430b9acff78b?s=50"></div><header><strong>Keyword for protocol conformance</strong> from <string>Jaden Geller</string> &lt;jaden.geller at gmail.com&gt;<p>August 25, 2016 at 04:00:00pm</p></header><div class="content"><p>If we really want to be overkill, we could use `required` for implementing an un-defaulted protocol requirement, `override` for implementing a defaulted protocol requirement, and `default` for implementing a protocol requirement in a protocol extension.<br></p><p>I think this might be more verbose than necessary, but I think it is at least worth exploring some subset of those keywords. They all reuse existing ones too, which is mostly a plus.<br></p><p>The biggest benefit I see from these is confidence that what you wrote satisfies your expectations. Just like `try` is required to document at the call-site that a method throws and like argument labels are required to document at the call-site the usage of each parameter, it&#39;s reasonable to require these keywords to document these expectations at the implementation-site. If you forget them, the compiler can easily remind you.<br></p><p>Requiring `override` and/or `required` would make it clear that you&#39;re actually implementing the protocol. It&#39;s too easily to make a typo and define a completely unrelated method. If the requirement is defaulted, you would never know until runtime weirdness. These keywords make protocol conformance less stringily typed.<br></p><p>I&#39;m +1 on this idea in some form (but not necessarily what I suggested).<br></p><p>&gt; On Aug 24, 2016, at 10:13 AM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Requiring &quot;override&quot; when anything overrides a method defined in a protocol extension should be added - structure and enumerated included, of course.<br>&gt; <br>&gt; Protocol extensions added inheritance to structs and enums and this should be made explicit.<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Aug 24, 2016, at 12:55 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Aug 24, 2016, at 1:20 AM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; 2016/08/23 20:52、Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 23, 2016, at 10:34 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016/08/23 15:29、Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 23, 2016, at 2:33 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/08/22 14:30、David Cordero via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The problem:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; At the moment, looking at the code of a class or a struct implementing a protocol, it is hard to know what methods are actually implementing the protocol and what other methods are just part of the code of the class or struct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That seems like a feature, not a bug.  Why should I as an author care whether a method contributes to a protocol conformance or not if the compiler can tell me that kind of information itself?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Being able to reason about your code, what it does, and what it’s for is undesirable?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That&#39;s not an answer to the question I asked.  Why is this significant enough to warrant an entire keyword?  The clutter of a whole keyword that does nothing but wait for a developer to make a source-compatible binary-breaking change to an interface does not seem worth it.  Maybe you can convince me otherwise. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Same reason overriding a class method warrants a keyword. It expresses the purpose more clearly, and allows the compiler to catch mistakes for us.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s just it: The class of mistakes one can make by not being explicit about overrides is significantly more dangerous than the class of mistakes caused by dead code leftover from trimming protocols.<br>&gt;&gt; <br>&gt;&gt; I am in the middle of a large refactor of code that was originally Objective-C and then Swift written like Objective-C, to more idiomatic protocol-oriented Swift. I am finding that in Swift’s POP idiom, protocols with overrides are serving very nearly the same purpose that overrides were serving in the old design; hence, I don’t really think either is more or less dangerous than the other.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol MyProtocol {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     func myMethod() -&gt; String<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class MyClass: MyProtocol {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     conform func myMethod() -&gt; String {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         return &quot;Yuhuuu,I am conforming \\o// &lt;smb://o//&gt;&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     func whatever() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         print(&quot;I am a boring method and I don&#39;t conform anything&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It would be something similar to the current keyword `override` but for protocols. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Apart from improving code readability, It would allow the detection, in compilation time, of errors due to code evolution. For example redundant methods that no longer conform anything once the requirement is removed from the protocol for whatever reason.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you make a breaking change to a protocol like this, you should have gone through a deprecation cycle to indicate to your clients the appropriate changes you&#39;re going to make to the protocol.  This aspect of the change seems to if not encourage, highlight, bad behavior.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What if it’s your own code and all the callers are internal? What if you’re still developing the protocol and haven’t released the API interface yet?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Then your concerns are local enough that you know where all implementations of the protocol lie and whether they require deletion or not.  The point about deprecation cycles still stands in all the cases you mention.  Just because the interface is private doesn&#39;t mean you can&#39;t take responsibility for keeping it as clean as you can.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; tl;dr It seems like all of this can be subsumed by us warning about dead code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Did you look at my examples earlier in the thread? Neither of those would be caught by warning about dead code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The example involving the default implementation is most compelling, but it indicates that your proposed solution should focus on the protocol extension and not the implementing declaration.  Perhaps reusing one of our existing keywords can help here<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;   func foo() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension P {<br>&gt;&gt;&gt;   default func foo() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S: P {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course, this change would be potentially source-breaking either way - I don&#39;t like the sound of an &quot;optional keyword”.  <br>&gt;&gt; <br>&gt;&gt; I can come up with a similar example without the mistake being in the extension, though:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt; 	func foo() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt; 	func foo() { print(“Default Behavior”) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: P {<br>&gt;&gt; 	func foo() { print(“Specific Behavior”) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; So far, so good. But now I realize that the original protocol needs an argument:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt; 	func foo(bar: String) {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt; 	func foo(bar: String) { print(“Default Behavior; bar is \(bar)”) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: P {<br>&gt;&gt; 	func foo() { print(“Specific Behavior”) } // Whoops, forgot to update this method, and now it won’t get called—and we of course won’t see the carnage until runtime.<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt;&gt; Either way, we can all agree we need better diagnostics around these cases.<br>&gt;&gt; <br>&gt;&gt; No doubt.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/eb8c969a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
