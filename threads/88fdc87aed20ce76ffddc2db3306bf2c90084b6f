<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 27, 2016 at 02:00:00pm</p></header><div class="content"><p>on Thu May 26 2016, Patrick Smith &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On 27 May 2016, at 2:40 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Any of the NSObject subclass candidates may require their<br>&gt;&gt; `description`s to be altered to meet the semantics, which may or may<br>&gt;&gt; not be an acceptable breaking change.<br>&gt;<br>&gt; Do you think it might be worth changing `description` to be named<br>&gt; something else? Something more clear, less likely to conflict with<br>&gt; ‘real’ properties — ‘description’ doesn’t seem to portray something<br>&gt; that is value-preserving. What is the reason for calling it<br>&gt; ‘description’?<br></p><p>The main reason was backward compatibility with Cocoa, which already has<br>a “description” property.<br></p><p>&gt; Especially if NSObject subclasses won’t fit, then why not have a<br>&gt; different method that can be strictly value preserving? (Then<br>&gt; `description` can stay being an NSObject thing.)<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 28, 2016 at 12:00:00pm</p></header><div class="content"><p>Is there any possibility we can break from this? Especially as:<br></p><p>1. ValuePreservingStringConvertible expects its description to be value preserving, but current Cocoa implementations are not.<br>2. ‘Description’ doesn’t really convey the meaning of ‘value preserving’ in my mind, but is a valuable name for many other use cases.<br>3. Swift 3 has a wide range of breaking changes for the better.<br>4. With the presence of ValuePreservingStringConvertible, CustomStringConvertible doesn’t seem to provide much value over CustomDebugStringConvertible?<br></p><p>For string interpolation, I imagine the standard library could fall back to a ‘description’ method for NSObject subclasses.<br></p><p>Thanks,<br></p><p>Patrick<br></p><p>&gt; On 28 May 2016, at 7:49 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu May 26 2016, Patrick Smith &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On 27 May 2016, at 2:40 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any of the NSObject subclass candidates may require their<br>&gt;&gt;&gt; `description`s to be altered to meet the semantics, which may or may<br>&gt;&gt;&gt; not be an acceptable breaking change.<br>&gt;&gt; <br>&gt;&gt; Do you think it might be worth changing `description` to be named<br>&gt;&gt; something else? Something more clear, less likely to conflict with<br>&gt;&gt; ‘real’ properties — ‘description’ doesn’t seem to portray something<br>&gt;&gt; that is value-preserving. What is the reason for calling it<br>&gt;&gt; ‘description’?<br>&gt; <br>&gt; The main reason was backward compatibility with Cocoa, which already has<br>&gt; a “description” property.<br>&gt; <br>&gt;&gt; Especially if NSObject subclasses won’t fit, then why not have a<br>&gt;&gt; different method that can be strictly value preserving? (Then<br>&gt;&gt; `description` can stay being an NSObject thing.)<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 27, 2016 at 08:00:00pm</p></header><div class="content"><p>Hello swift-evolution,<br></p><p>I&#39;ve put together a preliminary v2 of the proposal, taking into account<br>feedback expressed on this thread. I would appreciate any comments,<br>suggestions, or criticisms.<br></p><p>https://github.com/austinzheng/swift-evolution/blob/az-edit-89/proposals/0089-rename-string-reflection-init.md<br></p><p>If any objections can be worked out quickly, I hope to resubmit this<br>proposal for review early next week.<br></p><p>Best,<br>Austin<br></p><p><br>On Fri, May 27, 2016 at 7:50 PM, Patrick Smith via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Is there any possibility we can break from this? Especially as:<br>&gt;<br>&gt; 1. ValuePreservingStringConvertible expects its description to be value<br>&gt; preserving, but current Cocoa implementations are not.<br>&gt; 2. ‘Description’ doesn’t really convey the meaning of ‘value preserving’<br>&gt; in my mind, but is a valuable name for many other use cases.<br>&gt; 3. Swift 3 has a wide range of breaking changes for the better.<br>&gt; 4. With the presence of ValuePreservingStringConvertible,<br>&gt; CustomStringConvertible doesn’t seem to provide much value over<br>&gt; CustomDebugStringConvertible?<br>&gt;<br>&gt; For string interpolation, I imagine the standard library could fall back<br>&gt; to a ‘description’ method for NSObject subclasses.<br>&gt;<br>&gt; Thanks,<br>&gt;<br>&gt; Patrick<br>&gt;<br>&gt; &gt; On 28 May 2016, at 7:49 AM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; on Thu May 26 2016, Patrick Smith &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; On 27 May 2016, at 2:40 PM, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Any of the NSObject subclass candidates may require their<br>&gt; &gt;&gt;&gt; `description`s to be altered to meet the semantics, which may or may<br>&gt; &gt;&gt;&gt; not be an acceptable breaking change.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Do you think it might be worth changing `description` to be named<br>&gt; &gt;&gt; something else? Something more clear, less likely to conflict with<br>&gt; &gt;&gt; ‘real’ properties — ‘description’ doesn’t seem to portray something<br>&gt; &gt;&gt; that is value-preserving. What is the reason for calling it<br>&gt; &gt;&gt; ‘description’?<br>&gt; &gt;<br>&gt; &gt; The main reason was backward compatibility with Cocoa, which already has<br>&gt; &gt; a “description” property.<br>&gt; &gt;<br>&gt; &gt;&gt; Especially if NSObject subclasses won’t fit, then why not have a<br>&gt; &gt;&gt; different method that can be strictly value preserving? (Then<br>&gt; &gt;&gt; `description` can stay being an NSObject thing.)<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Dave<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/8dd00641/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 28, 2016 at 04:00:00am</p></header><div class="content"><p>This looks good. I like your use of the term &quot;lossless&quot;; perhaps we can use<br>it consistently, i.e. LosslessStringConvertible. The implication by<br>comparison would be that CustomStringConvertible makes no guarantee of<br>losslessness.<br>On Fri, May 27, 2016 at 23:52 Austin Zheng via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello swift-evolution,<br>&gt;<br>&gt; I&#39;ve put together a preliminary v2 of the proposal, taking into account<br>&gt; feedback expressed on this thread. I would appreciate any comments,<br>&gt; suggestions, or criticisms.<br>&gt;<br>&gt;<br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-edit-89/proposals/0089-rename-string-reflection-init.md<br>&gt;<br>&gt; If any objections can be worked out quickly, I hope to resubmit this<br>&gt; proposal for review early next week.<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt;<br>&gt; On Fri, May 27, 2016 at 7:50 PM, Patrick Smith via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Is there any possibility we can break from this? Especially as:<br>&gt;&gt;<br>&gt;&gt; 1. ValuePreservingStringConvertible expects its description to be value<br>&gt;&gt; preserving, but current Cocoa implementations are not.<br>&gt;&gt; 2. ‘Description’ doesn’t really convey the meaning of ‘value preserving’<br>&gt;&gt; in my mind, but is a valuable name for many other use cases.<br>&gt;&gt; 3. Swift 3 has a wide range of breaking changes for the better.<br>&gt;&gt; 4. With the presence of ValuePreservingStringConvertible,<br>&gt;&gt; CustomStringConvertible doesn’t seem to provide much value over<br>&gt;&gt; CustomDebugStringConvertible?<br>&gt;&gt;<br>&gt;&gt; For string interpolation, I imagine the standard library could fall back<br>&gt;&gt; to a ‘description’ method for NSObject subclasses.<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt;<br>&gt;&gt; Patrick<br>&gt;&gt;<br>&gt;&gt; &gt; On 28 May 2016, at 7:49 AM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; on Thu May 26 2016, Patrick Smith &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; On 27 May 2016, at 2:40 PM, Austin Zheng via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Any of the NSObject subclass candidates may require their<br>&gt;&gt; &gt;&gt;&gt; `description`s to be altered to meet the semantics, which may or may<br>&gt;&gt; &gt;&gt;&gt; not be an acceptable breaking change.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Do you think it might be worth changing `description` to be named<br>&gt;&gt; &gt;&gt; something else? Something more clear, less likely to conflict with<br>&gt;&gt; &gt;&gt; ‘real’ properties — ‘description’ doesn’t seem to portray something<br>&gt;&gt; &gt;&gt; that is value-preserving. What is the reason for calling it<br>&gt;&gt; &gt;&gt; ‘description’?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The main reason was backward compatibility with Cocoa, which already has<br>&gt;&gt; &gt; a “description” property.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Especially if NSObject subclasses won’t fit, then why not have a<br>&gt;&gt; &gt;&gt; different method that can be strictly value preserving? (Then<br>&gt;&gt; &gt;&gt; `description` can stay being an NSObject thing.)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Dave<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/7612f232/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 27, 2016 at 09:00:00pm</p></header><div class="content"><p>Thanks, I like &quot;Lossless&quot; too. Further suggestions on naming would be appreciated from anyone.<br></p><p>Austin<br></p><p>&gt; On May 27, 2016, at 9:03 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; This looks good. I like your use of the term &quot;lossless&quot;; perhaps we can use it consistently, i.e. LosslessStringConvertible. The implication by comparison would be that CustomStringConvertible makes no guarantee of losslessness.<br>&gt; On Fri, May 27, 2016 at 23:52 Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hello swift-evolution,<br>&gt; <br>&gt; I&#39;ve put together a preliminary v2 of the proposal, taking into account feedback expressed on this thread. I would appreciate any comments, suggestions, or criticisms.<br>&gt; <br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-edit-89/proposals/0089-rename-string-reflection-init.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-edit-89/proposals/0089-rename-string-reflection-init.md&gt;<br>&gt; <br>&gt; If any objections can be worked out quickly, I hope to resubmit this proposal for review early next week.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; On Fri, May 27, 2016 at 7:50 PM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Is there any possibility we can break from this? Especially as:<br>&gt; <br>&gt; 1. ValuePreservingStringConvertible expects its description to be value preserving, but current Cocoa implementations are not.<br>&gt; 2. ‘Description’ doesn’t really convey the meaning of ‘value preserving’ in my mind, but is a valuable name for many other use cases.<br>&gt; 3. Swift 3 has a wide range of breaking changes for the better.<br>&gt; 4. With the presence of ValuePreservingStringConvertible, CustomStringConvertible doesn’t seem to provide much value over CustomDebugStringConvertible?<br>&gt; <br>&gt; For string interpolation, I imagine the standard library could fall back to a ‘description’ method for NSObject subclasses.<br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; Patrick<br>&gt; <br>&gt; &gt; On 28 May 2016, at 7:49 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; on Thu May 26 2016, Patrick Smith &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; On 27 May 2016, at 2:40 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Any of the NSObject subclass candidates may require their<br>&gt; &gt;&gt;&gt; `description`s to be altered to meet the semantics, which may or may<br>&gt; &gt;&gt;&gt; not be an acceptable breaking change.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Do you think it might be worth changing `description` to be named<br>&gt; &gt;&gt; something else? Something more clear, less likely to conflict with<br>&gt; &gt;&gt; ‘real’ properties — ‘description’ doesn’t seem to portray something<br>&gt; &gt;&gt; that is value-preserving. What is the reason for calling it<br>&gt; &gt;&gt; ‘description’?<br>&gt; &gt;<br>&gt; &gt; The main reason was backward compatibility with Cocoa, which already has<br>&gt; &gt; a “description” property.<br>&gt; &gt;<br>&gt; &gt;&gt; Especially if NSObject subclasses won’t fit, then why not have a<br>&gt; &gt;&gt; different method that can be strictly value preserving? (Then<br>&gt; &gt;&gt; `description` can stay being an NSObject thing.)<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Dave<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/3c960e91/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>May 28, 2016 at 04:00:00am</p></header><div class="content"><p>Does &quot;lossless&quot; preclude floating-point numbers from being printed in<br>decimal unless they are exactly representable?<br></p><p>On Fri, May 27, 2016 at 9:04 PM Austin Zheng via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Thanks, I like &quot;Lossless&quot; too. Further suggestions on naming would be<br>&gt; appreciated from anyone.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt;<br>&gt; On May 27, 2016, at 9:03 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; This looks good. I like your use of the term &quot;lossless&quot;; perhaps we can<br>&gt; use it consistently, i.e. LosslessStringConvertible. The implication by<br>&gt; comparison would be that CustomStringConvertible makes no guarantee of<br>&gt; losslessness.<br>&gt; On Fri, May 27, 2016 at 23:52 Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hello swift-evolution,<br>&gt;&gt;<br>&gt;&gt; I&#39;ve put together a preliminary v2 of the proposal, taking into account<br>&gt;&gt; feedback expressed on this thread. I would appreciate any comments,<br>&gt;&gt; suggestions, or criticisms.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-edit-89/proposals/0089-rename-string-reflection-init.md<br>&gt;&gt;<br>&gt;&gt; If any objections can be worked out quickly, I hope to resubmit this<br>&gt;&gt; proposal for review early next week.<br>&gt;&gt;<br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Fri, May 27, 2016 at 7:50 PM, Patrick Smith via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Is there any possibility we can break from this? Especially as:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. ValuePreservingStringConvertible expects its description to be value<br>&gt;&gt;&gt; preserving, but current Cocoa implementations are not.<br>&gt;&gt;&gt; 2. ‘Description’ doesn’t really convey the meaning of ‘value preserving’<br>&gt;&gt;&gt; in my mind, but is a valuable name for many other use cases.<br>&gt;&gt;&gt; 3. Swift 3 has a wide range of breaking changes for the better.<br>&gt;&gt;&gt; 4. With the presence of ValuePreservingStringConvertible,<br>&gt;&gt;&gt; CustomStringConvertible doesn’t seem to provide much value over<br>&gt;&gt;&gt; CustomDebugStringConvertible?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For string interpolation, I imagine the standard library could fall back<br>&gt;&gt;&gt; to a ‘description’ method for NSObject subclasses.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Patrick<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On 28 May 2016, at 7:49 AM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; on Thu May 26 2016, Patrick Smith &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; On 27 May 2016, at 2:40 PM, Austin Zheng via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Any of the NSObject subclass candidates may require their<br>&gt;&gt;&gt; &gt;&gt;&gt; `description`s to be altered to meet the semantics, which may or may<br>&gt;&gt;&gt; &gt;&gt;&gt; not be an acceptable breaking change.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Do you think it might be worth changing `description` to be named<br>&gt;&gt;&gt; &gt;&gt; something else? Something more clear, less likely to conflict with<br>&gt;&gt;&gt; &gt;&gt; ‘real’ properties — ‘description’ doesn’t seem to portray something<br>&gt;&gt;&gt; &gt;&gt; that is value-preserving. What is the reason for calling it<br>&gt;&gt;&gt; &gt;&gt; ‘description’?<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The main reason was backward compatibility with Cocoa, which already<br>&gt;&gt;&gt; has<br>&gt;&gt;&gt; &gt; a “description” property.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; Especially if NSObject subclasses won’t fit, then why not have a<br>&gt;&gt;&gt; &gt;&gt; different method that can be strictly value preserving? (Then<br>&gt;&gt;&gt; &gt;&gt; `description` can stay being an NSObject thing.)<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt; &gt; Dave<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/55d6be21/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 28, 2016 at 04:00:00am</p></header><div class="content"><p>I&#39;d hope not. You can&#39;t guarantee String -&gt; Double -&gt; String roundtripping,<br>but Double -&gt; String -&gt; Double should be lossless.<br>On Sat, May 28, 2016 at 00:11 Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>wrote:<br></p><p>&gt; Does &quot;lossless&quot; preclude floating-point numbers from being printed in<br>&gt; decimal unless they are exactly representable?<br>&gt;<br>&gt; On Fri, May 27, 2016 at 9:04 PM Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Thanks, I like &quot;Lossless&quot; too. Further suggestions on naming would be<br>&gt;&gt; appreciated from anyone.<br>&gt;&gt;<br>&gt;&gt; Austin<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On May 27, 2016, at 9:03 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; This looks good. I like your use of the term &quot;lossless&quot;; perhaps we can<br>&gt;&gt; use it consistently, i.e. LosslessStringConvertible. The implication by<br>&gt;&gt; comparison would be that CustomStringConvertible makes no guarantee of<br>&gt;&gt; losslessness.<br>&gt;&gt; On Fri, May 27, 2016 at 23:52 Austin Zheng via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hello swift-evolution,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;ve put together a preliminary v2 of the proposal, taking into account<br>&gt;&gt;&gt; feedback expressed on this thread. I would appreciate any comments,<br>&gt;&gt;&gt; suggestions, or criticisms.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-edit-89/proposals/0089-rename-string-reflection-init.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If any objections can be worked out quickly, I hope to resubmit this<br>&gt;&gt;&gt; proposal for review early next week.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Fri, May 27, 2016 at 7:50 PM, Patrick Smith via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Is there any possibility we can break from this? Especially as:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1. ValuePreservingStringConvertible expects its description to be value<br>&gt;&gt;&gt;&gt; preserving, but current Cocoa implementations are not.<br>&gt;&gt;&gt;&gt; 2. ‘Description’ doesn’t really convey the meaning of ‘value<br>&gt;&gt;&gt;&gt; preserving’ in my mind, but is a valuable name for many other use cases.<br>&gt;&gt;&gt;&gt; 3. Swift 3 has a wide range of breaking changes for the better.<br>&gt;&gt;&gt;&gt; 4. With the presence of ValuePreservingStringConvertible,<br>&gt;&gt;&gt;&gt; CustomStringConvertible doesn’t seem to provide much value over<br>&gt;&gt;&gt;&gt; CustomDebugStringConvertible?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; For string interpolation, I imagine the standard library could fall<br>&gt;&gt;&gt;&gt; back to a ‘description’ method for NSObject subclasses.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Patrick<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On 28 May 2016, at 7:49 AM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; on Thu May 26 2016, Patrick Smith &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; On 27 May 2016, at 2:40 PM, Austin Zheng via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; Any of the NSObject subclass candidates may require their<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; `description`s to be altered to meet the semantics, which may or may<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; not be an acceptable breaking change.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Do you think it might be worth changing `description` to be named<br>&gt;&gt;&gt;&gt; &gt;&gt; something else? Something more clear, less likely to conflict with<br>&gt;&gt;&gt;&gt; &gt;&gt; ‘real’ properties — ‘description’ doesn’t seem to portray something<br>&gt;&gt;&gt;&gt; &gt;&gt; that is value-preserving. What is the reason for calling it<br>&gt;&gt;&gt;&gt; &gt;&gt; ‘description’?<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; The main reason was backward compatibility with Cocoa, which already<br>&gt;&gt;&gt;&gt; has<br>&gt;&gt;&gt;&gt; &gt; a “description” property.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Especially if NSObject subclasses won’t fit, then why not have a<br>&gt;&gt;&gt;&gt; &gt;&gt; different method that can be strictly value preserving? (Then<br>&gt;&gt;&gt;&gt; &gt;&gt; `description` can stay being an NSObject thing.)<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt;&gt; &gt; Dave<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/0e68c4d6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 28, 2016 at 01:00:00pm</p></header><div class="content"><p>On May 27, 2016, at 9:10 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Does &quot;lossless&quot; preclude floating-point numbers from being printed in decimal unless they are exactly representable?<br></p><p>No, FP types should be able to conform.  There are algorithms that are guaranteed to turn IEEE floating point values into a decimal representation in a reversible way.  <br></p><p>I don’t think we care about NaN payloads, but an encoding could be created for them as well.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 27, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; https://github.com/austinzheng/swift-evolution/blob/az-edit-89/proposals/0089-rename-string-reflection-init.md<br></p><p>I prefer the more conservative and backwards-compatible option of using `description` and conforming `ValuePreservingStringConvertible` to `CustomStringConvertible`. <br></p><p>This is for three reasons:<br></p><p>* ValuePreservingStringConvertible really is a refinement of CustomStringConvertible&#39;s semantic; a value-preserving `description` should always be acceptable as an ordinary `description`.<br></p><p>* You should not call `description` directly anyway; you should call `String.init(_:)`. That makes the arguably non-descriptive name a lot less important.<br></p><p>* Changing the name of this property now will not actually make `description` available for the uses you want to put it to in most code. No amount of monkeying with the Swift standard library in 2016 can change the fact that the OpenStep specification took that name in 1994, and we need to interoperate with that heritage. You might free up the name `description` in value types and Linux-only code, but only at the cost of interoperability headaches. I don&#39;t think that&#39;s worth it.<br></p><p>I also think that, if we&#39;re serious about ValuePreservingStringConvertible&#39;s initializer restoring the full state of the instance, then it is a full-width conversion and doesn&#39;t need a label.<br></p><p>So, here&#39;s what I suggest:<br></p><p>	protocol CustomStringConvertible {<br>		var description: String { get }<br>	}<br>	protocol ValuePreservingStringConvertible: CustomStringConvertible {<br>		init?(_ description: String)<br>	}<br>	extension String {<br>		init&lt;Value: ValuePreservingStringConvertible&gt;(_ value: Value) { ... }<br>		init&lt;Value&gt;(describing value: Value) { ... }<br>	}<br></p><p>Actually, I&#39;d *like* to see `String.init(describing:)` constrained to CustomStringConvertible, but I&#39;ve lost that argument before.<br></p><p>(&quot;Lossless&quot; instead of &quot;ValuePreserving&quot; is fine too, perhaps even slightly better.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 28, 2016 at 05:00:00am</p></header><div class="content"><p>I don&#39;t recall whether it was in this thread or another that this point was<br>made by the core team, but if I&#39;m remembering correctly: it was shared that<br>the protocol is now called CustomStringConvertible because conforming types<br>provide a *custom* description, not merely an ordinary description.<br></p><p>If we follow that reasoning, ValuePreservingStringConvertible should *not*<br>conform to CustomStringConvertible, because whether the description is<br>value-preserving is orthogonal to whether it has been customized.<br></p><p>But I share your concern that attempting to delete description from Swift<br>will only increase interoperability headaches rather than freeing the name<br>for other uses.<br></p><p>On Sat, May 28, 2016 at 00:36 Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt;<br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-edit-89/proposals/0089-rename-string-reflection-init.md<br>&gt;<br>&gt; I prefer the more conservative and backwards-compatible option of using<br>&gt; `description` and conforming `ValuePreservingStringConvertible` to<br>&gt; `CustomStringConvertible`.<br>&gt;<br>&gt; This is for three reasons:<br>&gt;<br>&gt; * ValuePreservingStringConvertible really is a refinement of<br>&gt; CustomStringConvertible&#39;s semantic; a value-preserving `description` should<br>&gt; always be acceptable as an ordinary `description`.<br>&gt;<br>&gt; * You should not call `description` directly anyway; you should call<br>&gt; `String.init(_:)`. That makes the arguably non-descriptive name a lot less<br>&gt; important.<br>&gt;<br>&gt; * Changing the name of this property now will not actually make<br>&gt; `description` available for the uses you want to put it to in most code. No<br>&gt; amount of monkeying with the Swift standard library in 2016 can change the<br>&gt; fact that the OpenStep specification took that name in 1994, and we need to<br>&gt; interoperate with that heritage. You might free up the name `description`<br>&gt; in value types and Linux-only code, but only at the cost of<br>&gt; interoperability headaches. I don&#39;t think that&#39;s worth it.<br>&gt;<br>&gt; I also think that, if we&#39;re serious about<br>&gt; ValuePreservingStringConvertible&#39;s initializer restoring the full state of<br>&gt; the instance, then it is a full-width conversion and doesn&#39;t need a label.<br>&gt;<br>&gt; So, here&#39;s what I suggest:<br>&gt;<br>&gt;         protocol CustomStringConvertible {<br>&gt;                 var description: String { get }<br>&gt;         }<br>&gt;         protocol ValuePreservingStringConvertible: CustomStringConvertible<br>&gt; {<br>&gt;                 init?(_ description: String)<br>&gt;         }<br>&gt;         extension String {<br>&gt;                 init&lt;Value: ValuePreservingStringConvertible&gt;(_ value:<br>&gt; Value) { ... }<br>&gt;                 init&lt;Value&gt;(describing value: Value) { ... }<br>&gt;         }<br>&gt;<br>&gt; Actually, I&#39;d *like* to see `String.init(describing:)` constrained to<br>&gt; CustomStringConvertible, but I&#39;ve lost that argument before.<br>&gt;<br>&gt; (&quot;Lossless&quot; instead of &quot;ValuePreserving&quot; is fine too, perhaps even<br>&gt; slightly better.)<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/73f4d522/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 28, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 28, 2016, at 7:49 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I don&#39;t recall whether it was in this thread or another that this point was made by the core team, but if I&#39;m remembering correctly: it was shared that the protocol is now called CustomStringConvertible because conforming types provide a *custom* description, not merely an ordinary description.<br>&gt; <br>&gt; If we follow that reasoning, ValuePreservingStringConvertible should *not* conform to CustomStringConvertible, because whether the description is value-preserving is orthogonal to whether it has been customized.<br>&gt; <br></p><p>IMO &quot;Custom&quot; evoques a general set, of which &quot;ValuePreserving&quot; is a subset.<br></p><p>&gt; But I share your concern that attempting to delete description from Swift will only increase interoperability headaches rather than freeing the name for other uses.<br>&gt; <br>&gt;&gt; On Sat, May 28, 2016 at 00:36 Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; https://github.com/austinzheng/swift-evolution/blob/az-edit-89/proposals/0089-rename-string-reflection-init.md<br>&gt;&gt; <br>&gt;&gt; I prefer the more conservative and backwards-compatible option of using `description` and conforming `ValuePreservingStringConvertible` to `CustomStringConvertible`.<br>&gt;&gt; <br>&gt;&gt; This is for three reasons:<br>&gt;&gt; <br>&gt;&gt; * ValuePreservingStringConvertible really is a refinement of CustomStringConvertible&#39;s semantic; a value-preserving `description` should always be acceptable as an ordinary `description`.<br>&gt;&gt; <br>&gt;&gt; * You should not call `description` directly anyway; you should call `String.init(_:)`. That makes the arguably non-descriptive name a lot less important.<br>&gt;&gt; <br>&gt;&gt; * Changing the name of this property now will not actually make `description` available for the uses you want to put it to in most code. No amount of monkeying with the Swift standard library in 2016 can change the fact that the OpenStep specification took that name in 1994, and we need to interoperate with that heritage. You might free up the name `description` in value types and Linux-only code, but only at the cost of interoperability headaches. I don&#39;t think that&#39;s worth it.<br>&gt;&gt; <br>&gt;&gt; I also think that, if we&#39;re serious about ValuePreservingStringConvertible&#39;s initializer restoring the full state of the instance, then it is a full-width conversion and doesn&#39;t need a label.<br>&gt;&gt; <br>&gt;&gt; So, here&#39;s what I suggest:<br>&gt;&gt; <br>&gt;&gt;         protocol CustomStringConvertible {<br>&gt;&gt;                 var description: String { get }<br>&gt;&gt;         }<br>&gt;&gt;         protocol ValuePreservingStringConvertible: CustomStringConvertible {<br>&gt;&gt;                 init?(_ description: String)<br>&gt;&gt;         }<br>&gt;&gt;         extension String {<br>&gt;&gt;                 init&lt;Value: ValuePreservingStringConvertible&gt;(_ value: Value) { ... }<br>&gt;&gt;                 init&lt;Value&gt;(describing value: Value) { ... }<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; Actually, I&#39;d *like* to see `String.init(describing:)` constrained to CustomStringConvertible, but I&#39;ve lost that argument before.<br>&gt;&gt; <br>&gt;&gt; (&quot;Lossless&quot; instead of &quot;ValuePreserving&quot; is fine too, perhaps even slightly better.)<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/e939a01b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 28, 2016 at 10:00:00am</p></header><div class="content"><p>-1   I like the original design for the fact that it does not give &quot;description&quot;, which nobody would have proposed Swift had started as a blank slate, center stage: promoting it to protocol membership would perpetuate something that people should no longer be focussing on. So although I do prefer definition over convention, this is an exception I do not mind making.<br></p><p>-1   for Lossless. ValuePreserving is clear as to WHAT it does, LossLess describes HOW it operates, relegating the value preservation to being a side effect that people have to infer themselves: &quot;if this thing operates in a loss less manner, then I must be getting back what I put in&quot;.<br></p><p><br>On May 28, 2016, at 6:36 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-edit-89/proposals/0089-rename-string-reflection-init.md<br>&gt; <br>&gt; I prefer the more conservative and backwards-compatible option of using `description` and conforming `ValuePreservingStringConvertible` to `CustomStringConvertible`. <br>&gt; <br>&gt; This is for three reasons:<br>&gt; <br>&gt; * ValuePreservingStringConvertible really is a refinement of CustomStringConvertible&#39;s semantic; a value-preserving `description` should always be acceptable as an ordinary `description`.<br>&gt; <br>&gt; * You should not call `description` directly anyway; you should call `String.init(_:)`. That makes the arguably non-descriptive name a lot less important.<br>&gt; <br>&gt; * Changing the name of this property now will not actually make `description` available for the uses you want to put it to in most code. No amount of monkeying with the Swift standard library in 2016 can change the fact that the OpenStep specification took that name in 1994, and we need to interoperate with that heritage. You might free up the name `description` in value types and Linux-only code, but only at the cost of interoperability headaches. I don&#39;t think that&#39;s worth it.<br>&gt; <br>&gt; I also think that, if we&#39;re serious about ValuePreservingStringConvertible&#39;s initializer restoring the full state of the instance, then it is a full-width conversion and doesn&#39;t need a label.<br>&gt; <br>&gt; So, here&#39;s what I suggest:<br>&gt; <br>&gt;    protocol CustomStringConvertible {<br>&gt;        var description: String { get }<br>&gt;    }<br>&gt;    protocol ValuePreservingStringConvertible: CustomStringConvertible {<br>&gt;        init?(_ description: String)<br>&gt;    }<br>&gt;    extension String {<br>&gt;        init&lt;Value: ValuePreservingStringConvertible&gt;(_ value: Value) { ... }<br>&gt;        init&lt;Value&gt;(describing value: Value) { ... }<br>&gt;    }<br>&gt; <br>&gt; Actually, I&#39;d *like* to see `String.init(describing:)` constrained to CustomStringConvertible, but I&#39;ve lost that argument before.<br>&gt; <br>&gt; (&quot;Lossless&quot; instead of &quot;ValuePreserving&quot; is fine too, perhaps even slightly better.)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 28, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 9:36 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-edit-89/proposals/0089-rename-string-reflection-init.md<br>&gt; <br>&gt; I prefer the more conservative and backwards-compatible option of using `description` and conforming `ValuePreservingStringConvertible` to `CustomStringConvertible`. <br>&gt; <br>&gt; This is for three reasons:<br></p><p>+1 to all of your points.<br></p><p>&gt; (&quot;Lossless&quot; instead of &quot;ValuePreserving&quot; is fine too, perhaps even slightly better.)<br></p><p>I agree, even though Lossless seems less specific, it does seem like it would feel more comfortable sitting next to “Custom”.<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 28, 2016 at 02:00:00pm</p></header><div class="content"><p>Some feedback:<br></p><p>I wonder if ValuePreservingStringConvertible having an initializer restricts its use case at all? Plus, ValuePreservingStringConvertible seems very similar to RawRepresentable with a RawValue of String.<br></p><p>Lossless sounds nice to me. Or ‘canonical’ I had wondered, but lossless sounds better.<br></p><p>• The standard library will be audited. Any type which can be reasonably represented as a string in a value-preserving way will be modified to conform to ValuePreservingStringConvertible. If they conform to CustomStringConvertible and their existing description is value-preserving, stringRepresentation will simply return description.<br>---<br>I think this should instead say description will simply return stringRepresentation, as it is more of a source of truth, and description is derivative<br></p><p>• CustomStringConvertible will provide a human-readable description of an instance. It may provide as little or as much detail as deemed appropriate.<br>• CustomDebugStringConvertible will provide a human-readable description of an instance. It can provide additional information relative to CustomStringConvertible, information that would not be pertinent for consumers of descriptions (such as human readers or other APIs), but would be useful for development or diagnostic purposes.<br>---<br>I think this reasoning for having both CustomStringConvertible and CustomDebugStringConvertible doesn’t really hold up. It’s a little bit vague. If it’s for an API, then the lossless value is the better choice. If it’s for people, then either a localised value (which description is not) or the lossless string representation is a better choice.<br></p><p>I know I keep repeating this, but I can’t see any use cases for a ‘description’ property. I think ‘stringRepresentation’ and ‘debugDescription’ cover all use cases. The ‘description’ property is never accessed by developers, instead as the Swift team’s feedback said `String.init&lt;T&gt;(describing: T)` or `&quot;\(interpolation)&quot;` is to be used, and I think they can detect and fallback to `NSObject.description’ for Objective-C objects, e.g. in _print_unlocked() here: https://github.com/apple/swift/blob/cf73dd9177c231a15429b08ae889e94f20e53f50/stdlib/public/core/OutputStream.swift#L319<br></p><p>Not having ‘description’ taken means we can create a struct like so without clashing:<br></p><p>struct Channel {<br>  let title: String<br>  let link: NSURL<br>  let description: String<br>}<br></p><p>Patrick<br> <br></p><p>&gt; On 28 May 2016, at 1:51 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hello swift-evolution,<br>&gt; <br>&gt; I&#39;ve put together a preliminary v2 of the proposal, taking into account feedback expressed on this thread. I would appreciate any comments, suggestions, or criticisms.<br>&gt; <br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-edit-89/proposals/0089-rename-string-reflection-init.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-edit-89/proposals/0089-rename-string-reflection-init.md&gt;<br>&gt; <br>&gt; If any objections can be worked out quickly, I hope to resubmit this proposal for review early next week.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; On Fri, May 27, 2016 at 7:50 PM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Is there any possibility we can break from this? Especially as:<br>&gt; <br>&gt; 1. ValuePreservingStringConvertible expects its description to be value preserving, but current Cocoa implementations are not.<br>&gt; 2. ‘Description’ doesn’t really convey the meaning of ‘value preserving’ in my mind, but is a valuable name for many other use cases.<br>&gt; 3. Swift 3 has a wide range of breaking changes for the better.<br>&gt; 4. With the presence of ValuePreservingStringConvertible, CustomStringConvertible doesn’t seem to provide much value over CustomDebugStringConvertible?<br>&gt; <br>&gt; For string interpolation, I imagine the standard library could fall back to a ‘description’ method for NSObject subclasses.<br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; Patrick<br>&gt; <br>&gt; &gt; On 28 May 2016, at 7:49 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; on Thu May 26 2016, Patrick Smith &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; On 27 May 2016, at 2:40 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Any of the NSObject subclass candidates may require their<br>&gt; &gt;&gt;&gt; `description`s to be altered to meet the semantics, which may or may<br>&gt; &gt;&gt;&gt; not be an acceptable breaking change.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Do you think it might be worth changing `description` to be named<br>&gt; &gt;&gt; something else? Something more clear, less likely to conflict with<br>&gt; &gt;&gt; ‘real’ properties — ‘description’ doesn’t seem to portray something<br>&gt; &gt;&gt; that is value-preserving. What is the reason for calling it<br>&gt; &gt;&gt; ‘description’?<br>&gt; &gt;<br>&gt; &gt; The main reason was backward compatibility with Cocoa, which already has<br>&gt; &gt; a “description” property.<br>&gt; &gt;<br>&gt; &gt;&gt; Especially if NSObject subclasses won’t fit, then why not have a<br>&gt; &gt;&gt; different method that can be strictly value preserving? (Then<br>&gt; &gt;&gt; `description` can stay being an NSObject thing.)<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Dave<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/db68e1cc/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 28, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 8:51 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello swift-evolution,<br>&gt; <br>&gt; I&#39;ve put together a preliminary v2 of the proposal, taking into account feedback expressed on this thread. I would appreciate any comments, suggestions, or criticisms.<br>&gt; <br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-edit-89/proposals/0089-rename-string-reflection-init.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-edit-89/proposals/0089-rename-string-reflection-init.md&gt;<br>&gt; <br>&gt; If any objections can be worked out quickly, I hope to resubmit this proposal for review early next week.<br></p><p>Thank you for doing this Austin!<br></p><p>Here are some random comments:<br></p><p>&quot;which accidentally invokes this initializer by accident” -&gt; &quot;which accidentally invokes this initializer”<br></p><p><br>&quot;A new protocol will be introduced: ValuePreservingStringConvertible. “ -&gt; Thanks for adding the init requirement.  It might be worth mentioning up at top that an alternative name to consider is “LosslessStringConvertible”.  <br></p><p>&quot;protocol ValuePreservingStringConvertible {“ -&gt; &quot;protocol ValuePreservingStringConvertible : CustomStringConvertible {&quot;<br></p><p>&quot; var stringRepresentation : String { get }&quot;<br></p><p>Just speaking for my opinion, but I think this is better to keep as description.  We don’t want multiple different string forms, because at the end of the day string literal interpolation and print need to do “something”, and description should be that default form.  If that form isn’t lossless, then the type shouldn’t have access to the labelless string initializer.<br></p><p>  init?(stringRepresentation: String)<br></p><p>Since this is a lossless conversion when it succeeds, it should be unlabeled.<br></p><p>&quot;The standard library will be audited.&quot;<br></p><p>This is prescriptive statement: the proposal should include the actual list of types in the stdlib.<br></p><p>&quot;The Foundation SDK overlay will be audited in the same manner.”<br></p><p>-&gt; Foundation is handled separately, it should be left out of the proposal.<br></p><p><br></p><p>&quot;If they conform to CustomStringConvertible and their existing description is value-preserving, stringRepresentation will simply return description.&quot;<br></p><p>With the structure above, this isn’t necessary.<br></p><p><br>Thank you for driving this forward Austin!<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/f1b018be/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 28, 2016 at 01:00:00pm</p></header><div class="content"><p>Thanks!<br></p><p>The PR I submitted earlier should have an updated version of the proposal which takes most of your feedback into account. I&#39;ll amend it later to address the rest. <br></p><p>Sent from my iPhone<br></p><p>&gt; On May 28, 2016, at 1:33 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 27, 2016, at 8:51 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello swift-evolution,<br>&gt;&gt; <br>&gt;&gt; I&#39;ve put together a preliminary v2 of the proposal, taking into account feedback expressed on this thread. I would appreciate any comments, suggestions, or criticisms.<br>&gt;&gt; <br>&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-edit-89/proposals/0089-rename-string-reflection-init.md<br>&gt;&gt; <br>&gt;&gt; If any objections can be worked out quickly, I hope to resubmit this proposal for review early next week.<br>&gt; <br>&gt; Thank you for doing this Austin!<br>&gt; <br>&gt; Here are some random comments:<br>&gt; <br>&gt; &quot;which accidentally invokes this initializer by accident” -&gt; &quot;which accidentally invokes this initializer”<br>&gt; <br>&gt; <br>&gt; &quot;A new protocol will be introduced: ValuePreservingStringConvertible. “ -&gt; Thanks for adding the init requirement.  It might be worth mentioning up at top that an alternative name to consider is “LosslessStringConvertible”.  <br>&gt; <br>&gt; &quot;protocol ValuePreservingStringConvertible {“ -&gt; &quot;protocol ValuePreservingStringConvertible : CustomStringConvertible {&quot;<br>&gt; <br>&gt; &quot; var stringRepresentation : String { get }&quot;<br>&gt; <br>&gt; Just speaking for my opinion, but I think this is better to keep as description.  We don’t want multiple different string forms, because at the end of the day string literal interpolation and print need to do “something”, and description should be that default form.  If that form isn’t lossless, then the type shouldn’t have access to the labelless string initializer.<br>&gt; <br>&gt;   init?(stringRepresentation: String)<br>&gt; <br>&gt; Since this is a lossless conversion when it succeeds, it should be unlabeled.<br>&gt; <br>&gt; &quot;The standard library will be audited.&quot;<br>&gt; <br>&gt; This is prescriptive statement: the proposal should include the actual list of types in the stdlib.<br>&gt; <br>&gt; &quot;The Foundation SDK overlay will be audited in the same manner.”<br>&gt; <br>&gt; -&gt; Foundation is handled separately, it should be left out of the proposal.<br>&gt; <br>&gt; <br>&gt; <br>&gt; &quot;If they conform to CustomStringConvertible and their existing description is value-preserving, stringRepresentation will simply return description.&quot;<br>&gt; <br>&gt; With the structure above, this isn’t necessary.<br>&gt; <br>&gt; <br>&gt; Thank you for driving this forward Austin!<br>&gt; <br>&gt; -Chris<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/33eb326d/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 28, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 7:50 PM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Is there any possibility we can break from this? Especially as:<br>&gt; <br>&gt; 1. ValuePreservingStringConvertible expects its description to be value preserving, but current Cocoa implementations are not.<br>&gt; 2. ‘Description’ doesn’t really convey the meaning of ‘value preserving’ in my mind, but is a valuable name for many other use cases.<br>&gt; 3. Swift 3 has a wide range of breaking changes for the better.<br>&gt; 4. With the presence of ValuePreservingStringConvertible, CustomStringConvertible doesn’t seem to provide much value over CustomDebugStringConvertible?<br>&gt; <br>&gt; For string interpolation, I imagine the standard library could fall back to a ‘description’ method for NSObject subclasses.<br></p><p>Personally, independent of the Cocoa precedent, I think that keeping “description” as the requirement of ValuePreservingStringConvertible is the right thing to do.<br></p><p>Here is the proposed schema (ignoring the related but different “debug description”):<br></p><p>1) Values can always be converted to a string in Swift through reflection.<br>2) If a value wants a better, or more customized, string form, then it conforms to CustomStringConvertible.<br>3) If that string form is value preserving, it conforms to ValuePreservingStringConvertible, which is a refinement of CustomStringConvertible.<br></p><p>In other words, this approach is saying that a value may be convertible to string in exactly one way.  If that way is value preserving (i.e., can be reversed as DaveA suggests) then it can do so by conforming to the more specific protocol.  The advantage of doing this is that it is now eligible for the String(x) syntax.<br></p><p>This seems clean and simple.  The only advantage to adding a new “stringRepresentation” requirement is if you wanted “description” to return one thing, but “stringRepresentation” to return another thing.  There may be use cases for such a thing, but to me it just seems like new complexity added to the model for very little gain.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 29, 2016 at 03:00:00pm</p></header><div class="content"><p>Thanks for replying Chris!<br></p><p>&gt; On 29 May 2016, at 6:00 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; 2) If a value wants a better, or more customized, string form, then it conforms to CustomStringConvertible.<br></p><p><br>What are the use cases for this more customized string form? If it is for the programmer, then debugDescription seems to be a better fit? For Playgrounds, the CustomPlaygroundQuickLookable protocol is used.<br></p><p>What are its other use cases? APIs? What about Streamable? Does this not take the same responsibility — it converts the receiver into a string? Here it seems like it trumps CustomStringConvertible with string conversion: https://github.com/apple/swift/blob/cf73dd9177c231a15429b08ae889e94f20e53f50/stdlib/public/core/OutputStream.swift#L332<br></p><p>Patrick<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 29, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 28, 2016, at 10:46 PM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt; <br>&gt; Thanks for replying Chris!<br>&gt; <br>&gt;&gt; On 29 May 2016, at 6:00 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 2) If a value wants a better, or more customized, string form, then it conforms to CustomStringConvertible.<br>&gt; <br>&gt; <br>&gt; What are the use cases for this more customized string form?<br></p><p>print() and string interpolation use it.  You conform to it and implement it when you want something specific to your type, otherwise you get the default reflection based implementation.  The reflection implementation is better than nothing, but usually not what you want.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 30, 2016 at 02:00:00pm</p></header><div class="content"><p>Thanks Chris. I just meant where is that string going?<br></p><p>To a developer -&gt; CustomDebugStringConvertible / Reflection<br>To standard output -&gt; Streamable<br>To a user -&gt; NSLocalizedString — no protocol (yet?)<br>To an API / for serialisation -&gt; LosslessStringConvertible<br>To a playground -&gt; CustomPlaygroundQuickLookable<br></p><p>CustomStringConvertible is left over, but doesn’t have a use case? Unless it’s an alternative to Streamable, but then why have Streamable? People will use ‘description’ for multiple use cases, which makes sense when you are both a developer and a user, or your users are developers like with a command-line tool, so there doesn’t seem to be any grey. But I believe there is, and that it is beneficial to pin it to one of the use cases above, and to have dedicated clear-cut protocols for each use case.<br></p><p>I’m not sure if anyone else shares the concern, so I’ll leave it. I do believe it’s important however.<br></p><p>Patrick<br></p><p>&gt; On 30 May 2016, at 5:16 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 28, 2016, at 10:46 PM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for replying Chris!<br>&gt;&gt; <br>&gt;&gt;&gt; On 29 May 2016, at 6:00 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2) If a value wants a better, or more customized, string form, then it conforms to CustomStringConvertible.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What are the use cases for this more customized string form?<br>&gt; <br>&gt; print() and string interpolation use it.  You conform to it and implement it when you want something specific to your type, otherwise you get the default reflection based implementation.  The reflection implementation is better than nothing, but usually not what you want.<br>&gt; <br>&gt; -Chris<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 29, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Thanks Chris. I just meant where is that string going?<br>&gt; <br>&gt; To a developer -&gt; CustomDebugStringConvertible / Reflection<br>&gt; To standard output -&gt; Streamable<br>&gt; To a user -&gt; NSLocalizedString — no protocol (yet?)<br>&gt; To an API / for serialisation -&gt; LosslessStringConvertible<br>&gt; To a playground -&gt; CustomPlaygroundQuickLookable<br>&gt; <br>&gt; CustomStringConvertible is left over, but doesn’t have a use case? Unless it’s an alternative to Streamable, but then why have Streamable?<br></p><p>There are *very* few conformances to Streamable in the standard library—just Character, String, and UnicodeScalar. I think that Streamable is for data that can be *directly* written to an output stream, whereas CustomStringConvertible is a way to convert an instance that *isn&#39;t* directly Streamable into something Streamable.<br></p><p>So, here&#39;s my version of your table:<br></p><p>User-readable, nonlocalized: CustomStringConvertible<br>User- and machine-readable, nonlocalized: LosslessStringConvertible<br>User-readable, localized: (nothing)<br>Developer-readable: CustomDebugStringConvertible<br></p><p>(Playground isn&#39;t necessarily working with strings, so it doesn&#39;t belong in this list.)<br></p><p>Localization is an obvious hole in our string conversions, but I think the reality here is that localization is part of a higher layer than the standard library. From what I can see, all of the &quot;standard library&quot; APIs which handle localization are actually part of Foundation. I&#39;m sure that, if we build any localization-related features into the language, we&#39;ll add basic supporting code to the standard library if needed, but other than that, I don&#39;t think the standard library is the right place.<br></p><p>&gt; I’m not sure if anyone else shares the concern, so I’ll leave it. I do believe it’s important however.<br></p><p>I do think this is an important concern, and I also think it&#39;s important to ask how interpolation interacts with it. For instance, I think it would be very useful to be able to say &quot;interpolate developer representations&quot; or &quot;interpolate user representations&quot; or &quot;interpolate localized user representations&quot;, and have the compiler reject interpolated expressions which don&#39;t have the necessary representation.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>May 29, 2016 at 11:00:00pm</p></header><div class="content"><p>On Sun, May 29, 2016 at 11:23 PM, Brent Royal-Gordon via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; There are *very* few conformances to Streamable in the standard library—just Character, String, and UnicodeScalar. I think that Streamable is for data that can be *directly* written to an output stream, whereas CustomStringConvertible is a way to convert an instance that *isn&#39;t* directly Streamable into something Streamable.<br></p><p>Right, this was the intent.  The intent was that Streamable is<br>something that is a container of string-like data, as opposed to other<br>things that have-a string representation.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June  1, 2016 at 06:00:00pm</p></header><div class="content"><p>Thank you Brent. I like your points, and agree that localisation is not a simple problem. Also interesting to see the latest discussion (from Vladimir, Dave, Austin, and Hooman).<br></p><p>Replied inline below:<br></p><p>&gt; On 30 May 2016, at 4:23 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Thanks Chris. I just meant where is that string going?<br>&gt;&gt; <br>&gt;&gt; To a developer -&gt; CustomDebugStringConvertible / Reflection<br>&gt;&gt; To standard output -&gt; Streamable<br>&gt;&gt; To a user -&gt; NSLocalizedString — no protocol (yet?)<br>&gt;&gt; To an API / for serialisation -&gt; LosslessStringConvertible<br>&gt;&gt; To a playground -&gt; CustomPlaygroundQuickLookable<br>&gt;&gt; <br>&gt;&gt; CustomStringConvertible is left over, but doesn’t have a use case? Unless it’s an alternative to Streamable, but then why have Streamable?<br>&gt; <br>&gt; There are *very* few conformances to Streamable in the standard library—just Character, String, and UnicodeScalar. I think that Streamable is for data that can be *directly* written to an output stream, whereas CustomStringConvertible is a way to convert an instance that *isn&#39;t* directly Streamable into something Streamable.<br></p><p>OK, that’s an interesting distinction (and interesting protocol in Streamable — it feels as though it has some functionality to come).<br></p><p>For developers, like ourselves, it seems straight-forward that a string is this simple primitive. We get them in, we process them, and we spit them back out. However, this is a flawed system, as it one that is made easiest for the programmer, and is really designed for a context where the user is also a programmer. It best suits technical scenarios such as configuration files, environment variables, and command line arguments, as Brent suggests. However, I don’t think this is the best case to design for.<br></p><p>&gt; <br>&gt; So, here&#39;s my version of your table:<br>&gt; <br>&gt; User-readable, nonlocalized: CustomStringConvertible<br>&gt; User- and machine-readable, nonlocalized: LosslessStringConvertible<br>&gt; User-readable, localized: (nothing)<br>&gt; Developer-readable: CustomDebugStringConvertible<br>&gt; <br>&gt; (Playground isn&#39;t necessarily working with strings, so it doesn&#39;t belong in this list.)<br></p><p>The first item in your table ‘User-readable, non-localised’, is the big problem area to me. Ideally in my mind all of these should be moved to other areas, such as the second area that LosslessStringConvertible occupies, which command line arguments and configuration keys certainly could. And user-readable should use a system that always allows localisation to be added progressively, by use of type extensions or protocols.<br></p><p>In a UI application, everything that is displayed should be using a system which allows localisation. I would argue a command line tool is also a UI application. I would not advocate for a full-on locale system like the one Foundation has to be brought to the Swift standard library (unless eventually it’s easy to integrate a standard a la Unicode).<br></p><p>&gt; Localization is an obvious hole in our string conversions, but I think the reality here is that localization is part of a higher layer than the standard library. From what I can see, all of the &quot;standard library&quot; APIs which handle localization are actually part of Foundation. I&#39;m sure that, if we build any localization-related features into the language, we&#39;ll add basic supporting code to the standard library if needed, but other than that, I don&#39;t think the standard library is the right place.<br></p><p>I believe best practices can be put in place with a system no more complicated for the programmer than the one we have now. This could be possible with protocols: a core protocols in the standard library that are then fleshed out in a Foundation-level framework above, with Locale / CultureCode / etc types extending or conforming.<br></p><p>&gt; <br>&gt;&gt; I’m not sure if anyone else shares the concern, so I’ll leave it. I do believe it’s important however.<br>&gt; <br>&gt; I do think this is an important concern, and I also think it&#39;s important to ask how interpolation interacts with it. For instance, I think it would be very useful to be able to say &quot;interpolate developer representations&quot; or &quot;interpolate user representations&quot; or &quot;interpolate localized user representations&quot;, and have the compiler reject interpolated expressions which don&#39;t have the necessary representation.<br></p><p>I like this idea. I think “interpolate localised user representations” should not be distinct from “interpolate user representations”. Instead non-localised is specifically denoted as ‘technical’ or perhaps ‘en-US’. Locales, or more broadly ‘contexts’, are not something additional, instead, everything already has a context, and the context of a string could be made more explicit.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  4, 2016 at 11:00:00pm</p></header><div class="content"><p>Sorry, I meant to reply to this but forgot.<br></p><p>&gt; For developers, like ourselves, it seems straight-forward that a string is this simple primitive. We get them in, we process them, and we spit them back out. However, this is a flawed system, as it one that is made easiest for the programmer, and is really designed for a context where the user is also a programmer. It best suits technical scenarios such as configuration files, environment variables, and command line arguments, as Brent suggests. However, I don’t think this is the best case to design for.<br></p><p>It is *a* case we need to design for. It is also the *base* case: localization is layered on top of non-localized constructs.<br></p><p>&gt;&gt; So, here&#39;s my version of your table:<br>&gt;&gt; <br>&gt;&gt; User-readable, nonlocalized: CustomStringConvertible<br>&gt;&gt; User- and machine-readable, nonlocalized: LosslessStringConvertible<br>&gt;&gt; User-readable, localized: (nothing)<br>&gt;&gt; Developer-readable: CustomDebugStringConvertible<br>&gt;&gt; <br>&gt;&gt; (Playground isn&#39;t necessarily working with strings, so it doesn&#39;t belong in this list.)<br>&gt; <br>&gt; The first item in your table ‘User-readable, non-localised’, is the big problem area to me. Ideally in my mind all of these should be moved to other areas, such as the second area that LosslessStringConvertible occupies, which command line arguments and configuration keys certainly could. And user-readable should use a system that always allows localisation to be added progressively, by use of type extensions or protocols.<br>&gt; <br>&gt; In a UI application, everything that is displayed should be using a system which allows localisation.<br></p><p>In theory, yes. In practice? We write code that will be used only once (like an ad-hoc fix for some problem). We write code that will never be exposed to users (like a background process). We write code that is kept in one limited environment (like a company internal app). We write code that simply isn&#39;t going to be localized for business reasons (like an app that wouldn&#39;t be profitable to translate).<br></p><p>We write code that constructs strings without caring what their contents are (think of a Markdown converter). We write code that emits strings which are primarily for machines, but formatted to be convenient for humans—particularly human programmers working with the formats—to understand (think of a reporting tool that emits CSV with column headings in English). We write code where we know everyone will understand a certain language (air traffic control is conducted entirely in English worldwide). We write code that&#39;s too low-level to be localized. We write unit tests (hopefully).<br></p><p>And we write code when we&#39;re just learning how to program, and printing the result of 1 + 2 in French is the last thing on our minds.<br></p><p>So yes, in a meticulously-engineered ideal application, you would have little call for &quot;user-readable, nonlocalized&quot;. But that&#39;s not what people write a lot of the time.<br></p><p>To be clear: If there is a *low-cost* way to make sure that UI text is localizable by default, I&#39;m all for it. (And I even have an idea or two in that area.) But I don&#39;t think bringing localization into the standard library is how you make it low-cost. Remember, Foundation can always add localization to any standard library type it wants through extensions.<br></p><p>&gt; I would argue a command line tool is also a UI application.<br></p><p><br>Sure, but see the above. (Plus, command line tools *do* have a stronger legitimate need for non-localized stuff—think of things like command-line switches and environment variables, communicating over filehandles and pipes, &quot;text&quot; that&#39;s actually UI like twirlers and progress bars, etc.)<br></p><p>&gt;&gt; Localization is an obvious hole in our string conversions, but I think the reality here is that localization is part of a higher layer than the standard library. From what I can see, all of the &quot;standard library&quot; APIs which handle localization are actually part of Foundation. I&#39;m sure that, if we build any localization-related features into the language, we&#39;ll add basic supporting code to the standard library if needed, but other than that, I don&#39;t think the standard library is the right place.<br>&gt; <br>&gt; I believe best practices can be put in place with a system no more complicated for the programmer than the one we have now. This could be possible with protocols: a core protocols in the standard library that are then fleshed out in a Foundation-level framework above, with Locale / CultureCode / etc types extending or conforming.<br></p><p>I&#39;m not sure what the purpose would be of having a protocol in the standard library which didn&#39;t offer even a lick of the promised functionality without a higher-level framework. What do we gain by having `localizedDescription` in the standard library if nothing written against only the standard library can actually emit a localized description? <br></p><p>&gt;&gt;&gt; I’m not sure if anyone else shares the concern, so I’ll leave it. I do believe it’s important however.<br>&gt;&gt; <br>&gt;&gt; I do think this is an important concern, and I also think it&#39;s important to ask how interpolation interacts with it. For instance, I think it would be very useful to be able to say &quot;interpolate developer representations&quot; or &quot;interpolate user representations&quot; or &quot;interpolate localized user representations&quot;, and have the compiler reject interpolated expressions which don&#39;t have the necessary representation.<br>&gt; <br>&gt; I like this idea. I think “interpolate localised user representations” should not be distinct from “interpolate user representations”. Instead non-localised is specifically denoted as ‘technical’ or perhaps ‘en-US’. Locales, or more broadly ‘contexts’, are not something additional, instead, everything already has a context, and the context of a string could be made more explicit.<br></p><p>I mean, you can call it &quot;non-localized&quot; or you can call it &quot;technical&quot;, but a rose by any other name smells just as sweet.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June  5, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 5 Jun 2016, at 4:31 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; Sorry, I meant to reply to this but forgot.<br></p><p>No worries Brent! Thanks for the thoughtful reply.<br></p><p>&gt; <br>&gt;&gt; For developers, like ourselves, it seems straight-forward that a string is this simple primitive. We get them in, we process them, and we spit them back out. However, this is a flawed system, as it one that is made easiest for the programmer, and is really designed for a context where the user is also a programmer. It best suits technical scenarios such as configuration files, environment variables, and command line arguments, as Brent suggests. However, I don’t think this is the best case to design for.<br>&gt; <br>&gt; It is *a* case we need to design for. It is also the *base* case: localization is layered on top of non-localized constructs.<br>&gt; <br>&gt;&gt;&gt; So, here&#39;s my version of your table:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; User-readable, nonlocalized: CustomStringConvertible<br>&gt;&gt;&gt; User- and machine-readable, nonlocalized: LosslessStringConvertible<br>&gt;&gt;&gt; User-readable, localized: (nothing)<br>&gt;&gt;&gt; Developer-readable: CustomDebugStringConvertible<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Playground isn&#39;t necessarily working with strings, so it doesn&#39;t belong in this list.)<br>&gt;&gt; <br>&gt;&gt; The first item in your table ‘User-readable, non-localised’, is the big problem area to me. Ideally in my mind all of these should be moved to other areas, such as the second area that LosslessStringConvertible occupies, which command line arguments and configuration keys certainly could. And user-readable should use a system that always allows localisation to be added progressively, by use of type extensions or protocols.<br>&gt;&gt; <br>&gt;&gt; In a UI application, everything that is displayed should be using a system which allows localisation.<br>&gt; <br>&gt; In theory, yes. In practice? We write code that will be used only once (like an ad-hoc fix for some problem). We write code that will never be exposed to users (like a background process). We write code that is kept in one limited environment (like a company internal app). We write code that simply isn&#39;t going to be localized for business reasons (like an app that wouldn&#39;t be profitable to translate).<br>&gt; <br>&gt; We write code that constructs strings without caring what their contents are (think of a Markdown converter). We write code that emits strings which are primarily for machines, but formatted to be convenient for humans—particularly human programmers working with the formats—to understand (think of a reporting tool that emits CSV with column headings in English). We write code where we know everyone will understand a certain language (air traffic control is conducted entirely in English worldwide). We write code that&#39;s too low-level to be localized. We write unit tests (hopefully).<br>&gt; <br>&gt; And we write code when we&#39;re just learning how to program, and printing the result of 1 + 2 in French is the last thing on our minds.<br>&gt; <br>&gt; So yes, in a meticulously-engineered ideal application, you would have little call for &quot;user-readable, nonlocalized&quot;. But that&#39;s not what people write a lot of the time.<br></p><p>Strings are this very flexible type. Currently the only validations I know of that the String type does are conformance to the various Unicode encodings.<br></p><p>I think it’s similar to pointer safety. A pointer in C can point to anything. The programmer might be sure its valid, but the computer isn’t until it dereferences it. It could be null (crash) or it could be pointing to an already deallocated object or something else entirely (worse than a crash). Swift tries to save us from making these mistakes. Similarly, the programmer could be 100% percent sure her cast will succeed, that this object is of a certain class or conforms to a certain protocol. Swift makes these casts safe, by either crashing immediately or letting the programmer decide what to do with nil, or avoids them by use of generics.<br></p><p>A String in Swift can mean anything. It could be empty, it could be 7000 characters long, it could be formatted incorrectly or contain illegal characters. `String` says as much to me as `id` does in Objective-C. It’s up to me to decide what the meaning is and whether it’s valid yet or not.<br></p><p>I wonder if most data-facing strings could use a string-represented enum or struct instead?<br></p><p>e.g.<br></p><p>enum GitCommand : String {<br>  case clone = &quot;clone&quot;<br>  case init = &quot;init&quot;<br>  case add = &quot;add&quot;<br>  case mv = &quot;mv&quot;<br>  ...<br>}<br></p><p>which can be conveniently shortened to:<br></p><p>enum GitCommand : String {<br>  case clone, init, add, mv, ...<br>}<br></p><p>A initialized GitCommand value can only be valid, which leads to clearer and safer code.<br></p><p>Loose string identifiers such as CSV column headings could use a struct that conforms to RawRepresentable / LosslessStringConvertible. The failable initializer could trim whitespace and validate, and generally conform it into an ideal form. There’s no flags for `isValidated` or assumptions that you bring by using a naked String — if you have an CSVHeading value in hand, you know that it is valid:<br></p><p>struct CSVHeading : RawRepresentable {<br>  typealias RawValue = String<br></p><p>  var rawValue: String<br></p><p>  init?(rawValue: String) {<br>    let trimmed = rawValue.stringByTrimmingCharactersInSet(.whitespaceCharacterSet)<br>    <br>    guard trimmed.rangeOfCharacterFromSet(.illegalCharacterSet) == nil else {<br>      return nil<br>    }<br></p><p>    // More validations here as per https://tools.ietf.org/html/rfc4180<br></p><p>    self.rawValue = trimmed<br>  }<br>}<br></p><p>(This raises a point — what’s the difference between the proposed LosslessStringConvertible and RawRepresentable where RawValue = String? They both have a failable init. Is it due to current limitations with typealiases that makes this hard?)<br></p><p>Swift makes this so easy compared to Objective-C, where you would have worried about the overhead of allocating about a wrapper object. In Swift, as I understand it, a struct with a single String member should be of similar weight in memory and performance to using that String by itself. A whole bunch of them in a typed Collection would take up the same amount of memory?<br></p><p>Note the String type would be still used for a situations such as parsing and formatting. But I don’t think they need to be used for everything where something better constructed can be used. And Formatting could have a whole range of interesting designs too.<br></p><p>&gt; <br>&gt; To be clear: If there is a *low-cost* way to make sure that UI text is localizable by default, I&#39;m all for it. (And I even have an idea or two in that area.) But I don&#39;t think bringing localization into the standard library is how you make it low-cost. Remember, Foundation can always add localization to any standard library type it wants through extensions.<br></p><p>I would love to find a low-cost way because I think Swift opens many opportunities to enable it, has an amazing team of library designers in the Swift standard library and from the Cocoa frameworks, and we have a chance here with a blank canvas to raise the bar like with Swift’s Unicode support. Glad to hear you have some ideas — look forward to hearing them!<br></p><p>&gt; <br>&gt;&gt; I would argue a command line tool is also a UI application.<br>&gt; <br>&gt; <br>&gt; Sure, but see the above. (Plus, command line tools *do* have a stronger legitimate need for non-localized stuff—think of things like command-line switches and environment variables, communicating over filehandles and pipes, &quot;text&quot; that&#39;s actually UI like twirlers and progress bars, etc.)<br>&gt; <br>&gt;&gt;&gt; Localization is an obvious hole in our string conversions, but I think the reality here is that localization is part of a higher layer than the standard library. From what I can see, all of the &quot;standard library&quot; APIs which handle localization are actually part of Foundation. I&#39;m sure that, if we build any localization-related features into the language, we&#39;ll add basic supporting code to the standard library if needed, but other than that, I don&#39;t think the standard library is the right place.<br>&gt;&gt; <br>&gt;&gt; I believe best practices can be put in place with a system no more complicated for the programmer than the one we have now. This could be possible with protocols: a core protocols in the standard library that are then fleshed out in a Foundation-level framework above, with Locale / CultureCode / etc types extending or conforming.<br>&gt; <br>&gt; I&#39;m not sure what the purpose would be of having a protocol in the standard library which didn&#39;t offer even a lick of the promised functionality without a higher-level framework. What do we gain by having `localizedDescription` in the standard library if nothing written against only the standard library can actually emit a localized description?<br></p><p>I had tried to design something as I was writing the email. I wasn’t thinking a `localizedDescription` method (which would rely on global state, an issue with Foundation’s current design), but a context that is used generically or as a type to customise string conversion. Here’s one design idea, but I’m sure there are many others possible:<br></p><p>enum Fruit : String {<br>  case raspberry, guava, passionFruit<br>}<br></p><p>extension Fruit : StringDisplayable {<br>  func toDisplayString(context: Swift.PrintDisplay) -&gt; String { // Extension with `Self : RawRepresentable where RawValue = String` could add this by default one day.<br>    return rawValue<br>  }<br></p><p>  func toDisplayString(context: Foundation.CultureCode.EnglishUS) -&gt; String {<br>    switch self {<br>    case raspberry: return &quot;Raspberry&quot;<br>    case guava: return &quot;Guava&quot;<br>    case passionFruit: return &quot;Passion Fruit&quot;<br>    }<br>  }<br>}<br></p><p>&gt; <br>&gt;&gt;&gt;&gt; I’m not sure if anyone else shares the concern, so I’ll leave it. I do believe it’s important however.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I do think this is an important concern, and I also think it&#39;s important to ask how interpolation interacts with it. For instance, I think it would be very useful to be able to say &quot;interpolate developer representations&quot; or &quot;interpolate user representations&quot; or &quot;interpolate localized user representations&quot;, and have the compiler reject interpolated expressions which don&#39;t have the necessary representation.<br>&gt;&gt; <br>&gt;&gt; I like this idea. I think “interpolate localised user representations” should not be distinct from “interpolate user representations”. Instead non-localised is specifically denoted as ‘technical’ or perhaps ‘en-US’. Locales, or more broadly ‘contexts’, are not something additional, instead, everything already has a context, and the context of a string could be made more explicit.<br>&gt; <br>&gt; I mean, you can call it &quot;non-localized&quot; or you can call it &quot;technical&quot;, but a rose by any other name smells just as sweet.<br></p><p>Non-localised can mean ‘my language’, ‘US english’, ‘we haven’t localised this yet but might in the future’, or ‘a domain-specific key word or phrase’. Technical means just ‘a domain-specific key word or phrase’, and could have the additional properties of losslessness or robustness (conservative in what you send, liberal in what you accept).<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June  5, 2016 at 08:00:00pm</p></header><div class="content"><p>To answer my own question, relooking at the proposal, RawRepresentable wouldn’t be suitable for Bool, Character, UnicodeScalar, Integer, etc.<br></p><p>&gt; On 5 Jun 2016, at 7:20 PM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt; <br>&gt; (This raises a point — what’s the difference between the proposed LosslessStringConvertible and RawRepresentable where RawValue = String? They both have a failable init. Is it due to current limitations with typealiases that makes this hard?)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  5, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; To answer my own question, relooking at the proposal, RawRepresentable wouldn’t be suitable for Bool, Character, UnicodeScalar, Integer, etc.<br>&gt; <br>&gt;&gt; On 5 Jun 2016, at 7:20 PM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; (This raises a point — what’s the difference between the proposed LosslessStringConvertible and RawRepresentable where RawValue = String? They both have a failable init. Is it due to current limitations with typealiases that makes this hard?)<br></p><p>I would add that RawRepresentable does not promise the representation is human-readable.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 30, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; 1) Values can always be converted to a string in Swift through reflection.<br> &gt; 2) If a value wants a better, or more customized, string form, then it <br>conforms to CustomStringConvertible.<br> &gt; 3) If that string form is value preserving, it conforms to <br>ValuePreservingStringConvertible, which is a refinement of <br>CustomStringConvertible.<br></p><p>I can&#39;t understand this. For me ValuePreservingStringConvertible usually <br>will be different than CustomStringConvertible. Can&#39;t I want to have some <br>string view of my struct to present data(also in UI) *and* value preserving <br>string value for the same struct?<br>So my .description will show something like &quot;12.345-6.78&quot; and value <br>preserving string will contain something like <br>&quot;19083749347923847293487293483&quot; to encode the data of the struct. No?<br></p><p>Btw, also I can&#39;t understand how we can use `description` property name to <br>contain &#39;value preserving&#39; string. IMO &#39;description&#39; in this case does not <br>reflect the meaning of contained data.<br></p><p>On 28.05.2016 23:00, Chris Lattner via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On May 27, 2016, at 7:50 PM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Is there any possibility we can break from this? Especially as:<br>&gt;&gt;<br>&gt;&gt; 1. ValuePreservingStringConvertible expects its description to be value preserving, but current Cocoa implementations are not.<br>&gt;&gt; 2. ‘Description’ doesn’t really convey the meaning of ‘value preserving’ in my mind, but is a valuable name for many other use cases.<br>&gt;&gt; 3. Swift 3 has a wide range of breaking changes for the better.<br>&gt;&gt; 4. With the presence of ValuePreservingStringConvertible, CustomStringConvertible doesn’t seem to provide much value over CustomDebugStringConvertible?<br>&gt;&gt;<br>&gt;&gt; For string interpolation, I imagine the standard library could fall back to a ‘description’ method for NSObject subclasses.<br>&gt;<br>&gt; Personally, independent of the Cocoa precedent, I think that keeping “description” as the requirement of ValuePreservingStringConvertible is the right thing to do.<br>&gt;<br>&gt; Here is the proposed schema (ignoring the related but different “debug description”):<br>&gt;<br>&gt; 1) Values can always be converted to a string in Swift through reflection.<br>&gt; 2) If a value wants a better, or more customized, string form, then it conforms to CustomStringConvertible.<br>&gt; 3) If that string form is value preserving, it conforms to ValuePreservingStringConvertible, which is a refinement of CustomStringConvertible.<br>&gt;<br>&gt; In other words, this approach is saying that a value may be convertible to string in exactly one way.  If that way is value preserving (i.e., can be reversed as DaveA suggests) then it can do so by conforming to the more specific protocol.  The advantage of doing this is that it is now eligible for the String(x) syntax.<br>&gt;<br>&gt; This seems clean and simple.  The only advantage to adding a new “stringRepresentation” requirement is if you wanted “description” to return one thing, but “stringRepresentation” to return another thing.  There may be use cases for such a thing, but to me it just seems like new complexity added to the model for very little gain.<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 30, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; I can&#39;t understand this. For me ValuePreservingStringConvertible usually will be different than CustomStringConvertible. Can&#39;t I want to have some string view of my struct to present data(also in UI) *and* value preserving string value for the same struct?<br>&gt; So my .description will show something like &quot;12.345-6.78&quot; and value preserving string will contain something like &quot;19083749347923847293487293483&quot; to encode the data of the struct. No?<br></p><p>Rather than thinking of LosslessStringConvertible as a protocol for serializing data into a string, think of it as a protocol for those cases where the human-readable description is also parseable and can be used to completely recreate the instance. It&#39;s something you would use for things like command-line arguments, environment variables, interactive command-line programs, and configuration files that you expect humans to read and write by hand.<br></p><p>	func prompt&lt;T: LosslessStringConvertible&gt;(for field: String, of type: T.Type) -&gt; T {<br>		while true {<br>			print(&quot;What&#39;s your \(field)?&quot;)<br>			<br>			let line = readline()<br>			<br>			if	!line.isEmpty<br>				let value = T(line) {		// how the hell do you indent this stupid syntax?<br>				return value<br>			}<br>		}<br>	}<br>	<br>	let name = prompt(for: &quot;name&quot;, of: String)<br>	let age = prompt(for: &quot;age&quot;, of: Int)<br>		<br>	let answer = age &lt; 13 ? &quot; not&quot; : &quot;&quot;<br>	print(&quot;\(name), you are\(answer) too old to have a favorite color.&quot;)<br></p><p>In other words, write the `description` first, and then decide if you can write a good `init(_ description:)` to match it.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 31, 2016 at 01:00:00am</p></header><div class="content"><p>Thank you, Brent. But for me you just described a serialization to/from <br>string ;)<br></p><p>So, using your example, if I have<br></p><p>struct A: CustomStringConvertible {<br>     var a = 0, b = 0<br>     var description: String { return &quot;a:\(a) b:\(b)&quot; }<br>}<br></p><p>and I want to use it in your code. Will I be able to do this?<br>For example, I&#39;m ok to give it &#39;lossless&#39; representation as &quot;\(a)/\(b)&quot; <br>(i.e. 1/2 for example) and provide init() for string of such format.<br></p><p>I.e. it seems like I just should create extension and conform to <br>LosslessStringConvertible, but as I understand I can&#39;t, as I need not only <br>introduce an init(:String), but modify `description` property ?<br>I.e. assume you have no rights or don&#39;t want to modify the A type itself.<br></p><p>This is why I don&#39;t understand why we should have the same .description for <br>this LosslessStringConvertible(i.e. if it will be .loslessDescription - no <br>problems).<br>Most likely I don&#39;t understand something.<br></p><p>Also there is a question regarding your example: what to do with Double <br>type? We can have some configuration items of Double type, but how to use <br>this LosslessStringConvertible here?<br></p><p>On 31.05.2016 0:22, Brent Royal-Gordon wrote:<br>&gt;&gt; I can&#39;t understand this. For me ValuePreservingStringConvertible usually will be different than CustomStringConvertible. Can&#39;t I want to have some string view of my struct to present data(also in UI) *and* value preserving string value for the same struct?<br>&gt;&gt; So my .description will show something like &quot;12.345-6.78&quot; and value preserving string will contain something like &quot;19083749347923847293487293483&quot; to encode the data of the struct. No?<br>&gt;<br>&gt; Rather than thinking of LosslessStringConvertible as a protocol for serializing data into a string, think of it as a protocol for those cases where the human-readable description is also parseable and can be used to completely recreate the instance. It&#39;s something you would use for things like command-line arguments, environment variables, interactive command-line programs, and configuration files that you expect humans to read and write by hand.<br>&gt;<br>&gt; 	func prompt&lt;T: LosslessStringConvertible&gt;(for field: String, of type: T.Type) -&gt; T {<br>&gt; 		while true {<br>&gt; 			print(&quot;What&#39;s your \(field)?&quot;)<br>&gt; 			<br>&gt; 			let line = readline()<br>&gt; 			<br>&gt; 			if	!line.isEmpty<br>&gt; 				let value = T(line) {		// how the hell do you indent this stupid syntax?<br>&gt; 				return value<br>&gt; 			}<br>&gt; 		}<br>&gt; 	}<br>&gt; 	<br>&gt; 	let name = prompt(for: &quot;name&quot;, of: String)<br>&gt; 	let age = prompt(for: &quot;age&quot;, of: Int)<br>&gt; 		<br>&gt; 	let answer = age &lt; 13 ? &quot; not&quot; : &quot;&quot;<br>&gt; 	print(&quot;\(name), you are\(answer) too old to have a favorite color.&quot;)<br>&gt;<br>&gt; In other words, write the `description` first, and then decide if you can write a good `init(_ description:)` to match it.<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 31, 2016 at 05:00:00pm</p></header><div class="content"><p>I agree with Vladimir. Having a value preserving representation is orthogonal to a human readable representation.<br></p><p>-Thorsten <br></p><p>&gt; Am 31.05.2016 um 00:04 schrieb Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Thank you, Brent. But for me you just described a serialization to/from string ;)<br>&gt; <br>&gt; So, using your example, if I have<br>&gt; <br>&gt; struct A: CustomStringConvertible {<br>&gt;    var a = 0, b = 0<br>&gt;    var description: String { return &quot;a:\(a) b:\(b)&quot; }<br>&gt; }<br>&gt; <br>&gt; and I want to use it in your code. Will I be able to do this?<br>&gt; For example, I&#39;m ok to give it &#39;lossless&#39; representation as &quot;\(a)/\(b)&quot; (i.e. 1/2 for example) and provide init() for string of such format.<br>&gt; <br>&gt; I.e. it seems like I just should create extension and conform to LosslessStringConvertible, but as I understand I can&#39;t, as I need not only introduce an init(:String), but modify `description` property ?<br>&gt; I.e. assume you have no rights or don&#39;t want to modify the A type itself.<br>&gt; <br>&gt; This is why I don&#39;t understand why we should have the same .description for this LosslessStringConvertible(i.e. if it will be .loslessDescription - no problems).<br>&gt; Most likely I don&#39;t understand something.<br>&gt; <br>&gt; Also there is a question regarding your example: what to do with Double type? We can have some configuration items of Double type, but how to use this LosslessStringConvertible here?<br>&gt; <br>&gt; On 31.05.2016 0:22, Brent Royal-Gordon wrote:<br>&gt;&gt;&gt; I can&#39;t understand this. For me ValuePreservingStringConvertible usually will be different than CustomStringConvertible. Can&#39;t I want to have some string view of my struct to present data(also in UI) *and* value preserving string value for the same struct?<br>&gt;&gt;&gt; So my .description will show something like &quot;12.345-6.78&quot; and value preserving string will contain something like &quot;19083749347923847293487293483&quot; to encode the data of the struct. No?<br>&gt;&gt; <br>&gt;&gt; Rather than thinking of LosslessStringConvertible as a protocol for serializing data into a string, think of it as a protocol for those cases where the human-readable description is also parseable and can be used to completely recreate the instance. It&#39;s something you would use for things like command-line arguments, environment variables, interactive command-line programs, and configuration files that you expect humans to read and write by hand.<br>&gt;&gt; <br>&gt;&gt;    func prompt&lt;T: LosslessStringConvertible&gt;(for field: String, of type: T.Type) -&gt; T {<br>&gt;&gt;        while true {<br>&gt;&gt;            print(&quot;What&#39;s your \(field)?&quot;)<br>&gt;&gt;            <br>&gt;&gt;            let line = readline()<br>&gt;&gt;            <br>&gt;&gt;            if    !line.isEmpty<br>&gt;&gt;                let value = T(line) {        // how the hell do you indent this stupid syntax?<br>&gt;&gt;                return value<br>&gt;&gt;            }<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt;    <br>&gt;&gt;    let name = prompt(for: &quot;name&quot;, of: String)<br>&gt;&gt;    let age = prompt(for: &quot;age&quot;, of: Int)<br>&gt;&gt;        <br>&gt;&gt;    let answer = age &lt; 13 ? &quot; not&quot; : &quot;&quot;<br>&gt;&gt;    print(&quot;\(name), you are\(answer) too old to have a favorite color.&quot;)<br>&gt;&gt; <br>&gt;&gt; In other words, write the `description` first, and then decide if you can write a good `init(_ description:)` to match it.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
