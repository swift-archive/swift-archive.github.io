<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Referencing the Objective-C selector of a method</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 11, 2016 at 01:00:00pm</p></header><div class="content"><p>Here’s a follow-up to the idea I posted for a simple expression to produce the selector for a given method, revised based on the discussion there. The proposal is over at<br></p><p>	https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md<br></p><p>Referencing the Objective-C selector of a method<br></p><p>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-objc-selectors.md&gt;<br>Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>Status: Awaiting review<br>Review manager: TBD<br> &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#introduction&gt;Introduction<br></p><p>In Swift 2, Objective-C selectors are written as string literals (e.g., &quot;insertSubview:aboveSubview:&quot;) in the type context of a Selector. This proposal seeks to replace this error-prone approach with Selector initialization syntax that refers to a specific method via its Swift name.<br></p><p>Swift-evolution thread: here &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/1384/focus=1403&gt;<br> &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#motivation&gt;Motivation<br></p><p>The use of string literals for selector names is extremely error-prone: there is no checking that the string is even a well-formed selector, much less that it refers to any known method, or a method of the intended class. Moreover, with the effort to perform automatic renaming of Objective-C APIs &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;, the link between Swift name and Objective-C selector is non-obvious. By providing explicit &quot;create a selector&quot; syntax based on the Swift name of a method, we eliminate the need for developers to reason about the actual Objective-C selectors being used.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#proposed-solution&gt;Proposed solution<br></p><p>Introduce Selector initialization syntax that allows one to build a selector from a reference to a method, e.g.,<br></p><p>control.sendAction(Selector(MyApplication.doSomething), to: target, forEvent: event)<br>where “doSomething” is a method of MyApplication, which might even have a completely-unrelated name in Objective-C:<br></p><p>extension MyApplication {<br>  @objc(jumpUpAndDown:)<br>  func doSomething(sender: AnyObject?) { … }<br>}<br>By naming the Swift method and having the Selector initializer do the work to form the Objective-C selector, we free the developer from having to do the naming translation manually and get static checking that the method exists and is exposed to Objective-C.<br></p><p>This proposal composes with the Naming Functions with Argument Labels proposal &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006262.html&gt;, which lets us name methods along with their argument labels, e.g.:<br></p><p>let sel = Selector(UIView.insertSubview(_:at:)) // produces the Selector &quot;insertSubview:atIndex:&quot;<br>With the introduction of the Selector syntax, we should deprecate the use of string literals to form selectors. Ideally, we could perform the deprecation in Swift 2.2 and remove the syntax entirely from Swift 3.<br></p><p>Additionally, we should introduce specific migrator support to translate string-literals-as-selectors into method references. Doing this well is non-trivial, requiring the compiler/migrator to find all of the declarations with a particular Objective-C selector and determine which one to reference. However, it should be feasible, and we can migrator other references to a specific, string-based initialization syntax (e.g., Selector(&quot;insertSubview:atIndex:&quot;)).<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#detailed-design&gt;Detailed design<br></p><p>The proposed Selector initializer &quot;almost&quot; has the signature:<br></p><p>extension Selector {<br>  init&lt;T, U&gt;(_ fn: (T) -&gt; U)<br>}<br>with some additional semantic restrictions that require that input be a reference to an objc method. Specifically, the input expression must be a direct reference to an Objective-C method, possibly parenthesized and possible with an &quot;as&quot; cast (which can be used to disambiguate same-named Swift methods). For example, here is a &quot;highly general&quot; example:<br></p><p>let sel = Selector(((UIKit.UIView.insertSubview(_:at:)) as (UIView) -&gt; (UIView, Int) -&gt; Void))<br>The actual implementation will introduce some magic in the type checker to only support references to methods within the Selector initialization syntax.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>The introduction of the Selector initialization syntax has no impact on existing code. However, deprecating and removing the string-literal-as-selector syntax is a source-breaking change. We can migrate the uses to either the new Selectorinitialization syntax or to explicit initialization of a Selector from a string.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#alternatives-considered&gt;Alternatives considered<br></p><p>The primary alternative is type-safe selectors &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000233.html&gt;, which would introduce a new &quot;selector&quot; calling convetion to capture the type of an @objc method, including its selector. One major benefit of type-safe selectors is that they can carry type information, improving type safety. From that discussion, referencing MyClass.observeNotification would produce a value of type:<br></p><p>@convention(selector) (MyClass) -&gt; (NSNotification) -&gt; Void<br>Objective-C APIs that accept selectors could provide type information (e.g., via Objective-C attributes or new syntax for a typed SEL), improving type safety for selector-based APIs. Personally, I feel that type-safe selectors are a well-designed feature that isn&#39;t worth doing: one would probably not use them outside of interoperability with existing Objective-C APIs, because closures are generally preferable (in both Swift and Objective-C). The cost of adding this feature to both Swift and Clang is significant, and we would also need adoption across a significant number of Objective-C APIs to make it worthwhile. On iOS, we are talking about a relatively small number of APIs (100-ish), and many of those have blocks/closure-based variants that are preferred anyway. Therefore, we should implement the simpler feature in this proposal rather than the far more complicated (but admittedly more type-safe) alternative approach.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/a996d8ab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal draft] Referencing the Objective-C selector of a method</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 11, 2016 at 10:00:00pm</p></header><div class="content"><p>+1<br>strings are error prone, and I&#39;d expect the new syntax to support autocompletion.<br></p><p>As Joe has suggested in the &quot;sister&quot;-proposal, I think skipping the underscores makes sense.<br></p><p>Tino<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Proposal draft] Referencing the Objective-C selector of a method</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 12, 2016 at 08:00:00am</p></header><div class="content"><p>Sounds good to me, much nicer than the current approach.<br></p><p>Perhaps it should be @selector() instead? I don&#39;t think you can currently<br>get enough information from the type signature alone to differentiate one<br>selector from another. This will probably have to introduce new syntax, it<br>would require changes to the language not just a standard library function.<br>@selector seems to differentiate it from standard structures and functions.<br></p><p>I also think the underscore should be removed, that&#39;s outside the scope of<br>this proposal though?<br></p><p>I had concerns for this with Self and associated type requirements, however<br>I don&#39;t think they&#39;re an issue unless Objective-C supports them, or this is<br>to be used outside of Objective-C. For the same reasons I&#39;m guessing<br>there&#39;s no need for this to distinguish between selectors with different<br>return types?<br></p><p><br>On Tue, Jan 12, 2016 at 8:08 AM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Here’s a follow-up to the idea I posted for a simple expression to produce<br>&gt; the selector for a given method, revised based on the discussion there. The<br>&gt; proposal is over at<br>&gt;<br>&gt;<br>&gt; https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md<br>&gt;<br>&gt; Referencing the Objective-C selector of a method<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-objc-selectors.md&gt;<br>&gt;    - Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;    - Status: *Awaiting review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; In Swift 2, Objective-C selectors are written as string literals (e.g.,<br>&gt; &quot;insertSubview:aboveSubview:&quot;) in the type context of a Selector. This<br>&gt; proposal seeks to replace this error-prone approach with Selector initialization<br>&gt; syntax that refers to a specific method via its Swift name.<br>&gt;<br>&gt; Swift-evolution thread: here<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/1384/focus=1403&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; The use of string literals for selector names is extremely error-prone:<br>&gt; there is no checking that the string is even a well-formed selector, much<br>&gt; less that it refers to any known method, or a method of the intended class.<br>&gt; Moreover, with the effort to perform automatic renaming of Objective-C<br>&gt; APIs<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;,<br>&gt; the link between Swift name and Objective-C selector is non-obvious. By<br>&gt; providing explicit &quot;create a selector&quot; syntax based on the Swift name of a<br>&gt; method, we eliminate the need for developers to reason about the actual<br>&gt; Objective-C selectors being used.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; Introduce Selector initialization syntax that allows one to build a<br>&gt; selector from a reference to a method, e.g.,<br>&gt;<br>&gt; control.sendAction(Selector(MyApplication.doSomething), to: target, forEvent: event)<br>&gt;<br>&gt; where “doSomething” is a method of MyApplication, which might even have a<br>&gt; completely-unrelated name in Objective-C:<br>&gt;<br>&gt; extension MyApplication {<br>&gt;   @objc(jumpUpAndDown:)<br>&gt;   func doSomething(sender: AnyObject?) { … }<br>&gt; }<br>&gt;<br>&gt; By naming the Swift method and having the Selector initializer do the<br>&gt; work to form the Objective-C selector, we free the developer from having to<br>&gt; do the naming translation manually and get static checking that the method<br>&gt; exists and is exposed to Objective-C.<br>&gt;<br>&gt; This proposal composes with the Naming Functions with Argument Labels<br>&gt; proposal<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006262.html&gt;,<br>&gt; which lets us name methods along with their argument labels, e.g.:<br>&gt;<br>&gt; let sel = Selector(UIView.insertSubview(_:at:)) // produces the Selector &quot;insertSubview:atIndex:&quot;<br>&gt;<br>&gt; With the introduction of the Selector syntax, we should deprecate the use<br>&gt; of string literals to form selectors. Ideally, we could perform the<br>&gt; deprecation in Swift 2.2 and remove the syntax entirely from Swift 3.<br>&gt;<br>&gt; Additionally, we should introduce specific migrator support to translate<br>&gt; string-literals-as-selectors into method references. Doing this well is<br>&gt; non-trivial, requiring the compiler/migrator to find all of the<br>&gt; declarations with a particular Objective-C selector and determine which one<br>&gt; to reference. However, it should be feasible, and we can migrator other<br>&gt; references to a specific, string-based initialization syntax (e.g.,<br>&gt; Selector(&quot;insertSubview:atIndex:&quot;)).<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; The proposed Selector initializer &quot;almost&quot; has the signature:<br>&gt;<br>&gt; extension Selector {<br>&gt;   init&lt;T, U&gt;(_ fn: (T) -&gt; U)<br>&gt; }<br>&gt;<br>&gt; with some additional semantic restrictions that require that input be a<br>&gt; reference to an objc method. Specifically, the input expression must be a<br>&gt; direct reference to an Objective-C method, possibly parenthesized and<br>&gt; possible with an &quot;as&quot; cast (which can be used to disambiguate same-named<br>&gt; Swift methods). For example, here is a &quot;highly general&quot; example:<br>&gt;<br>&gt; let sel = Selector(((UIKit.UIView.insertSubview(_:at:)) as (UIView) -&gt; (UIView, Int) -&gt; Void))<br>&gt;<br>&gt; The actual implementation will introduce some magic in the type checker to<br>&gt; only support references to methods within the Selector initialization<br>&gt; syntax.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; The introduction of the Selector initialization syntax has no impact on<br>&gt; existing code. However, deprecating and removing the<br>&gt; string-literal-as-selector syntax is a source-breaking change. We can<br>&gt; migrate the uses to either the new Selectorinitialization syntax or to<br>&gt; explicit initialization of a Selector from a string.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt; The primary alternative is type-safe selectors<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000233.html&gt;,<br>&gt; which would introduce a new &quot;selector&quot; calling convetion to capture the<br>&gt; type of an @objc method, including its selector. One major benefit of<br>&gt; type-safe selectors is that they can carry type information, improving type<br>&gt; safety. From that discussion, referencing MyClass.observeNotification would<br>&gt; produce a value of type:<br>&gt;<br>&gt; @convention(selector) (MyClass) -&gt; (NSNotification) -&gt; Void<br>&gt;<br>&gt; Objective-C APIs that accept selectors could provide type information<br>&gt; (e.g., via Objective-C attributes or new syntax for a typed SEL),<br>&gt; improving type safety for selector-based APIs. Personally, I feel that<br>&gt; type-safe selectors are a well-designed feature that isn&#39;t worth doing: one<br>&gt; would probably not use them outside of interoperability with existing<br>&gt; Objective-C APIs, because closures are generally preferable (in both Swift<br>&gt; and Objective-C). The cost of adding this feature to both Swift and Clang<br>&gt; is significant, and we would also need adoption across a significant number<br>&gt; of Objective-C APIs to make it worthwhile. On iOS, we are talking about a<br>&gt; relatively small number of APIs (100-ish), and many of those have<br>&gt; blocks/closure-based variants that are preferred anyway. Therefore, we<br>&gt; should implement the simpler feature in this proposal rather than the far<br>&gt; more complicated (but admittedly more type-safe) alternative approach.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/be2effd2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Referencing the Objective-C selector of a method</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 11, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 1:58 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Sounds good to me, much nicer than the current approach.<br>&gt; <br>&gt; Perhaps it should be @selector() instead? I don&#39;t think you can currently get enough information from the type signature alone to differentiate one selector from another. This will probably have to introduce new syntax, it would require changes to the language not just a standard library function. @selector seems to differentiate it from standard structures and functions.<br></p><p>@ is for attributes, so that doesn’t work. I’ll add commentary to the proposal, since this keeps coming up.<br></p><p>&gt; <br>&gt; I also think the underscore should be removed, that&#39;s outside the scope of this proposal though?<br></p><p>I’m strongly opposed to doing it only for this syntax. Doing it globally is annoying, because it requires changes in Clang as well.<br></p><p>&gt; <br>&gt; I had concerns for this with Self and associated type requirements, however I don&#39;t think they&#39;re an issue unless Objective-C supports them, or this is to be used outside of Objective-C.<br></p><p>I don’t see this as being a problem now or in the future.<br></p><p>&gt; For the same reasons I&#39;m guessing there&#39;s no need for this to distinguish between selectors with different return types?<br></p><p>One can introduce type context (with “as”) if this actually comes up. It should be *extremely* rare with Objective-C methods.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; <br>&gt; On Tue, Jan 12, 2016 at 8:08 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Here’s a follow-up to the idea I posted for a simple expression to produce the selector for a given method, revised based on the discussion there. The proposal is over at<br>&gt; <br>&gt; 	https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md&gt;<br>&gt; <br>&gt; Referencing the Objective-C selector of a method<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-objc-selectors.md&gt;<br>&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#introduction&gt;Introduction<br>&gt; <br>&gt; In Swift 2, Objective-C selectors are written as string literals (e.g., &quot;insertSubview:aboveSubview:&quot;) in the type context of a Selector. This proposal seeks to replace this error-prone approach with Selector initialization syntax that refers to a specific method via its Swift name.<br>&gt; <br>&gt; Swift-evolution thread: here &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/1384/focus=1403&gt;<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#motivation&gt;Motivation<br>&gt; <br>&gt; The use of string literals for selector names is extremely error-prone: there is no checking that the string is even a well-formed selector, much less that it refers to any known method, or a method of the intended class. Moreover, with the effort to perform automatic renaming of Objective-C APIs &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;, the link between Swift name and Objective-C selector is non-obvious. By providing explicit &quot;create a selector&quot; syntax based on the Swift name of a method, we eliminate the need for developers to reason about the actual Objective-C selectors being used.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; Introduce Selector initialization syntax that allows one to build a selector from a reference to a method, e.g.,<br>&gt; <br>&gt; control.sendAction(Selector(MyApplication.doSomething), to: target, forEvent: event)<br>&gt; where “doSomething” is a method of MyApplication, which might even have a completely-unrelated name in Objective-C:<br>&gt; <br>&gt; extension MyApplication {<br>&gt;   @objc(jumpUpAndDown:)<br>&gt;   func doSomething(sender: AnyObject?) { … }<br>&gt; }<br>&gt; By naming the Swift method and having the Selector initializer do the work to form the Objective-C selector, we free the developer from having to do the naming translation manually and get static checking that the method exists and is exposed to Objective-C.<br>&gt; <br>&gt; This proposal composes with the Naming Functions with Argument Labels proposal &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006262.html&gt;, which lets us name methods along with their argument labels, e.g.:<br>&gt; <br>&gt; let sel = Selector(UIView.insertSubview(_:at:)) // produces the Selector &quot;insertSubview:atIndex:&quot;<br>&gt; With the introduction of the Selector syntax, we should deprecate the use of string literals to form selectors. Ideally, we could perform the deprecation in Swift 2.2 and remove the syntax entirely from Swift 3.<br>&gt; <br>&gt; Additionally, we should introduce specific migrator support to translate string-literals-as-selectors into method references. Doing this well is non-trivial, requiring the compiler/migrator to find all of the declarations with a particular Objective-C selector and determine which one to reference. However, it should be feasible, and we can migrator other references to a specific, string-based initialization syntax (e.g., Selector(&quot;insertSubview:atIndex:&quot;)).<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; The proposed Selector initializer &quot;almost&quot; has the signature:<br>&gt; <br>&gt; extension Selector {<br>&gt;   init&lt;T, U&gt;(_ fn: (T) -&gt; U)<br>&gt; }<br>&gt; with some additional semantic restrictions that require that input be a reference to an objc method. Specifically, the input expression must be a direct reference to an Objective-C method, possibly parenthesized and possible with an &quot;as&quot; cast (which can be used to disambiguate same-named Swift methods). For example, here is a &quot;highly general&quot; example:<br>&gt; <br>&gt; let sel = Selector(((UIKit.UIView.insertSubview(_:at:)) as (UIView) -&gt; (UIView, Int) -&gt; Void))<br>&gt; The actual implementation will introduce some magic in the type checker to only support references to methods within the Selector initialization syntax.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; The introduction of the Selector initialization syntax has no impact on existing code. However, deprecating and removing the string-literal-as-selector syntax is a source-breaking change. We can migrate the uses to either the new Selectorinitialization syntax or to explicit initialization of a Selector from a string.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; The primary alternative is type-safe selectors &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000233.html&gt;, which would introduce a new &quot;selector&quot; calling convetion to capture the type of an @objc method, including its selector. One major benefit of type-safe selectors is that they can carry type information, improving type safety. From that discussion, referencing MyClass.observeNotification would produce a value of type:<br>&gt; <br>&gt; @convention(selector) (MyClass) -&gt; (NSNotification) -&gt; Void<br>&gt; Objective-C APIs that accept selectors could provide type information (e.g., via Objective-C attributes or new syntax for a typed SEL), improving type safety for selector-based APIs. Personally, I feel that type-safe selectors are a well-designed feature that isn&#39;t worth doing: one would probably not use them outside of interoperability with existing Objective-C APIs, because closures are generally preferable (in both Swift and Objective-C). The cost of adding this feature to both Swift and Clang is significant, and we would also need adoption across a significant number of Objective-C APIs to make it worthwhile. On iOS, we are talking about a relatively small number of APIs (100-ish), and many of those have blocks/closure-based variants that are preferred anyway. Therefore, we should implement the simpler feature in this proposal rather than the far more complicated (but admittedly more type-safe) alternative approach.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/98872f0c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Proposal draft] Referencing the Objective-C selector of a method</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 12, 2016 at 10:00:00am</p></header><div class="content"><p>I agree on pretty much every point. I also saw the light on _ since writing<br>that :)<br></p><p>+1<br></p><p>On Tue, Jan 12, 2016 at 9:04 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 11, 2016, at 1:58 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;<br>&gt; Sounds good to me, much nicer than the current approach.<br>&gt;<br>&gt; Perhaps it should be @selector() instead? I don&#39;t think you can currently<br>&gt; get enough information from the type signature alone to differentiate one<br>&gt; selector from another. This will probably have to introduce new syntax, it<br>&gt; would require changes to the language not just a standard library function.<br>&gt; @selector seems to differentiate it from standard structures and functions.<br>&gt;<br>&gt;<br>&gt; @ is for attributes, so that doesn’t work. I’ll add commentary to the<br>&gt; proposal, since this keeps coming up.<br>&gt;<br>&gt;<br>&gt; I also think the underscore should be removed, that&#39;s outside the scope of<br>&gt; this proposal though?<br>&gt;<br>&gt;<br>&gt; I’m strongly opposed to doing it only for this syntax. Doing it globally<br>&gt; is annoying, because it requires changes in Clang as well.<br>&gt;<br>&gt;<br>&gt; I had concerns for this with Self and associated type requirements,<br>&gt; however I don&#39;t think they&#39;re an issue unless Objective-C supports them, or<br>&gt; this is to be used outside of Objective-C.<br>&gt;<br>&gt;<br>&gt; I don’t see this as being a problem now or in the future.<br>&gt;<br>&gt; For the same reasons I&#39;m guessing there&#39;s no need for this to distinguish<br>&gt; between selectors with different return types?<br>&gt;<br>&gt;<br>&gt; One can introduce type context (with “as”) if this actually comes up. It<br>&gt; should be *extremely* rare with Objective-C methods.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, Jan 12, 2016 at 8:08 AM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Here’s a follow-up to the idea I posted for a simple expression to<br>&gt;&gt; produce the selector for a given method, revised based on the discussion<br>&gt;&gt; there. The proposal is over at<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md<br>&gt;&gt;<br>&gt;&gt; Referencing the Objective-C selector of a method<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-objc-selectors.md&gt;<br>&gt;&gt;    - Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;    - Status: *Awaiting review*<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#introduction&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; In Swift 2, Objective-C selectors are written as string literals (e.g.,<br>&gt;&gt; &quot;insertSubview:aboveSubview:&quot;) in the type context of a Selector. This<br>&gt;&gt; proposal seeks to replace this error-prone approach with Selector initialization<br>&gt;&gt; syntax that refers to a specific method via its Swift name.<br>&gt;&gt;<br>&gt;&gt; Swift-evolution thread: here<br>&gt;&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/1384/focus=1403&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; The use of string literals for selector names is extremely error-prone:<br>&gt;&gt; there is no checking that the string is even a well-formed selector, much<br>&gt;&gt; less that it refers to any known method, or a method of the intended class.<br>&gt;&gt; Moreover, with the effort to perform automatic renaming of Objective-C<br>&gt;&gt; APIs<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;,<br>&gt;&gt; the link between Swift name and Objective-C selector is non-obvious. By<br>&gt;&gt; providing explicit &quot;create a selector&quot; syntax based on the Swift name of a<br>&gt;&gt; method, we eliminate the need for developers to reason about the actual<br>&gt;&gt; Objective-C selectors being used.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#proposed-solution&gt;Proposed<br>&gt;&gt; solution<br>&gt;&gt;<br>&gt;&gt; Introduce Selector initialization syntax that allows one to build a<br>&gt;&gt; selector from a reference to a method, e.g.,<br>&gt;&gt;<br>&gt;&gt; control.sendAction(Selector(MyApplication.doSomething), to: target, forEvent: event)<br>&gt;&gt;<br>&gt;&gt; where “doSomething” is a method of MyApplication, which might even have a<br>&gt;&gt; completely-unrelated name in Objective-C:<br>&gt;&gt;<br>&gt;&gt; extension MyApplication {<br>&gt;&gt;   @objc(jumpUpAndDown:)<br>&gt;&gt;   func doSomething(sender: AnyObject?) { … }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; By naming the Swift method and having the Selector initializer do the<br>&gt;&gt; work to form the Objective-C selector, we free the developer from having to<br>&gt;&gt; do the naming translation manually and get static checking that the method<br>&gt;&gt; exists and is exposed to Objective-C.<br>&gt;&gt;<br>&gt;&gt; This proposal composes with the Naming Functions with Argument Labels<br>&gt;&gt; proposal<br>&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006262.html&gt;,<br>&gt;&gt; which lets us name methods along with their argument labels, e.g.:<br>&gt;&gt;<br>&gt;&gt; let sel = Selector(UIView.insertSubview(_:at:)) // produces the Selector &quot;insertSubview:atIndex:&quot;<br>&gt;&gt;<br>&gt;&gt; With the introduction of the Selector syntax, we should deprecate the<br>&gt;&gt; use of string literals to form selectors. Ideally, we could perform the<br>&gt;&gt; deprecation in Swift 2.2 and remove the syntax entirely from Swift 3.<br>&gt;&gt;<br>&gt;&gt; Additionally, we should introduce specific migrator support to translate<br>&gt;&gt; string-literals-as-selectors into method references. Doing this well is<br>&gt;&gt; non-trivial, requiring the compiler/migrator to find all of the<br>&gt;&gt; declarations with a particular Objective-C selector and determine which one<br>&gt;&gt; to reference. However, it should be feasible, and we can migrator other<br>&gt;&gt; references to a specific, string-based initialization syntax (e.g.,<br>&gt;&gt; Selector(&quot;insertSubview:atIndex:&quot;)).<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#detailed-design&gt;Detailed<br>&gt;&gt; design<br>&gt;&gt;<br>&gt;&gt; The proposed Selector initializer &quot;almost&quot; has the signature:<br>&gt;&gt;<br>&gt;&gt; extension Selector {<br>&gt;&gt;   init&lt;T, U&gt;(_ fn: (T) -&gt; U)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; with some additional semantic restrictions that require that input be a<br>&gt;&gt; reference to an objc method. Specifically, the input expression must be<br>&gt;&gt; a direct reference to an Objective-C method, possibly parenthesized and<br>&gt;&gt; possible with an &quot;as&quot; cast (which can be used to disambiguate same-named<br>&gt;&gt; Swift methods). For example, here is a &quot;highly general&quot; example:<br>&gt;&gt;<br>&gt;&gt; let sel = Selector(((UIKit.UIView.insertSubview(_:at:)) as (UIView) -&gt; (UIView, Int) -&gt; Void))<br>&gt;&gt;<br>&gt;&gt; The actual implementation will introduce some magic in the type checker<br>&gt;&gt; to only support references to methods within the Selector initialization<br>&gt;&gt; syntax.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#impact-on-existing-code&gt;Impact<br>&gt;&gt; on existing code<br>&gt;&gt;<br>&gt;&gt; The introduction of the Selector initialization syntax has no impact on<br>&gt;&gt; existing code. However, deprecating and removing the<br>&gt;&gt; string-literal-as-selector syntax is a source-breaking change. We can<br>&gt;&gt; migrate the uses to either the new Selectorinitialization syntax or to<br>&gt;&gt; explicit initialization of a Selector from a string.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#alternatives-considered&gt;Alternatives<br>&gt;&gt; considered<br>&gt;&gt;<br>&gt;&gt; The primary alternative is type-safe selectors<br>&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000233.html&gt;,<br>&gt;&gt; which would introduce a new &quot;selector&quot; calling convetion to capture the<br>&gt;&gt; type of an @objc method, including its selector. One major benefit of<br>&gt;&gt; type-safe selectors is that they can carry type information, improving type<br>&gt;&gt; safety. From that discussion, referencing MyClass.observeNotification would<br>&gt;&gt; produce a value of type:<br>&gt;&gt;<br>&gt;&gt; @convention(selector) (MyClass) -&gt; (NSNotification) -&gt; Void<br>&gt;&gt;<br>&gt;&gt; Objective-C APIs that accept selectors could provide type information<br>&gt;&gt; (e.g., via Objective-C attributes or new syntax for a typed SEL),<br>&gt;&gt; improving type safety for selector-based APIs. Personally, I feel that<br>&gt;&gt; type-safe selectors are a well-designed feature that isn&#39;t worth doing: one<br>&gt;&gt; would probably not use them outside of interoperability with existing<br>&gt;&gt; Objective-C APIs, because closures are generally preferable (in both Swift<br>&gt;&gt; and Objective-C). The cost of adding this feature to both Swift and Clang<br>&gt;&gt; is significant, and we would also need adoption across a significant number<br>&gt;&gt; of Objective-C APIs to make it worthwhile. On iOS, we are talking about a<br>&gt;&gt; relatively small number of APIs (100-ish), and many of those have<br>&gt;&gt; blocks/closure-based variants that are preferred anyway. Therefore, we<br>&gt;&gt; should implement the simpler feature in this proposal rather than the far<br>&gt;&gt; more complicated (but admittedly more type-safe) alternative approach.<br>&gt;&gt;<br>&gt;&gt; - Doug<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/780230e9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal draft] Referencing the Objective-C selector of a method</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 11, 2016 at 05:00:00pm</p></header><div class="content"><p>The underscore is discussed in &quot;[swift-evolution] [Proposal draft #2] Naming Functions with Argument Labels&quot;.<br></p><p>Selectors carry no type information at all. They don&#39;t belong to a class, they don&#39;t indicate their return value (if any), they don&#39;t indicate their parameter types.<br></p><p>Félix<br></p><p>&gt; Le 11 janv. 2016 à 16:58:17, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Sounds good to me, much nicer than the current approach.<br>&gt; <br>&gt; Perhaps it should be @selector() instead? I don&#39;t think you can currently get enough information from the type signature alone to differentiate one selector from another. This will probably have to introduce new syntax, it would require changes to the language not just a standard library function. @selector seems to differentiate it from standard structures and functions.<br>&gt; <br>&gt; I also think the underscore should be removed, that&#39;s outside the scope of this proposal though?<br>&gt; <br>&gt; I had concerns for this with Self and associated type requirements, however I don&#39;t think they&#39;re an issue unless Objective-C supports them, or this is to be used outside of Objective-C. For the same reasons I&#39;m guessing there&#39;s no need for this to distinguish between selectors with different return types?<br>&gt; <br>&gt; <br>&gt; On Tue, Jan 12, 2016 at 8:08 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Here’s a follow-up to the idea I posted for a simple expression to produce the selector for a given method, revised based on the discussion there. The proposal is over at<br>&gt; <br>&gt; 	https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md&gt;<br>&gt; <br>&gt; Referencing the Objective-C selector of a method<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-objc-selectors.md&gt;<br>&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#introduction&gt;Introduction<br>&gt; <br>&gt; In Swift 2, Objective-C selectors are written as string literals (e.g., &quot;insertSubview:aboveSubview:&quot;) in the type context of a Selector. This proposal seeks to replace this error-prone approach with Selector initialization syntax that refers to a specific method via its Swift name.<br>&gt; <br>&gt; Swift-evolution thread: here &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/1384/focus=1403&gt;<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#motivation&gt;Motivation<br>&gt; <br>&gt; The use of string literals for selector names is extremely error-prone: there is no checking that the string is even a well-formed selector, much less that it refers to any known method, or a method of the intended class. Moreover, with the effort to perform automatic renaming of Objective-C APIs &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;, the link between Swift name and Objective-C selector is non-obvious. By providing explicit &quot;create a selector&quot; syntax based on the Swift name of a method, we eliminate the need for developers to reason about the actual Objective-C selectors being used.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; Introduce Selector initialization syntax that allows one to build a selector from a reference to a method, e.g.,<br>&gt; <br>&gt; control.sendAction(Selector(MyApplication.doSomething), to: target, forEvent: event)<br>&gt; where “doSomething” is a method of MyApplication, which might even have a completely-unrelated name in Objective-C:<br>&gt; <br>&gt; extension MyApplication {<br>&gt;   @objc(jumpUpAndDown:)<br>&gt;   func doSomething(sender: AnyObject?) { … }<br>&gt; }<br>&gt; By naming the Swift method and having the Selector initializer do the work to form the Objective-C selector, we free the developer from having to do the naming translation manually and get static checking that the method exists and is exposed to Objective-C.<br>&gt; <br>&gt; This proposal composes with the Naming Functions with Argument Labels proposal &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006262.html&gt;, which lets us name methods along with their argument labels, e.g.:<br>&gt; <br>&gt; let sel = Selector(UIView.insertSubview(_:at:)) // produces the Selector &quot;insertSubview:atIndex:&quot;<br>&gt; With the introduction of the Selector syntax, we should deprecate the use of string literals to form selectors. Ideally, we could perform the deprecation in Swift 2.2 and remove the syntax entirely from Swift 3.<br>&gt; <br>&gt; Additionally, we should introduce specific migrator support to translate string-literals-as-selectors into method references. Doing this well is non-trivial, requiring the compiler/migrator to find all of the declarations with a particular Objective-C selector and determine which one to reference. However, it should be feasible, and we can migrator other references to a specific, string-based initialization syntax (e.g., Selector(&quot;insertSubview:atIndex:&quot;)).<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; The proposed Selector initializer &quot;almost&quot; has the signature:<br>&gt; <br>&gt; extension Selector {<br>&gt;   init&lt;T, U&gt;(_ fn: (T) -&gt; U)<br>&gt; }<br>&gt; with some additional semantic restrictions that require that input be a reference to an objc method. Specifically, the input expression must be a direct reference to an Objective-C method, possibly parenthesized and possible with an &quot;as&quot; cast (which can be used to disambiguate same-named Swift methods). For example, here is a &quot;highly general&quot; example:<br>&gt; <br>&gt; let sel = Selector(((UIKit.UIView.insertSubview(_:at:)) as (UIView) -&gt; (UIView, Int) -&gt; Void))<br>&gt; The actual implementation will introduce some magic in the type checker to only support references to methods within the Selector initialization syntax.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; The introduction of the Selector initialization syntax has no impact on existing code. However, deprecating and removing the string-literal-as-selector syntax is a source-breaking change. We can migrate the uses to either the new Selectorinitialization syntax or to explicit initialization of a Selector from a string.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; The primary alternative is type-safe selectors &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000233.html&gt;, which would introduce a new &quot;selector&quot; calling convetion to capture the type of an @objc method, including its selector. One major benefit of type-safe selectors is that they can carry type information, improving type safety. From that discussion, referencing MyClass.observeNotification would produce a value of type:<br>&gt; <br>&gt; @convention(selector) (MyClass) -&gt; (NSNotification) -&gt; Void<br>&gt; Objective-C APIs that accept selectors could provide type information (e.g., via Objective-C attributes or new syntax for a typed SEL), improving type safety for selector-based APIs. Personally, I feel that type-safe selectors are a well-designed feature that isn&#39;t worth doing: one would probably not use them outside of interoperability with existing Objective-C APIs, because closures are generally preferable (in both Swift and Objective-C). The cost of adding this feature to both Swift and Clang is significant, and we would also need adoption across a significant number of Objective-C APIs to make it worthwhile. On iOS, we are talking about a relatively small number of APIs (100-ish), and many of those have blocks/closure-based variants that are preferred anyway. Therefore, we should implement the simpler feature in this proposal rather than the far more complicated (but admittedly more type-safe) alternative approach.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/981bafbd/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Proposal draft] Referencing the Objective-C selector of a method</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>January 11, 2016 at 10:00:00pm</p></header><div class="content"><p>Big +1<br></p><p><br></p><p>Em seg, 11 de jan de 2016 às 19:08, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; Here’s a follow-up to the idea I posted for a simple expression to produce<br>&gt; the selector for a given method, revised based on the discussion there. The<br>&gt; proposal is over at<br>&gt;<br>&gt;<br>&gt; https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md<br>&gt;<br>&gt; Referencing the Objective-C selector of a method<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-objc-selectors.md&gt;<br>&gt;    - Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;    - Status: *Awaiting review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; In Swift 2, Objective-C selectors are written as string literals (e.g.,<br>&gt; &quot;insertSubview:aboveSubview:&quot;) in the type context of a Selector. This<br>&gt; proposal seeks to replace this error-prone approach with Selector initialization<br>&gt; syntax that refers to a specific method via its Swift name.<br>&gt;<br>&gt; Swift-evolution thread: here<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/1384/focus=1403&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; The use of string literals for selector names is extremely error-prone:<br>&gt; there is no checking that the string is even a well-formed selector, much<br>&gt; less that it refers to any known method, or a method of the intended class.<br>&gt; Moreover, with the effort to perform automatic renaming of Objective-C<br>&gt; APIs<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;,<br>&gt; the link between Swift name and Objective-C selector is non-obvious. By<br>&gt; providing explicit &quot;create a selector&quot; syntax based on the Swift name of a<br>&gt; method, we eliminate the need for developers to reason about the actual<br>&gt; Objective-C selectors being used.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; Introduce Selector initialization syntax that allows one to build a<br>&gt; selector from a reference to a method, e.g.,<br>&gt;<br>&gt; control.sendAction(Selector(MyApplication.doSomething), to: target, forEvent: event)<br>&gt;<br>&gt; where “doSomething” is a method of MyApplication, which might even have a<br>&gt; completely-unrelated name in Objective-C:<br>&gt;<br>&gt; extension MyApplication {<br>&gt;   @objc(jumpUpAndDown:)<br>&gt;   func doSomething(sender: AnyObject?) { … }<br>&gt; }<br>&gt;<br>&gt; By naming the Swift method and having the Selector initializer do the<br>&gt; work to form the Objective-C selector, we free the developer from having to<br>&gt; do the naming translation manually and get static checking that the method<br>&gt; exists and is exposed to Objective-C.<br>&gt;<br>&gt; This proposal composes with the Naming Functions with Argument Labels<br>&gt; proposal<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006262.html&gt;,<br>&gt; which lets us name methods along with their argument labels, e.g.:<br>&gt;<br>&gt; let sel = Selector(UIView.insertSubview(_:at:)) // produces the Selector &quot;insertSubview:atIndex:&quot;<br>&gt;<br>&gt; With the introduction of the Selector syntax, we should deprecate the use<br>&gt; of string literals to form selectors. Ideally, we could perform the<br>&gt; deprecation in Swift 2.2 and remove the syntax entirely from Swift 3.<br>&gt;<br>&gt; Additionally, we should introduce specific migrator support to translate<br>&gt; string-literals-as-selectors into method references. Doing this well is<br>&gt; non-trivial, requiring the compiler/migrator to find all of the<br>&gt; declarations with a particular Objective-C selector and determine which one<br>&gt; to reference. However, it should be feasible, and we can migrator other<br>&gt; references to a specific, string-based initialization syntax (e.g.,<br>&gt; Selector(&quot;insertSubview:atIndex:&quot;)).<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; The proposed Selector initializer &quot;almost&quot; has the signature:<br>&gt;<br>&gt; extension Selector {<br>&gt;   init&lt;T, U&gt;(_ fn: (T) -&gt; U)<br>&gt; }<br>&gt;<br>&gt; with some additional semantic restrictions that require that input be a<br>&gt; reference to an objc method. Specifically, the input expression must be a<br>&gt; direct reference to an Objective-C method, possibly parenthesized and<br>&gt; possible with an &quot;as&quot; cast (which can be used to disambiguate same-named<br>&gt; Swift methods). For example, here is a &quot;highly general&quot; example:<br>&gt;<br>&gt; let sel = Selector(((UIKit.UIView.insertSubview(_:at:)) as (UIView) -&gt; (UIView, Int) -&gt; Void))<br>&gt;<br>&gt; The actual implementation will introduce some magic in the type checker to<br>&gt; only support references to methods within the Selector initialization<br>&gt; syntax.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; The introduction of the Selector initialization syntax has no impact on<br>&gt; existing code. However, deprecating and removing the<br>&gt; string-literal-as-selector syntax is a source-breaking change. We can<br>&gt; migrate the uses to either the new Selectorinitialization syntax or to<br>&gt; explicit initialization of a Selector from a string.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt; The primary alternative is type-safe selectors<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000233.html&gt;,<br>&gt; which would introduce a new &quot;selector&quot; calling convetion to capture the<br>&gt; type of an @objc method, including its selector. One major benefit of<br>&gt; type-safe selectors is that they can carry type information, improving type<br>&gt; safety. From that discussion, referencing MyClass.observeNotification would<br>&gt; produce a value of type:<br>&gt;<br>&gt; @convention(selector) (MyClass) -&gt; (NSNotification) -&gt; Void<br>&gt;<br>&gt; Objective-C APIs that accept selectors could provide type information<br>&gt; (e.g., via Objective-C attributes or new syntax for a typed SEL),<br>&gt; improving type safety for selector-based APIs. Personally, I feel that<br>&gt; type-safe selectors are a well-designed feature that isn&#39;t worth doing: one<br>&gt; would probably not use them outside of interoperability with existing<br>&gt; Objective-C APIs, because closures are generally preferable (in both Swift<br>&gt; and Objective-C). The cost of adding this feature to both Swift and Clang<br>&gt; is significant, and we would also need adoption across a significant number<br>&gt; of Objective-C APIs to make it worthwhile. On iOS, we are talking about a<br>&gt; relatively small number of APIs (100-ish), and many of those have<br>&gt; blocks/closure-based variants that are preferred anyway. Therefore, we<br>&gt; should implement the simpler feature in this proposal rather than the far<br>&gt; more complicated (but admittedly more type-safe) alternative approach.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/31823747/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal draft] Referencing the Objective-C selector of a method</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 11, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; control.sendAction(Selector(MyApplication.doSomething), to: target, forEvent: event)<br></p><p>How bad an idea would it be to make it simply be:<br></p><p>	control.sendAction(MyApplication.doSomething, to: target, forEvent: event)<br></p><p>That is, implicitly convert eligible unbound method references to selectors? From what I can tell, there&#39;s already going to be a certain amount of magic involved in this Selector initializer.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Referencing the Objective-C selector of a method</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 12, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 11:42 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; control.sendAction(Selector(MyApplication.doSomething), to: target, forEvent: event)<br>&gt; <br>&gt; How bad an idea would it be to make it simply be:<br>&gt; <br>&gt; 	control.sendAction(MyApplication.doSomething, to: target, forEvent: event)<br>&gt; <br>&gt; That is, implicitly convert eligible unbound method references to selectors? From what I can tell, there&#39;s already going to be a certain amount of magic involved in this Selector initializer.<br></p><p><br>I’m strongly against making this an implicit conversion. It’s a very lossy conversion, losing bother type information and (for something like myApplicationInstance.doSomething) the apparently-bound “self”. It should also not be super-common (so we don’t need to syntax-optimize it) and isn’t available where there is no Objective-C runtime.<br></p><p>	- Doug<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal draft] Referencing the Objective-C selector of a method</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>January 12, 2016 at 09:00:00am</p></header><div class="content"><p>Would this proposal allow Selector to be CustomStringConvertible? I often use @selector in my ORM classes and would like to be able to write:<br></p><p>class Person: ModelClass {<br>	var firstName: String = “”<br>	var lastName: String = “”<br></p><p>	func findPersonByName(name: String) -&gt; Person? {<br>		db.firstObjectFromQuery(“SELECT * FROM \(self) WHERE \(Selector(Person.firstName)) = :name OR \(Selector(Person.lastName)) = :name”, args: [“name”: name])<br>	}<br>}<br></p><p>&gt; On 11 Jan 2016, at 22:08, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Here’s a follow-up to the idea I posted for a simple expression to produce the selector for a given method, revised based on the discussion there. The proposal is over at<br>&gt; <br>&gt; 	https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md&gt;<br>&gt; <br>&gt; Referencing the Objective-C selector of a method<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-objc-selectors.md&gt;<br>&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#introduction&gt;Introduction<br>&gt; <br>&gt; In Swift 2, Objective-C selectors are written as string literals (e.g., &quot;insertSubview:aboveSubview:&quot;) in the type context of a Selector. This proposal seeks to replace this error-prone approach with Selector initialization syntax that refers to a specific method via its Swift name.<br>&gt; <br>&gt; Swift-evolution thread: here &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/1384/focus=1403&gt;<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#motivation&gt;Motivation<br>&gt; <br>&gt; The use of string literals for selector names is extremely error-prone: there is no checking that the string is even a well-formed selector, much less that it refers to any known method, or a method of the intended class. Moreover, with the effort to perform automatic renaming of Objective-C APIs &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;, the link between Swift name and Objective-C selector is non-obvious. By providing explicit &quot;create a selector&quot; syntax based on the Swift name of a method, we eliminate the need for developers to reason about the actual Objective-C selectors being used.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; Introduce Selector initialization syntax that allows one to build a selector from a reference to a method, e.g.,<br>&gt; <br>&gt; control.sendAction(Selector(MyApplication.doSomething), to: target, forEvent: event)<br>&gt; where “doSomething” is a method of MyApplication, which might even have a completely-unrelated name in Objective-C:<br>&gt; <br>&gt; extension MyApplication {<br>&gt;   @objc(jumpUpAndDown:)<br>&gt;   func doSomething(sender: AnyObject?) { … }<br>&gt; }<br>&gt; By naming the Swift method and having the Selector initializer do the work to form the Objective-C selector, we free the developer from having to do the naming translation manually and get static checking that the method exists and is exposed to Objective-C.<br>&gt; <br>&gt; This proposal composes with the Naming Functions with Argument Labels proposal &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006262.html&gt;, which lets us name methods along with their argument labels, e.g.:<br>&gt; <br>&gt; let sel = Selector(UIView.insertSubview(_:at:)) // produces the Selector &quot;insertSubview:atIndex:&quot;<br>&gt; With the introduction of the Selector syntax, we should deprecate the use of string literals to form selectors. Ideally, we could perform the deprecation in Swift 2.2 and remove the syntax entirely from Swift 3.<br>&gt; <br>&gt; Additionally, we should introduce specific migrator support to translate string-literals-as-selectors into method references. Doing this well is non-trivial, requiring the compiler/migrator to find all of the declarations with a particular Objective-C selector and determine which one to reference. However, it should be feasible, and we can migrator other references to a specific, string-based initialization syntax (e.g., Selector(&quot;insertSubview:atIndex:&quot;)).<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; The proposed Selector initializer &quot;almost&quot; has the signature:<br>&gt; <br>&gt; extension Selector {<br>&gt;   init&lt;T, U&gt;(_ fn: (T) -&gt; U)<br>&gt; }<br>&gt; with some additional semantic restrictions that require that input be a reference to an objc method. Specifically, the input expression must be a direct reference to an Objective-C method, possibly parenthesized and possible with an &quot;as&quot; cast (which can be used to disambiguate same-named Swift methods). For example, here is a &quot;highly general&quot; example:<br>&gt; <br>&gt; let sel = Selector(((UIKit.UIView.insertSubview(_:at:)) as (UIView) -&gt; (UIView, Int) -&gt; Void))<br>&gt; The actual implementation will introduce some magic in the type checker to only support references to methods within the Selector initialization syntax.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; The introduction of the Selector initialization syntax has no impact on existing code. However, deprecating and removing the string-literal-as-selector syntax is a source-breaking change. We can migrate the uses to either the new Selectorinitialization syntax or to explicit initialization of a Selector from a string.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; The primary alternative is type-safe selectors &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000233.html&gt;, which would introduce a new &quot;selector&quot; calling convetion to capture the type of an @objc method, including its selector. One major benefit of type-safe selectors is that they can carry type information, improving type safety. From that discussion, referencing MyClass.observeNotification would produce a value of type:<br>&gt; <br>&gt; @convention(selector) (MyClass) -&gt; (NSNotification) -&gt; Void<br>&gt; Objective-C APIs that accept selectors could provide type information (e.g., via Objective-C attributes or new syntax for a typed SEL), improving type safety for selector-based APIs. Personally, I feel that type-safe selectors are a well-designed feature that isn&#39;t worth doing: one would probably not use them outside of interoperability with existing Objective-C APIs, because closures are generally preferable (in both Swift and Objective-C). The cost of adding this feature to both Swift and Clang is significant, and we would also need adoption across a significant number of Objective-C APIs to make it worthwhile. On iOS, we are talking about a relatively small number of APIs (100-ish), and many of those have blocks/closure-based variants that are preferred anyway. Therefore, we should implement the simpler feature in this proposal rather than the far more complicated (but admittedly more type-safe) alternative approach.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/496bba77/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Referencing the Objective-C selector of a method</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 12, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 12, 2016, at 12:36 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; Would this proposal allow Selector to be CustomStringConvertible? I often use @selector in my ORM classes and would like to be able to write:<br>&gt; <br>&gt; class Person: ModelClass {<br>&gt; 	var firstName: String = “”<br>&gt; 	var lastName: String = “”<br>&gt; <br>&gt; 	func findPersonByName(name: String) -&gt; Person? {<br>&gt; 		db.firstObjectFromQuery(“SELECT * FROM \(self) WHERE \(Selector(Person.firstName)) = :name OR \(Selector(Person.lastName)) = :name”, args: [“name”: name])<br>&gt; 	}<br>&gt; }<br></p><p>It’s orthogonal to this proposal, but you’re absolutely right that Selector should be CustomStringConvertible.<br></p><p>	- Doug<br></p><p>&gt;&gt; On 11 Jan 2016, at 22:08, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Here’s a follow-up to the idea I posted for a simple expression to produce the selector for a given method, revised based on the discussion there. The proposal is over at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md&gt;<br>&gt;&gt; <br>&gt;&gt; Referencing the Objective-C selector of a method<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-objc-selectors.md&gt;<br>&gt;&gt; Author(s): Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; In Swift 2, Objective-C selectors are written as string literals (e.g., &quot;insertSubview:aboveSubview:&quot;) in the type context of a Selector. This proposal seeks to replace this error-prone approach with Selector initialization syntax that refers to a specific method via its Swift name.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: here &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/1384/focus=1403&gt;<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; The use of string literals for selector names is extremely error-prone: there is no checking that the string is even a well-formed selector, much less that it refers to any known method, or a method of the intended class. Moreover, with the effort to perform automatic renaming of Objective-C APIs &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;, the link between Swift name and Objective-C selector is non-obvious. By providing explicit &quot;create a selector&quot; syntax based on the Swift name of a method, we eliminate the need for developers to reason about the actual Objective-C selectors being used.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; Introduce Selector initialization syntax that allows one to build a selector from a reference to a method, e.g.,<br>&gt;&gt; <br>&gt;&gt; control.sendAction(Selector(MyApplication.doSomething), to: target, forEvent: event)<br>&gt;&gt; where “doSomething” is a method of MyApplication, which might even have a completely-unrelated name in Objective-C:<br>&gt;&gt; <br>&gt;&gt; extension MyApplication {<br>&gt;&gt;   @objc(jumpUpAndDown:)<br>&gt;&gt;   func doSomething(sender: AnyObject?) { … }<br>&gt;&gt; }<br>&gt;&gt; By naming the Swift method and having the Selector initializer do the work to form the Objective-C selector, we free the developer from having to do the naming translation manually and get static checking that the method exists and is exposed to Objective-C.<br>&gt;&gt; <br>&gt;&gt; This proposal composes with the Naming Functions with Argument Labels proposal &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006262.html&gt;, which lets us name methods along with their argument labels, e.g.:<br>&gt;&gt; <br>&gt;&gt; let sel = Selector(UIView.insertSubview(_:at:)) // produces the Selector &quot;insertSubview:atIndex:&quot;<br>&gt;&gt; With the introduction of the Selector syntax, we should deprecate the use of string literals to form selectors. Ideally, we could perform the deprecation in Swift 2.2 and remove the syntax entirely from Swift 3.<br>&gt;&gt; <br>&gt;&gt; Additionally, we should introduce specific migrator support to translate string-literals-as-selectors into method references. Doing this well is non-trivial, requiring the compiler/migrator to find all of the declarations with a particular Objective-C selector and determine which one to reference. However, it should be feasible, and we can migrator other references to a specific, string-based initialization syntax (e.g., Selector(&quot;insertSubview:atIndex:&quot;)).<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; The proposed Selector initializer &quot;almost&quot; has the signature:<br>&gt;&gt; <br>&gt;&gt; extension Selector {<br>&gt;&gt;   init&lt;T, U&gt;(_ fn: (T) -&gt; U)<br>&gt;&gt; }<br>&gt;&gt; with some additional semantic restrictions that require that input be a reference to an objc method. Specifically, the input expression must be a direct reference to an Objective-C method, possibly parenthesized and possible with an &quot;as&quot; cast (which can be used to disambiguate same-named Swift methods). For example, here is a &quot;highly general&quot; example:<br>&gt;&gt; <br>&gt;&gt; let sel = Selector(((UIKit.UIView.insertSubview(_:at:)) as (UIView) -&gt; (UIView, Int) -&gt; Void))<br>&gt;&gt; The actual implementation will introduce some magic in the type checker to only support references to methods within the Selector initialization syntax.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; The introduction of the Selector initialization syntax has no impact on existing code. However, deprecating and removing the string-literal-as-selector syntax is a source-breaking change. We can migrate the uses to either the new Selectorinitialization syntax or to explicit initialization of a Selector from a string.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/objc-selectors/proposals/0000-objc-selectors.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The primary alternative is type-safe selectors &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000233.html&gt;, which would introduce a new &quot;selector&quot; calling convetion to capture the type of an @objc method, including its selector. One major benefit of type-safe selectors is that they can carry type information, improving type safety. From that discussion, referencing MyClass.observeNotification would produce a value of type:<br>&gt;&gt; <br>&gt;&gt; @convention(selector) (MyClass) -&gt; (NSNotification) -&gt; Void<br>&gt;&gt; Objective-C APIs that accept selectors could provide type information (e.g., via Objective-C attributes or new syntax for a typed SEL), improving type safety for selector-based APIs. Personally, I feel that type-safe selectors are a well-designed feature that isn&#39;t worth doing: one would probably not use them outside of interoperability with existing Objective-C APIs, because closures are generally preferable (in both Swift and Objective-C). The cost of adding this feature to both Swift and Clang is significant, and we would also need adoption across a significant number of Objective-C APIs to make it worthwhile. On iOS, we are talking about a relatively small number of APIs (100-ish), and many of those have blocks/closure-based variants that are preferred anyway. Therefore, we should implement the simpler feature in this proposal rather than the far more complicated (but admittedly more type-safe) alternative approach.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/252b39a9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
