<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Fixing the confusion between non-mutating algorithms and single-pass sequences</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>July 20, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; &gt;&gt;&gt; Basically, I added back in a super-minimal protocol to fill the<br>&gt; &gt;&gt;&gt; structural gap left by Sequence.  I call it “IteratorProvider” and it<br>&gt; &gt;&gt;&gt; only has a single function which vends an iterator.  Collection<br>&gt; &gt;&gt;&gt; adheres to this, and Iterator adheres to it by returning itself.  All<br>&gt; &gt;&gt;&gt; of the other methods from Sequence remain on Iterator.  Thus anyone<br>&gt; &gt;&gt;&gt; with API that only needs a single pass would take a IteratorProvider<br>&gt; &gt;&gt;&gt; and then work on the iterator it provides.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; That leaves us back where we are now: people will see that<br>&gt; &gt;&gt; IteratorProvider is a simple, universal protocol for both single-and<br>&gt; &gt;&gt; multi-pass sequences, write algorithm libraries that depend on<br>&gt; &gt;&gt; multi-pass-ness, and test them with the most prevalent examples, which<br>&gt; &gt;&gt; happen to be multi pass.<br>&gt; &gt;<br>&gt; &gt; Let me make a quick counter-argument, because I thought about it a<br>&gt; &gt; bit, and I don’t think it does have the same problem (especially with<br>&gt; &gt; careful/better naming).<br>&gt; &gt;<br>&gt; &gt; The difference is that the ONLY method on IteratorProvider is the one<br>&gt; &gt; to get an iterator.  There is no map, filter, sort, first, count, etc…<br>&gt; &gt; just a way to get a single-pass iterator.  This changes the mindset<br>&gt; &gt; when using it.  You are aware that you are getting a single-pass<br>&gt; &gt; iterator.<br>&gt; <br>&gt; Maybe.  What&#39;s to stop people from extending IteratorProvider?<br></p><p>Nothing.  But that is true of any protocol.  I am ok with individual&#39;s extensions.  They would have to use that single method to build up from anyway, so presumably they would have to consider the single pass case in their extensions...<br></p><p><br></p><p>&gt; &gt; True, people might try to get the iterator a second time, but we can<br>&gt; &gt; make the iteratorProvider method optional (and trying to get an<br>&gt; &gt; iterator from an iterator which is spent would return nil) <br>&gt; &gt; and then they are forced to deal with the case where it was<br>&gt; &gt; single-pass.<br>&gt; <br>&gt; Now you can&#39;t loop over the same array multiple times.<br>I must be missing something.  Isn’t that the point?<br></p><p>I mean, your version is called “IterableOnce”.  Why do you want to iterate on IterableOnce more than once?  The point (at least in my mind) is to provide a common interface for things that we want to iterate over a single time.  If you want to iterate multiple times, use collection’s interface where you are guaranteed multi-pass.<br></p><p>That said, you actually can loop multiple times for collections by getting a new iterator from the provider (which could point to the same array storage).  The optional just forces you to check for the single-pass case.<br></p><p>I have a feeling like I am missing your true meaning here though...<br></p><p>Thanks,<br>Jon<br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/e24d9566/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Fixing the confusion between non-mutating algorithms and single-pass sequences</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>July 20, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 2:57 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; &gt; True, people might try to get the iterator a second time, but we can<br>&gt;&gt; &gt; make the iteratorProvider method optional (and trying to get an<br>&gt;&gt; &gt; iterator from an iterator which is spent would return nil)<br>&gt;&gt; &gt; and then they are forced to deal with the case where it was<br>&gt;&gt; &gt; single-pass.<br>&gt;&gt; <br>&gt;&gt; Now you can&#39;t loop over the same array multiple times.<br>&gt; I must be missing something.  Isn’t that the point?<br>&gt; <br>&gt; I mean, your version is called “IterableOnce”.  Why do you want to iterate on IterableOnce more than once?  The point (at least in my mind) is to provide a common interface for things that we want to iterate over a single time.  If you want to iterate multiple times, use collection’s interface where you are guaranteed multi-pass.<br>&gt; <br>&gt; That said, you actually can loop multiple times for collections by getting a new iterator from the provider (which could point to the same array storage).  The optional just forces you to check for the single-pass case.<br>&gt; <br>&gt; I have a feeling like I am missing your true meaning here though...<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br></p><p>Right - an iterator instance is single pass, but a method that returns an iterator may be able to make multiple iterators which iterate over the same sequence of values.<br></p><p>I still think ideally you can operate on iterators as streams of data directly, rather than requiring a base protocol. I understand how this could cause lots of duplication to have two ‘sequence’ implementations, however.<br></p><p>-DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/ea6a3347/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/ea6a3347/attachment.sig&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Fixing the confusion between non-mutating algorithms and single-pass sequences</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 20, 2016 at 03:00:00pm</p></header><div class="content"><p>on Wed Jul 20 2016, Jonathan Hull &lt;jhull-AT-gbis.com&gt; wrote:<br></p><p>&gt;&gt; &gt;&gt;&gt; Basically, I added back in a super-minimal protocol to fill the<br>&gt;&gt; &gt;&gt;&gt; structural gap left by Sequence.  I call it “IteratorProvider” and it<br>&gt;&gt; &gt;&gt;&gt; only has a single function which vends an iterator.  Collection<br>&gt;&gt; &gt;&gt;&gt; adheres to this, and Iterator adheres to it by returning itself.  All<br>&gt;&gt; &gt;&gt;&gt; of the other methods from Sequence remain on Iterator.  Thus anyone<br>&gt;<br>&gt;&gt; &gt;&gt;&gt; with API that only needs a single pass would take a IteratorProvider<br>&gt;&gt; &gt;&gt;&gt; and then work on the iterator it provides.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; That leaves us back where we are now: people will see that<br>&gt;&gt; &gt;&gt; IteratorProvider is a simple, universal protocol for both single-and<br>&gt;&gt; &gt;&gt; multi-pass sequences, write algorithm libraries that depend on<br>&gt;&gt; &gt;&gt; multi-pass-ness, and test them with the most prevalent examples, which<br>&gt;&gt; &gt;&gt; happen to be multi pass.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Let me make a quick counter-argument, because I thought about it a<br>&gt;&gt; &gt; bit, and I don’t think it does have the same problem (especially with<br>&gt;&gt; &gt; careful/better naming).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The difference is that the ONLY method on IteratorProvider is the one<br>&gt;&gt; &gt; to get an iterator.  There is no map, filter, sort, first, count, etc…<br>&gt;&gt; &gt; just a way to get a single-pass iterator.  This changes the mindset<br>&gt;&gt; &gt; when using it.  You are aware that you are getting a single-pass<br>&gt;&gt; &gt; iterator.<br>&gt;&gt; <br>&gt;&gt; Maybe.  What&#39;s to stop people from extending IteratorProvider?<br>&gt;<br>&gt; Nothing.  But that is true of any protocol.  I am ok with individual&#39;s<br>&gt; extensions.  They would have to use that single method to build up<br>&gt; from anyway, so presumably they would have to consider the single pass<br>&gt; case in their extensions...<br>&gt;<br>&gt;&gt; &gt; True, people might try to get the iterator a second time, but we can<br>&gt;&gt; &gt; make the iteratorProvider method optional (and trying to get an<br>&gt;&gt; &gt; iterator from an iterator which is spent would return nil) <br>&gt;&gt; &gt; and then they are forced to deal with the case where it was<br>&gt;&gt; &gt; single-pass.<br>&gt;&gt; <br>&gt;&gt; Now you can&#39;t loop over the same array multiple times.<br>&gt; I must be missing something.  Isn’t that the point?<br></p><p>No.  Arrays are multipass.<br></p><p>&gt; I mean, your version is called “IterableOnce”.  Why do you want to<br>&gt; iterate on IterableOnce more than once?  <br></p><p>Because it happens to be multipass.<br></p><p>&gt; The point (at least in my mind) is to provide a common interface for<br>&gt; things that we want to iterate over a single time.  If you want to<br>&gt; iterate multiple times, use collection’s interface where you are<br>&gt; guaranteed multi-pass.<br></p><p>for ... in uses Iterators.<br></p><p>&gt; That said, you actually can loop multiple times for collections by<br>&gt; getting a new iterator from the provider (which could point to the<br>&gt; same array storage).  The optional just forces you to check for the<br>&gt; single-pass case.<br></p><p>Oh, I&#39;m sorry; I didn&#39;t realize you were saying that only single-pass<br>IteratorProviders would ever return nil from their methods.<br></p><p>&gt; I have a feeling like I am missing your true meaning here though...<br></p><p>Probably a communication failure on my end.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
