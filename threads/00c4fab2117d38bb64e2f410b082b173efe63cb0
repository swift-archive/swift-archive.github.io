<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 27, 2016 at 03:00:00pm</p></header><div class="content"><p>Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br></p><p>The third review of &quot;SE-0177: Allow distinguishing between public access and public overridability&quot; ran from Active review July 21...25. The proposal has been *accepted with revisions*.<br></p><p>This proposal was far better received by the community than previous versions of the proposal, and the ‚Äúfirst design‚Äù was the favored path within it.  However, there were some concerns raised about the complexity of the model, stemming from non-obvious combinations like ‚Äúopen private‚Äù.  As such, the core team has requested that the proposal be revised to make ‚Äúopen‚Äù function as another access control specifier.  ‚Äúopen‚Äù is now simply ‚Äúmore public than public‚Äù, providing a very simple and clean model.<br></p><p>John has already revised the proposal to the new model, I encourage you to read it if you haven‚Äôt already.<br></p><p>Thank you to John McCall and also Javier Soto for driving this discussion forward!  John is already working on an implementation of this now.<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c72bd3ba434ad651a5d8d3d79f2d4c49?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>Scott James Remnant</string> &lt;scott at netsplit.com&gt;<p>July 27, 2016 at 03:00:00pm</p></header><div class="content"><p>I realize that there‚Äôs no review needed, but I actually wanted to give a hearty üëè to the authors and commenters of this proposal, because I genuinely think we‚Äôve reached something good in the result.<br></p><p>The selling point for me is this:<br></p><p>// This is allowed since the superclass is `open`.<br>class SubclassB : SubclassableParentClass {<br>    // This is invalid because it overrides a method that is<br>    // defined outside of the current module but is not `open&#39;.<br>    override func foo() { }<br></p><p>    // This is allowed since the superclass&#39;s method is overridable.<br>    // It does not need to be marked `open` because it is defined on<br>    // an `internal` class.<br>    override func bar() { }<br>}<br></p><p>This feels super-clean; it gives Library developers `open` for their APIs, without confusing app developers, and still requires that sub-classing Library developers think about `open`.<br></p><p>Good job, everyone!<br></p><p>Scott<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160727/0c5fc55e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>July 27, 2016 at 04:00:00pm</p></header><div class="content"><p>I brought this up in review, but there seems to be a serious testability problem here because of how special @testable is.<br></p><p>// This class is not subclassable outside of ModuleA.<br>public class NonSubclassableParentClass {<br>    // This method is not overridable outside of ModuleA.<br>    public func foo() {}<br></p><p>    // This method is not overridable outside of ModuleA because<br>    // its class restricts its access level.<br>    // It is not invalid to declare it as `open`.<br>    open func bar() {}<br></p><p>    // The behavior of `final` methods remains unchanged.<br>    public final func baz() {}<br>}<br></p><p>In a unit test, I *can* subclass `NonSubclassableParentClass`, the access level of `NonSubclassableParentClass` is irrelevant. There‚Äôs now no programatic way to ensure that I‚Äôm actually testing the contract that I had intended to provide to the consumers of my framework (that my class is subclassable). Is this really the intention?<br></p><p>The ‚Äúfix‚Äù, on the authors end, is to create another target that consumes the output framework to ensure my contract is actually what I wanted (and make sure that it‚Äôs not a special test target!). No one is going to do this.<br></p><p>Sure, maybe a code review might catch it. Or I can write a custom linter to validate for this. Do we really want `open` members in non `open` types? The issue with `public` members on `internal` types is much less concerning as the `internal` type isn‚Äôt being exposed to others to begin with.<br></p><p>-David<br></p><p><br>&gt; On Jul 27, 2016, at 3:18 PM, Scott James Remnant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I realize that there‚Äôs no review needed, but I actually wanted to give a hearty üëè to the authors and commenters of this proposal, because I genuinely think we‚Äôve reached something good in the result.<br>&gt; <br>&gt; The selling point for me is this:<br>&gt; <br>&gt; // This is allowed since the superclass is `open`.<br>&gt; class SubclassB : SubclassableParentClass {<br>&gt;     // This is invalid because it overrides a method that is<br>&gt;     // defined outside of the current module but is not `open&#39;.<br>&gt;     override func foo() { }<br>&gt; <br>&gt;     // This is allowed since the superclass&#39;s method is overridable.<br>&gt;     // It does not need to be marked `open` because it is defined on<br>&gt;     // an `internal` class.<br>&gt;     override func bar() { }<br>&gt; }<br>&gt; <br>&gt; This feels super-clean; it gives Library developers `open` for their APIs, without confusing app developers, and still requires that sub-classing Library developers think about `open`.<br>&gt; <br>&gt; Good job, everyone!<br>&gt; <br>&gt; Scott<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160727/84bbfd2a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 27, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 27, 2016, at 4:41 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I brought this up in review, but there seems to be a serious testability problem here because of how special @testable is.<br>&gt; <br>&gt; // This class is not subclassable outside of ModuleA.<br>&gt; public class NonSubclassableParentClass {<br>&gt;     // This method is not overridable outside of ModuleA.<br>&gt;     public func foo() {}<br>&gt; <br>&gt;     // This method is not overridable outside of ModuleA because<br>&gt;     // its class restricts its access level.<br>&gt;     // It is not invalid to declare it as `open`.<br>&gt;     open func bar() {}<br>&gt; <br>&gt;     // The behavior of `final` methods remains unchanged.<br>&gt;     public final func baz() {}<br>&gt; }<br>&gt; <br>&gt; In a unit test, I *can* subclass `NonSubclassableParentClass`, the access level of `NonSubclassableParentClass` is irrelevant. There‚Äôs now no programatic way to ensure that I‚Äôm actually testing the contract that I had intended to provide to the consumers of my framework (that my class is subclassable). Is this really the intention?<br></p><p>A &quot;black box&quot; unit test emulating consumer behavior has no business using a @testable import.  It should just use the external API of the library.<br></p><p>John.<br></p><p>&gt; <br>&gt; The ‚Äúfix‚Äù, on the authors end, is to create another target that consumes the output framework to ensure my contract is actually what I wanted (and make sure that it‚Äôs not a special test target!). No one is going to do this.<br>&gt; <br>&gt; Sure, maybe a code review might catch it. Or I can write a custom linter to validate for this. Do we really want `open` members in non `open` types? The issue with `public` members on `internal` types is much less concerning as the `internal` type isn‚Äôt being exposed to others to begin with.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 27, 2016, at 3:18 PM, Scott James Remnant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I realize that there‚Äôs no review needed, but I actually wanted to give a hearty üëè to the authors and commenters of this proposal, because I genuinely think we‚Äôve reached something good in the result.<br>&gt;&gt; <br>&gt;&gt; The selling point for me is this:<br>&gt;&gt; <br>&gt;&gt; // This is allowed since the superclass is `open`.<br>&gt;&gt; class SubclassB : SubclassableParentClass {<br>&gt;&gt;     // This is invalid because it overrides a method that is<br>&gt;&gt;     // defined outside of the current module but is not `open&#39;.<br>&gt;&gt;     override func foo() { }<br>&gt;&gt; <br>&gt;&gt;     // This is allowed since the superclass&#39;s method is overridable.<br>&gt;&gt;     // It does not need to be marked `open` because it is defined on<br>&gt;&gt;     // an `internal` class.<br>&gt;&gt;     override func bar() { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This feels super-clean; it gives Library developers `open` for their APIs, without confusing app developers, and still requires that sub-classing Library developers think about `open`.<br>&gt;&gt; <br>&gt;&gt; Good job, everyone!<br>&gt;&gt; <br>&gt;&gt; Scott<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160727/922bd215/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>July 27, 2016 at 05:00:00pm</p></header><div class="content"><p>While arguably true, that&#39;s a philosophical debate. There are plenty of reasons to use @testable, and if that&#39;s what people are using, then I think there is a valid concern here. <br></p><p>Sent from my iPhone<br></p><p>&gt; On Jul 27, 2016, at 5:22 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 27, 2016, at 4:41 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I brought this up in review, but there seems to be a serious testability problem here because of how special @testable is.<br>&gt;&gt; <br>&gt;&gt; // This class is not subclassable outside of ModuleA.<br>&gt;&gt; public class NonSubclassableParentClass {<br>&gt;&gt;     // This method is not overridable outside of ModuleA.<br>&gt;&gt;     public func foo() {}<br>&gt;&gt; <br>&gt;&gt;     // This method is not overridable outside of ModuleA because<br>&gt;&gt;     // its class restricts its access level.<br>&gt;&gt;     // It is not invalid to declare it as `open`.<br>&gt;&gt;     open func bar() {}<br>&gt;&gt; <br>&gt;&gt;     // The behavior of `final` methods remains unchanged.<br>&gt;&gt;     public final func baz() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In a unit test, I *can* subclass `NonSubclassableParentClass`, the access level of `NonSubclassableParentClass` is irrelevant. There‚Äôs now no programatic way to ensure that I‚Äôm actually testing the contract that I had intended to provide to the consumers of my framework (that my class is subclassable). Is this really the intention?<br>&gt; <br>&gt; A &quot;black box&quot; unit test emulating consumer behavior has no business using a @testable import.  It should just use the external API of the library.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; The ‚Äúfix‚Äù, on the authors end, is to create another target that consumes the output framework to ensure my contract is actually what I wanted (and make sure that it‚Äôs not a special test target!). No one is going to do this.<br>&gt;&gt; <br>&gt;&gt; Sure, maybe a code review might catch it. Or I can write a custom linter to validate for this. Do we really want `open` members in non `open` types? The issue with `public` members on `internal` types is much less concerning as the `internal` type isn‚Äôt being exposed to others to begin with.<br>&gt;&gt; <br>&gt;&gt; -David<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 27, 2016, at 3:18 PM, Scott James Remnant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I realize that there‚Äôs no review needed, but I actually wanted to give a hearty üëè to the authors and commenters of this proposal, because I genuinely think we‚Äôve reached something good in the result.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The selling point for me is this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // This is allowed since the superclass is `open`.<br>&gt;&gt;&gt; class SubclassB : SubclassableParentClass {<br>&gt;&gt;&gt;     // This is invalid because it overrides a method that is<br>&gt;&gt;&gt;     // defined outside of the current module but is not `open&#39;.<br>&gt;&gt;&gt;     override func foo() { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // This is allowed since the superclass&#39;s method is overridable.<br>&gt;&gt;&gt;     // It does not need to be marked `open` because it is defined on<br>&gt;&gt;&gt;     // an `internal` class.<br>&gt;&gt;&gt;     override func bar() { }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This feels super-clean; it gives Library developers `open` for their APIs, without confusing app developers, and still requires that sub-classing Library developers think about `open`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Good job, everyone!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Scott<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160727/f14ea905/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July 27, 2016 at 05:00:00pm</p></header><div class="content"><p>Other than warning on open methods in non-open classes, I can‚Äôt think of a good way to avoid this and still preserve the rest of the testing model. After all, @testable allows you to override internal methods too.<br></p><p>(Just to make things clear, @testable only applies to the current file, so it‚Äôs possible to have a single test bundle with both black-box and glass-box tests, as long as they‚Äôre in different files.)<br></p><p>Jordan<br></p><p><br>&gt; On Jul 27, 2016, at 17:40, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; While arguably true, that&#39;s a philosophical debate. There are plenty of reasons to use @testable, and if that&#39;s what people are using, then I think there is a valid concern here. <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Jul 27, 2016, at 5:22 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jul 27, 2016, at 4:41 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; I brought this up in review, but there seems to be a serious testability problem here because of how special @testable is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // This class is not subclassable outside of ModuleA.<br>&gt;&gt;&gt; public class NonSubclassableParentClass {<br>&gt;&gt;&gt;     // This method is not overridable outside of ModuleA.<br>&gt;&gt;&gt;     public func foo() {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // This method is not overridable outside of ModuleA because<br>&gt;&gt;&gt;     // its class restricts its access level.<br>&gt;&gt;&gt;     // It is not invalid to declare it as `open`.<br>&gt;&gt;&gt;     open func bar() {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // The behavior of `final` methods remains unchanged.<br>&gt;&gt;&gt;     public final func baz() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In a unit test, I *can* subclass `NonSubclassableParentClass`, the access level of `NonSubclassableParentClass` is irrelevant. There‚Äôs now no programatic way to ensure that I‚Äôm actually testing the contract that I had intended to provide to the consumers of my framework (that my class is subclassable). Is this really the intention?<br>&gt;&gt; <br>&gt;&gt; A &quot;black box&quot; unit test emulating consumer behavior has no business using a @testable import.  It should just use the external API of the library.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The ‚Äúfix‚Äù, on the authors end, is to create another target that consumes the output framework to ensure my contract is actually what I wanted (and make sure that it‚Äôs not a special test target!). No one is going to do this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sure, maybe a code review might catch it. Or I can write a custom linter to validate for this. Do we really want `open` members in non `open` types? The issue with `public` members on `internal` types is much less concerning as the `internal` type isn‚Äôt being exposed to others to begin with.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 27, 2016, at 3:18 PM, Scott James Remnant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I realize that there‚Äôs no review needed, but I actually wanted to give a hearty üëè to the authors and commenters of this proposal, because I genuinely think we‚Äôve reached something good in the result.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The selling point for me is this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // This is allowed since the superclass is `open`.<br>&gt;&gt;&gt;&gt; class SubclassB : SubclassableParentClass {<br>&gt;&gt;&gt;&gt;     // This is invalid because it overrides a method that is<br>&gt;&gt;&gt;&gt;     // defined outside of the current module but is not `open&#39;.<br>&gt;&gt;&gt;&gt;     override func foo() { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     // This is allowed since the superclass&#39;s method is overridable.<br>&gt;&gt;&gt;&gt;     // It does not need to be marked `open` because it is defined on<br>&gt;&gt;&gt;&gt;     // an `internal` class.<br>&gt;&gt;&gt;&gt;     override func bar() { }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This feels super-clean; it gives Library developers `open` for their APIs, without confusing app developers, and still requires that sub-classing Library developers think about `open`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Good job, everyone!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Scott<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160727/3fd19a38/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 27, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jul 27, 2016, at 5:40 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; While arguably true, that&#39;s a philosophical debate. There are plenty of reasons to use @testable, and if that&#39;s what people are using, then I think there is a valid concern here. <br></p><p>There are absolutely plenty of reasons to use @testable.  But if you&#39;re a library developer, and you&#39;re writing a test that specifically is validating that a third party will be able to use your library the way you want it to be used, that is the very definition of black-box testing, and you should not be using a @testable import in that specific test.  The compiler&#39;s standard behavior if you don&#39;t use a @testable import is *exactly* the custom linter that you&#39;re talking about writing.<br></p><p>Like Jordan said, @testable imports are file-specific, so you can freely mix tests that use them with tests that don&#39;t.  If you have common testing infrastructure that needs internal access to your library, that&#39;s pretty easy to put in its own file, too.<br></p><p>John.<br></p><p>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Jul 27, 2016, at 5:22 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jul 27, 2016, at 4:41 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; I brought this up in review, but there seems to be a serious testability problem here because of how special @testable is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // This class is not subclassable outside of ModuleA.<br>&gt;&gt;&gt; public class NonSubclassableParentClass {<br>&gt;&gt;&gt;     // This method is not overridable outside of ModuleA.<br>&gt;&gt;&gt;     public func foo() {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // This method is not overridable outside of ModuleA because<br>&gt;&gt;&gt;     // its class restricts its access level.<br>&gt;&gt;&gt;     // It is not invalid to declare it as `open`.<br>&gt;&gt;&gt;     open func bar() {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // The behavior of `final` methods remains unchanged.<br>&gt;&gt;&gt;     public final func baz() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In a unit test, I *can* subclass `NonSubclassableParentClass`, the access level of `NonSubclassableParentClass` is irrelevant. There‚Äôs now no programatic way to ensure that I‚Äôm actually testing the contract that I had intended to provide to the consumers of my framework (that my class is subclassable). Is this really the intention?<br>&gt;&gt; <br>&gt;&gt; A &quot;black box&quot; unit test emulating consumer behavior has no business using a @testable import.  It should just use the external API of the library.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The ‚Äúfix‚Äù, on the authors end, is to create another target that consumes the output framework to ensure my contract is actually what I wanted (and make sure that it‚Äôs not a special test target!). No one is going to do this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sure, maybe a code review might catch it. Or I can write a custom linter to validate for this. Do we really want `open` members in non `open` types? The issue with `public` members on `internal` types is much less concerning as the `internal` type isn‚Äôt being exposed to others to begin with.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 27, 2016, at 3:18 PM, Scott James Remnant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I realize that there‚Äôs no review needed, but I actually wanted to give a hearty üëè to the authors and commenters of this proposal, because I genuinely think we‚Äôve reached something good in the result.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The selling point for me is this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // This is allowed since the superclass is `open`.<br>&gt;&gt;&gt;&gt; class SubclassB : SubclassableParentClass {<br>&gt;&gt;&gt;&gt;     // This is invalid because it overrides a method that is<br>&gt;&gt;&gt;&gt;     // defined outside of the current module but is not `open&#39;.<br>&gt;&gt;&gt;&gt;     override func foo() { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     // This is allowed since the superclass&#39;s method is overridable.<br>&gt;&gt;&gt;&gt;     // It does not need to be marked `open` because it is defined on<br>&gt;&gt;&gt;&gt;     // an `internal` class.<br>&gt;&gt;&gt;&gt;     override func bar() { }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This feels super-clean; it gives Library developers `open` for their APIs, without confusing app developers, and still requires that sub-classing Library developers think about `open`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Good job, everyone!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Scott<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160727/6e4ba295/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 27, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jul 27, 2016, at 4:41 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I brought this up in review, but there seems to be a serious testability problem here because of how special @testable is.<br>&gt; <br>&gt; // This class is not subclassable outside of ModuleA.<br>&gt; public class NonSubclassableParentClass {<br>&gt;     // This method is not overridable outside of ModuleA.<br>&gt;     public func foo() {}<br>&gt; <br>&gt;     // This method is not overridable outside of ModuleA because<br>&gt;     // its class restricts its access level.<br>&gt;     // It is not invalid to declare it as `open`.<br>&gt;     open func bar() {}<br>&gt; <br>&gt;     // The behavior of `final` methods remains unchanged.<br>&gt;     public final func baz() {}<br>&gt; }<br>&gt; <br>&gt; In a unit test, I *can* subclass `NonSubclassableParentClass`, the access level of `NonSubclassableParentClass` is irrelevant. There‚Äôs now no programatic way to ensure that I‚Äôm actually testing the contract that I had intended to provide to the consumers of my framework (that my class is subclassable). Is this really the intention?<br></p><p>I could be wrong, but isn&#39;t `@testable import` applied per-file? So if you keep code users should actually be able to write in one file with a non-`@testable` import, and mocks and other testing hacks in a different file with an `@testable` import, the first file should fail to compile if you use anything that&#39;s not normally permitted.<br></p><p>In a future version of Swift, we might consider refining this by requiring people to apply `@testable` directly to declarations which treat something closed as if it&#39;s open, but it seems like even the current feature set does not make testing impossible.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 27, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jul 27, 2016, at 8:36 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 27, 2016, at 4:41 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I brought this up in review, but there seems to be a serious testability problem here because of how special @testable is.<br>&gt;&gt; <br>&gt;&gt; // This class is not subclassable outside of ModuleA.<br>&gt;&gt; public class NonSubclassableParentClass {<br>&gt;&gt;    // This method is not overridable outside of ModuleA.<br>&gt;&gt;    public func foo() {}<br>&gt;&gt; <br>&gt;&gt;    // This method is not overridable outside of ModuleA because<br>&gt;&gt;    // its class restricts its access level.<br>&gt;&gt;    // It is not invalid to declare it as `open`.<br>&gt;&gt;    open func bar() {}<br>&gt;&gt; <br>&gt;&gt;    // The behavior of `final` methods remains unchanged.<br>&gt;&gt;    public final func baz() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In a unit test, I *can* subclass `NonSubclassableParentClass`, the access level of `NonSubclassableParentClass` is irrelevant. There‚Äôs now no programatic way to ensure that I‚Äôm actually testing the contract that I had intended to provide to the consumers of my framework (that my class is subclassable). Is this really the intention?<br>&gt; <br>&gt; I could be wrong, but isn&#39;t `@testable import` applied per-file? So if you keep code users should actually be able to write in one file with a non-`@testable` import, and mocks and other testing hacks in a different file with an `@testable` import, the first file should fail to compile if you use anything that&#39;s not normally permitted.<br>&gt; <br>&gt; In a future version of Swift, we might consider refining this by requiring people to apply `@testable` directly to declarations which treat something closed as if it&#39;s open, but it seems like even the current feature set does not make testing impossible.<br></p><p>+1 to @testable on declarations.  I really do not like making things internal when they should be private just because a test needs to inspect state.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 27, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jul 27, 2016, at 6:43 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; In a future version of Swift, we might consider refining this by requiring people to apply `@testable` directly to declarations which treat something closed as if it&#39;s open, but it seems like even the current feature set does not make testing impossible.<br>&gt; <br>&gt; +1 to @testable on declarations.  I really do not like making things internal when they should be private just because a test needs to inspect state.<br></p><p>Whoa, that wasn&#39;t what I was suggesting at all. I was suggesting that the *test suite* should mark the forbidden subclass/override with `@testable`.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 27, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jul 27, 2016, at 8:47 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 27, 2016, at 6:43 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; In a future version of Swift, we might consider refining this by requiring people to apply `@testable` directly to declarations which treat something closed as if it&#39;s open, but it seems like even the current feature set does not make testing impossible.<br>&gt;&gt; <br>&gt;&gt; +1 to @testable on declarations.  I really do not like making things internal when they should be private just because a test needs to inspect state.<br>&gt; <br>&gt; Whoa, that wasn&#39;t what I was suggesting at all. I was suggesting that the *test suite* should mark the forbidden subclass/override with `@testable`.<br></p><p>Sorry, I misread that.  But I still stand by the enhancement to @testable I mentioned.  There are times when access control is wider than necessary to support tests and it always sucks doing that.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>July 27, 2016 at 06:00:00pm</p></header><div class="content"><p>Yes, it‚Äôs per file. It‚Äôs also added in the initial template that Xcode creates with your project. In addition, it‚Äôs recommended by many that talk about ‚Äúhow to unit test in Swift.‚Äù So, to someone that is not paying scrupulous attention, there is no mechanism to prevent against this today.<br></p><p>This also assumes that people write tests‚Ä¶ which, well, we know is not the case at all.<br></p><p>I guess time will tell if this should be a warning/error or not depending on the usage of the various Swift linters that I‚Äôm sure will start to become prevalent. I know it‚Äôs something I‚Äôll be enabling in my code.<br></p><p>It seems this design is acceptable and by-design.<br></p><p>-David<br></p><p><br>&gt; On Jul 27, 2016, at 6:36 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 27, 2016, at 4:41 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I brought this up in review, but there seems to be a serious testability problem here because of how special @testable is.<br>&gt;&gt; <br>&gt;&gt; // This class is not subclassable outside of ModuleA.<br>&gt;&gt; public class NonSubclassableParentClass {<br>&gt;&gt;    // This method is not overridable outside of ModuleA.<br>&gt;&gt;    public func foo() {}<br>&gt;&gt; <br>&gt;&gt;    // This method is not overridable outside of ModuleA because<br>&gt;&gt;    // its class restricts its access level.<br>&gt;&gt;    // It is not invalid to declare it as `open`.<br>&gt;&gt;    open func bar() {}<br>&gt;&gt; <br>&gt;&gt;    // The behavior of `final` methods remains unchanged.<br>&gt;&gt;    public final func baz() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In a unit test, I *can* subclass `NonSubclassableParentClass`, the access level of `NonSubclassableParentClass` is irrelevant. There‚Äôs now no programatic way to ensure that I‚Äôm actually testing the contract that I had intended to provide to the consumers of my framework (that my class is subclassable). Is this really the intention?<br>&gt; <br>&gt; I could be wrong, but isn&#39;t `@testable import` applied per-file? So if you keep code users should actually be able to write in one file with a non-`@testable` import, and mocks and other testing hacks in a different file with an `@testable` import, the first file should fail to compile if you use anything that&#39;s not normally permitted.<br>&gt; <br>&gt; In a future version of Swift, we might consider refining this by requiring people to apply `@testable` directly to declarations which treat something closed as if it&#39;s open, but it seems like even the current feature set does not make testing impossible.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 27, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jul 27, 2016, at 6:55 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yes, it‚Äôs per file. It‚Äôs also added in the initial template that Xcode creates with your project. In addition, it‚Äôs recommended by many that talk about ‚Äúhow to unit test in Swift.‚Äù So, to someone that is not paying scrupulous attention, there is no mechanism to prevent against this today.<br></p><p>Perhaps we&#39;re not doing a good job of messaging this.<br></p><p>The Xcode template is the way it is because @testable imports are the right default for a *program* written in Swift.  A lot of the code in an application or command-line program isn&#39;t really suitable for independent, in-process black-box testing, because it isn&#39;t really presenting an integrated API.  If you break it down into components that can be independently tested, that&#39;s awesome, and at that point you can switch the imports in your tests over to non- at testable.  But we don&#39;t want the test template to create any obstacles to testing, because as you say, people already don&#39;t write enough tests.<br></p><p>In contrast, a library developer needs to be more conscientious about the difference between black-box and white-box testing.  In fact, they should really be leaning towards making black-box tests whenever that&#39;s reasonably practical.  We don&#39;t currently have Xcode templates around making Swift libraries, though; I think we all agree that there&#39;s a lot of room for tools improvement there.<br></p><p>John.<br></p><p>&gt; This also assumes that people write tests‚Ä¶ which, well, we know is not the case at all.<br>&gt; <br>&gt; I guess time will tell if this should be a warning/error or not depending on the usage of the various Swift linters that I‚Äôm sure will start to become prevalent. I know it‚Äôs something I‚Äôll be enabling in my code.<br>&gt; <br>&gt; It seems this design is acceptable and by-design.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 27, 2016, at 6:36 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 27, 2016, at 4:41 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I brought this up in review, but there seems to be a serious testability problem here because of how special @testable is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // This class is not subclassable outside of ModuleA.<br>&gt;&gt;&gt; public class NonSubclassableParentClass {<br>&gt;&gt;&gt;   // This method is not overridable outside of ModuleA.<br>&gt;&gt;&gt;   public func foo() {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // This method is not overridable outside of ModuleA because<br>&gt;&gt;&gt;   // its class restricts its access level.<br>&gt;&gt;&gt;   // It is not invalid to declare it as `open`.<br>&gt;&gt;&gt;   open func bar() {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // The behavior of `final` methods remains unchanged.<br>&gt;&gt;&gt;   public final func baz() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In a unit test, I *can* subclass `NonSubclassableParentClass`, the access level of `NonSubclassableParentClass` is irrelevant. There‚Äôs now no programatic way to ensure that I‚Äôm actually testing the contract that I had intended to provide to the consumers of my framework (that my class is subclassable). Is this really the intention?<br>&gt;&gt; <br>&gt;&gt; I could be wrong, but isn&#39;t `@testable import` applied per-file? So if you keep code users should actually be able to write in one file with a non-`@testable` import, and mocks and other testing hacks in a different file with an `@testable` import, the first file should fail to compile if you use anything that&#39;s not normally permitted.<br>&gt;&gt; <br>&gt;&gt; In a future version of Swift, we might consider refining this by requiring people to apply `@testable` directly to declarations which treat something closed as if it&#39;s open, but it seems like even the current feature set does not make testing impossible.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>July 27, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jul 27, 2016, at 7:18 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 27, 2016, at 6:55 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yes, it‚Äôs per file. It‚Äôs also added in the initial template that Xcode creates with your project. In addition, it‚Äôs recommended by many that talk about ‚Äúhow to unit test in Swift.‚Äù So, to someone that is not paying scrupulous attention, there is no mechanism to prevent against this today.<br>&gt; <br>&gt; Perhaps we&#39;re not doing a good job of messaging this.<br>&gt; <br>&gt; The Xcode template is the way it is because @testable imports are the right default for a *program* written in Swift.  A lot of the code in an application or command-line program isn&#39;t really suitable for independent, in-process black-box testing, because it isn&#39;t really presenting an integrated API.  If you break it down into components that can be independently tested, that&#39;s awesome, and at that point you can switch the imports in your tests over to non- at testable.  But we don&#39;t want the test template to create any obstacles to testing, because as you say, people already don&#39;t write enough tests.<br></p><p>My primary concern is that it‚Äôs easy to think you‚Äôve done the right thing and push out a release because all of your testing shows it‚Äôs good, only to find you messed up in a way that it‚Äôs easy for a tool to validate. Writing new code is probably not going to be the primary source of this, but refactoring a `public` class to an `open` one, where there are already existing tests for that class, probably in a single file and using `@testable`, it‚Äôs easy to say, ‚Äúlooks good, tests passed, integrations look good.‚Äù<br></p><p>&gt; In contrast, a library developer needs to be more conscientious about the difference between black-box and white-box testing.  In fact, they should really be leaning towards making black-box tests whenever that&#39;s reasonably practical.  We don&#39;t currently have Xcode templates around making Swift libraries, though; I think we all agree that there&#39;s a lot of room for tools improvement there.<br></p><p>Just FYI: The default Frameworks target also uses @testable for the Swift unit tests.<br></p><p>Regardless, there are mitigations that can turn this potential (maybe it‚Äôs not even an issue in practice) test-time error into a near compile-time error (using a linter).<br></p><p>-David<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 27, 2016 at 10:00:00pm</p></header><div class="content"><p>On Wed, Jul 27, 2016 at 10:30 PM, David Owens II via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jul 27, 2016, at 7:18 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jul 27, 2016, at 6:55 PM, David Owens II via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Yes, it‚Äôs per file. It‚Äôs also added in the initial template that Xcode<br>&gt; creates with your project. In addition, it‚Äôs recommended by many that talk<br>&gt; about ‚Äúhow to unit test in Swift.‚Äù So, to someone that is not paying<br>&gt; scrupulous attention, there is no mechanism to prevent against this today.<br>&gt; &gt;<br>&gt; &gt; Perhaps we&#39;re not doing a good job of messaging this.<br>&gt; &gt;<br>&gt; &gt; The Xcode template is the way it is because @testable imports are the<br>&gt; right default for a *program* written in Swift.  A lot of the code in an<br>&gt; application or command-line program isn&#39;t really suitable for independent,<br>&gt; in-process black-box testing, because it isn&#39;t really presenting an<br>&gt; integrated API.  If you break it down into components that can be<br>&gt; independently tested, that&#39;s awesome, and at that point you can switch the<br>&gt; imports in your tests over to non- at testable.  But we don&#39;t want the test<br>&gt; template to create any obstacles to testing, because as you say, people<br>&gt; already don&#39;t write enough tests.<br>&gt;<br>&gt; My primary concern is that it‚Äôs easy to think you‚Äôve done the right thing<br>&gt; and push out a release because all of your testing shows it‚Äôs good, only to<br>&gt; find you messed up in a way that it‚Äôs easy for a tool to validate. Writing<br>&gt; new code is probably not going to be the primary source of this, but<br>&gt; refactoring a `public` class to an `open` one, where there are already<br>&gt; existing tests for that class, probably in a single file and using<br>&gt; `@testable`, it‚Äôs easy to say, ‚Äúlooks good, tests passed, integrations look<br>&gt; good.‚Äù<br>&gt;<br></p><p>If you&#39;re refactoring `public` classes into `open` ones, though, you&#39;d be<br>more likely to have forgotten to open a method you intend to make<br>overridable, no? And there&#39;s no way to change the rules here to have<br>`@testable` pick that up...<br></p><p>&gt; In contrast, a library developer needs to be more conscientious about the<br>&gt; difference between black-box and white-box testing.  In fact, they should<br>&gt; really be leaning towards making black-box tests whenever that&#39;s reasonably<br>&gt; practical.  We don&#39;t currently have Xcode templates around making Swift<br>&gt; libraries, though; I think we all agree that there&#39;s a lot of room for<br>&gt; tools improvement there.<br>&gt;<br>&gt; Just FYI: The default Frameworks target also uses @testable for the Swift<br>&gt; unit tests.<br>&gt;<br>&gt; Regardless, there are mitigations that can turn this potential (maybe it‚Äôs<br>&gt; not even an issue in practice) test-time error into a near compile-time<br>&gt; error (using a linter).<br>&gt;<br>&gt; -David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160727/9cee79de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>July 27, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jul 27, 2016, at 8:52 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jul 27, 2016 at 10:30 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Jul 27, 2016, at 7:18 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jul 27, 2016, at 6:55 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Yes, it‚Äôs per file. It‚Äôs also added in the initial template that Xcode creates with your project. In addition, it‚Äôs recommended by many that talk about ‚Äúhow to unit test in Swift.‚Äù So, to someone that is not paying scrupulous attention, there is no mechanism to prevent against this today.<br>&gt; &gt;<br>&gt; &gt; Perhaps we&#39;re not doing a good job of messaging this.<br>&gt; &gt;<br>&gt; &gt; The Xcode template is the way it is because @testable imports are the right default for a *program* written in Swift.  A lot of the code in an application or command-line program isn&#39;t really suitable for independent, in-process black-box testing, because it isn&#39;t really presenting an integrated API.  If you break it down into components that can be independently tested, that&#39;s awesome, and at that point you can switch the imports in your tests over to non- at testable.  But we don&#39;t want the test template to create any obstacles to testing, because as you say, people already don&#39;t write enough tests.<br>&gt; <br>&gt; My primary concern is that it‚Äôs easy to think you‚Äôve done the right thing and push out a release because all of your testing shows it‚Äôs good, only to find you messed up in a way that it‚Äôs easy for a tool to validate. Writing new code is probably not going to be the primary source of this, but refactoring a `public` class to an `open` one, where there are already existing tests for that class, probably in a single file and using `@testable`, it‚Äôs easy to say, ‚Äúlooks good, tests passed, integrations look good.‚Äù<br>&gt; <br>&gt; If you&#39;re refactoring `public` classes into `open` ones, though, you&#39;d be more likely to have forgotten to open a method you intend to make overridable, no? And there&#39;s no way to change the rules here to have `@testable` pick that up‚Ä¶<br></p><p>Yes, `@testable` does exactly that. It basically treats the imported module as being part of the module it‚Äôs being imported into and gives the type all of the same access levels. So I‚Äôd be able to override a method that is *not* marked as open with no issues.<br></p><p>I see nothing in the proposal that restricts a class within the same module from subclassing and overriding `public` methods within the *same* module that it‚Äôs defined in.<br></p><p>So you need to have test cases that have *no* `@testable import ModuleToTest` to ensure the API contracts are being tested well. This is John‚Äôs point, that proper public API (e.g. ‚Äúblack box‚Äù) test cases would alleviate this issue from happening.<br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160727/505e6b3f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 28, 2016 at 06:00:00am</p></header><div class="content"><p>Right. So IIUC, what you called a serious testability issue earlier in the<br>thread (inadvertent open inside public) is no more and no less an issue<br>with @testable than inadvertent sealed inside open (in that neither would<br>be picked up during such testing), and proper black box testing is what you<br>need to verify that the public API contract is as you intend it to be.<br>On Thu, Jul 28, 2016 at 01:15 David Owens II &lt;david at owensd.io&gt; wrote:<br></p><p>&gt; On Jul 27, 2016, at 8:52 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jul 27, 2016 at 10:30 PM, David Owens II via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt;&gt; &gt; On Jul 27, 2016, at 7:18 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jul 27, 2016, at 6:55 PM, David Owens II via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Yes, it‚Äôs per file. It‚Äôs also added in the initial template that Xcode<br>&gt;&gt; creates with your project. In addition, it‚Äôs recommended by many that talk<br>&gt;&gt; about ‚Äúhow to unit test in Swift.‚Äù So, to someone that is not paying<br>&gt;&gt; scrupulous attention, there is no mechanism to prevent against this today.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Perhaps we&#39;re not doing a good job of messaging this.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The Xcode template is the way it is because @testable imports are the<br>&gt;&gt; right default for a *program* written in Swift.  A lot of the code in an<br>&gt;&gt; application or command-line program isn&#39;t really suitable for independent,<br>&gt;&gt; in-process black-box testing, because it isn&#39;t really presenting an<br>&gt;&gt; integrated API.  If you break it down into components that can be<br>&gt;&gt; independently tested, that&#39;s awesome, and at that point you can switch the<br>&gt;&gt; imports in your tests over to non- at testable.  But we don&#39;t want the test<br>&gt;&gt; template to create any obstacles to testing, because as you say, people<br>&gt;&gt; already don&#39;t write enough tests.<br>&gt;&gt;<br>&gt;&gt; My primary concern is that it‚Äôs easy to think you‚Äôve done the right thing<br>&gt;&gt; and push out a release because all of your testing shows it‚Äôs good, only to<br>&gt;&gt; find you messed up in a way that it‚Äôs easy for a tool to validate. Writing<br>&gt;&gt; new code is probably not going to be the primary source of this, but<br>&gt;&gt; refactoring a `public` class to an `open` one, where there are already<br>&gt;&gt; existing tests for that class, probably in a single file and using<br>&gt;&gt; `@testable`, it‚Äôs easy to say, ‚Äúlooks good, tests passed, integrations look<br>&gt;&gt; good.‚Äù<br>&gt;&gt;<br>&gt;<br>&gt; If you&#39;re refactoring `public` classes into `open` ones, though, you&#39;d be<br>&gt; more likely to have forgotten to open a method you intend to make<br>&gt; overridable, no? And there&#39;s no way to change the rules here to have<br>&gt; `@testable` pick that up‚Ä¶<br>&gt;<br>&gt;<br>&gt; Yes, `@testable` does exactly that. It basically treats the imported<br>&gt; module as being part of the module it‚Äôs being imported into and gives the<br>&gt; type all of the same access levels. So I‚Äôd be able to override a method<br>&gt; that is *not* marked as open with no issues.<br>&gt;<br>&gt; I see nothing in the proposal that restricts a class within the same<br>&gt; module from subclassing and overriding `public` methods within the *same*<br>&gt; module that it‚Äôs defined in.<br>&gt;<br>&gt; So you need to have test cases that have *no* `@testable import<br>&gt; ModuleToTest` to ensure the API contracts are being tested well. This is<br>&gt; John‚Äôs point, that proper public API (e.g. ‚Äúblack box‚Äù) test cases would<br>&gt; alleviate this issue from happening.<br>&gt;<br>&gt; -David<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160728/73a3c1b0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c72bd3ba434ad651a5d8d3d79f2d4c49?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>Scott James Remnant</string> &lt;scott at netsplit.com&gt;<p>July 27, 2016 at 06:00:00pm</p></header><div class="content"><p>I‚Äôm a bit confused here‚Ä¶<br></p><p>Since the result of breaching your subclassing contract is a compile-time error, how are you intending to test that using XCTest?<br></p><p>On the other hand, if you want to write a test that subclasses the class, and uses it as a Library consumer would, why would you use @testable? Wouldn‚Äôt you just import the module normally and verify the contract that way (and thus getting a compile failure if the open/public stuff is wrong).<br></p><p>That‚Äôs not a Unit Test, that‚Äôs a functional test, so I‚Äôd probably make that a separate test target anyway.<br></p><p>Scott<br></p><p><br>&gt; On Jul 27, 2016, at 4:41 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; I brought this up in review, but there seems to be a serious testability problem here because of how special @testable is.<br>&gt; <br>&gt; // This class is not subclassable outside of ModuleA.<br>&gt; public class NonSubclassableParentClass {<br>&gt;     // This method is not overridable outside of ModuleA.<br>&gt;     public func foo() {}<br>&gt; <br>&gt;     // This method is not overridable outside of ModuleA because<br>&gt;     // its class restricts its access level.<br>&gt;     // It is not invalid to declare it as `open`.<br>&gt;     open func bar() {}<br>&gt; <br>&gt;     // The behavior of `final` methods remains unchanged.<br>&gt;     public final func baz() {}<br>&gt; }<br>&gt; <br>&gt; In a unit test, I *can* subclass `NonSubclassableParentClass`, the access level of `NonSubclassableParentClass` is irrelevant. There‚Äôs now no programatic way to ensure that I‚Äôm actually testing the contract that I had intended to provide to the consumers of my framework (that my class is subclassable). Is this really the intention?<br>&gt; <br>&gt; The ‚Äúfix‚Äù, on the authors end, is to create another target that consumes the output framework to ensure my contract is actually what I wanted (and make sure that it‚Äôs not a special test target!). No one is going to do this.<br>&gt; <br>&gt; Sure, maybe a code review might catch it. Or I can write a custom linter to validate for this. Do we really want `open` members in non `open` types? The issue with `public` members on `internal` types is much less concerning as the `internal` type isn‚Äôt being exposed to others to begin with.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 27, 2016, at 3:18 PM, Scott James Remnant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I realize that there‚Äôs no review needed, but I actually wanted to give a hearty üëè to the authors and commenters of this proposal, because I genuinely think we‚Äôve reached something good in the result.<br>&gt;&gt; <br>&gt;&gt; The selling point for me is this:<br>&gt;&gt; <br>&gt;&gt; // This is allowed since the superclass is `open`.<br>&gt;&gt; class SubclassB : SubclassableParentClass {<br>&gt;&gt;     // This is invalid because it overrides a method that is<br>&gt;&gt;     // defined outside of the current module but is not `open&#39;.<br>&gt;&gt;     override func foo() { }<br>&gt;&gt; <br>&gt;&gt;     // This is allowed since the superclass&#39;s method is overridable.<br>&gt;&gt;     // It does not need to be marked `open` because it is defined on<br>&gt;&gt;     // an `internal` class.<br>&gt;&gt;     override func bar() { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This feels super-clean; it gives Library developers `open` for their APIs, without confusing app developers, and still requires that sub-classing Library developers think about `open`.<br>&gt;&gt; <br>&gt;&gt; Good job, everyone!<br>&gt;&gt; <br>&gt;&gt; Scott<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160727/5d32ce7b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>July 27, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; The third review of &quot;SE-0177: Allow distinguishing between public access<br>&gt; and public overridability&quot; ran from Active review July 21...25. The<br>&gt; proposal has been *accepted with revisions*.<br></p><p><br></p><p>The third review of &quot;SE-0177: Allow distinguishing between public access<br>&gt; and public overridability&quot;<br></p><p><br></p><p>The third review of &quot;SE-0177<br></p><p><br></p><p>SE-0177<br></p><p><br>‚Ä¶did someone already buy the core team a barrel of whiskey and I missed the<br>chance to chip in?<br></p><p>:-P<br></p><p>I second everything Scott said: The final result looks great‚Äîexcellent job<br>everyone, especially the core team!<br></p><p>Nevin<br></p><p><br>&gt;<br></p><p><br>On Wed, Jul 27, 2016 at 6:06 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Proposal Link:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;<br>&gt; The third review of &quot;SE-0177: Allow distinguishing between public access<br>&gt; and public overridability&quot; ran from Active review July 21...25. The<br>&gt; proposal has been *accepted with revisions*.<br>&gt;<br>&gt; This proposal was far better received by the community than previous<br>&gt; versions of the proposal, and the ‚Äúfirst design‚Äù was the favored path<br>&gt; within it.  However, there were some concerns raised about the complexity<br>&gt; of the model, stemming from non-obvious combinations like ‚Äúopen private‚Äù.<br>&gt; As such, the core team has requested that the proposal be revised to make<br>&gt; ‚Äúopen‚Äù function as another access control specifier.  ‚Äúopen‚Äù is now simply<br>&gt; ‚Äúmore public than public‚Äù, providing a very simple and clean model.<br>&gt;<br>&gt; John has already revised the proposal to the new model, I encourage you to<br>&gt; read it if you haven‚Äôt already.<br>&gt;<br>&gt; Thank you to John McCall and also Javier Soto for driving this discussion<br>&gt; forward!  John is already working on an implementation of this now.<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160727/81b7ca71/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>July 28, 2016 at 08:00:00am</p></header><div class="content"><p>Great news! Given that this was probably the most polarising proposal ever, I am very impressed with the patience and professionalism the core team has shown in handling the situation and ultimately converging on an elegant solution ‚Äî all that under oppressive deadline! A barrel of whiskey would be more then appropriate :)<br></p><p>--T<br></p><p>&gt; On 28 Jul 2016, at 00:06, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; The third review of &quot;SE-0177: Allow distinguishing between public access and public overridability&quot; ran from Active review July 21...25. The proposal has been *accepted with revisions*.<br>&gt; <br>&gt; This proposal was far better received by the community than previous versions of the proposal, and the ‚Äúfirst design‚Äù was the favored path within it.  However, there were some concerns raised about the complexity of the model, stemming from non-obvious combinations like ‚Äúopen private‚Äù.  As such, the core team has requested that the proposal be revised to make ‚Äúopen‚Äù function as another access control specifier.  ‚Äúopen‚Äù is now simply ‚Äúmore public than public‚Äù, providing a very simple and clean model.<br>&gt; <br>&gt; John has already revised the proposal to the new model, I encourage you to read it if you haven‚Äôt already.<br>&gt; <br>&gt; Thank you to John McCall and also Javier Soto for driving this discussion forward!  John is already working on an implementation of this now.<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Accepted with Revision] SE-0177: Allow distinguishing between public access and public overridability</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 28, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; Given that this was probably the most polarising proposal ever, I am very impressed with the patience and professionalism the core team has shown in handling the situation and ultimately converging on an elegant solution <br>‚Ä¶ and at first sight, they even found a way to please opposers of SE-0117:<br>It looks like this proposal will never be officially accepted (or maybe it&#39;s just a typo caused by all the stress ;-) ‚Äî I guess it&#39;s possible to find a group of sixty proposals that caused less chatter).<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[final revision] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>August  2, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 27, 2016, at 3:06 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; The third review of &quot;SE-0177: Allow distinguishing between public access and public overridability&quot; ran from Active review July 21...25. The proposal has been *accepted with revisions*.<br>&gt; <br>&gt; This proposal was far better received by the community than previous versions of the proposal, and the ‚Äúfirst design‚Äù was the favored path within it.  However, there were some concerns raised about the complexity of the model, stemming from non-obvious combinations like ‚Äúopen private‚Äù.  As such, the core team has requested that the proposal be revised to make ‚Äúopen‚Äù function as another access control specifier.  ‚Äúopen‚Äù is now simply ‚Äúmore public than public‚Äù, providing a very simple and clean model.<br>&gt; <br>&gt; John has already revised the proposal to the new model, I encourage you to read it if you haven‚Äôt already.<br>&gt; <br>&gt; Thank you to John McCall and also Javier Soto for driving this discussion forward!  John is already working on an implementation of this now.<br></p><p>I&#39;m resurrecting this thread to point out some minor revisions / clarifications that came up during implementation.<br></p><p>The first is that the accepted proposal contained &quot;temporary&quot; restrictions that required (1) open classes to subclass open classes and (2) open methods to override open methods.  (2) is actually inconsistent with our existing access-control rules about overrides: the overridden method doesn&#39;t even have to be public.  Making a method open in a subclass shouldn&#39;t force you to expose it in your superclass.  Therefore, we have lifted this restriction.  (1) is consistent with the access control rule on subclasses, so it has been conservatively kept; we&#39;re still open to reconsidering this in the future.<br></p><p>The second is that the proposal wasn&#39;t clear about how open interacts with initializers.  There are many things about our current class-initialization design that are unsatisfactory, but we are not going to fix them in Swift 3.  However, as a general matter, the clearest mental model for initializers is that every class provides its own, independent interface for constructing complete-objects / base-subobjects of that class.  The initializers in each class are formally distinct from the initializers in their subclasses, even when they happen to have the same signature; they are not in any real sense &quot;overrides&quot; (even if in some cases we do currently require the &quot;override&quot; keyword).  This is true even for required initializers, which merely state a requirement that all subclasses must provide a complete-object initializer with a particular signature, rather than expressing a real relationship between those initializers at each level.  Furthermore, it is understood that constructing an object of a subclass necessarily involves delegating to that subclass; subclasses must always be able to initialize their portions of constructed objects.  For all of these reasons, it is correct for initializers to not participate in open checking: they cannot be declared open, but correspondingly there are no restrictions on what initializers can be defined in a subclass, even if they have the same signature as an initializer from a superclass.<br></p><p>I have updated the proposal to reflect this.<br></p><p>John.<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
