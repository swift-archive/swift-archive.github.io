<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review #2] SE-0101: Reconfiguring sizeof and related functions into a unified MemoryLayout struct</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 12, 2016 at 04:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The second review of &quot;SE-0101: Reconfiguring sizeof and related functions into a unified MemoryLayout struct&quot; begins now and runs through July 19. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0101-standardizing-sizeof-naming.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00464d59365595ecaebd19b44de312fa?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0101: Reconfiguring sizeof and related functions into a unified MemoryLayout struct</strong> from <string>Gwynne Raskind</string> &lt;gwynne at darkrainfall.org&gt;<p>July 12, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jul 12, 2016, at 18:53, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; 	* What is your evaluation of the proposal?<br></p><p>Very strong +1; cleaning up the global namespace, addressing confusion with usage of these functions, and promoting the concept of the low-level attributes of a type being related to that type (rather than being arbitrarily global truths), are all significant wins for readability, discoverability, and conceptual clarity.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Definitively. The sizeof() family of functions are neither commonly enough used nor fundamental enough to idiomatic Swift to belong in the global namespace, and having them there adds potentially dangerous confusion for users coming from C, C++, and Objective-C. In particular, &quot;sizeof(T)&quot; almost definitely doesn’t mean what a newcomer to Swift expects, but when encountering &quot;MemoryLayout&lt;T&gt;.size&quot; one is considerably more likely to have at least noticed the documentation of what it means and the fact that &quot;.stride&quot; exists.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Very much so. To me, the syntax proposed here is simpler, clearer, and much more in keeping with OO design.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>The closest equivalent I can think of comes from C++, per std::numeric_limits&lt;T&gt;, std::pointer_traits&lt;T&gt;, std::allocator_traits&lt;T&gt;, etc. While C++ is being typically verbose in its syntax, it successfully represents the type information in object-oriented and unambiguous fashion, and the sheer verbosity aside, I’ve always liked this representation. This proposal is substantially similar in form and at a quick glance at my own Swift code, it adds similar clarity to the intent the code expresses.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A quick reading.<br></p><p>-- Gwynne Raskind<br>More magic than a mere signature can contain<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0101: Reconfiguring sizeof and related functions into a unified MemoryLayout struct</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>July 13, 2016 at 04:00:00am</p></header><div class="content"><p>Strong +1 for me as well, can&#39;t summarize it better then Gwynne&#39;s email<br></p><p>On Tue, Jul 12, 2016 at 8:48 PM Gwynne Raskind via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On Jul 12, 2016, at 18:53, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; &gt;       * What is your evaluation of the proposal?<br>&gt;<br>&gt; Very strong +1; cleaning up the global namespace, addressing confusion<br>&gt; with usage of these functions, and promoting the concept of the low-level<br>&gt; attributes of a type being related to that type (rather than being<br>&gt; arbitrarily global truths), are all significant wins for readability,<br>&gt; discoverability, and conceptual clarity.<br>&gt;<br>&gt; &gt;       * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br>&gt; Definitively. The sizeof() family of functions are neither commonly enough<br>&gt; used nor fundamental enough to idiomatic Swift to belong in the global<br>&gt; namespace, and having them there adds potentially dangerous confusion for<br>&gt; users coming from C, C++, and Objective-C. In particular, &quot;sizeof(T)&quot;<br>&gt; almost definitely doesn’t mean what a newcomer to Swift expects, but when<br>&gt; encountering &quot;MemoryLayout&lt;T&gt;.size&quot; one is considerably more likely to have<br>&gt; at least noticed the documentation of what it means and the fact that<br>&gt; &quot;.stride&quot; exists.<br>&gt;<br>&gt; &gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; Very much so. To me, the syntax proposed here is simpler, clearer, and<br>&gt; much more in keeping with OO design.<br>&gt;<br>&gt; &gt;       * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br>&gt; The closest equivalent I can think of comes from C++, per<br>&gt; std::numeric_limits&lt;T&gt;, std::pointer_traits&lt;T&gt;, std::allocator_traits&lt;T&gt;,<br>&gt; etc. While C++ is being typically verbose in its syntax, it successfully<br>&gt; represents the type information in object-oriented and unambiguous fashion,<br>&gt; and the sheer verbosity aside, I’ve always liked this representation. This<br>&gt; proposal is substantially similar in form and at a quick glance at my own<br>&gt; Swift code, it adds similar clarity to the intent the code expresses.<br>&gt;<br>&gt; &gt;       * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; A quick reading.<br>&gt;<br>&gt; -- Gwynne Raskind<br>&gt; More magic than a mere signature can contain<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/7532eec0/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c72bd3ba434ad651a5d8d3d79f2d4c49?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0101: Reconfiguring sizeof and related functions into a unified MemoryLayout struct</strong> from <string>Scott James Remnant</string> &lt;scott at netsplit.com&gt;<p>July 12, 2016 at 06:00:00pm</p></header><div class="content"><p>+1<br></p><p>Reviewed the previous version, I find this much cleaner and very Swift-y.<br></p><p>Scott<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0101: Reconfiguring sizeof and related functions into a unified MemoryLayout struct</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>July 12, 2016 at 10:00:00pm</p></header><div class="content"><p>What is your evaluation of the proposal?<br>I’m not in favor of the majority of this proposal (I do support getting rid of the *Value versions of the functions). Of the motivations, I find this one to be the most awkward:<br></p><p>&gt; Refactoring this proposal to use a single namespace increases discoverability, provides a single entry point for related operations, and enables future expansions without introducing further freestanding functions.<br></p><p>While technically storing stuff under a new type creates a level of indirection that we may refer to a namespace, it does so in a way that I’m not terribly convinced is even conceptually correct. A new MemoryLayout struct implies there is actually a type we are creating here, but that’s not the case: we are simply using the type as a hack to get a namespace because Swift lacks support for that notion. <br></p><p>If we must have a struct to achieve this, than at the very least, can’t we move all of the generics onto the function call itself?<br></p><p>public struct MemoryLayout {<br>    public static func sizeof&lt;T&gt;(_ x: T.Type) -&gt; Int { return Swift.sizeof(x) }<br>// ...<br>}<br></p><p>Further, I find this change to just make readability suffer. Here’s is a random snippet found from a GitHub search:<br></p><p>let data = NSData(bytes: &amp;bytes, length:sizeof(CChar) * bytes.count)<br>let data = NSData(bytes: &amp;bytes, length:MemoryLayout&lt;CChar&gt;.size * bytes.count)<br></p><p>That’s a lot more typing for what? <br></p><p>let data = NSData(bytes: &amp;bytes, length:MemoryLayout.sizeof(CChar) * bytes.count)<br></p><p>The above actually satisfies the concern, which seems to be primarily that the functions are top-level functions instead of namespaced.<br></p><p>Is the problem being addressed significant enough to warrant a change to Swift?<br>No. Like mentioned in the proposal, these are already low-use terms. As such, there is a much prior art for these to turn up search results easily for them and their concept apply across multiple languages.<br></p><p>Does this proposal fit well with the feel and direction of Swift?<br>No. The heart of the proposal seems to be a workaround for the lack of namespacing in Swift.<br></p><p>If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>Yes, those languages have better readability around these terms.<br></p><p>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>I’ve read the proposal, looked up code snippets, and tested my own implementation within playgrounds.<br></p><p>-David<br></p><p>&gt; On Jul 12, 2016, at 4:53 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The second review of &quot;SE-0101: Reconfiguring sizeof and related functions into a unified MemoryLayout struct&quot; begins now and runs through July 19. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0101-standardizing-sizeof-naming.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/9da893f2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review #2] SE-0101: Reconfiguring sizeof and related functions into a unified MemoryLayout struct</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 13, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On Jul 12, 2016, at 4:53 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>I think grouping these into a type is a sensible approach, but I don&#39;t like that it allows the creation of meaningless MemoryLayout instances. The simplest fix would be to make `MemoryLayout` an empty enum instead of an empty struct. This would convey that no MemoryLayout instances do or can exist.<br></p><p>However, I&#39;m also not really a fan of the way this reads. `MemoryLayout&lt;Int&gt;` is an unnatural way to access this functionality, quite different from how generics are typically used. The heavy use of type members, with instance behavior as a complete afterthought, is very unusual. If we are serious about use sites being the most important thing, we ought to be concerned about these use sites.<br></p><p>I would prefer to see an instance-centric version of this design, with use sites along the lines of:<br></p><p>	MemoryLayout(of: Int.self).size<br>	let buffer = UnsafeRawPointer.allocate(bytes: MemoryLayout(of: Int.self).stride * count)<br></p><p>If the problem is that it would sometimes misbehave—for instance, when someone tries to construct a MemoryLayout instance from a `type(of:)` call—then we should make it behave correctly, or at least consider it a bug to be fixed eventually.<br></p><p>(Incidentally, I notice that the ABI documentation lists the size, alignment, and stride as part of the type&#39;s value witness table. &lt;https://github.com/apple/swift/blob/master/docs/ABI.rst#common-metadata-layout&gt; Would it make sense to think of this as exposing the value witness table as a user-visible type? How might that be different from what&#39;s being proposed here?)<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. We need to lock this down.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>See my comment above about how it reads.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Well, it *is* more coherent and less magical than the C family.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Quick reading, but I&#39;ve chimed in during previous discussions (though not in this latest round—family duties have kept me from my mail client).<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review #2] SE-0101: Reconfiguring sizeof and related functions into a unified MemoryLayout struct</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 14, 2016 at 04:00:00pm</p></header><div class="content"><p>I share the minor concerns that have been expressed so far.<br>My first thought on this topic (&quot;MyStruct.size&quot;) had a obvious flaw, but I wouldn&#39;t fear name collisions with something like &quot;MyStruct.memoryLayout.size&quot;.<br>This one most likely has issues as well, but imho they aren&#39;t that obvious and deserve being discussed in the alternatives-section (or a short answer here to wake up my tired mind ;-)<br></p><p>- Tino<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
