<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>RFC: Preventing Retain Cycles (Memory Ownership Model)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>July 29, 2016 at 08:00:00pm</p></header><div class="content"><p>Rust attempted this sort of type-directed cycle prevention early in its development, when it was attempting to provide language-supported shared references without GC, and it didn&#39;t work out well for them in practice.<br></p><p>-Joe<br></p><p>&gt; On Jul 29, 2016, at 6:42 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;d like an opt-in way to verify and prevent unintentional strong references in Swift.<br>&gt; <br>&gt; This can be used to verify ownership structures, and ultimately avoid retain cycles.<br>&gt; <br>&gt; Read a draft proposal here:<br>&gt; https://github.com/therealbnut/swift-evolution/blob/therealbnut-explicit-ownership/proposals/NNNN-explicit-ownership-type-attribute.md<br>&gt; <br>&gt; TL;DR:<br>&gt; <br>&gt; If you have any questions please read the proposal before asking here.<br>&gt; <br>&gt; It&#39;s an opt-in attribute that defines a whitelist of types something can own. For example:<br>&gt; <br>&gt; @owns(TypeA, TypeB) struct TypeC { ... }<br>&gt; <br>&gt; I wrote this a few months ago, but we weren&#39;t accepting additive proposals. Now we&#39;re explicitly looking for something like this:<br>&gt; <br>&gt; Memory ownership model: Adding an (opt-in) Cyclone/Rust inspired memory ownership model to Swift is highly desired by systems programmers and folks who want predictable and deterministic performance (for example, in real time audio processing code).  More pertinent to the goals of Swift 4, this feature is important because it fundamentally shapes the ABI.  It informs code generation for “inout&quot;, how low-level “addressors” work in the ABI, impacts the Swift runtime, and will have a significant impact on the type system and name mangling. <br>&gt; <br>&gt; - Chris<br>&gt; <br>&gt; ----<br>&gt; <br>&gt; Here&#39;s a link to the version of the proposal when I sent this email.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>RFC: Preventing Retain Cycles (Memory Ownership Model)</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>July 30, 2016 at 01:00:00pm</p></header><div class="content"><p>Interesting, I&#39;m not familiar with the history of the feature in Rust. Are<br>you able to provide more details on what went wrong in practice?<br></p><p>This proposal may be different, this is not attempting to do it without GC.<br>What I&#39;m suggesting still uses ARC (assuming you were counting ARC as GC).<br>It does provide the compiler many opportunities to optimise ARC though.<br></p><p>I really like what Rust ended up with, but I&#39;m concerned that it&#39;s very<br>complicated, and I want to explore alternatives. From<br>https://doc.rust-lang.org/book/ownership.html:<br></p><p>However, this system does have a certain cost: learning curve. Many new<br>&gt; users to Rust experience something we like to call ‘fighting with the<br>&gt; borrow checker’.<br></p><p><br></p><p><br>On Sat, Jul 30, 2016 at 1:22 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Rust attempted this sort of type-directed cycle prevention early in its<br>&gt; development, when it was attempting to provide language-supported shared<br>&gt; references without GC, and it didn&#39;t work out well for them in practice.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; &gt; On Jul 29, 2016, at 6:42 PM, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I&#39;d like an opt-in way to verify and prevent unintentional strong<br>&gt; references in Swift.<br>&gt; &gt;<br>&gt; &gt; This can be used to verify ownership structures, and ultimately avoid<br>&gt; retain cycles.<br>&gt; &gt;<br>&gt; &gt; Read a draft proposal here:<br>&gt; &gt;<br>&gt; https://github.com/therealbnut/swift-evolution/blob/therealbnut-explicit-ownership/proposals/NNNN-explicit-ownership-type-attribute.md<br>&gt; &gt;<br>&gt; &gt; TL;DR:<br>&gt; &gt;<br>&gt; &gt; If you have any questions please read the proposal before asking here.<br>&gt; &gt;<br>&gt; &gt; It&#39;s an opt-in attribute that defines a whitelist of types something can<br>&gt; own. For example:<br>&gt; &gt;<br>&gt; &gt; @owns(TypeA, TypeB) struct TypeC { ... }<br>&gt; &gt;<br>&gt; &gt; I wrote this a few months ago, but we weren&#39;t accepting additive<br>&gt; proposals. Now we&#39;re explicitly looking for something like this:<br>&gt; &gt;<br>&gt; &gt; Memory ownership model: Adding an (opt-in) Cyclone/Rust inspired memory<br>&gt; ownership model to Swift is highly desired by systems programmers and folks<br>&gt; who want predictable and deterministic performance (for example, in real<br>&gt; time audio processing code).  More pertinent to the goals of Swift 4, this<br>&gt; feature is important because it fundamentally shapes the ABI.  It informs<br>&gt; code generation for “inout&quot;, how low-level “addressors” work in the ABI,<br>&gt; impacts the Swift runtime, and will have a significant impact on the type<br>&gt; system and name mangling.<br>&gt; &gt;<br>&gt; &gt; - Chris<br>&gt; &gt;<br>&gt; &gt; ----<br>&gt; &gt;<br>&gt; &gt; Here&#39;s a link to the version of the proposal when I sent this email.<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160730/14a5eb2f/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
