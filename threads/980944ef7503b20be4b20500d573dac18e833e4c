<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 25, 2016 at 10:00:00pm</p></header><div class="content"><p>Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0089-rename-string-reflection-init.md<br></p><p>The review of &quot;SE-0089: Renaming String.init&lt;T&gt;(_: T)&quot; ran from May 17…23, 2016. The proposal has been *returned for revision* and another round of discussion - the core team would love to see the revised proposal make it into Swift 3.<br></p><p>The community and core team both want to remove this “footgun” from the standard library, where someone could write &quot;String(x)” with the intention of getting a value-preserving conversion to String, but may instead get a potentially lossy and potentially expensive reflection-based conversion to a String.  After extensive discussion, the core team recommends that the community consider a somewhat more elaborate design:<br></p><p>- Rename the existing reflection-based &quot;String.init&lt;T&gt;(_: T)” initializer to &quot;String.init&lt;T&gt;(describing: T)” as recommend by the community.  This initializer would rarely be invoked in user code directly.<br></p><p>- Introduce a new protocol (for sake of discussion, call it “ValuePreservingStringConvertible&quot;) that refines CustomStringConvertible but that adds no new requirements.  Conformance to this protocol indicates that the “description” requirement produces a value-preserving representation in String form.<br></p><p>- Introduce a new unlabeled initializer on String: &quot;init&lt;T: ValuePreservingStringConvertible&gt;(_ v: T) { return v.description }&quot;.  This permits the “String(x)” syntax to be used on all values of types that can be converted to string in a value-preserving way.<br></p><p> - Audit important standard library types (e.g. the integer and floating point types), and make them explicitly conform to ValuePreservingStringConvertible with an explicitly implemented “description” property.<br></p><p>- As a performance optimization, change the implementation of the string literal interpolation syntax to prefer the unlabeled initializer when interpolating a type that is ValuePreservingStringConvertible or that has otherwise has an unlabeled String initializer, but use the &quot;String.init&lt;T&gt;(describing: T)” initializer if not.<br></p><p><br>The expected advantages of this design are:<br></p><p>- Swift encourages the T(x) syntax for value preserving conversions, and this design ensures that String(x) continues to work for the value preserving cases.<br></p><p>- This ensures that the String(x) syntax does not accidentally fall off a performance cliff by using the extremely-dynamic reflection mechanism unintentionally.<br></p><p>- The preferred “I don’t care how you do it, just convert this value to a string somehow” syntax remains string interpolation syntax.  This syntax is efficient in the cases where the String(x) syntax is allowed, but fully general to the other cases where custom convert-to-string code has not been provided.<br></p><p><br>Some remaining open questions:<br></p><p>- Exactly what types should conform to ValuePreservingStringConvertible.  It seems clear that integer, floating point types, and Character can and should conform.  What other types should?<br></p><p>- Do we need the ValuePreservingStringConvertible at all, or is the existing CustomStringConvertible enough?  We already have a few protocols for handling string convertibility, it would be great to avoid adding another one.<br></p><p>Thank you to Austin Zheng for driving this proposal forward!<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 26, 2016 at 05:00:00pm</p></header><div class="content"><p>These are some great points. I like the sound of ValuePreservingStringConvertible. A few questions to add:<br></p><p>- If its conformers produce a value-preserving representation, would it make sense for it to also have an initializer accepting the value? What specifically makes it value preserving otherwise?<br></p><p>- What is the difference between CustomStringConvertible and CustomDebugStringConvertible? Are most implementations of description and debugDescription identical? It says CustomStringConvertible is for writing to an output stream. Is a ‘value preserving string’ going to be a better fit for that all the time?<br></p><p>- To the question of ‘is CustomStringConvertible enough?’, what about replacing it with ValuePreservingStringConvertible? Then there are two very distinct protocols: ValuePreservingStringConvertible and CustomDebugStringConvertible, one obviously safely value preserving and one obviously just for inspecting.<br></p><p>- Could `.description` be renamed to something more specific and clear? For example, `preservedValue` or `.valuePreservingDescription`. If the recommended way is to use `init&lt;T: ValuePreservingStringConvertible&gt;(_ v: T)`, will anybody be using `.description` directly anyway? I always found NSObject’s seize of the ‘description’ property annoying, as on models it’s a perfect valid property to want as a member, so I was a little disappointed to see it in Swift too. If there’s an alternative, more clear name for this property then it won’t clash with anything else.<br></p><p>I like this clear separation of ‘value preserving’ and ‘just show me something’ representations.<br></p><p>Patrick<br></p><p><br>&gt; On 26 May 2016, at 3:08 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0089-rename-string-reflection-init.md<br>&gt; <br>&gt; The review of &quot;SE-0089: Renaming String.init&lt;T&gt;(_: T)&quot; ran from May 17…23, 2016. The proposal has been *returned for revision* and another round of discussion - the core team would love to see the revised proposal make it into Swift 3.<br>&gt; <br>&gt; The community and core team both want to remove this “footgun” from the standard library, where someone could write &quot;String(x)” with the intention of getting a value-preserving conversion to String, but may instead get a potentially lossy and potentially expensive reflection-based conversion to a String.  After extensive discussion, the core team recommends that the community consider a somewhat more elaborate design:<br>&gt; <br>&gt; - Rename the existing reflection-based &quot;String.init&lt;T&gt;(_: T)” initializer to &quot;String.init&lt;T&gt;(describing: T)” as recommend by the community.  This initializer would rarely be invoked in user code directly.<br>&gt; <br>&gt; - Introduce a new protocol (for sake of discussion, call it “ValuePreservingStringConvertible&quot;) that refines CustomStringConvertible but that adds no new requirements.  Conformance to this protocol indicates that the “description” requirement produces a value-preserving representation in String form.<br>&gt; <br>&gt; - Introduce a new unlabeled initializer on String: &quot;init&lt;T: ValuePreservingStringConvertible&gt;(_ v: T) { return v.description }&quot;.  This permits the “String(x)” syntax to be used on all values of types that can be converted to string in a value-preserving way.<br>&gt; <br>&gt; - Audit important standard library types (e.g. the integer and floating point types), and make them explicitly conform to ValuePreservingStringConvertible with an explicitly implemented “description” property.<br>&gt; <br>&gt; - As a performance optimization, change the implementation of the string literal interpolation syntax to prefer the unlabeled initializer when interpolating a type that is ValuePreservingStringConvertible or that has otherwise has an unlabeled String initializer, but use the &quot;String.init&lt;T&gt;(describing: T)” initializer if not.<br>&gt; <br>&gt; <br>&gt; The expected advantages of this design are:<br>&gt; <br>&gt; - Swift encourages the T(x) syntax for value preserving conversions, and this design ensures that String(x) continues to work for the value preserving cases.<br>&gt; <br>&gt; - This ensures that the String(x) syntax does not accidentally fall off a performance cliff by using the extremely-dynamic reflection mechanism unintentionally.<br>&gt; <br>&gt; - The preferred “I don’t care how you do it, just convert this value to a string somehow” syntax remains string interpolation syntax.  This syntax is efficient in the cases where the String(x) syntax is allowed, but fully general to the other cases where custom convert-to-string code has not been provided.<br>&gt; <br>&gt; <br>&gt; Some remaining open questions:<br>&gt; <br>&gt; - Exactly what types should conform to ValuePreservingStringConvertible.  It seems clear that integer, floating point types, and Character can and should conform.  What other types should?<br>&gt; <br>&gt; - Do we need the ValuePreservingStringConvertible at all, or is the existing CustomStringConvertible enough?  We already have a few protocols for handling string convertibility, it would be great to avoid adding another one.<br>&gt; <br>&gt; Thank you to Austin Zheng for driving this proposal forward!<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 26, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; - If its conformers produce a value-preserving representation, would it make sense for it to also have an initializer accepting the value? What specifically makes it value preserving otherwise?<br></p><p>This makes sense to me. But we are getting dangerously close to a Serialization feature which could benefit a more complex and generic design.<br></p><p>&gt; - What is the difference between CustomStringConvertible and CustomDebugStringConvertible? Are most implementations of description and debugDescription identical? It says CustomStringConvertible is for writing to an output stream. Is a ‘value preserving string’ going to be a better fit for that all the time?<br></p><p>I’ve always found those two confusing. But I guess that CustomDebugStringConvertible could provide more information, like the actual type and pointer value. For example, imagine that we make UIColor ValuePreservingStringConvertible, one implementation could look like:<br></p><p>let a = UIColor(red: 0, green: 0, blue: 0)<br>a.description // #000000<br>a.debugDescription // &lt;UIColor: 0xcodebeef - red: 0.0, green: 0.0, blue: 0.0&gt;<br></p><p>&gt; - To the question of ‘is CustomStringConvertible enough?’, what about replacing it with ValuePreservingStringConvertible? Then there are two very distinct protocols: ValuePreservingStringConvertible and CustomDebugStringConvertible, one obviously safely value preserving and one obviously just for inspecting.<br>&gt; <br>&gt; - Could `.description` be renamed to something more specific and clear? For example, `preservedValue` or `.valuePreservingDescription`. If the recommended way is to use `init&lt;T: ValuePreservingStringConvertible&gt;(_ v: T)`, will anybody be using `.description` directly anyway? I always found NSObject’s seize of the ‘description’ property annoying, as on models it’s a perfect valid property to want as a member, so I was a little disappointed to see it in Swift too. If there’s an alternative, more clear name for this property then it won’t clash with anything else.<br>&gt; <br>&gt; I like this clear separation of ‘value preserving’ and ‘just show me something’ representations.<br>&gt; <br>&gt; Patrick<br>&gt; <br>&gt; <br>&gt;&gt; On 26 May 2016, at 3:08 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0089-rename-string-reflection-init.md<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0089: Renaming String.init&lt;T&gt;(_: T)&quot; ran from May 17…23, 2016. The proposal has been *returned for revision* and another round of discussion - the core team would love to see the revised proposal make it into Swift 3.<br>&gt;&gt; <br>&gt;&gt; The community and core team both want to remove this “footgun” from the standard library, where someone could write &quot;String(x)” with the intention of getting a value-preserving conversion to String, but may instead get a potentially lossy and potentially expensive reflection-based conversion to a String.  After extensive discussion, the core team recommends that the community consider a somewhat more elaborate design:<br>&gt;&gt; <br>&gt;&gt; - Rename the existing reflection-based &quot;String.init&lt;T&gt;(_: T)” initializer to &quot;String.init&lt;T&gt;(describing: T)” as recommend by the community.  This initializer would rarely be invoked in user code directly.<br>&gt;&gt; <br>&gt;&gt; - Introduce a new protocol (for sake of discussion, call it “ValuePreservingStringConvertible&quot;) that refines CustomStringConvertible but that adds no new requirements.  Conformance to this protocol indicates that the “description” requirement produces a value-preserving representation in String form.<br>&gt;&gt; <br>&gt;&gt; - Introduce a new unlabeled initializer on String: &quot;init&lt;T: ValuePreservingStringConvertible&gt;(_ v: T) { return v.description }&quot;.  This permits the “String(x)” syntax to be used on all values of types that can be converted to string in a value-preserving way.<br>&gt;&gt; <br>&gt;&gt; - Audit important standard library types (e.g. the integer and floating point types), and make them explicitly conform to ValuePreservingStringConvertible with an explicitly implemented “description” property.<br>&gt;&gt; <br>&gt;&gt; - As a performance optimization, change the implementation of the string literal interpolation syntax to prefer the unlabeled initializer when interpolating a type that is ValuePreservingStringConvertible or that has otherwise has an unlabeled String initializer, but use the &quot;String.init&lt;T&gt;(describing: T)” initializer if not.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The expected advantages of this design are:<br>&gt;&gt; <br>&gt;&gt; - Swift encourages the T(x) syntax for value preserving conversions, and this design ensures that String(x) continues to work for the value preserving cases.<br>&gt;&gt; <br>&gt;&gt; - This ensures that the String(x) syntax does not accidentally fall off a performance cliff by using the extremely-dynamic reflection mechanism unintentionally.<br>&gt;&gt; <br>&gt;&gt; - The preferred “I don’t care how you do it, just convert this value to a string somehow” syntax remains string interpolation syntax.  This syntax is efficient in the cases where the String(x) syntax is allowed, but fully general to the other cases where custom convert-to-string code has not been provided.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Some remaining open questions:<br>&gt;&gt; <br>&gt;&gt; - Exactly what types should conform to ValuePreservingStringConvertible.  It seems clear that integer, floating point types, and Character can and should conform.  What other types should?<br>&gt;&gt; <br>&gt;&gt; - Do we need the ValuePreservingStringConvertible at all, or is the existing CustomStringConvertible enough?  We already have a few protocols for handling string convertibility, it would be great to avoid adding another one.<br>&gt;&gt; <br>&gt;&gt; Thank you to Austin Zheng for driving this proposal forward!<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 27, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 26 May 2016, at 5:40 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; I’ve always found those two confusing. But I guess that CustomDebugStringConvertible could provide more information, like the actual type and pointer value. For example, imagine that we make UIColor ValuePreservingStringConvertible, one implementation could look like:<br>&gt; <br>&gt; let a = UIColor(red: 0, green: 0, blue: 0)<br>&gt; a.description // #000000<br>&gt; a.debugDescription // &lt;UIColor: 0xcodebeef - red: 0.0, green: 0.0, blue: 0.0&gt;<br></p><p>This distinction seems a little arbitrary to me. However, something like `preservedString` would make more sense to me:<br></p><p>let a = UIColor(red: 0, green: 0, blue: 0)<br>a.preservedString // #000000 — or perhaps more accurate: rgba(0.0,0.0,0.0,1.0)<br>a.debugDescription // &lt;UIColor: 0xcodebeef - red: 0.0, green: 0.0, blue: 0.0&gt;<br></p><p>This why I think it makes sense to really differentiate `description` from `debugDescription`, so it’s no long ‘confusing’ as you say.<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 26, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; - Rename the existing reflection-based &quot;String.init&lt;T&gt;(_: T)” initializer to &quot;String.init&lt;T&gt;(describing: T)” as recommend by the community.  This initializer would rarely be invoked in user code directly.<br></p><p>Yes.<br></p><p>&gt; - Introduce a new protocol (for sake of discussion, call it “ValuePreservingStringConvertible&quot;) that refines CustomStringConvertible but that adds no new requirements.  Conformance to this protocol indicates that the “description” requirement produces a value-preserving representation in String form.<br></p><p>Yes!<br></p><p>&gt; - Introduce a new unlabeled initializer on String: &quot;init&lt;T: ValuePreservingStringConvertible&gt;(_ v: T) { return v.description }&quot;.  This permits the “String(x)” syntax to be used on all values of types that can be converted to string in a value-preserving way.<br></p><p>YES!<br></p><p>&gt; - Audit important standard library types (e.g. the integer and floating point types), and make them explicitly conform to ValuePreservingStringConvertible with an explicitly implemented “description” property.<br></p><p>HELL YES!<br></p><p>&gt; - As a performance optimization, change the implementation of the string literal interpolation syntax to prefer the unlabeled initializer when interpolating a type that is ValuePreservingStringConvertible or that has otherwise has an unlabeled String initializer, but use the &quot;String.init&lt;T&gt;(describing: T)” initializer if not.<br></p><p>...huh. Well, if you insist.<br></p><p>(I would favor a design which somehow differentiated between strings intended for debugging or logging, which would permit any interpolation, and strings intended for paths, user display, and other such purposes, which would only permit ValuePreservingStringConvertible interpolations. But short of introducing a separate DebugString type, I&#39;m not sure how we might actually accomplish that.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 26, 2016 at 09:00:00pm</p></header><div class="content"><p>I think this is an incredible idea.<br></p><p>Should we eventually prepare an updated proposal? Given the need for further discussion I&#39;d be happy to drive it forward, or if someone else wants they can take over too.<br></p><p>(inline)<br></p><p>&gt; On May 25, 2016, at 10:08 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0089-rename-string-reflection-init.md<br>&gt; <br>&gt; The review of &quot;SE-0089: Renaming String.init&lt;T&gt;(_: T)&quot; ran from May 17…23, 2016. The proposal has been *returned for revision* and another round of discussion - the core team would love to see the revised proposal make it into Swift 3.<br>&gt; <br>&gt; The community and core team both want to remove this “footgun” from the standard library, where someone could write &quot;String(x)” with the intention of getting a value-preserving conversion to String, but may instead get a potentially lossy and potentially expensive reflection-based conversion to a String.  After extensive discussion, the core team recommends that the community consider a somewhat more elaborate design:<br>&gt; <br>&gt; - Rename the existing reflection-based &quot;String.init&lt;T&gt;(_: T)” initializer to &quot;String.init&lt;T&gt;(describing: T)” as recommend by the community.  This initializer would rarely be invoked in user code directly.<br>&gt; <br>&gt; - Introduce a new protocol (for sake of discussion, call it “ValuePreservingStringConvertible&quot;) that refines CustomStringConvertible but that adds no new requirements.  Conformance to this protocol indicates that the “description” requirement produces a value-preserving representation in String form.<br>&gt; <br>&gt; - Introduce a new unlabeled initializer on String: &quot;init&lt;T: ValuePreservingStringConvertible&gt;(_ v: T) { return v.description }&quot;.  This permits the “String(x)” syntax to be used on all values of types that can be converted to string in a value-preserving way.<br>&gt; <br>&gt; - Audit important standard library types (e.g. the integer and floating point types), and make them explicitly conform to ValuePreservingStringConvertible with an explicitly implemented “description” property.<br></p><p>Yes to all of this, as others have already said.<br></p><p>&gt; <br>&gt; - As a performance optimization, change the implementation of the string literal interpolation syntax to prefer the unlabeled initializer when interpolating a type that is ValuePreservingStringConvertible or that has otherwise has an unlabeled String initializer, but use the &quot;String.init&lt;T&gt;(describing: T)” initializer if not.<br>&gt; <br>&gt; <br>&gt; The expected advantages of this design are:<br>&gt; <br>&gt; - Swift encourages the T(x) syntax for value preserving conversions, and this design ensures that String(x) continues to work for the value preserving cases.<br></p><p>Yes. I think doing a little more work to keep this convention is worthwhile.<br></p><p>&gt; <br>&gt; - This ensures that the String(x) syntax does not accidentally fall off a performance cliff by using the extremely-dynamic reflection mechanism unintentionally.<br>&gt; <br>&gt; - The preferred “I don’t care how you do it, just convert this value to a string somehow” syntax remains string interpolation syntax.  This syntax is efficient in the cases where the String(x) syntax is allowed, but fully general to the other cases where custom convert-to-string code has not been provided.<br>&gt; <br>&gt; <br>&gt; Some remaining open questions:<br>&gt; <br>&gt; - Exactly what types should conform to ValuePreservingStringConvertible.  It seems clear that integer, floating point types, and Character can and should conform.  What other types should?<br></p><p>Like Brent mentioned, there are some types that are natural candidates, including Foundation types whose conformance could go into the overlays. NSURL, NSUUID, NSIndexPath. NSData is a borderline candidate, and probably not a good fit in the end (what encoding to use? what happens if you get the .description of a 100 MB NSData? etc). Same with NSDate. Maybe some of the CGStructs, although maybe the fact that CGFloat differs between platforms will sink that idea.<br></p><p>Any of the NSObject subclass candidates may require their `description`s to be altered to meet the semantics, which may or may not be an acceptable breaking change.<br></p><p>&gt; <br>&gt; - Do we need the ValuePreservingStringConvertible at all, or is the existing CustomStringConvertible enough?  We already have a few protocols for handling string convertibility, it would be great to avoid adding another one.<br></p><p>This is a good question.<br></p><p>Since a ValuePreservingStringConvertible is, by definition, a type that can be represented as a string in a lossless and unambiguous manner, would it be worth requiring a reverse conversion in the form of a failable initializer taking a string? Some of the proposed ValuePreservingStringConvertible types already have such functionality today. It would give the protocol a little more of a reason to exist, as well as encouraging proper conformance.<br></p><p>Today, `description` is definitely used for both lossless and lossy string representations, and that&#39;s probably not going to change in the future.<br></p><p>&gt; <br>&gt; Thank you to Austin Zheng for driving this proposal forward!<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 27, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 27 May 2016, at 2:40 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Any of the NSObject subclass candidates may require their `description`s to be altered to meet the semantics, which may or may not be an acceptable breaking change.<br></p><p>Do you think it might be worth changing `description` to be named something else? Something more clear, less likely to conflict with ‘real’ properties — ‘description’ doesn’t seem to portray something that is value-preserving. What is the reason for calling it ‘description’?<br></p><p>Especially if NSObject subclasses won’t fit, then why not have a different method that can be strictly value preserving? (Then `description` can stay being an NSObject thing.)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6a2eebe83a60a4b42395145484cda15?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Daniel Vollmer</string> &lt;lists at maven.de&gt;<p>May 27, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 27 May 2016, at 07:14, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 27 May 2016, at 2:40 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Any of the NSObject subclass candidates may require their `description`s to be altered to meet the semantics, which may or may not be an acceptable breaking change.<br>&gt; <br>&gt; Do you think it might be worth changing `description` to be named something else? Something more clear, less likely to conflict with ‘real’ properties — ‘description’ doesn’t seem to portray something that is value-preserving. What is the reason for calling it ‘description’?<br></p><p>I’m also not quite sure (from the suggested names) whether the intended use is to be “a string *description* that happens to be value-preserving” (for which the name description might be ok), or “a value-preserving version of the instance as string *with no intent of that string ever being descriptive or helpful when presented to anything other than the matching initialiser of the same type*” (which rather be one form of serialisation).<br></p><p>	Daniel.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 27, 2016 at 12:00:00am</p></header><div class="content"><p>I think I agree. &quot;description&quot; to me implies something meant for humans to read, whatever the exact form. Something like &quot;stringRepresentation&quot; would be a more precise name for the property.<br></p><p>&gt; On May 26, 2016, at 11:58 PM, Daniel Vollmer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 27 May 2016, at 07:14, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 27 May 2016, at 2:40 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any of the NSObject subclass candidates may require their `description`s to be altered to meet the semantics, which may or may not be an acceptable breaking change.<br>&gt;&gt; <br>&gt;&gt; Do you think it might be worth changing `description` to be named something else? Something more clear, less likely to conflict with ‘real’ properties — ‘description’ doesn’t seem to portray something that is value-preserving. What is the reason for calling it ‘description’?<br>&gt; <br>&gt; I’m also not quite sure (from the suggested names) whether the intended use is to be “a string *description* that happens to be value-preserving” (for which the name description might be ok), or “a value-preserving version of the instance as string *with no intent of that string ever being descriptive or helpful when presented to anything other than the matching initialiser of the same type*” (which rather be one form of serialisation).<br>&gt; <br>&gt; 	Daniel.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 27, 2016, at 8:58 AM, Daniel Vollmer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 27 May 2016, at 07:14, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 27 May 2016, at 2:40 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any of the NSObject subclass candidates may require their `description`s to be altered to meet the semantics, which may or may not be an acceptable breaking change.<br>&gt;&gt; <br>&gt;&gt; Do you think it might be worth changing `description` to be named something else? Something more clear, less likely to conflict with ‘real’ properties — ‘description’ doesn’t seem to portray something that is value-preserving. What is the reason for calling it ‘description’?<br>&gt; <br>&gt; I’m also not quite sure (from the suggested names) whether the intended use is to be “a string *description* that happens to be value-preserving” (for which the name description might be ok), or “a value-preserving version of the instance as string *with no intent of that string ever being descriptive or helpful when presented to anything other than the matching initialiser of the same type*” (which rather be one form of serialisation).<br>&gt; <br>&gt;    Daniel.<br>&gt; <br></p><p>If you want to pursue this line of thinking, there is already precedent in the language for denoting &#39;an equivalent representation to&#39;, it is the &quot;as&quot; keyword. So perhaps to denote that the string is an equivalent representation of the value of this object, something like the following might be closer:<br></p><p>asStringValue<br>asString<br></p><p>but not the following as they convey the notion of a convertion rather than an equivalence:<br>toString<br>toStringValue<br></p><p>But frankly, I don&#39;t know that is it worth touching description (as the merrit of avoiding the ensuing debate of camel casing).<br></p><p><br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 28, 2016 at 01:00:00pm</p></header><div class="content"><p>On May 26, 2016, at 9:40 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Some remaining open questions:<br>&gt;&gt; <br>&gt;&gt; - Exactly what types should conform to ValuePreservingStringConvertible.  It seems clear that integer, floating point types, and Character can and should conform.  What other types should?<br>&gt; <br>&gt; Like Brent mentioned, there are some types that are natural candidates, including Foundation types whose conformance could go into the overlays. NSURL, NSUUID, NSIndexPath. NSData is a borderline candidate, and probably not a good fit in the end (what encoding to use? what happens if you get the .description of a 100 MB NSData? etc). Same with NSDate. Maybe some of the CGStructs, although maybe the fact that CGFloat differs between platforms will sink that idea.<br></p><p>Yes, there definitely are Foundation types that could adopt this.  However, we don’t have a swift-evolution process at the moment to propose Foundation API extensions, so these would have to go through bugreporter.apple.com.<br></p><p>&gt;&gt; - Do we need the ValuePreservingStringConvertible at all, or is the existing CustomStringConvertible enough?  We already have a few protocols for handling string convertibility, it would be great to avoid adding another one.<br>&gt; <br>&gt; This is a good question.<br>&gt; <br>&gt; Since a ValuePreservingStringConvertible is, by definition, a type that can be represented as a string in a lossless and unambiguous manner, would it be worth requiring a reverse conversion in the form of a failable initializer taking a string? Some of the proposed ValuePreservingStringConvertible types already have such functionality today. It would give the protocol a little more of a reason to exist, as well as encouraging proper conformance.<br></p><p>Yes, this would be really great.  Perhaps obvious, but this could/should be expressed an initializer requirement in ValuePreservingStringConvertible.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/f4538674/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 28, 2016 at 01:00:00pm</p></header><div class="content"><p>I&#39;ve submitted a swift-evolution PR with a modified version of the proposal that takes into account the feedback from the discussion participants.<br></p><p>If anyone is curious, the revised proposal can be found here: https://github.com/austinzheng/swift-evolution/blob/2b31df6163f5c5d1975a37e72c6996b82d61a5c6/proposals/0089-rename-string-reflection-init.md &lt;https://github.com/austinzheng/swift-evolution/blob/2b31df6163f5c5d1975a37e72c6996b82d61a5c6/proposals/0089-rename-string-reflection-init.md&gt;<br></p><p>Best,<br>Austin<br></p><p>&gt; On May 28, 2016, at 1:08 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On May 26, 2016, at 9:40 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Some remaining open questions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Exactly what types should conform to ValuePreservingStringConvertible.  It seems clear that integer, floating point types, and Character can and should conform.  What other types should?<br>&gt;&gt; <br>&gt;&gt; Like Brent mentioned, there are some types that are natural candidates, including Foundation types whose conformance could go into the overlays. NSURL, NSUUID, NSIndexPath. NSData is a borderline candidate, and probably not a good fit in the end (what encoding to use? what happens if you get the .description of a 100 MB NSData? etc). Same with NSDate. Maybe some of the CGStructs, although maybe the fact that CGFloat differs between platforms will sink that idea.<br>&gt; <br>&gt; Yes, there definitely are Foundation types that could adopt this.  However, we don’t have a swift-evolution process at the moment to propose Foundation API extensions, so these would have to go through bugreporter.apple.com &lt;http://bugreporter.apple.com/&gt;.<br>&gt; <br>&gt;&gt;&gt; - Do we need the ValuePreservingStringConvertible at all, or is the existing CustomStringConvertible enough?  We already have a few protocols for handling string convertibility, it would be great to avoid adding another one.<br>&gt;&gt; <br>&gt;&gt; This is a good question.<br>&gt;&gt; <br>&gt;&gt; Since a ValuePreservingStringConvertible is, by definition, a type that can be represented as a string in a lossless and unambiguous manner, would it be worth requiring a reverse conversion in the form of a failable initializer taking a string? Some of the proposed ValuePreservingStringConvertible types already have such functionality today. It would give the protocol a little more of a reason to exist, as well as encouraging proper conformance.<br>&gt; <br>&gt; Yes, this would be really great.  Perhaps obvious, but this could/should be expressed an initializer requirement in ValuePreservingStringConvertible.<br>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/4d077eb1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 28, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; If anyone is curious, the revised proposal can be found here: https://github.com/austinzheng/swift-evolution/blob/2b31df6163f5c5d1975a37e72c6996b82d61a5c6/proposals/0089-rename-string-reflection-init.md<br></p><p>This is great. My only suggestion is that `init?(description: String)` should be `init?(_ description: String)`, since by definition the conversion is fullwidth. But you may already be planning to incorporate that change, since Chris mentioned it.<br></p><p>Just quickly scanning the docs on swiftdoc.org, here are protocols which I think should conform to LosslessStringConvertible:<br></p><p>* FloatingPoint<br>* Integer<br>* Boolean?<br></p><p>And here are concrete types:<br></p><p>* Bool (if not Boolean)<br>* Character<br>* String (kind of circular, but I think it&#39;s a good idea) and its views<br>* String.Index? (Not sure how to represent this; UTF-8 offset, maybe?)<br>* UnicodeScalar<br></p><p>Protocols which would require conditional conformances:<br></p><p>* RangeReplaceableCollection where Iterator.Element == Character or UnicodeScalar<br>* SetAlgebra where Iterator.Element == Character or UnicodeScalar<br></p><p>These protocols were chosen because they include `init&lt;S: Sequence where S.Iterator.Element == Iterator.Element&gt;(_: S)` initializers.<br></p><p>Generic types which would require conditional conformances:<br></p><p>* ClosedRange where Bound: LosslessStringConvertible<br>* CountableClosedRange where Bound: LosslessStringConvertible<br>* CountableRange where Bound: LosslessStringConvertible<br>* Range where Bound: LosslessStringConvertible<br></p><p>These would be non-trivial, but useful. They could have a serialization like:<br></p><p>	var description: String {<br>		let operator = &quot;..&lt;&quot;	// or &quot;...&quot; for the closed ranges<br>		func escape(_ string: String) -&gt; String {<br>			let escapedOperator = String(operator.characters.flatMap { [&quot;\\&quot;, $0] })<br>			return string.replacingOccurrences(of: &quot;\\&quot;, with: &quot;\\\\&quot;).replacingOccurrences(of: operator, with: escapedOperator)<br>		}<br>		<br>		return escape(String(lowerBound)) + &quot; &quot; + operator + &quot; &quot; + escape(String(upperBound))<br>	}<br></p><p>The `init(_: String)` method would need to handle the escapes—hence the nontrivial-ness.<br></p><p>Technically possible, but probably unwise:<br></p><p>* ObjectIdentifier<br>* UnsafePointer and friends<br>* Set.Index and Dictionary.Index<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 29, 2016 at 12:00:00pm</p></header><div class="content"><p>Fantastic, thanks to both of you.  I merged it here:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0089-rename-string-reflection-init.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0089-rename-string-reflection-init.md&gt;<br></p><p>Please let me know if you’d like any other changes, I’ll kick off the review on Tuesday.<br></p><p>-Chris<br></p><p>&gt; On May 28, 2016, at 3:33 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; If anyone is curious, the revised proposal can be found here: https://github.com/austinzheng/swift-evolution/blob/2b31df6163f5c5d1975a37e72c6996b82d61a5c6/proposals/0089-rename-string-reflection-init.md<br>&gt; <br>&gt; This is great. My only suggestion is that `init?(description: String)` should be `init?(_ description: String)`, since by definition the conversion is fullwidth. But you may already be planning to incorporate that change, since Chris mentioned it.<br>&gt; <br>&gt; Just quickly scanning the docs on swiftdoc.org, here are protocols which I think should conform to LosslessStringConvertible:<br>&gt; <br>&gt; * FloatingPoint<br>&gt; * Integer<br>&gt; * Boolean?<br>&gt; <br>&gt; And here are concrete types:<br>&gt; <br>&gt; * Bool (if not Boolean)<br>&gt; * Character<br>&gt; * String (kind of circular, but I think it&#39;s a good idea) and its views<br>&gt; * String.Index? (Not sure how to represent this; UTF-8 offset, maybe?)<br>&gt; * UnicodeScalar<br>&gt; <br>&gt; Protocols which would require conditional conformances:<br>&gt; <br>&gt; * RangeReplaceableCollection where Iterator.Element == Character or UnicodeScalar<br>&gt; * SetAlgebra where Iterator.Element == Character or UnicodeScalar<br>&gt; <br>&gt; These protocols were chosen because they include `init&lt;S: Sequence where S.Iterator.Element == Iterator.Element&gt;(_: S)` initializers.<br>&gt; <br>&gt; Generic types which would require conditional conformances:<br>&gt; <br>&gt; * ClosedRange where Bound: LosslessStringConvertible<br>&gt; * CountableClosedRange where Bound: LosslessStringConvertible<br>&gt; * CountableRange where Bound: LosslessStringConvertible<br>&gt; * Range where Bound: LosslessStringConvertible<br>&gt; <br>&gt; These would be non-trivial, but useful. They could have a serialization like:<br>&gt; <br>&gt; 	var description: String {<br>&gt; 		let operator = &quot;..&lt;&quot;	// or &quot;...&quot; for the closed ranges<br>&gt; 		func escape(_ string: String) -&gt; String {<br>&gt; 			let escapedOperator = String(operator.characters.flatMap { [&quot;\\&quot;, $0] })<br>&gt; 			return string.replacingOccurrences(of: &quot;\\&quot;, with: &quot;\\\\&quot;).replacingOccurrences(of: operator, with: escapedOperator)<br>&gt; 		}<br>&gt; 		<br>&gt; 		return escape(String(lowerBound)) + &quot; &quot; + operator + &quot; &quot; + escape(String(upperBound))<br>&gt; 	}<br>&gt; <br>&gt; The `init(_: String)` method would need to handle the escapes—hence the nontrivial-ness.<br>&gt; <br>&gt; Technically possible, but probably unwise:<br>&gt; <br>&gt; * ObjectIdentifier<br>&gt; * UnsafePointer and friends<br>&gt; * Set.Index and Dictionary.Index<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/f50f9f6d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Returned for revision] SE-0089: Renaming String.init&lt;T&gt;(_: T)</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>May 27, 2016 at 10:00:00am</p></header><div class="content"><p>I like the design strategy, but I’m having a hard time seeing the value of `ValuePreservingStringConvertible`; it’d be easier to evaluate the need for it with some concrete examples of types with `description` implementations that:<br></p><p>- aren’t value-preserving<br>- would cause problems if mistakenly-classified as value-preserving<br></p><p>Relatedly, here are some concrete `description`/`debugDescription` pairs; would these `description`s be value-preserving or not?<br></p><p>- a `Wavelength` type<br> - description: “650.0 nm”<br> - debugDescription: “Wavelength(nanometers: 650.0)”<br></p><p>- an `Angle` type:<br>  - description: “90.0°”<br>  - debugDescription: “Angle(πUnits: 0.5)”<br></p><p>…(note that neither type has a corresponding `init?(_ string: String)` implementation, and I don’t plan to add one either).<br></p><p>I’m just having trouble coming up with realistic non-value-preserving descriptions that’d be *problematic* (as opposed to just, say, unhelpful).<br></p><p>&gt; On May 26, 2016, at 12:08 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0089-rename-string-reflection-init.md<br>&gt; <br>&gt; The review of &quot;SE-0089: Renaming String.init&lt;T&gt;(_: T)&quot; ran from May 17…23, 2016. The proposal has been *returned for revision* and another round of discussion - the core team would love to see the revised proposal make it into Swift 3.<br>&gt; <br>&gt; The community and core team both want to remove this “footgun” from the standard library, where someone could write &quot;String(x)” with the intention of getting a value-preserving conversion to String, but may instead get a potentially lossy and potentially expensive reflection-based conversion to a String.  After extensive discussion, the core team recommends that the community consider a somewhat more elaborate design:<br>&gt; <br>&gt; - Rename the existing reflection-based &quot;String.init&lt;T&gt;(_: T)” initializer to &quot;String.init&lt;T&gt;(describing: T)” as recommend by the community.  This initializer would rarely be invoked in user code directly.<br>&gt; <br>&gt; - Introduce a new protocol (for sake of discussion, call it “ValuePreservingStringConvertible&quot;) that refines CustomStringConvertible but that adds no new requirements.  Conformance to this protocol indicates that the “description” requirement produces a value-preserving representation in String form.<br>&gt; <br>&gt; - Introduce a new unlabeled initializer on String: &quot;init&lt;T: ValuePreservingStringConvertible&gt;(_ v: T) { return v.description }&quot;.  This permits the “String(x)” syntax to be used on all values of types that can be converted to string in a value-preserving way.<br>&gt; <br>&gt; - Audit important standard library types (e.g. the integer and floating point types), and make them explicitly conform to ValuePreservingStringConvertible with an explicitly implemented “description” property.<br>&gt; <br>&gt; - As a performance optimization, change the implementation of the string literal interpolation syntax to prefer the unlabeled initializer when interpolating a type that is ValuePreservingStringConvertible or that has otherwise has an unlabeled String initializer, but use the &quot;String.init&lt;T&gt;(describing: T)” initializer if not.<br>&gt; <br>&gt; <br>&gt; The expected advantages of this design are:<br>&gt; <br>&gt; - Swift encourages the T(x) syntax for value preserving conversions, and this design ensures that String(x) continues to work for the value preserving cases.<br>&gt; <br>&gt; - This ensures that the String(x) syntax does not accidentally fall off a performance cliff by using the extremely-dynamic reflection mechanism unintentionally.<br>&gt; <br>&gt; - The preferred “I don’t care how you do it, just convert this value to a string somehow” syntax remains string interpolation syntax.  This syntax is efficient in the cases where the String(x) syntax is allowed, but fully general to the other cases where custom convert-to-string code has not been provided.<br>&gt; <br>&gt; <br>&gt; Some remaining open questions:<br>&gt; <br>&gt; - Exactly what types should conform to ValuePreservingStringConvertible.  It seems clear that integer, floating point types, and Character can and should conform.  What other types should?<br>&gt; <br>&gt; - Do we need the ValuePreservingStringConvertible at all, or is the existing CustomStringConvertible enough?  We already have a few protocols for handling string convertibility, it would be great to avoid adding another one.<br>&gt; <br>&gt; Thank you to Austin Zheng for driving this proposal forward!<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
