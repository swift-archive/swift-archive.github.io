<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 29, 2015 at 06:00:00pm</p></header><div class="content"><p>I&#39;m proposing a new extension method on SequenceType called find(). It&#39;s similar to CollectionType.indexOf() except it returns the element:<br></p><p>extension SequenceType {<br></p><p>/// Returns the first element where `predicate` returns `true`, or `nil`<br></p><p>/// if such value is not found.<br></p><p>public func find(@noescape predicate: (Self.Generator.Element) throws -&gt;<br>Bool) rethrows -&gt; Self.Generator.Element? {<br></p><p>for elt in self {<br></p><p>if try predicate(elt) {<br></p><p>return elt<br></p><p>}<br></p><p>}<br></p><p>return nil<br></p><p>}<br></p><p>}<br></p><p><br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/11370ad6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6ab7ae85b84ebb323fab427b11500742?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Keith Smiley</string> &lt;keithbsmiley at gmail.com&gt;<p>December 30, 2015 at 02:00:00am</p></header><div class="content"><p>+1. We&#39;ve added an extension for this and find it very useful.<br>On Tue, Dec 29, 2015 at 18:38 Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;m proposing a new extension method on SequenceType called find(). It&#39;s<br>&gt; similar to CollectionType.indexOf() except it returns the element:<br>&gt;<br>&gt;<br>&gt; extension SequenceType {<br>&gt;<br>&gt;     /// Returns the first element where `predicate` returns `true`, or<br>&gt; `nil`<br>&gt;<br>&gt;     /// if such value is not found.<br>&gt;<br>&gt;     public func find(@noescape predicate: (Self.Generator.Element) throws<br>&gt; -&gt; Bool) rethrows -&gt; Self.Generator.Element? {<br>&gt;<br>&gt;         for elt in self {<br>&gt;<br>&gt;             if try predicate(elt) {<br>&gt;<br>&gt;                 return elt<br>&gt;<br>&gt;             }<br>&gt;<br>&gt;         }<br>&gt;<br>&gt;         return nil<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/9c794520/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 30, 2015 at 06:00:00pm</p></header><div class="content"><p>+1 we also have a very similar extension.<br></p><p>On Wed, Dec 30, 2015 at 1:40 PM, Keith Smiley via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1. We&#39;ve added an extension for this and find it very useful.<br>&gt; On Tue, Dec 29, 2015 at 18:38 Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I&#39;m proposing a new extension method on SequenceType called find(). It&#39;s<br>&gt;&gt; similar to CollectionType.indexOf() except it returns the element:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; extension SequenceType {<br>&gt;&gt;<br>&gt;&gt;     /// Returns the first element where `predicate` returns `true`, or<br>&gt;&gt; `nil`<br>&gt;&gt;<br>&gt;&gt;     /// if such value is not found.<br>&gt;&gt;<br>&gt;&gt;     public func find(@noescape predicate: (Self.Generator.Element) throws<br>&gt;&gt; -&gt; Bool) rethrows -&gt; Self.Generator.Element? {<br>&gt;&gt;<br>&gt;&gt;         for elt in self {<br>&gt;&gt;<br>&gt;&gt;             if try predicate(elt) {<br>&gt;&gt;<br>&gt;&gt;                 return elt<br>&gt;&gt;<br>&gt;&gt;             }<br>&gt;&gt;<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         return nil<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/a5ebd817/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 30, 2015 at 10:00:00am</p></header><div class="content"><p>We should add the full collection of ruby methods http://matthewcarriere.com/06/23/using-select-reject-collect-inject-and-detect/<br></p><p><br></p><p>Sent from my iPhone<br></p><p>&gt; On 30 Dec 2015, at 02:40, Keith Smiley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1. We&#39;ve added an extension for this and find it very useful.<br>&gt;&gt; On Tue, Dec 29, 2015 at 18:38 Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I&#39;m proposing a new extension method on SequenceType called find(). It&#39;s similar to CollectionType.indexOf() except it returns the element:<br>&gt;&gt;  <br>&gt;&gt; extension SequenceType {<br>&gt;&gt;     /// Returns the first element where `predicate` returns `true`, or `nil`<br>&gt;&gt;     /// if such value is not found.<br>&gt;&gt;     public func find(@noescape predicate: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.Generator.Element? {<br>&gt;&gt;         for elt in self {<br>&gt;&gt;             if try predicate(elt) {<br>&gt;&gt;                 return elt<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;         return nil<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/6b7cd587/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f5228ad4a1fad94f1a7d3d05b0c0ff6a?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Donnacha Oisín Kidney</string> &lt;oisin.kidney at gmail.com&gt;<p>December 30, 2015 at 03:00:00pm</p></header><div class="content"><p>+1 on this.<br></p><p>I see a lot of code like this:<br></p><p>sequence.filter(predicate).first<br></p><p>Which is of course is inefficient. However, the go-to optimisation:<br></p><p>sequence.lazy.filter(predicate).first<br></p><p>Is not necessarily better, and has some strange behaviour:<br></p><p>let array = [1, 2, 3, 4, 5, 6]<br>func noisyPredicate(n: Int) -&gt; Bool {<br>  print(n, terminator: &quot; &quot;)<br>  return n &gt; 2<br>}<br></p><p>array.lazy.filter(noisyPredicate).first<br>// 1 2 3 1 2 3<br></p><p>AnySequence(array).lazy.filter(noisyPredicate).first<br>// 1 2 3 4 5 6<br></p><p>If it’s called on a collection, the collection is only evaluated up until the element being looked for, but it’s done twice. If it’s called on a sequence, the whole sequence is evaluated, regardless of where the element is found.<br></p><p>I think that find is maybe not the best name, though. It’s not immediately clear that it doesn’t return an index. I’d prefer to call it first, as in:<br></p><p>extension SequenceType {<br>  /// Returns the first element where `predicate` returns `true`, or `nil`<br>  /// if such value is not found.<br>  public func first(@noescape thatSatisfies: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.Generator.Element? {<br>    for elt in self {<br>      if try thatSatisfies(elt) {<br>        return elt<br>      }<br>    }<br>    return nil<br>  }<br>}<br></p><p>[1, 2, 3, 4, 5].first(thatSatisfies: (Int) throws -&gt; Bool)<br></p><p>[1, 2, 3, 4, 5].first { $0 &gt; 3 }<br></p><p>&gt; On 30 Dec 2015, at 10:13, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We should add the full collection of ruby methods http://matthewcarriere.com/06/23/using-select-reject-collect-inject-and-detect/ &lt;http://matthewcarriere.com/06/23/using-select-reject-collect-inject-and-detect/&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On 30 Dec 2015, at 02:40, Keith Smiley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; +1. We&#39;ve added an extension for this and find it very useful.<br>&gt;&gt; On Tue, Dec 29, 2015 at 18:38 Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I&#39;m proposing a new extension method on SequenceType called find(). It&#39;s similar to CollectionType.indexOf() except it returns the element:<br>&gt;&gt;  <br>&gt;&gt; extension SequenceType {<br>&gt;&gt;     /// Returns the first element where `predicate` returns `true`, or `nil`<br>&gt;&gt;     /// if such value is not found.<br>&gt;&gt;     public func find(@noescape predicate: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.Generator.Element? {<br>&gt;&gt;         for elt in self {<br>&gt;&gt;             if try predicate(elt) {<br>&gt;&gt;                 return elt<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;         return nil<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/d3b26c10/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 30, 2015 at 05:00:00pm</p></header><div class="content"><p>Ruby calls that method detect. As in detect and return the item that matches this condition<br></p><p>Sent from my iPhone<br></p><p>&gt; On 30 Dec 2015, at 15:33, Donnacha Oisín Kidney &lt;oisin.kidney at gmail.com&gt; wrote:<br>&gt; <br>&gt; +1 on this.<br>&gt; <br>&gt; I see a lot of code like this:<br>&gt; <br>&gt; sequence.filter(predicate).first<br>&gt; <br>&gt; Which is of course is inefficient. However, the go-to optimisation:<br>&gt; <br>&gt; sequence.lazy.filter(predicate).first<br>&gt; <br>&gt; Is not necessarily better, and has some strange behaviour:<br>&gt; <br>&gt; let array = [1, 2, 3, 4, 5, 6]<br>&gt; func noisyPredicate(n: Int) -&gt; Bool {<br>&gt;   print(n, terminator: &quot; &quot;)<br>&gt;   return n &gt; 2<br>&gt; }<br>&gt; <br>&gt; array.lazy.filter(noisyPredicate).first<br>&gt; // 1 2 3 1 2 3<br>&gt; <br>&gt; AnySequence(array).lazy.filter(noisyPredicate).first<br>&gt; // 1 2 3 4 5 6<br>&gt; <br>&gt; If it’s called on a collection, the collection is only evaluated up until the element being looked for, but it’s done twice. If it’s called on a sequence, the whole sequence is evaluated, regardless of where the element is found.<br>&gt; <br>&gt; I think that find is maybe not the best name, though. It’s not immediately clear that it doesn’t return an index. I’d prefer to call it first, as in:<br>&gt; <br>&gt; extension SequenceType {<br>&gt;   /// Returns the first element where `predicate` returns `true`, or `nil`<br>&gt;   /// if such value is not found.<br>&gt;   public func first(@noescape thatSatisfies: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.Generator.Element? {<br>&gt;     for elt in self {<br>&gt;       if try thatSatisfies(elt) {<br>&gt;         return elt<br>&gt;       }<br>&gt;     }<br>&gt;     return nil<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; [1, 2, 3, 4, 5].first(thatSatisfies: (Int) throws -&gt; Bool)<br>&gt; <br>&gt; [1, 2, 3, 4, 5].first { $0 &gt; 3 }<br>&gt; <br>&gt;&gt; On 30 Dec 2015, at 10:13, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We should add the full collection of ruby methods http://matthewcarriere.com/06/23/using-select-reject-collect-inject-and-detect/<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 30 Dec 2015, at 02:40, Keith Smiley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1. We&#39;ve added an extension for this and find it very useful.<br>&gt;&gt;&gt;&gt; On Tue, Dec 29, 2015 at 18:38 Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; I&#39;m proposing a new extension method on SequenceType called find(). It&#39;s similar to CollectionType.indexOf() except it returns the element:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; extension SequenceType {<br>&gt;&gt;&gt;&gt;     /// Returns the first element where `predicate` returns `true`, or `nil`<br>&gt;&gt;&gt;&gt;     /// if such value is not found.<br>&gt;&gt;&gt;&gt;     public func find(@noescape predicate: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.Generator.Element? {<br>&gt;&gt;&gt;&gt;         for elt in self {<br>&gt;&gt;&gt;&gt;             if try predicate(elt) {<br>&gt;&gt;&gt;&gt;                 return elt<br>&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         return nil<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/d3a7912d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 30, 2015 at 05:00:00pm</p></header><div class="content"><p>But overloading the first method with a closure is a clever ide s<br></p><p>Sent from my iPhone<br></p><p>&gt; On 30 Dec 2015, at 15:33, Donnacha Oisín Kidney &lt;oisin.kidney at gmail.com&gt; wrote:<br>&gt; <br>&gt; +1 on this.<br>&gt; <br>&gt; I see a lot of code like this:<br>&gt; <br>&gt; sequence.filter(predicate).first<br>&gt; <br>&gt; Which is of course is inefficient. However, the go-to optimisation:<br>&gt; <br>&gt; sequence.lazy.filter(predicate).first<br>&gt; <br>&gt; Is not necessarily better, and has some strange behaviour:<br>&gt; <br>&gt; let array = [1, 2, 3, 4, 5, 6]<br>&gt; func noisyPredicate(n: Int) -&gt; Bool {<br>&gt;   print(n, terminator: &quot; &quot;)<br>&gt;   return n &gt; 2<br>&gt; }<br>&gt; <br>&gt; array.lazy.filter(noisyPredicate).first<br>&gt; // 1 2 3 1 2 3<br>&gt; <br>&gt; AnySequence(array).lazy.filter(noisyPredicate).first<br>&gt; // 1 2 3 4 5 6<br>&gt; <br>&gt; If it’s called on a collection, the collection is only evaluated up until the element being looked for, but it’s done twice. If it’s called on a sequence, the whole sequence is evaluated, regardless of where the element is found.<br>&gt; <br>&gt; I think that find is maybe not the best name, though. It’s not immediately clear that it doesn’t return an index. I’d prefer to call it first, as in:<br>&gt; <br>&gt; extension SequenceType {<br>&gt;   /// Returns the first element where `predicate` returns `true`, or `nil`<br>&gt;   /// if such value is not found.<br>&gt;   public func first(@noescape thatSatisfies: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.Generator.Element? {<br>&gt;     for elt in self {<br>&gt;       if try thatSatisfies(elt) {<br>&gt;         return elt<br>&gt;       }<br>&gt;     }<br>&gt;     return nil<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; [1, 2, 3, 4, 5].first(thatSatisfies: (Int) throws -&gt; Bool)<br>&gt; <br>&gt; [1, 2, 3, 4, 5].first { $0 &gt; 3 }<br>&gt; <br>&gt;&gt; On 30 Dec 2015, at 10:13, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We should add the full collection of ruby methods http://matthewcarriere.com/06/23/using-select-reject-collect-inject-and-detect/<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 30 Dec 2015, at 02:40, Keith Smiley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1. We&#39;ve added an extension for this and find it very useful.<br>&gt;&gt;&gt;&gt; On Tue, Dec 29, 2015 at 18:38 Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; I&#39;m proposing a new extension method on SequenceType called find(). It&#39;s similar to CollectionType.indexOf() except it returns the element:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; extension SequenceType {<br>&gt;&gt;&gt;&gt;     /// Returns the first element where `predicate` returns `true`, or `nil`<br>&gt;&gt;&gt;&gt;     /// if such value is not found.<br>&gt;&gt;&gt;&gt;     public func find(@noescape predicate: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.Generator.Element? {<br>&gt;&gt;&gt;&gt;         for elt in self {<br>&gt;&gt;&gt;&gt;             if try predicate(elt) {<br>&gt;&gt;&gt;&gt;                 return elt<br>&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         return nil<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/8c1d5c59/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 30, 2015 at 02:00:00pm</p></header><div class="content"><p>On Wed, Dec 30, 2015, at 07:33 AM, Donnacha Oisín Kidney via swift-evolution wrote:<br>&gt; +1 on this.<br>&gt;<br>&gt; I see a lot of code like this:<br>&gt;<br>&gt; sequence.filter(predicate).first<br>&gt;<br>&gt; Which is of course is inefficient. However, the go-to optimisation:<br>&gt;<br>&gt; sequence.lazy.filter(predicate).first<br>&gt;<br>&gt; Is not necessarily better, and has some strange behaviour:<br>&gt;<br>&gt; let array = [1, 2, 3, 4, 5, 6] func noisyPredicate(n: Int) -&gt; Bool {<br>&gt; print(n, terminator: &quot; &quot;) return n &gt; 2 }<br>&gt;<br>&gt; array.lazy.filter(noisyPredicate).first // 1 2 3 1 2 3<br>&gt;<br>&gt; AnySequence(array).lazy.filter(noisyPredicate).first // 1 2 3 4 5 6<br>&gt;<br>&gt; If it’s called on a collection, the collection is only evaluated up<br>&gt; until the element being looked for, but it’s done twice. If it’s<br>&gt; called on a sequence, the *whole* sequence is evaluated, regardless of<br>&gt; where the element is found.<br></p><p>Actually, you&#39;re calling it on a collection in both cases. SequenceType<br>doesn&#39;t have a `first` property (honestly, I think it should). Saying<br>`lazy.filter(noisyPredicate)` is actually resolving to the version of<br>filter() from SequenceType, the one that returns an Array, because the<br>one from LazySequenceType that returns a LazyFilterSequence doesn&#39;t have<br>a `first` property.<br></p><p>As for it calling it twice on a collection, this is because it&#39;s<br>implemented as `isEmpty ? nil : self[startIndex]`, which is honestly<br>pretty silly.<br></p><p>FWIW, there&#39;s other sequence methods that actually evaluate lazy<br>collections twice, because they detect that the receiver is a<br>collection and run a preprocessing pass first. For example, the<br>version of joinWithSeparator() that returns a String does this (to<br>size all of the elements so it can preallocate a buffer), which causes<br>duplicate evaluation of lazy filter/map collections. I filed this a<br>while ago as SR-68[1].<br></p><p>&gt; I think that find is maybe not the best name, though. It’s not<br>&gt; immediately clear that it doesn’t return an index.<br></p><p>indexOf() used to be called find(), but it was renamed because find()<br>didn&#39;t make it obvious that it returned an index. I know I personally<br>got confused all the time about what find() returned.<br></p><p>Also, this is a sequence method. Sequences don&#39;t have indexes.<br></p><p>-Kevin Ballard<br></p><p>&gt; I’d prefer to call it first, as in:<br>&gt;<br>&gt; extensionSequenceType { /// Returns the first element where<br>&gt; `predicate` returns `true`, or `nil` /// if such value is not found.<br>&gt; public func first(@noescape thatSatisfies: (Self.Generator.Element)<br>&gt; throws -&gt; Bool) rethrows -&gt; Self.Generator.Element? { for elt in self<br>&gt; { if try thatSatisfies(elt) { return elt      }    } returnnil  } }<br>&gt;<br>&gt; [1, 2, 3, 4, 5].first(thatSatisfies: (Int) throws -&gt; Bool)<br>&gt;<br>&gt; [1, 2, 3, 4, 5].first { $0 &gt; 3 }<br>&gt;<br>&gt;&gt; On 30 Dec 2015, at 10:13, James Campbell via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; We should add the full collection of ruby methods<br>&gt;&gt; http://matthewcarriere.com/06/23/using-select-reject-collect-inject-and-detect/<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPhone<br>&gt;&gt;<br>&gt;&gt; On 30 Dec 2015, at 02:40, Keith Smiley via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; +1. We&#39;ve added an extension for this and find it very useful. On<br>&gt;&gt;&gt; Tue, Dec 29, 2015 at 18:38 Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; __<br>&gt;&gt;&gt;&gt; I&#39;m proposing a new extension method on SequenceType called find().<br>&gt;&gt;&gt;&gt; It&#39;s similar to CollectionType.indexOf() except it returns the<br>&gt;&gt;&gt;&gt; element:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; extensionSequenceType{ /// Returns the first element where<br>&gt;&gt;&gt;&gt; `predicate` returns `true`, or `nil` /// if such value is not<br>&gt;&gt;&gt;&gt; found. publicfuncfind(@noescapepredicate: (Self.Generator.Element)throws-&gt;Bool)rethrows-<br>&gt;&gt;&gt;&gt; &gt;Self.Generator.Element? { foreltinself{ iftrypredicate(elt) {<br>&gt;&gt;&gt;&gt; returnelt            }        } returnnil    } }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>Links:<br></p><p>  1. https://bugs.swift.org/browse/SR-68<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/39494b39/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 30, 2015 at 02:00:00pm</p></header><div class="content"><p>On Wed, Dec 30, 2015, at 02:13 AM, James Campbell wrote:<br>&gt; We should add the full collection of ruby methods http://matthewcarriere.com/06/23/using-select-reject-collect-inject-and-detect/<br></p><p>We already have them. Well, almost:<br></p><p>select - this is filter reject - this is just filter with a negated<br>predicate collect - this is map inject - this is reduce detect - this is<br>the find() method that I&#39;m proposing here.<br></p><p>-Kevin<br></p><p>&gt; On 30 Dec 2015, at 02:40, Keith Smiley via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt; +1. We&#39;ve added an extension for this and find it very useful. On<br>&gt;&gt; Tue, Dec 29, 2015 at 18:38 Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; __<br>&gt;&gt;&gt; I&#39;m proposing a new extension method on SequenceType called find().<br>&gt;&gt;&gt; It&#39;s similar to CollectionType.indexOf() except it returns the<br>&gt;&gt;&gt; element:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extensionSequenceType {<br></p><p><br>&gt;&gt;&gt; /// Returns the first element where `predicate` returns `true`,<br>&gt;&gt;&gt; or `nil`<br></p><p><br>&gt;&gt;&gt; /// if such value is not found.<br></p><p><br>&gt;&gt;&gt; public func find(@noescape predicate: (Self.Generator.Element)<br>&gt;&gt;&gt; throws -&gt; Bool) rethrows -&gt; Self.Generator.Element? {<br></p><p><br>&gt;&gt;&gt; for elt in self {<br></p><p><br>&gt;&gt;&gt; if try predicate(elt) {<br></p><p><br>&gt;&gt;&gt; return elt<br></p><p><br>&gt;&gt;&gt; }<br></p><p><br>&gt;&gt;&gt; }<br></p><p><br>&gt;&gt;&gt; return nil<br></p><p><br>&gt;&gt;&gt; }<br></p><p><br>&gt;&gt;&gt; }<br></p><p><br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;<br>swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/86b58426/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>December 30, 2015 at 07:00:00pm</p></header><div class="content"><p>Is it worth considering a version that returns a tuple of (index, element) ?<br></p><p>Nevin<br></p><p><br>On Tue, Dec 29, 2015 at 9:40 PM, Keith Smiley via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1. We&#39;ve added an extension for this and find it very useful.<br>&gt; On Tue, Dec 29, 2015 at 18:38 Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I&#39;m proposing a new extension method on SequenceType called find(). It&#39;s<br>&gt;&gt; similar to CollectionType.indexOf() except it returns the element:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; extension SequenceType {<br>&gt;&gt;<br>&gt;&gt;     /// Returns the first element where `predicate` returns `true`, or<br>&gt;&gt; `nil`<br>&gt;&gt;<br>&gt;&gt;     /// if such value is not found.<br>&gt;&gt;<br>&gt;&gt;     public func find(@noescape predicate: (Self.Generator.Element) throws<br>&gt;&gt; -&gt; Bool) rethrows -&gt; Self.Generator.Element? {<br>&gt;&gt;<br>&gt;&gt;         for elt in self {<br>&gt;&gt;<br>&gt;&gt;             if try predicate(elt) {<br>&gt;&gt;<br>&gt;&gt;                 return elt<br>&gt;&gt;<br>&gt;&gt;             }<br>&gt;&gt;<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         return nil<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/7c6b878c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 30, 2015 at 04:00:00pm</p></header><div class="content"><p>Good thought, but I doubt such a method would pull its own weight.<br></p><p>-Kevin Ballard<br></p><p>On Wed, Dec 30, 2015, at 04:24 PM, Nevin Brackett-Rozinsky wrote:<br>&gt; Is it worth considering a version that returns a tuple of (index,<br>&gt; element) ?<br>&gt;<br>&gt; Nevin<br>&gt;<br>&gt;<br>&gt; On Tue, Dec 29, 2015 at 9:40 PM, Keith Smiley via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt; +1. We&#39;ve added an extension for this and find it very useful. On<br>&gt;&gt; Tue, Dec 29, 2015 at 18:38 Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; __<br>&gt;&gt;&gt; I&#39;m proposing a new extension method on SequenceType called find().<br>&gt;&gt;&gt; It&#39;s similar to CollectionType.indexOf() except it returns the<br>&gt;&gt;&gt; element:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extensionSequenceType {<br></p><p><br>&gt;&gt;&gt; /// Returns the first element where `predicate` returns `true`,<br>&gt;&gt;&gt; or `nil`<br></p><p><br>&gt;&gt;&gt; /// if such value is not found.<br></p><p><br>&gt;&gt;&gt; public func find(@noescape predicate: (Self.Generator.Element)<br>&gt;&gt;&gt; throws -&gt; Bool) rethrows -&gt; Self.Generator.Element? {<br></p><p><br>&gt;&gt;&gt; for elt in self {<br></p><p><br>&gt;&gt;&gt; if try predicate(elt) {<br></p><p><br>&gt;&gt;&gt; return elt<br></p><p><br>&gt;&gt;&gt; }<br></p><p><br>&gt;&gt;&gt; }<br></p><p><br>&gt;&gt;&gt; return nil<br></p><p><br>&gt;&gt;&gt; }<br></p><p><br>&gt;&gt;&gt; }<br></p><p><br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;<br>swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt;<br>swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/b4869034/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  9, 2016 at 04:00:00pm</p></header><div class="content"><p>Proposal PR submitted as https://github.com/apple/swift-evolution/pull/94<br></p><p>-Kevin Ballard<br></p><p>On Tue, Dec 29, 2015, at 06:38 PM, Kevin Ballard wrote:<br>&gt; I&#39;m proposing a new extension method on SequenceType called find().<br>&gt; It&#39;s similar to CollectionType.indexOf() except it returns the<br>&gt; element:<br>&gt;<br>&gt; extensionSequenceType {<br></p><p><br>&gt; /// Returns the first element where `predicate` returns `true`,<br>&gt; or `nil`<br></p><p><br>&gt; /// if such value is not found.<br></p><p><br>&gt; public func find(@noescape predicate: (Self.Generator.Element) throws<br>&gt; -&gt; Bool) rethrows -&gt; Self.Generator.Element? {<br></p><p><br>&gt; for elt in self {<br></p><p><br>&gt; if try predicate(elt) {<br></p><p><br>&gt; return elt<br></p><p><br>&gt; }<br></p><p><br>&gt; }<br></p><p><br>&gt; return nil<br></p><p><br>&gt; }<br></p><p><br>&gt; }<br></p><p><br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/602c5058/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f1b93037cbc5f78f16450bd925ce3b5b?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Marco Masser</string> &lt;lists at duckcode.com&gt;<p>February 17, 2016 at 10:00:00am</p></header><div class="content"><p>I just saw this PR and have a quick comment about the implementation: It could be shortened by a few lines using a where clause like this:<br></p><p>func find(@noescape predicate: Self.Generator.Element throws -&gt; Bool) rethrows -&gt; Self.Generator.Element? {<br>    for element in self where try predicate(element) {<br>        return element<br>    }<br>    return nil<br>}<br></p><p><br>Also, I’d like suggest adding a variant that works better with heterogenous sequences, but I’ll raise that when this proposal goes into review.<br></p><p>FYI: That variant would look like this:<br>func find&lt;T&gt;(_: T.Type, @noescape matching predicate: T throws -&gt; Bool) rethrows -&gt; T?<br></p><p>A question by me on the swift-users mailing list describes its intention, implementation, and usage:<br>[swift-users] Which is the more idiomatic approach for pinning down	the type of a generic parameter? &lt;https://lists.swift.org/pipermail/swift-users/Week-of-Mon-20160118/000893.html&gt;<br></p><p>Cheers,<br></p><p>Marco<br></p><p><br>&gt; On 2016-01-10, at 01:58, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Proposal PR submitted as https://github.com/apple/swift-evolution/pull/94 &lt;https://github.com/apple/swift-evolution/pull/94&gt;<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Tue, Dec 29, 2015, at 06:38 PM, Kevin Ballard wrote:<br>&gt;&gt; I&#39;m proposing a new extension method on SequenceType called find(). It&#39;s similar to CollectionType.indexOf() except it returns the element:<br>&gt;&gt;  <br>&gt;&gt; extensionSequenceType {<br>&gt;&gt; /// Returns the first element where `predicate` returns `true`, or `nil`<br>&gt;&gt; /// if such value is not found.<br>&gt;&gt; public func find(@noescape predicate: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.Generator.Element? {<br>&gt;&gt; for elt in self {<br>&gt;&gt; if try predicate(elt) {<br>&gt;&gt; return elt<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt; return nil<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;  <br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/56d04681/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February 17, 2016 at 04:00:00pm</p></header><div class="content"><p>I think<br></p><p>        subviews.find{ ($0 as? NSButton)?.state == NSOnState } as? NSButton<br></p><p>is sufficient and makes it clear that you are searching for a specific type. Even though you have to cast twice I don&#39;t think an additional method would be worth its use since it isn&#39;t used as often.<br></p><p>- Maximilian<br></p><p>&gt; Am 17.02.2016 um 10:32 schrieb Marco Masser via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I just saw this PR and have a quick comment about the implementation: It could be shortened by a few lines using a where clause like this:<br>&gt; <br>&gt; func find(@noescape predicate: Self.Generator.Element throws -&gt; Bool) rethrows -&gt; Self.Generator.Element? {<br>&gt;     for element in self where try predicate(element) {<br>&gt;         return element<br>&gt;     }<br>&gt;     return nil<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Also, I’d like suggest adding a variant that works better with heterogenous sequences, but I’ll raise that when this proposal goes into review.<br>&gt; <br>&gt; FYI: That variant would look like this:<br>&gt; func find&lt;T&gt;(_: T.Type, @noescape matching predicate: T throws -&gt; Bool) rethrows -&gt; T?<br>&gt; <br>&gt; A question by me on the swift-users mailing list describes its intention, implementation, and usage:<br>&gt; [swift-users] Which is the more idiomatic approach for pinning down	the type of a generic parameter?<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Marco<br>&gt; <br>&gt; <br>&gt;&gt; On 2016-01-10, at 01:58, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Proposal PR submitted as https://github.com/apple/swift-evolution/pull/94<br>&gt;&gt;  <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;  <br>&gt;&gt;&gt; On Tue, Dec 29, 2015, at 06:38 PM, Kevin Ballard wrote:<br>&gt;&gt;&gt; I&#39;m proposing a new extension method on SequenceType called find(). It&#39;s similar to CollectionType.indexOf() except it returns the element:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; extensionSequenceType {<br>&gt;&gt;&gt; /// Returns the first element where `predicate` returns `true`, or `nil`<br>&gt;&gt;&gt; /// if such value is not found.<br>&gt;&gt;&gt; public func find(@noescape predicate: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.Generator.Element? {<br>&gt;&gt;&gt; for elt in self {<br>&gt;&gt;&gt; if try predicate(elt) {<br>&gt;&gt;&gt; return elt<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt; return nil<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/8e45578d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>February 17, 2016 at 03:00:00pm</p></header><div class="content"><p>Alternatively you can write<br></p><p>subviews.lazy.flatMap({ $0 as? NSButton }).find({ $0.state ==<br>NSOnState })<br></p><p>-Kevin Ballard<br></p><p>On Wed, Feb 17, 2016, at 07:12 AM, Maximilian Hünenberger via swift-evolution wrote:<br>&gt;<br>&gt; I think<br>&gt;<br>&gt; subviews.find{ ($0 as? NSButton)?.state == NSOnState } as? NSButton<br>&gt;<br>&gt; is sufficient and makes it clear that you are searching for a specific<br>&gt; type. Even though you have to cast twice I don&#39;t think an additional<br>&gt; method would be worth its use since it isn&#39;t used as often.<br>&gt;<br>&gt; - Maximilian<br>&gt;<br>&gt; Am 17.02.2016 um 10:32 schrieb Marco Masser via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt;:<br>&gt;&gt; I just saw this PR and have a quick comment about the implementation:<br>&gt;&gt; It could be shortened by a few lines using a where clause like this:<br>&gt;&gt;<br>&gt;&gt; func find(@noescape predicate: Self.Generator.Elementthrows -&gt; Bool)<br>&gt;&gt; rethrows -&gt; Self.Generator.Element? { for element inselfwheretry<br>&gt;&gt; predicate(element) { return element    } returnnil }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Also, I’d like suggest adding a variant that works better with<br>&gt;&gt; heterogenous sequences, but I’ll raise that when this proposal goes<br>&gt;&gt; into review.<br>&gt;&gt;<br>&gt;&gt; FYI: That variant would look like this: func find&lt;T&gt;(_: T.Type,<br>&gt;&gt; @noescape matching predicate: Tthrows -&gt; Bool) rethrows -&gt; T?<br>&gt;&gt;<br>&gt;&gt; A question by me on the swift-users mailing list describes its<br>&gt;&gt; intention, implementation, and usage: [swift-users] Which is the more<br>&gt;&gt; idiomatic approach for pinning down  the type of a generic<br>&gt;&gt; parameter?[1]<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt;<br>&gt;&gt; Marco<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On 2016-01-10, at 01:58, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Proposal PR submitted as<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/pull/94<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Dec 29, 2015, at 06:38 PM, Kevin Ballard wrote:<br>&gt;&gt;&gt;&gt; I&#39;m proposing a new extension method on SequenceType called find().<br>&gt;&gt;&gt;&gt; It&#39;s similar to CollectionType.indexOf() except it returns the<br>&gt;&gt;&gt;&gt; element:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; extensionSequenceType { /// Returns the first element where<br>&gt;&gt;&gt;&gt; `predicate` returns `true`, or `nil` /// if such value is not<br>&gt;&gt;&gt;&gt; found. public func find(@noescape predicate:<br>&gt;&gt;&gt;&gt; (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt;<br>&gt;&gt;&gt;&gt; Self.Generator.Element? { for elt in self { if try predicate(elt) {<br>&gt;&gt;&gt;&gt; return elt            }        } return nil    } }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>Links:<br></p><p>  1. https://lists.swift.org/pipermail/swift-users/Week-of-Mon-20160118/000893.html<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/93248d09/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f1b93037cbc5f78f16450bd925ce3b5b?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Marco Masser</string> &lt;lists at duckcode.com&gt;<p>February 18, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 2016-02-18, at 00:46, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Alternatively you can write<br>&gt;  <br>&gt;     subviews.lazy.flatMap({ $0 as? NSButton }).find({ $0.state == NSOnState })<br></p><p>Just to reiterate my point: I very much prefer the version without any casts. I just think this is much clearer and doesn’t put the burden of thinking about accidental memory and speed overhead (when forgetting the “lazy”) on the caller every time:<br></p><p>subviews.find(NSButton.self, matching: { $0.state == NSOnState })<br></p><p>Also, there’s the goal of Swift being easy to learn. Which line do you think is easier to explain to newcomers?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/c702f3c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>February 18, 2016 at 02:00:00pm</p></header><div class="content"><p>I would prefer a label on the first parameter, since you&#39;re not finding the<br>NSButton type but instead elements having the type of NSButton.<br></p><p>subviews.find(havingType: NSButton.self, matching: { $0.state == NSOnState<br> })<br></p><p>On Thu, Feb 18, 2016 at 4:37 AM, Marco Masser via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 2016-02-18, at 00:46, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Alternatively you can write<br>&gt;<br>&gt;     subviews.lazy.flatMap({ $0 as? NSButton }).find({ $0.state ==<br>&gt; NSOnState })<br>&gt;<br>&gt;<br>&gt; Just to reiterate my point: I very much prefer the version without any<br>&gt; casts. I just think this is much clearer and doesn’t put the burden of<br>&gt; thinking about accidental memory and speed overhead (when forgetting the<br>&gt; “lazy”) on the caller every time:<br>&gt;<br>&gt; subviews.find(NSButton.self, matching: { $0.state == NSOnState })<br>&gt;<br>&gt; Also, there’s the goal of Swift being easy to learn. Which line do you<br>&gt; think is easier to explain to newcomers?<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/ad542308/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 18, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Am 18.02.2016 um 20:36 schrieb Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I would prefer a label on the first parameter, since you&#39;re not finding the NSButton type but instead elements having the type of NSButton.<br>&gt; <br>&gt; subviews.find(havingType: NSButton.self, matching: { $0.state == NSOnState })<br></p><p>To comply with the guidelines I would expect a phrase like<br></p><p>subviews.findElement(havingType: NSButton.self, matching: { $0.state == NSOnState })<br>subviews.find(instanceOf: NSButton.self, matching: { $0.state == NSOnState })<br></p><p>-Thorsten <br></p><p>&gt; <br>&gt;&gt; On Thu, Feb 18, 2016 at 4:37 AM, Marco Masser via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 2016-02-18, at 00:46, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatively you can write<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;     subviews.lazy.flatMap({ $0 as? NSButton }).find({ $0.state == NSOnState })<br>&gt;&gt; <br>&gt;&gt; Just to reiterate my point: I very much prefer the version without any casts. I just think this is much clearer and doesn’t put the burden of thinking about accidental memory and speed overhead (when forgetting the “lazy”) on the caller every time:<br>&gt;&gt; <br>&gt;&gt; subviews.find(NSButton.self, matching: { $0.state == NSOnState })<br>&gt;&gt; <br>&gt;&gt; Also, there’s the goal of Swift being easy to learn. Which line do you think is easier to explain to newcomers?<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/d096b3d7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>February 18, 2016 at 04:00:00pm</p></header><div class="content"><p>Indeed. I quite like the second version.<br></p><p>On Thu, Feb 18, 2016 at 4:01 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br></p><p>&gt;<br>&gt; Am 18.02.2016 um 20:36 schrieb Trent Nadeau via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; I would prefer a label on the first parameter, since you&#39;re not finding<br>&gt; the NSButton type but instead elements having the type of NSButton.<br>&gt;<br>&gt; subviews.find(havingType: NSButton.self, matching: { $0.state == NSOnState<br>&gt;  })<br>&gt;<br>&gt;<br>&gt; To comply with the guidelines I would expect a phrase like<br>&gt;<br>&gt; subviews.findElement(havingType: NSButton.self, matching: { $0.state<br>&gt; == NSOnState })<br>&gt; subviews.find(instanceOf: NSButton.self, matching: { $0.state<br>&gt; == NSOnState })<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt; On Thu, Feb 18, 2016 at 4:37 AM, Marco Masser via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On 2016-02-18, at 00:46, Kevin Ballard via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Alternatively you can write<br>&gt;&gt;<br>&gt;&gt;     subviews.lazy.flatMap({ $0 as? NSButton }).find({ $0.state ==<br>&gt;&gt; NSOnState })<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Just to reiterate my point: I very much prefer the version without any<br>&gt;&gt; casts. I just think this is much clearer and doesn’t put the burden of<br>&gt;&gt; thinking about accidental memory and speed overhead (when forgetting the<br>&gt;&gt; “lazy”) on the caller every time:<br>&gt;&gt;<br>&gt;&gt; subviews.find(NSButton.self, matching: { $0.state == NSOnState })<br>&gt;&gt;<br>&gt;&gt; Also, there’s the goal of Swift being easy to learn. Which line do you<br>&gt;&gt; think is easier to explain to newcomers?<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Trent Nadeau<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/bb308ee1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 18, 2016 at 10:00:00pm</p></header><div class="content"><p>Thanks! The second version is my favorite, too.<br></p><p>-Thorsten <br></p><p>&gt; Am 18.02.2016 um 22:02 schrieb Trent Nadeau &lt;tanadeau at gmail.com&gt;:<br>&gt; <br>&gt; Indeed. I quite like the second version.<br>&gt; <br>&gt;&gt; On Thu, Feb 18, 2016 at 4:01 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Am 18.02.2016 um 20:36 schrieb Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would prefer a label on the first parameter, since you&#39;re not finding the NSButton type but instead elements having the type of NSButton.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; subviews.find(havingType: NSButton.self, matching: { $0.state == NSOnState })<br>&gt;&gt; <br>&gt;&gt; To comply with the guidelines I would expect a phrase like<br>&gt;&gt; <br>&gt;&gt; subviews.findElement(havingType: NSButton.self, matching: { $0.state == NSOnState })<br>&gt;&gt; subviews.find(instanceOf: NSButton.self, matching: { $0.state == NSOnState })<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, Feb 18, 2016 at 4:37 AM, Marco Masser via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 2016-02-18, at 00:46, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Alternatively you can write<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;     subviews.lazy.flatMap({ $0 as? NSButton }).find({ $0.state == NSOnState })<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just to reiterate my point: I very much prefer the version without any casts. I just think this is much clearer and doesn’t put the burden of thinking about accidental memory and speed overhead (when forgetting the “lazy”) on the caller every time:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; subviews.find(NSButton.self, matching: { $0.state == NSOnState })<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, there’s the goal of Swift being easy to learn. Which line do you think is easier to explain to newcomers?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Trent Nadeau<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/688c04b7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f1b93037cbc5f78f16450bd925ce3b5b?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Marco Masser</string> &lt;lists at duckcode.com&gt;<p>February 19, 2016 at 10:00:00am</p></header><div class="content"><p>Yep, you are right. That looks better.<br></p><p>&gt; On 2016-02-18, at 22:02, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; <br>&gt; Indeed. I quite like the second version.<br>&gt; <br>&gt; On Thu, Feb 18, 2016 at 4:01 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt; <br>&gt; Am 18.02.2016 um 20:36 schrieb Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; I would prefer a label on the first parameter, since you&#39;re not finding the NSButton type but instead elements having the type of NSButton.<br>&gt;&gt; <br>&gt;&gt; subviews.find(havingType: NSButton.self, matching: { $0.state == NSOnState })<br>&gt; <br>&gt; To comply with the guidelines I would expect a phrase like<br>&gt; <br>&gt; subviews.findElement(havingType: NSButton.self, matching: { $0.state == NSOnState })<br>&gt; subviews.find(instanceOf: NSButton.self, matching: { $0.state == NSOnState })<br>&gt; <br>&gt; -Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/ba0b7a3d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>February 18, 2016 at 02:00:00pm</p></header><div class="content"><p>A version specifically for dealing with downcasts seems very special purpose to this particular use case, especially when you can just use flatMap.<br></p><p>-DW<br></p><p>&gt; On Feb 18, 2016, at 2:01 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Am 18.02.2016 um 20:36 schrieb Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; I would prefer a label on the first parameter, since you&#39;re not finding the NSButton type but instead elements having the type of NSButton.<br>&gt;&gt; <br>&gt;&gt; subviews.find(havingType: NSButton.self, matching: { $0.state == NSOnState })<br>&gt; <br>&gt; To comply with the guidelines I would expect a phrase like<br>&gt; <br>&gt; subviews.findElement(havingType: NSButton.self, matching: { $0.state == NSOnState })<br>&gt; subviews.find(instanceOf: NSButton.self, matching: { $0.state == NSOnState })<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Thu, Feb 18, 2016 at 4:37 AM, Marco Masser via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 2016-02-18, at 00:46, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatively you can write<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     subviews.lazy.flatMap({ $0 as? NSButton }).find({ $0.state == NSOnState })<br>&gt;&gt; <br>&gt;&gt; Just to reiterate my point: I very much prefer the version without any casts. I just think this is much clearer and doesn’t put the burden of thinking about accidental memory and speed overhead (when forgetting the “lazy”) on the caller every time:<br>&gt;&gt; <br>&gt;&gt; subviews.find(NSButton.self, matching: { $0.state == NSOnState })<br>&gt;&gt; <br>&gt;&gt; Also, there’s the goal of Swift being easy to learn. Which line do you think is easier to explain to newcomers?<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Trent Nadeau<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/0ac950f2/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/0ac950f2/attachment.sig&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 18, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt; I would prefer a label on the first parameter, since you&#39;re not finding the NSButton type but instead elements having the type of NSButton.<br>&gt;&gt; <br>&gt;&gt; subviews.find(havingType: NSButton.self, matching: { $0.state == NSOnState })<br>&gt; <br>&gt; To comply with the guidelines I would expect a phrase like<br>&gt; <br>&gt; subviews.findElement(havingType: NSButton.self, matching: { $0.state == NSOnState })<br>&gt; subviews.find(instanceOf: NSButton.self, matching: { $0.state == NSOnState })<br></p><p>A funny thing just happened—I was writing some Swift, needed something like `find`, remembered this thread, copied it in, andt ehn realized I wanted to find-and-cast at the same time. Here&#39;s what I ended up doing:<br></p><p>extension SequenceType {<br>    func find&lt;U&gt;(@noescape finder: Generator.Element throws -&gt; U?) rethrows -&gt; U? {<br>        for elem in self {<br>            if let returnValue = try finder(elem) {<br>                return returnValue<br>            }<br>        }<br>        return nil<br>    }<br>    <br>    func find(@noescape predicate: Generator.Element throws -&gt; Bool) rethrows -&gt; Generator.Element? {<br>        return try find { try predicate($0) ? $0 : nil }<br>    }<br>}<br></p><p>Then the code that used it ended up being:<br></p><p>        var bitmap = representations.find { $0 as? NSBitmapImageRep } ?? makeNormalizedBitmapRep()<br></p><p>Which I think is about as nice as I could&#39;ve hoped for.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f1b93037cbc5f78f16450bd925ce3b5b?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Marco Masser</string> &lt;lists at duckcode.com&gt;<p>February 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 2016-02-18, at 23:13, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A funny thing just happened—I was writing some Swift, needed something like `find`, remembered this thread, copied it in, andt ehn realized I wanted to find-and-cast at the same time. Here&#39;s what I ended up doing:<br>&gt; <br>&gt; extension SequenceType {<br>&gt;    func find&lt;U&gt;(@noescape finder: Generator.Element throws -&gt; U?) rethrows -&gt; U? {<br>&gt;        for elem in self {<br>&gt;            if let returnValue = try finder(elem) {<br>&gt;                return returnValue<br>&gt;            }<br>&gt;        }<br>&gt;        return nil<br>&gt;    }<br>&gt; <br>&gt;    func find(@noescape predicate: Generator.Element throws -&gt; Bool) rethrows -&gt; Generator.Element? {<br>&gt;        return try find { try predicate($0) ? $0 : nil }<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; Then the code that used it ended up being:<br>&gt; <br>&gt;        var bitmap = representations.find { $0 as? NSBitmapImageRep } ?? makeNormalizedBitmapRep()<br>&gt; <br>&gt; Which I think is about as nice as I could&#39;ve hoped for.<br></p><p>If I’m not mistaken, this works OK as long as you only want to find something of a specific type. Maybe I’m missing something here, but to add some kind of predicate (e.g. checking for bitsPerPixel == 8), this would lead to code like this:<br></p><p>var bitmap: NSBitmapImageRep? = representations.find {<br>    if let bitmap = $0 as? NSBitmapImageRep where bitmap.bitsPerPixel == 8 {<br>        return bitmap<br>    }<br>    return nil<br>} ?? makeNormalizedBitmapRep()<br></p><p><br>… whereas my original version would look like this:<br></p><p>var bitmap = representations.find(NSBitmapImageRep.self) { $0.bitsPerPixel == 8 } ?? makeNormalizedBitmapRep()<br></p><p><br>The point of my proposed method is to filter for a *subtype* of Generator.Element and apply a given predicate only to those that match that subtype, then return the an instance of that subtype or nil.<br></p><p>Again, maybe I’m missing something here?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/daa84f25/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f1b93037cbc5f78f16450bd925ce3b5b?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Marco Masser</string> &lt;lists at duckcode.com&gt;<p>February 18, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 2016-02-17, at 16:12, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt; <br>&gt; I think<br>&gt; <br>&gt;         subviews.find{ ($0 as? NSButton)?.state == NSOnState } as? NSButton<br>&gt; <br>&gt; is sufficient and makes it clear that you are searching for a specific type. Even though you have to cast twice I don&#39;t think an additional method would be worth its use since it isn&#39;t used as often.<br></p><p>While I very much prefer the version without any casts, I suspect that you’re right in that the consensus will probably be that adding an additional method for heterogenous sequences will be considered not to be worthwhile. But maybe I’m wrong and if not, I can still keep my own implementation.<br></p><p>Cheers,<br></p><p>Marco<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>Proposal: Add function SequenceType.find()</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February 17, 2016 at 10:00:00pm</p></header><div class="content"><p>+1. Like others, this was one of the first stdlib extensions I’ve put into my Swift projects. It’s very common to want to find the first matching element in an array (or, perhaps even more common, find what you know if the only matching element — `filter` without the extra step of unpacking the value from array.)<br></p><p>It’s also common in other languages, and `find` is a good name.<br></p><p>— Radek<br></p><p>&gt; On 30 Dec 2015, at 03:38, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m proposing a new extension method on SequenceType called find(). It&#39;s similar to CollectionType.indexOf() except it returns the element:<br>&gt;  <br>&gt; extension SequenceType {<br>&gt;     /// Returns the first element where `predicate` returns `true`, or `nil`<br>&gt;     /// if such value is not found.<br>&gt;     public func find(@noescape predicate: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.Generator.Element? {<br>&gt;         for elt in self {<br>&gt;             if try predicate(elt) {<br>&gt;                 return elt<br>&gt;             }<br>&gt;         }<br>&gt;         return nil<br>&gt;     }<br>&gt; }<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/748e02f7/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
