<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9196b648a4f24597e0423bda1db0e50b?s=50"></div><header><strong>Every non-trivial Swift function should throw, right?</strong> from <string>John Spurlock</string> &lt;john.spurlock at gmail.com&gt;<p>March  3, 2016 at 11:00:00am</p></header><div class="content"><p>&quot;so pretty much every non-trivial #swift function should throw, right?<br> cheap &amp; gives caller choice to catch, rethrow, try? or try!  (4 in 1)&quot;<br>-- https://twitter.com/johnspurlock/status/704478619779866625<br></p><p>One of the annoying things about checked exceptions in other languages is<br>that they somewhat dictate client behavior wrt error handling and flow.<br>Also expensive (for some value of expensive) when they occur, so not a good<br>choice for standard-case control flow.<br></p><p>Given that Swift provides multiple language-standard ways for clients to<br>deal with a function marked as &#39;throws&#39;, it seems like almost all<br>non-trivial shared functions should provide the additional information of<br>the error in that standard form, instead of hiding it behind an optional<br>return type or a bespoke error callback argument.<br></p><p>i.e. always:  func parse(str: String) throws -&gt; Foo<br>instead of: func parse(str: String) -&gt; Foo?    // loss of information: why<br>did it fail?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160303/31ddc355/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Every non-trivial Swift function should throw, right?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  5, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; &quot;so pretty much every non-trivial #swift function should throw, right?  cheap &amp; gives caller choice to catch, rethrow, try? or try!  (4 in 1)&quot;<br>&gt; -- https://twitter.com/johnspurlock/status/704478619779866625<br>&gt; <br>&gt; [snip]<br>&gt; <br>&gt; Given that Swift provides multiple language-standard ways for clients to deal with a function marked as &#39;throws&#39;, it seems like almost all non-trivial shared functions should provide the additional information of the error in that standard form, instead of hiding it behind an optional return type<br></p><p>No, I don&#39;t think so.<br></p><p>First of all, there are functions which I can&#39;t imagine describing as trivial, but which nonetheless cannot fail except by programmer error. For instance, sorting can only fail if you provide a comparator which doesn&#39;t work properly (by, for instance, saying that both `a &lt; b` and `b &lt; a` are true). There is no error reporting needed at all for sorting, because the only possible errors are outright mistakes by the programmer. Those should be handled with preconditions, and the function itself should not signal the possibility of an error in any way at all.<br></p><p>Secondly, there are functions which can only fail in a single, obvious way. For instance, the `indexOf(_:)` method can only fail by reaching the end of the Collection without finding an element matching its parameter. It could indicate this by throwing a CollectionError.NoMatch error, but that would be overkill; it&#39;s far easier to return an optional Int, with `nil` meaning &quot;no match&quot;.<br></p><p>Of course, the line between what should be optional and what should be a thrown error is necessarily subjective. Should `Int.init(_: String, radix: Int = 10)` be throwing or optional? On the one hand, all possible errors boil down to one: &quot;you passed a string that isn&#39;t a number&quot;. On the other, in some contexts it might be helpful to know the problem is &quot;there&#39;s a space at character offset X&quot;.<br></p><p>But the solution to this tension cannot and should not simply be &quot;always use the most heavyweight error handling mechanism available&quot;. That is the answer many languages offer, and we&#39;ve all seen where it leads.<br></p><p>Here are my rules of thumb:<br></p><p>• If the error should never happen unless the programmer makes a mistake, use a precondition.<br></p><p>• If there is only one way the error can be caused (or there is rarely any useful way for callers to respond to different causes differently), AND error conditions are so common that the error code paths ought to be given just as much weight as the success code paths, use an optional (or a boolean).<br></p><p>• For everything else, use thrown errors. That is, errors which are neither impossible in well-written code, nor so common as to be equally likely as successes *and* without useful distinctions from one another, should be thrown.<br></p><p>These rules are not purely mechanical; they require judgement from the API&#39;s designers and embed opinions about uses which may inconvenience some callers. But there&#39;s simply no way around that—the best APIs are almost always opinionated ones.<br></p><p>&gt; or a bespoke error callback argument.<br></p><p><br>This is worth discussing separately.<br></p><p>I assume that you mean passing a closure to handle either success or failure. That&#39;s usually only done with asynchronous operations, which by necessity *must* communicate their result through a callback, so neither returning an optional nor throwing an error is available.<br></p><p>However, we have conventional equivalents of both, which are used in the same cases. The equivalent of returning an optional/boolean is passing a single optional/boolean to the completion, and the equivalent of throwing is passing both an optional/boolean and an optional error to the completion. The throwing equivalent could be expressed a little more cleanly if we had a Result/Either type in the standard library, but we currently don&#39;t, so we can&#39;t.<br></p><p>Some developers prefer to pass separate success and failure closures. I&#39;ve never been a fan of this approach except when writing functional-style APIs on a type like Result, where you can use it to arbitrarily chain operations together. Otherwise I think it fights the language—for instance, it&#39;s not compatible with trailing closure syntax.<br></p><p>I have high hopes that a future version of Swift will either formalize the success/failure pattern in callbacks, or provide some way to avoid having to write callbacks explicitly, just as Swift 2 formalized the old &quot;return optional and have an error out parameter&quot; pattern into the current throwing system. But we&#39;re not there yet and we won&#39;t be until at least Swift 4, so until then, we&#39;ll have to make do with awkward multiple-parameter patterns.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Every non-trivial Swift function should throw, right?</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  5, 2016 at 07:00:00pm</p></header><div class="content"><p>I&#39;m hopping in here ridiculously late, but wasn&#39;t someone going to propose a vanilla universal stdlib error type along the lines of<br></p><p>struct Error: ErrorType {<br>   let reason: String<br>}<br></p><p>(preferably with auto-captured location context (http://ericasadun.com/2015/08/27/capturing-context-swiftlang/ &lt;http://ericasadun.com/2015/08/27/capturing-context-swiftlang/&gt;) and a custom mutable dictionary.)<br></p><p>-- Erica<br></p><p><br></p><p>&gt; On Mar 5, 2016, at 5:59 PM, Brent Royal-Gordon via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; &quot;so pretty much every non-trivial #swift function should throw, right?  cheap &amp; gives caller choice to catch, rethrow, try? or try!  (4 in 1)&quot;<br>&gt;&gt; -- https://twitter.com/johnspurlock/status/704478619779866625<br>&gt;&gt; <br>&gt;&gt; [snip]<br>&gt;&gt; <br>&gt;&gt; Given that Swift provides multiple language-standard ways for clients to deal with a function marked as &#39;throws&#39;, it seems like almost all non-trivial shared functions should provide the additional information of the error in that standard form, instead of hiding it behind an optional return type<br>&gt; <br>&gt; No, I don&#39;t think so.<br>&gt; <br>&gt; First of all, there are functions which I can&#39;t imagine describing as trivial, but which nonetheless cannot fail except by programmer error. For instance, sorting can only fail if you provide a comparator which doesn&#39;t work properly (by, for instance, saying that both `a &lt; b` and `b &lt; a` are true). There is no error reporting needed at all for sorting, because the only possible errors are outright mistakes by the programmer. Those should be handled with preconditions, and the function itself should not signal the possibility of an error in any way at all.<br>&gt; <br></p><p>... etc<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160305/3af66ac1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Every non-trivial Swift function should throw, right?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March  7, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Mar 5, 2016, at 16:59, Brent Royal-Gordon via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; &quot;so pretty much every non-trivial #swift function should throw, right?  cheap &amp; gives caller choice to catch, rethrow, try? or try!  (4 in 1)&quot;<br>&gt;&gt; -- https://twitter.com/johnspurlock/status/704478619779866625<br>&gt;&gt; <br>&gt;&gt; [snip]<br>&gt;&gt; <br>&gt;&gt; Given that Swift provides multiple language-standard ways for clients to deal with a function marked as &#39;throws&#39;, it seems like almost all non-trivial shared functions should provide the additional information of the error in that standard form, instead of hiding it behind an optional return type<br>&gt; <br>&gt; No, I don&#39;t think so.<br>&gt; <br>&gt; First of all, there are functions which I can&#39;t imagine describing as trivial, but which nonetheless cannot fail except by programmer error. For instance, sorting can only fail if you provide a comparator which doesn&#39;t work properly (by, for instance, saying that both `a &lt; b` and `b &lt; a` are true). There is no error reporting needed at all for sorting, because the only possible errors are outright mistakes by the programmer. Those should be handled with preconditions, and the function itself should not signal the possibility of an error in any way at all.<br>&gt; <br>&gt; Secondly, there are functions which can only fail in a single, obvious way. For instance, the `indexOf(_:)` method can only fail by reaching the end of the Collection without finding an element matching its parameter. It could indicate this by throwing a CollectionError.NoMatch error, but that would be overkill; it&#39;s far easier to return an optional Int, with `nil` meaning &quot;no match&quot;.<br>&gt; <br>&gt; Of course, the line between what should be optional and what should be a thrown error is necessarily subjective. Should `Int.init(_: String, radix: Int = 10)` be throwing or optional? On the one hand, all possible errors boil down to one: &quot;you passed a string that isn&#39;t a number&quot;. On the other, in some contexts it might be helpful to know the problem is &quot;there&#39;s a space at character offset X&quot;.<br>&gt; <br>&gt; But the solution to this tension cannot and should not simply be &quot;always use the most heavyweight error handling mechanism available&quot;. That is the answer many languages offer, and we&#39;ve all seen where it leads.<br>&gt; <br>&gt; Here are my rules of thumb:<br>&gt; <br>&gt; • If the error should never happen unless the programmer makes a mistake, use a precondition.<br>&gt; <br>&gt; • If there is only one way the error can be caused (or there is rarely any useful way for callers to respond to different causes differently), AND error conditions are so common that the error code paths ought to be given just as much weight as the success code paths, use an optional (or a boolean).<br>&gt; <br>&gt; • For everything else, use thrown errors. That is, errors which are neither impossible in well-written code, nor so common as to be equally likely as successes *and* without useful distinctions from one another, should be thrown.<br>&gt; <br>&gt; These rules are not purely mechanical; they require judgement from the API&#39;s designers and embed opinions about uses which may inconvenience some callers. But there&#39;s simply no way around that—the best APIs are almost always opinionated ones.<br>&gt; <br>&gt;&gt; or a bespoke error callback argument.<br>&gt; <br>&gt; <br>&gt; This is worth discussing separately.<br>&gt; <br>&gt; I assume that you mean passing a closure to handle either success or failure. That&#39;s usually only done with asynchronous operations, which by necessity *must* communicate their result through a callback, so neither returning an optional nor throwing an error is available.<br>&gt; <br>&gt; However, we have conventional equivalents of both, which are used in the same cases. The equivalent of returning an optional/boolean is passing a single optional/boolean to the completion, and the equivalent of throwing is passing both an optional/boolean and an optional error to the completion. The throwing equivalent could be expressed a little more cleanly if we had a Result/Either type in the standard library, but we currently don&#39;t, so we can&#39;t.<br>&gt; <br>&gt; Some developers prefer to pass separate success and failure closures. I&#39;ve never been a fan of this approach except when writing functional-style APIs on a type like Result, where you can use it to arbitrarily chain operations together. Otherwise I think it fights the language—for instance, it&#39;s not compatible with trailing closure syntax.<br>&gt; <br>&gt; I have high hopes that a future version of Swift will either formalize the success/failure pattern in callbacks, or provide some way to avoid having to write callbacks explicitly, just as Swift 2 formalized the old &quot;return optional and have an error out parameter&quot; pattern into the current throwing system. But we&#39;re not there yet and we won&#39;t be until at least Swift 4, so until then, we&#39;ll have to make do with awkward multiple-parameter patterns.<br></p><p>There&#39;s some more expansion on different kinds of errors and the Swift model both in last year&#39;s WWDC presentation &lt;https://developer.apple.com/videos/play/wwdc2015/106/?time=1816&gt; (look for &quot;There are really three different ways that functions can fail&quot;) and in the internal docs &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandling.rst&gt; in the Swift repo. (And again with more detail in the original &quot;rationale&quot; doc &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt;.)<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160307/c6de6c46/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Every non-trivial Swift function should throw, right?</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>March  7, 2016 at 11:00:00pm</p></header><div class="content"><p>There is a proposal which is aiming to tackle a small subset of these issues<br></p><p>https://github.com/apple/swift-evolution/pull/196<br></p><p>*___________________________________*<br></p><p>*James⎥Head of Trolls*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Mon, Mar 7, 2016 at 9:44 PM, Jordan Rose via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Mar 5, 2016, at 16:59, Brent Royal-Gordon via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; &quot;so pretty much every non-trivial #swift function should throw, right?<br>&gt;  cheap &amp; gives caller choice to catch, rethrow, try? or try!  (4 in 1)&quot;<br>&gt; -- https://twitter.com/johnspurlock/status/704478619779866625<br>&gt;<br>&gt; [snip]<br>&gt;<br>&gt; Given that Swift provides multiple language-standard ways for clients to<br>&gt; deal with a function marked as &#39;throws&#39;, it seems like almost all<br>&gt; non-trivial shared functions should provide the additional information of<br>&gt; the error in that standard form, instead of hiding it behind an optional<br>&gt; return type<br>&gt;<br>&gt;<br>&gt; No, I don&#39;t think so.<br>&gt;<br>&gt; First of all, there are functions which I can&#39;t imagine describing as<br>&gt; trivial, but which nonetheless cannot fail except by programmer error. For<br>&gt; instance, sorting can only fail if you provide a comparator which doesn&#39;t<br>&gt; work properly (by, for instance, saying that both `a &lt; b` and `b &lt; a` are<br>&gt; true). There is no error reporting needed at all for sorting, because the<br>&gt; only possible errors are outright mistakes by the programmer. Those should<br>&gt; be handled with preconditions, and the function itself should not signal<br>&gt; the possibility of an error in any way at all.<br>&gt;<br>&gt; Secondly, there are functions which can only fail in a single, obvious<br>&gt; way. For instance, the `indexOf(_:)` method can only fail by reaching the<br>&gt; end of the Collection without finding an element matching its parameter. It<br>&gt; could indicate this by throwing a CollectionError.NoMatch error, but that<br>&gt; would be overkill; it&#39;s far easier to return an optional Int, with `nil`<br>&gt; meaning &quot;no match&quot;.<br>&gt;<br>&gt; Of course, the line between what should be optional and what should be a<br>&gt; thrown error is necessarily subjective. Should `Int.init(_: String, radix:<br>&gt; Int = 10)` be throwing or optional? On the one hand, all possible errors<br>&gt; boil down to one: &quot;you passed a string that isn&#39;t a number&quot;. On the other,<br>&gt; in some contexts it might be helpful to know the problem is &quot;there&#39;s a<br>&gt; space at character offset X&quot;.<br>&gt;<br>&gt; But the solution to this tension cannot and should not simply be &quot;always<br>&gt; use the most heavyweight error handling mechanism available&quot;. That is the<br>&gt; answer many languages offer, and we&#39;ve all seen where it leads.<br>&gt;<br>&gt; Here are my rules of thumb:<br>&gt;<br>&gt; • If the error should never happen unless the programmer makes a mistake,<br>&gt; use a precondition.<br>&gt;<br>&gt; • If there is only one way the error can be caused (or there is rarely any<br>&gt; useful way for callers to respond to different causes differently), AND<br>&gt; error conditions are so common that the error code paths ought to be given<br>&gt; just as much weight as the success code paths, use an optional (or a<br>&gt; boolean).<br>&gt;<br>&gt; • For everything else, use thrown errors. That is, errors which are<br>&gt; neither impossible in well-written code, nor so common as to be equally<br>&gt; likely as successes *and* without useful distinctions from one another,<br>&gt; should be thrown.<br>&gt;<br>&gt; These rules are not purely mechanical; they require judgement from the<br>&gt; API&#39;s designers and embed opinions about uses which may inconvenience some<br>&gt; callers. But there&#39;s simply no way around that—the best APIs are almost<br>&gt; always opinionated ones.<br>&gt;<br>&gt; or a bespoke error callback argument.<br>&gt;<br>&gt;<br>&gt;<br>&gt; This is worth discussing separately.<br>&gt;<br>&gt; I assume that you mean passing a closure to handle either success or<br>&gt; failure. That&#39;s usually only done with asynchronous operations, which by<br>&gt; necessity *must* communicate their result through a callback, so neither<br>&gt; returning an optional nor throwing an error is available.<br>&gt;<br>&gt; However, we have conventional equivalents of both, which are used in the<br>&gt; same cases. The equivalent of returning an optional/boolean is passing a<br>&gt; single optional/boolean to the completion, and the equivalent of throwing<br>&gt; is passing both an optional/boolean and an optional error to the<br>&gt; completion. The throwing equivalent could be expressed a little more<br>&gt; cleanly if we had a Result/Either type in the standard library, but we<br>&gt; currently don&#39;t, so we can&#39;t.<br>&gt;<br>&gt; Some developers prefer to pass separate success and failure closures. I&#39;ve<br>&gt; never been a fan of this approach except when writing functional-style APIs<br>&gt; on a type like Result, where you can use it to arbitrarily chain operations<br>&gt; together. Otherwise I think it fights the language—for instance, it&#39;s not<br>&gt; compatible with trailing closure syntax.<br>&gt;<br>&gt; I have high hopes that a future version of Swift will either formalize the<br>&gt; success/failure pattern in callbacks, or provide some way to avoid having<br>&gt; to write callbacks explicitly, just as Swift 2 formalized the old &quot;return<br>&gt; optional and have an error out parameter&quot; pattern into the current throwing<br>&gt; system. But we&#39;re not there yet and we won&#39;t be until at least Swift 4, so<br>&gt; until then, we&#39;ll have to make do with awkward multiple-parameter patterns.<br>&gt;<br>&gt;<br>&gt; There&#39;s some more expansion on different kinds of errors and the Swift<br>&gt; model both in last year&#39;s WWDC presentation<br>&gt; &lt;https://developer.apple.com/videos/play/wwdc2015/106/?time=1816&gt; (look<br>&gt; for &quot;There are really three different ways that functions can fail&quot;) and in<br>&gt; the internal docs<br>&gt; &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandling.rst&gt; in<br>&gt; the Swift repo. (And again with more detail in the original &quot;rationale&quot;<br>&gt; doc<br>&gt; &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt;<br>&gt; .)<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160307/219343e2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9196b648a4f24597e0423bda1db0e50b?s=50"></div><header><strong>Every non-trivial Swift function should throw, right?</strong> from <string>John Spurlock</string> &lt;john.spurlock at gmail.com&gt;<p>March  8, 2016 at 12:00:00pm</p></header><div class="content"><p>The error handling rationale document [1] is an excellent review, thanks.<br></p><p>If you are going to consider optional returns as appropriate for a<br>certain class of errors, that class needs to be crystal clear - and<br>enforceable/hinted-at by the compiler.  Java and C# exception<br>hierarchies have rationale, but end-users don&#39;t read documentation.<br>Since they can only be minimally enforced by the type system, it has<br>turned out to be a free-for-all.<br></p><p>Too bad Result&lt;T&gt; does not exist!  The Result handling flow looks<br>depressingly familiar (as mentioned above), it&#39;s just as tedious and<br>error-prone to do by hand as C/Go-style error checking, so it&#39;s weird<br>that the current error system does not have first-class support for<br>them under the same rationale.<br></p><p>Perhaps Optional&lt;T&gt; and Result&lt;T&gt; would be best thought of as<br>fundamentally related in some way, and have a similar protocol/shape<br>called Either&lt;T,Or&gt; where Or is nil for optionals and<br>ErrorType/NSError for results.  Or consider optionals an error of a<br>certain kind for simplicity.<br></p><p>[1] https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst<br></p><p>&gt;  (And again with more detail in the original &quot;rationale&quot; doc.)<br>&gt;<br>&gt; Jordan<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
