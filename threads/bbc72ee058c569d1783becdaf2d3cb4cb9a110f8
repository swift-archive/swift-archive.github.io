<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>April 11, 2016 at 01:00:00pm</p></header><div class="content"><p>This proposal seeks to provide a safer ..&lt; (aka half-open range operator)<br>in order to avoid **Array index out of range** errors in execution time.<br></p><p>Here is my first draft for this proposal:<br>https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br></p><p>In short, doing that in Swift causes a runtime error:<br></p><p>let a = [1,2,3]<br>let b = a[0..&lt;5]<br>print(b)<br></p><p>&gt; Error running code:<br>&gt; fatal error: Array index out of range<br></p><p>The proposed solution is to slice the array returning all elements that are<br>below the half-open operator, even though the number of elements is lesser<br>than the ending of the half-open operator. So the example above would<br>return [1,2,3].<br>We can see this very behaviour in other languages, such as Python and Ruby<br>as shown in the proposal draft.<br></p><p>This would eliminate the need for verifications on the array size before<br>slicing it -- and consequently runtime errors in cases when the programmer<br>didn&#39;t.<br></p><p>Viewing that it is my very first proposal, any feedback will be helpful.<br>Thanks!<br></p><p>Luis Henrique Borges<br>@luishborges<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/bbc710f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 11, 2016 at 03:00:00pm</p></header><div class="content"><p>I like the idea in theory, but the question is; is it really safer to return a result that the developer may not have wanted, versus an error indicating that a mistake may have been made? I wonder if perhaps there could be an alternative, such as a variation of the operator like so:<br></p><p>	let b = a [0 &amp;..&lt; 5]	// Equivalent to let b = a[0 ..&lt; min(5, a.endIndex)], becomes let b = a[0 ..&lt; 3]<br></p><p>I’m just not sure that we can assume that an array index out of range error is okay without some kind of indication from the developer, as otherwise we could end up returning a partial slice, which could end up causing an error elsewhere where the size of the slice is assumed to be 5 but isn’t.<br></p><p>&gt; On 11 Apr 2016, at 13:23, Luis Henrique B. Sousa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This proposal seeks to provide a safer ..&lt; (aka half-open range operator) in order to avoid **Array index out of range** errors in execution time.<br>&gt; <br>&gt; Here is my first draft for this proposal: https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md &lt;https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md&gt;<br>&gt; <br>&gt; In short, doing that in Swift causes a runtime error:<br>&gt; let a = [1,2,3]<br>&gt; let b = a[0..&lt;5]<br>&gt; print(b)<br>&gt; <br>&gt; &gt; Error running code: <br>&gt; &gt; fatal error: Array index out of range<br>&gt; <br>&gt; The proposed solution is to slice the array returning all elements that are below the half-open operator, even though the number of elements is lesser than the ending of the half-open operator. So the example above would return [1,2,3]. <br>&gt; We can see this very behaviour in other languages, such as Python and Ruby as shown in the proposal draft.<br>&gt; <br>&gt; This would eliminate the need for verifications on the array size before slicing it -- and consequently runtime errors in cases when the programmer didn&#39;t. <br>&gt; <br>&gt; Viewing that it is my very first proposal, any feedback will be helpful.<br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt; Luis Henrique Borges<br>&gt; @luishborges<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/80436af3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 11, 2016 at 06:00:00pm</p></header><div class="content"><p>+1 for the idea &quot;in general&quot;. But I also think that explicit is better than <br>implicit, especially if we deal with possible errors. Just like we work in <br>Swift with integer overflow : &#39;+&#39; will generate run time error, but saying <br>&amp;+ we point Swift that we know what we do.<br></p><p>but.. what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise error or <br>become [0 ..&lt; 3] ? I think, the latter.<br></p><p>On 11.04.2016 17:02, Haravikk via swift-evolution wrote:<br>&gt; I like the idea in theory, but the question is; is it really safer to<br>&gt; return a result that the developer may not have wanted, versus an error<br>&gt; indicating that a mistake may have been made? I wonder if perhaps there<br>&gt; could be an alternative, such as a variation of the operator like so:<br>&gt;<br>&gt; let b = a [0 &amp;..&lt; 5]// Equivalent to let b = a[0 ..&lt; min(5, a.endIndex)],<br>&gt; becomes let b = a[0 ..&lt; 3]<br>&gt;<br>&gt; I’m just not sure that we can assume that an array index out of range error<br>&gt; is okay without some kind of indication from the developer, as otherwise we<br>&gt; could end up returning a partial slice, which could end up causing an error<br>&gt; elsewhere where the size of the slice is assumed to be 5 but isn’t.<br>&gt;<br>&gt;&gt; On 11 Apr 2016, at 13:23, Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; This proposal seeks to provide a safer ..&lt; (aka half-open range operator)<br>&gt;&gt; in order to avoid **Array index out of range** errors in execution time.<br>&gt;&gt;<br>&gt;&gt; Here is my first draft for this proposal:<br>&gt;&gt; https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;<br>&gt;&gt; In short, doing that in Swift causes a runtime error:<br>&gt;&gt;<br>&gt;&gt; leta =[1,2,3]<br>&gt;&gt; letb =a[0..&lt;5]<br>&gt;&gt; print(b)<br>&gt;&gt;<br>&gt;&gt; &gt; Error running code:<br>&gt;&gt; &gt; fatal error: Array index out of range<br>&gt;&gt;<br>&gt;&gt; The proposed solution is to slice the array returning all elements that<br>&gt;&gt; are below the half-open operator, even though the number of elements is<br>&gt;&gt; lesser than the ending of the half-open operator. So the example above<br>&gt;&gt; would return [1,2,3].<br>&gt;&gt; We can see this very behaviour in other languages, such as Python and<br>&gt;&gt; Ruby as shown in the proposal draft.<br>&gt;&gt;<br>&gt;&gt; This would eliminate the need for verifications on the array size before<br>&gt;&gt; slicing it -- and consequently runtime errors in cases when the<br>&gt;&gt; programmer didn&#39;t.<br>&gt;&gt;<br>&gt;&gt; Viewing that it is my very first proposal, any feedback will be helpful.<br>&gt;&gt;<br>&gt;&gt; Thanks!<br>&gt;&gt;<br>&gt;&gt; Luis Henrique Borges<br>&gt;&gt; @luishborges<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>April 12, 2016 at 12:00:00am</p></header><div class="content"><p>The idea of having a new operator following the principles of overflow<br>operators looks great. Two distinct operators doing implicit and explicitly<br>might really be a good way to go; it would be concise and wouldn&#39;t look<br>like some magic happened behind the scenes. I&#39;d like to hear more opinions<br>about it.<br></p><p>&gt; what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise error or become<br>[0 ..&lt; 3] ? I think, the latter.<br>I agree here, I&#39;d choose the latter.<br></p><p>&gt;From my perspective, the behaviour I&#39;m proposing is what a considerable<br>number of users expect, especially if coming from other languages that<br>follow that path. Of course I&#39;m not comparing languages here, but<br>considering the Swift principles of being a safer language, in my opinion<br>we&#39;d rather have a partial slice than a crash in execution time (when the<br>user is not totally aware of it).<br></p><p>Many thanks for all your additions so far. It&#39;s really good to see that<br>these things are not set in stone yet.<br></p><p>- Luis<br>On Apr 11, 2016 4:21 PM, &quot;Vladimir.S via swift-evolution&quot; &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 for the idea &quot;in general&quot;. But I also think that explicit is better<br>&gt; than implicit, especially if we deal with possible errors. Just like we<br>&gt; work in Swift with integer overflow : &#39;+&#39; will generate run time error, but<br>&gt; saying &amp;+ we point Swift that we know what we do.<br>&gt;<br>&gt; but.. what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise error or<br>&gt; become [0 ..&lt; 3] ? I think, the latter.<br>&gt;<br>&gt; On 11.04.2016 17:02, Haravikk via swift-evolution wrote:<br>&gt;<br>&gt;&gt; I like the idea in theory, but the question is; is it really safer to<br>&gt;&gt; return a result that the developer may not have wanted, versus an error<br>&gt;&gt; indicating that a mistake may have been made? I wonder if perhaps there<br>&gt;&gt; could be an alternative, such as a variation of the operator like so:<br>&gt;&gt;<br>&gt;&gt; let b = a [0 &amp;..&lt; 5]// Equivalent to let b = a[0 ..&lt; min(5, a.endIndex)],<br>&gt;&gt; becomes let b = a[0 ..&lt; 3]<br>&gt;&gt;<br>&gt;&gt; I’m just not sure that we can assume that an array index out of range<br>&gt;&gt; error<br>&gt;&gt; is okay without some kind of indication from the developer, as otherwise<br>&gt;&gt; we<br>&gt;&gt; could end up returning a partial slice, which could end up causing an<br>&gt;&gt; error<br>&gt;&gt; elsewhere where the size of the slice is assumed to be 5 but isn’t.<br>&gt;&gt;<br>&gt;&gt; On 11 Apr 2016, at 13:23, Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This proposal seeks to provide a safer ..&lt; (aka half-open range operator)<br>&gt;&gt;&gt; in order to avoid **Array index out of range** errors in execution time.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Here is my first draft for this proposal:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In short, doing that in Swift causes a runtime error:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; leta =[1,2,3]<br>&gt;&gt;&gt; letb =a[0..&lt;5]<br>&gt;&gt;&gt; print(b)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; Error running code:<br>&gt;&gt;&gt; &gt; fatal error: Array index out of range<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The proposed solution is to slice the array returning all elements that<br>&gt;&gt;&gt; are below the half-open operator, even though the number of elements is<br>&gt;&gt;&gt; lesser than the ending of the half-open operator. So the example above<br>&gt;&gt;&gt; would return [1,2,3].<br>&gt;&gt;&gt; We can see this very behaviour in other languages, such as Python and<br>&gt;&gt;&gt; Ruby as shown in the proposal draft.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This would eliminate the need for verifications on the array size before<br>&gt;&gt;&gt; slicing it -- and consequently runtime errors in cases when the<br>&gt;&gt;&gt; programmer didn&#39;t.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Viewing that it is my very first proposal, any feedback will be helpful.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Luis Henrique Borges<br>&gt;&gt;&gt; @luishborges<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160412/35bb0c67/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>April 13, 2016 at 12:00:00pm</p></header><div class="content"><p>Should this new operator form a new range? How can this range know about the array&#39;s indices?<br></p><p>A while ago there was a proposal (unfortunately it was not discussed enough) which introduced safe array indexing:<br></p><p>         array[safe: 3] // returns nil if index out of bounds<br></p><p>So another way to handle this issue would be to make another subscript like:<br></p><p>         array[truncate: -1...6]<br></p><p>Best regards<br>- Maximilian<br></p><p>&gt; Am 12.04.2016 um 01:21 schrieb Luis Henrique B. Sousa via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; The idea of having a new operator following the principles of overflow operators looks great. Two distinct operators doing implicit and explicitly might really be a good way to go; it would be concise and wouldn&#39;t look like some magic happened behind the scenes. I&#39;d like to hear more opinions about it.<br>&gt; <br>&gt; &gt; what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise error or become [0 ..&lt; 3] ? I think, the latter.<br>&gt; I agree here, I&#39;d choose the latter.<br>&gt; <br>&gt; From my perspective, the behaviour I&#39;m proposing is what a considerable number of users expect, especially if coming from other languages that follow that path. Of course I&#39;m not comparing languages here, but considering the Swift principles of being a safer language, in my opinion we&#39;d rather have a partial slice than a crash in execution time (when the user is not totally aware of it).<br>&gt; <br>&gt; Many thanks for all your additions so far. It&#39;s really good to see that these things are not set in stone yet.<br>&gt; <br>&gt; - Luis<br>&gt; <br>&gt;&gt; On Apr 11, 2016 4:21 PM, &quot;Vladimir.S via swift-evolution&quot; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; +1 for the idea &quot;in general&quot;. But I also think that explicit is better than implicit, especially if we deal with possible errors. Just like we work in Swift with integer overflow : &#39;+&#39; will generate run time error, but saying &amp;+ we point Swift that we know what we do.<br>&gt;&gt; <br>&gt;&gt; but.. what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise error or become [0 ..&lt; 3] ? I think, the latter.<br>&gt;&gt; <br>&gt;&gt;&gt; On 11.04.2016 17:02, Haravikk via swift-evolution wrote:<br>&gt;&gt;&gt; I like the idea in theory, but the question is; is it really safer to<br>&gt;&gt;&gt; return a result that the developer may not have wanted, versus an error<br>&gt;&gt;&gt; indicating that a mistake may have been made? I wonder if perhaps there<br>&gt;&gt;&gt; could be an alternative, such as a variation of the operator like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let b = a [0 &amp;..&lt; 5]// Equivalent to let b = a[0 ..&lt; min(5, a.endIndex)],<br>&gt;&gt;&gt; becomes let b = a[0 ..&lt; 3]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m just not sure that we can assume that an array index out of range error<br>&gt;&gt;&gt; is okay without some kind of indication from the developer, as otherwise we<br>&gt;&gt;&gt; could end up returning a partial slice, which could end up causing an error<br>&gt;&gt;&gt; elsewhere where the size of the slice is assumed to be 5 but isn’t.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 11 Apr 2016, at 13:23, Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal seeks to provide a safer ..&lt; (aka half-open range operator)<br>&gt;&gt;&gt;&gt; in order to avoid **Array index out of range** errors in execution time.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here is my first draft for this proposal:<br>&gt;&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In short, doing that in Swift causes a runtime error:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; leta =[1,2,3]<br>&gt;&gt;&gt;&gt; letb =a[0..&lt;5]<br>&gt;&gt;&gt;&gt; print(b)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; Error running code:<br>&gt;&gt;&gt;&gt; &gt; fatal error: Array index out of range<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The proposed solution is to slice the array returning all elements that<br>&gt;&gt;&gt;&gt; are below the half-open operator, even though the number of elements is<br>&gt;&gt;&gt;&gt; lesser than the ending of the half-open operator. So the example above<br>&gt;&gt;&gt;&gt; would return [1,2,3].<br>&gt;&gt;&gt;&gt; We can see this very behaviour in other languages, such as Python and<br>&gt;&gt;&gt;&gt; Ruby as shown in the proposal draft.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This would eliminate the need for verifications on the array size before<br>&gt;&gt;&gt;&gt; slicing it -- and consequently runtime errors in cases when the<br>&gt;&gt;&gt;&gt; programmer didn&#39;t.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Viewing that it is my very first proposal, any feedback will be helpful.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Luis Henrique Borges<br>&gt;&gt;&gt;&gt; @luishborges<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160413/984f9d7e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 13, 2016 at 03:00:00pm</p></header><div class="content"><p>The problem the &quot;a[i &amp;..&lt; j]&quot; is trying to solve is to allow us to work <br>with array bounds without errors, even if i/j is incorrect, when we <br>explicitly allows this.<br></p><p>As for your question, yes, it seems like there is a problem :-)<br>&quot;i &amp;..&lt; j&quot; should become a new Range. But such range knows nothing about <br>array and its bounds. Probably such operator is not the best idea.<br></p><p>It seems I&#39;d prefer in this case some kind of a[truncate: -1..&lt;6] and <br>probably a[safe: -1..&lt;6] - which returns nil if range is incorrect.<br>So, in this case we&#39;ll have these methods and behavior:<br>a=[1,2,3]<br>a[-1..&lt;6] - raises runtime error<br>a[truncate: -1..&lt;6] - produces [1,2,3]<br>a[safe: -1..&lt;6] - produces nil (i.e [T]?)<br></p><p>Seems like very handy and explicit. Right behavior by default(raises <br>error). Opinions?<br></p><p>On 13.04.2016 13:52, Maximilian Hünenberger via swift-evolution wrote:<br>&gt; Should this new operator form a new range? How can this range know about<br>&gt; the array&#39;s indices?<br>&gt;<br>&gt; A while ago there was a proposal (unfortunately it was not discussed<br>&gt; enough) which introduced safe array indexing:<br>&gt;<br>&gt;           array[safe: 3] // returns nil if index out of bounds<br>&gt;<br>&gt; So another way to handle this issue would be to make another subscript like:<br>&gt;<br>&gt;           array[truncate: -1...6]<br>&gt;<br>&gt; Best regards<br>&gt; - Maximilian<br>&gt;<br>&gt; Am 12.04.2016 um 01:21 schrieb Luis Henrique B. Sousa via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;<br>&gt;&gt; The idea of having a new operator following the principles of overflow<br>&gt;&gt; operators looks great. Two distinct operators doing implicit and<br>&gt;&gt; explicitly might really be a good way to go; it would be concise and<br>&gt;&gt; wouldn&#39;t look like some magic happened behind the scenes. I&#39;d like to<br>&gt;&gt; hear more opinions about it.<br>&gt;&gt;<br>&gt;&gt; &gt; what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise error or become<br>&gt;&gt; [0 ..&lt; 3] ? I think, the latter.<br>&gt;&gt; I agree here, I&#39;d choose the latter.<br>&gt;&gt;<br>&gt;&gt; From my perspective, the behaviour I&#39;m proposing is what a considerable<br>&gt;&gt; number of users expect, especially if coming from other languages that<br>&gt;&gt; follow that path. Of course I&#39;m not comparing languages here, but<br>&gt;&gt; considering the Swift principles of being a safer language, in my opinion<br>&gt;&gt; we&#39;d rather have a partial slice than a crash in execution time (when the<br>&gt;&gt; user is not totally aware of it).<br>&gt;&gt;<br>&gt;&gt; Many thanks for all your additions so far. It&#39;s really good to see that<br>&gt;&gt; these things are not set in stone yet.<br>&gt;&gt;<br>&gt;&gt; - Luis<br>&gt;&gt;<br>&gt;&gt; On Apr 11, 2016 4:21 PM, &quot;Vladimir.S via swift-evolution&quot;<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     +1 for the idea &quot;in general&quot;. But I also think that explicit is<br>&gt;&gt;     better than implicit, especially if we deal with possible errors.<br>&gt;&gt;     Just like we work in Swift with integer overflow : &#39;+&#39; will generate<br>&gt;&gt;     run time error, but saying &amp;+ we point Swift that we know what we do.<br>&gt;&gt;<br>&gt;&gt;     but.. what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise error<br>&gt;&gt;     or become [0 ..&lt; 3] ? I think, the latter.<br>&gt;&gt;<br>&gt;&gt;     On 11.04.2016 17:02, Haravikk via swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt;         I like the idea in theory, but the question is; is it really safer to<br>&gt;&gt;         return a result that the developer may not have wanted, versus an<br>&gt;&gt;         error<br>&gt;&gt;         indicating that a mistake may have been made? I wonder if perhaps<br>&gt;&gt;         there<br>&gt;&gt;         could be an alternative, such as a variation of the operator like so:<br>&gt;&gt;<br>&gt;&gt;         let b = a [0 &amp;..&lt; 5]// Equivalent to let b = a[0 ..&lt; min(5,<br>&gt;&gt;         a.endIndex)],<br>&gt;&gt;         becomes let b = a[0 ..&lt; 3]<br>&gt;&gt;<br>&gt;&gt;         I’m just not sure that we can assume that an array index out of<br>&gt;&gt;         range error<br>&gt;&gt;         is okay without some kind of indication from the developer, as<br>&gt;&gt;         otherwise we<br>&gt;&gt;         could end up returning a partial slice, which could end up<br>&gt;&gt;         causing an error<br>&gt;&gt;         elsewhere where the size of the slice is assumed to be 5 but isn’t.<br>&gt;&gt;<br>&gt;&gt;             On 11 Apr 2016, at 13:23, Luis Henrique B. Sousa via<br>&gt;&gt;             swift-evolution<br>&gt;&gt;             &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;             &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;             &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;             This proposal seeks to provide a safer ..&lt; (aka half-open<br>&gt;&gt;             range operator)<br>&gt;&gt;             in order to avoid **Array index out of range** errors in<br>&gt;&gt;             execution time.<br>&gt;&gt;<br>&gt;&gt;             Here is my first draft for this proposal:<br>&gt;&gt;             https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;<br>&gt;&gt;             In short, doing that in Swift causes a runtime error:<br>&gt;&gt;<br>&gt;&gt;             leta =[1,2,3]<br>&gt;&gt;             letb =a[0..&lt;5]<br>&gt;&gt;             print(b)<br>&gt;&gt;<br>&gt;&gt;             &gt; Error running code:<br>&gt;&gt;             &gt; fatal error: Array index out of range<br>&gt;&gt;<br>&gt;&gt;             The proposed solution is to slice the array returning all<br>&gt;&gt;             elements that<br>&gt;&gt;             are below the half-open operator, even though the number of<br>&gt;&gt;             elements is<br>&gt;&gt;             lesser than the ending of the half-open operator. So the<br>&gt;&gt;             example above<br>&gt;&gt;             would return [1,2,3].<br>&gt;&gt;             We can see this very behaviour in other languages, such as<br>&gt;&gt;             Python and<br>&gt;&gt;             Ruby as shown in the proposal draft.<br>&gt;&gt;<br>&gt;&gt;             This would eliminate the need for verifications on the array<br>&gt;&gt;             size before<br>&gt;&gt;             slicing it -- and consequently runtime errors in cases when the<br>&gt;&gt;             programmer didn&#39;t.<br>&gt;&gt;<br>&gt;&gt;             Viewing that it is my very first proposal, any feedback will<br>&gt;&gt;             be helpful.<br>&gt;&gt;<br>&gt;&gt;             Thanks!<br>&gt;&gt;<br>&gt;&gt;             Luis Henrique Borges<br>&gt;&gt;             @luishborges<br>&gt;&gt;             _______________________________________________<br>&gt;&gt;             swift-evolution mailing list<br>&gt;&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;             &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;             &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         _______________________________________________<br>&gt;&gt;         swift-evolution mailing list<br>&gt;&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;     _______________________________________________<br>&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>April 14, 2016 at 09:00:00pm</p></header><div class="content"><p>I&#39;ve just updated the proposal draft adding this new approach as an<br>&quot;alternative considered&quot;, hope it conforms to what we&#39;ve discussed so far:<br></p><p>https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md#alternatives-considered<br></p><p>I&#39;ll wait for more feedback so that I can see whether or not I should<br>submit this proposal for review.<br></p><p>If you have something to add/fix there, please let me know or just send a<br>pull request :-)<br></p><p>(ah, sorry for the wrong subject, it should be &quot;[Draft]&quot; instead)<br></p><p>- Luis<br></p><p>On Wed, Apr 13, 2016 at 1:50 PM, Vladimir.S via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The problem the &quot;a[i &amp;..&lt; j]&quot; is trying to solve is to allow us to work<br>&gt; with array bounds without errors, even if i/j is incorrect, when we<br>&gt; explicitly allows this.<br>&gt;<br>&gt; As for your question, yes, it seems like there is a problem :-)<br>&gt; &quot;i &amp;..&lt; j&quot; should become a new Range. But such range knows nothing about<br>&gt; array and its bounds. Probably such operator is not the best idea.<br>&gt;<br>&gt; It seems I&#39;d prefer in this case some kind of a[truncate: -1..&lt;6] and<br>&gt; probably a[safe: -1..&lt;6] - which returns nil if range is incorrect.<br>&gt; So, in this case we&#39;ll have these methods and behavior:<br>&gt; a=[1,2,3]<br>&gt; a[-1..&lt;6] - raises runtime error<br>&gt; a[truncate: -1..&lt;6] - produces [1,2,3]<br>&gt; a[safe: -1..&lt;6] - produces nil (i.e [T]?)<br>&gt;<br>&gt; Seems like very handy and explicit. Right behavior by default(raises<br>&gt; error). Opinions?<br>&gt;<br>&gt; On 13.04.2016 13:52, Maximilian Hünenberger via swift-evolution wrote:<br>&gt;<br>&gt;&gt; Should this new operator form a new range? How can this range know about<br>&gt;&gt; the array&#39;s indices?<br>&gt;&gt;<br>&gt;&gt; A while ago there was a proposal (unfortunately it was not discussed<br>&gt;&gt; enough) which introduced safe array indexing:<br>&gt;&gt;<br>&gt;&gt;           array[safe: 3] // returns nil if index out of bounds<br>&gt;&gt;<br>&gt;&gt; So another way to handle this issue would be to make another subscript<br>&gt;&gt; like:<br>&gt;&gt;<br>&gt;&gt;           array[truncate: -1...6]<br>&gt;&gt;<br>&gt;&gt; Best regards<br>&gt;&gt; - Maximilian<br>&gt;&gt;<br>&gt;&gt; Am 12.04.2016 um 01:21 schrieb Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;<br>&gt;&gt; The idea of having a new operator following the principles of overflow<br>&gt;&gt;&gt; operators looks great. Two distinct operators doing implicit and<br>&gt;&gt;&gt; explicitly might really be a good way to go; it would be concise and<br>&gt;&gt;&gt; wouldn&#39;t look like some magic happened behind the scenes. I&#39;d like to<br>&gt;&gt;&gt; hear more opinions about it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise error or become<br>&gt;&gt;&gt; [0 ..&lt; 3] ? I think, the latter.<br>&gt;&gt;&gt; I agree here, I&#39;d choose the latter.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; From my perspective, the behaviour I&#39;m proposing is what a considerable<br>&gt;&gt;&gt; number of users expect, especially if coming from other languages that<br>&gt;&gt;&gt; follow that path. Of course I&#39;m not comparing languages here, but<br>&gt;&gt;&gt; considering the Swift principles of being a safer language, in my opinion<br>&gt;&gt;&gt; we&#39;d rather have a partial slice than a crash in execution time (when the<br>&gt;&gt;&gt; user is not totally aware of it).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Many thanks for all your additions so far. It&#39;s really good to see that<br>&gt;&gt;&gt; these things are not set in stone yet.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Luis<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Apr 11, 2016 4:21 PM, &quot;Vladimir.S via swift-evolution&quot;<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     +1 for the idea &quot;in general&quot;. But I also think that explicit is<br>&gt;&gt;&gt;     better than implicit, especially if we deal with possible errors.<br>&gt;&gt;&gt;     Just like we work in Swift with integer overflow : &#39;+&#39; will generate<br>&gt;&gt;&gt;     run time error, but saying &amp;+ we point Swift that we know what we do.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     but.. what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise error<br>&gt;&gt;&gt;     or become [0 ..&lt; 3] ? I think, the latter.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     On 11.04.2016 17:02, Haravikk via swift-evolution wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         I like the idea in theory, but the question is; is it really<br>&gt;&gt;&gt; safer to<br>&gt;&gt;&gt;         return a result that the developer may not have wanted, versus an<br>&gt;&gt;&gt;         error<br>&gt;&gt;&gt;         indicating that a mistake may have been made? I wonder if perhaps<br>&gt;&gt;&gt;         there<br>&gt;&gt;&gt;         could be an alternative, such as a variation of the operator<br>&gt;&gt;&gt; like so:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         let b = a [0 &amp;..&lt; 5]// Equivalent to let b = a[0 ..&lt; min(5,<br>&gt;&gt;&gt;         a.endIndex)],<br>&gt;&gt;&gt;         becomes let b = a[0 ..&lt; 3]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         I’m just not sure that we can assume that an array index out of<br>&gt;&gt;&gt;         range error<br>&gt;&gt;&gt;         is okay without some kind of indication from the developer, as<br>&gt;&gt;&gt;         otherwise we<br>&gt;&gt;&gt;         could end up returning a partial slice, which could end up<br>&gt;&gt;&gt;         causing an error<br>&gt;&gt;&gt;         elsewhere where the size of the slice is assumed to be 5 but<br>&gt;&gt;&gt; isn’t.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             On 11 Apr 2016, at 13:23, Luis Henrique B. Sousa via<br>&gt;&gt;&gt;             swift-evolution<br>&gt;&gt;&gt;             &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;             &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             This proposal seeks to provide a safer ..&lt; (aka half-open<br>&gt;&gt;&gt;             range operator)<br>&gt;&gt;&gt;             in order to avoid **Array index out of range** errors in<br>&gt;&gt;&gt;             execution time.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             Here is my first draft for this proposal:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             In short, doing that in Swift causes a runtime error:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             leta =[1,2,3]<br>&gt;&gt;&gt;             letb =a[0..&lt;5]<br>&gt;&gt;&gt;             print(b)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt; Error running code:<br>&gt;&gt;&gt;             &gt; fatal error: Array index out of range<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             The proposed solution is to slice the array returning all<br>&gt;&gt;&gt;             elements that<br>&gt;&gt;&gt;             are below the half-open operator, even though the number of<br>&gt;&gt;&gt;             elements is<br>&gt;&gt;&gt;             lesser than the ending of the half-open operator. So the<br>&gt;&gt;&gt;             example above<br>&gt;&gt;&gt;             would return [1,2,3].<br>&gt;&gt;&gt;             We can see this very behaviour in other languages, such as<br>&gt;&gt;&gt;             Python and<br>&gt;&gt;&gt;             Ruby as shown in the proposal draft.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             This would eliminate the need for verifications on the array<br>&gt;&gt;&gt;             size before<br>&gt;&gt;&gt;             slicing it -- and consequently runtime errors in cases when<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt;             programmer didn&#39;t.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             Viewing that it is my very first proposal, any feedback will<br>&gt;&gt;&gt;             be helpful.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             Thanks!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             Luis Henrique Borges<br>&gt;&gt;&gt;             @luishborges<br>&gt;&gt;&gt;             _______________________________________________<br>&gt;&gt;&gt;             swift-evolution mailing list<br>&gt;&gt;&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;             &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;             &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         _______________________________________________<br>&gt;&gt;&gt;         swift-evolution mailing list<br>&gt;&gt;&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     _______________________________________________<br>&gt;&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/835f0fd4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7b4f0271043628eecd950f1e3cdd1a84?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at googlemail.com&gt;<p>April 11, 2016 at 05:00:00pm</p></header><div class="content"><p>I do not think that this should be included in the default library as it is inconsistent with the behavior we generally have on collections (where user is responsible for correct indexing). However, it is quite trivial to define a new subscript operation, e.g. subscript(safe: Range)<br></p><p>— Taras<br></p><p>&gt; On 11 Apr 2016, at 14:23, Luis Henrique B. Sousa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This proposal seeks to provide a safer ..&lt; (aka half-open range operator) in order to avoid **Array index out of range** errors in execution time.<br>&gt; <br>&gt; Here is my first draft for this proposal: https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md &lt;https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md&gt;<br>&gt; <br>&gt; In short, doing that in Swift causes a runtime error:<br>&gt; let a = [1,2,3]<br>&gt; let b = a[0..&lt;5]<br>&gt; print(b)<br>&gt; <br>&gt; &gt; Error running code: <br>&gt; &gt; fatal error: Array index out of range<br>&gt; <br>&gt; The proposed solution is to slice the array returning all elements that are below the half-open operator, even though the number of elements is lesser than the ending of the half-open operator. So the example above would return [1,2,3]. <br>&gt; We can see this very behaviour in other languages, such as Python and Ruby as shown in the proposal draft.<br>&gt; <br>&gt; This would eliminate the need for verifications on the array size before slicing it -- and consequently runtime errors in cases when the programmer didn&#39;t. <br>&gt; <br>&gt; Viewing that it is my very first proposal, any feedback will be helpful.<br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt; Luis Henrique Borges<br>&gt; @luishborges<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/d9807746/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>April 13, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 11 Apr 2016, at 15:23, Luis Henrique B. Sousa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; let a = [1,2,3]<br>&gt; let b = a[0..&lt;5]<br>&gt; print(b)<br>&gt; <br></p><p>In the swift-3-indexing-model branch &lt;https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/Range.swift#L94&gt;, you can clamp a range just like you could clamp intervals in Swift 2. So the following will work in the way you preferred:<br></p><p>    let b = a[a.indices.clamped(to: 0 ..&lt; 5)]<br></p><p>It was suggested to extend `Collection` with a subscript like `a[safe: 0 ..&lt; 5]` which resembles the current subsequence subscript &lt;https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/Collection.swift#L82&gt;. Alternatively, we could bring collections even closer to ranges by extending them with the equivalent `.clamped(to:)` method:<br></p><p>    let b = a.clamped(to: 0 ..&lt; 5) // &quot;safe&quot; subsequence<br></p><p>— Pyry<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160413/74206274/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 13, 2016 at 04:00:00pm</p></header><div class="content"><p>Is it really great to have a[a.indices.clamped(to: 0 ..&lt; 5)]<br>instead of a clear a[truncate: 0 ..&lt; 5] ?<br>and if it is not &quot;a&quot; but &quot;arrayOfSomeValues&quot; we have<br>arrayOfSomeValues[arrayOfSomeValues.indices.clamped(to: 0 ..&lt; 5)]<br>Don&#39;t feel this is nice.<br></p><p>Is it really so wrong to have additional(to &quot;direct&quot; functions like <br>&quot;indices.clamped&quot; ) handy and nice-looking methods/subscripts in language?<br></p><p>IMO we all want to have great language. It should be great to code in such <br>language. Is it great and enjoyable to have strange long construction <br>instead of handy,clear and explicit expression?<br>Why don&#39;t improve the language in all possible area where we can improve <br>it? I believe we should improve.<br></p><p>On 13.04.2016 14:09, Pyry Jahkola via swift-evolution wrote:<br>&gt;&gt; On 11 Apr 2016, at 15:23, Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; leta =[1,2,3]<br>&gt;&gt; letb =a[0..&lt;5]<br>&gt;&gt; print(b)<br>&gt;&gt;<br>&gt; In the swift-3-indexing-model branch<br>&gt; &lt;https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/Range.swift#L94&gt;,<br>&gt; you can /clamp/ a range just like you could clamp intervals in Swift 2. So<br>&gt; the following will work in the way you preferred:<br>&gt;<br>&gt;      let b = a[a.indices.clamped(to: 0 ..&lt; 5)]<br>&gt;<br>&gt; It was suggested to extend `Collection` with a subscript like `a[safe: 0<br>&gt; ..&lt; 5]` which resembles the current subsequence subscript<br>&gt; &lt;https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/Collection.swift#L82&gt;. Alternatively,<br>&gt; we could bring collections even closer to ranges by extending them with the<br>&gt; equivalent `.clamped(to:)` method:<br>&gt;<br>&gt;      let b = a.clamped(to: 0 ..&lt; 5) // &quot;safe&quot; subsequence<br>&gt;<br>&gt; — Pyry<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>April 13, 2016 at 03:00:00pm</p></header><div class="content"><p>Many thanks @Pyry, it&#39;s great to see those changes coming in swift 3. The<br>examples using *clamp* you mentioned here would do what I&#39;m proposing, but<br>I totally agree with @Vladimir that we could have a more clear and<br>*swift-ly* way to concisely wrap those operations.<br></p><p>The behaviour pointed out by him looks very nice and doable to me.<br></p><p>a = [1,2,3]<br>a[-1..&lt;6] - raises runtime error (right behavior by default, doesn&#39;t affect<br>existing code)<br>a[truncate: -1..&lt;6] - produces [1,2,3] (the very behaviour I proposed<br>initially)<br>a[safe: -1..&lt;6] - produces nil (i.e [T]?) (no runtime errors and makes it<br>easy to handle unexpected results)<br></p><p>I&#39;d like to hear more opinions before I update my proposal with those new<br>subscript methods (instead of a different operator, or added as an<br>alternative considered).<br>Thanks<br></p><p>- Luis<br></p><p>On Wed, Apr 13, 2016 at 2:11 PM, Vladimir.S via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Is it really great to have a[a.indices.clamped(to: 0 ..&lt; 5)]<br>&gt; instead of a clear a[truncate: 0 ..&lt; 5] ?<br>&gt; and if it is not &quot;a&quot; but &quot;arrayOfSomeValues&quot; we have<br>&gt; arrayOfSomeValues[arrayOfSomeValues.indices.clamped(to: 0 ..&lt; 5)]<br>&gt; Don&#39;t feel this is nice.<br>&gt;<br>&gt; Is it really so wrong to have additional(to &quot;direct&quot; functions like<br>&gt; &quot;indices.clamped&quot; ) handy and nice-looking methods/subscripts in language?<br>&gt;<br>&gt; IMO we all want to have great language. It should be great to code in such<br>&gt; language. Is it great and enjoyable to have strange long construction<br>&gt; instead of handy,clear and explicit expression?<br>&gt; Why don&#39;t improve the language in all possible area where we can improve<br>&gt; it? I believe we should improve.<br>&gt;<br>&gt; On 13.04.2016 14:09, Pyry Jahkola via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On 11 Apr 2016, at 15:23, Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; leta =[1,2,3]<br>&gt;&gt;&gt; letb =a[0..&lt;5]<br>&gt;&gt;&gt; print(b)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In the swift-3-indexing-model branch<br>&gt;&gt; &lt;<br>&gt;&gt; https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/Range.swift#L94<br>&gt;&gt; &gt;,<br>&gt;&gt; you can /clamp/ a range just like you could clamp intervals in Swift 2. So<br>&gt;&gt; the following will work in the way you preferred:<br>&gt;&gt;<br>&gt;&gt;      let b = a[a.indices.clamped(to: 0 ..&lt; 5)]<br>&gt;&gt;<br>&gt;&gt; It was suggested to extend `Collection` with a subscript like `a[safe: 0<br>&gt;&gt; ..&lt; 5]` which resembles the current subsequence subscript<br>&gt;&gt; &lt;<br>&gt;&gt; https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/Collection.swift#L82&gt;.<br>&gt;&gt; Alternatively,<br>&gt;&gt; we could bring collections even closer to ranges by extending them with<br>&gt;&gt; the<br>&gt;&gt; equivalent `.clamped(to:)` method:<br>&gt;&gt;<br>&gt;&gt;      let b = a.clamped(to: 0 ..&lt; 5) // &quot;safe&quot; subsequence<br>&gt;&gt;<br>&gt;&gt; — Pyry<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160413/43a359f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>April 13, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 13 Apr 2016, at 17:53, Luis Henrique B. Sousa &lt;lshsousa at gmail.com&gt; wrote:<br>&gt; <br>&gt; (…) I totally agree with @Vladimir that we could have a more clear and swift-ly way to concisely wrap those operations.<br>&gt; <br>&gt; The behaviour pointed out by him looks very nice and doable to me.<br>&gt; <br>&gt; a = [1,2,3]<br>&gt; a[-1..&lt;6] - raises runtime error (right behavior by default, doesn&#39;t affect existing code)<br>&gt; a[truncate: -1..&lt;6] - produces [1,2,3] (the very behaviour I proposed initially)<br>&gt; a[safe: -1..&lt;6] - produces nil (i.e [T]?) (no runtime errors and makes it easy to handle unexpected results)<br></p><p><br>I don&#39;t feel strongly about this. Yes, if this were shorter to express, it would feel like nicer design. But what Haravikk and Chris L. already said seems to me as wiser design.<br></p><p>(@Vladimir: Besides, I&#39;m sure `.clamped(to:)` wasn&#39;t invented for this purpose but for doing interval arithmetic on ranges. It just happens to somewhat work here.)<br></p><p>– Would this feature really provide a measurable benefit to developers?<br>– Under which circumstances do you find yourself with a past-the-end upper bound such as 6 where `a.count == 3`?<br>– …Let alone a negative start index like `-1`?<br></p><p>I find cases like these to be much more common in languages like Python and Ruby where e.g. `array[-2]` refers to the penultimate element. Swift doesn&#39;t seem to want to go there.<br></p><p>For the use cases I can think of, Swift 3—as the proposal currently goes &lt;https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/Collection.swift#L724-L808&gt;—already offers the following suitable methods:<br></p><p>    array[bounds]<br>    array.prefix(maxLength)      // no precondition<br>    array.prefix(upTo: index)<br>    array.prefix(through: index)<br>    array.dropLast(n)            // no precondition<br>    array.dropFirst(n)           // no precondition<br>    array.suffix(from: index)<br>    array.suffix(maxLength)      // no precondition<br></p><p>If these feel too clumsy to use, maybe we should focus on making them all more convenient. Ideally, that suggestion would apply to all `Collection`s.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160413/4f3787a9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 13, 2016 at 09:00:00pm</p></header><div class="content"><p>On 13.04.2016 19:59, Pyry Jahkola wrote:<br>&gt;&gt; On 13 Apr 2016, at 17:53, Luis Henrique B. Sousa &lt;lshsousa at gmail.com<br>&gt;&gt; &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; (…) I totally agree with @Vladimir that we could have a more clear and<br>&gt;&gt; /swift-ly/ way to concisely wrap those operations.<br>&gt;&gt;<br>&gt;&gt; The behaviour pointed out by him looks very nice and doable to me.<br>&gt;&gt;<br>&gt;&gt; a = [1,2,3]<br>&gt;&gt; a[-1..&lt;6] - raises runtime error (right behavior by default, doesn&#39;t<br>&gt;&gt; affect existing code)<br>&gt;&gt; a[truncate: -1..&lt;6] - produces [1,2,3] (the very behaviour I proposed<br>&gt;&gt; initially)<br>&gt;&gt; a[safe: -1..&lt;6] - produces nil (i.e [T]?) (no runtime errors and makes it<br>&gt;&gt; easy to handle unexpected results)<br>&gt;<br>&gt; I don&#39;t feel strongly about this. Yes, if this were shorter to express, it<br>&gt; would feel like /nicer/ design. But what Haravikk and Chris L. already said<br>&gt; seems to me as /wiser/ design.<br></p><p><br>IMO it is not just nicer, it provides you with handy and explicit <br>alternatives.<br></p><p>In some situations, you are checking bounds and you sure that if you <br>calculated them incorrectly - error will be raised.<br>But sometimes, you don&#39;t need to check exact bounds, probably &quot;take these <br>values, or give me nil of no such&quot;.<br></p><p>I can compare this with Dictionary we have in Swift.<br>Can you say if it is &quot;wise&quot; to return Optional(T) when we calls <br>dict[somekey] ? Probably it is wise to raise error if there is no such key? <br>(to force us to check the key first).<br></p><p>The proposed subscript for special situations when you know you need <br>exactly this behavior to make your code clear and readable and you fully <br>controls code&amp;error flow.<br></p><p>&gt;<br>&gt; (@Vladimir: Besides, I&#39;m sure `.clamped(to:)` wasn&#39;t invented for this<br>&gt; purpose but for doing interval arithmetic on ranges. It just happens to<br>&gt; somewhat work here.)<br>&gt;<br>&gt; – Would this feature really provide a measurable benefit to developers?<br>&gt; – Under which circumstances do you find yourself with a past-the-end upper<br>&gt; bound such as 6 where `a.count == 3`?<br>&gt; – …Let alone a /negative/ start index like `-1`?<br>&gt;<br>&gt; I find cases like these to be much more common in languages like Python and<br>&gt; Ruby where e.g. `array[-2]` refers to the penultimate element. Swift<br>&gt; doesn&#39;t seem to want to go there.<br>&gt;<br></p><p>Each good feature will provide benefit to developers. For those, who work a <br>lot with arrays/bounds/slices/copies this will provide measurable benefit, IMO.<br>Can we live without such improvement? Absolutely. Are there more important <br>proposals? Yes. But will this make Swift more elegant, handy, clear? Yes, I <br>believe.<br></p><p>As for &quot;Under which circumstances..&quot; questions. Well.. something like &quot;get <br>+- 5 elements(at max) with center in some index&quot;<br></p><p>let a = [1,2,3,4,5,6]<br>let index = random(0..&lt;a.count)<br>let result = a[truncate: index-5...index+5]<br></p><p>or &quot;get 5 elements from index, if no 5 elements from index - return empty <br>array&quot;<br></p><p>let a = [1,2,3,4,5,6]<br>let index = random(0..&lt;a.count)<br>if let result = a[safe: index..&lt;index+5]  //[Int]?<br>  {return result}<br>else<br>  {return []}<br></p><p>Something like this.<br></p><p><br>&gt; For the use cases I can think of, Swift 3—as the proposal currently goes<br>&gt; &lt;https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/Collection.swift#L724-L808&gt;—already<br>&gt; offers the following suitable methods:<br>&gt;<br>&gt;      array[bounds]<br>&gt;      array.prefix(maxLength)// no precondition<br>&gt;      array.prefix(upTo: index)<br>&gt;      array.prefix(through: index)<br>&gt;      array.dropLast(n)// no precondition<br>&gt;      array.dropFirst(n)// no precondition<br>&gt;      array.suffix(from: index)<br>&gt;      array.suffix(maxLength)      // no precondition<br>&gt;<br>&gt; If these feel too clumsy to use, maybe we should focus on making them all<br>&gt; more convenient. Ideally, that suggestion would apply to all `Collection`s.<br>&gt;<br>&gt; — Pyry<br>&gt;<br></p><p>Yes, some variants can be covered by these methods:<br>array.prefix(maxLength) -&gt; array[truncate: 0..&lt;maxLength]<br>array.prefix(upTo) -&gt; array[0..&lt;upTo]<br>array.prefix(through) -&gt; array[0...through]<br></p><p>And some has no good alternatives in subscription:<br>array.suffix(from: index) -&gt; array[truncate: index...Int.max ??<br>array.suffix(maxLength)   -&gt; array[truncate: hm..<br></p><p>But. As array[bound] returns a copy(slice) of array, it feels natural to <br>have variants of behavior of array[bound], just like you have different <br>variants of prefix() methods.<br></p><p>So it seems for me like this proposal for subscript variants(safe: &amp; <br>truncate:) is good addition to then proposal you pointed to.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>April 13, 2016 at 08:00:00pm</p></header><div class="content"><p>Another common application would be on pagination systems. For example,<br>this function that I just found randomly:<br>https://github.com/MrAlek/PagedArray/blob/bf64cbb140cf8bd109483dd749ac40a5f4531dfd/Source/PagedArray.swift#L88<br></p><p><br>public func indexes(pageIndex: Int) -&gt; Range&lt;Index&gt; {<br>    assert(pageIndex &gt;= startPageIndex &amp;&amp; pageIndex &lt;= lastPageIndex, &quot;Page<br>index out of bounds&quot;)<br></p><p>    let startIndex: Index = (pageIndex-startPageIndex)*pageSize<br>    let endIndex: Index<br>    if pageIndex == lastPageIndex {<br>        endIndex = count<br>    } else {<br>        endIndex = startIndex+pageSize<br>    }<br></p><p>    return (startIndex..&lt;endIndex)<br>}<br></p><p><br>wouldn&#39;t be required anymore before accessing the array, having simply<br>something like<br></p><p>&gt; let current = pageIndex * pageSize<br>&gt; array[safe: (current - pageSize) ..&lt; (current + pageSize)]<br></p><p>(or *truncate* according to the user expectation) instead, which in my<br>opinion looks much more elegant and handy.<br></p><p><br>Regards,<br></p><p>- Luis<br></p><p>On Wed, Apr 13, 2016 at 7:37 PM, Vladimir.S via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 13.04.2016 19:59, Pyry Jahkola wrote:<br>&gt;<br>&gt;&gt; On 13 Apr 2016, at 17:53, Luis Henrique B. Sousa &lt;lshsousa at gmail.com<br>&gt;&gt;&gt; &lt;mailto:lshsousa at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (…) I totally agree with @Vladimir that we could have a more clear and<br>&gt;&gt;&gt; /swift-ly/ way to concisely wrap those operations.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The behaviour pointed out by him looks very nice and doable to me.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; a = [1,2,3]<br>&gt;&gt;&gt; a[-1..&lt;6] - raises runtime error (right behavior by default, doesn&#39;t<br>&gt;&gt;&gt; affect existing code)<br>&gt;&gt;&gt; a[truncate: -1..&lt;6] - produces [1,2,3] (the very behaviour I proposed<br>&gt;&gt;&gt; initially)<br>&gt;&gt;&gt; a[safe: -1..&lt;6] - produces nil (i.e [T]?) (no runtime errors and makes it<br>&gt;&gt;&gt; easy to handle unexpected results)<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don&#39;t feel strongly about this. Yes, if this were shorter to express, it<br>&gt;&gt; would feel like /nicer/ design. But what Haravikk and Chris L. already<br>&gt;&gt; said<br>&gt;&gt; seems to me as /wiser/ design.<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; IMO it is not just nicer, it provides you with handy and explicit<br>&gt; alternatives.<br>&gt;<br>&gt; In some situations, you are checking bounds and you sure that if you<br>&gt; calculated them incorrectly - error will be raised.<br>&gt; But sometimes, you don&#39;t need to check exact bounds, probably &quot;take these<br>&gt; values, or give me nil of no such&quot;.<br>&gt;<br>&gt; I can compare this with Dictionary we have in Swift.<br>&gt; Can you say if it is &quot;wise&quot; to return Optional(T) when we calls<br>&gt; dict[somekey] ? Probably it is wise to raise error if there is no such key?<br>&gt; (to force us to check the key first).<br>&gt;<br>&gt; The proposed subscript for special situations when you know you need<br>&gt; exactly this behavior to make your code clear and readable and you fully<br>&gt; controls code&amp;error flow.<br>&gt;<br>&gt;<br>&gt;&gt; (@Vladimir: Besides, I&#39;m sure `.clamped(to:)` wasn&#39;t invented for this<br>&gt;&gt; purpose but for doing interval arithmetic on ranges. It just happens to<br>&gt;&gt; somewhat work here.)<br>&gt;&gt;<br>&gt;&gt; – Would this feature really provide a measurable benefit to developers?<br>&gt;&gt; – Under which circumstances do you find yourself with a past-the-end upper<br>&gt;&gt; bound such as 6 where `a.count == 3`?<br>&gt;&gt; – …Let alone a /negative/ start index like `-1`?<br>&gt;&gt;<br>&gt;&gt; I find cases like these to be much more common in languages like Python<br>&gt;&gt; and<br>&gt;&gt; Ruby where e.g. `array[-2]` refers to the penultimate element. Swift<br>&gt;&gt; doesn&#39;t seem to want to go there.<br>&gt;&gt;<br>&gt;&gt;<br>&gt; Each good feature will provide benefit to developers. For those, who work<br>&gt; a lot with arrays/bounds/slices/copies this will provide measurable<br>&gt; benefit, IMO.<br>&gt; Can we live without such improvement? Absolutely. Are there more important<br>&gt; proposals? Yes. But will this make Swift more elegant, handy, clear? Yes, I<br>&gt; believe.<br>&gt;<br>&gt; As for &quot;Under which circumstances..&quot; questions. Well.. something like &quot;get<br>&gt; +- 5 elements(at max) with center in some index&quot;<br>&gt;<br>&gt; let a = [1,2,3,4,5,6]<br>&gt; let index = random(0..&lt;a.count)<br>&gt; let result = a[truncate: index-5...index+5]<br>&gt;<br>&gt; or &quot;get 5 elements from index, if no 5 elements from index - return empty<br>&gt; array&quot;<br>&gt;<br>&gt; let a = [1,2,3,4,5,6]<br>&gt; let index = random(0..&lt;a.count)<br>&gt; if let result = a[safe: index..&lt;index+5]  //[Int]?<br>&gt;  {return result}<br>&gt; else<br>&gt;  {return []}<br>&gt;<br>&gt; Something like this.<br>&gt;<br>&gt;<br>&gt; For the use cases I can think of, Swift 3—as the proposal currently goes<br>&gt;&gt; &lt;<br>&gt;&gt; https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/Collection.swift#L724-L808<br>&gt;&gt; &gt;—already<br>&gt;&gt; offers the following suitable methods:<br>&gt;&gt;<br>&gt;&gt;      array[bounds]<br>&gt;&gt;      array.prefix(maxLength)// no precondition<br>&gt;&gt;      array.prefix(upTo: index)<br>&gt;&gt;      array.prefix(through: index)<br>&gt;&gt;      array.dropLast(n)// no precondition<br>&gt;&gt;      array.dropFirst(n)// no precondition<br>&gt;&gt;      array.suffix(from: index)<br>&gt;&gt;      array.suffix(maxLength)      // no precondition<br>&gt;&gt;<br>&gt;&gt; If these feel too clumsy to use, maybe we should focus on making them all<br>&gt;&gt; more convenient. Ideally, that suggestion would apply to all<br>&gt;&gt; `Collection`s.<br>&gt;&gt;<br>&gt;&gt; — Pyry<br>&gt;&gt;<br>&gt;&gt;<br>&gt; Yes, some variants can be covered by these methods:<br>&gt; array.prefix(maxLength) -&gt; array[truncate: 0..&lt;maxLength]<br>&gt; array.prefix(upTo) -&gt; array[0..&lt;upTo]<br>&gt; array.prefix(through) -&gt; array[0...through]<br>&gt;<br>&gt; And some has no good alternatives in subscription:<br>&gt; array.suffix(from: index) -&gt; array[truncate: index...Int.max ??<br>&gt; array.suffix(maxLength)   -&gt; array[truncate: hm..<br>&gt;<br>&gt; But. As array[bound] returns a copy(slice) of array, it feels natural to<br>&gt; have variants of behavior of array[bound], just like you have different<br>&gt; variants of prefix() methods.<br>&gt;<br>&gt; So it seems for me like this proposal for subscript variants(safe: &amp;<br>&gt; truncate:) is good addition to then proposal you pointed to.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160413/1c9a6601/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/945b1c30e3fef71ac52c1748e94a8555?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Daniel Quirino</string> &lt;quirinux at gmail.com&gt;<p>April 14, 2016 at 09:00:00am</p></header><div class="content"><p>Totally agreed with you guys, for me the matter question here is:<br></p><p>Why should we care about language details instead  what the app really have<br>to do?<br></p><p>Keeping in mind that kind of stuff doesn&#39;t help, the focus should be in<br>their functionalities and all that could be done to get handy and keep a<br>clearly code should be done, I think we need less C/C++/Obj-C style on<br>swift and I let a question:<br></p><p>What controlling arrays bounds stands for? being that swift could do this<br>behind the scenes.<br></p><p><br></p><p>Em quarta-feira, 13 de abril de 2016, Luis Henrique B. Sousa via<br>swift-evolution &lt;swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; Another common application would be on pagination systems. For example,<br>&gt; this function that I just found randomly:<br>&gt;<br>&gt; https://github.com/MrAlek/PagedArray/blob/bf64cbb140cf8bd109483dd749ac40a5f4531dfd/Source/PagedArray.swift#L88<br>&gt;<br>&gt;<br>&gt; public func indexes(pageIndex: Int) -&gt; Range&lt;Index&gt; {<br>&gt;     assert(pageIndex &gt;= startPageIndex &amp;&amp; pageIndex &lt;= lastPageIndex,<br>&gt; &quot;Page index out of bounds&quot;)<br>&gt;<br>&gt;     let startIndex: Index = (pageIndex-startPageIndex)*pageSize<br>&gt;     let endIndex: Index<br>&gt;     if pageIndex == lastPageIndex {<br>&gt;         endIndex = count<br>&gt;     } else {<br>&gt;         endIndex = startIndex+pageSize<br>&gt;     }<br>&gt;<br>&gt;     return (startIndex..&lt;endIndex)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; wouldn&#39;t be required anymore before accessing the array, having simply<br>&gt; something like<br>&gt;<br>&gt; &gt; let current = pageIndex * pageSize<br>&gt; &gt; array[safe: (current - pageSize) ..&lt; (current + pageSize)]<br>&gt;<br>&gt; (or *truncate* according to the user expectation) instead, which in my<br>&gt; opinion looks much more elegant and handy.<br>&gt;<br>&gt;<br>&gt; Regards,<br>&gt;<br>&gt; - Luis<br>&gt;<br>&gt; On Wed, Apr 13, 2016 at 7:37 PM, Vladimir.S via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On 13.04.2016 19:59, Pyry Jahkola wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On 13 Apr 2016, at 17:53, Luis Henrique B. Sousa &lt;lshsousa at gmail.com<br>&gt;&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;lshsousa at gmail.com&#39;);&gt;<br>&gt;&gt;&gt;&gt; &lt;mailto:lshsousa at gmail.com<br>&gt;&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;lshsousa at gmail.com&#39;);&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; (…) I totally agree with @Vladimir that we could have a more clear and<br>&gt;&gt;&gt;&gt; /swift-ly/ way to concisely wrap those operations.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The behaviour pointed out by him looks very nice and doable to me.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; a = [1,2,3]<br>&gt;&gt;&gt;&gt; a[-1..&lt;6] - raises runtime error (right behavior by default, doesn&#39;t<br>&gt;&gt;&gt;&gt; affect existing code)<br>&gt;&gt;&gt;&gt; a[truncate: -1..&lt;6] - produces [1,2,3] (the very behaviour I proposed<br>&gt;&gt;&gt;&gt; initially)<br>&gt;&gt;&gt;&gt; a[safe: -1..&lt;6] - produces nil (i.e [T]?) (no runtime errors and makes<br>&gt;&gt;&gt;&gt; it<br>&gt;&gt;&gt;&gt; easy to handle unexpected results)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don&#39;t feel strongly about this. Yes, if this were shorter to express,<br>&gt;&gt;&gt; it<br>&gt;&gt;&gt; would feel like /nicer/ design. But what Haravikk and Chris L. already<br>&gt;&gt;&gt; said<br>&gt;&gt;&gt; seems to me as /wiser/ design.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; IMO it is not just nicer, it provides you with handy and explicit<br>&gt;&gt; alternatives.<br>&gt;&gt;<br>&gt;&gt; In some situations, you are checking bounds and you sure that if you<br>&gt;&gt; calculated them incorrectly - error will be raised.<br>&gt;&gt; But sometimes, you don&#39;t need to check exact bounds, probably &quot;take these<br>&gt;&gt; values, or give me nil of no such&quot;.<br>&gt;&gt;<br>&gt;&gt; I can compare this with Dictionary we have in Swift.<br>&gt;&gt; Can you say if it is &quot;wise&quot; to return Optional(T) when we calls<br>&gt;&gt; dict[somekey] ? Probably it is wise to raise error if there is no such key?<br>&gt;&gt; (to force us to check the key first).<br>&gt;&gt;<br>&gt;&gt; The proposed subscript for special situations when you know you need<br>&gt;&gt; exactly this behavior to make your code clear and readable and you fully<br>&gt;&gt; controls code&amp;error flow.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; (@Vladimir: Besides, I&#39;m sure `.clamped(to:)` wasn&#39;t invented for this<br>&gt;&gt;&gt; purpose but for doing interval arithmetic on ranges. It just happens to<br>&gt;&gt;&gt; somewhat work here.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; – Would this feature really provide a measurable benefit to developers?<br>&gt;&gt;&gt; – Under which circumstances do you find yourself with a past-the-end<br>&gt;&gt;&gt; upper<br>&gt;&gt;&gt; bound such as 6 where `a.count == 3`?<br>&gt;&gt;&gt; – …Let alone a /negative/ start index like `-1`?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I find cases like these to be much more common in languages like Python<br>&gt;&gt;&gt; and<br>&gt;&gt;&gt; Ruby where e.g. `array[-2]` refers to the penultimate element. Swift<br>&gt;&gt;&gt; doesn&#39;t seem to want to go there.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; Each good feature will provide benefit to developers. For those, who work<br>&gt;&gt; a lot with arrays/bounds/slices/copies this will provide measurable<br>&gt;&gt; benefit, IMO.<br>&gt;&gt; Can we live without such improvement? Absolutely. Are there more<br>&gt;&gt; important proposals? Yes. But will this make Swift more elegant, handy,<br>&gt;&gt; clear? Yes, I believe.<br>&gt;&gt;<br>&gt;&gt; As for &quot;Under which circumstances..&quot; questions. Well.. something like<br>&gt;&gt; &quot;get +- 5 elements(at max) with center in some index&quot;<br>&gt;&gt;<br>&gt;&gt; let a = [1,2,3,4,5,6]<br>&gt;&gt; let index = random(0..&lt;a.count)<br>&gt;&gt; let result = a[truncate: index-5...index+5]<br>&gt;&gt;<br>&gt;&gt; or &quot;get 5 elements from index, if no 5 elements from index - return empty<br>&gt;&gt; array&quot;<br>&gt;&gt;<br>&gt;&gt; let a = [1,2,3,4,5,6]<br>&gt;&gt; let index = random(0..&lt;a.count)<br>&gt;&gt; if let result = a[safe: index..&lt;index+5]  //[Int]?<br>&gt;&gt;  {return result}<br>&gt;&gt; else<br>&gt;&gt;  {return []}<br>&gt;&gt;<br>&gt;&gt; Something like this.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; For the use cases I can think of, Swift 3—as the proposal currently goes<br>&gt;&gt;&gt; &lt;<br>&gt;&gt;&gt; https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/Collection.swift#L724-L808<br>&gt;&gt;&gt; &gt;—already<br>&gt;&gt;&gt; offers the following suitable methods:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;      array[bounds]<br>&gt;&gt;&gt;      array.prefix(maxLength)// no precondition<br>&gt;&gt;&gt;      array.prefix(upTo: index)<br>&gt;&gt;&gt;      array.prefix(through: index)<br>&gt;&gt;&gt;      array.dropLast(n)// no precondition<br>&gt;&gt;&gt;      array.dropFirst(n)// no precondition<br>&gt;&gt;&gt;      array.suffix(from: index)<br>&gt;&gt;&gt;      array.suffix(maxLength)      // no precondition<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If these feel too clumsy to use, maybe we should focus on making them all<br>&gt;&gt;&gt; more convenient. Ideally, that suggestion would apply to all<br>&gt;&gt;&gt; `Collection`s.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; — Pyry<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; Yes, some variants can be covered by these methods:<br>&gt;&gt; array.prefix(maxLength) -&gt; array[truncate: 0..&lt;maxLength]<br>&gt;&gt; array.prefix(upTo) -&gt; array[0..&lt;upTo]<br>&gt;&gt; array.prefix(through) -&gt; array[0...through]<br>&gt;&gt;<br>&gt;&gt; And some has no good alternatives in subscription:<br>&gt;&gt; array.suffix(from: index) -&gt; array[truncate: index...Int.max ??<br>&gt;&gt; array.suffix(maxLength)   -&gt; array[truncate: hm..<br>&gt;&gt;<br>&gt;&gt; But. As array[bound] returns a copy(slice) of array, it feels natural to<br>&gt;&gt; have variants of behavior of array[bound], just like you have different<br>&gt;&gt; variants of prefix() methods.<br>&gt;&gt;<br>&gt;&gt; So it seems for me like this proposal for subscript variants(safe: &amp;<br>&gt;&gt; truncate:) is good addition to then proposal you pointed to.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>Obrigado.<br>Daniel Quirino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/83d6c1b6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
