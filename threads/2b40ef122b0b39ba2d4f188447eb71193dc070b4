<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>Collection&#39;s &quot;past the end&quot; endIndex</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>July  2, 2016 at 06:00:00pm</p></header><div class="content"><p>Why is endIndex one greater than the last valid subscript argument, rather than simply the last valid subscript argument? I’m sure there are great reasons for this, but I just can’t think of them myself.<br></p><p>I’m implementing a binary tree and I want to implement BidirectionalCollection. Each index contains a (private) reference to the corresponding node in the tree. However, endIndex shouldn’t point to anything, and it makes things very complicated if I want a constant time implementation of index(before:). How are we supposed to deal with endIndex if the index is something more complex than a simple integer?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Collection&#39;s &quot;past the end&quot; endIndex</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>July  2, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 2, 2016, at 9:48 AM, Tim Vermeulen via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Why is endIndex one greater than the last valid subscript argument, rather than simply the last valid subscript argument? I’m sure there are great reasons for this, but I just can’t think of them myself.<br></p><p>It’s hard to handle empty collections, otherwise. If endIndex were the last valid subscript, then in an empty collection what would its value be? Presumably it would have to point to one before the start, which is rather weird because that’s never a valid index (in an int-indexed collection it would be negative.) Even worse, endIndex is never reachable from startIndex, so an iteration can’t simply continue until it reaches the endIndex. Instead the Indexable type would have to implement a (cheap, constant-time) &gt;= operator to use as the test for an iteration.<br></p><p>These are probably the reasons why C++ also uses the convention of a collection’s end() pointing to one past the end.<br></p><p>&gt; I’m implementing a binary tree and I want to implement BidirectionalCollection. Each index contains a (private) reference to the corresponding node in the tree. However, endIndex shouldn’t point to anything, and it makes things very complicated if I want a constant time implementation of index(before:).<br></p><p>Have the tree object keep a pointer to its last node. That makes it cheap to get that node as the ‘before’ of the last node. You’ll also have the benefit of making endIndex() itself constant-time, whereas presumably it’s now O(log n) since you have to walk down the tree to find it.<br></p><p>Or alternatively, you could add a flag to your index type that indicates it’s pointing to the end of the collection. Then the endIndex() really points to the last node but has the flag set.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160702/d7915419/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>Collection&#39;s &quot;past the end&quot; endIndex</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>July  2, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 2 Jul 2016, at 20:40, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 2, 2016, at 9:48 AM, Tim Vermeulen via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Why is endIndex one greater than the last valid subscript argument, rather than simply the last valid subscript argument? I’m sure there are great reasons for this, but I just can’t think of them myself.<br>&gt; <br>&gt; It’s hard to handle empty collections, otherwise. If endIndex were the last valid subscript, then in an empty collection what would its value be? Presumably it would have to point to one before the start, which is rather weird because that’s never a valid index (in an int-indexed collection it would be negative.) Even worse, endIndex is never reachable from startIndex, so an iteration can’t simply continue until it reaches the endIndex. Instead the Indexable type would have to implement a (cheap, constant-time) &gt;= operator to use as the test for an iteration.<br>&gt; <br>&gt; These are probably the reasons why C++ also uses the convention of a collection’s end() pointing to one past the end.<br></p><p>Thanks Jens, that makes sense. An alternative to the current model would be to require an implementation of isEmpty, and in the case that it evaluates to true, startIndex and endIndex aren’t considered. That isn’t as clean as the current model though, and I don’t doubt that the core Swift team thought this out very well.<br></p><p>&gt; <br>&gt;&gt; I’m implementing a binary tree and I want to implement BidirectionalCollection. Each index contains a (private) reference to the corresponding node in the tree. However, endIndex shouldn’t point to anything, and it makes things very complicated if I want a constant time implementation of index(before:).<br>&gt; <br>&gt; Have the tree object keep a pointer to its last node. That makes it cheap to get that node as the ‘before’ of the last node. You’ll also have the benefit of making endIndex() itself constant-time, whereas presumably it’s now O(log n) since you have to walk down the tree to find it.<br></p><p>You’re right, I need to keep a reference to the last node anyways to ensure constant time access to endIndex. This was a bigger issue when I implemented a singly linked list, but I was able to implement a nice workaround.<br></p><p>&gt; <br>&gt; Or alternatively, you could add a flag to your index type that indicates it’s pointing to the end of the collection. Then the endIndex() really points to the last node but has the flag set.<br></p><p>I also did this before, but it made everything less elegant than it needed to be. Thanks for your suggestions, I’ll stick with keeping a reference to the last node.<br></p><p>&gt; <br>&gt; —Jens<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160702/72db6838/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Collection&#39;s &quot;past the end&quot; endIndex</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July  2, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 2, 2016, at 11:40 AM, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; It’s hard to handle empty collections, otherwise. If endIndex were the last valid subscript, then in an empty collection what would its value be? Presumably it would have to point to one before the start, which is rather weird because that’s never a valid index (in an int-indexed collection it would be negative.) Even worse, endIndex is never reachable from startIndex, so an iteration can’t simply continue until it reaches the endIndex. Instead the Indexable type would have to implement a (cheap, constant-time) &gt;= operator to use as the test for an iteration.<br></p><p>To add to Jens&#39;s point, all of this adds up to simplify iterating over a collection with a `while` loop (remember, all loops are `while` loops eventually):<br>	<br>	// Without invalid endIndex:<br>	<br>	var index = c.startIndex<br>	var done = c.isEmpty<br>		<br>	while !done {<br>		...<br>		<br>		if index == c.endIndex {<br>			done = true<br>		}<br>		else {<br>			index = c.index(after: index)<br>		}<br>	}<br></p><p>	// With invalid endIndex:<br>	<br>	var index = c.startIndex<br>	while index != c.endIndex {<br>		...<br>		index = c.index(after: index)<br>	}<br></p><p>There are even more reasons than this one. For instance, having `endIndex` be past the end means that `insert(_:at:)` can insert after the last element of the collection, in addition to before any other element. It gives other range-based APIs similar powers. It means that `distance(from: startIndex, to: endIndex)` is the count of the elements in the collection. It means you natively use `Range` instead of `ClosedRange`, which (perhaps counterintuitively) is easier to reason about. And so on.<br></p><p>The manuscripts of famed computer scientist Edsger Dijkstra include a little note about ranges and zero-based indexes; its logic is intimately related to this: https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
