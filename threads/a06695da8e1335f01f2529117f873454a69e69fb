<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[idle] COW wrapper in 30 lines</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March  9, 2016 at 09:00:00am</p></header><div class="content"><p>Just for fun, I wrote a wrapper for COW types that don&#39;t need the flexible inline storage of ManagedBuffer. It turned out to be pretty straightforward, though I didn&#39;t bother with materializeForSet and thus am incurring the cost of many extra value copies on mutation. The major downside is having to forward all operations through, something I&#39;m sure the implementers of Array and Dictionary are very used to!<br></p><p>Disclaimer: This is not performant; don&#39;t use it in your app.<br></p><p>Jordan<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160309/a06669fb/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: cow.swift<br>Type: application/octet-stream<br>Size: 982 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160309/a06669fb/attachment.obj&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160309/a06669fb/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18c60397fcda8f42900d42ba4db4f029?s=50"></div><header><strong>[idle] COW wrapper in 30 lines</strong> from <string>Nadav Rotem</string> &lt;nrotem at apple.com&gt;<p>March  9, 2016 at 09:00:00am</p></header><div class="content"><p>HI Jordan, <br></p><p>Very Nice!    <br></p><p>There is a similar implementation and discussion about performance here:<br></p><p>https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#advice-use-copy-on-write-semantics-for-large-values<br></p><p>-Nadav<br></p><p><br>&gt; On Mar 9, 2016, at 9:39 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Just for fun, I wrote a wrapper for COW types that don&#39;t need the flexible inline storage of ManagedBuffer. It turned out to be pretty straightforward, though I didn&#39;t bother with materializeForSet and thus am incurring the cost of many extra value copies on mutation. The major downside is having to forward all operations through, something I&#39;m sure the implementers of Array and Dictionary are very used to!<br>&gt; <br>&gt; Disclaimer: This is not performant; don&#39;t use it in your app.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; &lt;cow.swift&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160309/da92261c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[idle] COW wrapper in 30 lines</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March  9, 2016 at 09:00:00am</p></header><div class="content"><p>Ha, I remember this document, but forgot it included an implementation. Encouraging to see that it&#39;s pretty much identical.<br></p><p>The concrete type forwarding logic is something we ought to be able to simplify somehow (with new language features).<br></p><p>Jordan<br></p><p><br>&gt; On Mar 9, 2016, at 9:50 , Nadav Rotem &lt;nrotem at apple.com&gt; wrote:<br>&gt; <br>&gt; HI Jordan, <br>&gt; <br>&gt; Very Nice!    <br>&gt; <br>&gt; There is a similar implementation and discussion about performance here:<br>&gt; <br>&gt; https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#advice-use-copy-on-write-semantics-for-large-values &lt;https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#advice-use-copy-on-write-semantics-for-large-values&gt;<br>&gt; <br>&gt; -Nadav<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 9, 2016, at 9:39 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Just for fun, I wrote a wrapper for COW types that don&#39;t need the flexible inline storage of ManagedBuffer. It turned out to be pretty straightforward, though I didn&#39;t bother with materializeForSet and thus am incurring the cost of many extra value copies on mutation. The major downside is having to forward all operations through, something I&#39;m sure the implementers of Array and Dictionary are very used to!<br>&gt;&gt; <br>&gt;&gt; Disclaimer: This is not performant; don&#39;t use it in your app.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; &lt;cow.swift&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160309/ab850ce0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>[idle] COW wrapper in 30 lines</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>March 10, 2016 at 07:00:00am</p></header><div class="content"><p>Nice!<br></p><p>As you have mentioned, unfortunately, this does not work on nested types without spurious copies (e.g. for foo.left.value.right.value = …). You would need to implement this with a mutableAddressor. Unfortunately, doing so requires Builtins and so this can’t currently be done outside of the standard library (without nasty flags).<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: 0001-A-copy-on-write-data-type.patch<br>Type: application/octet-stream<br>Size: 4157 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160310/70202fbf/attachment.obj&gt;<br>-------------- next part --------------<br></p><p><br>I agree with you that some interface forwarding would be an awesome language feature to have.<br></p><p>It would allow for implementing an indirect storage wrapper without lots of boilerplate.<br></p><p>Consider an example where you have value types that implement a protocol:<br></p><p><br>public _MyProtoWithoutAsscociatedType {<br>}<br></p><p>public protocol MyProtocol : MyProtoWithoutAsscociatedType {<br>  associatedtype Assoc<br></p><p>  public func doThis(v : Assoc)<br>  public func doThat()<br></p><p>  public static func initAssocType() -&gt; Assoc<br></p><p>}<br></p><p>struct MyProtocolImplementation : MyProtocol {<br>  typealias Assoc = Int<br>  var a : AReference<br>  var b : AReference<br>  var c : AReference<br>  var d : Double<br></p><p>  func doThis(v: Assoc) {…}<br>  func doThat() {…}<br></p><p>  static func initAssocType() -&gt; Assoc {<br>    return 0<br>  }<br>}<br></p><p>Your application passes those value types as existential values or as generic values because the architecture requires that. This can incur lots of allocations at every value copy for this example value type because we don’t fit in the inline buffer (three pointer words) which would be allocated inline (on the stack or as a stored property for existentials).<br></p><p>One way to work around this is today is make your value type’s storage indirect via a wrapper such that it will always fit in inline storage.<br></p><p>class _BoxStorage&lt;T&gt; {<br>    final var value: T<br></p><p>    init(_ elt: T) {<br>        value = elt<br>    }<br>}<br></p><p>public struct Indirect&lt;V : MyProtocol&gt; : MyProcotol {<br></p><p>    public typealias Assoc = V.Assoc<br></p><p>    final var _storage: _BoxStorage&lt;V&gt;<br></p><p>    public init(_ elt: V) {<br>        _storage = _BoxStorage(elt)<br>    }<br></p><p>    internal var value: V {<br>        get {<br>            return _storage.value<br>        }<br>        mutableAddressWithNativeOwner {<br>            if !isUniquelyReferencedNonObjC(&amp;_storage) {<br>                _storage = _BoxStorage(_storage.value)<br>            }<br>            return (<br>                UnsafeMutablePointer(Builtin.addressof(&amp;_storage.value)),<br>                Builtin.castToNativeObject(_storage))<br>        }<br>    }<br></p><p>    public static func initAssocType() -&gt; Assoc {<br>        return Assoc.initAssocType()<br>    }<br></p><p>    public func doThis(v: Assoc) {<br>      value.doThis(v)<br>    }<br>    public func doThat() {<br>      value.doThat()<br>    }<br>}<br></p><p>Indeed, doing so would require a lot of boiler plate.<br></p><p><br>Instead the following would be much nicer:<br></p><p>public struct Indirect&lt;V : MyProtocol&gt; : MyProcotol {<br></p><p>    public typealias Assoc = V.Assoc<br></p><p>    final var _storage: _BoxStorage&lt;V&gt;<br></p><p>    public init(_ elt: V) {<br>        _storage = _BoxStorage(elt)<br>    }<br></p><p>    internal forwarding var value: V as MyProtocol {<br>        typealias Assoc = V.Assoc<br></p><p>        get {<br>            return _storage.value<br>        }<br>        mutableAddressWithNativeOwner {<br>            if !isUniquelyReferencedNonObjC(&amp;_storage) {<br>                _storage = _BoxStorage(_storage.value)<br>            }<br>            return (<br>                UnsafeMutablePointer(Builtin.addressof(&amp;_storage.value)),<br>                Builtin.castToNativeObject(_storage))<br>        }<br>    }<br></p><p>}<br></p><p><br></p><p>&gt; On Mar 9, 2016, at 9:53 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Ha, I remember this document, but forgot it included an implementation. Encouraging to see that it&#39;s pretty much identical.<br>&gt; <br>&gt; The concrete type forwarding logic is something we ought to be able to simplify somehow (with new language features).<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 9, 2016, at 9:50 , Nadav Rotem &lt;nrotem at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; HI Jordan, <br>&gt;&gt; <br>&gt;&gt; Very Nice!    <br>&gt;&gt; <br>&gt;&gt; There is a similar implementation and discussion about performance here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#advice-use-copy-on-write-semantics-for-large-values<br>&gt;&gt; <br>&gt;&gt; -Nadav<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 9, 2016, at 9:39 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just for fun, I wrote a wrapper for COW types that don&#39;t need the flexible inline storage of ManagedBuffer. It turned out to be pretty straightforward, though I didn&#39;t bother with materializeForSet and thus am incurring the cost of many extra value copies on mutation. The major downside is having to forward all operations through, something I&#39;m sure the implementers of Array and Dictionary are very used to!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Disclaimer: This is not performant; don&#39;t use it in your app.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;cow.swift&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[idle] COW wrapper in 30 lines</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 10, 2016 at 09:00:00am</p></header><div class="content"><p>Wouldn&#39;t materializeForSet be good enough? I guess that&#39;s one extra copy if you don&#39;t want to rely on things not guaranteed by the language (i.e. &quot;fields of classes have stable addresses&quot;).<br></p><p>Jordan<br></p><p><br>&gt; On Mar 10, 2016, at 7:43 , Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt; <br>&gt; Nice!<br>&gt; <br>&gt; As you have mentioned, unfortunately, this does not work on nested types without spurious copies (e.g. for foo.left.value.right.value = …). You would need to implement this with a mutableAddressor. Unfortunately, doing so requires Builtins and so this can’t currently be done outside of the standard library (without nasty flags).<br>&gt; <br>&gt; &lt;0001-A-copy-on-write-data-type.patch&gt;<br>&gt; <br>&gt; I agree with you that some interface forwarding would be an awesome language feature to have.<br>&gt; <br>&gt; It would allow for implementing an indirect storage wrapper without lots of boilerplate.<br>&gt; <br>&gt; Consider an example where you have value types that implement a protocol:<br>&gt; <br>&gt; <br>&gt; public _MyProtoWithoutAsscociatedType {<br>&gt; }<br>&gt; <br>&gt; public protocol MyProtocol : MyProtoWithoutAsscociatedType {<br>&gt;  associatedtype Assoc<br>&gt; <br>&gt;  public func doThis(v : Assoc)<br>&gt;  public func doThat()<br>&gt; <br>&gt;  public static func initAssocType() -&gt; Assoc<br>&gt; <br>&gt; }<br>&gt; <br>&gt; struct MyProtocolImplementation : MyProtocol {<br>&gt;  typealias Assoc = Int<br>&gt;  var a : AReference<br>&gt;  var b : AReference<br>&gt;  var c : AReference<br>&gt;  var d : Double<br>&gt; <br>&gt;  func doThis(v: Assoc) {…}<br>&gt;  func doThat() {…}<br>&gt; <br>&gt;  static func initAssocType() -&gt; Assoc {<br>&gt;    return 0<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; Your application passes those value types as existential values or as generic values because the architecture requires that. This can incur lots of allocations at every value copy for this example value type because we don’t fit in the inline buffer (three pointer words) which would be allocated inline (on the stack or as a stored property for existentials).<br>&gt; <br>&gt; One way to work around this is today is make your value type’s storage indirect via a wrapper such that it will always fit in inline storage.<br>&gt; <br>&gt; class _BoxStorage&lt;T&gt; {<br>&gt;    final var value: T<br>&gt; <br>&gt;    init(_ elt: T) {<br>&gt;        value = elt<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; public struct Indirect&lt;V : MyProtocol&gt; : MyProcotol {<br>&gt; <br>&gt;    public typealias Assoc = V.Assoc<br>&gt; <br>&gt;    final var _storage: _BoxStorage&lt;V&gt;<br>&gt; <br>&gt;    public init(_ elt: V) {<br>&gt;        _storage = _BoxStorage(elt)<br>&gt;    }<br>&gt; <br>&gt;    internal var value: V {<br>&gt;        get {<br>&gt;            return _storage.value<br>&gt;        }<br>&gt;        mutableAddressWithNativeOwner {<br>&gt;            if !isUniquelyReferencedNonObjC(&amp;_storage) {<br>&gt;                _storage = _BoxStorage(_storage.value)<br>&gt;            }<br>&gt;            return (<br>&gt;                UnsafeMutablePointer(Builtin.addressof(&amp;_storage.value)),<br>&gt;                Builtin.castToNativeObject(_storage))<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt;    public static func initAssocType() -&gt; Assoc {<br>&gt;        return Assoc.initAssocType()<br>&gt;    }<br>&gt; <br>&gt;    public func doThis(v: Assoc) {<br>&gt;      value.doThis(v)<br>&gt;    }<br>&gt;    public func doThat() {<br>&gt;      value.doThat()<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; Indeed, doing so would require a lot of boiler plate.<br>&gt; <br>&gt; <br>&gt; Instead the following would be much nicer:<br>&gt; <br>&gt; public struct Indirect&lt;V : MyProtocol&gt; : MyProcotol {<br>&gt; <br>&gt;    public typealias Assoc = V.Assoc<br>&gt; <br>&gt;    final var _storage: _BoxStorage&lt;V&gt;<br>&gt; <br>&gt;    public init(_ elt: V) {<br>&gt;        _storage = _BoxStorage(elt)<br>&gt;    }<br>&gt; <br>&gt;    internal forwarding var value: V as MyProtocol {<br>&gt;        typealias Assoc = V.Assoc<br>&gt; <br>&gt;        get {<br>&gt;            return _storage.value<br>&gt;        }<br>&gt;        mutableAddressWithNativeOwner {<br>&gt;            if !isUniquelyReferencedNonObjC(&amp;_storage) {<br>&gt;                _storage = _BoxStorage(_storage.value)<br>&gt;            }<br>&gt;            return (<br>&gt;                UnsafeMutablePointer(Builtin.addressof(&amp;_storage.value)),<br>&gt;                Builtin.castToNativeObject(_storage))<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Mar 9, 2016, at 9:53 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Ha, I remember this document, but forgot it included an implementation. Encouraging to see that it&#39;s pretty much identical.<br>&gt;&gt; <br>&gt;&gt; The concrete type forwarding logic is something we ought to be able to simplify somehow (with new language features).<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 9, 2016, at 9:50 , Nadav Rotem &lt;nrotem at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; HI Jordan, <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Very Nice!    <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is a similar implementation and discussion about performance here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#advice-use-copy-on-write-semantics-for-large-values<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Nadav<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 9, 2016, at 9:39 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just for fun, I wrote a wrapper for COW types that don&#39;t need the flexible inline storage of ManagedBuffer. It turned out to be pretty straightforward, though I didn&#39;t bother with materializeForSet and thus am incurring the cost of many extra value copies on mutation. The major downside is having to forward all operations through, something I&#39;m sure the implementers of Array and Dictionary are very used to!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Disclaimer: This is not performant; don&#39;t use it in your app.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &lt;cow.swift&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160310/a907a7eb/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
