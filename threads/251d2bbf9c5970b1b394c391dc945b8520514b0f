<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>March 22, 2016 at 05:00:00pm</p></header><div class="content"><p>Yes and No.<br>Yes, because this is a problem I run into all the time, and I really want swift to have a solution for it. I especially like Brent’s idea of a protocol init.<br>No, because I have gotten a bit greedy. I want us to take a step back and look at the underlying problem to see if we can come up with something which completely solves it… and I think factories get us only part way there. Let’s take a moment and see if we can create something uniquely swift before we copy/paste existing solutions.<br>Think about Cocoa’s class clusters for a moment. I love them, but they are a pain to subclass. To the level where any beginning Cocoa instruction tells you explicitly not to subclass them. Similarly, even in my own factories, they are always a pain to extend.<br>I want our factory inits to be extensible by default.<br></p><p>By extensible, I mean that I want to be able to add a new subclass (or a new entity satisfying a protocol), and have it come out of the factory when appropriate without editing the base class! Madness, I know, but:<br>1) I may not have access to the source of the base class (e.g. Cocoa Collections)<br>2) I always feel a bit dirty giving the base class knowledge of it’s subclasses<br>3) It is a royal pain, and a potential source of errors as things get refactored when adding new subclasses<br></p><p>I think I have at least the seed of an idea of how to solve this, and I am hoping that one of you (who are all much smarter than I) might have the key to getting it the rest of the way.<br>I ran into this problem again last week, and it made me think of an old language I used to use...<br>There was a small programming language I used to use in the 90’s which had an interesting core language feature we called “handlers”. These were a lot like registering for notifications, except that writing a function (with a special “Handler” attribute: “Handler func myFuncName()&quot;) was all you needed to do to register. Writing “Handle myFuncName()” would then systematically call every function with that name and the Handler attribute.<br>That is, instead of calling a single function, it would systematically call a series of functions (all with the same name).<br>There was one other thing that made these handlers special. Each one had the option, when it was called, to reply that it was the one true handler, and the others didn’t need to be called. Basically, it said “I&#39;ve got this!”. This even allowed it to return a result to the caller.<br>The original intent of this feature (and why it was a core language feature) was to handle events. It would handle things like hit testing and key events fairly elegantly. It was a powerful feature, so it was quickly used for other things. It made things like plug-ins ridiculously simple. We even used it for a form of error handling.<br>I remember helping to write a page layout program in it, and we used handlers not just for the hit testing, but for the tool palette as well. The end result was that you were able to add new shapes and new tools without modifying existing code at all. It is a feature I miss all the time...<br></p><p>That is more power than we need here, but it provided me the inspiration for a potential solution to the factory problem. Back to swift…<br></p><p>The idea here is to give each interested subclass a chance to say “I&#39;ve got this!”. The factory init runs through each of the subclasses’ overrides until it finds one that doesn’t return nil. New subclasses can be added and they will be given a chance as well (without modifying the base class). The first subclass to successfully init wins. (only subclasses which override the factory init would be considered)<br></p><p>class AbstractBase {<br>    public factory init?(type: InformationToSwitchOn){<br>        //I like having an explicit call, so that the traditional (non-distributed) factory is possible as well<br>        return factory.init(type) //We could also call this “subclass.init(type)” to mirror super<br>    }<br>}<br>class ConcreteImplementation : AbstractBase {<br>    public factory override init?(type: InformationToSwitchOn){<br>        guard type == compatibleWithThisType else {return nil} //If info doesn’t work for us, we return nil, and the next class gets a shot<br>	//Init concrete type here<br>    }<br>}<br></p><p>The main issue which still needs to be solved is that the order they get called sometimes really matters (this was solved by a well defined ordering + IDE features in the language mentioned above). For the most part, as long as subclasses are called before their superclasses (or there is a some method for cascading), it works. There are still times where you want to define a specific ordering though (e.g. a new subclass wants to get called before an existing subclasses to override some of it’s use cases).<br>I see a few options (and I would love to hear more):<br>- subclasses define a numeric precedence (similar to operators now). This is probably the most effective stop-gap solution, but is not elegant.<br>- subclasses do whatever we change operator precedence to do in the future<br>- optionally allow subclasses to name another specific subclass that they are before/after<br>- allow subclasses to declare that they would like to be earlier or later (or that they don’t care) in the calling list. subclasses defined outside of the module where the base class was defined would be placed more extremely early/late. Exact order is undefined, but rough ordering is possible.<br>- return (to the superclass) an array of all subclasses which successfully inited. It can then select which one it wants and return it. This seems overly inefficient to me, since you are initializing a bunch of unused objects.<br>- &lt;Your idea here&gt;<br></p><p>The end result is that you can extend factories of both classes and protocols without access to the original source code.  <br></p><p>I also don’t think that the base should always need to be abstract. Factory inits should allow returning subclasses as a way of replacing themselves with a subclass, and returning nil if they are failable, but if there is no return (or return self), it can create an instance of itself. This way, it provides a customization point where subclasses can handle special cases, but the class itself provides an obvious default (i.e. a much less messy form of class cluster).<br></p><p>class Base {<br>    public factory init(type: InformationToSwitchOn){<br>	if let subclass = factory.init(type){<br>	    return subclass<br>	}<br>	return self.init()//If subclasses didn’t work, initialize ourselves<br>    }<br>}<br></p><p>Thoughts?  Too crazy to consider?<br></p><p>Thanks,<br>Jon<br></p><p>On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br></p><p>&gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt; <br>&gt;&gt; # Factory Initializers<br>&gt;&gt; <br>&gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt; <br>&gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt; <br>&gt;&gt; class AbstractBase {<br>&gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt; <br>&gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt; <br>&gt;&gt; ## Protocol Initializers<br>&gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt; <br>&gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt; <br>&gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Riley Testut<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt; <br>&gt; Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160322/251d4b0f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 23, 2016 at 05:00:00pm</p></header><div class="content"><p>In Smalltalk we often used something like the following which is almost exactly what Jonathan suggested:<br></p><p>fromData: data<br>    self subclasses <br>            do: [:subclass | (subclass fromData: data) ifNotNil: [:instance | ^instance]].<br>    ^nil<br></p><p>The relevant feature being used here is the class method #subclasses which just returns a collection of the subclasses. The advantage here is that no special language feature is needed.<br>The order of the subclasses is given as depth first order with children being ordered alphabetically. Having a more powerful concept available here as suggested by Jonathan might certainly be useful in some cases.<br></p><p>-Thorsten <br></p><p><br>&gt; Am 23.03.2016 um 01:21 schrieb Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt; Yes and No.<br>&gt; Yes, because this is a problem I run into all the time, and I really want swift to have a solution for it. I especially like Brent’s idea of a protocol init.<br>&gt; No, because I have gotten a bit greedy. I want us to take a step back and look at the underlying problem to see if we can come up with something which completely solves it… and I think factories get us only part way there. Let’s take a moment and see if we can create something uniquely swift before we copy/paste existing solutions.<br>&gt; Think about Cocoa’s class clusters for a moment. I love them, but they are a pain to subclass. To the level where any beginning Cocoa instruction tells you explicitly not to subclass them. Similarly, even in my own factories, they are always a pain to extend.<br>&gt; I want our factory inits to be extensible by default.<br>&gt; <br>&gt; By extensible, I mean that I want to be able to add a new subclass (or a new entity satisfying a protocol), and have it come out of the factory when appropriate without editing the base class! Madness, I know, but:<br>&gt; 1) I may not have access to the source of the base class (e.g. Cocoa Collections)<br>&gt; 2) I always feel a bit dirty giving the base class knowledge of it’s subclasses<br>&gt; 3) It is a royal pain, and a potential source of errors as things get refactored when adding new subclasses<br>&gt; <br>&gt; I think I have at least the seed of an idea of how to solve this, and I am hoping that one of you (who are all much smarter than I) might have the key to getting it the rest of the way.<br>&gt; I ran into this problem again last week, and it made me think of an old language I used to use...<br>&gt; There was a small programming language I used to use in the 90’s which had an interesting core language feature we called “handlers”. These were a lot like registering for notifications, except that writing a function (with a special “Handler” attribute: “Handler func myFuncName()&quot;) was all you needed to do to register. Writing “Handle myFuncName()” would then systematically call every function with that name and the Handler attribute.<br>&gt; That is, instead of calling a single function, it would systematically call a series of functions (all with the same name).<br>&gt; There was one other thing that made these handlers special. Each one had the option, when it was called, to reply that it was the one true handler, and the others didn’t need to be called. Basically, it said “I&#39;ve got this!”. This even allowed it to return a result to the caller.<br>&gt; The original intent of this feature (and why it was a core language feature) was to handle events. It would handle things like hit testing and key events fairly elegantly. It was a powerful feature, so it was quickly used for other things. It made things like plug-ins ridiculously simple. We even used it for a form of error handling.<br>&gt; I remember helping to write a page layout program in it, and we used handlers not just for the hit testing, but for the tool palette as well. The end result was that you were able to add new shapes and new tools without modifying existing code at all. It is a feature I miss all the time...<br>&gt; <br>&gt; That is more power than we need here, but it provided me the inspiration for a potential solution to the factory problem. Back to swift…<br>&gt; <br>&gt; The idea here is to give each interested subclass a chance to say “I&#39;ve got this!”. The factory init runs through each of the subclasses’ overrides until it finds one that doesn’t return nil. New subclasses can be added and they will be given a chance as well (without modifying the base class). The first subclass to successfully init wins. (only subclasses which override the factory init would be considered)<br>&gt; <br>&gt; class AbstractBase {<br>&gt;     public factory init?(type: InformationToSwitchOn){<br>&gt;         //I like having an explicit call, so that the traditional (non-distributed) factory is possible as well<br>&gt;         return factory.init(type) //We could also call this “subclass.init(type)” to mirror super<br>&gt;     }<br>&gt; }<br>&gt; class ConcreteImplementation : AbstractBase {<br>&gt;     public factory override init?(type: InformationToSwitchOn){<br>&gt;         guard type == compatibleWithThisType else {return nil} //If info doesn’t work for us, we return nil, and the next class gets a shot<br>&gt; 	//Init concrete type here<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; The main issue which still needs to be solved is that the order they get called sometimes really matters (this was solved by a well defined ordering + IDE features in the language mentioned above). For the most part, as long as subclasses are called before their superclasses (or there is a some method for cascading), it works. There are still times where you want to define a specific ordering though (e.g. a new subclass wants to get called before an existing subclasses to override some of it’s use cases).<br>&gt; I see a few options (and I would love to hear more):<br>&gt; - subclasses define a numeric precedence (similar to operators now). This is probably the most effective stop-gap solution, but is not elegant.<br>&gt; - subclasses do whatever we change operator precedence to do in the future<br>&gt; - optionally allow subclasses to name another specific subclass that they are before/after<br>&gt; - allow subclasses to declare that they would like to be earlier or later (or that they don’t care) in the calling list. subclasses defined outside of the module where the base class was defined would be placed more extremely early/late. Exact order is undefined, but rough ordering is possible.<br>&gt; - return (to the superclass) an array of all subclasses which successfully inited. It can then select which one it wants and return it. This seems overly inefficient to me, since you are initializing a bunch of unused objects.<br>&gt; - &lt;Your idea here&gt;<br>&gt; <br>&gt; The end result is that you can extend factories of both classes and protocols without access to the original source code.  <br>&gt; <br>&gt; I also don’t think that the base should always need to be abstract. Factory inits should allow returning subclasses as a way of replacing themselves with a subclass, and returning nil if they are failable, but if there is no return (or return self), it can create an instance of itself. This way, it provides a customization point where subclasses can handle special cases, but the class itself provides an obvious default (i.e. a much less messy form of class cluster).<br>&gt; <br>&gt; class Base {<br>&gt;     public factory init(type: InformationToSwitchOn){<br>&gt; 	if let subclass = factory.init(type){<br>&gt; 	    return subclass<br>&gt; 	}<br>&gt; 	return self.init()//If subclasses didn’t work, initialize ourselves<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Thoughts?  Too crazy to consider?<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt; &gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; # Factory Initializers<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; class AbstractBase {<br>&gt; &gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt; &gt;&gt;       return ConcreteImplementation(type)<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; ## Class Cluster/Abstract Classes<br>&gt; &gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; ## Protocol Initializers<br>&gt; &gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt; &gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Best,<br>&gt; &gt;&gt; Riley Testut<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; <br>&gt; &gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt; &gt; <br>&gt; &gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/1aa4a529/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>March 24, 2016 at 12:00:00am</p></header><div class="content"><p>While I do believe your proposed additions have their benefits, my gut tells me this is too large a change to Swift for an arguably small gain. For this proposal, I&#39;m wanting to keep the change as minimalistic as possible, while still providing enough flexibility and use cases to warrant it.<br></p><p>Interesting you bring up the registering of subclasses, as that is similar to the very original proposal, and actually similar to what I&#39;m doing in my own app. Effectively, I have an Objective-C base class, and in +load it dynamically finds all subclasses using the Objective-C runtime, and stores a reference to them. Then in the initializer, it returns the appropriate subclass based on the initialization parameters. This was my solution to the superclass not having to explicitly know each individual subclass.<br></p><p>Using factory initializers, however, this pattern could be used in pure Swift, albeit with some minor modifications. At program start, the program could register subclasses with the superclass, and then in the initializer would simply return the appropriate subclass (similar to NSURLProtocol, I believe).<br></p><p>As for rationale for protocol (factory) initializers, a common pattern I&#39;ve come across when developing my internal frameworks is to design a protocol, and then to provide a default implementation of the protocol with a type (typically a struct). I feel this relationship could be bridged easier by simply returning this type from a protocol initializer, which could even potentially allow me to declare the actual type as private, so for all intents and purposes the client does simply get an initialized protocol object (similar in part to creating an anonymous class conforming to a protocol in Java).<br></p><p>&gt; On Mar 22, 2016, at 5:21 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Yes and No.<br>&gt; Yes, because this is a problem I run into all the time, and I really want swift to have a solution for it. I especially like Brent’s idea of a protocol init.<br>&gt; No, because I have gotten a bit greedy. I want us to take a step back and look at the underlying problem to see if we can come up with something which completely solves it… and I think factories get us only part way there. Let’s take a moment and see if we can create something uniquely swift before we copy/paste existing solutions.<br>&gt; Think about Cocoa’s class clusters for a moment. I love them, but they are a pain to subclass. To the level where any beginning Cocoa instruction tells you explicitly not to subclass them. Similarly, even in my own factories, they are always a pain to extend.<br>&gt; I want our factory inits to be extensible by default.<br>&gt; <br>&gt; By extensible, I mean that I want to be able to add a new subclass (or a new entity satisfying a protocol), and have it come out of the factory when appropriate without editing the base class! Madness, I know, but:<br>&gt; 1) I may not have access to the source of the base class (e.g. Cocoa Collections)<br>&gt; 2) I always feel a bit dirty giving the base class knowledge of it’s subclasses<br>&gt; 3) It is a royal pain, and a potential source of errors as things get refactored when adding new subclasses<br>&gt; <br>&gt; I think I have at least the seed of an idea of how to solve this, and I am hoping that one of you (who are all much smarter than I) might have the key to getting it the rest of the way.<br>&gt; I ran into this problem again last week, and it made me think of an old language I used to use...<br>&gt; There was a small programming language I used to use in the 90’s which had an interesting core language feature we called “handlers”. These were a lot like registering for notifications, except that writing a function (with a special “Handler” attribute: “Handler func myFuncName()&quot;) was all you needed to do to register. Writing “Handle myFuncName()” would then systematically call every function with that name and the Handler attribute.<br>&gt; That is, instead of calling a single function, it would systematically call a series of functions (all with the same name).<br>&gt; There was one other thing that made these handlers special. Each one had the option, when it was called, to reply that it was the one true handler, and the others didn’t need to be called. Basically, it said “I&#39;ve got this!”. This even allowed it to return a result to the caller.<br>&gt; The original intent of this feature (and why it was a core language feature) was to handle events. It would handle things like hit testing and key events fairly elegantly. It was a powerful feature, so it was quickly used for other things. It made things like plug-ins ridiculously simple. We even used it for a form of error handling.<br>&gt; I remember helping to write a page layout program in it, and we used handlers not just for the hit testing, but for the tool palette as well. The end result was that you were able to add new shapes and new tools without modifying existing code at all. It is a feature I miss all the time...<br>&gt; <br>&gt; That is more power than we need here, but it provided me the inspiration for a potential solution to the factory problem. Back to swift…<br>&gt; <br>&gt; The idea here is to give each interested subclass a chance to say “I&#39;ve got this!”. The factory init runs through each of the subclasses’ overrides until it finds one that doesn’t return nil. New subclasses can be added and they will be given a chance as well (without modifying the base class). The first subclass to successfully init wins. (only subclasses which override the factory init would be considered)<br>&gt; <br>&gt; class AbstractBase {<br>&gt;     public factory init?(type: InformationToSwitchOn){<br>&gt;         //I like having an explicit call, so that the traditional (non-distributed) factory is possible as well<br>&gt;         return factory.init(type) //We could also call this “subclass.init(type)” to mirror super<br>&gt;     }<br>&gt; }<br>&gt; class ConcreteImplementation : AbstractBase {<br>&gt;     public factory override init?(type: InformationToSwitchOn){<br>&gt;         guard type == compatibleWithThisType else {return nil} //If info doesn’t work for us, we return nil, and the next class gets a shot<br>&gt; 	//Init concrete type here<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; The main issue which still needs to be solved is that the order they get called sometimes really matters (this was solved by a well defined ordering + IDE features in the language mentioned above). For the most part, as long as subclasses are called before their superclasses (or there is a some method for cascading), it works. There are still times where you want to define a specific ordering though (e.g. a new subclass wants to get called before an existing subclasses to override some of it’s use cases).<br>&gt; I see a few options (and I would love to hear more):<br>&gt; - subclasses define a numeric precedence (similar to operators now). This is probably the most effective stop-gap solution, but is not elegant.<br>&gt; - subclasses do whatever we change operator precedence to do in the future<br>&gt; - optionally allow subclasses to name another specific subclass that they are before/after<br>&gt; - allow subclasses to declare that they would like to be earlier or later (or that they don’t care) in the calling list. subclasses defined outside of the module where the base class was defined would be placed more extremely early/late. Exact order is undefined, but rough ordering is possible.<br>&gt; - return (to the superclass) an array of all subclasses which successfully inited. It can then select which one it wants and return it. This seems overly inefficient to me, since you are initializing a bunch of unused objects.<br>&gt; - &lt;Your idea here&gt;<br>&gt; <br>&gt; The end result is that you can extend factories of both classes and protocols without access to the original source code.  <br>&gt; <br>&gt; I also don’t think that the base should always need to be abstract. Factory inits should allow returning subclasses as a way of replacing themselves with a subclass, and returning nil if they are failable, but if there is no return (or return self), it can create an instance of itself. This way, it provides a customization point where subclasses can handle special cases, but the class itself provides an obvious default (i.e. a much less messy form of class cluster).<br>&gt; <br>&gt; class Base {<br>&gt;     public factory init(type: InformationToSwitchOn){<br>&gt; 	if let subclass = factory.init(type){<br>&gt; 	    return subclass<br>&gt; 	}<br>&gt; 	return self.init()//If subclasses didn’t work, initialize ourselves<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Thoughts?  Too crazy to consider?<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt; &gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; # Factory Initializers<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; class AbstractBase {<br>&gt; &gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt; &gt;&gt;       return ConcreteImplementation(type)<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; ## Class Cluster/Abstract Classes<br>&gt; &gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; ## Protocol Initializers<br>&gt; &gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt; &gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Best,<br>&gt; &gt;&gt; Riley Testut<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; <br>&gt; &gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt; &gt; <br>&gt; &gt; Charles<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/7b8ed8c3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>March 24, 2016 at 05:00:00pm</p></header><div class="content"><p>Comments inline.<br></p><p>&gt; On Mar 24, 2016, at 12:10 AM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt; <br>&gt; While I do believe your proposed additions have their benefits, my gut tells me this is too large a change to Swift for an arguably small gain. For this proposal, I&#39;m wanting to keep the change as minimalistic as possible, while still providing enough flexibility and use cases to warrant it.<br></p><p>I can definitely see the argument that extensibility is out of scope for Swift 3, but I do want to make sure that it is possible for us to have extensibility in the future (that we don’t block ourselves from doing it).<br></p><p>I strongly disagree that the gain is small.  One of the core benefits of both Swift/ObjC (and now POP) is the ability to extend things post-hoc, without access to the original code.<br></p><p>I often write libraries &amp; SDKs, so the users of my code don&#39;t have access to the original code.  I guess extensibility is less necessary when you control the entire codebase, but you still have to refactor your factory whenever you subclass (or adhere to a protocol), which I find problematic.<br></p><p>This is something I run into a lot while writing actual code, so it isn’t just a theoretical concern.<br></p><p><br></p><p>&gt; Interesting you bring up the registering of subclasses, as that is similar to the very original proposal, and actually similar to what I&#39;m doing in my own app. Effectively, I have an Objective-C base class, and in +load it dynamically finds all subclasses using the Objective-C runtime, and stores a reference to them. Then in the initializer, it returns the appropriate subclass based on the initialization parameters. This was my solution to the superclass not having to explicitly know each individual subclass.<br>&gt; <br>&gt; Using factory initializers, however, this pattern could be used in pure Swift, albeit with some minor modifications. At program start, the program could register subclasses with the superclass, and then in the initializer would simply return the appropriate subclass (similar to NSURLProtocol, I believe).<br></p><p>Yes, I have also used load in this way in ObjC.  In Swift, I think the compiler could easily build an array/table of the overloads of factory inits.  This avoids having to register explicitly (the declaration itself implies intent to register), and doesn’t take up any cycles during execution.<br></p><p>I ran into the problem of when to register the other day in a current project, as Swift doesn’t have an equivalent to +load that I am aware of.  I had to settle for something of a hack which gets called on first use… but it was only a partial solution which worked in that particular case.  How do the swift classes/enums/structs get called to register themselves?<br></p><p>We may want to propose adding a +load equivalent for Swift types, since it does come up occasionally. It is one of those things which you don’t need often, but when you do, you really need it.  Ironically, this was one of the uses of the original feature I talked about earlier (we used it to provide the equivalent of +load, awakeFromNib, etc… in the language). <br></p><p><br></p><p>&gt; As for rationale for protocol (factory) initializers, a common pattern I&#39;ve come across when developing my internal frameworks is to design a protocol, and then to provide a default implementation of the protocol with a type (typically a struct). I feel this relationship could be bridged easier by simply returning this type from a protocol initializer, which could even potentially allow me to declare the actual type as private, so for all intents and purposes the client does simply get an initialized protocol object (similar in part to creating an anonymous class conforming to a protocol in Java).<br></p><p>I strongly agree that we should have factory initializers for protocols for the reasons you state here, plus many others.  It just seems like a natural fit.<br></p><p><br>I would like to see a 3 stage approach:<br></p><p>Stage 1:  Declaring an init as “factory” allows you to return any fully inited object which fits the type (including calling self.init like a convenience init would and then returning it). If the init is failable, you can also return nil.  This works both on classes and protocols.<br></p><p>Stage 2:  The compiler builds a table of the overrides of a given factory init, and there is some syntax to call them (e.g. “let sub = subclasses.init(value)”) such that the first one to return non-nil is the return value to that call.  Thorsten’s depth first + alphabetical ordering would be adequate to make the behavior predictable.  Again, this should work for both classes and protocols. (I am open to better ideas for syntax/naming)<br></p><p>Stage 3: We allow greater control over the ordering in the table. This still needs thought both on syntax and method.  Something similar to operator precedence (or autolayout priority) would work in a pinch, but isn’t super elegant. In practice, it might be enough just to be able to declare that something needs to be before/after a specific subclass in the list.<br></p><p><br>Note: A slightly different approach to stage 2 (for classes) might have only the direct subclasses in the table, and then the subclasses have the option to call off to their own subclasses in the same manner if desired.  This has the tradeoff that each level needs to plan for extensibility (i.e. you can’t override something which wasn’t expecting to be subclassed), but I do like how it simplifies the model a bit.<br></p><p>I have a feeling that the proper syntax for stages 2/3 may become more obvious once the design work around mixins/protocols+storage gets done.  It may just fall out of the disambiguation syntax...<br></p><p>Thanks,<br>Jon<br></p><p>&gt; On Mar 22, 2016, at 5:21 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Yes and No.<br>&gt;&gt; Yes, because this is a problem I run into all the time, and I really want swift to have a solution for it. I especially like Brent’s idea of a protocol init.<br>&gt;&gt; No, because I have gotten a bit greedy. I want us to take a step back and look at the underlying problem to see if we can come up with something which completely solves it… and I think factories get us only part way there. Let’s take a moment and see if we can create something uniquely swift before we copy/paste existing solutions.<br>&gt;&gt; Think about Cocoa’s class clusters for a moment. I love them, but they are a pain to subclass. To the level where any beginning Cocoa instruction tells you explicitly not to subclass them. Similarly, even in my own factories, they are always a pain to extend.<br>&gt;&gt; I want our factory inits to be extensible by default.<br>&gt;&gt; <br>&gt;&gt; By extensible, I mean that I want to be able to add a new subclass (or a new entity satisfying a protocol), and have it come out of the factory when appropriate without editing the base class! Madness, I know, but:<br>&gt;&gt; 1) I may not have access to the source of the base class (e.g. Cocoa Collections)<br>&gt;&gt; 2) I always feel a bit dirty giving the base class knowledge of it’s subclasses<br>&gt;&gt; 3) It is a royal pain, and a potential source of errors as things get refactored when adding new subclasses<br>&gt;&gt; <br>&gt;&gt; I think I have at least the seed of an idea of how to solve this, and I am hoping that one of you (who are all much smarter than I) might have the key to getting it the rest of the way.<br>&gt;&gt; I ran into this problem again last week, and it made me think of an old language I used to use...<br>&gt;&gt; There was a small programming language I used to use in the 90’s which had an interesting core language feature we called “handlers”. These were a lot like registering for notifications, except that writing a function (with a special “Handler” attribute: “Handler func myFuncName()&quot;) was all you needed to do to register. Writing “Handle myFuncName()” would then systematically call every function with that name and the Handler attribute.<br>&gt;&gt; That is, instead of calling a single function, it would systematically call a series of functions (all with the same name).<br>&gt;&gt; There was one other thing that made these handlers special. Each one had the option, when it was called, to reply that it was the one true handler, and the others didn’t need to be called. Basically, it said “I&#39;ve got this!”. This even allowed it to return a result to the caller.<br>&gt;&gt; The original intent of this feature (and why it was a core language feature) was to handle events. It would handle things like hit testing and key events fairly elegantly. It was a powerful feature, so it was quickly used for other things. It made things like plug-ins ridiculously simple. We even used it for a form of error handling.<br>&gt;&gt; I remember helping to write a page layout program in it, and we used handlers not just for the hit testing, but for the tool palette as well. The end result was that you were able to add new shapes and new tools without modifying existing code at all. It is a feature I miss all the time...<br>&gt;&gt; <br>&gt;&gt; That is more power than we need here, but it provided me the inspiration for a potential solution to the factory problem. Back to swift…<br>&gt;&gt; <br>&gt;&gt; The idea here is to give each interested subclass a chance to say “I&#39;ve got this!”. The factory init runs through each of the subclasses’ overrides until it finds one that doesn’t return nil. New subclasses can be added and they will be given a chance as well (without modifying the base class). The first subclass to successfully init wins. (only subclasses which override the factory init would be considered)<br>&gt;&gt; <br>&gt;&gt; class AbstractBase {<br>&gt;&gt;     public factory init?(type: InformationToSwitchOn){<br>&gt;&gt;         //I like having an explicit call, so that the traditional (non-distributed) factory is possible as well<br>&gt;&gt;         return factory.init(type) //We could also call this “subclass.init(type)” to mirror super<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;     public factory override init?(type: InformationToSwitchOn){<br>&gt;&gt;         guard type == compatibleWithThisType else {return nil} //If info doesn’t work for us, we return nil, and the next class gets a shot<br>&gt;&gt; 	//Init concrete type here<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The main issue which still needs to be solved is that the order they get called sometimes really matters (this was solved by a well defined ordering + IDE features in the language mentioned above). For the most part, as long as subclasses are called before their superclasses (or there is a some method for cascading), it works. There are still times where you want to define a specific ordering though (e.g. a new subclass wants to get called before an existing subclasses to override some of it’s use cases).<br>&gt;&gt; I see a few options (and I would love to hear more):<br>&gt;&gt; - subclasses define a numeric precedence (similar to operators now). This is probably the most effective stop-gap solution, but is not elegant.<br>&gt;&gt; - subclasses do whatever we change operator precedence to do in the future<br>&gt;&gt; - optionally allow subclasses to name another specific subclass that they are before/after<br>&gt;&gt; - allow subclasses to declare that they would like to be earlier or later (or that they don’t care) in the calling list. subclasses defined outside of the module where the base class was defined would be placed more extremely early/late. Exact order is undefined, but rough ordering is possible.<br>&gt;&gt; - return (to the superclass) an array of all subclasses which successfully inited. It can then select which one it wants and return it. This seems overly inefficient to me, since you are initializing a bunch of unused objects.<br>&gt;&gt; - &lt;Your idea here&gt;<br>&gt;&gt; <br>&gt;&gt; The end result is that you can extend factories of both classes and protocols without access to the original source code.  <br>&gt;&gt; <br>&gt;&gt; I also don’t think that the base should always need to be abstract. Factory inits should allow returning subclasses as a way of replacing themselves with a subclass, and returning nil if they are failable, but if there is no return (or return self), it can create an instance of itself. This way, it provides a customization point where subclasses can handle special cases, but the class itself provides an obvious default (i.e. a much less messy form of class cluster).<br>&gt;&gt; <br>&gt;&gt; class Base {<br>&gt;&gt;     public factory init(type: InformationToSwitchOn){<br>&gt;&gt; 	if let subclass = factory.init(type){<br>&gt;&gt; 	    return subclass<br>&gt;&gt; 	}<br>&gt;&gt; 	return self.init()//If subclasses didn’t work, initialize ourselves<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Thoughts?  Too crazy to consider?<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; # Factory Initializers<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; class AbstractBase {<br>&gt;&gt; &gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt; &gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt; &gt;&gt;   }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt; &gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; ## Protocol Initializers<br>&gt;&gt; &gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt; &gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt; &gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt; &gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt; &gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; Best,<br>&gt;&gt; &gt;&gt; Riley Testut<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Charles<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/07775775/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>March 30, 2016 at 02:00:00am</p></header><div class="content"><p>Ultimately, while these are good points, I feel the full mechanism for class clusters belong in a separate proposal. The focus for this one I believe should be the underlying mechanism of factory initializers; should that be approved, then we can focus on adding additional features on top of it.<br></p><p>That being said, I’ve written up essentially a final version of the proposal, which you can find here: https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md. Assuming everyone is happy with it, I’ll send a pull request in the next few days to the main-repo. But please, give any last minute feedback now!<br></p><p>&gt; On Mar 24, 2016, at 5:12 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt; <br>&gt; Comments inline.<br>&gt; <br>&gt;&gt; On Mar 24, 2016, at 12:10 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; While I do believe your proposed additions have their benefits, my gut tells me this is too large a change to Swift for an arguably small gain. For this proposal, I&#39;m wanting to keep the change as minimalistic as possible, while still providing enough flexibility and use cases to warrant it.<br>&gt; <br>&gt; I can definitely see the argument that extensibility is out of scope for Swift 3, but I do want to make sure that it is possible for us to have extensibility in the future (that we don’t block ourselves from doing it).<br>&gt; <br>&gt; I strongly disagree that the gain is small.  One of the core benefits of both Swift/ObjC (and now POP) is the ability to extend things post-hoc, without access to the original code.<br>&gt; <br>&gt; I often write libraries &amp; SDKs, so the users of my code don&#39;t have access to the original code.  I guess extensibility is less necessary when you control the entire codebase, but you still have to refactor your factory whenever you subclass (or adhere to a protocol), which I find problematic.<br>&gt; <br>&gt; This is something I run into a lot while writing actual code, so it isn’t just a theoretical concern.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Interesting you bring up the registering of subclasses, as that is similar to the very original proposal, and actually similar to what I&#39;m doing in my own app. Effectively, I have an Objective-C base class, and in +load it dynamically finds all subclasses using the Objective-C runtime, and stores a reference to them. Then in the initializer, it returns the appropriate subclass based on the initialization parameters. This was my solution to the superclass not having to explicitly know each individual subclass.<br>&gt;&gt; <br>&gt;&gt; Using factory initializers, however, this pattern could be used in pure Swift, albeit with some minor modifications. At program start, the program could register subclasses with the superclass, and then in the initializer would simply return the appropriate subclass (similar to NSURLProtocol, I believe).<br>&gt; <br>&gt; Yes, I have also used load in this way in ObjC.  In Swift, I think the compiler could easily build an array/table of the overloads of factory inits.  This avoids having to register explicitly (the declaration itself implies intent to register), and doesn’t take up any cycles during execution.<br>&gt; <br>&gt; I ran into the problem of when to register the other day in a current project, as Swift doesn’t have an equivalent to +load that I am aware of.  I had to settle for something of a hack which gets called on first use… but it was only a partial solution which worked in that particular case.  How do the swift classes/enums/structs get called to register themselves?<br>&gt; <br>&gt; We may want to propose adding a +load equivalent for Swift types, since it does come up occasionally. It is one of those things which you don’t need often, but when you do, you really need it.  Ironically, this was one of the uses of the original feature I talked about earlier (we used it to provide the equivalent of +load, awakeFromNib, etc… in the language). <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; As for rationale for protocol (factory) initializers, a common pattern I&#39;ve come across when developing my internal frameworks is to design a protocol, and then to provide a default implementation of the protocol with a type (typically a struct). I feel this relationship could be bridged easier by simply returning this type from a protocol initializer, which could even potentially allow me to declare the actual type as private, so for all intents and purposes the client does simply get an initialized protocol object (similar in part to creating an anonymous class conforming to a protocol in Java).<br>&gt; <br>&gt; I strongly agree that we should have factory initializers for protocols for the reasons you state here, plus many others.  It just seems like a natural fit.<br>&gt; <br>&gt; <br>&gt; I would like to see a 3 stage approach:<br>&gt; <br>&gt; Stage 1:  Declaring an init as “factory” allows you to return any fully inited object which fits the type (including calling self.init like a convenience init would and then returning it). If the init is failable, you can also return nil.  This works both on classes and protocols.<br>&gt; <br>&gt; Stage 2:  The compiler builds a table of the overrides of a given factory init, and there is some syntax to call them (e.g. “let sub = subclasses.init(value)”) such that the first one to return non-nil is the return value to that call.  Thorsten’s depth first + alphabetical ordering would be adequate to make the behavior predictable.  Again, this should work for both classes and protocols. (I am open to better ideas for syntax/naming)<br>&gt; <br>&gt; Stage 3: We allow greater control over the ordering in the table. This still needs thought both on syntax and method.  Something similar to operator precedence (or autolayout priority) would work in a pinch, but isn’t super elegant. In practice, it might be enough just to be able to declare that something needs to be before/after a specific subclass in the list.<br>&gt; <br>&gt; <br>&gt; Note: A slightly different approach to stage 2 (for classes) might have only the direct subclasses in the table, and then the subclasses have the option to call off to their own subclasses in the same manner if desired.  This has the tradeoff that each level needs to plan for extensibility (i.e. you can’t override something which wasn’t expecting to be subclassed), but I do like how it simplifies the model a bit.<br>&gt; <br>&gt; I have a feeling that the proper syntax for stages 2/3 may become more obvious once the design work around mixins/protocols+storage gets done.  It may just fall out of the disambiguation syntax...<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt;&gt; On Mar 22, 2016, at 5:21 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes and No.<br>&gt;&gt;&gt; Yes, because this is a problem I run into all the time, and I really want swift to have a solution for it. I especially like Brent’s idea of a protocol init.<br>&gt;&gt;&gt; No, because I have gotten a bit greedy. I want us to take a step back and look at the underlying problem to see if we can come up with something which completely solves it… and I think factories get us only part way there. Let’s take a moment and see if we can create something uniquely swift before we copy/paste existing solutions.<br>&gt;&gt;&gt; Think about Cocoa’s class clusters for a moment. I love them, but they are a pain to subclass. To the level where any beginning Cocoa instruction tells you explicitly not to subclass them. Similarly, even in my own factories, they are always a pain to extend.<br>&gt;&gt;&gt; I want our factory inits to be extensible by default.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By extensible, I mean that I want to be able to add a new subclass (or a new entity satisfying a protocol), and have it come out of the factory when appropriate without editing the base class! Madness, I know, but:<br>&gt;&gt;&gt; 1) I may not have access to the source of the base class (e.g. Cocoa Collections)<br>&gt;&gt;&gt; 2) I always feel a bit dirty giving the base class knowledge of it’s subclasses<br>&gt;&gt;&gt; 3) It is a royal pain, and a potential source of errors as things get refactored when adding new subclasses<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think I have at least the seed of an idea of how to solve this, and I am hoping that one of you (who are all much smarter than I) might have the key to getting it the rest of the way.<br>&gt;&gt;&gt; I ran into this problem again last week, and it made me think of an old language I used to use...<br>&gt;&gt;&gt; There was a small programming language I used to use in the 90’s which had an interesting core language feature we called “handlers”. These were a lot like registering for notifications, except that writing a function (with a special “Handler” attribute: “Handler func myFuncName()&quot;) was all you needed to do to register. Writing “Handle myFuncName()” would then systematically call every function with that name and the Handler attribute.<br>&gt;&gt;&gt; That is, instead of calling a single function, it would systematically call a series of functions (all with the same name).<br>&gt;&gt;&gt; There was one other thing that made these handlers special. Each one had the option, when it was called, to reply that it was the one true handler, and the others didn’t need to be called. Basically, it said “I&#39;ve got this!”. This even allowed it to return a result to the caller.<br>&gt;&gt;&gt; The original intent of this feature (and why it was a core language feature) was to handle events. It would handle things like hit testing and key events fairly elegantly. It was a powerful feature, so it was quickly used for other things. It made things like plug-ins ridiculously simple. We even used it for a form of error handling.<br>&gt;&gt;&gt; I remember helping to write a page layout program in it, and we used handlers not just for the hit testing, but for the tool palette as well. The end result was that you were able to add new shapes and new tools without modifying existing code at all. It is a feature I miss all the time...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is more power than we need here, but it provided me the inspiration for a potential solution to the factory problem. Back to swift…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The idea here is to give each interested subclass a chance to say “I&#39;ve got this!”. The factory init runs through each of the subclasses’ overrides until it finds one that doesn’t return nil. New subclasses can be added and they will be given a chance as well (without modifying the base class). The first subclass to successfully init wins. (only subclasses which override the factory init would be considered)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;     public factory init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;         //I like having an explicit call, so that the traditional (non-distributed) factory is possible as well<br>&gt;&gt;&gt;         return factory.init(type) //We could also call this “subclass.init(type)” to mirror super<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;     public factory override init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;         guard type == compatibleWithThisType else {return nil} //If info doesn’t work for us, we return nil, and the next class gets a shot<br>&gt;&gt;&gt; 	//Init concrete type here<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The main issue which still needs to be solved is that the order they get called sometimes really matters (this was solved by a well defined ordering + IDE features in the language mentioned above). For the most part, as long as subclasses are called before their superclasses (or there is a some method for cascading), it works. There are still times where you want to define a specific ordering though (e.g. a new subclass wants to get called before an existing subclasses to override some of it’s use cases).<br>&gt;&gt;&gt; I see a few options (and I would love to hear more):<br>&gt;&gt;&gt; - subclasses define a numeric precedence (similar to operators now). This is probably the most effective stop-gap solution, but is not elegant.<br>&gt;&gt;&gt; - subclasses do whatever we change operator precedence to do in the future<br>&gt;&gt;&gt; - optionally allow subclasses to name another specific subclass that they are before/after<br>&gt;&gt;&gt; - allow subclasses to declare that they would like to be earlier or later (or that they don’t care) in the calling list. subclasses defined outside of the module where the base class was defined would be placed more extremely early/late. Exact order is undefined, but rough ordering is possible.<br>&gt;&gt;&gt; - return (to the superclass) an array of all subclasses which successfully inited. It can then select which one it wants and return it. This seems overly inefficient to me, since you are initializing a bunch of unused objects.<br>&gt;&gt;&gt; - &lt;Your idea here&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The end result is that you can extend factories of both classes and protocols without access to the original source code.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I also don’t think that the base should always need to be abstract. Factory inits should allow returning subclasses as a way of replacing themselves with a subclass, and returning nil if they are failable, but if there is no return (or return self), it can create an instance of itself. This way, it provides a customization point where subclasses can handle special cases, but the class itself provides an obvious default (i.e. a much less messy form of class cluster).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;     public factory init(type: InformationToSwitchOn){<br>&gt;&gt;&gt; 	if let subclass = factory.init(type){<br>&gt;&gt;&gt; 	    return subclass<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; 	return self.init()//If subclasses didn’t work, initialize ourselves<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?  Too crazy to consider?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; # Factory Initializers<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; class AbstractBase {<br>&gt;&gt;&gt; &gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt; &gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt;&gt; &gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; ## Protocol Initializers<br>&gt;&gt;&gt; &gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt;&gt; &gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; Best,<br>&gt;&gt;&gt; &gt;&gt; Riley Testut<br>&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/45281159/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>March 30, 2016 at 02:00:00am</p></header><div class="content"><p>Agreed.  I would like to see what I was referring to as “stage 1” in this proposal, and we can (hopefully) add on a full solution over time.  (I just wanted to make sure we considered those cases so we didn’t block future improvements)<br></p><p>Looking at the proposal, my only contention would be that we should also allow self.init() to be called from the factory init (similar to a convenience init).  It could still be used with an AbstractBase as shown in your example (especially when dealing with protocols), but it shouldn’t force us to be abstract in the class case.<br></p><p>In other words, we should also be able to do the following:<br></p><p>public class ConcreteBase {<br></p><p>	private init(type: InformationToSwitchOn) {<br>		//Default implementation here<br>	}<br></p><p>	public factory init (type: InformationToSwitchOn) {<br>		if … {<br>			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>		}<br>		return self.init(type) //Handle the general case with the main class<br>	}<br>}<br></p><p>class SpecialSubclass : ConcreteBase {}<br></p><p><br></p><p>The behavior should simply be that we can return any init’d object that conforms to the given type.<br></p><p>Thanks,<br>Jon<br></p><p><br>&gt; On Mar 30, 2016, at 2:20 AM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt; <br>&gt; Ultimately, while these are good points, I feel the full mechanism for class clusters belong in a separate proposal. The focus for this one I believe should be the underlying mechanism of factory initializers; should that be approved, then we can focus on adding additional features on top of it.<br>&gt; <br>&gt; That being said, I’ve written up essentially a final version of the proposal, which you can find here: https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md &lt;https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md&gt;. Assuming everyone is happy with it, I’ll send a pull request in the next few days to the main-repo. But please, give any last minute feedback now!<br>&gt; <br>&gt;&gt; On Mar 24, 2016, at 5:12 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Comments inline.<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 24, 2016, at 12:10 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While I do believe your proposed additions have their benefits, my gut tells me this is too large a change to Swift for an arguably small gain. For this proposal, I&#39;m wanting to keep the change as minimalistic as possible, while still providing enough flexibility and use cases to warrant it.<br>&gt;&gt; <br>&gt;&gt; I can definitely see the argument that extensibility is out of scope for Swift 3, but I do want to make sure that it is possible for us to have extensibility in the future (that we don’t block ourselves from doing it).<br>&gt;&gt; <br>&gt;&gt; I strongly disagree that the gain is small.  One of the core benefits of both Swift/ObjC (and now POP) is the ability to extend things post-hoc, without access to the original code.<br>&gt;&gt; <br>&gt;&gt; I often write libraries &amp; SDKs, so the users of my code don&#39;t have access to the original code.  I guess extensibility is less necessary when you control the entire codebase, but you still have to refactor your factory whenever you subclass (or adhere to a protocol), which I find problematic.<br>&gt;&gt; <br>&gt;&gt; This is something I run into a lot while writing actual code, so it isn’t just a theoretical concern.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Interesting you bring up the registering of subclasses, as that is similar to the very original proposal, and actually similar to what I&#39;m doing in my own app. Effectively, I have an Objective-C base class, and in +load it dynamically finds all subclasses using the Objective-C runtime, and stores a reference to them. Then in the initializer, it returns the appropriate subclass based on the initialization parameters. This was my solution to the superclass not having to explicitly know each individual subclass.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using factory initializers, however, this pattern could be used in pure Swift, albeit with some minor modifications. At program start, the program could register subclasses with the superclass, and then in the initializer would simply return the appropriate subclass (similar to NSURLProtocol, I believe).<br>&gt;&gt; <br>&gt;&gt; Yes, I have also used load in this way in ObjC.  In Swift, I think the compiler could easily build an array/table of the overloads of factory inits.  This avoids having to register explicitly (the declaration itself implies intent to register), and doesn’t take up any cycles during execution.<br>&gt;&gt; <br>&gt;&gt; I ran into the problem of when to register the other day in a current project, as Swift doesn’t have an equivalent to +load that I am aware of.  I had to settle for something of a hack which gets called on first use… but it was only a partial solution which worked in that particular case.  How do the swift classes/enums/structs get called to register themselves?<br>&gt;&gt; <br>&gt;&gt; We may want to propose adding a +load equivalent for Swift types, since it does come up occasionally. It is one of those things which you don’t need often, but when you do, you really need it.  Ironically, this was one of the uses of the original feature I talked about earlier (we used it to provide the equivalent of +load, awakeFromNib, etc… in the language). <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; As for rationale for protocol (factory) initializers, a common pattern I&#39;ve come across when developing my internal frameworks is to design a protocol, and then to provide a default implementation of the protocol with a type (typically a struct). I feel this relationship could be bridged easier by simply returning this type from a protocol initializer, which could even potentially allow me to declare the actual type as private, so for all intents and purposes the client does simply get an initialized protocol object (similar in part to creating an anonymous class conforming to a protocol in Java).<br>&gt;&gt; <br>&gt;&gt; I strongly agree that we should have factory initializers for protocols for the reasons you state here, plus many others.  It just seems like a natural fit.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I would like to see a 3 stage approach:<br>&gt;&gt; <br>&gt;&gt; Stage 1:  Declaring an init as “factory” allows you to return any fully inited object which fits the type (including calling self.init like a convenience init would and then returning it). If the init is failable, you can also return nil.  This works both on classes and protocols.<br>&gt;&gt; <br>&gt;&gt; Stage 2:  The compiler builds a table of the overrides of a given factory init, and there is some syntax to call them (e.g. “let sub = subclasses.init(value)”) such that the first one to return non-nil is the return value to that call.  Thorsten’s depth first + alphabetical ordering would be adequate to make the behavior predictable.  Again, this should work for both classes and protocols. (I am open to better ideas for syntax/naming)<br>&gt;&gt; <br>&gt;&gt; Stage 3: We allow greater control over the ordering in the table. This still needs thought both on syntax and method.  Something similar to operator precedence (or autolayout priority) would work in a pinch, but isn’t super elegant. In practice, it might be enough just to be able to declare that something needs to be before/after a specific subclass in the list.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Note: A slightly different approach to stage 2 (for classes) might have only the direct subclasses in the table, and then the subclasses have the option to call off to their own subclasses in the same manner if desired.  This has the tradeoff that each level needs to plan for extensibility (i.e. you can’t override something which wasn’t expecting to be subclassed), but I do like how it simplifies the model a bit.<br>&gt;&gt; <br>&gt;&gt; I have a feeling that the proper syntax for stages 2/3 may become more obvious once the design work around mixins/protocols+storage gets done.  It may just fall out of the disambiguation syntax...<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 22, 2016, at 5:21 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes and No.<br>&gt;&gt;&gt;&gt; Yes, because this is a problem I run into all the time, and I really want swift to have a solution for it. I especially like Brent’s idea of a protocol init.<br>&gt;&gt;&gt;&gt; No, because I have gotten a bit greedy. I want us to take a step back and look at the underlying problem to see if we can come up with something which completely solves it… and I think factories get us only part way there. Let’s take a moment and see if we can create something uniquely swift before we copy/paste existing solutions.<br>&gt;&gt;&gt;&gt; Think about Cocoa’s class clusters for a moment. I love them, but they are a pain to subclass. To the level where any beginning Cocoa instruction tells you explicitly not to subclass them. Similarly, even in my own factories, they are always a pain to extend.<br>&gt;&gt;&gt;&gt; I want our factory inits to be extensible by default.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; By extensible, I mean that I want to be able to add a new subclass (or a new entity satisfying a protocol), and have it come out of the factory when appropriate without editing the base class! Madness, I know, but:<br>&gt;&gt;&gt;&gt; 1) I may not have access to the source of the base class (e.g. Cocoa Collections)<br>&gt;&gt;&gt;&gt; 2) I always feel a bit dirty giving the base class knowledge of it’s subclasses<br>&gt;&gt;&gt;&gt; 3) It is a royal pain, and a potential source of errors as things get refactored when adding new subclasses<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think I have at least the seed of an idea of how to solve this, and I am hoping that one of you (who are all much smarter than I) might have the key to getting it the rest of the way.<br>&gt;&gt;&gt;&gt; I ran into this problem again last week, and it made me think of an old language I used to use...<br>&gt;&gt;&gt;&gt; There was a small programming language I used to use in the 90’s which had an interesting core language feature we called “handlers”. These were a lot like registering for notifications, except that writing a function (with a special “Handler” attribute: “Handler func myFuncName()&quot;) was all you needed to do to register. Writing “Handle myFuncName()” would then systematically call every function with that name and the Handler attribute.<br>&gt;&gt;&gt;&gt; That is, instead of calling a single function, it would systematically call a series of functions (all with the same name).<br>&gt;&gt;&gt;&gt; There was one other thing that made these handlers special. Each one had the option, when it was called, to reply that it was the one true handler, and the others didn’t need to be called. Basically, it said “I&#39;ve got this!”. This even allowed it to return a result to the caller.<br>&gt;&gt;&gt;&gt; The original intent of this feature (and why it was a core language feature) was to handle events. It would handle things like hit testing and key events fairly elegantly. It was a powerful feature, so it was quickly used for other things. It made things like plug-ins ridiculously simple. We even used it for a form of error handling.<br>&gt;&gt;&gt;&gt; I remember helping to write a page layout program in it, and we used handlers not just for the hit testing, but for the tool palette as well. The end result was that you were able to add new shapes and new tools without modifying existing code at all. It is a feature I miss all the time...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That is more power than we need here, but it provided me the inspiration for a potential solution to the factory problem. Back to swift…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The idea here is to give each interested subclass a chance to say “I&#39;ve got this!”. The factory init runs through each of the subclasses’ overrides until it finds one that doesn’t return nil. New subclasses can be added and they will be given a chance as well (without modifying the base class). The first subclass to successfully init wins. (only subclasses which override the factory init would be considered)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;     public factory init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;         //I like having an explicit call, so that the traditional (non-distributed) factory is possible as well<br>&gt;&gt;&gt;&gt;         return factory.init(type) //We could also call this “subclass.init(type)” to mirror super<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;     public factory override init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;         guard type == compatibleWithThisType else {return nil} //If info doesn’t work for us, we return nil, and the next class gets a shot<br>&gt;&gt;&gt;&gt; 	//Init concrete type here<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The main issue which still needs to be solved is that the order they get called sometimes really matters (this was solved by a well defined ordering + IDE features in the language mentioned above). For the most part, as long as subclasses are called before their superclasses (or there is a some method for cascading), it works. There are still times where you want to define a specific ordering though (e.g. a new subclass wants to get called before an existing subclasses to override some of it’s use cases).<br>&gt;&gt;&gt;&gt; I see a few options (and I would love to hear more):<br>&gt;&gt;&gt;&gt; - subclasses define a numeric precedence (similar to operators now). This is probably the most effective stop-gap solution, but is not elegant.<br>&gt;&gt;&gt;&gt; - subclasses do whatever we change operator precedence to do in the future<br>&gt;&gt;&gt;&gt; - optionally allow subclasses to name another specific subclass that they are before/after<br>&gt;&gt;&gt;&gt; - allow subclasses to declare that they would like to be earlier or later (or that they don’t care) in the calling list. subclasses defined outside of the module where the base class was defined would be placed more extremely early/late. Exact order is undefined, but rough ordering is possible.<br>&gt;&gt;&gt;&gt; - return (to the superclass) an array of all subclasses which successfully inited. It can then select which one it wants and return it. This seems overly inefficient to me, since you are initializing a bunch of unused objects.<br>&gt;&gt;&gt;&gt; - &lt;Your idea here&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The end result is that you can extend factories of both classes and protocols without access to the original source code.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I also don’t think that the base should always need to be abstract. Factory inits should allow returning subclasses as a way of replacing themselves with a subclass, and returning nil if they are failable, but if there is no return (or return self), it can create an instance of itself. This way, it provides a customization point where subclasses can handle special cases, but the class itself provides an obvious default (i.e. a much less messy form of class cluster).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;     public factory init(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt; 	if let subclass = factory.init(type){<br>&gt;&gt;&gt;&gt; 	    return subclass<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; 	return self.init()//If subclasses didn’t work, initialize ourselves<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts?  Too crazy to consider?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; # Factory Initializers<br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt; &gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt; &gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt;&gt;&gt; &gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; ## Protocol Initializers<br>&gt;&gt;&gt;&gt; &gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt;&gt;&gt; &gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt; Best,<br>&gt;&gt;&gt;&gt; &gt;&gt; Riley Testut<br>&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; &gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/f93dad7d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>March 30, 2016 at 03:00:00am</p></header><div class="content"><p>Ah, good catch. Would that be confusing as to whether self.init() would lead to an infinite loop, or call the required initializer? Unlike convenience initializers, factory initializers might have the same signature as the required ones.<br></p><p>&gt; On Mar 30, 2016, at 2:52 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt; <br>&gt; Agreed.  I would like to see what I was referring to as “stage 1” in this proposal, and we can (hopefully) add on a full solution over time.  (I just wanted to make sure we considered those cases so we didn’t block future improvements)<br>&gt; <br>&gt; Looking at the proposal, my only contention would be that we should also allow self.init() to be called from the factory init (similar to a convenience init).  It could still be used with an AbstractBase as shown in your example (especially when dealing with protocols), but it shouldn’t force us to be abstract in the class case.<br>&gt; <br>&gt; In other words, we should also be able to do the following:<br>&gt; <br>&gt; public class ConcreteBase {<br>&gt; <br>&gt; 	private init(type: InformationToSwitchOn) {<br>&gt; 		//Default implementation here<br>&gt; 	}<br>&gt; <br>&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt; 		if … {<br>&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt; 		}<br>&gt; 		return self.init(type) //Handle the general case with the main class<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; class SpecialSubclass : ConcreteBase {}<br>&gt; <br>&gt; <br>&gt; <br>&gt; The behavior should simply be that we can return any init’d object that conforms to the given type.<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 30, 2016, at 2:20 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Ultimately, while these are good points, I feel the full mechanism for class clusters belong in a separate proposal. The focus for this one I believe should be the underlying mechanism of factory initializers; should that be approved, then we can focus on adding additional features on top of it.<br>&gt;&gt; <br>&gt;&gt; That being said, I’ve written up essentially a final version of the proposal, which you can find here: https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md &lt;https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md&gt;. Assuming everyone is happy with it, I’ll send a pull request in the next few days to the main-repo. But please, give any last minute feedback now!<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 24, 2016, at 5:12 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comments inline.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 24, 2016, at 12:10 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While I do believe your proposed additions have their benefits, my gut tells me this is too large a change to Swift for an arguably small gain. For this proposal, I&#39;m wanting to keep the change as minimalistic as possible, while still providing enough flexibility and use cases to warrant it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can definitely see the argument that extensibility is out of scope for Swift 3, but I do want to make sure that it is possible for us to have extensibility in the future (that we don’t block ourselves from doing it).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I strongly disagree that the gain is small.  One of the core benefits of both Swift/ObjC (and now POP) is the ability to extend things post-hoc, without access to the original code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I often write libraries &amp; SDKs, so the users of my code don&#39;t have access to the original code.  I guess extensibility is less necessary when you control the entire codebase, but you still have to refactor your factory whenever you subclass (or adhere to a protocol), which I find problematic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is something I run into a lot while writing actual code, so it isn’t just a theoretical concern.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Interesting you bring up the registering of subclasses, as that is similar to the very original proposal, and actually similar to what I&#39;m doing in my own app. Effectively, I have an Objective-C base class, and in +load it dynamically finds all subclasses using the Objective-C runtime, and stores a reference to them. Then in the initializer, it returns the appropriate subclass based on the initialization parameters. This was my solution to the superclass not having to explicitly know each individual subclass.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Using factory initializers, however, this pattern could be used in pure Swift, albeit with some minor modifications. At program start, the program could register subclasses with the superclass, and then in the initializer would simply return the appropriate subclass (similar to NSURLProtocol, I believe).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, I have also used load in this way in ObjC.  In Swift, I think the compiler could easily build an array/table of the overloads of factory inits.  This avoids having to register explicitly (the declaration itself implies intent to register), and doesn’t take up any cycles during execution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I ran into the problem of when to register the other day in a current project, as Swift doesn’t have an equivalent to +load that I am aware of.  I had to settle for something of a hack which gets called on first use… but it was only a partial solution which worked in that particular case.  How do the swift classes/enums/structs get called to register themselves?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We may want to propose adding a +load equivalent for Swift types, since it does come up occasionally. It is one of those things which you don’t need often, but when you do, you really need it.  Ironically, this was one of the uses of the original feature I talked about earlier (we used it to provide the equivalent of +load, awakeFromNib, etc… in the language). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As for rationale for protocol (factory) initializers, a common pattern I&#39;ve come across when developing my internal frameworks is to design a protocol, and then to provide a default implementation of the protocol with a type (typically a struct). I feel this relationship could be bridged easier by simply returning this type from a protocol initializer, which could even potentially allow me to declare the actual type as private, so for all intents and purposes the client does simply get an initialized protocol object (similar in part to creating an anonymous class conforming to a protocol in Java).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I strongly agree that we should have factory initializers for protocols for the reasons you state here, plus many others.  It just seems like a natural fit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would like to see a 3 stage approach:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Stage 1:  Declaring an init as “factory” allows you to return any fully inited object which fits the type (including calling self.init like a convenience init would and then returning it). If the init is failable, you can also return nil.  This works both on classes and protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Stage 2:  The compiler builds a table of the overrides of a given factory init, and there is some syntax to call them (e.g. “let sub = subclasses.init(value)”) such that the first one to return non-nil is the return value to that call.  Thorsten’s depth first + alphabetical ordering would be adequate to make the behavior predictable.  Again, this should work for both classes and protocols. (I am open to better ideas for syntax/naming)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Stage 3: We allow greater control over the ordering in the table. This still needs thought both on syntax and method.  Something similar to operator precedence (or autolayout priority) would work in a pinch, but isn’t super elegant. In practice, it might be enough just to be able to declare that something needs to be before/after a specific subclass in the list.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note: A slightly different approach to stage 2 (for classes) might have only the direct subclasses in the table, and then the subclasses have the option to call off to their own subclasses in the same manner if desired.  This has the tradeoff that each level needs to plan for extensibility (i.e. you can’t override something which wasn’t expecting to be subclassed), but I do like how it simplifies the model a bit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have a feeling that the proper syntax for stages 2/3 may become more obvious once the design work around mixins/protocols+storage gets done.  It may just fall out of the disambiguation syntax...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 22, 2016, at 5:21 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes and No.<br>&gt;&gt;&gt;&gt;&gt; Yes, because this is a problem I run into all the time, and I really want swift to have a solution for it. I especially like Brent’s idea of a protocol init.<br>&gt;&gt;&gt;&gt;&gt; No, because I have gotten a bit greedy. I want us to take a step back and look at the underlying problem to see if we can come up with something which completely solves it… and I think factories get us only part way there. Let’s take a moment and see if we can create something uniquely swift before we copy/paste existing solutions.<br>&gt;&gt;&gt;&gt;&gt; Think about Cocoa’s class clusters for a moment. I love them, but they are a pain to subclass. To the level where any beginning Cocoa instruction tells you explicitly not to subclass them. Similarly, even in my own factories, they are always a pain to extend.<br>&gt;&gt;&gt;&gt;&gt; I want our factory inits to be extensible by default.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; By extensible, I mean that I want to be able to add a new subclass (or a new entity satisfying a protocol), and have it come out of the factory when appropriate without editing the base class! Madness, I know, but:<br>&gt;&gt;&gt;&gt;&gt; 1) I may not have access to the source of the base class (e.g. Cocoa Collections)<br>&gt;&gt;&gt;&gt;&gt; 2) I always feel a bit dirty giving the base class knowledge of it’s subclasses<br>&gt;&gt;&gt;&gt;&gt; 3) It is a royal pain, and a potential source of errors as things get refactored when adding new subclasses<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think I have at least the seed of an idea of how to solve this, and I am hoping that one of you (who are all much smarter than I) might have the key to getting it the rest of the way.<br>&gt;&gt;&gt;&gt;&gt; I ran into this problem again last week, and it made me think of an old language I used to use...<br>&gt;&gt;&gt;&gt;&gt; There was a small programming language I used to use in the 90’s which had an interesting core language feature we called “handlers”. These were a lot like registering for notifications, except that writing a function (with a special “Handler” attribute: “Handler func myFuncName()&quot;) was all you needed to do to register. Writing “Handle myFuncName()” would then systematically call every function with that name and the Handler attribute.<br>&gt;&gt;&gt;&gt;&gt; That is, instead of calling a single function, it would systematically call a series of functions (all with the same name).<br>&gt;&gt;&gt;&gt;&gt; There was one other thing that made these handlers special. Each one had the option, when it was called, to reply that it was the one true handler, and the others didn’t need to be called. Basically, it said “I&#39;ve got this!”. This even allowed it to return a result to the caller.<br>&gt;&gt;&gt;&gt;&gt; The original intent of this feature (and why it was a core language feature) was to handle events. It would handle things like hit testing and key events fairly elegantly. It was a powerful feature, so it was quickly used for other things. It made things like plug-ins ridiculously simple. We even used it for a form of error handling.<br>&gt;&gt;&gt;&gt;&gt; I remember helping to write a page layout program in it, and we used handlers not just for the hit testing, but for the tool palette as well. The end result was that you were able to add new shapes and new tools without modifying existing code at all. It is a feature I miss all the time...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That is more power than we need here, but it provided me the inspiration for a potential solution to the factory problem. Back to swift…<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The idea here is to give each interested subclass a chance to say “I&#39;ve got this!”. The factory init runs through each of the subclasses’ overrides until it finds one that doesn’t return nil. New subclasses can be added and they will be given a chance as well (without modifying the base class). The first subclass to successfully init wins. (only subclasses which override the factory init would be considered)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;     public factory init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;         //I like having an explicit call, so that the traditional (non-distributed) factory is possible as well<br>&gt;&gt;&gt;&gt;&gt;         return factory.init(type) //We could also call this “subclass.init(type)” to mirror super<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;     public factory override init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;         guard type == compatibleWithThisType else {return nil} //If info doesn’t work for us, we return nil, and the next class gets a shot<br>&gt;&gt;&gt;&gt;&gt; 	//Init concrete type here<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The main issue which still needs to be solved is that the order they get called sometimes really matters (this was solved by a well defined ordering + IDE features in the language mentioned above). For the most part, as long as subclasses are called before their superclasses (or there is a some method for cascading), it works. There are still times where you want to define a specific ordering though (e.g. a new subclass wants to get called before an existing subclasses to override some of it’s use cases).<br>&gt;&gt;&gt;&gt;&gt; I see a few options (and I would love to hear more):<br>&gt;&gt;&gt;&gt;&gt; - subclasses define a numeric precedence (similar to operators now). This is probably the most effective stop-gap solution, but is not elegant.<br>&gt;&gt;&gt;&gt;&gt; - subclasses do whatever we change operator precedence to do in the future<br>&gt;&gt;&gt;&gt;&gt; - optionally allow subclasses to name another specific subclass that they are before/after<br>&gt;&gt;&gt;&gt;&gt; - allow subclasses to declare that they would like to be earlier or later (or that they don’t care) in the calling list. subclasses defined outside of the module where the base class was defined would be placed more extremely early/late. Exact order is undefined, but rough ordering is possible.<br>&gt;&gt;&gt;&gt;&gt; - return (to the superclass) an array of all subclasses which successfully inited. It can then select which one it wants and return it. This seems overly inefficient to me, since you are initializing a bunch of unused objects.<br>&gt;&gt;&gt;&gt;&gt; - &lt;Your idea here&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The end result is that you can extend factories of both classes and protocols without access to the original source code.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I also don’t think that the base should always need to be abstract. Factory inits should allow returning subclasses as a way of replacing themselves with a subclass, and returning nil if they are failable, but if there is no return (or return self), it can create an instance of itself. This way, it provides a customization point where subclasses can handle special cases, but the class itself provides an obvious default (i.e. a much less messy form of class cluster).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;&gt;     public factory init(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt; 	if let subclass = factory.init(type){<br>&gt;&gt;&gt;&gt;&gt; 	    return subclass<br>&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt; 	return self.init()//If subclasses didn’t work, initialize ourselves<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thoughts?  Too crazy to consider?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; # Factory Initializers<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Protocol Initializers<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Riley Testut<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/517d6de4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>March 30, 2016 at 03:00:00am</p></header><div class="content"><p>Doh!  <br></p><p>Sorry, typed that up in mail while working on something else at the same time.  We shouldn’t allow an init with the same signature.  self.init() could be called with different parameters.  Trying to call the factory method from the factory method should generate an error.<br></p><p>We probably also want to disallow having an init with the same signature in subclasses as well (we could pass the same info with different parameter names) as a subclass which doesn’t override it would again be calling the factory method.  Ultimately, I would like to see the ability to override the factory method with the behavior I described earlier… but that is for a later proposal.<br></p><p>Basically we should be able to return anything which adheres to the type, so we are free to use other initializers on the class/subclasses.<br></p><p>Thanks,<br>Jon<br></p><p><br>&gt; On Mar 30, 2016, at 3:10 AM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt; <br>&gt; Ah, good catch. Would that be confusing as to whether self.init() would lead to an infinite loop, or call the required initializer? Unlike convenience initializers, factory initializers might have the same signature as the required ones.<br>&gt; <br>&gt;&gt; On Mar 30, 2016, at 2:52 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Agreed.  I would like to see what I was referring to as “stage 1” in this proposal, and we can (hopefully) add on a full solution over time.  (I just wanted to make sure we considered those cases so we didn’t block future improvements)<br>&gt;&gt; <br>&gt;&gt; Looking at the proposal, my only contention would be that we should also allow self.init() to be called from the factory init (similar to a convenience init).  It could still be used with an AbstractBase as shown in your example (especially when dealing with protocols), but it shouldn’t force us to be abstract in the class case.<br>&gt;&gt; <br>&gt;&gt; In other words, we should also be able to do the following:<br>&gt;&gt; <br>&gt;&gt; public class ConcreteBase {<br>&gt;&gt; <br>&gt;&gt; 	private init(type: InformationToSwitchOn) {<br>&gt;&gt; 		//Default implementation here<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt;&gt; 		if … {<br>&gt;&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt;&gt; 		}<br>&gt;&gt; 		return self.init(type) //Handle the general case with the main class<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class SpecialSubclass : ConcreteBase {}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The behavior should simply be that we can return any init’d object that conforms to the given type.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 30, 2016, at 2:20 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ultimately, while these are good points, I feel the full mechanism for class clusters belong in a separate proposal. The focus for this one I believe should be the underlying mechanism of factory initializers; should that be approved, then we can focus on adding additional features on top of it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That being said, I’ve written up essentially a final version of the proposal, which you can find here: https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md &lt;https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md&gt;. Assuming everyone is happy with it, I’ll send a pull request in the next few days to the main-repo. But please, give any last minute feedback now!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 24, 2016, at 5:12 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Comments inline.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 12:10 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; While I do believe your proposed additions have their benefits, my gut tells me this is too large a change to Swift for an arguably small gain. For this proposal, I&#39;m wanting to keep the change as minimalistic as possible, while still providing enough flexibility and use cases to warrant it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can definitely see the argument that extensibility is out of scope for Swift 3, but I do want to make sure that it is possible for us to have extensibility in the future (that we don’t block ourselves from doing it).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I strongly disagree that the gain is small.  One of the core benefits of both Swift/ObjC (and now POP) is the ability to extend things post-hoc, without access to the original code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I often write libraries &amp; SDKs, so the users of my code don&#39;t have access to the original code.  I guess extensibility is less necessary when you control the entire codebase, but you still have to refactor your factory whenever you subclass (or adhere to a protocol), which I find problematic.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is something I run into a lot while writing actual code, so it isn’t just a theoretical concern.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Interesting you bring up the registering of subclasses, as that is similar to the very original proposal, and actually similar to what I&#39;m doing in my own app. Effectively, I have an Objective-C base class, and in +load it dynamically finds all subclasses using the Objective-C runtime, and stores a reference to them. Then in the initializer, it returns the appropriate subclass based on the initialization parameters. This was my solution to the superclass not having to explicitly know each individual subclass.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Using factory initializers, however, this pattern could be used in pure Swift, albeit with some minor modifications. At program start, the program could register subclasses with the superclass, and then in the initializer would simply return the appropriate subclass (similar to NSURLProtocol, I believe).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, I have also used load in this way in ObjC.  In Swift, I think the compiler could easily build an array/table of the overloads of factory inits.  This avoids having to register explicitly (the declaration itself implies intent to register), and doesn’t take up any cycles during execution.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I ran into the problem of when to register the other day in a current project, as Swift doesn’t have an equivalent to +load that I am aware of.  I had to settle for something of a hack which gets called on first use… but it was only a partial solution which worked in that particular case.  How do the swift classes/enums/structs get called to register themselves?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We may want to propose adding a +load equivalent for Swift types, since it does come up occasionally. It is one of those things which you don’t need often, but when you do, you really need it.  Ironically, this was one of the uses of the original feature I talked about earlier (we used it to provide the equivalent of +load, awakeFromNib, etc… in the language). <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As for rationale for protocol (factory) initializers, a common pattern I&#39;ve come across when developing my internal frameworks is to design a protocol, and then to provide a default implementation of the protocol with a type (typically a struct). I feel this relationship could be bridged easier by simply returning this type from a protocol initializer, which could even potentially allow me to declare the actual type as private, so for all intents and purposes the client does simply get an initialized protocol object (similar in part to creating an anonymous class conforming to a protocol in Java).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I strongly agree that we should have factory initializers for protocols for the reasons you state here, plus many others.  It just seems like a natural fit.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would like to see a 3 stage approach:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Stage 1:  Declaring an init as “factory” allows you to return any fully inited object which fits the type (including calling self.init like a convenience init would and then returning it). If the init is failable, you can also return nil.  This works both on classes and protocols.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Stage 2:  The compiler builds a table of the overrides of a given factory init, and there is some syntax to call them (e.g. “let sub = subclasses.init(value)”) such that the first one to return non-nil is the return value to that call.  Thorsten’s depth first + alphabetical ordering would be adequate to make the behavior predictable.  Again, this should work for both classes and protocols. (I am open to better ideas for syntax/naming)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Stage 3: We allow greater control over the ordering in the table. This still needs thought both on syntax and method.  Something similar to operator precedence (or autolayout priority) would work in a pinch, but isn’t super elegant. In practice, it might be enough just to be able to declare that something needs to be before/after a specific subclass in the list.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note: A slightly different approach to stage 2 (for classes) might have only the direct subclasses in the table, and then the subclasses have the option to call off to their own subclasses in the same manner if desired.  This has the tradeoff that each level needs to plan for extensibility (i.e. you can’t override something which wasn’t expecting to be subclassed), but I do like how it simplifies the model a bit.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have a feeling that the proper syntax for stages 2/3 may become more obvious once the design work around mixins/protocols+storage gets done.  It may just fall out of the disambiguation syntax...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 22, 2016, at 5:21 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes and No.<br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, because this is a problem I run into all the time, and I really want swift to have a solution for it. I especially like Brent’s idea of a protocol init.<br>&gt;&gt;&gt;&gt;&gt;&gt; No, because I have gotten a bit greedy. I want us to take a step back and look at the underlying problem to see if we can come up with something which completely solves it… and I think factories get us only part way there. Let’s take a moment and see if we can create something uniquely swift before we copy/paste existing solutions.<br>&gt;&gt;&gt;&gt;&gt;&gt; Think about Cocoa’s class clusters for a moment. I love them, but they are a pain to subclass. To the level where any beginning Cocoa instruction tells you explicitly not to subclass them. Similarly, even in my own factories, they are always a pain to extend.<br>&gt;&gt;&gt;&gt;&gt;&gt; I want our factory inits to be extensible by default.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; By extensible, I mean that I want to be able to add a new subclass (or a new entity satisfying a protocol), and have it come out of the factory when appropriate without editing the base class! Madness, I know, but:<br>&gt;&gt;&gt;&gt;&gt;&gt; 1) I may not have access to the source of the base class (e.g. Cocoa Collections)<br>&gt;&gt;&gt;&gt;&gt;&gt; 2) I always feel a bit dirty giving the base class knowledge of it’s subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt; 3) It is a royal pain, and a potential source of errors as things get refactored when adding new subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think I have at least the seed of an idea of how to solve this, and I am hoping that one of you (who are all much smarter than I) might have the key to getting it the rest of the way.<br>&gt;&gt;&gt;&gt;&gt;&gt; I ran into this problem again last week, and it made me think of an old language I used to use...<br>&gt;&gt;&gt;&gt;&gt;&gt; There was a small programming language I used to use in the 90’s which had an interesting core language feature we called “handlers”. These were a lot like registering for notifications, except that writing a function (with a special “Handler” attribute: “Handler func myFuncName()&quot;) was all you needed to do to register. Writing “Handle myFuncName()” would then systematically call every function with that name and the Handler attribute.<br>&gt;&gt;&gt;&gt;&gt;&gt; That is, instead of calling a single function, it would systematically call a series of functions (all with the same name).<br>&gt;&gt;&gt;&gt;&gt;&gt; There was one other thing that made these handlers special. Each one had the option, when it was called, to reply that it was the one true handler, and the others didn’t need to be called. Basically, it said “I&#39;ve got this!”. This even allowed it to return a result to the caller.<br>&gt;&gt;&gt;&gt;&gt;&gt; The original intent of this feature (and why it was a core language feature) was to handle events. It would handle things like hit testing and key events fairly elegantly. It was a powerful feature, so it was quickly used for other things. It made things like plug-ins ridiculously simple. We even used it for a form of error handling.<br>&gt;&gt;&gt;&gt;&gt;&gt; I remember helping to write a page layout program in it, and we used handlers not just for the hit testing, but for the tool palette as well. The end result was that you were able to add new shapes and new tools without modifying existing code at all. It is a feature I miss all the time...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That is more power than we need here, but it provided me the inspiration for a potential solution to the factory problem. Back to swift…<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The idea here is to give each interested subclass a chance to say “I&#39;ve got this!”. The factory init runs through each of the subclasses’ overrides until it finds one that doesn’t return nil. New subclasses can be added and they will be given a chance as well (without modifying the base class). The first subclass to successfully init wins. (only subclasses which override the factory init would be considered)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;     public factory init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;         //I like having an explicit call, so that the traditional (non-distributed) factory is possible as well<br>&gt;&gt;&gt;&gt;&gt;&gt;         return factory.init(type) //We could also call this “subclass.init(type)” to mirror super<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;     public factory override init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;         guard type == compatibleWithThisType else {return nil} //If info doesn’t work for us, we return nil, and the next class gets a shot<br>&gt;&gt;&gt;&gt;&gt;&gt; 	//Init concrete type here<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The main issue which still needs to be solved is that the order they get called sometimes really matters (this was solved by a well defined ordering + IDE features in the language mentioned above). For the most part, as long as subclasses are called before their superclasses (or there is a some method for cascading), it works. There are still times where you want to define a specific ordering though (e.g. a new subclass wants to get called before an existing subclasses to override some of it’s use cases).<br>&gt;&gt;&gt;&gt;&gt;&gt; I see a few options (and I would love to hear more):<br>&gt;&gt;&gt;&gt;&gt;&gt; - subclasses define a numeric precedence (similar to operators now). This is probably the most effective stop-gap solution, but is not elegant.<br>&gt;&gt;&gt;&gt;&gt;&gt; - subclasses do whatever we change operator precedence to do in the future<br>&gt;&gt;&gt;&gt;&gt;&gt; - optionally allow subclasses to name another specific subclass that they are before/after<br>&gt;&gt;&gt;&gt;&gt;&gt; - allow subclasses to declare that they would like to be earlier or later (or that they don’t care) in the calling list. subclasses defined outside of the module where the base class was defined would be placed more extremely early/late. Exact order is undefined, but rough ordering is possible.<br>&gt;&gt;&gt;&gt;&gt;&gt; - return (to the superclass) an array of all subclasses which successfully inited. It can then select which one it wants and return it. This seems overly inefficient to me, since you are initializing a bunch of unused objects.<br>&gt;&gt;&gt;&gt;&gt;&gt; - &lt;Your idea here&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The end result is that you can extend factories of both classes and protocols without access to the original source code.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I also don’t think that the base should always need to be abstract. Factory inits should allow returning subclasses as a way of replacing themselves with a subclass, and returning nil if they are failable, but if there is no return (or return self), it can create an instance of itself. This way, it provides a customization point where subclasses can handle special cases, but the class itself provides an obvious default (i.e. a much less messy form of class cluster).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;&gt;&gt;     public factory init(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt; 	if let subclass = factory.init(type){<br>&gt;&gt;&gt;&gt;&gt;&gt; 	    return subclass<br>&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt; 	return self.init()//If subclasses didn’t work, initialize ourselves<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?  Too crazy to consider?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; # Factory Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Protocol Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Riley Testut<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/551b86b7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>March 30, 2016 at 03:00:00am</p></header><div class="content"><p>If we are to enforce a different type signature for factory initializers vs required/convenience initializers (which would greatly simplify this issue), if I’m understanding correctly, there shouldn’t be a need to be able to “return” self.init(), right? Because you could do this instead:<br></p><p>public class ConcreteBase {<br></p><p>	private init(type2: InformationToSwitchOn) {<br>		//Default implementation here<br>	}<br></p><p>	public factory init (type: InformationToSwitchOn) {<br>		if … {<br>			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>		}<br>		return ConcreteBase(type) //Handle the general case with the main class<br>	}<br>}<br></p><p>class SpecialSubclass : ConcreteBase {}<br></p><p>&gt; On Mar 30, 2016, at 3:30 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt; <br>&gt; Doh!  <br>&gt; <br>&gt; Sorry, typed that up in mail while working on something else at the same time.  We shouldn’t allow an init with the same signature.  self.init() could be called with different parameters.  Trying to call the factory method from the factory method should generate an error.<br>&gt; <br>&gt; We probably also want to disallow having an init with the same signature in subclasses as well (we could pass the same info with different parameter names) as a subclass which doesn’t override it would again be calling the factory method.  Ultimately, I would like to see the ability to override the factory method with the behavior I described earlier… but that is for a later proposal.<br>&gt; <br>&gt; Basically we should be able to return anything which adheres to the type, so we are free to use other initializers on the class/subclasses.<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 30, 2016, at 3:10 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Ah, good catch. Would that be confusing as to whether self.init() would lead to an infinite loop, or call the required initializer? Unlike convenience initializers, factory initializers might have the same signature as the required ones.<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 30, 2016, at 2:52 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Agreed.  I would like to see what I was referring to as “stage 1” in this proposal, and we can (hopefully) add on a full solution over time.  (I just wanted to make sure we considered those cases so we didn’t block future improvements)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Looking at the proposal, my only contention would be that we should also allow self.init() to be called from the factory init (similar to a convenience init).  It could still be used with an AbstractBase as shown in your example (especially when dealing with protocols), but it shouldn’t force us to be abstract in the class case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In other words, we should also be able to do the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class ConcreteBase {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	private init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt; 		//Default implementation here<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt;&gt;&gt; 		if … {<br>&gt;&gt;&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt;&gt;&gt; 		}<br>&gt;&gt;&gt; 		return self.init(type) //Handle the general case with the main class<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class SpecialSubclass : ConcreteBase {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The behavior should simply be that we can return any init’d object that conforms to the given type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 30, 2016, at 2:20 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ultimately, while these are good points, I feel the full mechanism for class clusters belong in a separate proposal. The focus for this one I believe should be the underlying mechanism of factory initializers; should that be approved, then we can focus on adding additional features on top of it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That being said, I’ve written up essentially a final version of the proposal, which you can find here: https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md &lt;https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md&gt;. Assuming everyone is happy with it, I’ll send a pull request in the next few days to the main-repo. But please, give any last minute feedback now!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 5:12 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Comments inline.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 12:10 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; While I do believe your proposed additions have their benefits, my gut tells me this is too large a change to Swift for an arguably small gain. For this proposal, I&#39;m wanting to keep the change as minimalistic as possible, while still providing enough flexibility and use cases to warrant it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I can definitely see the argument that extensibility is out of scope for Swift 3, but I do want to make sure that it is possible for us to have extensibility in the future (that we don’t block ourselves from doing it).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I strongly disagree that the gain is small.  One of the core benefits of both Swift/ObjC (and now POP) is the ability to extend things post-hoc, without access to the original code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I often write libraries &amp; SDKs, so the users of my code don&#39;t have access to the original code.  I guess extensibility is less necessary when you control the entire codebase, but you still have to refactor your factory whenever you subclass (or adhere to a protocol), which I find problematic.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is something I run into a lot while writing actual code, so it isn’t just a theoretical concern.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Interesting you bring up the registering of subclasses, as that is similar to the very original proposal, and actually similar to what I&#39;m doing in my own app. Effectively, I have an Objective-C base class, and in +load it dynamically finds all subclasses using the Objective-C runtime, and stores a reference to them. Then in the initializer, it returns the appropriate subclass based on the initialization parameters. This was my solution to the superclass not having to explicitly know each individual subclass.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Using factory initializers, however, this pattern could be used in pure Swift, albeit with some minor modifications. At program start, the program could register subclasses with the superclass, and then in the initializer would simply return the appropriate subclass (similar to NSURLProtocol, I believe).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, I have also used load in this way in ObjC.  In Swift, I think the compiler could easily build an array/table of the overloads of factory inits.  This avoids having to register explicitly (the declaration itself implies intent to register), and doesn’t take up any cycles during execution.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I ran into the problem of when to register the other day in a current project, as Swift doesn’t have an equivalent to +load that I am aware of.  I had to settle for something of a hack which gets called on first use… but it was only a partial solution which worked in that particular case.  How do the swift classes/enums/structs get called to register themselves?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We may want to propose adding a +load equivalent for Swift types, since it does come up occasionally. It is one of those things which you don’t need often, but when you do, you really need it.  Ironically, this was one of the uses of the original feature I talked about earlier (we used it to provide the equivalent of +load, awakeFromNib, etc… in the language). <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As for rationale for protocol (factory) initializers, a common pattern I&#39;ve come across when developing my internal frameworks is to design a protocol, and then to provide a default implementation of the protocol with a type (typically a struct). I feel this relationship could be bridged easier by simply returning this type from a protocol initializer, which could even potentially allow me to declare the actual type as private, so for all intents and purposes the client does simply get an initialized protocol object (similar in part to creating an anonymous class conforming to a protocol in Java).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I strongly agree that we should have factory initializers for protocols for the reasons you state here, plus many others.  It just seems like a natural fit.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would like to see a 3 stage approach:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Stage 1:  Declaring an init as “factory” allows you to return any fully inited object which fits the type (including calling self.init like a convenience init would and then returning it). If the init is failable, you can also return nil.  This works both on classes and protocols.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Stage 2:  The compiler builds a table of the overrides of a given factory init, and there is some syntax to call them (e.g. “let sub = subclasses.init(value)”) such that the first one to return non-nil is the return value to that call.  Thorsten’s depth first + alphabetical ordering would be adequate to make the behavior predictable.  Again, this should work for both classes and protocols. (I am open to better ideas for syntax/naming)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Stage 3: We allow greater control over the ordering in the table. This still needs thought both on syntax and method.  Something similar to operator precedence (or autolayout priority) would work in a pinch, but isn’t super elegant. In practice, it might be enough just to be able to declare that something needs to be before/after a specific subclass in the list.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Note: A slightly different approach to stage 2 (for classes) might have only the direct subclasses in the table, and then the subclasses have the option to call off to their own subclasses in the same manner if desired.  This has the tradeoff that each level needs to plan for extensibility (i.e. you can’t override something which wasn’t expecting to be subclassed), but I do like how it simplifies the model a bit.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I have a feeling that the proper syntax for stages 2/3 may become more obvious once the design work around mixins/protocols+storage gets done.  It may just fall out of the disambiguation syntax...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mar 22, 2016, at 5:21 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes and No.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, because this is a problem I run into all the time, and I really want swift to have a solution for it. I especially like Brent’s idea of a protocol init.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, because I have gotten a bit greedy. I want us to take a step back and look at the underlying problem to see if we can come up with something which completely solves it… and I think factories get us only part way there. Let’s take a moment and see if we can create something uniquely swift before we copy/paste existing solutions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Think about Cocoa’s class clusters for a moment. I love them, but they are a pain to subclass. To the level where any beginning Cocoa instruction tells you explicitly not to subclass them. Similarly, even in my own factories, they are always a pain to extend.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I want our factory inits to be extensible by default.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; By extensible, I mean that I want to be able to add a new subclass (or a new entity satisfying a protocol), and have it come out of the factory when appropriate without editing the base class! Madness, I know, but:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) I may not have access to the source of the base class (e.g. Cocoa Collections)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) I always feel a bit dirty giving the base class knowledge of it’s subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) It is a royal pain, and a potential source of errors as things get refactored when adding new subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think I have at least the seed of an idea of how to solve this, and I am hoping that one of you (who are all much smarter than I) might have the key to getting it the rest of the way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I ran into this problem again last week, and it made me think of an old language I used to use...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was a small programming language I used to use in the 90’s which had an interesting core language feature we called “handlers”. These were a lot like registering for notifications, except that writing a function (with a special “Handler” attribute: “Handler func myFuncName()&quot;) was all you needed to do to register. Writing “Handle myFuncName()” would then systematically call every function with that name and the Handler attribute.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is, instead of calling a single function, it would systematically call a series of functions (all with the same name).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was one other thing that made these handlers special. Each one had the option, when it was called, to reply that it was the one true handler, and the others didn’t need to be called. Basically, it said “I&#39;ve got this!”. This even allowed it to return a result to the caller.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The original intent of this feature (and why it was a core language feature) was to handle events. It would handle things like hit testing and key events fairly elegantly. It was a powerful feature, so it was quickly used for other things. It made things like plug-ins ridiculously simple. We even used it for a form of error handling.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I remember helping to write a page layout program in it, and we used handlers not just for the hit testing, but for the tool palette as well. The end result was that you were able to add new shapes and new tools without modifying existing code at all. It is a feature I miss all the time...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is more power than we need here, but it provided me the inspiration for a potential solution to the factory problem. Back to swift…<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The idea here is to give each interested subclass a chance to say “I&#39;ve got this!”. The factory init runs through each of the subclasses’ overrides until it finds one that doesn’t return nil. New subclasses can be added and they will be given a chance as well (without modifying the base class). The first subclass to successfully init wins. (only subclasses which override the factory init would be considered)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //I like having an explicit call, so that the traditional (non-distributed) factory is possible as well<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         return factory.init(type) //We could also call this “subclass.init(type)” to mirror super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory override init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         guard type == compatibleWithThisType else {return nil} //If info doesn’t work for us, we return nil, and the next class gets a shot<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	//Init concrete type here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The main issue which still needs to be solved is that the order they get called sometimes really matters (this was solved by a well defined ordering + IDE features in the language mentioned above). For the most part, as long as subclasses are called before their superclasses (or there is a some method for cascading), it works. There are still times where you want to define a specific ordering though (e.g. a new subclass wants to get called before an existing subclasses to override some of it’s use cases).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I see a few options (and I would love to hear more):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - subclasses define a numeric precedence (similar to operators now). This is probably the most effective stop-gap solution, but is not elegant.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - subclasses do whatever we change operator precedence to do in the future<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - optionally allow subclasses to name another specific subclass that they are before/after<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - allow subclasses to declare that they would like to be earlier or later (or that they don’t care) in the calling list. subclasses defined outside of the module where the base class was defined would be placed more extremely early/late. Exact order is undefined, but rough ordering is possible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - return (to the superclass) an array of all subclasses which successfully inited. It can then select which one it wants and return it. This seems overly inefficient to me, since you are initializing a bunch of unused objects.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - &lt;Your idea here&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The end result is that you can extend factories of both classes and protocols without access to the original source code.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I also don’t think that the base should always need to be abstract. Factory inits should allow returning subclasses as a way of replacing themselves with a subclass, and returning nil if they are failable, but if there is no return (or return self), it can create an instance of itself. This way, it provides a customization point where subclasses can handle special cases, but the class itself provides an obvious default (i.e. a much less messy form of class cluster).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory init(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	if let subclass = factory.init(type){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	    return subclass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	return self.init()//If subclasses didn’t work, initialize ourselves<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?  Too crazy to consider?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; # Factory Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Protocol Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Riley Testut<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/458437f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>March 30, 2016 at 03:00:00am</p></header><div class="content"><p>Yeah.  I was thinking we would want to mirror the convenience initializer syntax, but I am completely ok with this as well.  Honestly this is the syntax I first tried to use in convenience inits while learning swift, and I would love to see that migrate to something like this.  My only worry would be that people would be confused on when to use ClassName() and when to use self.init().  Best to choose one and stick with it.<br></p><p>Thanks,<br>Jon<br></p><p>&gt; On Mar 30, 2016, at 3:36 AM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt; <br>&gt; If we are to enforce a different type signature for factory initializers vs required/convenience initializers (which would greatly simplify this issue), if I’m understanding correctly, there shouldn’t be a need to be able to “return” self.init(), right? Because you could do this instead:<br>&gt; <br>&gt; public class ConcreteBase {<br>&gt; <br>&gt; 	private init(type2: InformationToSwitchOn) {<br>&gt; 		//Default implementation here<br>&gt; 	}<br>&gt; <br>&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt; 		if … {<br>&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt; 		}<br>&gt; 		return ConcreteBase(type) //Handle the general case with the main class<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; class SpecialSubclass : ConcreteBase {}<br>&gt; <br>&gt;&gt; On Mar 30, 2016, at 3:30 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Doh!  <br>&gt;&gt; <br>&gt;&gt; Sorry, typed that up in mail while working on something else at the same time.  We shouldn’t allow an init with the same signature.  self.init() could be called with different parameters.  Trying to call the factory method from the factory method should generate an error.<br>&gt;&gt; <br>&gt;&gt; We probably also want to disallow having an init with the same signature in subclasses as well (we could pass the same info with different parameter names) as a subclass which doesn’t override it would again be calling the factory method.  Ultimately, I would like to see the ability to override the factory method with the behavior I described earlier… but that is for a later proposal.<br>&gt;&gt; <br>&gt;&gt; Basically we should be able to return anything which adheres to the type, so we are free to use other initializers on the class/subclasses.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 30, 2016, at 3:10 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ah, good catch. Would that be confusing as to whether self.init() would lead to an infinite loop, or call the required initializer? Unlike convenience initializers, factory initializers might have the same signature as the required ones.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 30, 2016, at 2:52 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Agreed.  I would like to see what I was referring to as “stage 1” in this proposal, and we can (hopefully) add on a full solution over time.  (I just wanted to make sure we considered those cases so we didn’t block future improvements)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Looking at the proposal, my only contention would be that we should also allow self.init() to be called from the factory init (similar to a convenience init).  It could still be used with an AbstractBase as shown in your example (especially when dealing with protocols), but it shouldn’t force us to be abstract in the class case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In other words, we should also be able to do the following:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public class ConcreteBase {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	private init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt; 		//Default implementation here<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt; 		if … {<br>&gt;&gt;&gt;&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt; 		return self.init(type) //Handle the general case with the main class<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class SpecialSubclass : ConcreteBase {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The behavior should simply be that we can return any init’d object that conforms to the given type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 2:20 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ultimately, while these are good points, I feel the full mechanism for class clusters belong in a separate proposal. The focus for this one I believe should be the underlying mechanism of factory initializers; should that be approved, then we can focus on adding additional features on top of it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That being said, I’ve written up essentially a final version of the proposal, which you can find here: https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md &lt;https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md&gt;. Assuming everyone is happy with it, I’ll send a pull request in the next few days to the main-repo. But please, give any last minute feedback now!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 5:12 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Comments inline.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 12:10 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; While I do believe your proposed additions have their benefits, my gut tells me this is too large a change to Swift for an arguably small gain. For this proposal, I&#39;m wanting to keep the change as minimalistic as possible, while still providing enough flexibility and use cases to warrant it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I can definitely see the argument that extensibility is out of scope for Swift 3, but I do want to make sure that it is possible for us to have extensibility in the future (that we don’t block ourselves from doing it).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I strongly disagree that the gain is small.  One of the core benefits of both Swift/ObjC (and now POP) is the ability to extend things post-hoc, without access to the original code.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I often write libraries &amp; SDKs, so the users of my code don&#39;t have access to the original code.  I guess extensibility is less necessary when you control the entire codebase, but you still have to refactor your factory whenever you subclass (or adhere to a protocol), which I find problematic.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is something I run into a lot while writing actual code, so it isn’t just a theoretical concern.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Interesting you bring up the registering of subclasses, as that is similar to the very original proposal, and actually similar to what I&#39;m doing in my own app. Effectively, I have an Objective-C base class, and in +load it dynamically finds all subclasses using the Objective-C runtime, and stores a reference to them. Then in the initializer, it returns the appropriate subclass based on the initialization parameters. This was my solution to the superclass not having to explicitly know each individual subclass.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Using factory initializers, however, this pattern could be used in pure Swift, albeit with some minor modifications. At program start, the program could register subclasses with the superclass, and then in the initializer would simply return the appropriate subclass (similar to NSURLProtocol, I believe).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, I have also used load in this way in ObjC.  In Swift, I think the compiler could easily build an array/table of the overloads of factory inits.  This avoids having to register explicitly (the declaration itself implies intent to register), and doesn’t take up any cycles during execution.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I ran into the problem of when to register the other day in a current project, as Swift doesn’t have an equivalent to +load that I am aware of.  I had to settle for something of a hack which gets called on first use… but it was only a partial solution which worked in that particular case.  How do the swift classes/enums/structs get called to register themselves?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We may want to propose adding a +load equivalent for Swift types, since it does come up occasionally. It is one of those things which you don’t need often, but when you do, you really need it.  Ironically, this was one of the uses of the original feature I talked about earlier (we used it to provide the equivalent of +load, awakeFromNib, etc… in the language). <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As for rationale for protocol (factory) initializers, a common pattern I&#39;ve come across when developing my internal frameworks is to design a protocol, and then to provide a default implementation of the protocol with a type (typically a struct). I feel this relationship could be bridged easier by simply returning this type from a protocol initializer, which could even potentially allow me to declare the actual type as private, so for all intents and purposes the client does simply get an initialized protocol object (similar in part to creating an anonymous class conforming to a protocol in Java).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I strongly agree that we should have factory initializers for protocols for the reasons you state here, plus many others.  It just seems like a natural fit.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would like to see a 3 stage approach:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Stage 1:  Declaring an init as “factory” allows you to return any fully inited object which fits the type (including calling self.init like a convenience init would and then returning it). If the init is failable, you can also return nil.  This works both on classes and protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Stage 2:  The compiler builds a table of the overrides of a given factory init, and there is some syntax to call them (e.g. “let sub = subclasses.init(value)”) such that the first one to return non-nil is the return value to that call.  Thorsten’s depth first + alphabetical ordering would be adequate to make the behavior predictable.  Again, this should work for both classes and protocols. (I am open to better ideas for syntax/naming)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Stage 3: We allow greater control over the ordering in the table. This still needs thought both on syntax and method.  Something similar to operator precedence (or autolayout priority) would work in a pinch, but isn’t super elegant. In practice, it might be enough just to be able to declare that something needs to be before/after a specific subclass in the list.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Note: A slightly different approach to stage 2 (for classes) might have only the direct subclasses in the table, and then the subclasses have the option to call off to their own subclasses in the same manner if desired.  This has the tradeoff that each level needs to plan for extensibility (i.e. you can’t override something which wasn’t expecting to be subclassed), but I do like how it simplifies the model a bit.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I have a feeling that the proper syntax for stages 2/3 may become more obvious once the design work around mixins/protocols+storage gets done.  It may just fall out of the disambiguation syntax...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 22, 2016, at 5:21 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes and No.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, because this is a problem I run into all the time, and I really want swift to have a solution for it. I especially like Brent’s idea of a protocol init.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, because I have gotten a bit greedy. I want us to take a step back and look at the underlying problem to see if we can come up with something which completely solves it… and I think factories get us only part way there. Let’s take a moment and see if we can create something uniquely swift before we copy/paste existing solutions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Think about Cocoa’s class clusters for a moment. I love them, but they are a pain to subclass. To the level where any beginning Cocoa instruction tells you explicitly not to subclass them. Similarly, even in my own factories, they are always a pain to extend.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I want our factory inits to be extensible by default.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; By extensible, I mean that I want to be able to add a new subclass (or a new entity satisfying a protocol), and have it come out of the factory when appropriate without editing the base class! Madness, I know, but:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) I may not have access to the source of the base class (e.g. Cocoa Collections)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) I always feel a bit dirty giving the base class knowledge of it’s subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) It is a royal pain, and a potential source of errors as things get refactored when adding new subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think I have at least the seed of an idea of how to solve this, and I am hoping that one of you (who are all much smarter than I) might have the key to getting it the rest of the way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I ran into this problem again last week, and it made me think of an old language I used to use...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was a small programming language I used to use in the 90’s which had an interesting core language feature we called “handlers”. These were a lot like registering for notifications, except that writing a function (with a special “Handler” attribute: “Handler func myFuncName()&quot;) was all you needed to do to register. Writing “Handle myFuncName()” would then systematically call every function with that name and the Handler attribute.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is, instead of calling a single function, it would systematically call a series of functions (all with the same name).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was one other thing that made these handlers special. Each one had the option, when it was called, to reply that it was the one true handler, and the others didn’t need to be called. Basically, it said “I&#39;ve got this!”. This even allowed it to return a result to the caller.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The original intent of this feature (and why it was a core language feature) was to handle events. It would handle things like hit testing and key events fairly elegantly. It was a powerful feature, so it was quickly used for other things. It made things like plug-ins ridiculously simple. We even used it for a form of error handling.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I remember helping to write a page layout program in it, and we used handlers not just for the hit testing, but for the tool palette as well. The end result was that you were able to add new shapes and new tools without modifying existing code at all. It is a feature I miss all the time...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is more power than we need here, but it provided me the inspiration for a potential solution to the factory problem. Back to swift…<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The idea here is to give each interested subclass a chance to say “I&#39;ve got this!”. The factory init runs through each of the subclasses’ overrides until it finds one that doesn’t return nil. New subclasses can be added and they will be given a chance as well (without modifying the base class). The first subclass to successfully init wins. (only subclasses which override the factory init would be considered)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //I like having an explicit call, so that the traditional (non-distributed) factory is possible as well<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         return factory.init(type) //We could also call this “subclass.init(type)” to mirror super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory override init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         guard type == compatibleWithThisType else {return nil} //If info doesn’t work for us, we return nil, and the next class gets a shot<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	//Init concrete type here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The main issue which still needs to be solved is that the order they get called sometimes really matters (this was solved by a well defined ordering + IDE features in the language mentioned above). For the most part, as long as subclasses are called before their superclasses (or there is a some method for cascading), it works. There are still times where you want to define a specific ordering though (e.g. a new subclass wants to get called before an existing subclasses to override some of it’s use cases).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I see a few options (and I would love to hear more):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - subclasses define a numeric precedence (similar to operators now). This is probably the most effective stop-gap solution, but is not elegant.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - subclasses do whatever we change operator precedence to do in the future<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - optionally allow subclasses to name another specific subclass that they are before/after<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - allow subclasses to declare that they would like to be earlier or later (or that they don’t care) in the calling list. subclasses defined outside of the module where the base class was defined would be placed more extremely early/late. Exact order is undefined, but rough ordering is possible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - return (to the superclass) an array of all subclasses which successfully inited. It can then select which one it wants and return it. This seems overly inefficient to me, since you are initializing a bunch of unused objects.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - &lt;Your idea here&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The end result is that you can extend factories of both classes and protocols without access to the original source code.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I also don’t think that the base should always need to be abstract. Factory inits should allow returning subclasses as a way of replacing themselves with a subclass, and returning nil if they are failable, but if there is no return (or return self), it can create an instance of itself. This way, it provides a customization point where subclasses can handle special cases, but the class itself provides an obvious default (i.e. a much less messy form of class cluster).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory init(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	if let subclass = factory.init(type){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	    return subclass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	return self.init()//If subclasses didn’t work, initialize ourselves<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?  Too crazy to consider?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; # Factory Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Protocol Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Riley Testut<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/bf5dce8a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>March 30, 2016 at 01:00:00pm</p></header><div class="content"><p>Another point to consider: should factory initializers be able to be overridden by subclasses? I vote no, just as you can&#39;t override convenience initializers.<br></p><p>&gt; On Mar 30, 2016, at 3:50 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt; <br>&gt; Yeah.  I was thinking we would want to mirror the convenience initializer syntax, but I am completely ok with this as well.  Honestly this is the syntax I first tried to use in convenience inits while learning swift, and I would love to see that migrate to something like this.  My only worry would be that people would be confused on when to use ClassName() and when to use self.init().  Best to choose one and stick with it.<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt;&gt; On Mar 30, 2016, at 3:36 AM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If we are to enforce a different type signature for factory initializers vs required/convenience initializers (which would greatly simplify this issue), if I’m understanding correctly, there shouldn’t be a need to be able to “return” self.init(), right? Because you could do this instead:<br>&gt;&gt; <br>&gt;&gt; public class ConcreteBase {<br>&gt;&gt; <br>&gt;&gt; 	private init(type2: InformationToSwitchOn) {<br>&gt;&gt; 		//Default implementation here<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt;&gt; 		if … {<br>&gt;&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt;&gt; 		}<br>&gt;&gt; 		return ConcreteBase(type) //Handle the general case with the main class<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class SpecialSubclass : ConcreteBase {}<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 30, 2016, at 3:30 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Doh!  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, typed that up in mail while working on something else at the same time.  We shouldn’t allow an init with the same signature.  self.init() could be called with different parameters.  Trying to call the factory method from the factory method should generate an error.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We probably also want to disallow having an init with the same signature in subclasses as well (we could pass the same info with different parameter names) as a subclass which doesn’t override it would again be calling the factory method.  Ultimately, I would like to see the ability to override the factory method with the behavior I described earlier… but that is for a later proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Basically we should be able to return anything which adheres to the type, so we are free to use other initializers on the class/subclasses.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:10 AM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ah, good catch. Would that be confusing as to whether self.init() would lead to an infinite loop, or call the required initializer? Unlike convenience initializers, factory initializers might have the same signature as the required ones.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 2:52 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Agreed.  I would like to see what I was referring to as “stage 1” in this proposal, and we can (hopefully) add on a full solution over time.  (I just wanted to make sure we considered those cases so we didn’t block future improvements)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Looking at the proposal, my only contention would be that we should also allow self.init() to be called from the factory init (similar to a convenience init).  It could still be used with an AbstractBase as shown in your example (especially when dealing with protocols), but it shouldn’t force us to be abstract in the class case.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In other words, we should also be able to do the following:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; public class ConcreteBase {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	private init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt; 		//Default implementation here<br>&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt; 		if … {<br>&gt;&gt;&gt;&gt;&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt;&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt;&gt; 		return self.init(type) //Handle the general case with the main class<br>&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class SpecialSubclass : ConcreteBase {}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The behavior should simply be that we can return any init’d object that conforms to the given type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 2:20 AM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Ultimately, while these are good points, I feel the full mechanism for class clusters belong in a separate proposal. The focus for this one I believe should be the underlying mechanism of factory initializers; should that be approved, then we can focus on adding additional features on top of it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That being said, I’ve written up essentially a final version of the proposal, which you can find here: https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md. Assuming everyone is happy with it, I’ll send a pull request in the next few days to the main-repo. But please, give any last minute feedback now!<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 5:12 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comments inline.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 12:10 AM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While I do believe your proposed additions have their benefits, my gut tells me this is too large a change to Swift for an arguably small gain. For this proposal, I&#39;m wanting to keep the change as minimalistic as possible, while still providing enough flexibility and use cases to warrant it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can definitely see the argument that extensibility is out of scope for Swift 3, but I do want to make sure that it is possible for us to have extensibility in the future (that we don’t block ourselves from doing it).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I strongly disagree that the gain is small.  One of the core benefits of both Swift/ObjC (and now POP) is the ability to extend things post-hoc, without access to the original code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I often write libraries &amp; SDKs, so the users of my code don&#39;t have access to the original code.  I guess extensibility is less necessary when you control the entire codebase, but you still have to refactor your factory whenever you subclass (or adhere to a protocol), which I find problematic.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is something I run into a lot while writing actual code, so it isn’t just a theoretical concern.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Interesting you bring up the registering of subclasses, as that is similar to the very original proposal, and actually similar to what I&#39;m doing in my own app. Effectively, I have an Objective-C base class, and in +load it dynamically finds all subclasses using the Objective-C runtime, and stores a reference to them. Then in the initializer, it returns the appropriate subclass based on the initialization parameters. This was my solution to the superclass not having to explicitly know each individual subclass.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Using factory initializers, however, this pattern could be used in pure Swift, albeit with some minor modifications. At program start, the program could register subclasses with the superclass, and then in the initializer would simply return the appropriate subclass (similar to NSURLProtocol, I believe).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, I have also used load in this way in ObjC.  In Swift, I think the compiler could easily build an array/table of the overloads of factory inits.  This avoids having to register explicitly (the declaration itself implies intent to register), and doesn’t take up any cycles during execution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I ran into the problem of when to register the other day in a current project, as Swift doesn’t have an equivalent to +load that I am aware of.  I had to settle for something of a hack which gets called on first use… but it was only a partial solution which worked in that particular case.  How do the swift classes/enums/structs get called to register themselves?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We may want to propose adding a +load equivalent for Swift types, since it does come up occasionally. It is one of those things which you don’t need often, but when you do, you really need it.  Ironically, this was one of the uses of the original feature I talked about earlier (we used it to provide the equivalent of +load, awakeFromNib, etc… in the language). <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As for rationale for protocol (factory) initializers, a common pattern I&#39;ve come across when developing my internal frameworks is to design a protocol, and then to provide a default implementation of the protocol with a type (typically a struct). I feel this relationship could be bridged easier by simply returning this type from a protocol initializer, which could even potentially allow me to declare the actual type as private, so for all intents and purposes the client does simply get an initialized protocol object (similar in part to creating an anonymous class conforming to a protocol in Java).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I strongly agree that we should have factory initializers for protocols for the reasons you state here, plus many others.  It just seems like a natural fit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would like to see a 3 stage approach:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 1:  Declaring an init as “factory” allows you to return any fully inited object which fits the type (including calling self.init like a convenience init would and then returning it). If the init is failable, you can also return nil.  This works both on classes and protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 2:  The compiler builds a table of the overrides of a given factory init, and there is some syntax to call them (e.g. “let sub = subclasses.init(value)”) such that the first one to return non-nil is the return value to that call.  Thorsten’s depth first + alphabetical ordering would be adequate to make the behavior predictable.  Again, this should work for both classes and protocols. (I am open to better ideas for syntax/naming)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 3: We allow greater control over the ordering in the table. This still needs thought both on syntax and method.  Something similar to operator precedence (or autolayout priority) would work in a pinch, but isn’t super elegant. In practice, it might be enough just to be able to declare that something needs to be before/after a specific subclass in the list.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note: A slightly different approach to stage 2 (for classes) might have only the direct subclasses in the table, and then the subclasses have the option to call off to their own subclasses in the same manner if desired.  This has the tradeoff that each level needs to plan for extensibility (i.e. you can’t override something which wasn’t expecting to be subclassed), but I do like how it simplifies the model a bit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have a feeling that the proper syntax for stages 2/3 may become more obvious once the design work around mixins/protocols+storage gets done.  It may just fall out of the disambiguation syntax...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 22, 2016, at 5:21 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes and No.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, because this is a problem I run into all the time, and I really want swift to have a solution for it. I especially like Brent’s idea of a protocol init.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, because I have gotten a bit greedy. I want us to take a step back and look at the underlying problem to see if we can come up with something which completely solves it… and I think factories get us only part way there. Let’s take a moment and see if we can create something uniquely swift before we copy/paste existing solutions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Think about Cocoa’s class clusters for a moment. I love them, but they are a pain to subclass. To the level where any beginning Cocoa instruction tells you explicitly not to subclass them. Similarly, even in my own factories, they are always a pain to extend.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I want our factory inits to be extensible by default.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; By extensible, I mean that I want to be able to add a new subclass (or a new entity satisfying a protocol), and have it come out of the factory when appropriate without editing the base class! Madness, I know, but:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) I may not have access to the source of the base class (e.g. Cocoa Collections)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) I always feel a bit dirty giving the base class knowledge of it’s subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) It is a royal pain, and a potential source of errors as things get refactored when adding new subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think I have at least the seed of an idea of how to solve this, and I am hoping that one of you (who are all much smarter than I) might have the key to getting it the rest of the way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I ran into this problem again last week, and it made me think of an old language I used to use...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was a small programming language I used to use in the 90’s which had an interesting core language feature we called “handlers”. These were a lot like registering for notifications, except that writing a function (with a special “Handler” attribute: “Handler func myFuncName()&quot;) was all you needed to do to register. Writing “Handle myFuncName()” would then systematically call every function with that name and the Handler attribute.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is, instead of calling a single function, it would systematically call a series of functions (all with the same name).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was one other thing that made these handlers special. Each one had the option, when it was called, to reply that it was the one true handler, and the others didn’t need to be called. Basically, it said “I&#39;ve got this!”. This even allowed it to return a result to the caller.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The original intent of this feature (and why it was a core language feature) was to handle events. It would handle things like hit testing and key events fairly elegantly. It was a powerful feature, so it was quickly used for other things. It made things like plug-ins ridiculously simple. We even used it for a form of error handling.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I remember helping to write a page layout program in it, and we used handlers not just for the hit testing, but for the tool palette as well. The end result was that you were able to add new shapes and new tools without modifying existing code at all. It is a feature I miss all the time...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is more power than we need here, but it provided me the inspiration for a potential solution to the factory problem. Back to swift…<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The idea here is to give each interested subclass a chance to say “I&#39;ve got this!”. The factory init runs through each of the subclasses’ overrides until it finds one that doesn’t return nil. New subclasses can be added and they will be given a chance as well (without modifying the base class). The first subclass to successfully init wins. (only subclasses which override the factory init would be considered)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //I like having an explicit call, so that the traditional (non-distributed) factory is possible as well<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         return factory.init(type) //We could also call this “subclass.init(type)” to mirror super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory override init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         guard type == compatibleWithThisType else {return nil} //If info doesn’t work for us, we return nil, and the next class gets a shot<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	//Init concrete type here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The main issue which still needs to be solved is that the order they get called sometimes really matters (this was solved by a well defined ordering + IDE features in the language mentioned above). For the most part, as long as subclasses are called before their superclasses (or there is a some method for cascading), it works. There are still times where you want to define a specific ordering though (e.g. a new subclass wants to get called before an existing subclasses to override some of it’s use cases).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I see a few options (and I would love to hear more):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - subclasses define a numeric precedence (similar to operators now). This is probably the most effective stop-gap solution, but is not elegant.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - subclasses do whatever we change operator precedence to do in the future<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - optionally allow subclasses to name another specific subclass that they are before/after<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - allow subclasses to declare that they would like to be earlier or later (or that they don’t care) in the calling list. subclasses defined outside of the module where the base class was defined would be placed more extremely early/late. Exact order is undefined, but rough ordering is possible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - return (to the superclass) an array of all subclasses which successfully inited. It can then select which one it wants and return it. This seems overly inefficient to me, since you are initializing a bunch of unused objects.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - &lt;Your idea here&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The end result is that you can extend factories of both classes and protocols without access to the original source code.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I also don’t think that the base should always need to be abstract. Factory inits should allow returning subclasses as a way of replacing themselves with a subclass, and returning nil if they are failable, but if there is no return (or return self), it can create an instance of itself. This way, it provides a customization point where subclasses can handle special cases, but the class itself provides an obvious default (i.e. a much less messy form of class cluster).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory init(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	if let subclass = factory.init(type){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	    return subclass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	return self.init()//If subclasses didn’t work, initialize ourselves<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?  Too crazy to consider?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; # Factory Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Protocol Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Riley Testut<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Charles<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/e54dd9a2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>March 30, 2016 at 01:00:00pm</p></header><div class="content"><p>Probably ‘no&#39; in this proposal to keep things simple.<br></p><p>Long term, I would like overriding of the factory init to be the mechanism for a post-hoc extendable factory.  Disallowing it now probably makes that easier in the future.<br></p><p>Thanks,<br>Jon<br></p><p><br>&gt; On Mar 30, 2016, at 1:20 PM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt; <br>&gt; Another point to consider: should factory initializers be able to be overridden by subclasses? I vote no, just as you can&#39;t override convenience initializers.<br>&gt; <br>&gt; On Mar 30, 2016, at 3:50 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Yeah.  I was thinking we would want to mirror the convenience initializer syntax, but I am completely ok with this as well.  Honestly this is the syntax I first tried to use in convenience inits while learning swift, and I would love to see that migrate to something like this.  My only worry would be that people would be confused on when to use ClassName() and when to use self.init().  Best to choose one and stick with it.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 30, 2016, at 3:36 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we are to enforce a different type signature for factory initializers vs required/convenience initializers (which would greatly simplify this issue), if I’m understanding correctly, there shouldn’t be a need to be able to “return” self.init(), right? Because you could do this instead:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class ConcreteBase {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	private init(type2: InformationToSwitchOn) {<br>&gt;&gt;&gt; 		//Default implementation here<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt;&gt;&gt; 		if … {<br>&gt;&gt;&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt;&gt;&gt; 		}<br>&gt;&gt;&gt; 		return ConcreteBase(type) //Handle the general case with the main class<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class SpecialSubclass : ConcreteBase {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:30 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Doh!  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry, typed that up in mail while working on something else at the same time.  We shouldn’t allow an init with the same signature.  self.init() could be called with different parameters.  Trying to call the factory method from the factory method should generate an error.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We probably also want to disallow having an init with the same signature in subclasses as well (we could pass the same info with different parameter names) as a subclass which doesn’t override it would again be calling the factory method.  Ultimately, I would like to see the ability to override the factory method with the behavior I described earlier… but that is for a later proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Basically we should be able to return anything which adheres to the type, so we are free to use other initializers on the class/subclasses.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:10 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ah, good catch. Would that be confusing as to whether self.init() would lead to an infinite loop, or call the required initializer? Unlike convenience initializers, factory initializers might have the same signature as the required ones.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 2:52 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Agreed.  I would like to see what I was referring to as “stage 1” in this proposal, and we can (hopefully) add on a full solution over time.  (I just wanted to make sure we considered those cases so we didn’t block future improvements)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Looking at the proposal, my only contention would be that we should also allow self.init() to be called from the factory init (similar to a convenience init).  It could still be used with an AbstractBase as shown in your example (especially when dealing with protocols), but it shouldn’t force us to be abstract in the class case.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In other words, we should also be able to do the following:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; public class ConcreteBase {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	private init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt; 		//Default implementation here<br>&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt; 		if … {<br>&gt;&gt;&gt;&gt;&gt;&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt;&gt;&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt;&gt;&gt; 		return self.init(type) //Handle the general case with the main class<br>&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class SpecialSubclass : ConcreteBase {}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The behavior should simply be that we can return any init’d object that conforms to the given type.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 2:20 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ultimately, while these are good points, I feel the full mechanism for class clusters belong in a separate proposal. The focus for this one I believe should be the underlying mechanism of factory initializers; should that be approved, then we can focus on adding additional features on top of it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That being said, I’ve written up essentially a final version of the proposal, which you can find here: https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md &lt;https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md&gt;. Assuming everyone is happy with it, I’ll send a pull request in the next few days to the main-repo. But please, give any last minute feedback now!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 5:12 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comments inline.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 12:10 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While I do believe your proposed additions have their benefits, my gut tells me this is too large a change to Swift for an arguably small gain. For this proposal, I&#39;m wanting to keep the change as minimalistic as possible, while still providing enough flexibility and use cases to warrant it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can definitely see the argument that extensibility is out of scope for Swift 3, but I do want to make sure that it is possible for us to have extensibility in the future (that we don’t block ourselves from doing it).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I strongly disagree that the gain is small.  One of the core benefits of both Swift/ObjC (and now POP) is the ability to extend things post-hoc, without access to the original code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I often write libraries &amp; SDKs, so the users of my code don&#39;t have access to the original code.  I guess extensibility is less necessary when you control the entire codebase, but you still have to refactor your factory whenever you subclass (or adhere to a protocol), which I find problematic.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is something I run into a lot while writing actual code, so it isn’t just a theoretical concern.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Interesting you bring up the registering of subclasses, as that is similar to the very original proposal, and actually similar to what I&#39;m doing in my own app. Effectively, I have an Objective-C base class, and in +load it dynamically finds all subclasses using the Objective-C runtime, and stores a reference to them. Then in the initializer, it returns the appropriate subclass based on the initialization parameters. This was my solution to the superclass not having to explicitly know each individual subclass.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Using factory initializers, however, this pattern could be used in pure Swift, albeit with some minor modifications. At program start, the program could register subclasses with the superclass, and then in the initializer would simply return the appropriate subclass (similar to NSURLProtocol, I believe).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, I have also used load in this way in ObjC.  In Swift, I think the compiler could easily build an array/table of the overloads of factory inits.  This avoids having to register explicitly (the declaration itself implies intent to register), and doesn’t take up any cycles during execution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I ran into the problem of when to register the other day in a current project, as Swift doesn’t have an equivalent to +load that I am aware of.  I had to settle for something of a hack which gets called on first use… but it was only a partial solution which worked in that particular case.  How do the swift classes/enums/structs get called to register themselves?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We may want to propose adding a +load equivalent for Swift types, since it does come up occasionally. It is one of those things which you don’t need often, but when you do, you really need it.  Ironically, this was one of the uses of the original feature I talked about earlier (we used it to provide the equivalent of +load, awakeFromNib, etc… in the language). <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As for rationale for protocol (factory) initializers, a common pattern I&#39;ve come across when developing my internal frameworks is to design a protocol, and then to provide a default implementation of the protocol with a type (typically a struct). I feel this relationship could be bridged easier by simply returning this type from a protocol initializer, which could even potentially allow me to declare the actual type as private, so for all intents and purposes the client does simply get an initialized protocol object (similar in part to creating an anonymous class conforming to a protocol in Java).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I strongly agree that we should have factory initializers for protocols for the reasons you state here, plus many others.  It just seems like a natural fit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would like to see a 3 stage approach:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 1:  Declaring an init as “factory” allows you to return any fully inited object which fits the type (including calling self.init like a convenience init would and then returning it). If the init is failable, you can also return nil.  This works both on classes and protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 2:  The compiler builds a table of the overrides of a given factory init, and there is some syntax to call them (e.g. “let sub = subclasses.init(value)”) such that the first one to return non-nil is the return value to that call.  Thorsten’s depth first + alphabetical ordering would be adequate to make the behavior predictable.  Again, this should work for both classes and protocols. (I am open to better ideas for syntax/naming)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 3: We allow greater control over the ordering in the table. This still needs thought both on syntax and method.  Something similar to operator precedence (or autolayout priority) would work in a pinch, but isn’t super elegant. In practice, it might be enough just to be able to declare that something needs to be before/after a specific subclass in the list.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note: A slightly different approach to stage 2 (for classes) might have only the direct subclasses in the table, and then the subclasses have the option to call off to their own subclasses in the same manner if desired.  This has the tradeoff that each level needs to plan for extensibility (i.e. you can’t override something which wasn’t expecting to be subclassed), but I do like how it simplifies the model a bit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have a feeling that the proper syntax for stages 2/3 may become more obvious once the design work around mixins/protocols+storage gets done.  It may just fall out of the disambiguation syntax...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 22, 2016, at 5:21 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes and No.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, because this is a problem I run into all the time, and I really want swift to have a solution for it. I especially like Brent’s idea of a protocol init.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, because I have gotten a bit greedy. I want us to take a step back and look at the underlying problem to see if we can come up with something which completely solves it… and I think factories get us only part way there. Let’s take a moment and see if we can create something uniquely swift before we copy/paste existing solutions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Think about Cocoa’s class clusters for a moment. I love them, but they are a pain to subclass. To the level where any beginning Cocoa instruction tells you explicitly not to subclass them. Similarly, even in my own factories, they are always a pain to extend.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I want our factory inits to be extensible by default.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; By extensible, I mean that I want to be able to add a new subclass (or a new entity satisfying a protocol), and have it come out of the factory when appropriate without editing the base class! Madness, I know, but:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) I may not have access to the source of the base class (e.g. Cocoa Collections)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) I always feel a bit dirty giving the base class knowledge of it’s subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) It is a royal pain, and a potential source of errors as things get refactored when adding new subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think I have at least the seed of an idea of how to solve this, and I am hoping that one of you (who are all much smarter than I) might have the key to getting it the rest of the way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I ran into this problem again last week, and it made me think of an old language I used to use...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was a small programming language I used to use in the 90’s which had an interesting core language feature we called “handlers”. These were a lot like registering for notifications, except that writing a function (with a special “Handler” attribute: “Handler func myFuncName()&quot;) was all you needed to do to register. Writing “Handle myFuncName()” would then systematically call every function with that name and the Handler attribute.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is, instead of calling a single function, it would systematically call a series of functions (all with the same name).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was one other thing that made these handlers special. Each one had the option, when it was called, to reply that it was the one true handler, and the others didn’t need to be called. Basically, it said “I&#39;ve got this!”. This even allowed it to return a result to the caller.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The original intent of this feature (and why it was a core language feature) was to handle events. It would handle things like hit testing and key events fairly elegantly. It was a powerful feature, so it was quickly used for other things. It made things like plug-ins ridiculously simple. We even used it for a form of error handling.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I remember helping to write a page layout program in it, and we used handlers not just for the hit testing, but for the tool palette as well. The end result was that you were able to add new shapes and new tools without modifying existing code at all. It is a feature I miss all the time...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is more power than we need here, but it provided me the inspiration for a potential solution to the factory problem. Back to swift…<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The idea here is to give each interested subclass a chance to say “I&#39;ve got this!”. The factory init runs through each of the subclasses’ overrides until it finds one that doesn’t return nil. New subclasses can be added and they will be given a chance as well (without modifying the base class). The first subclass to successfully init wins. (only subclasses which override the factory init would be considered)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //I like having an explicit call, so that the traditional (non-distributed) factory is possible as well<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         return factory.init(type) //We could also call this “subclass.init(type)” to mirror super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory override init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         guard type == compatibleWithThisType else {return nil} //If info doesn’t work for us, we return nil, and the next class gets a shot<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	//Init concrete type here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The main issue which still needs to be solved is that the order they get called sometimes really matters (this was solved by a well defined ordering + IDE features in the language mentioned above). For the most part, as long as subclasses are called before their superclasses (or there is a some method for cascading), it works. There are still times where you want to define a specific ordering though (e.g. a new subclass wants to get called before an existing subclasses to override some of it’s use cases).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I see a few options (and I would love to hear more):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - subclasses define a numeric precedence (similar to operators now). This is probably the most effective stop-gap solution, but is not elegant.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - subclasses do whatever we change operator precedence to do in the future<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - optionally allow subclasses to name another specific subclass that they are before/after<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - allow subclasses to declare that they would like to be earlier or later (or that they don’t care) in the calling list. subclasses defined outside of the module where the base class was defined would be placed more extremely early/late. Exact order is undefined, but rough ordering is possible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - return (to the superclass) an array of all subclasses which successfully inited. It can then select which one it wants and return it. This seems overly inefficient to me, since you are initializing a bunch of unused objects.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - &lt;Your idea here&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The end result is that you can extend factories of both classes and protocols without access to the original source code.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I also don’t think that the base should always need to be abstract. Factory inits should allow returning subclasses as a way of replacing themselves with a subclass, and returning nil if they are failable, but if there is no return (or return self), it can create an instance of itself. This way, it provides a customization point where subclasses can handle special cases, but the class itself provides an obvious default (i.e. a much less messy form of class cluster).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory init(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	if let subclass = factory.init(type){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	    return subclass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	return self.init()//If subclasses didn’t work, initialize ourselves<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?  Too crazy to consider?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; # Factory Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Protocol Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Riley Testut<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/6a67635e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>April  4, 2016 at 11:00:00am</p></header><div class="content"><p>Hey all!<br></p><p>Just updated the proposal with all the recent changes, and you can check it here: https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md &lt;https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md&gt;<br></p><p>Planning on submitting the PR later tonight, so please let me know if you have any last minute feedback!<br>Riley<br></p><p>&gt; On Mar 30, 2016, at 1:35 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt; <br>&gt; Probably ‘no&#39; in this proposal to keep things simple.<br>&gt; <br>&gt; Long term, I would like overriding of the factory init to be the mechanism for a post-hoc extendable factory.  Disallowing it now probably makes that easier in the future.<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 30, 2016, at 1:20 PM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Another point to consider: should factory initializers be able to be overridden by subclasses? I vote no, just as you can&#39;t override convenience initializers.<br>&gt;&gt; <br>&gt;&gt; On Mar 30, 2016, at 3:50 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Yeah.  I was thinking we would want to mirror the convenience initializer syntax, but I am completely ok with this as well.  Honestly this is the syntax I first tried to use in convenience inits while learning swift, and I would love to see that migrate to something like this.  My only worry would be that people would be confused on when to use ClassName() and when to use self.init().  Best to choose one and stick with it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:36 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we are to enforce a different type signature for factory initializers vs required/convenience initializers (which would greatly simplify this issue), if I’m understanding correctly, there shouldn’t be a need to be able to “return” self.init(), right? Because you could do this instead:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public class ConcreteBase {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	private init(type2: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt; 		//Default implementation here<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt; 		if … {<br>&gt;&gt;&gt;&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt; 		return ConcreteBase(type) //Handle the general case with the main class<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class SpecialSubclass : ConcreteBase {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:30 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Doh!  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sorry, typed that up in mail while working on something else at the same time.  We shouldn’t allow an init with the same signature.  self.init() could be called with different parameters.  Trying to call the factory method from the factory method should generate an error.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We probably also want to disallow having an init with the same signature in subclasses as well (we could pass the same info with different parameter names) as a subclass which doesn’t override it would again be calling the factory method.  Ultimately, I would like to see the ability to override the factory method with the behavior I described earlier… but that is for a later proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Basically we should be able to return anything which adheres to the type, so we are free to use other initializers on the class/subclasses.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:10 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Ah, good catch. Would that be confusing as to whether self.init() would lead to an infinite loop, or call the required initializer? Unlike convenience initializers, factory initializers might have the same signature as the required ones.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 2:52 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Agreed.  I would like to see what I was referring to as “stage 1” in this proposal, and we can (hopefully) add on a full solution over time.  (I just wanted to make sure we considered those cases so we didn’t block future improvements)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Looking at the proposal, my only contention would be that we should also allow self.init() to be called from the factory init (similar to a convenience init).  It could still be used with an AbstractBase as shown in your example (especially when dealing with protocols), but it shouldn’t force us to be abstract in the class case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In other words, we should also be able to do the following:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; public class ConcreteBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	private init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		//Default implementation here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		if … {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		return self.init(type) //Handle the general case with the main class<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class SpecialSubclass : ConcreteBase {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The behavior should simply be that we can return any init’d object that conforms to the given type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 2:20 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ultimately, while these are good points, I feel the full mechanism for class clusters belong in a separate proposal. The focus for this one I believe should be the underlying mechanism of factory initializers; should that be approved, then we can focus on adding additional features on top of it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That being said, I’ve written up essentially a final version of the proposal, which you can find here: https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md &lt;https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md&gt;. Assuming everyone is happy with it, I’ll send a pull request in the next few days to the main-repo. But please, give any last minute feedback now!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 5:12 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comments inline.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 12:10 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While I do believe your proposed additions have their benefits, my gut tells me this is too large a change to Swift for an arguably small gain. For this proposal, I&#39;m wanting to keep the change as minimalistic as possible, while still providing enough flexibility and use cases to warrant it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can definitely see the argument that extensibility is out of scope for Swift 3, but I do want to make sure that it is possible for us to have extensibility in the future (that we don’t block ourselves from doing it).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I strongly disagree that the gain is small.  One of the core benefits of both Swift/ObjC (and now POP) is the ability to extend things post-hoc, without access to the original code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I often write libraries &amp; SDKs, so the users of my code don&#39;t have access to the original code.  I guess extensibility is less necessary when you control the entire codebase, but you still have to refactor your factory whenever you subclass (or adhere to a protocol), which I find problematic.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is something I run into a lot while writing actual code, so it isn’t just a theoretical concern.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Interesting you bring up the registering of subclasses, as that is similar to the very original proposal, and actually similar to what I&#39;m doing in my own app. Effectively, I have an Objective-C base class, and in +load it dynamically finds all subclasses using the Objective-C runtime, and stores a reference to them. Then in the initializer, it returns the appropriate subclass based on the initialization parameters. This was my solution to the superclass not having to explicitly know each individual subclass.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Using factory initializers, however, this pattern could be used in pure Swift, albeit with some minor modifications. At program start, the program could register subclasses with the superclass, and then in the initializer would simply return the appropriate subclass (similar to NSURLProtocol, I believe).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, I have also used load in this way in ObjC.  In Swift, I think the compiler could easily build an array/table of the overloads of factory inits.  This avoids having to register explicitly (the declaration itself implies intent to register), and doesn’t take up any cycles during execution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I ran into the problem of when to register the other day in a current project, as Swift doesn’t have an equivalent to +load that I am aware of.  I had to settle for something of a hack which gets called on first use… but it was only a partial solution which worked in that particular case.  How do the swift classes/enums/structs get called to register themselves?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We may want to propose adding a +load equivalent for Swift types, since it does come up occasionally. It is one of those things which you don’t need often, but when you do, you really need it.  Ironically, this was one of the uses of the original feature I talked about earlier (we used it to provide the equivalent of +load, awakeFromNib, etc… in the language). <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As for rationale for protocol (factory) initializers, a common pattern I&#39;ve come across when developing my internal frameworks is to design a protocol, and then to provide a default implementation of the protocol with a type (typically a struct). I feel this relationship could be bridged easier by simply returning this type from a protocol initializer, which could even potentially allow me to declare the actual type as private, so for all intents and purposes the client does simply get an initialized protocol object (similar in part to creating an anonymous class conforming to a protocol in Java).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I strongly agree that we should have factory initializers for protocols for the reasons you state here, plus many others.  It just seems like a natural fit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would like to see a 3 stage approach:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 1:  Declaring an init as “factory” allows you to return any fully inited object which fits the type (including calling self.init like a convenience init would and then returning it). If the init is failable, you can also return nil.  This works both on classes and protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 2:  The compiler builds a table of the overrides of a given factory init, and there is some syntax to call them (e.g. “let sub = subclasses.init(value)”) such that the first one to return non-nil is the return value to that call.  Thorsten’s depth first + alphabetical ordering would be adequate to make the behavior predictable.  Again, this should work for both classes and protocols. (I am open to better ideas for syntax/naming)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 3: We allow greater control over the ordering in the table. This still needs thought both on syntax and method.  Something similar to operator precedence (or autolayout priority) would work in a pinch, but isn’t super elegant. In practice, it might be enough just to be able to declare that something needs to be before/after a specific subclass in the list.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note: A slightly different approach to stage 2 (for classes) might have only the direct subclasses in the table, and then the subclasses have the option to call off to their own subclasses in the same manner if desired.  This has the tradeoff that each level needs to plan for extensibility (i.e. you can’t override something which wasn’t expecting to be subclassed), but I do like how it simplifies the model a bit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have a feeling that the proper syntax for stages 2/3 may become more obvious once the design work around mixins/protocols+storage gets done.  It may just fall out of the disambiguation syntax...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 22, 2016, at 5:21 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes and No.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, because this is a problem I run into all the time, and I really want swift to have a solution for it. I especially like Brent’s idea of a protocol init.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, because I have gotten a bit greedy. I want us to take a step back and look at the underlying problem to see if we can come up with something which completely solves it… and I think factories get us only part way there. Let’s take a moment and see if we can create something uniquely swift before we copy/paste existing solutions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Think about Cocoa’s class clusters for a moment. I love them, but they are a pain to subclass. To the level where any beginning Cocoa instruction tells you explicitly not to subclass them. Similarly, even in my own factories, they are always a pain to extend.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I want our factory inits to be extensible by default.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; By extensible, I mean that I want to be able to add a new subclass (or a new entity satisfying a protocol), and have it come out of the factory when appropriate without editing the base class! Madness, I know, but:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) I may not have access to the source of the base class (e.g. Cocoa Collections)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) I always feel a bit dirty giving the base class knowledge of it’s subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) It is a royal pain, and a potential source of errors as things get refactored when adding new subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think I have at least the seed of an idea of how to solve this, and I am hoping that one of you (who are all much smarter than I) might have the key to getting it the rest of the way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I ran into this problem again last week, and it made me think of an old language I used to use...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was a small programming language I used to use in the 90’s which had an interesting core language feature we called “handlers”. These were a lot like registering for notifications, except that writing a function (with a special “Handler” attribute: “Handler func myFuncName()&quot;) was all you needed to do to register. Writing “Handle myFuncName()” would then systematically call every function with that name and the Handler attribute.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is, instead of calling a single function, it would systematically call a series of functions (all with the same name).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was one other thing that made these handlers special. Each one had the option, when it was called, to reply that it was the one true handler, and the others didn’t need to be called. Basically, it said “I&#39;ve got this!”. This even allowed it to return a result to the caller.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The original intent of this feature (and why it was a core language feature) was to handle events. It would handle things like hit testing and key events fairly elegantly. It was a powerful feature, so it was quickly used for other things. It made things like plug-ins ridiculously simple. We even used it for a form of error handling.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I remember helping to write a page layout program in it, and we used handlers not just for the hit testing, but for the tool palette as well. The end result was that you were able to add new shapes and new tools without modifying existing code at all. It is a feature I miss all the time...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is more power than we need here, but it provided me the inspiration for a potential solution to the factory problem. Back to swift…<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The idea here is to give each interested subclass a chance to say “I&#39;ve got this!”. The factory init runs through each of the subclasses’ overrides until it finds one that doesn’t return nil. New subclasses can be added and they will be given a chance as well (without modifying the base class). The first subclass to successfully init wins. (only subclasses which override the factory init would be considered)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //I like having an explicit call, so that the traditional (non-distributed) factory is possible as well<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         return factory.init(type) //We could also call this “subclass.init(type)” to mirror super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory override init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         guard type == compatibleWithThisType else {return nil} //If info doesn’t work for us, we return nil, and the next class gets a shot<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	//Init concrete type here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The main issue which still needs to be solved is that the order they get called sometimes really matters (this was solved by a well defined ordering + IDE features in the language mentioned above). For the most part, as long as subclasses are called before their superclasses (or there is a some method for cascading), it works. There are still times where you want to define a specific ordering though (e.g. a new subclass wants to get called before an existing subclasses to override some of it’s use cases).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I see a few options (and I would love to hear more):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - subclasses define a numeric precedence (similar to operators now). This is probably the most effective stop-gap solution, but is not elegant.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - subclasses do whatever we change operator precedence to do in the future<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - optionally allow subclasses to name another specific subclass that they are before/after<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - allow subclasses to declare that they would like to be earlier or later (or that they don’t care) in the calling list. subclasses defined outside of the module where the base class was defined would be placed more extremely early/late. Exact order is undefined, but rough ordering is possible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - return (to the superclass) an array of all subclasses which successfully inited. It can then select which one it wants and return it. This seems overly inefficient to me, since you are initializing a bunch of unused objects.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - &lt;Your idea here&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The end result is that you can extend factories of both classes and protocols without access to the original source code.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I also don’t think that the base should always need to be abstract. Factory inits should allow returning subclasses as a way of replacing themselves with a subclass, and returning nil if they are failable, but if there is no return (or return self), it can create an instance of itself. This way, it provides a customization point where subclasses can handle special cases, but the class itself provides an obvious default (i.e. a much less messy form of class cluster).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory init(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	if let subclass = factory.init(type){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	    return subclass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	return self.init()//If subclasses didn’t work, initialize ourselves<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?  Too crazy to consider?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; # Factory Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Protocol Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Riley Testut<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/f2c71d8f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>April  9, 2016 at 12:00:00pm</p></header><div class="content"><p>Hello again everyone!<br></p><p>Just an update, I did submit the PR about a week ago, and you can check it out here:<br>https://github.com/apple/swift-evolution/pull/247<br></p><p>As far as I know, now we wait until a core team member reviews the PR, and either suggests changes, or accepts it and initiates a review. Of course, if this is incorrect, please let me know so I can do whatever next steps there are :-)<br></p><p>Thanks again for all the contributions to this proposal, hope we see it get approved soon!<br>Riley<br></p><p>&gt; On Apr 4, 2016, at 11:58 AM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hey all!<br>&gt; <br>&gt; Just updated the proposal with all the recent changes, and you can check it here: https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md &lt;https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md&gt;<br>&gt; <br>&gt; Planning on submitting the PR later tonight, so please let me know if you have any last minute feedback!<br>&gt; Riley<br>&gt; <br>&gt;&gt; On Mar 30, 2016, at 1:35 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Probably ‘no&#39; in this proposal to keep things simple.<br>&gt;&gt; <br>&gt;&gt; Long term, I would like overriding of the factory init to be the mechanism for a post-hoc extendable factory.  Disallowing it now probably makes that easier in the future.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 30, 2016, at 1:20 PM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another point to consider: should factory initializers be able to be overridden by subclasses? I vote no, just as you can&#39;t override convenience initializers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 30, 2016, at 3:50 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yeah.  I was thinking we would want to mirror the convenience initializer syntax, but I am completely ok with this as well.  Honestly this is the syntax I first tried to use in convenience inits while learning swift, and I would love to see that migrate to something like this.  My only worry would be that people would be confused on when to use ClassName() and when to use self.init().  Best to choose one and stick with it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:36 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we are to enforce a different type signature for factory initializers vs required/convenience initializers (which would greatly simplify this issue), if I’m understanding correctly, there shouldn’t be a need to be able to “return” self.init(), right? Because you could do this instead:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; public class ConcreteBase {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	private init(type2: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt; 		//Default implementation here<br>&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt; 		if … {<br>&gt;&gt;&gt;&gt;&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt;&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt;&gt; 		return ConcreteBase(type) //Handle the general case with the main class<br>&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class SpecialSubclass : ConcreteBase {}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:30 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Doh!  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sorry, typed that up in mail while working on something else at the same time.  We shouldn’t allow an init with the same signature.  self.init() could be called with different parameters.  Trying to call the factory method from the factory method should generate an error.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We probably also want to disallow having an init with the same signature in subclasses as well (we could pass the same info with different parameter names) as a subclass which doesn’t override it would again be calling the factory method.  Ultimately, I would like to see the ability to override the factory method with the behavior I described earlier… but that is for a later proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Basically we should be able to return anything which adheres to the type, so we are free to use other initializers on the class/subclasses.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:10 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, good catch. Would that be confusing as to whether self.init() would lead to an infinite loop, or call the required initializer? Unlike convenience initializers, factory initializers might have the same signature as the required ones.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 2:52 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Agreed.  I would like to see what I was referring to as “stage 1” in this proposal, and we can (hopefully) add on a full solution over time.  (I just wanted to make sure we considered those cases so we didn’t block future improvements)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Looking at the proposal, my only contention would be that we should also allow self.init() to be called from the factory init (similar to a convenience init).  It could still be used with an AbstractBase as shown in your example (especially when dealing with protocols), but it shouldn’t force us to be abstract in the class case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In other words, we should also be able to do the following:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; public class ConcreteBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	private init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		//Default implementation here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		if … {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		return self.init(type) //Handle the general case with the main class<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class SpecialSubclass : ConcreteBase {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The behavior should simply be that we can return any init’d object that conforms to the given type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 2:20 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ultimately, while these are good points, I feel the full mechanism for class clusters belong in a separate proposal. The focus for this one I believe should be the underlying mechanism of factory initializers; should that be approved, then we can focus on adding additional features on top of it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That being said, I’ve written up essentially a final version of the proposal, which you can find here: https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md &lt;https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md&gt;. Assuming everyone is happy with it, I’ll send a pull request in the next few days to the main-repo. But please, give any last minute feedback now!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 5:12 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comments inline.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 12:10 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While I do believe your proposed additions have their benefits, my gut tells me this is too large a change to Swift for an arguably small gain. For this proposal, I&#39;m wanting to keep the change as minimalistic as possible, while still providing enough flexibility and use cases to warrant it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can definitely see the argument that extensibility is out of scope for Swift 3, but I do want to make sure that it is possible for us to have extensibility in the future (that we don’t block ourselves from doing it).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I strongly disagree that the gain is small.  One of the core benefits of both Swift/ObjC (and now POP) is the ability to extend things post-hoc, without access to the original code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I often write libraries &amp; SDKs, so the users of my code don&#39;t have access to the original code.  I guess extensibility is less necessary when you control the entire codebase, but you still have to refactor your factory whenever you subclass (or adhere to a protocol), which I find problematic.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is something I run into a lot while writing actual code, so it isn’t just a theoretical concern.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Interesting you bring up the registering of subclasses, as that is similar to the very original proposal, and actually similar to what I&#39;m doing in my own app. Effectively, I have an Objective-C base class, and in +load it dynamically finds all subclasses using the Objective-C runtime, and stores a reference to them. Then in the initializer, it returns the appropriate subclass based on the initialization parameters. This was my solution to the superclass not having to explicitly know each individual subclass.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Using factory initializers, however, this pattern could be used in pure Swift, albeit with some minor modifications. At program start, the program could register subclasses with the superclass, and then in the initializer would simply return the appropriate subclass (similar to NSURLProtocol, I believe).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, I have also used load in this way in ObjC.  In Swift, I think the compiler could easily build an array/table of the overloads of factory inits.  This avoids having to register explicitly (the declaration itself implies intent to register), and doesn’t take up any cycles during execution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I ran into the problem of when to register the other day in a current project, as Swift doesn’t have an equivalent to +load that I am aware of.  I had to settle for something of a hack which gets called on first use… but it was only a partial solution which worked in that particular case.  How do the swift classes/enums/structs get called to register themselves?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We may want to propose adding a +load equivalent for Swift types, since it does come up occasionally. It is one of those things which you don’t need often, but when you do, you really need it.  Ironically, this was one of the uses of the original feature I talked about earlier (we used it to provide the equivalent of +load, awakeFromNib, etc… in the language). <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As for rationale for protocol (factory) initializers, a common pattern I&#39;ve come across when developing my internal frameworks is to design a protocol, and then to provide a default implementation of the protocol with a type (typically a struct). I feel this relationship could be bridged easier by simply returning this type from a protocol initializer, which could even potentially allow me to declare the actual type as private, so for all intents and purposes the client does simply get an initialized protocol object (similar in part to creating an anonymous class conforming to a protocol in Java).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I strongly agree that we should have factory initializers for protocols for the reasons you state here, plus many others.  It just seems like a natural fit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would like to see a 3 stage approach:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 1:  Declaring an init as “factory” allows you to return any fully inited object which fits the type (including calling self.init like a convenience init would and then returning it). If the init is failable, you can also return nil.  This works both on classes and protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 2:  The compiler builds a table of the overrides of a given factory init, and there is some syntax to call them (e.g. “let sub = subclasses.init(value)”) such that the first one to return non-nil is the return value to that call.  Thorsten’s depth first + alphabetical ordering would be adequate to make the behavior predictable.  Again, this should work for both classes and protocols. (I am open to better ideas for syntax/naming)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 3: We allow greater control over the ordering in the table. This still needs thought both on syntax and method.  Something similar to operator precedence (or autolayout priority) would work in a pinch, but isn’t super elegant. In practice, it might be enough just to be able to declare that something needs to be before/after a specific subclass in the list.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note: A slightly different approach to stage 2 (for classes) might have only the direct subclasses in the table, and then the subclasses have the option to call off to their own subclasses in the same manner if desired.  This has the tradeoff that each level needs to plan for extensibility (i.e. you can’t override something which wasn’t expecting to be subclassed), but I do like how it simplifies the model a bit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have a feeling that the proper syntax for stages 2/3 may become more obvious once the design work around mixins/protocols+storage gets done.  It may just fall out of the disambiguation syntax...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 22, 2016, at 5:21 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes and No.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, because this is a problem I run into all the time, and I really want swift to have a solution for it. I especially like Brent’s idea of a protocol init.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, because I have gotten a bit greedy. I want us to take a step back and look at the underlying problem to see if we can come up with something which completely solves it… and I think factories get us only part way there. Let’s take a moment and see if we can create something uniquely swift before we copy/paste existing solutions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Think about Cocoa’s class clusters for a moment. I love them, but they are a pain to subclass. To the level where any beginning Cocoa instruction tells you explicitly not to subclass them. Similarly, even in my own factories, they are always a pain to extend.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I want our factory inits to be extensible by default.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; By extensible, I mean that I want to be able to add a new subclass (or a new entity satisfying a protocol), and have it come out of the factory when appropriate without editing the base class! Madness, I know, but:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) I may not have access to the source of the base class (e.g. Cocoa Collections)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) I always feel a bit dirty giving the base class knowledge of it’s subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) It is a royal pain, and a potential source of errors as things get refactored when adding new subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think I have at least the seed of an idea of how to solve this, and I am hoping that one of you (who are all much smarter than I) might have the key to getting it the rest of the way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I ran into this problem again last week, and it made me think of an old language I used to use...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was a small programming language I used to use in the 90’s which had an interesting core language feature we called “handlers”. These were a lot like registering for notifications, except that writing a function (with a special “Handler” attribute: “Handler func myFuncName()&quot;) was all you needed to do to register. Writing “Handle myFuncName()” would then systematically call every function with that name and the Handler attribute.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is, instead of calling a single function, it would systematically call a series of functions (all with the same name).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was one other thing that made these handlers special. Each one had the option, when it was called, to reply that it was the one true handler, and the others didn’t need to be called. Basically, it said “I&#39;ve got this!”. This even allowed it to return a result to the caller.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The original intent of this feature (and why it was a core language feature) was to handle events. It would handle things like hit testing and key events fairly elegantly. It was a powerful feature, so it was quickly used for other things. It made things like plug-ins ridiculously simple. We even used it for a form of error handling.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I remember helping to write a page layout program in it, and we used handlers not just for the hit testing, but for the tool palette as well. The end result was that you were able to add new shapes and new tools without modifying existing code at all. It is a feature I miss all the time...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is more power than we need here, but it provided me the inspiration for a potential solution to the factory problem. Back to swift…<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The idea here is to give each interested subclass a chance to say “I&#39;ve got this!”. The factory init runs through each of the subclasses’ overrides until it finds one that doesn’t return nil. New subclasses can be added and they will be given a chance as well (without modifying the base class). The first subclass to successfully init wins. (only subclasses which override the factory init would be considered)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //I like having an explicit call, so that the traditional (non-distributed) factory is possible as well<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         return factory.init(type) //We could also call this “subclass.init(type)” to mirror super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory override init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         guard type == compatibleWithThisType else {return nil} //If info doesn’t work for us, we return nil, and the next class gets a shot<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	//Init concrete type here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The main issue which still needs to be solved is that the order they get called sometimes really matters (this was solved by a well defined ordering + IDE features in the language mentioned above). For the most part, as long as subclasses are called before their superclasses (or there is a some method for cascading), it works. There are still times where you want to define a specific ordering though (e.g. a new subclass wants to get called before an existing subclasses to override some of it’s use cases).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I see a few options (and I would love to hear more):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - subclasses define a numeric precedence (similar to operators now). This is probably the most effective stop-gap solution, but is not elegant.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - subclasses do whatever we change operator precedence to do in the future<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - optionally allow subclasses to name another specific subclass that they are before/after<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - allow subclasses to declare that they would like to be earlier or later (or that they don’t care) in the calling list. subclasses defined outside of the module where the base class was defined would be placed more extremely early/late. Exact order is undefined, but rough ordering is possible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - return (to the superclass) an array of all subclasses which successfully inited. It can then select which one it wants and return it. This seems overly inefficient to me, since you are initializing a bunch of unused objects.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - &lt;Your idea here&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The end result is that you can extend factories of both classes and protocols without access to the original source code.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I also don’t think that the base should always need to be abstract. Factory inits should allow returning subclasses as a way of replacing themselves with a subclass, and returning nil if they are failable, but if there is no return (or return self), it can create an instance of itself. This way, it provides a customization point where subclasses can handle special cases, but the class itself provides an obvious default (i.e. a much less messy form of class cluster).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory init(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	if let subclass = factory.init(type){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	    return subclass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	return self.init()//If subclasses didn’t work, initialize ourselves<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?  Too crazy to consider?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; # Factory Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Protocol Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Riley Testut<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160409/9ed7a9ea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>April 10, 2016 at 08:00:00pm</p></header><div class="content"><p>Nice!<br></p><p>I must admit, my first reaction to this proposal was “uhhh, why complicate initializers even more?”. But then I hit these two roadblocks:<br></p><p>1. I wanted to add an initializer on `NSTimer` extension that returns the (toll-free-bridged) value from CFRunLoopTimerCreateWithHandler. Sadly, this is impossible, and so I have to write NSTimer.new(…) &lt;https://github.com/radex/SwiftyTimer/blob/3b4f233989dd60dc2dd728659e5bcf750a8c9f2f/Sources/SwiftyTimer.swift#L65&gt; :(<br>2. I wanted to add a custom initializer to a class inheriting from UIButton. But I can’t, because the initializer for UIButton is `convenience init(type buttonType: UIButtonType)` :(<br></p><p>A `factory init` allowing me to use both the initializer syntax and return an object from some other initializer would solve both problems. The &quot;Initializing Storyboard-backed View Controller” use case is also compelling to me.<br></p><p>+1.<br></p><p>— Radek<br></p><p>&gt; On 09 Apr 2016, at 21:17, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello again everyone!<br>&gt; <br>&gt; Just an update, I did submit the PR about a week ago, and you can check it out here:<br>&gt; https://github.com/apple/swift-evolution/pull/247 &lt;https://github.com/apple/swift-evolution/pull/247&gt;<br>&gt; <br>&gt; As far as I know, now we wait until a core team member reviews the PR, and either suggests changes, or accepts it and initiates a review. Of course, if this is incorrect, please let me know so I can do whatever next steps there are :-)<br>&gt; <br>&gt; Thanks again for all the contributions to this proposal, hope we see it get approved soon!<br>&gt; Riley<br>&gt; <br>&gt;&gt; On Apr 4, 2016, at 11:58 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey all!<br>&gt;&gt; <br>&gt;&gt; Just updated the proposal with all the recent changes, and you can check it here: https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md &lt;https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md&gt;<br>&gt;&gt; <br>&gt;&gt; Planning on submitting the PR later tonight, so please let me know if you have any last minute feedback!<br>&gt;&gt; Riley<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 30, 2016, at 1:35 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Probably ‘no&#39; in this proposal to keep things simple.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Long term, I would like overriding of the factory init to be the mechanism for a post-hoc extendable factory.  Disallowing it now probably makes that easier in the future.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 30, 2016, at 1:20 PM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another point to consider: should factory initializers be able to be overridden by subclasses? I vote no, just as you can&#39;t override convenience initializers.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:50 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yeah.  I was thinking we would want to mirror the convenience initializer syntax, but I am completely ok with this as well.  Honestly this is the syntax I first tried to use in convenience inits while learning swift, and I would love to see that migrate to something like this.  My only worry would be that people would be confused on when to use ClassName() and when to use self.init().  Best to choose one and stick with it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:36 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If we are to enforce a different type signature for factory initializers vs required/convenience initializers (which would greatly simplify this issue), if I’m understanding correctly, there shouldn’t be a need to be able to “return” self.init(), right? Because you could do this instead:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; public class ConcreteBase {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	private init(type2: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt; 		//Default implementation here<br>&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt; 		if … {<br>&gt;&gt;&gt;&gt;&gt;&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt;&gt;&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt;&gt;&gt; 		return ConcreteBase(type) //Handle the general case with the main class<br>&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class SpecialSubclass : ConcreteBase {}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:30 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Doh!  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sorry, typed that up in mail while working on something else at the same time.  We shouldn’t allow an init with the same signature.  self.init() could be called with different parameters.  Trying to call the factory method from the factory method should generate an error.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We probably also want to disallow having an init with the same signature in subclasses as well (we could pass the same info with different parameter names) as a subclass which doesn’t override it would again be calling the factory method.  Ultimately, I would like to see the ability to override the factory method with the behavior I described earlier… but that is for a later proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Basically we should be able to return anything which adheres to the type, so we are free to use other initializers on the class/subclasses.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:10 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, good catch. Would that be confusing as to whether self.init() would lead to an infinite loop, or call the required initializer? Unlike convenience initializers, factory initializers might have the same signature as the required ones.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 2:52 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Agreed.  I would like to see what I was referring to as “stage 1” in this proposal, and we can (hopefully) add on a full solution over time.  (I just wanted to make sure we considered those cases so we didn’t block future improvements)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Looking at the proposal, my only contention would be that we should also allow self.init() to be called from the factory init (similar to a convenience init).  It could still be used with an AbstractBase as shown in your example (especially when dealing with protocols), but it shouldn’t force us to be abstract in the class case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In other words, we should also be able to do the following:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; public class ConcreteBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	private init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		//Default implementation here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		if … {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		return self.init(type) //Handle the general case with the main class<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class SpecialSubclass : ConcreteBase {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The behavior should simply be that we can return any init’d object that conforms to the given type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 2:20 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ultimately, while these are good points, I feel the full mechanism for class clusters belong in a separate proposal. The focus for this one I believe should be the underlying mechanism of factory initializers; should that be approved, then we can focus on adding additional features on top of it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That being said, I’ve written up essentially a final version of the proposal, which you can find here: https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md &lt;https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md&gt;. Assuming everyone is happy with it, I’ll send a pull request in the next few days to the main-repo. But please, give any last minute feedback now!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 5:12 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comments inline.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 12:10 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While I do believe your proposed additions have their benefits, my gut tells me this is too large a change to Swift for an arguably small gain. For this proposal, I&#39;m wanting to keep the change as minimalistic as possible, while still providing enough flexibility and use cases to warrant it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can definitely see the argument that extensibility is out of scope for Swift 3, but I do want to make sure that it is possible for us to have extensibility in the future (that we don’t block ourselves from doing it).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I strongly disagree that the gain is small.  One of the core benefits of both Swift/ObjC (and now POP) is the ability to extend things post-hoc, without access to the original code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I often write libraries &amp; SDKs, so the users of my code don&#39;t have access to the original code.  I guess extensibility is less necessary when you control the entire codebase, but you still have to refactor your factory whenever you subclass (or adhere to a protocol), which I find problematic.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is something I run into a lot while writing actual code, so it isn’t just a theoretical concern.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Interesting you bring up the registering of subclasses, as that is similar to the very original proposal, and actually similar to what I&#39;m doing in my own app. Effectively, I have an Objective-C base class, and in +load it dynamically finds all subclasses using the Objective-C runtime, and stores a reference to them. Then in the initializer, it returns the appropriate subclass based on the initialization parameters. This was my solution to the superclass not having to explicitly know each individual subclass.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Using factory initializers, however, this pattern could be used in pure Swift, albeit with some minor modifications. At program start, the program could register subclasses with the superclass, and then in the initializer would simply return the appropriate subclass (similar to NSURLProtocol, I believe).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, I have also used load in this way in ObjC.  In Swift, I think the compiler could easily build an array/table of the overloads of factory inits.  This avoids having to register explicitly (the declaration itself implies intent to register), and doesn’t take up any cycles during execution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I ran into the problem of when to register the other day in a current project, as Swift doesn’t have an equivalent to +load that I am aware of.  I had to settle for something of a hack which gets called on first use… but it was only a partial solution which worked in that particular case.  How do the swift classes/enums/structs get called to register themselves?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We may want to propose adding a +load equivalent for Swift types, since it does come up occasionally. It is one of those things which you don’t need often, but when you do, you really need it.  Ironically, this was one of the uses of the original feature I talked about earlier (we used it to provide the equivalent of +load, awakeFromNib, etc… in the language). <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As for rationale for protocol (factory) initializers, a common pattern I&#39;ve come across when developing my internal frameworks is to design a protocol, and then to provide a default implementation of the protocol with a type (typically a struct). I feel this relationship could be bridged easier by simply returning this type from a protocol initializer, which could even potentially allow me to declare the actual type as private, so for all intents and purposes the client does simply get an initialized protocol object (similar in part to creating an anonymous class conforming to a protocol in Java).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I strongly agree that we should have factory initializers for protocols for the reasons you state here, plus many others.  It just seems like a natural fit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would like to see a 3 stage approach:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 1:  Declaring an init as “factory” allows you to return any fully inited object which fits the type (including calling self.init like a convenience init would and then returning it). If the init is failable, you can also return nil.  This works both on classes and protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 2:  The compiler builds a table of the overrides of a given factory init, and there is some syntax to call them (e.g. “let sub = subclasses.init(value)”) such that the first one to return non-nil is the return value to that call.  Thorsten’s depth first + alphabetical ordering would be adequate to make the behavior predictable.  Again, this should work for both classes and protocols. (I am open to better ideas for syntax/naming)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 3: We allow greater control over the ordering in the table. This still needs thought both on syntax and method.  Something similar to operator precedence (or autolayout priority) would work in a pinch, but isn’t super elegant. In practice, it might be enough just to be able to declare that something needs to be before/after a specific subclass in the list.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note: A slightly different approach to stage 2 (for classes) might have only the direct subclasses in the table, and then the subclasses have the option to call off to their own subclasses in the same manner if desired.  This has the tradeoff that each level needs to plan for extensibility (i.e. you can’t override something which wasn’t expecting to be subclassed), but I do like how it simplifies the model a bit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have a feeling that the proper syntax for stages 2/3 may become more obvious once the design work around mixins/protocols+storage gets done.  It may just fall out of the disambiguation syntax...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 22, 2016, at 5:21 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes and No.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, because this is a problem I run into all the time, and I really want swift to have a solution for it. I especially like Brent’s idea of a protocol init.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, because I have gotten a bit greedy. I want us to take a step back and look at the underlying problem to see if we can come up with something which completely solves it… and I think factories get us only part way there. Let’s take a moment and see if we can create something uniquely swift before we copy/paste existing solutions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Think about Cocoa’s class clusters for a moment. I love them, but they are a pain to subclass. To the level where any beginning Cocoa instruction tells you explicitly not to subclass them. Similarly, even in my own factories, they are always a pain to extend.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I want our factory inits to be extensible by default.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; By extensible, I mean that I want to be able to add a new subclass (or a new entity satisfying a protocol), and have it come out of the factory when appropriate without editing the base class! Madness, I know, but:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) I may not have access to the source of the base class (e.g. Cocoa Collections)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) I always feel a bit dirty giving the base class knowledge of it’s subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) It is a royal pain, and a potential source of errors as things get refactored when adding new subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think I have at least the seed of an idea of how to solve this, and I am hoping that one of you (who are all much smarter than I) might have the key to getting it the rest of the way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I ran into this problem again last week, and it made me think of an old language I used to use...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was a small programming language I used to use in the 90’s which had an interesting core language feature we called “handlers”. These were a lot like registering for notifications, except that writing a function (with a special “Handler” attribute: “Handler func myFuncName()&quot;) was all you needed to do to register. Writing “Handle myFuncName()” would then systematically call every function with that name and the Handler attribute.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is, instead of calling a single function, it would systematically call a series of functions (all with the same name).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was one other thing that made these handlers special. Each one had the option, when it was called, to reply that it was the one true handler, and the others didn’t need to be called. Basically, it said “I&#39;ve got this!”. This even allowed it to return a result to the caller.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The original intent of this feature (and why it was a core language feature) was to handle events. It would handle things like hit testing and key events fairly elegantly. It was a powerful feature, so it was quickly used for other things. It made things like plug-ins ridiculously simple. We even used it for a form of error handling.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I remember helping to write a page layout program in it, and we used handlers not just for the hit testing, but for the tool palette as well. The end result was that you were able to add new shapes and new tools without modifying existing code at all. It is a feature I miss all the time...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is more power than we need here, but it provided me the inspiration for a potential solution to the factory problem. Back to swift…<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The idea here is to give each interested subclass a chance to say “I&#39;ve got this!”. The factory init runs through each of the subclasses’ overrides until it finds one that doesn’t return nil. New subclasses can be added and they will be given a chance as well (without modifying the base class). The first subclass to successfully init wins. (only subclasses which override the factory init would be considered)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //I like having an explicit call, so that the traditional (non-distributed) factory is possible as well<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         return factory.init(type) //We could also call this “subclass.init(type)” to mirror super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory override init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         guard type == compatibleWithThisType else {return nil} //If info doesn’t work for us, we return nil, and the next class gets a shot<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	//Init concrete type here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The main issue which still needs to be solved is that the order they get called sometimes really matters (this was solved by a well defined ordering + IDE features in the language mentioned above). For the most part, as long as subclasses are called before their superclasses (or there is a some method for cascading), it works. There are still times where you want to define a specific ordering though (e.g. a new subclass wants to get called before an existing subclasses to override some of it’s use cases).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I see a few options (and I would love to hear more):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - subclasses define a numeric precedence (similar to operators now). This is probably the most effective stop-gap solution, but is not elegant.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - subclasses do whatever we change operator precedence to do in the future<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - optionally allow subclasses to name another specific subclass that they are before/after<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - allow subclasses to declare that they would like to be earlier or later (or that they don’t care) in the calling list. subclasses defined outside of the module where the base class was defined would be placed more extremely early/late. Exact order is undefined, but rough ordering is possible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - return (to the superclass) an array of all subclasses which successfully inited. It can then select which one it wants and return it. This seems overly inefficient to me, since you are initializing a bunch of unused objects.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - &lt;Your idea here&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The end result is that you can extend factories of both classes and protocols without access to the original source code.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I also don’t think that the base should always need to be abstract. Factory inits should allow returning subclasses as a way of replacing themselves with a subclass, and returning nil if they are failable, but if there is no return (or return self), it can create an instance of itself. This way, it provides a customization point where subclasses can handle special cases, but the class itself provides an obvious default (i.e. a much less messy form of class cluster).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory init(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	if let subclass = factory.init(type){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	    return subclass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	return self.init()//If subclasses didn’t work, initialize ourselves<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?  Too crazy to consider?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; # Factory Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Protocol Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Riley Testut<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/36c2b968/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>April 11, 2016 at 07:00:00am</p></header><div class="content"><p>I thought this already went in review somehow, sorry a +1 from me as well.<br></p><p>[[iOS messageWithData:ideas] broadcast]<br></p><p>&gt; On 10 Apr 2016, at 19:14, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Nice!<br>&gt; <br>&gt; I must admit, my first reaction to this proposal was “uhhh, why complicate initializers even more?”. But then I hit these two roadblocks:<br>&gt; <br>&gt; 1. I wanted to add an initializer on `NSTimer` extension that returns the (toll-free-bridged) value from CFRunLoopTimerCreateWithHandler. Sadly, this is impossible, and so I have to write NSTimer.new(…) :(<br>&gt; 2. I wanted to add a custom initializer to a class inheriting from UIButton. But I can’t, because the initializer for UIButton is `convenience init(type buttonType: UIButtonType)` :(<br>&gt; <br>&gt; A `factory init` allowing me to use both the initializer syntax and return an object from some other initializer would solve both problems. The &quot;Initializing Storyboard-backed View Controller” use case is also compelling to me.<br>&gt; <br>&gt; +1.<br>&gt; <br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 09 Apr 2016, at 21:17, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello again everyone!<br>&gt;&gt; <br>&gt;&gt; Just an update, I did submit the PR about a week ago, and you can check it out here:<br>&gt;&gt; https://github.com/apple/swift-evolution/pull/247<br>&gt;&gt; <br>&gt;&gt; As far as I know, now we wait until a core team member reviews the PR, and either suggests changes, or accepts it and initiates a review. Of course, if this is incorrect, please let me know so I can do whatever next steps there are :-)<br>&gt;&gt; <br>&gt;&gt; Thanks again for all the contributions to this proposal, hope we see it get approved soon!<br>&gt;&gt; Riley<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 4, 2016, at 11:58 AM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hey all!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just updated the proposal with all the recent changes, and you can check it here: https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Planning on submitting the PR later tonight, so please let me know if you have any last minute feedback!<br>&gt;&gt;&gt; Riley<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 30, 2016, at 1:35 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Probably ‘no&#39; in this proposal to keep things simple.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Long term, I would like overriding of the factory init to be the mechanism for a post-hoc extendable factory.  Disallowing it now probably makes that easier in the future.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 1:20 PM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another point to consider: should factory initializers be able to be overridden by subclasses? I vote no, just as you can&#39;t override convenience initializers.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:50 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yeah.  I was thinking we would want to mirror the convenience initializer syntax, but I am completely ok with this as well.  Honestly this is the syntax I first tried to use in convenience inits while learning swift, and I would love to see that migrate to something like this.  My only worry would be that people would be confused on when to use ClassName() and when to use self.init().  Best to choose one and stick with it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:36 AM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we are to enforce a different type signature for factory initializers vs required/convenience initializers (which would greatly simplify this issue), if I’m understanding correctly, there shouldn’t be a need to be able to “return” self.init(), right? Because you could do this instead:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; public class ConcreteBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	private init(type2: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		//Default implementation here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		if … {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		return ConcreteBase(type) //Handle the general case with the main class<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class SpecialSubclass : ConcreteBase {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:30 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Doh!  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sorry, typed that up in mail while working on something else at the same time.  We shouldn’t allow an init with the same signature.  self.init() could be called with different parameters.  Trying to call the factory method from the factory method should generate an error.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We probably also want to disallow having an init with the same signature in subclasses as well (we could pass the same info with different parameter names) as a subclass which doesn’t override it would again be calling the factory method.  Ultimately, I would like to see the ability to override the factory method with the behavior I described earlier… but that is for a later proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Basically we should be able to return anything which adheres to the type, so we are free to use other initializers on the class/subclasses.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:10 AM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, good catch. Would that be confusing as to whether self.init() would lead to an infinite loop, or call the required initializer? Unlike convenience initializers, factory initializers might have the same signature as the required ones.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 2:52 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Agreed.  I would like to see what I was referring to as “stage 1” in this proposal, and we can (hopefully) add on a full solution over time.  (I just wanted to make sure we considered those cases so we didn’t block future improvements)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Looking at the proposal, my only contention would be that we should also allow self.init() to be called from the factory init (similar to a convenience init).  It could still be used with an AbstractBase as shown in your example (especially when dealing with protocols), but it shouldn’t force us to be abstract in the class case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In other words, we should also be able to do the following:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; public class ConcreteBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	private init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		//Default implementation here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		if … {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		return self.init(type) //Handle the general case with the main class<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class SpecialSubclass : ConcreteBase {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The behavior should simply be that we can return any init’d object that conforms to the given type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 2:20 AM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ultimately, while these are good points, I feel the full mechanism for class clusters belong in a separate proposal. The focus for this one I believe should be the underlying mechanism of factory initializers; should that be approved, then we can focus on adding additional features on top of it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That being said, I’ve written up essentially a final version of the proposal, which you can find here: https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md. Assuming everyone is happy with it, I’ll send a pull request in the next few days to the main-repo. But please, give any last minute feedback now!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 5:12 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comments inline.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 12:10 AM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While I do believe your proposed additions have their benefits, my gut tells me this is too large a change to Swift for an arguably small gain. For this proposal, I&#39;m wanting to keep the change as minimalistic as possible, while still providing enough flexibility and use cases to warrant it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can definitely see the argument that extensibility is out of scope for Swift 3, but I do want to make sure that it is possible for us to have extensibility in the future (that we don’t block ourselves from doing it).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I strongly disagree that the gain is small.  One of the core benefits of both Swift/ObjC (and now POP) is the ability to extend things post-hoc, without access to the original code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I often write libraries &amp; SDKs, so the users of my code don&#39;t have access to the original code.  I guess extensibility is less necessary when you control the entire codebase, but you still have to refactor your factory whenever you subclass (or adhere to a protocol), which I find problematic.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is something I run into a lot while writing actual code, so it isn’t just a theoretical concern.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Interesting you bring up the registering of subclasses, as that is similar to the very original proposal, and actually similar to what I&#39;m doing in my own app. Effectively, I have an Objective-C base class, and in +load it dynamically finds all subclasses using the Objective-C runtime, and stores a reference to them. Then in the initializer, it returns the appropriate subclass based on the initialization parameters. This was my solution to the superclass not having to explicitly know each individual subclass.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Using factory initializers, however, this pattern could be used in pure Swift, albeit with some minor modifications. At program start, the program could register subclasses with the superclass, and then in the initializer would simply return the appropriate subclass (similar to NSURLProtocol, I believe).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, I have also used load in this way in ObjC.  In Swift, I think the compiler could easily build an array/table of the overloads of factory inits.  This avoids having to register explicitly (the declaration itself implies intent to register), and doesn’t take up any cycles during execution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I ran into the problem of when to register the other day in a current project, as Swift doesn’t have an equivalent to +load that I am aware of.  I had to settle for something of a hack which gets called on first use… but it was only a partial solution which worked in that particular case.  How do the swift classes/enums/structs get called to register themselves?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We may want to propose adding a +load equivalent for Swift types, since it does come up occasionally. It is one of those things which you don’t need often, but when you do, you really need it.  Ironically, this was one of the uses of the original feature I talked about earlier (we used it to provide the equivalent of +load, awakeFromNib, etc… in the language). <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As for rationale for protocol (factory) initializers, a common pattern I&#39;ve come across when developing my internal frameworks is to design a protocol, and then to provide a default implementation of the protocol with a type (typically a struct). I feel this relationship could be bridged easier by simply returning this type from a protocol initializer, which could even potentially allow me to declare the actual type as private, so for all intents and purposes the client does simply get an initialized protocol object (similar in part to creating an anonymous class conforming to a protocol in Java).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I strongly agree that we should have factory initializers for protocols for the reasons you state here, plus many others.  It just seems like a natural fit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would like to see a 3 stage approach:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 1:  Declaring an init as “factory” allows you to return any fully inited object which fits the type (including calling self.init like a convenience init would and then returning it). If the init is failable, you can also return nil.  This works both on classes and protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 2:  The compiler builds a table of the overrides of a given factory init, and there is some syntax to call them (e.g. “let sub = subclasses.init(value)”) such that the first one to return non-nil is the return value to that call.  Thorsten’s depth first + alphabetical ordering would be adequate to make the behavior predictable.  Again, this should work for both classes and protocols. (I am open to better ideas for syntax/naming)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 3: We allow greater control over the ordering in the table. This still needs thought both on syntax and method.  Something similar to operator precedence (or autolayout priority) would work in a pinch, but isn’t super elegant. In practice, it might be enough just to be able to declare that something needs to be before/after a specific subclass in the list.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note: A slightly different approach to stage 2 (for classes) might have only the direct subclasses in the table, and then the subclasses have the option to call off to their own subclasses in the same manner if desired.  This has the tradeoff that each level needs to plan for extensibility (i.e. you can’t override something which wasn’t expecting to be subclassed), but I do like how it simplifies the model a bit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have a feeling that the proper syntax for stages 2/3 may become more obvious once the design work around mixins/protocols+storage gets done.  It may just fall out of the disambiguation syntax...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 22, 2016, at 5:21 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes and No.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, because this is a problem I run into all the time, and I really want swift to have a solution for it. I especially like Brent’s idea of a protocol init.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, because I have gotten a bit greedy. I want us to take a step back and look at the underlying problem to see if we can come up with something which completely solves it… and I think factories get us only part way there. Let’s take a moment and see if we can create something uniquely swift before we copy/paste existing solutions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Think about Cocoa’s class clusters for a moment. I love them, but they are a pain to subclass. To the level where any beginning Cocoa instruction tells you explicitly not to subclass them. Similarly, even in my own factories, they are always a pain to extend.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I want our factory inits to be extensible by default.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; By extensible, I mean that I want to be able to add a new subclass (or a new entity satisfying a protocol), and have it come out of the factory when appropriate without editing the base class! Madness, I know, but:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) I may not have access to the source of the base class (e.g. Cocoa Collections)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) I always feel a bit dirty giving the base class knowledge of it’s subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) It is a royal pain, and a potential source of errors as things get refactored when adding new subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think I have at least the seed of an idea of how to solve this, and I am hoping that one of you (who are all much smarter than I) might have the key to getting it the rest of the way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I ran into this problem again last week, and it made me think of an old language I used to use...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was a small programming language I used to use in the 90’s which had an interesting core language feature we called “handlers”. These were a lot like registering for notifications, except that writing a function (with a special “Handler” attribute: “Handler func myFuncName()&quot;) was all you needed to do to register. Writing “Handle myFuncName()” would then systematically call every function with that name and the Handler attribute.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is, instead of calling a single function, it would systematically call a series of functions (all with the same name).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was one other thing that made these handlers special. Each one had the option, when it was called, to reply that it was the one true handler, and the others didn’t need to be called. Basically, it said “I&#39;ve got this!”. This even allowed it to return a result to the caller.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The original intent of this feature (and why it was a core language feature) was to handle events. It would handle things like hit testing and key events fairly elegantly. It was a powerful feature, so it was quickly used for other things. It made things like plug-ins ridiculously simple. We even used it for a form of error handling.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I remember helping to write a page layout program in it, and we used handlers not just for the hit testing, but for the tool palette as well. The end result was that you were able to add new shapes and new tools without modifying existing code at all. It is a feature I miss all the time...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is more power than we need here, but it provided me the inspiration for a potential solution to the factory problem. Back to swift…<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The idea here is to give each interested subclass a chance to say “I&#39;ve got this!”. The factory init runs through each of the subclasses’ overrides until it finds one that doesn’t return nil. New subclasses can be added and they will be given a chance as well (without modifying the base class). The first subclass to successfully init wins. (only subclasses which override the factory init would be considered)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //I like having an explicit call, so that the traditional (non-distributed) factory is possible as well<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         return factory.init(type) //We could also call this “subclass.init(type)” to mirror super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory override init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         guard type == compatibleWithThisType else {return nil} //If info doesn’t work for us, we return nil, and the next class gets a shot<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	//Init concrete type here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The main issue which still needs to be solved is that the order they get called sometimes really matters (this was solved by a well defined ordering + IDE features in the language mentioned above). For the most part, as long as subclasses are called before their superclasses (or there is a some method for cascading), it works. There are still times where you want to define a specific ordering though (e.g. a new subclass wants to get called before an existing subclasses to override some of it’s use cases).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I see a few options (and I would love to hear more):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - subclasses define a numeric precedence (similar to operators now). This is probably the most effective stop-gap solution, but is not elegant.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - subclasses do whatever we change operator precedence to do in the future<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - optionally allow subclasses to name another specific subclass that they are before/after<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - allow subclasses to declare that they would like to be earlier or later (or that they don’t care) in the calling list. subclasses defined outside of the module where the base class was defined would be placed more extremely early/late. Exact order is undefined, but rough ordering is possible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - return (to the superclass) an array of all subclasses which successfully inited. It can then select which one it wants and return it. This seems overly inefficient to me, since you are initializing a bunch of unused objects.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - &lt;Your idea here&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The end result is that you can extend factories of both classes and protocols without access to the original source code.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I also don’t think that the base should always need to be abstract. Factory inits should allow returning subclasses as a way of replacing themselves with a subclass, and returning nil if they are failable, but if there is no return (or return self), it can create an instance of itself. This way, it provides a customization point where subclasses can handle special cases, but the class itself provides an obvious default (i.e. a much less messy form of class cluster).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory init(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	if let subclass = factory.init(type){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	    return subclass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	return self.init()//If subclasses didn’t work, initialize ourselves<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?  Too crazy to consider?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; # Factory Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Protocol Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Riley Testut<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Charles<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/a0d27c3d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>April 11, 2016 at 09:00:00am</p></header><div class="content"><p>At first, I was opposed to this idea but after working with many heterogeneous implementations of the same protocol, where instance creation needs to be dynamically dispatched to based on the properties of the data, I think that factory initialisers might be a nice idea. However, it would IMO make sense to restrict them to protocol extensions only.<br></p><p>— Taras<br></p><p><br>&gt; On 11 Apr 2016, at 08:55, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I thought this already went in review somehow, sorry a +1 from me as well.<br>&gt; <br>&gt; [[iOS messageWithData:ideas] broadcast]<br>&gt; <br>&gt; On 10 Apr 2016, at 19:14, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Nice!<br>&gt;&gt; <br>&gt;&gt; I must admit, my first reaction to this proposal was “uhhh, why complicate initializers even more?”. But then I hit these two roadblocks:<br>&gt;&gt; <br>&gt;&gt; 1. I wanted to add an initializer on `NSTimer` extension that returns the (toll-free-bridged) value from CFRunLoopTimerCreateWithHandler. Sadly, this is impossible, and so I have to write NSTimer.new(…) &lt;https://github.com/radex/SwiftyTimer/blob/3b4f233989dd60dc2dd728659e5bcf750a8c9f2f/Sources/SwiftyTimer.swift#L65&gt; :(<br>&gt;&gt; 2. I wanted to add a custom initializer to a class inheriting from UIButton. But I can’t, because the initializer for UIButton is `convenience init(type buttonType: UIButtonType)` :(<br>&gt;&gt; <br>&gt;&gt; A `factory init` allowing me to use both the initializer syntax and return an object from some other initializer would solve both problems. The &quot;Initializing Storyboard-backed View Controller” use case is also compelling to me.<br>&gt;&gt; <br>&gt;&gt; +1.<br>&gt;&gt; <br>&gt;&gt; — Radek<br>&gt;&gt; <br>&gt;&gt;&gt; On 09 Apr 2016, at 21:17, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello again everyone!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just an update, I did submit the PR about a week ago, and you can check it out here:<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/pull/247 &lt;https://github.com/apple/swift-evolution/pull/247&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As far as I know, now we wait until a core team member reviews the PR, and either suggests changes, or accepts it and initiates a review. Of course, if this is incorrect, please let me know so I can do whatever next steps there are :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks again for all the contributions to this proposal, hope we see it get approved soon!<br>&gt;&gt;&gt; Riley<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 4, 2016, at 11:58 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hey all!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just updated the proposal with all the recent changes, and you can check it here: https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md &lt;https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Planning on submitting the PR later tonight, so please let me know if you have any last minute feedback!<br>&gt;&gt;&gt;&gt; Riley<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 1:35 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Probably ‘no&#39; in this proposal to keep things simple.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Long term, I would like overriding of the factory init to be the mechanism for a post-hoc extendable factory.  Disallowing it now probably makes that easier in the future.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 1:20 PM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Another point to consider: should factory initializers be able to be overridden by subclasses? I vote no, just as you can&#39;t override convenience initializers.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:50 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yeah.  I was thinking we would want to mirror the convenience initializer syntax, but I am completely ok with this as well.  Honestly this is the syntax I first tried to use in convenience inits while learning swift, and I would love to see that migrate to something like this.  My only worry would be that people would be confused on when to use ClassName() and when to use self.init().  Best to choose one and stick with it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:36 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we are to enforce a different type signature for factory initializers vs required/convenience initializers (which would greatly simplify this issue), if I’m understanding correctly, there shouldn’t be a need to be able to “return” self.init(), right? Because you could do this instead:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; public class ConcreteBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	private init(type2: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		//Default implementation here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		if … {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		return ConcreteBase(type) //Handle the general case with the main class<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class SpecialSubclass : ConcreteBase {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:30 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Doh!  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sorry, typed that up in mail while working on something else at the same time.  We shouldn’t allow an init with the same signature.  self.init() could be called with different parameters.  Trying to call the factory method from the factory method should generate an error.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We probably also want to disallow having an init with the same signature in subclasses as well (we could pass the same info with different parameter names) as a subclass which doesn’t override it would again be calling the factory method.  Ultimately, I would like to see the ability to override the factory method with the behavior I described earlier… but that is for a later proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Basically we should be able to return anything which adheres to the type, so we are free to use other initializers on the class/subclasses.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:10 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, good catch. Would that be confusing as to whether self.init() would lead to an infinite loop, or call the required initializer? Unlike convenience initializers, factory initializers might have the same signature as the required ones.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 2:52 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Agreed.  I would like to see what I was referring to as “stage 1” in this proposal, and we can (hopefully) add on a full solution over time.  (I just wanted to make sure we considered those cases so we didn’t block future improvements)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Looking at the proposal, my only contention would be that we should also allow self.init() to be called from the factory init (similar to a convenience init).  It could still be used with an AbstractBase as shown in your example (especially when dealing with protocols), but it shouldn’t force us to be abstract in the class case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In other words, we should also be able to do the following:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; public class ConcreteBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	private init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		//Default implementation here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		if … {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		return self.init(type) //Handle the general case with the main class<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class SpecialSubclass : ConcreteBase {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The behavior should simply be that we can return any init’d object that conforms to the given type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 2:20 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ultimately, while these are good points, I feel the full mechanism for class clusters belong in a separate proposal. The focus for this one I believe should be the underlying mechanism of factory initializers; should that be approved, then we can focus on adding additional features on top of it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That being said, I’ve written up essentially a final version of the proposal, which you can find here: https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md &lt;https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md&gt;. Assuming everyone is happy with it, I’ll send a pull request in the next few days to the main-repo. But please, give any last minute feedback now!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 5:12 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comments inline.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 12:10 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While I do believe your proposed additions have their benefits, my gut tells me this is too large a change to Swift for an arguably small gain. For this proposal, I&#39;m wanting to keep the change as minimalistic as possible, while still providing enough flexibility and use cases to warrant it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can definitely see the argument that extensibility is out of scope for Swift 3, but I do want to make sure that it is possible for us to have extensibility in the future (that we don’t block ourselves from doing it).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I strongly disagree that the gain is small.  One of the core benefits of both Swift/ObjC (and now POP) is the ability to extend things post-hoc, without access to the original code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I often write libraries &amp; SDKs, so the users of my code don&#39;t have access to the original code.  I guess extensibility is less necessary when you control the entire codebase, but you still have to refactor your factory whenever you subclass (or adhere to a protocol), which I find problematic.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is something I run into a lot while writing actual code, so it isn’t just a theoretical concern.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Interesting you bring up the registering of subclasses, as that is similar to the very original proposal, and actually similar to what I&#39;m doing in my own app. Effectively, I have an Objective-C base class, and in +load it dynamically finds all subclasses using the Objective-C runtime, and stores a reference to them. Then in the initializer, it returns the appropriate subclass based on the initialization parameters. This was my solution to the superclass not having to explicitly know each individual subclass.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Using factory initializers, however, this pattern could be used in pure Swift, albeit with some minor modifications. At program start, the program could register subclasses with the superclass, and then in the initializer would simply return the appropriate subclass (similar to NSURLProtocol, I believe).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, I have also used load in this way in ObjC.  In Swift, I think the compiler could easily build an array/table of the overloads of factory inits.  This avoids having to register explicitly (the declaration itself implies intent to register), and doesn’t take up any cycles during execution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I ran into the problem of when to register the other day in a current project, as Swift doesn’t have an equivalent to +load that I am aware of.  I had to settle for something of a hack which gets called on first use… but it was only a partial solution which worked in that particular case.  How do the swift classes/enums/structs get called to register themselves?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We may want to propose adding a +load equivalent for Swift types, since it does come up occasionally. It is one of those things which you don’t need often, but when you do, you really need it.  Ironically, this was one of the uses of the original feature I talked about earlier (we used it to provide the equivalent of +load, awakeFromNib, etc… in the language). <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As for rationale for protocol (factory) initializers, a common pattern I&#39;ve come across when developing my internal frameworks is to design a protocol, and then to provide a default implementation of the protocol with a type (typically a struct). I feel this relationship could be bridged easier by simply returning this type from a protocol initializer, which could even potentially allow me to declare the actual type as private, so for all intents and purposes the client does simply get an initialized protocol object (similar in part to creating an anonymous class conforming to a protocol in Java).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I strongly agree that we should have factory initializers for protocols for the reasons you state here, plus many others.  It just seems like a natural fit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would like to see a 3 stage approach:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 1:  Declaring an init as “factory” allows you to return any fully inited object which fits the type (including calling self.init like a convenience init would and then returning it). If the init is failable, you can also return nil.  This works both on classes and protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 2:  The compiler builds a table of the overrides of a given factory init, and there is some syntax to call them (e.g. “let sub = subclasses.init(value)”) such that the first one to return non-nil is the return value to that call.  Thorsten’s depth first + alphabetical ordering would be adequate to make the behavior predictable.  Again, this should work for both classes and protocols. (I am open to better ideas for syntax/naming)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 3: We allow greater control over the ordering in the table. This still needs thought both on syntax and method.  Something similar to operator precedence (or autolayout priority) would work in a pinch, but isn’t super elegant. In practice, it might be enough just to be able to declare that something needs to be before/after a specific subclass in the list.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note: A slightly different approach to stage 2 (for classes) might have only the direct subclasses in the table, and then the subclasses have the option to call off to their own subclasses in the same manner if desired.  This has the tradeoff that each level needs to plan for extensibility (i.e. you can’t override something which wasn’t expecting to be subclassed), but I do like how it simplifies the model a bit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have a feeling that the proper syntax for stages 2/3 may become more obvious once the design work around mixins/protocols+storage gets done.  It may just fall out of the disambiguation syntax...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 22, 2016, at 5:21 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes and No.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, because this is a problem I run into all the time, and I really want swift to have a solution for it. I especially like Brent’s idea of a protocol init.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, because I have gotten a bit greedy. I want us to take a step back and look at the underlying problem to see if we can come up with something which completely solves it… and I think factories get us only part way there. Let’s take a moment and see if we can create something uniquely swift before we copy/paste existing solutions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Think about Cocoa’s class clusters for a moment. I love them, but they are a pain to subclass. To the level where any beginning Cocoa instruction tells you explicitly not to subclass them. Similarly, even in my own factories, they are always a pain to extend.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I want our factory inits to be extensible by default.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; By extensible, I mean that I want to be able to add a new subclass (or a new entity satisfying a protocol), and have it come out of the factory when appropriate without editing the base class! Madness, I know, but:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) I may not have access to the source of the base class (e.g. Cocoa Collections)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) I always feel a bit dirty giving the base class knowledge of it’s subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) It is a royal pain, and a potential source of errors as things get refactored when adding new subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think I have at least the seed of an idea of how to solve this, and I am hoping that one of you (who are all much smarter than I) might have the key to getting it the rest of the way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I ran into this problem again last week, and it made me think of an old language I used to use...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was a small programming language I used to use in the 90’s which had an interesting core language feature we called “handlers”. These were a lot like registering for notifications, except that writing a function (with a special “Handler” attribute: “Handler func myFuncName()&quot;) was all you needed to do to register. Writing “Handle myFuncName()” would then systematically call every function with that name and the Handler attribute.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is, instead of calling a single function, it would systematically call a series of functions (all with the same name).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was one other thing that made these handlers special. Each one had the option, when it was called, to reply that it was the one true handler, and the others didn’t need to be called. Basically, it said “I&#39;ve got this!”. This even allowed it to return a result to the caller.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The original intent of this feature (and why it was a core language feature) was to handle events. It would handle things like hit testing and key events fairly elegantly. It was a powerful feature, so it was quickly used for other things. It made things like plug-ins ridiculously simple. We even used it for a form of error handling.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I remember helping to write a page layout program in it, and we used handlers not just for the hit testing, but for the tool palette as well. The end result was that you were able to add new shapes and new tools without modifying existing code at all. It is a feature I miss all the time...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is more power than we need here, but it provided me the inspiration for a potential solution to the factory problem. Back to swift…<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The idea here is to give each interested subclass a chance to say “I&#39;ve got this!”. The factory init runs through each of the subclasses’ overrides until it finds one that doesn’t return nil. New subclasses can be added and they will be given a chance as well (without modifying the base class). The first subclass to successfully init wins. (only subclasses which override the factory init would be considered)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //I like having an explicit call, so that the traditional (non-distributed) factory is possible as well<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         return factory.init(type) //We could also call this “subclass.init(type)” to mirror super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory override init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         guard type == compatibleWithThisType else {return nil} //If info doesn’t work for us, we return nil, and the next class gets a shot<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	//Init concrete type here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The main issue which still needs to be solved is that the order they get called sometimes really matters (this was solved by a well defined ordering + IDE features in the language mentioned above). For the most part, as long as subclasses are called before their superclasses (or there is a some method for cascading), it works. There are still times where you want to define a specific ordering though (e.g. a new subclass wants to get called before an existing subclasses to override some of it’s use cases).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I see a few options (and I would love to hear more):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - subclasses define a numeric precedence (similar to operators now). This is probably the most effective stop-gap solution, but is not elegant.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - subclasses do whatever we change operator precedence to do in the future<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - optionally allow subclasses to name another specific subclass that they are before/after<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - allow subclasses to declare that they would like to be earlier or later (or that they don’t care) in the calling list. subclasses defined outside of the module where the base class was defined would be placed more extremely early/late. Exact order is undefined, but rough ordering is possible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - return (to the superclass) an array of all subclasses which successfully inited. It can then select which one it wants and return it. This seems overly inefficient to me, since you are initializing a bunch of unused objects.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - &lt;Your idea here&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The end result is that you can extend factories of both classes and protocols without access to the original source code.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I also don’t think that the base should always need to be abstract. Factory inits should allow returning subclasses as a way of replacing themselves with a subclass, and returning nil if they are failable, but if there is no return (or return self), it can create an instance of itself. This way, it provides a customization point where subclasses can handle special cases, but the class itself provides an obvious default (i.e. a much less messy form of class cluster).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory init(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	if let subclass = factory.init(type){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	    return subclass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	return self.init()//If subclasses didn’t work, initialize ourselves<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?  Too crazy to consider?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; # Factory Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Protocol Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Riley Testut<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/53327a08/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Proposal] Factory Initializers</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>April 10, 2016 at 06:00:00pm</p></header><div class="content"><p>+1 from me as well!<br></p><p><br>&gt; On Apr 9, 2016, at 12:17 PM, Riley Testut &lt;rileytestut at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hello again everyone!<br>&gt; <br>&gt; Just an update, I did submit the PR about a week ago, and you can check it out here:<br>&gt; https://github.com/apple/swift-evolution/pull/247 &lt;https://github.com/apple/swift-evolution/pull/247&gt;<br>&gt; <br>&gt; As far as I know, now we wait until a core team member reviews the PR, and either suggests changes, or accepts it and initiates a review. Of course, if this is incorrect, please let me know so I can do whatever next steps there are :-)<br>&gt; <br>&gt; Thanks again for all the contributions to this proposal, hope we see it get approved soon!<br>&gt; Riley<br>&gt; <br>&gt;&gt; On Apr 4, 2016, at 11:58 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey all!<br>&gt;&gt; <br>&gt;&gt; Just updated the proposal with all the recent changes, and you can check it here: https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md &lt;https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md&gt;<br>&gt;&gt; <br>&gt;&gt; Planning on submitting the PR later tonight, so please let me know if you have any last minute feedback!<br>&gt;&gt; Riley<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 30, 2016, at 1:35 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Probably ‘no&#39; in this proposal to keep things simple.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Long term, I would like overriding of the factory init to be the mechanism for a post-hoc extendable factory.  Disallowing it now probably makes that easier in the future.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 30, 2016, at 1:20 PM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another point to consider: should factory initializers be able to be overridden by subclasses? I vote no, just as you can&#39;t override convenience initializers.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:50 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yeah.  I was thinking we would want to mirror the convenience initializer syntax, but I am completely ok with this as well.  Honestly this is the syntax I first tried to use in convenience inits while learning swift, and I would love to see that migrate to something like this.  My only worry would be that people would be confused on when to use ClassName() and when to use self.init().  Best to choose one and stick with it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:36 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If we are to enforce a different type signature for factory initializers vs required/convenience initializers (which would greatly simplify this issue), if I’m understanding correctly, there shouldn’t be a need to be able to “return” self.init(), right? Because you could do this instead:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; public class ConcreteBase {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	private init(type2: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt; 		//Default implementation here<br>&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt; 		if … {<br>&gt;&gt;&gt;&gt;&gt;&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt;&gt;&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt;&gt;&gt; 		return ConcreteBase(type) //Handle the general case with the main class<br>&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class SpecialSubclass : ConcreteBase {}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:30 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Doh!  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sorry, typed that up in mail while working on something else at the same time.  We shouldn’t allow an init with the same signature.  self.init() could be called with different parameters.  Trying to call the factory method from the factory method should generate an error.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We probably also want to disallow having an init with the same signature in subclasses as well (we could pass the same info with different parameter names) as a subclass which doesn’t override it would again be calling the factory method.  Ultimately, I would like to see the ability to override the factory method with the behavior I described earlier… but that is for a later proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Basically we should be able to return anything which adheres to the type, so we are free to use other initializers on the class/subclasses.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 3:10 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, good catch. Would that be confusing as to whether self.init() would lead to an infinite loop, or call the required initializer? Unlike convenience initializers, factory initializers might have the same signature as the required ones.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 2:52 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Agreed.  I would like to see what I was referring to as “stage 1” in this proposal, and we can (hopefully) add on a full solution over time.  (I just wanted to make sure we considered those cases so we didn’t block future improvements)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Looking at the proposal, my only contention would be that we should also allow self.init() to be called from the factory init (similar to a convenience init).  It could still be used with an AbstractBase as shown in your example (especially when dealing with protocols), but it shouldn’t force us to be abstract in the class case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In other words, we should also be able to do the following:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; public class ConcreteBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	private init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		//Default implementation here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	public factory init (type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		if … {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 			return SpecialSubclass(type)  //Handle a special case with a more efficient implementation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 		return self.init(type) //Handle the general case with the main class<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class SpecialSubclass : ConcreteBase {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The behavior should simply be that we can return any init’d object that conforms to the given type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 30, 2016, at 2:20 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ultimately, while these are good points, I feel the full mechanism for class clusters belong in a separate proposal. The focus for this one I believe should be the underlying mechanism of factory initializers; should that be approved, then we can focus on adding additional features on top of it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That being said, I’ve written up essentially a final version of the proposal, which you can find here: https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md &lt;https://github.com/rileytestut/swift-evolution/blob/master/proposals/NNNN-factory-initializers.md&gt;. Assuming everyone is happy with it, I’ll send a pull request in the next few days to the main-repo. But please, give any last minute feedback now!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 5:12 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comments inline.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 24, 2016, at 12:10 AM, Riley Testut &lt;rileytestut at gmail.com &lt;mailto:rileytestut at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While I do believe your proposed additions have their benefits, my gut tells me this is too large a change to Swift for an arguably small gain. For this proposal, I&#39;m wanting to keep the change as minimalistic as possible, while still providing enough flexibility and use cases to warrant it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can definitely see the argument that extensibility is out of scope for Swift 3, but I do want to make sure that it is possible for us to have extensibility in the future (that we don’t block ourselves from doing it).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I strongly disagree that the gain is small.  One of the core benefits of both Swift/ObjC (and now POP) is the ability to extend things post-hoc, without access to the original code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I often write libraries &amp; SDKs, so the users of my code don&#39;t have access to the original code.  I guess extensibility is less necessary when you control the entire codebase, but you still have to refactor your factory whenever you subclass (or adhere to a protocol), which I find problematic.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is something I run into a lot while writing actual code, so it isn’t just a theoretical concern.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Interesting you bring up the registering of subclasses, as that is similar to the very original proposal, and actually similar to what I&#39;m doing in my own app. Effectively, I have an Objective-C base class, and in +load it dynamically finds all subclasses using the Objective-C runtime, and stores a reference to them. Then in the initializer, it returns the appropriate subclass based on the initialization parameters. This was my solution to the superclass not having to explicitly know each individual subclass.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Using factory initializers, however, this pattern could be used in pure Swift, albeit with some minor modifications. At program start, the program could register subclasses with the superclass, and then in the initializer would simply return the appropriate subclass (similar to NSURLProtocol, I believe).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, I have also used load in this way in ObjC.  In Swift, I think the compiler could easily build an array/table of the overloads of factory inits.  This avoids having to register explicitly (the declaration itself implies intent to register), and doesn’t take up any cycles during execution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I ran into the problem of when to register the other day in a current project, as Swift doesn’t have an equivalent to +load that I am aware of.  I had to settle for something of a hack which gets called on first use… but it was only a partial solution which worked in that particular case.  How do the swift classes/enums/structs get called to register themselves?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We may want to propose adding a +load equivalent for Swift types, since it does come up occasionally. It is one of those things which you don’t need often, but when you do, you really need it.  Ironically, this was one of the uses of the original feature I talked about earlier (we used it to provide the equivalent of +load, awakeFromNib, etc… in the language). <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As for rationale for protocol (factory) initializers, a common pattern I&#39;ve come across when developing my internal frameworks is to design a protocol, and then to provide a default implementation of the protocol with a type (typically a struct). I feel this relationship could be bridged easier by simply returning this type from a protocol initializer, which could even potentially allow me to declare the actual type as private, so for all intents and purposes the client does simply get an initialized protocol object (similar in part to creating an anonymous class conforming to a protocol in Java).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I strongly agree that we should have factory initializers for protocols for the reasons you state here, plus many others.  It just seems like a natural fit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would like to see a 3 stage approach:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 1:  Declaring an init as “factory” allows you to return any fully inited object which fits the type (including calling self.init like a convenience init would and then returning it). If the init is failable, you can also return nil.  This works both on classes and protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 2:  The compiler builds a table of the overrides of a given factory init, and there is some syntax to call them (e.g. “let sub = subclasses.init(value)”) such that the first one to return non-nil is the return value to that call.  Thorsten’s depth first + alphabetical ordering would be adequate to make the behavior predictable.  Again, this should work for both classes and protocols. (I am open to better ideas for syntax/naming)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stage 3: We allow greater control over the ordering in the table. This still needs thought both on syntax and method.  Something similar to operator precedence (or autolayout priority) would work in a pinch, but isn’t super elegant. In practice, it might be enough just to be able to declare that something needs to be before/after a specific subclass in the list.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note: A slightly different approach to stage 2 (for classes) might have only the direct subclasses in the table, and then the subclasses have the option to call off to their own subclasses in the same manner if desired.  This has the tradeoff that each level needs to plan for extensibility (i.e. you can’t override something which wasn’t expecting to be subclassed), but I do like how it simplifies the model a bit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have a feeling that the proper syntax for stages 2/3 may become more obvious once the design work around mixins/protocols+storage gets done.  It may just fall out of the disambiguation syntax...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 22, 2016, at 5:21 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes and No.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, because this is a problem I run into all the time, and I really want swift to have a solution for it. I especially like Brent’s idea of a protocol init.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, because I have gotten a bit greedy. I want us to take a step back and look at the underlying problem to see if we can come up with something which completely solves it… and I think factories get us only part way there. Let’s take a moment and see if we can create something uniquely swift before we copy/paste existing solutions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Think about Cocoa’s class clusters for a moment. I love them, but they are a pain to subclass. To the level where any beginning Cocoa instruction tells you explicitly not to subclass them. Similarly, even in my own factories, they are always a pain to extend.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I want our factory inits to be extensible by default.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; By extensible, I mean that I want to be able to add a new subclass (or a new entity satisfying a protocol), and have it come out of the factory when appropriate without editing the base class! Madness, I know, but:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) I may not have access to the source of the base class (e.g. Cocoa Collections)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) I always feel a bit dirty giving the base class knowledge of it’s subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) It is a royal pain, and a potential source of errors as things get refactored when adding new subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think I have at least the seed of an idea of how to solve this, and I am hoping that one of you (who are all much smarter than I) might have the key to getting it the rest of the way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I ran into this problem again last week, and it made me think of an old language I used to use...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was a small programming language I used to use in the 90’s which had an interesting core language feature we called “handlers”. These were a lot like registering for notifications, except that writing a function (with a special “Handler” attribute: “Handler func myFuncName()&quot;) was all you needed to do to register. Writing “Handle myFuncName()” would then systematically call every function with that name and the Handler attribute.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is, instead of calling a single function, it would systematically call a series of functions (all with the same name).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was one other thing that made these handlers special. Each one had the option, when it was called, to reply that it was the one true handler, and the others didn’t need to be called. Basically, it said “I&#39;ve got this!”. This even allowed it to return a result to the caller.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The original intent of this feature (and why it was a core language feature) was to handle events. It would handle things like hit testing and key events fairly elegantly. It was a powerful feature, so it was quickly used for other things. It made things like plug-ins ridiculously simple. We even used it for a form of error handling.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I remember helping to write a page layout program in it, and we used handlers not just for the hit testing, but for the tool palette as well. The end result was that you were able to add new shapes and new tools without modifying existing code at all. It is a feature I miss all the time...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is more power than we need here, but it provided me the inspiration for a potential solution to the factory problem. Back to swift…<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The idea here is to give each interested subclass a chance to say “I&#39;ve got this!”. The factory init runs through each of the subclasses’ overrides until it finds one that doesn’t return nil. New subclasses can be added and they will be given a chance as well (without modifying the base class). The first subclass to successfully init wins. (only subclasses which override the factory init would be considered)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         //I like having an explicit call, so that the traditional (non-distributed) factory is possible as well<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         return factory.init(type) //We could also call this “subclass.init(type)” to mirror super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory override init?(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         guard type == compatibleWithThisType else {return nil} //If info doesn’t work for us, we return nil, and the next class gets a shot<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	//Init concrete type here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The main issue which still needs to be solved is that the order they get called sometimes really matters (this was solved by a well defined ordering + IDE features in the language mentioned above). For the most part, as long as subclasses are called before their superclasses (or there is a some method for cascading), it works. There are still times where you want to define a specific ordering though (e.g. a new subclass wants to get called before an existing subclasses to override some of it’s use cases).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I see a few options (and I would love to hear more):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - subclasses define a numeric precedence (similar to operators now). This is probably the most effective stop-gap solution, but is not elegant.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - subclasses do whatever we change operator precedence to do in the future<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - optionally allow subclasses to name another specific subclass that they are before/after<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - allow subclasses to declare that they would like to be earlier or later (or that they don’t care) in the calling list. subclasses defined outside of the module where the base class was defined would be placed more extremely early/late. Exact order is undefined, but rough ordering is possible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - return (to the superclass) an array of all subclasses which successfully inited. It can then select which one it wants and return it. This seems overly inefficient to me, since you are initializing a bunch of unused objects.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - &lt;Your idea here&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The end result is that you can extend factories of both classes and protocols without access to the original source code.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I also don’t think that the base should always need to be abstract. Factory inits should allow returning subclasses as a way of replacing themselves with a subclass, and returning nil if they are failable, but if there is no return (or return self), it can create an instance of itself. This way, it provides a customization point where subclasses can handle special cases, but the class itself provides an obvious default (i.e. a much less messy form of class cluster).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     public factory init(type: InformationToSwitchOn){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	if let subclass = factory.init(type){<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	    return subclass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	return self.init()//If subclasses didn’t work, initialize ourselves<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?  Too crazy to consider?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 8, 2016, at 11:26 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Dec 17, 2015, at 3:41 PM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Recently, I proposed the idea of adding the ability to implement the &quot;class cluster&quot; pattern from Cocoa (Touch) in Swift. However, as we discussed it and came up with different approaches, it evolved into a functionality that I believe is far more beneficial to Swift, and subsequently should be the focus of its own proposal. So here is the improved (pre-)proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; # Factory Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; The &quot;factory&quot; pattern is common in many languages, including Objective-C. Essentially, instead of initializing a type directly, a method is called that returns an instance of the appropriate type determined by the input parameters. Functionally this works well, but ultimately it forces the client of the API to remember to call the factory method instead, rather than the type&#39;s initializer. This might seem like a minor gripe, but given that we want Swift to be as approachable as possible to new developers, I think we can do better in this regard.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Rather than have a separate factory method, I propose we build the factory pattern right into Swift, by way of specialized “factory initializers”. The exact syntax was proposed by Philippe Hausler from the previous thread, and I think it is an excellent solution:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   public factory init(type: InformationToSwitchOn) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;       return ConcreteImplementation(type)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class ConcreteImplementation : AbstractBase {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Why exactly would this be useful in practice? In my own development, I’ve come across a few places where this would especially be relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Class Cluster/Abstract Classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This was the reasoning behind the original proposal, and I still think it would be a very valid use case. The public superclass would declare all the public methods, and could delegate off the specific implementations to the private subclasses. Alternatively, this method could be used as an easy way to handle backwards-compatibility: rather than litter the code with branches depending on the OS version, simply return the OS-appropriate subclass from the factory initializer. Very useful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Protocol Initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Proposed by Brent Royal-Gordon, we could use factory initializers with protocol extensions to return the appropriate instance conforming to a protocol for the given needs. Similar to the class cluster/abstract class method, but can work with structs too. This would be closer to the factory method pattern, since you don’t need to know exactly what type is returned, just the protocol it conforms to.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; ## Initializing Storyboard-backed View Controller<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; This is more specific to Apple Frameworks, but having factory initializers could definitely help here. Currently, view controllers associated with a storyboard must be initialized from the client through a factory method on the storyboard instance (storyboard. instantiateViewControllerWithIdentifier()). This works when the entire flow of the app is storyboard based, but when a single storyboard is used to configure a one-off view controller, having to initialize through the storyboard is essentially use of private implementation details; it shouldn’t matter whether the VC was designed in code or storyboards, ultimately a single initializer should “do the right thing” (just as it does when using XIBs directly). A factory initializer for a View Controller subclass could handle the loading of the storyboard and returning the appropriate view controller.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are some comments from the previous thread that I believe are still relevant:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 9, 2015, at 1:06 PM, Philippe Hausler &lt;phausler at apple.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; I can definitely attest that in implementing Foundation we could have much more idiomatic swift and much more similar behavior to the way Foundation on Darwin actually works if we had factory initializers.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 5:24 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; A `protocol init` in a protocol extension creates an initializer which is *not* applied to types conforming to the protocol. Instead, it is actually an initializer on the protocol itself. `self` is the protocol metatype, not an instance of anything. The provided implementation should `return` an instance conforming to (and implicitly casted to) the protocol. Just like any other initializer, a `protocol init` can be failable or throwing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Unlike other initializers, Swift usually won’t be able to tell at compile time which concrete type will be returned by a protocol init(), reducing opportunities to statically bind methods and perform other optimization tricks. Frankly, though, that’s just the cost of doing business. If you want to select a type dynamically, you’re going to lose the ability to aggressively optimize calls to the resulting instance.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I’d love to hear everyone’s thoughts on this!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Riley Testut<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Was any proposal for this ever written up? It would be really useful to have, and it appeared to have the support of several Apple staff members.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/1b2d8868/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
