<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>June 18, 2016 at 03:00:00am</p></header><div class="content"><p>I heard that this has been brought up before, but what if we give all non-mutating methods the same name as their mutating counterparts? The compiler can just pick the right one based on whether an assignment is taking place or not. Here are the advantages I can think of:<br></p><p>- it would end this debate once and for all, because every relevant method name would just be the infinitive<br>- it makes it way easier to keep the language consistent<br>- we won’t have to remember which name belongs to the mutating version and which name belongs to the non-mutating version<br>- people are attached to `map` and `filter`<br></p><p>Last but not least, this could get rid of a lot of boilerplate code. Often, either the mutating or non-mutating version of a method is implemented using the other:<br></p><p>func someNonMutatingMethod() -&gt; Self {<br>    var copy = self<br>    copy.someMutatingMethod()<br>    return copy<br>}<br></p><p>or:<br></p><p>mutating func someMutatingMethod() {<br>    self = someNonMutatingMethod()<br>}<br></p><p>If we only implement one of the two, the compiler could implement the missing method for us (which we then can prevent with the attributes @mutatingOnly and @nonMutatingOnly, or something of the sort). Or we can make this system opt-in instead.<br></p><p>If there are convincing arguments against this, I’d love to hear them.<br></p><p>&gt; Due to considerably support onthis thread(http://news.gmane.org/find-root.php?group=gmane.comp.lang.swift.evolution&amp;article=20783), a draft proposal to revisit the core functional method exceptions to the -ed/-ing rule.<br>&gt; <br>&gt; Online version:https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md<br>&gt; <br>&gt; Apply -ed/-ing rule to core functional methods<br>&gt; Proposal:SE-NNNN(https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/NNNN-functional-methods-ed-ing.md)<br>&gt; Author:Patrick Pijnappel(https://github.com/PatrickPijnappel)<br>&gt; Status:Awaiting review<br>&gt; Review manager: TBD<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; The Swift API Guidelines standardizes non-mutating method forms on verbs ending in -ed/-ing (or nouns). However, a few non-mutating forms have been kept as &quot;Terms of Art&quot;:map,flatMap,filter,reduce,dropFirstanddropLast. This proposal proposes to bring these in line with all other non-mutating forms (e.g.filter =&gt;filtered).<br>&gt; <br>&gt; <br>&gt; Swift-evolution threads:Source(http://news.gmane.org/find-root.php?group=gmane.comp.lang.swift.evolution&amp;article=20783)<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; These method have been kept to preserve the terms of art. Generally, this can have significant benefits:<br>&gt; <br>&gt; Anyone familiar with the term will immediately understand it, and use their assumptions about how it works.<br>&gt; Users learning the term from Swift can use their knowledge when encountering it elsewhere.<br>&gt; Experienced users will be able to use the mental pattern matching they&#39;ve built-up for quickly recognizing common programming patterns.<br>&gt; <br>&gt; <br>&gt; However, basically all of the benefits of using a term of art still apply to the modified forms: – For recognition, the modified forms are still very close to the traditional terms of art. So both coming to and from Swift you&#39;ll be able to use your knowledge pretty much unaffected.<br>&gt; <br>&gt; If the user looks for e.g.filterthey are pretty much guaranteed to quickly find the correct form, be it through code-completion, google or a fix-it.<br>&gt; There isn&#39;t really any violation of assumptions that might cause problems in this case.<br>&gt; Any mental pattern matching will likely transfer quickly due to the minimal difference.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The proposed solution modifies the method verbs to their -ed/-ing forms (preferring the former).<br>&gt; <br>&gt; <br>&gt; It removes the last clear exceptions to the -ed/-ing rule from the standard library, which previously were exactly the opposite of what one would expect based on the API guidelines (and the rest of the language).<br>&gt; <br>&gt; <br>&gt; It also aids users in learning to pattern match on the -ed/-ing rule and internalizing the API guidelines, since now all methods are named this way – instead of the most commonly used methods defying the normal pattern.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; The change would rename the following method families:<br>&gt; <br>&gt; map    =&gt;mapped flatMap  =&gt;flatMapped filter  =&gt;filtered reduce  =&gt;reduced dropFirst =&gt;droppingFirst dropLast =&gt;droppingLast<br>&gt; Impact on existing code<br>&gt; <br>&gt; The Swift migrator and fix-its would be provided for the change.<br>&gt; <br>&gt; Alternatives considered<br>&gt; Alternatively -ing suffixes could be used formap/flatMap/filter/reduce. However, these are normally reserved for when -ed doesn&#39;t really work (e.g. droppedFirst).<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
