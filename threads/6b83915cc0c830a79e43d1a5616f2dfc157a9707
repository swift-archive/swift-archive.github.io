<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27cba2e668c6c6fb1f1d4669b1474397?s=50"></div><header><strong>Explicit Protocol Conformance for Child Classes</strong> from <string>Arthur Ariel Sabintsev</string> &lt;arthur at sabintsev.com&gt;<p>December 12, 2015 at 12:00:00pm</p></header><div class="content"><p>TL;DR: Force explicit protocol conformance of non-optional methods for<br>child classes on an opt-in basis.<br></p><p>Currently, a child class that inherits their parent class&#39; protocol<br>conformations are not explicitly required to override their parent classes<br>implementation of a protocol. For example, a custom class,<br>MyTableViewController, does not explicitly have to override the<br>non-optional methods of the protocols (i.e., UITableViewDataSource,<br>UITableViewDelegate) to which UITableViewController conforms.<br></p><p>For many protocols, the superclass implementation of a protocol method may<br>be enough. Therefore, this feature should off by default, and only enabled<br>if the creator of the protocol requires it (for whatever reason). I suggest<br>using a new `@abstract` attribute  to designate if a protocol requires<br>explicit conformance for children of a conforming parent class. This choice<br>of naming for the attribute is along the lines of what other languages call<br>an Abstract Class, which is what I&#39;m trying to have added to Swift in this<br>fairly long-winded post.<br></p><p>@abstract protocol P: class {<br>     // All methods defined in here would need to be explicitly overridden<br>by the conforming class&#39;s children.<br>}<br></p><p>If you want to have optional methods in your protocol, then using the<br>@abstract attribute gets kind of messy, as you also have the @objc<br>attribute.<br></p><p>@abstract @objc protocol P: class {<br>     // All non-optional methods defined in here would need to be<br>explicitly overridden by the conforming class&#39;s children.<br>}<br></p><p>Thoughts?<br></p><p>Best,<br></p><p>Arthur / Sabintsev.com &lt;http://sabintsev.com/&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/6b839707/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Explicit Protocol Conformance for Child Classes</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 13, 2015 at 02:00:00pm</p></header><div class="content"><p>How about reusing the keyword &quot;required&quot; for this? It&#39;s already used (and<br>has a similar meaning) for initializers.<br></p><p>I think NSSecureCoding is a good example of a use case.<br></p><p>On Sat, Dec 12, 2015 at 9:14 AM, Arthur Ariel Sabintsev via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; TL;DR: Force explicit protocol conformance of non-optional methods for<br>&gt; child classes on an opt-in basis.<br>&gt;<br>&gt; Currently, a child class that inherits their parent class&#39; protocol<br>&gt; conformations are not explicitly required to override their parent classes<br>&gt; implementation of a protocol. For example, a custom class,<br>&gt; MyTableViewController, does not explicitly have to override the<br>&gt; non-optional methods of the protocols (i.e., UITableViewDataSource,<br>&gt; UITableViewDelegate) to which UITableViewController conforms.<br>&gt;<br>&gt; For many protocols, the superclass implementation of a protocol method may<br>&gt; be enough. Therefore, this feature should off by default, and only enabled<br>&gt; if the creator of the protocol requires it (for whatever reason). I suggest<br>&gt; using a new `@abstract` attribute  to designate if a protocol requires<br>&gt; explicit conformance for children of a conforming parent class. This choice<br>&gt; of naming for the attribute is along the lines of what other languages call<br>&gt; an Abstract Class, which is what I&#39;m trying to have added to Swift in this<br>&gt; fairly long-winded post.<br>&gt;<br>&gt; @abstract protocol P: class {<br>&gt;      // All methods defined in here would need to be explicitly overridden<br>&gt; by the conforming class&#39;s children.<br>&gt; }<br>&gt;<br>&gt; If you want to have optional methods in your protocol, then using the<br>&gt; @abstract attribute gets kind of messy, as you also have the @objc<br>&gt; attribute.<br>&gt;<br>&gt; @abstract @objc protocol P: class {<br>&gt;      // All non-optional methods defined in here would need to be<br>&gt; explicitly overridden by the conforming class&#39;s children.<br>&gt; }<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt; Arthur / Sabintsev.com &lt;http://sabintsev.com/&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/2a9b61ca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Explicit Protocol Conformance for Child Classes</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 13, 2015 at 03:00:00pm</p></header><div class="content"><p>Seems to me this doesn&#39;t actually make sense on protocols at all. The<br>scenario of a base superclass like UITableViewController that conforms<br>to a protocol but only makes sense if its children override methods<br>doesn&#39;t actually have anything to do with the protocol at all, as it&#39;s<br>certainly not true any class that conforms to<br>UITableViewDelegate/DataSource wants subclasses to override methods,<br>that&#39;s only true of UITableViewController.<br></p><p>Given that, the proposed @abstract is actually something that would make<br>sense to put on the implementation of a method in a class, not on a<br>protocol. There&#39;s simply no such thing as an abstract protocol. And when<br>put on a method, it would probably be better to just call it<br>@requires_override, because that&#39;s all it means.<br></p><p>All that said, it doesn&#39;t actually make sense to put the attribute on<br>UITableViewController&#39;s methods either. And the reason for that is that<br>if you use a storyboard with static cells, you can have a<br>UITableViewController that functions perfectly fine without overriding<br>any of the UITableViewDelegate/DataSource methods. So requiring that a<br>subclass implement any of those methods would actually be wrong.<br></p><p>So overall, there are use-cases for a @requires_override attribute, but<br>UITableViewController actually isn&#39;t one of them (in fact, I don&#39;t think<br>anything in UIKit/Foundation qualifies).<br></p><p>Regarding `required`, that&#39;s not appropriate because `required` means<br>that every single descendant class must provide an implementation. And<br>it&#39;s only allowed on init methods because the whole point of `required`<br>is to remove the special-cased behavior of init for subclassing (e.g.<br>that it&#39;s not inherited by subclasses). There&#39;s no other place besides<br>init() where it makes sense to require every single descendant class to<br>provide an implementation because every other method will get inherited<br>(and even if your base class&#39;s implementation should always be<br>overridden, if your child overrides it, your grandchild certainly<br>doesn&#39;t have to!).<br></p><p>-Kevin Ballard<br></p><p>On Sun, Dec 13, 2015, at 02:16 PM, Jacob Bandes-Storch via swift-evolution wrote:<br>&gt; How about reusing the keyword &quot;required&quot; for this? It&#39;s already used<br>&gt; (and has a similar meaning) for initializers.<br>&gt;<br>&gt; I think NSSecureCoding is a good example of a use case.<br>&gt;<br>&gt; On Sat, Dec 12, 2015 at 9:14 AM, Arthur Ariel Sabintsev via swift-<br>&gt; evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; TL;DR: Force explicit protocol conformance of non-optional methods<br>&gt;&gt; for child classes on an opt-in basis.<br>&gt;&gt;<br>&gt;&gt; Currently, a child class that inherits their parent class&#39; protocol<br>&gt;&gt; conformations are not explicitly required to override their parent<br>&gt;&gt; classes implementation of a protocol. For example, a custom class,<br>&gt;&gt; MyTableViewController, does not explicitly have to override the non-<br>&gt;&gt; optional methods of the protocols (i.e., UITableViewDataSource,<br>&gt;&gt; UITableViewDelegate) to which UITableViewController conforms.<br>&gt;&gt;<br>&gt;&gt; For many protocols, the superclass implementation of a protocol<br>&gt;&gt; method may be enough. Therefore, this feature should off by default,<br>&gt;&gt; and only enabled if the creator of the protocol requires it (for<br>&gt;&gt; whatever reason). I suggest using a new `@abstract` attribute  to<br>&gt;&gt; designate if a protocol requires explicit conformance for children<br>&gt;&gt; of a conforming parent class. This choice of naming for the<br>&gt;&gt; attribute is along the lines of what other languages call an<br>&gt;&gt; Abstract Class, which is what I&#39;m trying to have added to Swift in<br>&gt;&gt; this fairly long-winded post.<br>&gt;&gt;<br>&gt;&gt; @abstract protocol P: class {     // All methods defined in here<br>&gt;&gt; would need to be explicitly overridden by the conforming class&#39;s<br>&gt;&gt; children. }<br>&gt;&gt;<br>&gt;&gt; If you want to have optional methods in your protocol, then using the<br>&gt;&gt; @abstract attribute gets kind of messy, as you also have the @objc<br>&gt;&gt; attribute.<br>&gt;&gt;<br>&gt;&gt; @abstract @objc protocol P: class {     // All non-optional methods<br>&gt;&gt; defined in here would need to be explicitly overridden by the<br>&gt;&gt; conforming class&#39;s children. }<br>&gt;&gt;<br>&gt;&gt; Thoughts?<br>&gt;&gt;<br>&gt;&gt; Best,<br>&gt;&gt;<br>&gt;&gt; Arthur / Sabintsev.com[1]<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt;<br>swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>Links:<br></p><p>  1. http://sabintsev.com/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/8810cab1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0eaab3d5d1d4428f74a711f724f2eb47?s=50"></div><header><strong>Explicit Protocol Conformance for Child Classes</strong> from <string>Etan Kissling</string> &lt;kissling at oberon.ch&gt;<p>December 15, 2015 at 02:00:00pm</p></header><div class="content"><p>Would maybe stick with @abstract or @deferred instead of the verbose @requires_override as the keyword.<br>Those keywords are known from other languages.<br></p><p>+1 with the rest, though.<br></p><p>It&#39;s really a pain to not have access to abstract classes.<br>My workaround for similar cases is<br>- Put function definitions with deferred implementation into protocols.<br>- Mark initializer of base class as private to prevent instantiation of the incomplete class.<br>- Put subclasses into same file as base class.<br>- In subclass, inherit from both the base class and the protocol, and override initializer as public.<br></p><p>Also agree with the irrelevance for UITableViewController. The class works perfectly fine without the overrides.<br></p><p>Etan<br></p><p>&gt; On 14 Dec 2015, at 00:27, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Seems to me this doesn&#39;t actually make sense on protocols at all. The scenario of a base superclass like UITableViewController that conforms to a protocol but only makes sense if its children override methods doesn&#39;t actually have anything to do with the protocol at all, as it&#39;s certainly not true any class that conforms to UITableViewDelegate/DataSource wants subclasses to override methods, that&#39;s only true of UITableViewController.<br>&gt; <br>&gt; Given that, the proposed @abstract is actually something that would make sense to put on the implementation of a method in a class, not on a protocol. There&#39;s simply no such thing as an abstract protocol. And when put on a method, it would probably be better to just call it @requires_override, because that&#39;s all it means.<br>&gt; <br>&gt; All that said, it doesn&#39;t actually make sense to put the attribute on UITableViewController&#39;s methods either. And the reason for that is that if you use a storyboard with static cells, you can have a UITableViewController that functions perfectly fine without overriding any of the UITableViewDelegate/DataSource methods. So requiring that a subclass implement any of those methods would actually be wrong.<br>&gt; <br>&gt; So overall, there are use-cases for a @requires_override attribute, but UITableViewController actually isn&#39;t one of them (in fact, I don&#39;t think anything in UIKit/Foundation qualifies).<br>&gt; <br>&gt; Regarding `required`, that&#39;s not appropriate because `required` means that every single descendant class must provide an implementation. And it&#39;s only allowed on init methods because the whole point of `required` is to remove the special-cased behavior of init for subclassing (e.g. that it&#39;s not inherited by subclasses). There&#39;s no other place besides init() where it makes sense to require every single descendant class to provide an implementation because every other method will get inherited (and even if your base class&#39;s implementation should always be overridden, if your child overrides it, your grandchild certainly doesn&#39;t have to!).<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Sun, Dec 13, 2015, at 02:16 PM, Jacob Bandes-Storch via swift-evolution wrote:<br>&gt;&gt; How about reusing the keyword &quot;required&quot; for this? It&#39;s already used (and has a similar meaning) for initializers.<br>&gt;&gt; <br>&gt;&gt; I think NSSecureCoding is a good example of a use case.<br>&gt;&gt; <br>&gt;&gt; On Sat, Dec 12, 2015 at 9:14 AM, Arthur Ariel Sabintsev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; TL;DR: Force explicit protocol conformance of non-optional methods for child classes on an opt-in basis.<br>&gt;&gt; <br>&gt;&gt; Currently, a child class that inherits their parent class&#39; protocol conformations are not explicitly required to override their parent classes implementation of a protocol. For example, a custom class, MyTableViewController, does not explicitly have to override the non-optional methods of the protocols (i.e., UITableViewDataSource, UITableViewDelegate) to which UITableViewController conforms.<br>&gt;&gt; <br>&gt;&gt; For many protocols, the superclass implementation of a protocol method may be enough. Therefore, this feature should off by default, and only enabled if the creator of the protocol requires it (for whatever reason). I suggest using a new `@abstract` attribute  to designate if a protocol requires explicit conformance for children of a conforming parent class. This choice of naming for the attribute is along the lines of what other languages call an Abstract Class, which is what I&#39;m trying to have added to Swift in this fairly long-winded post.<br>&gt;&gt; <br>&gt;&gt; @abstract protocol P: class {<br>&gt;&gt;      // All methods defined in here would need to be explicitly overridden by the conforming class&#39;s children.<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; If you want to have optional methods in your protocol, then using the @abstract attribute gets kind of messy, as you also have the @objc attribute.<br>&gt;&gt; <br>&gt;&gt; @abstract @objc protocol P: class {<br>&gt;&gt;      // All non-optional methods defined in here would need to be explicitly overridden by the conforming class&#39;s children.<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; <br>&gt;&gt; Arthur / Sabintsev.com &lt;http://sabintsev.com/&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/56080341/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 801 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/56080341/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27cba2e668c6c6fb1f1d4669b1474397?s=50"></div><header><strong>Explicit Protocol Conformance for Child Classes</strong> from <string>Arthur Ariel Sabintsev</string> &lt;arthur at sabintsev.com&gt;<p>December 17, 2015 at 04:00:00am</p></header><div class="content"><p>All,<br></p><p>I agree, the UITableViewController example was poor. I couldn&#39;t pull out<br>another example without being extremely abstract. I used UITableVC to<br>delineate the hierarchy more than to delineate the actual benefit of my<br>suggestion.<br></p><p>My goal, in one line, is to have the ability enforce certain<br>(marked/flagged) methods in a subclass to explicitly override their<br>parent&#39;s protocol-conformed methods. I chose @abstract as it&#39;s a known<br>keyword. Personally, @requires_override is my favorite suggestion thus far.<br></p><p><br></p><p>On Tue, Dec 15, 2015 at 9:43 AM Etan Kissling via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Would maybe stick with @abstract or @deferred instead of the verbose<br>&gt; @requires_override as the keyword.<br>&gt; Those keywords are known from other languages.<br>&gt;<br>&gt; +1 with the rest, though.<br>&gt;<br>&gt; It&#39;s really a pain to not have access to abstract classes.<br>&gt; My workaround for similar cases is<br>&gt; - Put function definitions with deferred implementation into protocols.<br>&gt; - Mark initializer of base class as private to prevent instantiation of<br>&gt; the incomplete class.<br>&gt; - Put subclasses into same file as base class.<br>&gt; - In subclass, inherit from both the base class and the protocol, and<br>&gt; override initializer as public.<br>&gt;<br>&gt; Also agree with the irrelevance for UITableViewController. The class works<br>&gt; perfectly fine without the overrides.<br>&gt;<br>&gt; Etan<br>&gt;<br>&gt; On 14 Dec 2015, at 00:27, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Seems to me this doesn&#39;t actually make sense on protocols at all. The<br>&gt; scenario of a base superclass like UITableViewController that conforms to a<br>&gt; protocol but only makes sense if its children override methods doesn&#39;t<br>&gt; actually have anything to do with the protocol at all, as it&#39;s certainly<br>&gt; not true any class that conforms to UITableViewDelegate/DataSource wants<br>&gt; subclasses to override methods, that&#39;s only true of UITableViewController.<br>&gt;<br>&gt; Given that, the proposed @abstract is actually something that would make<br>&gt; sense to put on the implementation of a method in a class, not on a<br>&gt; protocol. There&#39;s simply no such thing as an abstract protocol. And when<br>&gt; put on a method, it would probably be better to just call it<br>&gt; @requires_override, because that&#39;s all it means.<br>&gt;<br>&gt; All that said, it doesn&#39;t actually make sense to put the attribute on<br>&gt; UITableViewController&#39;s methods either. And the reason for that is that if<br>&gt; you use a storyboard with static cells, you can have a<br>&gt; UITableViewController that functions perfectly fine without overriding any<br>&gt; of the UITableViewDelegate/DataSource methods. So requiring that a subclass<br>&gt; implement any of those methods would actually be wrong.<br>&gt;<br>&gt; So overall, there are use-cases for a @requires_override attribute, but<br>&gt; UITableViewController actually isn&#39;t one of them (in fact, I don&#39;t think<br>&gt; anything in UIKit/Foundation qualifies).<br>&gt;<br>&gt; Regarding `required`, that&#39;s not appropriate because `required` means that<br>&gt; every single descendant class must provide an implementation. And it&#39;s only<br>&gt; allowed on init methods because the whole point of `required` is to remove<br>&gt; the special-cased behavior of init for subclassing (e.g. that it&#39;s not<br>&gt; inherited by subclasses). There&#39;s no other place besides init() where it<br>&gt; makes sense to require every single descendant class to provide an<br>&gt; implementation because every other method will get inherited (and even if<br>&gt; your base class&#39;s implementation should always be overridden, if your child<br>&gt; overrides it, your grandchild certainly doesn&#39;t have to!).<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Sun, Dec 13, 2015, at 02:16 PM, Jacob Bandes-Storch via swift-evolution<br>&gt; wrote:<br>&gt;<br>&gt; How about reusing the keyword &quot;required&quot; for this? It&#39;s already used (and<br>&gt; has a similar meaning) for initializers.<br>&gt;<br>&gt; I think NSSecureCoding is a good example of a use case.<br>&gt;<br>&gt; On Sat, Dec 12, 2015 at 9:14 AM, Arthur Ariel Sabintsev via<br>&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; TL;DR: Force explicit protocol conformance of non-optional methods for<br>&gt; child classes on an opt-in basis.<br>&gt;<br>&gt; Currently, a child class that inherits their parent class&#39; protocol<br>&gt; conformations are not explicitly required to override their parent classes<br>&gt; implementation of a protocol. For example, a custom class,<br>&gt; MyTableViewController, does not explicitly have to override the<br>&gt; non-optional methods of the protocols (i.e., UITableViewDataSource,<br>&gt; UITableViewDelegate) to which UITableViewController conforms.<br>&gt;<br>&gt; For many protocols, the superclass implementation of a protocol method may<br>&gt; be enough. Therefore, this feature should off by default, and only enabled<br>&gt; if the creator of the protocol requires it (for whatever reason). I suggest<br>&gt; using a new `@abstract` attribute  to designate if a protocol requires<br>&gt; explicit conformance for children of a conforming parent class. This choice<br>&gt; of naming for the attribute is along the lines of what other languages call<br>&gt; an Abstract Class, which is what I&#39;m trying to have added to Swift in this<br>&gt; fairly long-winded post.<br>&gt;<br>&gt; @abstract protocol P: class {<br>&gt;      // All methods defined in here would need to be explicitly overridden<br>&gt; by the conforming class&#39;s children.<br>&gt; }<br>&gt;<br>&gt; If you want to have optional methods in your protocol, then using the<br>&gt; @abstract attribute gets kind of messy, as you also have the @objc<br>&gt; attribute.<br>&gt;<br>&gt; @abstract @objc protocol P: class {<br>&gt;      // All non-optional methods defined in here would need to be<br>&gt; explicitly overridden by the conforming class&#39;s children.<br>&gt; }<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt; Arthur / Sabintsev.com &lt;http://sabintsev.com/&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; *_______________________________________________*<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Best,<br></p><p>Arthur / Sabintsev.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/3d024bb6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
