<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May  6, 2016 at 10:00:00pm</p></header><div class="content"><p>Hello Swift development community,<br></p><p>Swift does a great job of protecting against undefined behavior--as long as you avoid &quot;unsafe&quot; APIs, that is. However, unsafe APIs are important for giving developers control over implementation details and performance. Naturally, the contract between unsafe APIs and the optimizer is crucial. When a developer uses an unsafe API, the rules governing safe, well-defined behavior must be clear. On the opposite end, the optimizer must know which assumptions it can make based on those rules. Simply saying that anything goes because &quot;unsafe&quot; is in the name is not helpful to this effort.<br></p><p>For a long time, I&#39;ve wanted these rules nailed down. We have more users taking advantage of advanced features, and more optimizations that take advantage of assumptions guided by the type system. This seems like a particularly good time to resolve UnsafePointer semantics, considering the type system and UnsafePointer work that&#39;s been going on recently. Strict aliasing is something I would like addressed. If we do nothing here, then we will end up by default inheriting C/C++ semantics, as with any language that relies on a C/C++ backend. In other words, developers will be forced to write code with technically undefined behavior and rely on the compiler to be smart enough to recognize and recover from common patterns. Or we can take advantage of this opportunity and instead adopt a sound memory model with respect to aliasing.<br></p><p>This proposal is only an RFC at this point. I&#39;m sending it out now to allow for plenty of time for discussion (or advance warning). Keep in mind that it could change considerably before it goes up for review.<br></p><p>-Andy<br></p><p>UnsafeBytePointer API for In-Memory Layout<br></p><p>Proposal: SE-NNNN &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md&gt;<br>Author(s): Andrew Trick &lt;https://github.com/atrick&gt;<br>Status: Awaiting review &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#rationale&gt;<br>Review manager: TBD<br> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#introduction&gt;Introduction<br></p><p>UnsafePointer and UnsafeMutable refer to a typed region of memory, and the compiler must be able to assume that UnsafePointer element (Pointee) type is consistent with other access to the same memory. See proposed Type Safe Memory Access documentation &lt;https://github.com/atrick/swift/blob/type-safe-mem-docs/docs/TypeSafeMemory.rst&gt;. Consequently, inferred conversion between UnsafePointer element types exposes an easy way to abuse the type system. No alternative currently exists for manual memory layout and direct access to untyped memory, and that leads to an overuse of UnsafePointer. These uses of UnsafePointer, which depend on pointer type conversion, make accidental type punning likely. Type punning via UnsafePointer is semantically undefined behavior and de facto undefined behavior given the optimizer&#39;s long-time treatment of UnsafePointer.<br></p><p>In this document, all mentions of UnsafePointer also apply to UnsafeMutablePointer.<br></p><p> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#motivation&gt;Motivation<br></p><p>To avoid accidental type punning, we should prohibit inferred conversion between UnsafePointer&lt;T&gt; and UnsafePointer&lt;U&gt; unless the target of the conversion is an untyped or nondereferenceable pointer (currently represented as UnsafePointer&lt;Void&gt;).<br></p><p>To support this change we should introduce a new pointer type that does not bind the type of its Pointee. Such a new pointer type would provide an ideal foundation for an API that allows byte-wise pointer arithmetic and a legal, well-defined means to access an untyped region of memory.<br></p><p>As motivation for such an API, consider that an UnsafePointer&lt;Void&gt; or OpaquePointer may be currently be obtained from an external API. However, the developer may know the memory layout and may want to read or write elements whose types are compatible with that layout. This a reasonable use case, but unless the developer can guarantee that all accesses to the same memory location have the same type, then they cannot use UnsafePointer to access the memory without risking undefined behavior.<br></p><p>An UnsafeBytePointer example, using a new proposed API is included below.<br></p><p> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#proposed-solution&gt;Proposed solution<br></p><p>Introduce an UnsafeBytePointer type along with an API for obtaining a UnsafeBytePointer value at a relative byte offset and loading and storing arbitrary types at that location.<br></p><p>Statically prohibit inferred UnsafePointer conversion while allowing inferred UnsafePointer to UnsafeBytePointerconversion.<br></p><p>UnsafeBytePointer meets multiple requirements:<br></p><p>An untyped pointer to memory<br>Pointer arithmetic within byte-addressable memory<br>Type-unsafe access to memory (legal type punning)<br>UnsafeBytePointer will replace UnsafeMutablePointer&lt;Void&gt; as the representation for untyped memory. For API clarify we could consider a typealias for VoidPointer. I don&#39;t think a separate VoidPointer type would be useful--there&#39;s no danger that UnsafeBytePointer will be casually dereferenced, and don&#39;t see the danger in allowing pointer arithmetic since the only reasonable interpretation is that of a byte-addressable memory.<br></p><p>Providing an API for type-unsafe memory access would not serve a purpose without the ability to compute byte offsets. Of course, we could require users to convert back and forth using bitPatterns, but I think that would be awkward and only obscure the purpose of the UnsafeBytePointer type.<br></p><p>In this proposal, UnsafeBytePointer does not specify mutability. Adding an UnsafeMutableBytePointer would be straightforward, but adding another pointer type needs strong justification. I expect to get input from the community on this. If we agree that the imported type for const void* should be UnsafeBytePointer, then we probably need UnsafeMutablePointer to handle interoperability.<br></p><p> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#detailed-design&gt;Detailed design<br></p><p>The public API is shown here. For details and comments, see the unsafeptr_convert branch &lt;https://github.com/atrick/swift/commits/unsafeptr_convert&gt;.<br></p><p>struct UnsafeBytePointer : Hashable, _Pointer {<br></p><p>  let _rawValue: Builtin.RawPointer<br></p><p>  var hashValue: Int {...}<br></p><p>  init&lt;T&gt;(_ : UnsafePointer&lt;T&gt;)<br>  init&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;)<br>  init?&lt;T&gt;(_ : UnsafePointer&lt;T&gt;?)<br>  init?&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;?)<br></p><p>  init&lt;T&gt;(_ : OpaquePointer&lt;T&gt;)<br>  init?&lt;T&gt;(_ : OpaquePointer&lt;T&gt;?)<br></p><p>  init?(bitPattern: Int)<br>  init?(bitPattern: UInt)<br></p><p>  func load&lt;T&gt;(_ : T.Type) -&gt; T<br></p><p>  @warn_unused_result<br>  init(allocatingBytes size: Int, alignedTo: Int)<br></p><p>  @warn_unused_result<br>  init&lt;T&gt;(allocatingCapacity count: Int, of: T.Type)<br></p><p>  func deallocateBytes(_ size: Int, alignedTo: Int)<br></p><p>  func deallocateCapacity&lt;T&gt;(_ num: Int, of: T.Type)<br></p><p>  // Returns a pointer one byte after the initialized memory.<br>  func initialize&lt;T&gt;(with newValue: T, count: Int = 1) -&gt; UnsafeBytePointer<br></p><p>  // Returns a pointer one byte after the initialized memory.<br>  func initialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int) -&gt; UnsafeBytePointer<br></p><p>  func initializeBackward&lt;T&gt;(from source: UnsafePointer&lt;T&gt;, count: Int)<br></p><p>  func deinitialize&lt;T&gt;(_ : T.Type, count: Int = 1)<br>}<br></p><p>extension OpaquePointer {<br>  init(_ : UnsafeBytePointer)<br>}<br></p><p>extension Int {<br>  init(bitPattern: UnsafeBytePointer)<br>}<br></p><p>extension UInt {<br>  init(bitPattern: UnsafeBytePointer)<br>}<br></p><p>extension UnsafeBytePointer : RandomAccessIndex {<br>  typealias Distance = Int<br></p><p>  func successor() -&gt; UnsafeBytePointer<br>  func predecessor() -&gt; UnsafeBytePointer<br>  func distance(to : UnsafeBytePointer) -&gt; Int<br>  func advanced(by : Int) -&gt; UnsafeBytePointer<br>}<br></p><p>func == (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Bool<br></p><p>func &lt; (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Bool<br></p><p>func + (lhs: UnsafeBytePointer, rhs: Int) -&gt; UnsafeBytePointer<br></p><p>func + (lhs: Int, rhs: UnsafeBytePointer) -&gt; UnsafeBytePointer<br></p><p>func - (lhs: UnsafeBytePointer, rhs: Int) -&gt; UnsafeBytePointer<br></p><p>func - (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Int<br></p><p>func += (lhs: inout UnsafeBytePointer, rhs: Int)<br></p><p>func -= (lhs: inout UnsafeBytePointer, rhs: Int)<br>Occasionally, we need to convert from a UnsafeBytePointer to an UnsafePointer. This should only be done in very rare circumstances when the author understands the compiler&#39;s strict type rules for UnsafePointer. Although this could be done by casting through an OpaquePointer, an explicit, designated unsafe pointer cast API would makes the risks more obvious and self-documenting. For example:<br></p><p>extension UnsafePointer {<br>  init(_ from: UnsafeBytePointer, toPointee: Pointee.type)<br>}<br>extension UnsafeMutablePointer {<br>  init(_ from: UnsafeBytePointer, toPointee: Pointee.type)<br>}<br>Similarly, conversion between UnsafePointer types must now be spelled with an explicitly Pointee type:<br></p><p>extension UnsafePointer {<br>  init&lt;U&gt;(_ from: UnsafePointer&lt;U&gt;, toPointee: Pointee.Type)<br>  init&lt;U&gt;(_ from: UnsafeMutablePointer&lt;U&gt;, toPointee: Pointee.Type)<br>}<br>extension UnsafeMutablePointer {<br>  init&lt;U&gt;(_ from: UnsafeMutablePointer&lt;U&gt;, toPointee: Pointee.Type)<br>}<br> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>The largest impact of this change is that void* and const void* are imported as UnsafeBytePointer. This impacts many public APIs, but with implicit argument conversion should not affect typical uses of those APIs.<br></p><p>Any Swift projects that rely on type inference to convert between UnsafePointer types will need to take action. The developer needs to determine whether type punning is necessary. If so, they must migrate to the UnsafeBytePointer API. Otherwise, they can work around the new restriction by using a toPointee, or mutating label.<br></p><p>Disallowing inferred UnsafePointer direct conversion requires some standard library code to use an explicit toPointeelabel for unsafe conversions that may violate strict aliasing.<br></p><p>All occurrences of Unsafe[Mutable]Pointer&lt;Void&gt; in the standard library are converted to UnsafeBytePointer. e.g. unsafeAddress() now returns UnsafeBytePointer, not UnsafePointer&lt;Void&gt;.<br></p><p>Some occurrences of Unsafe[Mutable]Pointer&lt;Pointee&gt; in the standard library are replaced with UnsafeBytePointer, either because the code was playing too loosely with strict aliasing rules, or because the code actually wanted to perform pointer arithmetic on byte-addresses.<br></p><p>StringCore.baseAddress changes from OpaquePointer to UnsafeBytePointer because it is computing byte offsets and accessing the memory. OpaquePointer is meant for bridging, but should be truly opaque; that is, nondereferenceable and not involved in address computation.<br></p><p>The StringCore implementation does a considerable amount of casting between different views of the String storage. The current implementation already demonstrates some awareness of strict aliasing rules. The rules are generally followed by ensuring that the StringBuffer only be accessed using the appropriate CodeUnit within Swift code. For interoperability and optimization, String buffers frequently need to be cast to and from CChar. This is valid as long access to the buffer from Swift is guarded by dynamic checks of the encoding type. These unsafe, but dynamically legal conversion points will now be labeled with toPointee.<br></p><p>CoreAudio utilities now use an UnsafeBytePointer.<br></p><p> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#implementation-status&gt;Implementation status<br></p><p>On my unsafeptr_convert branch &lt;https://github.com/atrick/swift/commits/unsafeptr_convert&gt;, I&#39;ve made most of the necessary changes to support the addition of UnsafeBytePointerand the removal of inferred UnsafePointer conversion.<br></p><p>There are a several things going on here in order to make it possible to build the standard library with the changes:<br></p><p>A new UnsafeBytePointer type is defined.<br></p><p>The type system imports void* as UnsafeBytePointer.<br></p><p>The type system handles implicit conversions to UnsafeBytePointer.<br></p><p>UnsafeBytePointer replaces both UnsafePointer&lt;Void&gt; and UnsafeMutablePointer&lt;Void&gt;.<br></p><p>The standard library was relying on inferred UnsafePointer conversion in over 100 places. Most of these conversions now either take an explicit label, such as &#39;toPointee&#39;, &#39;mutating&#39;. Some have been rewritten.<br></p><p>Several places in the standard library that were playing loosely with strict aliasing or doing bytewise pointer arithmetic now use UnsafeBytePointer instead.<br></p><p>Explicit labeled Unsafe[Mutable]Pointer initializers are added.<br></p><p>The inferred Unsafe[Mutable]Pointer conversion is removed.<br></p><p>TODO:<br></p><p>Once this proposal is accepted, and the rules for casting between pointers types have been decided, we need to finish implementing the type system support. The current implementation (intentionally) breaks a few tests in pointer_conversion.swift. We also need to ensure that interoperability requirements are met. Currently, many argument casts to be explicitly labeled. The current implementation also makes it easy for users to hit an &quot;ambiguous use of &#39;init&#39;&quot; error when relying on implicit argument conversion.<br></p><p>Additionally:<br></p><p>A name mangled abbreviation needs to be created for UnsafeBytePointer.<br></p><p>The StringAPI tests should probably be rewritten with UnsafeBytePointer.<br></p><p>The NSStringAPI utilities and tests may need to be ported to UnsafeBytePointer<br></p><p>The CoreAudio utilities and tests may need to be ported to UnsafeBytePointer.<br></p><p> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#alternatives-considered&gt;Alternatives considered<br></p><p> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#existing-workaround&gt;Existing workaround<br></p><p>In some cases, developers can safely reinterpret values to achieve the same effect as type punning:<br></p><p>let ptrI32 = UnsafeMutablePointer&lt;Int32&gt;(allocatingCapacity: 1)<br>ptrI32[0] = Int32()<br>let u = unsafeBitCast(ptrI32[0], to: UInt32.self)<br>Note that all access to the underlying memory is performed with the same element type. This is perfectly legitimate, but simply isn&#39;t a complete solution. It also does not eliminate the inherent danger in declaring a typed pointer and expecting it to point to values of a different type.<br></p><p> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#discarded-alternatives&gt;Discarded alternatives<br></p><p>We considered adding a typePunnedMemory property to the existing Unsafe[Mutabale]Pointer API. This would provide a legal way to access a potentially type punned Unsafe[Mutabale]Pointer. However, it would certainly cause confusion without doing much to reduce likelihood of programmer error. Furthermore, there are no good use cases for such a property evident in the standard library.<br></p><p>The opaque _RawByte struct is a technique that allows for byte-addressable buffers while hiding the dangerous side effects of type punning (a _RawByte could be loaded but it&#39;s value cannot be directly inspected). UnsafePointer&lt;_RawByte&gt; is a clever alternative to UnsafeBytePointer. However, it doesn&#39;t do enough to prevent undefined behavior. The loaded _RawByte would naturally be accessed via unsafeBitCast, which would mislead the author into thinking that they have legally bypassed the type system. In actuality, this API blatantly violates strict aliasing. It theoretically results in undefined behavior as it stands, and may actually exhibit undefined behavior if the user recovers the loaded value.<br></p><p>To solve the safety problem with UnsafePointer&lt;_RawByte&gt;, the compiler could associate special semantics with a UnsafePointer bound to this concrete generic parameter type. Statically enforcing casting rules would be difficult if not impossible without new language features. It would also be impossible to distinguish between typed and untyped pointer APIs. For example, UnsafePointer&lt;T&gt;.load&lt;U&gt; would be a nonsensical vestige.<br></p><p> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#alternate-proposal-for-void-type&gt;Alternate proposal for void* type<br></p><p>Changing the imported type for void* will be somewhat disruptive. Furthermore, this proposal currently drops the distinction between void* and const void*--an obvious loss of API information.<br></p><p>We could continue to import void* as UnsafeMutablePointer&lt;Void&gt; and const void* as UnsafePointer&lt;Void&gt;, which will continue to serve as an &quot;opaque&quot; untyped pointer. Converting to UnsafeBytePointer would be necesarry to perform pointer arithmetic or to conservatively handle possible type punning.<br></p><p>This alternative is much less disruptive, but we are left with two forms of untyped pointer, one of which (UnsafePointer) the type system somewhat conflates with typed pointers.<br></p><p>Given the current restrictions of the language, it&#39;s not clear how to statically enforce the necessary rules for castingUnsafePointer&lt;Void&gt; once general UnsafePointer&lt;T&gt; conversions are disallowed. The following conversions should be inferred, and implied for function arguments (ignoring mutability):<br></p><p>UnsafePointer&lt;T&gt; to UnsafePointer&lt;Void&gt;<br></p><p>UnsafePointer&lt;Void&gt; to UnsafeBytePointer<br></p><p>I did not implement this simpler design because my primary goal was to enforce legal pointer conversion and rid Swift code of undefined behavior. I can&#39;t do that while allowing UnsafePointer conversions.<br></p><p> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#api-improvements&gt;API improvements<br></p><p>As proposed, the initialize API infers the stored value:<br></p><p>func initialize&lt;T&gt;(with newValue: T, count: Int = 1) -&gt; UnsafeBytePointer<br>This is somewhat dangerous because the developer may not realize the size of the object(s) that will be written to memory. This can be easily asserted by checking the return pointer:<br></p><p>let newptr = ptr.initialize(with: 3)<br>assert(newptr - ptr == 8)<br>As an alternative, we could force the user to provide the expected type name in the initialize invocation:<br></p><p>func initialize&lt;T&gt;(_ T.Type, with newValue: T, count: Int = 1)<br>  -&gt; UnsafeBytePointer<br> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#future-improvements&gt;Future improvements<br></p><p>UnsafeBytePointer should eventually support unaligned memory access. I believe that we will eventually have a modifier that allows &quot;packed&quot; struct members. At that time we may also want to add a &quot;packed&quot; flag to UnsafeBytePointer&#39;s load and initialize methods.<br></p><p>When accessing a memory buffer, it is generally convenient to cast to a type with known layout and compute offsets relative to the type&#39;s size. This is how UnsafePointer&lt;Pointee&gt; works. A generic UnsafeTypePunnedPointer&lt;Pointee&gt; could be introduced with the same interface as UnsafePointer&lt;Pointer&gt;, but without the strict aliasing requirements. This seems like an overdesign simply to avoid calling sizeof() in an rare use case, but nothing prevents adding this type later.<br></p><p> &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#unsafebytepointer-example&gt;UnsafeBytePointer example<br></p><p>/// An example of using UnsafeBytePointer to implement manual memory layout.<br></p><p>/// A Buffer for reading and writing basic types at a fixed address.<br>/// Indirection allows the buffer to refer to mutable state elsewhere.<br>struct MessageBuffer {<br>  let ptr: UnsafeBytePointer<br></p><p>  enum IndirectFlag { case Direct, Indirect }<br></p><p>  private func getPointer(atOffset n: Int, _ isIndirect: IndirectFlag)<br>  -&gt; UnsafeBytePointer {<br>    switch isIndirect {<br>    case .Indirect:<br>      return (ptr + n).load(UnsafeBytePointer.self)<br>    case .Direct:<br>      return ptr + n<br>    }<br>  }<br></p><p>  func readUInt32(atOffset n: Int, _ isIndirect: IndirectFlag) -&gt; UInt32 {<br>    return getPointer(atOffset: n, isIndirect).load(UInt32.self)<br>  }<br>  func readFloat32(atOffset n: Int, _ isIndirect: IndirectFlag) -&gt; Float32 {<br>    return getPointer(atOffset: n, isIndirect).load(Float32.self)<br>  }<br></p><p>  func writeUInt32(_ val: UInt32, atOffset n: Int) {<br>    getPointer(atOffset: n, .Direct).initialize(with: val)<br>  }<br>  func writeFloat32(_ val: Float32, atOffset n: Int) {<br>    getPointer(atOffset: n, .Direct).initialize(with: val)<br>  }<br>  func writeIndirect(_ ptr: UnsafeBytePointer, atOffset n: Int) {<br>    getPointer(atOffset: n, .Direct).initialize(with: ptr)<br>  }<br>}<br></p><p>/// Encoded message format.<br>struct MessageFormat : Sequence, IteratorProtocol {<br>  typealias Element = MessageFormat<br></p><p>  private static let maxFormatFields = 32 / 4<br>  static let maxBufferBytes = maxFormatFields * sizeof(UInt)<br></p><p>  var formatCode: UInt32 = 0<br>  var elementCode: UInt32 = 0<br>  var offset: Int = 0<br></p><p>  init(bitPattern: UInt32) {<br>    formatCode = bitPattern<br>  }<br></p><p>  enum Kind {<br>    case None, Reserved, UInt32, Float32, IndirectUInt32, IndirectFloat32<br>  }<br></p><p>  /// The first field&#39;s kind.<br>  var kind : Kind {<br>    get {<br>      switch elementCode {<br>      case 0x0: return Kind.None<br>      case 0x2: return Kind.UInt32<br>      case 0x3: return Kind.Float32<br>      case 0x6: return Kind.IndirectUInt32<br>      case 0x7: return Kind.IndirectFloat32<br>      default:  return Kind.Reserved<br>      }<br>    }<br>  }<br></p><p>  func elementSize() -&gt; Int {<br>    return (elementCode &amp; 0x4) != 0 ? sizeof(UInt) : 4<br>  }<br></p><p>  /// Get the format for the next element.<br>  mutating func next() -&gt; Element? {<br>    if elementCode != 0 {<br>      offset += elementSize()<br>    }<br>    elementCode = formatCode &amp; 0xF<br>    formatCode &gt;&gt;= 4<br>    if kind == .None {<br>      return nil<br>    }<br>    // align to the next element size<br>    let offsetMask = elementSize() - 1<br>    offset = (offset + offsetMask) &amp; ~offsetMask<br>    return self<br>  }<br>}<br></p><p>func createBuffer() -&gt; MessageBuffer {<br>  return MessageBuffer(ptr: UnsafeBytePointer(<br>      allocatingBytes: MessageFormat.maxBufferBytes, alignedTo: sizeof(UInt)))<br>}<br></p><p>func destroy(buffer: MessageBuffer) {<br>  buffer.ptr.deallocateBytes(MessageFormat.maxBufferBytes,<br>    alignedTo: sizeof(UInt))<br>}<br></p><p>var sharedInt: UInt32 = 42<br>var sharedFloat: Float32 = 16.25<br></p><p>func generateMessage(inBuffer mb: MessageBuffer) -&gt; MessageFormat {<br>  let mf = MessageFormat(bitPattern: 0x06727632)<br>  for field in mf {<br>    switch field.kind {<br>    case .UInt32:<br>      mb.writeUInt32(66, atOffset: field.offset)<br>    case .Float32:<br>      mb.writeFloat32(41.625, atOffset: field.offset)<br>    case .IndirectUInt32:<br>      mb.writeIndirect(&amp;sharedInt, atOffset: field.offset)<br>    case .IndirectFloat32:<br>      mb.writeIndirect(&amp;sharedFloat, atOffset: field.offset)<br>    case .None:<br>      fallthrough<br>    case .Reserved:<br>      return MessageFormat(bitPattern: 0)<br>    }<br>  }<br>  return mf<br>}<br></p><p>func handleMessage(buffer mb: MessageBuffer, format: MessageFormat) -&gt; Bool {<br>  for field in format {<br>    switch field.kind {<br>    case .UInt32:<br>      print(mb.readUInt32(atOffset: field.offset, .Direct))<br>    case .Float32:<br>      print(mb.readFloat32(atOffset: field.offset, .Direct))<br>    case .IndirectUInt32:<br>      print(mb.readUInt32(atOffset: field.offset, .Indirect))<br>    case .IndirectFloat32:<br>      print(mb.readFloat32(atOffset: field.offset, .Indirect))<br>    case .None:<br>      fallthrough<br>    case .Reserved:<br>      return false<br>    }<br>  }<br>  return true<br>}<br></p><p>func runProgram() {<br>  let mb = createBuffer()<br>  let mf = generateMessage(inBuffer: mb)<br>  if handleMessage(buffer: mb, format: mf) {<br>    print(&quot;Done&quot;)<br>  }<br>  destroy(buffer: mb)<br>}<br>runProgram()<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160506/f89b98e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May 12, 2016 at 09:00:00am</p></header><div class="content"><p>Hi, Andy. Thanks for working on this! I have a pile of scattered comments which are hopefully helpful.<br></p><p>On the model itself:<br></p><p>- I’m uncomfortable with using the term “undefined behavior” as if it’s universally understood. Up until now we haven&#39;t formally had that notion in Swift, just “type safety” and “memory safety” and “invariant-preserving” and the like. Maybe we need it now, but I think it needs to be explicitly defined. (I’d actually talk to Dave about exactly what terms make the most sense for users.)<br></p><p>- &quot;thin function, C function, and block function types” &lt;-- block functions are not layout-compatible with C functions, and they are layout-compatible with AnyObject. (I mean, they’re both pointers at the moment, but so are non-weak object references.)<br></p><p>- &quot;nonresilient structs” &lt;-- nitpick: the term “nonresilient” is not defined here, and isn’t a formal term in the Library Evolution doc. I guess I would actually prefer “fragile” if you needed a generic term across structs and enums, but either way you should put a small definition somewhere in this doc.<br></p><p>- &quot;homogeneous tuples, fixed-sized array storage, and homogeneous nonresilient structs in which the element type has no spare bits (structs may be bit packed).” &lt;-- I would leave the structs out of this, even if it’s true. Also, Swift doesn’t have fixed-size arrays at the moment, right?<br></p><p>- &quot;In particular, they apply to access that originates from stored property getter and setters, reading from and assigning into inout variables, and reading or assigning subscripts (including the Unsafe[Mutable]Pointer pointee property and subscripts).” I’m unhappy with inout variables being called out specially here. An inout variable should be exactly like a local variable that happens to be stack-allocated, rather than just in registers. Closure captures probably figure in here too.<br></p><p>- &quot;unsafeBitCast is valid for pointer to integer conversions” &lt;-- we have better APIs to do this now (&#39;init(bitPattern:)’ in both directions).<br></p><p>- &quot;It is also used internally to convert between nondereferenceable pointer types, which avoids the need to add builtin conversions for all combinations of pointer types.” &lt;-- I’d be happy to get rid of this and just go through Builtin.RawPointer when necessary.<br></p><p>- On the flip side, I think we do need to preserve the ability to reference-cast in order to send Objective-C messages, at least for now. I don’t know how I want to expose that to users, though. (In general it’s probably worth seeing how unsafeBitCast is used in the wild and what we’d recommend instead.)<br></p><p><br>Some concerns with UnsafeBytePointer:<br></p><p>- I was concerned about having a store() to go with load(). It’s just deinitialize + initialize with a count of 1, but that’s easily the common case when you do need to write to something. That said, I’m not sure which people are more likely to mess up: using initialize and forgetting to deinitialize before, or using store when there wasn’t anything there before.<br></p><p>- I am concerned about eliminating the distinction between mutable and immutable memory. That is, I think we’ll want the Mutable variant to be a separate type.<br></p><p>- Is there a good way to do a mass copy or move from an UnsafeBytePointer?<br></p><p><br>Thoughts on the diff:<br></p><p>- What was the thought behind putting UnsafeBytePointer in PointerTypeKind? OpaquePointer isn’t there, and I’m concerned about places that test if something’s a pointer by checking that the pointee type is non-null (by far the common pattern).<br></p><p>- The PrintAsObjC test can’t possibly pass as is—it’s checking that one pointer is const and the other isn’t. I’m guessing there’s actually more work to do here.<br></p><p><br>I think that’s about it. Sorry for the laundry list, but I feel good about most of them being small issues. The model seems sensible, other than lingering fears about it still being too easy to do the wrong thing. Maybe we need a Pointer Sanitizer for dynamic verification.<br></p><p>Jordan<br></p><p><br>&gt; On May 6, 2016, at 22:28, Andrew Trick via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift development community,<br>&gt; <br>&gt; Swift does a great job of protecting against undefined behavior--as long as you avoid &quot;unsafe&quot; APIs, that is. However, unsafe APIs are important for giving developers control over implementation details and performance. Naturally, the contract between unsafe APIs and the optimizer is crucial. When a developer uses an unsafe API, the rules governing safe, well-defined behavior must be clear. On the opposite end, the optimizer must know which assumptions it can make based on those rules. Simply saying that anything goes because &quot;unsafe&quot; is in the name is not helpful to this effort.<br>&gt; <br>&gt; For a long time, I&#39;ve wanted these rules nailed down. We have more users taking advantage of advanced features, and more optimizations that take advantage of assumptions guided by the type system. This seems like a particularly good time to resolve UnsafePointer semantics, considering the type system and UnsafePointer work that&#39;s been going on recently. Strict aliasing is something I would like addressed. If we do nothing here, then we will end up by default inheriting C/C++ semantics, as with any language that relies on a C/C++ backend. In other words, developers will be forced to write code with technically undefined behavior and rely on the compiler to be smart enough to recognize and recover from common patterns. Or we can take advantage of this opportunity and instead adopt a sound memory model with respect to aliasing.<br>&gt; <br>&gt; This proposal is only an RFC at this point. I&#39;m sending it out now to allow for plenty of time for discussion (or advance warning). Keep in mind that it could change considerably before it goes up for review.<br>&gt; <br>&gt; -Andy<br>&gt; <br>&gt; UnsafeBytePointer API for In-Memory Layout<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md&gt;<br>&gt; Author(s): Andrew Trick &lt;https://github.com/atrick&gt;<br>&gt; Status: Awaiting review &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#rationale&gt;<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#introduction&gt;Introduction<br>&gt; <br>&gt; UnsafePointer and UnsafeMutable refer to a typed region of memory, and the compiler must be able to assume that UnsafePointer element (Pointee) type is consistent with other access to the same memory. See proposed Type Safe Memory Access documentation &lt;https://github.com/atrick/swift/blob/type-safe-mem-docs/docs/TypeSafeMemory.rst&gt;. Consequently, inferred conversion between UnsafePointer element types exposes an easy way to abuse the type system. No alternative currently exists for manual memory layout and direct access to untyped memory, and that leads to an overuse of UnsafePointer. These uses of UnsafePointer, which depend on pointer type conversion, make accidental type punning likely. Type punning via UnsafePointer is semantically undefined behavior and de facto undefined behavior given the optimizer&#39;s long-time treatment of UnsafePointer.<br>&gt; <br>&gt; In this document, all mentions of UnsafePointer also apply to UnsafeMutablePointer.<br>&gt; <br>&gt;  &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#motivation&gt;Motivation<br>&gt; <br>&gt; To avoid accidental type punning, we should prohibit inferred conversion between UnsafePointer&lt;T&gt; and UnsafePointer&lt;U&gt; unless the target of the conversion is an untyped or nondereferenceable pointer (currently represented as UnsafePointer&lt;Void&gt;).<br>&gt; <br>&gt; To support this change we should introduce a new pointer type that does not bind the type of its Pointee. Such a new pointer type would provide an ideal foundation for an API that allows byte-wise pointer arithmetic and a legal, well-defined means to access an untyped region of memory.<br>&gt; <br>&gt; As motivation for such an API, consider that an UnsafePointer&lt;Void&gt; or OpaquePointer may be currently be obtained from an external API. However, the developer may know the memory layout and may want to read or write elements whose types are compatible with that layout. This a reasonable use case, but unless the developer can guarantee that all accesses to the same memory location have the same type, then they cannot use UnsafePointer to access the memory without risking undefined behavior.<br>&gt; <br>&gt; An UnsafeBytePointer example, using a new proposed API is included below.<br>&gt; <br>&gt;  &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; Introduce an UnsafeBytePointer type along with an API for obtaining a UnsafeBytePointer value at a relative byte offset and loading and storing arbitrary types at that location.<br>&gt; <br>&gt; Statically prohibit inferred UnsafePointer conversion while allowing inferred UnsafePointer to UnsafeBytePointerconversion.<br>&gt; <br>&gt; UnsafeBytePointer meets multiple requirements:<br>&gt; <br>&gt; An untyped pointer to memory<br>&gt; Pointer arithmetic within byte-addressable memory<br>&gt; Type-unsafe access to memory (legal type punning)<br>&gt; UnsafeBytePointer will replace UnsafeMutablePointer&lt;Void&gt; as the representation for untyped memory. For API clarify we could consider a typealias for VoidPointer. I don&#39;t think a separate VoidPointer type would be useful--there&#39;s no danger that UnsafeBytePointer will be casually dereferenced, and don&#39;t see the danger in allowing pointer arithmetic since the only reasonable interpretation is that of a byte-addressable memory.<br>&gt; <br>&gt; Providing an API for type-unsafe memory access would not serve a purpose without the ability to compute byte offsets. Of course, we could require users to convert back and forth using bitPatterns, but I think that would be awkward and only obscure the purpose of the UnsafeBytePointer type.<br>&gt; <br>&gt; In this proposal, UnsafeBytePointer does not specify mutability. Adding an UnsafeMutableBytePointer would be straightforward, but adding another pointer type needs strong justification. I expect to get input from the community on this. If we agree that the imported type for const void* should be UnsafeBytePointer, then we probably need UnsafeMutablePointer to handle interoperability.<br>&gt; <br>&gt;  &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; The public API is shown here. For details and comments, see the unsafeptr_convert branch &lt;https://github.com/atrick/swift/commits/unsafeptr_convert&gt;.<br>&gt; <br>&gt; struct UnsafeBytePointer : Hashable, _Pointer {<br>&gt; <br>&gt;   let _rawValue: Builtin.RawPointer<br>&gt; <br>&gt;   var hashValue: Int {...}<br>&gt; <br>&gt;   init&lt;T&gt;(_ : UnsafePointer&lt;T&gt;)<br>&gt;   init&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;)<br>&gt;   init?&lt;T&gt;(_ : UnsafePointer&lt;T&gt;?)<br>&gt;   init?&lt;T&gt;(_ : UnsafeMutablePointer&lt;T&gt;?)<br>&gt; <br>&gt;   init&lt;T&gt;(_ : OpaquePointer&lt;T&gt;)<br>&gt;   init?&lt;T&gt;(_ : OpaquePointer&lt;T&gt;?)<br>&gt; <br>&gt;   init?(bitPattern: Int)<br>&gt;   init?(bitPattern: UInt)<br>&gt; <br>&gt;   func load&lt;T&gt;(_ : T.Type) -&gt; T<br>&gt; <br>&gt;   @warn_unused_result<br>&gt;   init(allocatingBytes size: Int, alignedTo: Int)<br>&gt; <br>&gt;   @warn_unused_result<br>&gt;   init&lt;T&gt;(allocatingCapacity count: Int, of: T.Type)<br>&gt; <br>&gt;   func deallocateBytes(_ size: Int, alignedTo: Int)<br>&gt; <br>&gt;   func deallocateCapacity&lt;T&gt;(_ num: Int, of: T.Type)<br>&gt; <br>&gt;   // Returns a pointer one byte after the initialized memory.<br>&gt;   func initialize&lt;T&gt;(with newValue: T, count: Int = 1) -&gt; UnsafeBytePointer<br>&gt; <br>&gt;   // Returns a pointer one byte after the initialized memory.<br>&gt;   func initialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int) -&gt; UnsafeBytePointer<br>&gt; <br>&gt;   func initializeBackward&lt;T&gt;(from source: UnsafePointer&lt;T&gt;, count: Int)<br>&gt; <br>&gt;   func deinitialize&lt;T&gt;(_ : T.Type, count: Int = 1)<br>&gt; }<br>&gt; <br>&gt; extension OpaquePointer {<br>&gt;   init(_ : UnsafeBytePointer)<br>&gt; }<br>&gt; <br>&gt; extension Int {<br>&gt;   init(bitPattern: UnsafeBytePointer)<br>&gt; }<br>&gt; <br>&gt; extension UInt {<br>&gt;   init(bitPattern: UnsafeBytePointer)<br>&gt; }<br>&gt; <br>&gt; extension UnsafeBytePointer : RandomAccessIndex {<br>&gt;   typealias Distance = Int<br>&gt; <br>&gt;   func successor() -&gt; UnsafeBytePointer<br>&gt;   func predecessor() -&gt; UnsafeBytePointer<br>&gt;   func distance(to : UnsafeBytePointer) -&gt; Int<br>&gt;   func advanced(by : Int) -&gt; UnsafeBytePointer<br>&gt; }<br>&gt; <br>&gt; func == (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Bool<br>&gt; <br>&gt; func &lt; (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Bool<br>&gt; <br>&gt; func + (lhs: UnsafeBytePointer, rhs: Int) -&gt; UnsafeBytePointer<br>&gt; <br>&gt; func + (lhs: Int, rhs: UnsafeBytePointer) -&gt; UnsafeBytePointer<br>&gt; <br>&gt; func - (lhs: UnsafeBytePointer, rhs: Int) -&gt; UnsafeBytePointer<br>&gt; <br>&gt; func - (lhs: UnsafeBytePointer, rhs: UnsafeBytePointer) -&gt; Int<br>&gt; <br>&gt; func += (lhs: inout UnsafeBytePointer, rhs: Int)<br>&gt; <br>&gt; func -= (lhs: inout UnsafeBytePointer, rhs: Int)<br>&gt; Occasionally, we need to convert from a UnsafeBytePointer to an UnsafePointer. This should only be done in very rare circumstances when the author understands the compiler&#39;s strict type rules for UnsafePointer. Although this could be done by casting through an OpaquePointer, an explicit, designated unsafe pointer cast API would makes the risks more obvious and self-documenting. For example:<br>&gt; <br>&gt; extension UnsafePointer {<br>&gt;   init(_ from: UnsafeBytePointer, toPointee: Pointee.type)<br>&gt; }<br>&gt; extension UnsafeMutablePointer {<br>&gt;   init(_ from: UnsafeBytePointer, toPointee: Pointee.type)<br>&gt; }<br>&gt; Similarly, conversion between UnsafePointer types must now be spelled with an explicitly Pointee type:<br>&gt; <br>&gt; extension UnsafePointer {<br>&gt;   init&lt;U&gt;(_ from: UnsafePointer&lt;U&gt;, toPointee: Pointee.Type)<br>&gt;   init&lt;U&gt;(_ from: UnsafeMutablePointer&lt;U&gt;, toPointee: Pointee.Type)<br>&gt; }<br>&gt; extension UnsafeMutablePointer {<br>&gt;   init&lt;U&gt;(_ from: UnsafeMutablePointer&lt;U&gt;, toPointee: Pointee.Type)<br>&gt; }<br>&gt;  &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; The largest impact of this change is that void* and const void* are imported as UnsafeBytePointer. This impacts many public APIs, but with implicit argument conversion should not affect typical uses of those APIs.<br>&gt; <br>&gt; Any Swift projects that rely on type inference to convert between UnsafePointer types will need to take action. The developer needs to determine whether type punning is necessary. If so, they must migrate to the UnsafeBytePointer API. Otherwise, they can work around the new restriction by using a toPointee, or mutating label.<br>&gt; <br>&gt; Disallowing inferred UnsafePointer direct conversion requires some standard library code to use an explicit toPointeelabel for unsafe conversions that may violate strict aliasing.<br>&gt; <br>&gt; All occurrences of Unsafe[Mutable]Pointer&lt;Void&gt; in the standard library are converted to UnsafeBytePointer. e.g. unsafeAddress() now returns UnsafeBytePointer, not UnsafePointer&lt;Void&gt;.<br>&gt; <br>&gt; Some occurrences of Unsafe[Mutable]Pointer&lt;Pointee&gt; in the standard library are replaced with UnsafeBytePointer, either because the code was playing too loosely with strict aliasing rules, or because the code actually wanted to perform pointer arithmetic on byte-addresses.<br>&gt; <br>&gt; StringCore.baseAddress changes from OpaquePointer to UnsafeBytePointer because it is computing byte offsets and accessing the memory. OpaquePointer is meant for bridging, but should be truly opaque; that is, nondereferenceable and not involved in address computation.<br>&gt; <br>&gt; The StringCore implementation does a considerable amount of casting between different views of the String storage. The current implementation already demonstrates some awareness of strict aliasing rules. The rules are generally followed by ensuring that the StringBuffer only be accessed using the appropriate CodeUnit within Swift code. For interoperability and optimization, String buffers frequently need to be cast to and from CChar. This is valid as long access to the buffer from Swift is guarded by dynamic checks of the encoding type. These unsafe, but dynamically legal conversion points will now be labeled with toPointee.<br>&gt; <br>&gt; CoreAudio utilities now use an UnsafeBytePointer.<br>&gt; <br>&gt;  &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#implementation-status&gt;Implementation status<br>&gt; <br>&gt; On my unsafeptr_convert branch &lt;https://github.com/atrick/swift/commits/unsafeptr_convert&gt;, I&#39;ve made most of the necessary changes to support the addition of UnsafeBytePointerand the removal of inferred UnsafePointer conversion.<br>&gt; <br>&gt; There are a several things going on here in order to make it possible to build the standard library with the changes:<br>&gt; <br>&gt; A new UnsafeBytePointer type is defined.<br>&gt; <br>&gt; The type system imports void* as UnsafeBytePointer.<br>&gt; <br>&gt; The type system handles implicit conversions to UnsafeBytePointer.<br>&gt; <br>&gt; UnsafeBytePointer replaces both UnsafePointer&lt;Void&gt; and UnsafeMutablePointer&lt;Void&gt;.<br>&gt; <br>&gt; The standard library was relying on inferred UnsafePointer conversion in over 100 places. Most of these conversions now either take an explicit label, such as &#39;toPointee&#39;, &#39;mutating&#39;. Some have been rewritten.<br>&gt; <br>&gt; Several places in the standard library that were playing loosely with strict aliasing or doing bytewise pointer arithmetic now use UnsafeBytePointer instead.<br>&gt; <br>&gt; Explicit labeled Unsafe[Mutable]Pointer initializers are added.<br>&gt; <br>&gt; The inferred Unsafe[Mutable]Pointer conversion is removed.<br>&gt; <br>&gt; TODO:<br>&gt; <br>&gt; Once this proposal is accepted, and the rules for casting between pointers types have been decided, we need to finish implementing the type system support. The current implementation (intentionally) breaks a few tests in pointer_conversion.swift. We also need to ensure that interoperability requirements are met. Currently, many argument casts to be explicitly labeled. The current implementation also makes it easy for users to hit an &quot;ambiguous use of &#39;init&#39;&quot; error when relying on implicit argument conversion.<br>&gt; <br>&gt; Additionally:<br>&gt; <br>&gt; A name mangled abbreviation needs to be created for UnsafeBytePointer.<br>&gt; <br>&gt; The StringAPI tests should probably be rewritten with UnsafeBytePointer.<br>&gt; <br>&gt; The NSStringAPI utilities and tests may need to be ported to UnsafeBytePointer<br>&gt; <br>&gt; The CoreAudio utilities and tests may need to be ported to UnsafeBytePointer.<br>&gt; <br>&gt;  &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt;  &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#existing-workaround&gt;Existing workaround<br>&gt; <br>&gt; In some cases, developers can safely reinterpret values to achieve the same effect as type punning:<br>&gt; <br>&gt; let ptrI32 = UnsafeMutablePointer&lt;Int32&gt;(allocatingCapacity: 1)<br>&gt; ptrI32[0] = Int32()<br>&gt; let u = unsafeBitCast(ptrI32[0], to: UInt32.self)<br>&gt; Note that all access to the underlying memory is performed with the same element type. This is perfectly legitimate, but simply isn&#39;t a complete solution. It also does not eliminate the inherent danger in declaring a typed pointer and expecting it to point to values of a different type.<br>&gt; <br>&gt;  &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#discarded-alternatives&gt;Discarded alternatives<br>&gt; <br>&gt; We considered adding a typePunnedMemory property to the existing Unsafe[Mutabale]Pointer API. This would provide a legal way to access a potentially type punned Unsafe[Mutabale]Pointer. However, it would certainly cause confusion without doing much to reduce likelihood of programmer error. Furthermore, there are no good use cases for such a property evident in the standard library.<br>&gt; <br>&gt; The opaque _RawByte struct is a technique that allows for byte-addressable buffers while hiding the dangerous side effects of type punning (a _RawByte could be loaded but it&#39;s value cannot be directly inspected). UnsafePointer&lt;_RawByte&gt; is a clever alternative to UnsafeBytePointer. However, it doesn&#39;t do enough to prevent undefined behavior. The loaded _RawByte would naturally be accessed via unsafeBitCast, which would mislead the author into thinking that they have legally bypassed the type system. In actuality, this API blatantly violates strict aliasing. It theoretically results in undefined behavior as it stands, and may actually exhibit undefined behavior if the user recovers the loaded value.<br>&gt; <br>&gt; To solve the safety problem with UnsafePointer&lt;_RawByte&gt;, the compiler could associate special semantics with a UnsafePointer bound to this concrete generic parameter type. Statically enforcing casting rules would be difficult if not impossible without new language features. It would also be impossible to distinguish between typed and untyped pointer APIs. For example, UnsafePointer&lt;T&gt;.load&lt;U&gt; would be a nonsensical vestige.<br>&gt; <br>&gt;  &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#alternate-proposal-for-void-type&gt;Alternate proposal for void* type<br>&gt; <br>&gt; Changing the imported type for void* will be somewhat disruptive. Furthermore, this proposal currently drops the distinction between void* and const void*--an obvious loss of API information.<br>&gt; <br>&gt; We could continue to import void* as UnsafeMutablePointer&lt;Void&gt; and const void* as UnsafePointer&lt;Void&gt;, which will continue to serve as an &quot;opaque&quot; untyped pointer. Converting to UnsafeBytePointer would be necesarry to perform pointer arithmetic or to conservatively handle possible type punning.<br>&gt; <br>&gt; This alternative is much less disruptive, but we are left with two forms of untyped pointer, one of which (UnsafePointer) the type system somewhat conflates with typed pointers.<br>&gt; <br>&gt; Given the current restrictions of the language, it&#39;s not clear how to statically enforce the necessary rules for castingUnsafePointer&lt;Void&gt; once general UnsafePointer&lt;T&gt; conversions are disallowed. The following conversions should be inferred, and implied for function arguments (ignoring mutability):<br>&gt; <br>&gt; UnsafePointer&lt;T&gt; to UnsafePointer&lt;Void&gt;<br>&gt; <br>&gt; UnsafePointer&lt;Void&gt; to UnsafeBytePointer<br>&gt; <br>&gt; I did not implement this simpler design because my primary goal was to enforce legal pointer conversion and rid Swift code of undefined behavior. I can&#39;t do that while allowing UnsafePointer conversions.<br>&gt; <br>&gt;  &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#api-improvements&gt;API improvements<br>&gt; <br>&gt; As proposed, the initialize API infers the stored value:<br>&gt; <br>&gt; func initialize&lt;T&gt;(with newValue: T, count: Int = 1) -&gt; UnsafeBytePointer<br>&gt; This is somewhat dangerous because the developer may not realize the size of the object(s) that will be written to memory. This can be easily asserted by checking the return pointer:<br>&gt; <br>&gt; let newptr = ptr.initialize(with: 3)<br>&gt; assert(newptr - ptr == 8)<br>&gt; As an alternative, we could force the user to provide the expected type name in the initialize invocation:<br>&gt; <br>&gt; func initialize&lt;T&gt;(_ T.Type, with newValue: T, count: Int = 1)<br>&gt;   -&gt; UnsafeBytePointer<br>&gt;  &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#future-improvements&gt;Future improvements<br>&gt; <br>&gt; UnsafeBytePointer should eventually support unaligned memory access. I believe that we will eventually have a modifier that allows &quot;packed&quot; struct members. At that time we may also want to add a &quot;packed&quot; flag to UnsafeBytePointer&#39;s load and initialize methods.<br>&gt; <br>&gt; When accessing a memory buffer, it is generally convenient to cast to a type with known layout and compute offsets relative to the type&#39;s size. This is how UnsafePointer&lt;Pointee&gt; works. A generic UnsafeTypePunnedPointer&lt;Pointee&gt; could be introduced with the same interface as UnsafePointer&lt;Pointer&gt;, but without the strict aliasing requirements. This seems like an overdesign simply to avoid calling sizeof() in an rare use case, but nothing prevents adding this type later.<br>&gt; <br>&gt;  &lt;https://github.com/atrick/swift-evolution/blob/voidpointer/proposals/XXXX-unsafebytepointer.md#unsafebytepointer-example&gt;UnsafeBytePointer example<br>&gt; <br>&gt; /// An example of using UnsafeBytePointer to implement manual memory layout.<br>&gt; <br>&gt; /// A Buffer for reading and writing basic types at a fixed address.<br>&gt; /// Indirection allows the buffer to refer to mutable state elsewhere.<br>&gt; struct MessageBuffer {<br>&gt;   let ptr: UnsafeBytePointer<br>&gt; <br>&gt;   enum IndirectFlag { case Direct, Indirect }<br>&gt; <br>&gt;   private func getPointer(atOffset n: Int, _ isIndirect: IndirectFlag)<br>&gt;   -&gt; UnsafeBytePointer {<br>&gt;     switch isIndirect {<br>&gt;     case .Indirect:<br>&gt;       return (ptr + n).load(UnsafeBytePointer.self)<br>&gt;     case .Direct:<br>&gt;       return ptr + n<br>&gt;     }<br>&gt;   }<br>&gt; <br>&gt;   func readUInt32(atOffset n: Int, _ isIndirect: IndirectFlag) -&gt; UInt32 {<br>&gt;     return getPointer(atOffset: n, isIndirect).load(UInt32.self)<br>&gt;   }<br>&gt;   func readFloat32(atOffset n: Int, _ isIndirect: IndirectFlag) -&gt; Float32 {<br>&gt;     return getPointer(atOffset: n, isIndirect).load(Float32.self)<br>&gt;   }<br>&gt; <br>&gt;   func writeUInt32(_ val: UInt32, atOffset n: Int) {<br>&gt;     getPointer(atOffset: n, .Direct).initialize(with: val)<br>&gt;   }<br>&gt;   func writeFloat32(_ val: Float32, atOffset n: Int) {<br>&gt;     getPointer(atOffset: n, .Direct).initialize(with: val)<br>&gt;   }<br>&gt;   func writeIndirect(_ ptr: UnsafeBytePointer, atOffset n: Int) {<br>&gt;     getPointer(atOffset: n, .Direct).initialize(with: ptr)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; /// Encoded message format.<br>&gt; struct MessageFormat : Sequence, IteratorProtocol {<br>&gt;   typealias Element = MessageFormat<br>&gt; <br>&gt;   private static let maxFormatFields = 32 / 4<br>&gt;   static let maxBufferBytes = maxFormatFields * sizeof(UInt)<br>&gt; <br>&gt;   var formatCode: UInt32 = 0<br>&gt;   var elementCode: UInt32 = 0<br>&gt;   var offset: Int = 0<br>&gt; <br>&gt;   init(bitPattern: UInt32) {<br>&gt;     formatCode = bitPattern<br>&gt;   }<br>&gt; <br>&gt;   enum Kind {<br>&gt;     case None, Reserved, UInt32, Float32, IndirectUInt32, IndirectFloat32<br>&gt;   }<br>&gt; <br>&gt;   /// The first field&#39;s kind.<br>&gt;   var kind : Kind {<br>&gt;     get {<br>&gt;       switch elementCode {<br>&gt;       case 0x0: return Kind.None<br>&gt;       case 0x2: return Kind.UInt32<br>&gt;       case 0x3: return Kind.Float32<br>&gt;       case 0x6: return Kind.IndirectUInt32<br>&gt;       case 0x7: return Kind.IndirectFloat32<br>&gt;       default:  return Kind.Reserved<br>&gt;       }<br>&gt;     }<br>&gt;   }<br>&gt; <br>&gt;   func elementSize() -&gt; Int {<br>&gt;     return (elementCode &amp; 0x4) != 0 ? sizeof(UInt) : 4<br>&gt;   }<br>&gt; <br>&gt;   /// Get the format for the next element.<br>&gt;   mutating func next() -&gt; Element? {<br>&gt;     if elementCode != 0 {<br>&gt;       offset += elementSize()<br>&gt;     }<br>&gt;     elementCode = formatCode &amp; 0xF<br>&gt;     formatCode &gt;&gt;= 4<br>&gt;     if kind == .None {<br>&gt;       return nil<br>&gt;     }<br>&gt;     // align to the next element size<br>&gt;     let offsetMask = elementSize() - 1<br>&gt;     offset = (offset + offsetMask) &amp; ~offsetMask<br>&gt;     return self<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; func createBuffer() -&gt; MessageBuffer {<br>&gt;   return MessageBuffer(ptr: UnsafeBytePointer(<br>&gt;       allocatingBytes: MessageFormat.maxBufferBytes, alignedTo: sizeof(UInt)))<br>&gt; }<br>&gt; <br>&gt; func destroy(buffer: MessageBuffer) {<br>&gt;   buffer.ptr.deallocateBytes(MessageFormat.maxBufferBytes,<br>&gt;     alignedTo: sizeof(UInt))<br>&gt; }<br>&gt; <br>&gt; var sharedInt: UInt32 = 42<br>&gt; var sharedFloat: Float32 = 16.25<br>&gt; <br>&gt; func generateMessage(inBuffer mb: MessageBuffer) -&gt; MessageFormat {<br>&gt;   let mf = MessageFormat(bitPattern: 0x06727632)<br>&gt;   for field in mf {<br>&gt;     switch field.kind {<br>&gt;     case .UInt32:<br>&gt;       mb.writeUInt32(66, atOffset: field.offset)<br>&gt;     case .Float32:<br>&gt;       mb.writeFloat32(41.625, atOffset: field.offset)<br>&gt;     case .IndirectUInt32:<br>&gt;       mb.writeIndirect(&amp;sharedInt, atOffset: field.offset)<br>&gt;     case .IndirectFloat32:<br>&gt;       mb.writeIndirect(&amp;sharedFloat, atOffset: field.offset)<br>&gt;     case .None:<br>&gt;       fallthrough<br>&gt;     case .Reserved:<br>&gt;       return MessageFormat(bitPattern: 0)<br>&gt;     }<br>&gt;   }<br>&gt;   return mf<br>&gt; }<br>&gt; <br>&gt; func handleMessage(buffer mb: MessageBuffer, format: MessageFormat) -&gt; Bool {<br>&gt;   for field in format {<br>&gt;     switch field.kind {<br>&gt;     case .UInt32:<br>&gt;       print(mb.readUInt32(atOffset: field.offset, .Direct))<br>&gt;     case .Float32:<br>&gt;       print(mb.readFloat32(atOffset: field.offset, .Direct))<br>&gt;     case .IndirectUInt32:<br>&gt;       print(mb.readUInt32(atOffset: field.offset, .Indirect))<br>&gt;     case .IndirectFloat32:<br>&gt;       print(mb.readFloat32(atOffset: field.offset, .Indirect))<br>&gt;     case .None:<br>&gt;       fallthrough<br>&gt;     case .Reserved:<br>&gt;       return false<br>&gt;     }<br>&gt;   }<br>&gt;   return true<br>&gt; }<br>&gt; <br>&gt; func runProgram() {<br>&gt;   let mb = createBuffer()<br>&gt;   let mf = generateMessage(inBuffer: mb)<br>&gt;   if handleMessage(buffer: mb, format: mf) {<br>&gt;     print(&quot;Done&quot;)<br>&gt;   }<br>&gt;   destroy(buffer: mb)<br>&gt; }<br>&gt; runProgram()<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160512/9dafd3f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 12, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 12, 2016, at 9:27 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; - I’m uncomfortable with using the term “undefined behavior” as if it’s universally understood. Up until now we haven&#39;t formally had that notion in Swift, just “type safety” and “memory safety” and “invariant-preserving” and the like. Maybe we need it now, but I think it needs to be explicitly defined. (I’d actually talk to Dave about exactly what terms make the most sense for users.)<br></p><p>We do have undefined behavior, and use that term in the standard library docs where appropriate:<br></p><p>stdlib/public/core/Optional.swift-  /// `!` (forced unwrap) operator. However, in optimized builds (`-O`), no<br>stdlib/public/core/Optional.swift-  /// check is performed to ensure that the current instance actually has a<br>stdlib/public/core/Optional.swift-  /// value. Accessing this property in the case of a `nil` value is a serious<br>stdlib/public/core/Optional.swift:  /// programming error and could lead to undefined behavior or a runtime<br>stdlib/public/core/Optional.swift-  /// error.<br>stdlib/public/core/Optional.swift-  ///<br>stdlib/public/core/Optional.swift-  /// In debug builds (`-Onone`), the `unsafelyUnwrapped` property has the same<br>--<br>stdlib/public/core/StringBridge.swift-  /// The caller of this function guarantees that the closure &#39;body&#39; does not<br>stdlib/public/core/StringBridge.swift-  /// escape the object referenced by the opaque pointer passed to it or<br>stdlib/public/core/StringBridge.swift-  /// anything transitively reachable form this object. Doing so<br>stdlib/public/core/StringBridge.swift:  /// will result in undefined behavior.<br>stdlib/public/core/StringBridge.swift-  @_semantics(&quot;self_no_escaping_closure&quot;)<br>stdlib/public/core/StringBridge.swift-  func _unsafeWithNotEscapedSelfPointer&lt;Result&gt;(<br>stdlib/public/core/StringBridge.swift-    _ body: @noescape (OpaquePointer) throws -&gt; Result<br>--<br>stdlib/public/core/Unmanaged.swift-  /// reference&#39;s lifetime fixed for the duration of the<br>stdlib/public/core/Unmanaged.swift-  /// &#39;_withUnsafeGuaranteedRef&#39; call.<br>stdlib/public/core/Unmanaged.swift-  ///<br>stdlib/public/core/Unmanaged.swift:  /// Violation of this will incur undefined behavior.<br>stdlib/public/core/Unmanaged.swift-  ///<br>stdlib/public/core/Unmanaged.swift-  /// A lifetime of a reference &#39;the instance&#39; is fixed over a point in the<br>stdlib/public/core/Unmanaged.swift-  /// programm if:<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160512/ab890f0b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May 12, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 12, 2016, at 10:44, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 12, 2016, at 9:27 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; - I’m uncomfortable with using the term “undefined behavior” as if it’s universally understood. Up until now we haven&#39;t formally had that notion in Swift, just “type safety” and “memory safety” and “invariant-preserving” and the like. Maybe we need it now, but I think it needs to be explicitly defined. (I’d actually talk to Dave about exactly what terms make the most sense for users.)<br>&gt; <br>&gt; We do have undefined behavior, and use that term in the standard library docs where appropriate:<br>&gt; <br>&gt; stdlib/public/core/Optional.swift-  /// `!` (forced unwrap) operator. However, in optimized builds (`-O`), no<br>&gt; stdlib/public/core/Optional.swift-  /// check is performed to ensure that the current instance actually has a<br>&gt; stdlib/public/core/Optional.swift-  /// value. Accessing this property in the case of a `nil` value is a serious<br>&gt; stdlib/public/core/Optional.swift:  /// programming error and could lead to undefined behavior or a runtime<br>&gt; stdlib/public/core/Optional.swift-  /// error.<br>&gt; stdlib/public/core/Optional.swift-  ///<br>&gt; stdlib/public/core/Optional.swift-  /// In debug builds (`-Onone`), the `unsafelyUnwrapped` property has the same<br>&gt; --<br>&gt; stdlib/public/core/StringBridge.swift-  /// The caller of this function guarantees that the closure &#39;body&#39; does not<br>&gt; stdlib/public/core/StringBridge.swift-  /// escape the object referenced by the opaque pointer passed to it or<br>&gt; stdlib/public/core/StringBridge.swift-  /// anything transitively reachable form this object. Doing so<br>&gt; stdlib/public/core/StringBridge.swift:  /// will result in undefined behavior.<br>&gt; stdlib/public/core/StringBridge.swift-  @_semantics(&quot;self_no_escaping_closure&quot;)<br>&gt; stdlib/public/core/StringBridge.swift-  func _unsafeWithNotEscapedSelfPointer&lt;Result&gt;(<br>&gt; stdlib/public/core/StringBridge.swift-    _ body: @noescape (OpaquePointer) throws -&gt; Result<br>&gt; --<br>&gt; stdlib/public/core/Unmanaged.swift-  /// reference&#39;s lifetime fixed for the duration of the<br>&gt; stdlib/public/core/Unmanaged.swift-  /// &#39;_withUnsafeGuaranteedRef&#39; call.<br>&gt; stdlib/public/core/Unmanaged.swift-  ///<br>&gt; stdlib/public/core/Unmanaged.swift:  /// Violation of this will incur undefined behavior.<br>&gt; stdlib/public/core/Unmanaged.swift-  ///<br>&gt; stdlib/public/core/Unmanaged.swift-  /// A lifetime of a reference &#39;the instance&#39; is fixed over a point in the<br>&gt; stdlib/public/core/Unmanaged.swift-  /// programm if:<br></p><p>Those latter two are in stdlib-internal declarations. I think I have the same objection with using the term for &#39;unsafelyUnwrapped&#39;.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160512/c7058eb5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>May 12, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 12, 2016, at 10:45 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; On May 12, 2016, at 10:44, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 12, 2016, at 9:27 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - I’m uncomfortable with using the term “undefined behavior” as if it’s universally understood. Up until now we haven&#39;t formally had that notion in Swift, just “type safety” and “memory safety” and “invariant-preserving” and the like. Maybe we need it now, but I think it needs to be explicitly defined. (I’d actually talk to Dave about exactly what terms make the most sense for users.)<br>&gt;&gt; <br>&gt;&gt; We do have undefined behavior, and use that term in the standard library docs where appropriate:<br>&gt;&gt; <br>&gt;&gt; stdlib/public/core/Optional.swift-  /// `!` (forced unwrap) operator. However, in optimized builds (`-O`), no<br>&gt;&gt; stdlib/public/core/Optional.swift-  /// check is performed to ensure that the current instance actually has a<br>&gt;&gt; stdlib/public/core/Optional.swift-  /// value. Accessing this property in the case of a `nil` value is a serious<br>&gt;&gt; stdlib/public/core/Optional.swift:  /// programming error and could lead to undefined behavior or a runtime<br>&gt;&gt; stdlib/public/core/Optional.swift-  /// error.<br>&gt;&gt; stdlib/public/core/Optional.swift-  ///<br>&gt;&gt; stdlib/public/core/Optional.swift-  /// In debug builds (`-Onone`), the `unsafelyUnwrapped` property has the same<br>&gt;&gt; --<br>&gt;&gt; stdlib/public/core/StringBridge.swift-  /// The caller of this function guarantees that the closure &#39;body&#39; does not<br>&gt;&gt; stdlib/public/core/StringBridge.swift-  /// escape the object referenced by the opaque pointer passed to it or<br>&gt;&gt; stdlib/public/core/StringBridge.swift-  /// anything transitively reachable form this object. Doing so<br>&gt;&gt; stdlib/public/core/StringBridge.swift:  /// will result in undefined behavior.<br>&gt;&gt; stdlib/public/core/StringBridge.swift-  @_semantics(&quot;self_no_escaping_closure&quot;)<br>&gt;&gt; stdlib/public/core/StringBridge.swift-  func _unsafeWithNotEscapedSelfPointer&lt;Result&gt;(<br>&gt;&gt; stdlib/public/core/StringBridge.swift-    _ body: @noescape (OpaquePointer) throws -&gt; Result<br>&gt;&gt; --<br>&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// reference&#39;s lifetime fixed for the duration of the<br>&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// &#39;_withUnsafeGuaranteedRef&#39; call.<br>&gt;&gt; stdlib/public/core/Unmanaged.swift-  ///<br>&gt;&gt; stdlib/public/core/Unmanaged.swift:  /// Violation of this will incur undefined behavior.<br>&gt;&gt; stdlib/public/core/Unmanaged.swift-  ///<br>&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// A lifetime of a reference &#39;the instance&#39; is fixed over a point in the<br>&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// programm if:<br>&gt; <br>&gt; Those latter two are in stdlib-internal declarations. I think I have the same objection with using the term for &#39;unsafelyUnwrapped&#39;.<br></p><p>Well, we can say &quot;A program has undefined behavior if it does X or Y&quot;, or we can say &quot;A program which does X or Y lacks type safety&quot;.  In all cases we are referring to a concept defined elsewhere.  If we say &quot;undefined behavior&quot;, we are using an easily-googled term whose popular discussions will quickly inform the reader of the consequences of the violation.  If we say &quot;type safety&quot;, we are using a term with that&#39;s popularly used in very vague, hand-wavey ways and whose consequences aren&#39;t usually discussed outside of formal contexts.  If we say &quot;memory safety&quot;, we&#39;re using a term that doesn&#39;t even have that precedent.  So we can use the latter two terms if we want, but that just means we need to have a standard place where we define them and describe the consequences of violating them, probably with at least a footnote saying &quot;this is analogous to the undefined behavior rules of C and C++&quot;.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160512/0fb40864/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>May 12, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 12, 2016, at 11:21 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Well, we can say &quot;A program has undefined behavior if it does X or Y&quot;, or we can say &quot;A program which does X or Y lacks type safety&quot;.  In all cases we are referring to a concept defined elsewhere.  If we say &quot;undefined behavior&quot;, we are using an easily-googled term whose popular discussions will quickly inform the reader of the consequences of the violation.  If we say &quot;type safety&quot;, we are using a term with that&#39;s popularly used in very vague, hand-wavey ways and whose consequences aren&#39;t usually discussed outside of formal contexts.  If we say &quot;memory safety&quot;, we&#39;re using a term that doesn&#39;t even have that precedent.  So we can use the latter two terms if we want, but that just means we need to have a standard place where we define them and describe the consequences of violating them, probably with at least a footnote saying &quot;this is analogous to the undefined behavior rules of C and C++&quot;.<br>&gt; <br>&gt; John.<br>&gt; <br></p><p>IMHO “lacks type safety” implies you might get nonsense values but that’s it. I assume that’s the average lay-programmer’s interpretation of the concept too.<br></p><p>I would wager that the vast majority of developers don’t understand undefined behavior or don’t fully understand its consequences. The whole “the program is free to format your hard drive or print SAUSAGE, beep, and exit” discussion almost never fails to surprise anyone I’ve had it with. Doesn’t the C standard still say that the entire program itself is undefined, not just up until the point of executing undefined behavior? I bet if you took a poll you’d be lucky to get 5% of responders who knew that.<br></p><p>IMHO the standard library docs around Unmanaged, UnsafePointer, and OpaquePointer would benefit greatly with much more in-depth explanations of the concepts and consequences of failing to adhere to the rules. In theory developers should read the docs, check google, etc. In reality a huge number of them will possibly bother to check the headers or run with the QuickHelp pane open and that’s the extent of the exposure they’ll have. One could say they shouldn’t be messing with such unsafe features if that’s the case but that won’t stop someone from writing the next Heartbleed by abusing UnsafeMutablePointer (or perhaps less dramatically just create exploitable security holes in a framework used by a bunch of apps).<br></p><p><br>Again just my opinion but I’d love to see Swift set a standard of over-explaining anytime potentially unsafe operations are involved. I think it would promote a culture of careful consideration around the use of unsafe operations.<br></p><p>Russ<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160512/66674867/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 12, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 12, 2016, at 11:21 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On May 12, 2016, at 10:45 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; On May 12, 2016, at 10:44, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 12, 2016, at 9:27 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - I’m uncomfortable with using the term “undefined behavior” as if it’s universally understood. Up until now we haven&#39;t formally had that notion in Swift, just “type safety” and “memory safety” and “invariant-preserving” and the like. Maybe we need it now, but I think it needs to be explicitly defined. (I’d actually talk to Dave about exactly what terms make the most sense for users.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We do have undefined behavior, and use that term in the standard library docs where appropriate:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// `!` (forced unwrap) operator. However, in optimized builds (`-O`), no<br>&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// check is performed to ensure that the current instance actually has a<br>&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// value. Accessing this property in the case of a `nil` value is a serious<br>&gt;&gt;&gt; stdlib/public/core/Optional.swift:  /// programming error and could lead to undefined behavior or a runtime<br>&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// error.<br>&gt;&gt;&gt; stdlib/public/core/Optional.swift-  ///<br>&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// In debug builds (`-Onone`), the `unsafelyUnwrapped` property has the same<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  /// The caller of this function guarantees that the closure &#39;body&#39; does not<br>&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  /// escape the object referenced by the opaque pointer passed to it or<br>&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  /// anything transitively reachable form this object. Doing so<br>&gt;&gt;&gt; stdlib/public/core/StringBridge.swift:  /// will result in undefined behavior.<br>&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  @_semantics(&quot;self_no_escaping_closure&quot;)<br>&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  func _unsafeWithNotEscapedSelfPointer&lt;Result&gt;(<br>&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-    _ body: @noescape (OpaquePointer) throws -&gt; Result<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// reference&#39;s lifetime fixed for the duration of the<br>&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// &#39;_withUnsafeGuaranteedRef&#39; call.<br>&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  ///<br>&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift:  /// Violation of this will incur undefined behavior.<br>&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  ///<br>&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// A lifetime of a reference &#39;the instance&#39; is fixed over a point in the<br>&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// programm if:<br>&gt;&gt; <br>&gt;&gt; Those latter two are in stdlib-internal declarations. I think I have the same objection with using the term for &#39;unsafelyUnwrapped&#39;.<br>&gt; <br>&gt; Well, we can say &quot;A program has undefined behavior if it does X or Y&quot;, or we can say &quot;A program which does X or Y lacks type safety&quot;.  In all cases we are referring to a concept defined elsewhere.  If we say &quot;undefined behavior&quot;, we are using an easily-googled term whose popular discussions will quickly inform the reader of the consequences of the violation.  If we say &quot;type safety&quot;, we are using a term with that&#39;s popularly used in very vague, hand-wavey ways and whose consequences aren&#39;t usually discussed outside of formal contexts.  If we say &quot;memory safety&quot;, we&#39;re using a term that doesn&#39;t even have that precedent.  So we can use the latter two terms if we want, but that just means we need to have a standard place where we define them and describe the consequences of violating them, probably with at least a footnote saying &quot;this is analogous to the undefined behavior rules of C and C++&quot;.<br></p><p>In other places where the standard library intentionally has undefined behavior, it looks like we use the term &quot;serious programming error&quot;, for instance in the the doc comment for `assert`:<br></p><p>/// * In -Ounchecked builds, `condition` is not evaluated, but the<br>///   optimizer may assume that it *would* evaluate to `true`. Failure<br>///   to satisfy that assumption in -Ounchecked builds is a serious<br>///   programming error.<br></p><p>which feels a bit colloquial to me, and doesn&#39;t provide much insight into the full consequences of UB. I think we&#39;re better off using an established term.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>May 12, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 12, 2016, at 3:21 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On May 12, 2016, at 11:21 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 12, 2016, at 10:45 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On May 12, 2016, at 10:44, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 12, 2016, at 9:27 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - I’m uncomfortable with using the term “undefined behavior” as if it’s universally understood. Up until now we haven&#39;t formally had that notion in Swift, just “type safety” and “memory safety” and “invariant-preserving” and the like. Maybe we need it now, but I think it needs to be explicitly defined. (I’d actually talk to Dave about exactly what terms make the most sense for users.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We do have undefined behavior, and use that term in the standard library docs where appropriate:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// `!` (forced unwrap) operator. However, in optimized builds (`-O`), no<br>&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// check is performed to ensure that the current instance actually has a<br>&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// value. Accessing this property in the case of a `nil` value is a serious<br>&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift:  /// programming error and could lead to undefined behavior or a runtime<br>&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// error.<br>&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  ///<br>&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// In debug builds (`-Onone`), the `unsafelyUnwrapped` property has the same<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  /// The caller of this function guarantees that the closure &#39;body&#39; does not<br>&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  /// escape the object referenced by the opaque pointer passed to it or<br>&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  /// anything transitively reachable form this object. Doing so<br>&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift:  /// will result in undefined behavior.<br>&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  @_semantics(&quot;self_no_escaping_closure&quot;)<br>&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  func _unsafeWithNotEscapedSelfPointer&lt;Result&gt;(<br>&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-    _ body: @noescape (OpaquePointer) throws -&gt; Result<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// reference&#39;s lifetime fixed for the duration of the<br>&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// &#39;_withUnsafeGuaranteedRef&#39; call.<br>&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  ///<br>&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift:  /// Violation of this will incur undefined behavior.<br>&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  ///<br>&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// A lifetime of a reference &#39;the instance&#39; is fixed over a point in the<br>&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// programm if:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Those latter two are in stdlib-internal declarations. I think I have the same objection with using the term for &#39;unsafelyUnwrapped&#39;.<br>&gt;&gt; <br>&gt;&gt; Well, we can say &quot;A program has undefined behavior if it does X or Y&quot;, or we can say &quot;A program which does X or Y lacks type safety&quot;.  In all cases we are referring to a concept defined elsewhere.  If we say &quot;undefined behavior&quot;, we are using an easily-googled term whose popular discussions will quickly inform the reader of the consequences of the violation.  If we say &quot;type safety&quot;, we are using a term with that&#39;s popularly used in very vague, hand-wavey ways and whose consequences aren&#39;t usually discussed outside of formal contexts.  If we say &quot;memory safety&quot;, we&#39;re using a term that doesn&#39;t even have that precedent.  So we can use the latter two terms if we want, but that just means we need to have a standard place where we define them and describe the consequences of violating them, probably with at least a footnote saying &quot;this is analogous to the undefined behavior rules of C and C++&quot;.<br>&gt; <br>&gt; In other places where the standard library intentionally has undefined behavior, it looks like we use the term &quot;serious programming error&quot;, for instance in the the doc comment for `assert`:<br>&gt; <br>&gt; /// * In -Ounchecked builds, `condition` is not evaluated, but the<br>&gt; ///   optimizer may assume that it *would* evaluate to `true`. Failure<br>&gt; ///   to satisfy that assumption in -Ounchecked builds is a serious<br>&gt; ///   programming error.<br>&gt; <br>&gt; which feels a bit colloquial to me, and doesn&#39;t provide much insight into the full consequences of UB. I think we&#39;re better off using an established term.<br></p><p>Agreed.<br></p><p>Do we have a good place to document common terms?  Preferably one that isn&#39;t a book?<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May 13, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 12, 2016, at 4:03 PM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On May 12, 2016, at 3:21 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; On May 12, 2016, at 11:21 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 12, 2016, at 10:45 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On May 12, 2016, at 10:44, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 12, 2016, at 9:27 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - I’m uncomfortable with using the term “undefined behavior” as if it’s universally understood. Up until now we haven&#39;t formally had that notion in Swift, just “type safety” and “memory safety” and “invariant-preserving” and the like. Maybe we need it now, but I think it needs to be explicitly defined. (I’d actually talk to Dave about exactly what terms make the most sense for users.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We do have undefined behavior, and use that term in the standard library docs where appropriate:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// `!` (forced unwrap) operator. However, in optimized builds (`-O`), no<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// check is performed to ensure that the current instance actually has a<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// value. Accessing this property in the case of a `nil` value is a serious<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift:  /// programming error and could lead to undefined behavior or a runtime<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// error.<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  ///<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// In debug builds (`-Onone`), the `unsafelyUnwrapped` property has the same<br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  /// The caller of this function guarantees that the closure &#39;body&#39; does not<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  /// escape the object referenced by the opaque pointer passed to it or<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  /// anything transitively reachable form this object. Doing so<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift:  /// will result in undefined behavior.<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  @_semantics(&quot;self_no_escaping_closure&quot;)<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  func _unsafeWithNotEscapedSelfPointer&lt;Result&gt;(<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-    _ body: @noescape (OpaquePointer) throws -&gt; Result<br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// reference&#39;s lifetime fixed for the duration of the<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// &#39;_withUnsafeGuaranteedRef&#39; call.<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  ///<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift:  /// Violation of this will incur undefined behavior.<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  ///<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// A lifetime of a reference &#39;the instance&#39; is fixed over a point in the<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// programm if:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Those latter two are in stdlib-internal declarations. I think I have the same objection with using the term for &#39;unsafelyUnwrapped&#39;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, we can say &quot;A program has undefined behavior if it does X or Y&quot;, or we can say &quot;A program which does X or Y lacks type safety&quot;. In all cases we are referring to a concept defined elsewhere.  If we say &quot;undefined behavior&quot;, we are using an easily-googled term whose popular discussions will quickly inform the reader of the consequences of the violation.  If we say &quot;type safety&quot;, we are using a term with that&#39;s popularly used in very vague, hand-wavey ways and whose consequences aren&#39;t usually discussed outside of formal contexts.  If we say &quot;memory safety&quot;, we&#39;re using a term that doesn&#39;t even have that precedent.  So we can use the latter two terms if we want, but that just means we need to have a standard place where we define them and describe the consequences of violating them, probably with at least a footnote saying &quot;this is analogous to the undefined behavior rules of C and C++&quot;.<br>&gt;&gt; <br>&gt;&gt; In other places where the standard library intentionally has undefined behavior, it looks like we use the term &quot;serious programming error&quot;, for instance in the the doc comment for `assert`:<br>&gt;&gt; <br>&gt;&gt; /// * In -Ounchecked builds, `condition` is not evaluated, but the<br>&gt;&gt; ///   optimizer may assume that it *would* evaluate to `true`. Failure<br>&gt;&gt; ///   to satisfy that assumption in -Ounchecked builds is a serious<br>&gt;&gt; ///   programming error.<br>&gt;&gt; <br>&gt;&gt; which feels a bit colloquial to me, and doesn&#39;t provide much insight into the full consequences of UB. I think we&#39;re better off using an established term.<br>&gt; <br>&gt; Agreed.<br>&gt; <br>&gt; Do we have a good place to document common terms?  Preferably one that isn&#39;t a book?<br>&gt; <br>&gt; John.<br></p><p><br>Am I the only one who sees defining &quot;undefined behavior&quot; as a paradox?<br></p><p>I&#39;m not disagreeing with better documentation, but there&#39;s no way to specify the behavor of compiled code once you feed the compiler an incorrect fact. Violating a simple constraint that two pointers cannot alias can easily lead to executing code paths that would not otherwise be executed, hence unknown side effects. We could make statements about the current implemenation of the compiler but that would only be misleading as it&#39;s impossible to make any guarantee about future compilers once you&#39;ve violated the contract. The implementation should make common cases less surprising, but limits on the possible side effects can&#39;t be specified. Once you intentionally step beyond the protection that the Swift language provides, you&#39;re firmly in C/C++ compiler territory. So for more on that, see one of the many discussions out there on the topic in general.<br></p><p>What we should try really hard to do is to make it clear what rules programmers need to follow to safely use &quot;unsafe&quot; constructs. Once you have those rules, you have a contract with future compilers and you can write code sanitizers. <br></p><p>I&#39;m specifically focussing on UnsafePointer&#39;s Pointee type, because making that safer requires source breaking changes, and because the rules were so nonobvious. This is an API that programmers use when they are comfortable taking responsibility for the lifetime and bounds of an object. They are probably not expecting to take responsibility for type safety, and likely not even aware of strict aliasing rules.<br></p><p>-Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160513/4739297e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 20, 2016 at 07:00:00am</p></header><div class="content"><p>On May 12, 2016, at 4:03 PM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br></p><p>&gt;&gt;&gt; On May 12, 2016, at 3:21 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On May 12, 2016, at 11:21 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 12, 2016, at 10:45 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On May 12, 2016, at 10:44, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 12, 2016, at 9:27 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - I’m uncomfortable with using the term “undefined behavior” as if it’s universally understood. Up until now we haven&#39;t formally had that notion in Swift, just “type safety” and “memory safety” and “invariant-preserving” and the like. Maybe we need it now, but I think it needs to be explicitly defined. (I’d actually talk to Dave about exactly what terms make the most sense for users.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We do have undefined behavior, and use that term in the standard library docs where appropriate:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// `!` (forced unwrap) operator. However, in optimized builds (`-O`), no<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// check is performed to ensure that the current instance actually has a<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// value. Accessing this property in the case of a `nil` value is a serious<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift:  /// programming error and could lead to undefined behavior or a runtime<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// error.<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  ///<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// In debug builds (`-Onone`), the `unsafelyUnwrapped` property has the same<br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  /// The caller of this function guarantees that the closure &#39;body&#39; does not<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  /// escape the object referenced by the opaque pointer passed to it or<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  /// anything transitively reachable form this object. Doing so<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift:  /// will result in undefined behavior.<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  @_semantics(&quot;self_no_escaping_closure&quot;)<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  func _unsafeWithNotEscapedSelfPointer&lt;Result&gt;(<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-    _ body: @noescape (OpaquePointer) throws -&gt; Result<br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// reference&#39;s lifetime fixed for the duration of the<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// &#39;_withUnsafeGuaranteedRef&#39; call.<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  ///<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift:  /// Violation of this will incur undefined behavior.<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  ///<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// A lifetime of a reference &#39;the instance&#39; is fixed over a point in the<br>&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// programm if:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Those latter two are in stdlib-internal declarations. I think I have the same objection with using the term for &#39;unsafelyUnwrapped&#39;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, we can say &quot;A program has undefined behavior if it does X or Y&quot;, or we can say &quot;A program which does X or Y lacks type safety&quot;.  In all cases we are referring to a concept defined elsewhere.  If we say &quot;undefined behavior&quot;, we are using an easily-googled term whose popular discussions will quickly inform the reader of the consequences of the violation.  If we say &quot;type safety&quot;, we are using a term with that&#39;s popularly used in very vague, hand-wavey ways and whose consequences aren&#39;t usually discussed outside of formal contexts.  If we say &quot;memory safety&quot;, we&#39;re using a term that doesn&#39;t even have that precedent.  So we can use the latter two terms if we want, but that just means we need to have a standard place where we define them and describe the consequences of violating them, probably with at least a footnote saying &quot;this is analogous to the undefined behavior rules of C and C++&quot;.<br>&gt;&gt; <br>&gt;&gt; In other places where the standard library intentionally has undefined behavior, it looks like we use the term &quot;serious programming error&quot;, for instance in the the doc comment for `assert`:<br>&gt;&gt; <br>&gt;&gt; /// * In -Ounchecked builds, `condition` is not evaluated, but the<br>&gt;&gt; ///   optimizer may assume that it *would* evaluate to `true`. Failure<br>&gt;&gt; ///   to satisfy that assumption in -Ounchecked builds is a serious<br>&gt;&gt; ///   programming error.<br>&gt;&gt; <br>&gt;&gt; which feels a bit colloquial to me, and doesn&#39;t provide much insight into the full consequences of UB. I think we&#39;re better off using an established term.<br>&gt; <br>&gt; Agreed.<br>&gt; <br>&gt; Do we have a good place to document common terms?  Preferably one that isn&#39;t a book?<br></p><p>We cite Wikipedia in the stdlib doc comments, why can&#39;t we cite TSPL, and put the detailed discussion there?<br></p><p>-Chris<br></p><p><br></p><p>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>May 20, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 7:56 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; On May 12, 2016, at 4:03 PM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; On May 12, 2016, at 3:21 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On May 12, 2016, at 11:21 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 12, 2016, at 10:45 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On May 12, 2016, at 10:44, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 12, 2016, at 9:27 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - I’m uncomfortable with using the term “undefined behavior” as if it’s universally understood. Up until now we haven&#39;t formally had that notion in Swift, just “type safety” and “memory safety” and “invariant-preserving” and the like. Maybe we need it now, but I think it needs to be explicitly defined. (I’d actually talk to Dave about exactly what terms make the most sense for users.)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We do have undefined behavior, and use that term in the standard library docs where appropriate:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// `!` (forced unwrap) operator. However, in optimized builds (`-O`), no<br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// check is performed to ensure that the current instance actually has a<br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// value. Accessing this property in the case of a `nil` value is a serious<br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift:  /// programming error and could lead to undefined behavior or a runtime<br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// error.<br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  ///<br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Optional.swift-  /// In debug builds (`-Onone`), the `unsafelyUnwrapped` property has the same<br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  /// The caller of this function guarantees that the closure &#39;body&#39; does not<br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  /// escape the object referenced by the opaque pointer passed to it or<br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  /// anything transitively reachable form this object. Doing so<br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift:  /// will result in undefined behavior.<br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  @_semantics(&quot;self_no_escaping_closure&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-  func _unsafeWithNotEscapedSelfPointer&lt;Result&gt;(<br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/StringBridge.swift-    _ body: @noescape (OpaquePointer) throws -&gt; Result<br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// reference&#39;s lifetime fixed for the duration of the<br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// &#39;_withUnsafeGuaranteedRef&#39; call.<br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  ///<br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift:  /// Violation of this will incur undefined behavior.<br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  ///<br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// A lifetime of a reference &#39;the instance&#39; is fixed over a point in the<br>&gt;&gt;&gt;&gt;&gt;&gt; stdlib/public/core/Unmanaged.swift-  /// programm if:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Those latter two are in stdlib-internal declarations. I think I have the same objection with using the term for &#39;unsafelyUnwrapped&#39;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Well, we can say &quot;A program has undefined behavior if it does X or Y&quot;, or we can say &quot;A program which does X or Y lacks type safety&quot;.  In all cases we are referring to a concept defined elsewhere.  If we say &quot;undefined behavior&quot;, we are using an easily-googled term whose popular discussions will quickly inform the reader of the consequences of the violation.  If we say &quot;type safety&quot;, we are using a term with that&#39;s popularly used in very vague, hand-wavey ways and whose consequences aren&#39;t usually discussed outside of formal contexts.  If we say &quot;memory safety&quot;, we&#39;re using a term that doesn&#39;t even have that precedent.  So we can use the latter two terms if we want, but that just means we need to have a standard place where we define them and describe the consequences of violating them, probably with at least a footnote saying &quot;this is analogous to the undefined behavior rules of C and C++&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In other places where the standard library intentionally has undefined behavior, it looks like we use the term &quot;serious programming error&quot;, for instance in the the doc comment for `assert`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /// * In -Ounchecked builds, `condition` is not evaluated, but the<br>&gt;&gt;&gt; ///   optimizer may assume that it *would* evaluate to `true`. Failure<br>&gt;&gt;&gt; ///   to satisfy that assumption in -Ounchecked builds is a serious<br>&gt;&gt;&gt; ///   programming error.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which feels a bit colloquial to me, and doesn&#39;t provide much insight into the full consequences of UB. I think we&#39;re better off using an established term.<br>&gt;&gt; <br>&gt;&gt; Agreed.<br>&gt;&gt; <br>&gt;&gt; Do we have a good place to document common terms?  Preferably one that isn&#39;t a book?<br>&gt; <br>&gt; We cite Wikipedia in the stdlib doc comments, why can&#39;t we cite TSPL, and put the detailed discussion there?<br></p><p>I don&#39;t feel comfortable editing TSPL.  Should I?<br></p><p>John.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May 12, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 12, 2016, at 9:27 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; On the model itself:<br></p><p>Responding to your feedback on the model (thanks!). <br>https://github.com/atrick/swift/blob/type-safe-mem-docs/docs/TypeSafeMemory.rst &lt;https://github.com/atrick/swift/blob/type-safe-mem-docs/docs/TypeSafeMemory.rst&gt;<br>With just one follow up question at the bottom of this email…<br></p><p>&gt; - &quot;thin function, C function, and block function types” &lt;-- block functions are not layout-compatible with C functions, and they are layout-compatible with AnyObject. (I mean, they’re both pointers at the moment, but so are non-weak object references.)<br></p><p>   - pointer types (e.g. ``OpaquePointer``, ``UnsafePointer``)<br>-  - thin function, C function, and block function types<br>+  - block function types and ``AnyObject``<br>+  - thin function and C function types<br>   - imported C types that have the same layout in C<br></p><p>&gt; - &quot;nonresilient structs” &lt;-- nitpick: the term “nonresilient” is not defined here, and isn’t a formal term in the Library Evolution doc. I guess I would actually prefer “fragile” if you needed a generic term across structs and enums, but either way you should put a small definition somewhere in this doc.<br></p><p>   - imported C types that have the same layout in C<br>-  - nonresilient structs with one stored property and their stored<br>+  - fragile structs with one stored property and their stored<br>     property type<br>-  - nonresilient enums with one case and their payload type<br>+  - fragile enums with one case and their payload type<br> <br> .. note::<br> <br>-   `Library Evolution Support in Swift`__<br>+   &quot;Fragile&quot; enums and structs have strict layout rules that ensure<br>+   binary compatibility. `Library Evolution Support in Swift`__<br>    explains the impact of resilience on object layout.<br></p><p>&gt; - &quot;homogeneous tuples, fixed-sized array storage, and homogeneous nonresilient structs in which the element type has no spare bits (structs may be bit packed).” &lt;-- I would leave the structs out of this, even if it’s true. Also, Swift doesn’t have fixed-size arrays at the moment, right?<br></p><p>Hmm, I think we want to say that raw allocated memory, arrays, homogeneous tuples and structs are layout compatible with &#39;strideof&#39;. I&#39;ll leave out structs for now and this can be hashed out in ABI specs. I want to avoid naming specific API&#39;s and I think it&#39;s ok to be a bit vague in this (non-ABI) document as long as the intent is obvious:<br></p><p>  - contiguous array storage and homogeneous tuples which <br>    have the same number and type of elements.<br></p><p>&gt; - &quot;In particular, they apply to access that originates from stored property getter and setters, reading from and assigning into inout variables, and reading or assigning subscripts (including the Unsafe[Mutable]Pointer pointee property and subscripts).” I’m unhappy with inout variables being called out specially here. An inout variable should be exactly like a local variable that happens to be stack-allocated, rather than just in registers. Closure captures probably figure in here too.<br></p><p>Agreed. I&#39;m not sure what I was thinking.<br></p><p>&gt; - &quot;unsafeBitCast is valid for pointer to integer conversions” &lt;-- we have better APIs to do this now (&#39;init(bitPattern:)’ in both directions).<br></p><p>+``unsafeBitCast`` should generally be avoided on pointer types,<br>+particularly class types. For pointer to integer conversions,<br>+``bitPattern`` initializers are available in both<br>+directions. ``unsafeBitCast`` may be used to convert between<br>+nondereferenceable pointer types, but as with any conversion to and<br>+from opaque pointers, this presents an opportunity for type punning<br>+when converting back to a dereferenceable pointer type.<br></p><p>&gt; - &quot;It is also used internally to convert between nondereferenceable pointer types, which avoids the need to add builtin conversions for all combinations of pointer types.” &lt;-- I’d be happy to get rid of this and just go through Builtin.RawPointer when necessary.<br></p><p>...I do like to get feedback that eliminating unsafeBitCast is a good thing. I think it should only be needed for genuine reinterpretation of the bits as opposed working around the type system. I&#39;d like to see only a tiny handful of occurrences in stdlib. I have a branch where I&#39;ve cleaned up many unsafeBitCasts, which never got checked in, so I can spend some time on that again after UnsafePointer changes land. Then maybe we should prohibit it from being called on certain pointer types. For starters AnyObject, UnsafePointer, and UnsafeBytePointer.<br></p><p>&gt; - On the flip side, I think we do need to preserve the ability to reference-cast in order to send Objective-C messages, at least for now. I don’t know how I want to expose that to users, though. (In general it’s probably worth seeing how unsafeBitCast is used in the wild and what we’d recommend instead.)<br></p><p>Does ``X as Y`` fail for some reason? We have unchecked versions of ``X as Y`` for performance reasons: ``unsafeDowncast`` and ``_unsafeReferenceCast``.<br></p><p>-Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160512/5c9b7d81/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May 12, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On May 12, 2016, at 18:34, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; - On the flip side, I think we do need to preserve the ability to reference-cast in order to send Objective-C messages, at least for now. I don’t know how I want to expose that to users, though. (In general it’s probably worth seeing how unsafeBitCast is used in the wild and what we’d recommend instead.)<br>&gt; <br>&gt; Does ``X as Y`` fail for some reason? We have unchecked versions of ``X as Y`` for performance reasons: ``unsafeDowncast`` and ``_unsafeReferenceCast``.<br></p><p><br>The particular case I’m thinking about is where we reinterpret an AnyObject as an @objc protocol because we don’t know the dynamic type we would need to add a method to. This doesn’t happen much, and maybe we just say sending arbitrary messages requires an ObjC-side workaround. Or we commit to ‘_unsafeReferenceCast’ and de-underscore it.<br></p><p>(_unsafeReferenceCast is probably a better choice for StdlibUnittest, which is where I used this.)<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160512/6d457f4e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>May 12, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 12, 2016, at 9:27 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Thoughts on the diff:<br></p><p>https://github.com/atrick/swift/tree/unsafeptr_convert &lt;https://github.com/atrick/swift/tree/unsafeptr_convert&gt;<br></p><p>&gt; - What was the thought behind putting UnsafeBytePointer in PointerTypeKind? OpaquePointer isn’t there, and I’m concerned about places that test if something’s a pointer by checking that the pointee type is non-null (by far the common pattern).<br></p><p>In general I wanted UnsafeBytePointer to stand-in for UnsafePointer&lt;Void&gt; throughout the type system and handle most of the same implicit conversions. Specifically, I wanted getAnyPointerElementType to do the same thing as UnsafePointer&lt;Void&gt; and return an empty tuple pointee type so that the calling code could be reused. Also, I thought that supporting PointerToPointerExpr was necessary.<br></p><p>The only extra burden of doing this that I could find was that getPointerPointeePropertyDecl may return null. The only code that calls this is emitStoreToForeignErrorSlot.<br></p><p>I&#39;m very open to alternate implementations, especially once the proposal is accepted.<br></p><p>&gt; - The PrintAsObjC test can’t possibly pass as is—it’s checking that one pointer is const and the other isn’t. I’m guessing there’s actually more work to do here.<br></p><p>That&#39;s right. PrintAsObjC is one of several tests that are still failing. Before fixing them I want to:<br></p><p>- get reassurance that we really want to replace the the imported type of &#39;void*&#39;. Then I&#39;ll introduce an UnsafeMutableBytePointer.<br></p><p>- determine precisely which implicit conversions we want to allow and update test cases accordingly.<br></p><p>These are the tests that were failing on my branch (last time I succesfully rebased):<br></p><p>POSIX.swift - requires String -&gt; UnsafeBytePointer arg conversion<br>UnsafeBufferPointer.swift - UnsafePointer conversion rules?<br>UnsafePointer.swift - UnsafePointer conversion rules?<br>ClangModules/* - UnsafePointer conversion rules?<br>IRGen/objc_pointer - name mangling<br>SDK/c_pointers - [Double] to UnsafeBytePointer<br>SDK/objc_inner_pointer - [UInt8] to UnsafeBytePointer<br>Parse/pointer_conversion - &#39;UnsafePointer&lt;Int&gt;&#39; to &#39;UnsafeBytePointer&#39;<br>PrintAsObjC/classes.swift - void* export<br>SILGen/objc_currying - name mangling<br>SILGen/pointer_conversion - String to UnsafeBytePointer<br>SourceKit/DocSupport - formatting<br>sil-opt/emit-sib. - mangling<br>OpenCLSDKOverlay - [Float] to UnsafeBytePointer<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160512/1165e3f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May 12, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On May 12, 2016, at 18:56, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; - What was the thought behind putting UnsafeBytePointer in PointerTypeKind? OpaquePointer isn’t there, and I’m concerned about places that test if something’s a pointer by checking that the pointee type is non-null (by far the common pattern).<br>&gt; <br>&gt; In general I wanted UnsafeBytePointer to stand-in for UnsafePointer&lt;Void&gt; throughout the type system and handle most of the same implicit conversions. Specifically, I wanted getAnyPointerElementType to do the same thing as UnsafePointer&lt;Void&gt; and return an empty tuple pointee type so that the calling code could be reused. Also, I thought that supporting PointerToPointerExpr was necessary.<br>&gt; <br>&gt; The only extra burden of doing this that I could find was that getPointerPointeePropertyDecl may return null. The only code that calls this is emitStoreToForeignErrorSlot.<br>&gt; <br>&gt; I&#39;m very open to alternate implementations, especially once the proposal is accepted.<br></p><p>I’m sorry, I got ASTContext::getPointerPointeePropertyDecl and TypeBase::getAnyPointerElementType mixed up. I’m still a little unsure that this is the right way to go, and I wonder how many uses of getAnyPointerElementType actually make sense for UnsafeBytePointer, but I see now that it’s the most incremental way to make this change.<br></p><p>For fun I looked through the (relatively small) set of uses for getAnyPointerElementType, and it looks like only the inout-to-pointer ones are relevant for UnsafeBytePointer. (These are the ones in lib/Sema, plus SILGen’s RValueEmitter::visitInOutToPointerExpr.) So it could be dropped as a pointer type. But it doesn’t seem to be doing any harm.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160512/bccd1029/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[RFC] UnsafeBytePointer API for In-Memory Layout</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>May 13, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On May 12, 2016, at 7:47 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; On May 12, 2016, at 18:56, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; - What was the thought behind putting UnsafeBytePointer in PointerTypeKind? OpaquePointer isn’t there, and I’m concerned about places that test if something’s a pointer by checking that the pointee type is non-null (by far the common pattern).<br>&gt;&gt; <br>&gt;&gt; In general I wanted UnsafeBytePointer to stand-in for UnsafePointer&lt;Void&gt; throughout the type system and handle most of the same implicit conversions. Specifically, I wanted getAnyPointerElementType to do the same thing as UnsafePointer&lt;Void&gt; and return an empty tuple pointee type so that the calling code could be reused. Also, I thought that supporting PointerToPointerExpr was necessary.<br>&gt;&gt; <br>&gt;&gt; The only extra burden of doing this that I could find was that getPointerPointeePropertyDecl may return null. The only code that calls this is emitStoreToForeignErrorSlot.<br>&gt;&gt; <br>&gt;&gt; I&#39;m very open to alternate implementations, especially once the proposal is accepted.<br>&gt; <br>&gt; I’m sorry, I got ASTContext::getPointerPointeePropertyDecl and TypeBase::getAnyPointerElementType mixed up. I’m still a little unsure that this is the right way to go, and I wonder how many uses of getAnyPointerElementType actually make sense for UnsafeBytePointer, but I see now that it’s the most incremental way to make this change.<br>&gt; <br>&gt; For fun I looked through the (relatively small) set of uses for getAnyPointerElementType, and it looks like only the inout-to-pointer ones are relevant for UnsafeBytePointer. (These are the ones in lib/Sema, plus SILGen’s RValueEmitter::visitInOutToPointerExpr.) So it could be dropped as a pointer type. But it doesn’t seem to be doing any harm.<br></p><p>One thing Andy and I discussed is whether we could support aliasing addressors.  The answer is yes, although it will important to force a copy in cases where a non-aliasing address is required, i.e. when passing the l-value as an inout argument or when implementing materializeForSet.  An aliasing addressor would naturally return an UnsafeBytePointer value (or better yet a typed version of it).<br></p><p>John.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160513/646b413b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
