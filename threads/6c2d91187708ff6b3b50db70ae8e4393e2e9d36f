<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72853d2b57e37aab89afe61af4f74c62?s=50"></div><header><strong>pattern matching in if improvement?</strong> from <string>Maury Markowitz</string> &lt;maury.markowitz at gmail.com&gt;<p>March 26, 2016 at 05:00:00pm</p></header><div class="content"><p>Before I stick my head into the other list, consider:<br></p><p>   if statusCode &gt;= 200 &amp;&amp; statusCode &lt;= 299<br></p><p>I&#39;m sure examples of something like this occur throughout your code. But the actual semantics of the test is hidden here, you&#39;re really testing if statusCode lies within a range. Swift 2.0 has a couple of options for this, but I find them all rather odd. The most recommended is:<br></p><p>   if case 0...100 = someInteger<br></p><p>This syntax has problems. For one thing, it&#39;s written backwards compared to most people&#39;s code...<br></p><p>   if someinteger == 100<br></p><p>not...<br></p><p>   if 100 == someinteger<br></p><p>so it just *feels* wrong. In addition, the use of &quot;case&quot; seems odd too. And finally, there&#39;s the use of the single equals sign in a test, which goes against everything we&#39;ve learned in C-like languages.<br></p><p>So unless I&#39;m missing something, can anyone offer a reason this wouldn&#39;t work?<br></p><p>  if someinteger in 0...100<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>pattern matching in if improvement?</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>March 26, 2016 at 10:00:00pm</p></header><div class="content"><p>var someInteger = 250<br>if 200..&lt;299 ~= someInteger {<br>  print(&quot;works&quot;)<br>}<br></p><p>Em s√°b, 26 de mar de 2016 18:47, Maury Markowitz via swift-users &lt;<br>swift-users at swift.org&gt; escreveu:<br></p><p>&gt; Before I stick my head into the other list, consider:<br>&gt;<br>&gt;    if statusCode &gt;= 200 &amp;&amp; statusCode &lt;= 299<br>&gt;<br>&gt; I&#39;m sure examples of something like this occur throughout your code. But<br>&gt; the actual semantics of the test is hidden here, you&#39;re really testing if<br>&gt; statusCode lies within a range. Swift 2.0 has a couple of options for this,<br>&gt; but I find them all rather odd. The most recommended is:<br>&gt;<br>&gt;    if case 0...100 = someInteger<br>&gt;<br>&gt; This syntax has problems. For one thing, it&#39;s written backwards compared<br>&gt; to most people&#39;s code...<br>&gt;<br>&gt;    if someinteger == 100<br>&gt;<br>&gt; not...<br>&gt;<br>&gt;    if 100 == someinteger<br>&gt;<br>&gt; so it just *feels* wrong. In addition, the use of &quot;case&quot; seems odd too.<br>&gt; And finally, there&#39;s the use of the single equals sign in a test, which<br>&gt; goes against everything we&#39;ve learned in C-like languages.<br>&gt;<br>&gt; So unless I&#39;m missing something, can anyone offer a reason this wouldn&#39;t<br>&gt; work?<br>&gt;<br>&gt;   if someinteger in 0...100<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160326/620c1fd9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a49c2b8a7e2ffa1339ac013f4cf9b6ff?s=50"></div><header><strong>pattern matching in if improvement?</strong> from <string>Neil Faiman</string> &lt;neil.swift at faiman.org&gt;<p>March 26, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Mar 26, 2016, at 5:47 PM, Maury Markowitz via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Before I stick my head into the other list, consider:<br>&gt; <br>&gt;   if statusCode &gt;= 200 &amp;&amp; statusCode &lt;= 299<br>&gt; <br>&gt; I&#39;m sure examples of something like this occur throughout your code. But the actual semantics of the test is hidden here, you&#39;re really testing if statusCode lies within a range. Swift 2.0 has a couple of options for this, but I find them all rather odd. The most recommended is:<br>&gt; <br>&gt;   if case 0...100 = someInteger<br>&gt; <br>&gt; This syntax has problems. For one thing, it&#39;s written backwards compared to most people&#39;s code...<br>&gt; <br>&gt;   if someinteger == 100<br>&gt; <br></p><p>How about<br></p><p>	if (200..&lt;299).contains(statusCode)<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>pattern matching in if improvement?</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 26, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Mar 26, 2016, at 3:47 PM, Maury Markowitz via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Before I stick my head into the other list, consider:<br>&gt; <br>&gt;   if statusCode &gt;= 200 &amp;&amp; statusCode &lt;= 299<br>&gt; <br>&gt; I&#39;m sure examples of something like this occur throughout your code. But the actual semantics of the test is hidden here, you&#39;re really testing if statusCode lies within a range. Swift 2.0 has a couple of options for this, but I find them all rather odd. The most recommended is:<br>&gt; <br>&gt;   if case 0...100 = someInteger<br></p><p>While I prefer: <br></p><p>if 200...299 ~= statusCode { print(&quot;within 200-299&quot;) }<br></p><p>I see that you&#39;re asking specifically about case/=. But keep that example in mind because I&#39;m<br>going to circle back to it.<br></p><p>&gt; This syntax has problems. For one thing, it&#39;s written backwards compared to most people&#39;s code...<br>&gt; <br>&gt;   if someinteger == 100<br>&gt; <br>&gt; not...<br>&gt; <br>&gt;   if 100 == someinteger<br>&gt; <br>&gt; so it just *feels* wrong. In addition, the use of &quot;case&quot; seems odd too. And finally, there&#39;s the use of the single equals sign in a test, which goes against everything we&#39;ve learned in C-like languages.<br>&gt; <br>&gt; So unless I&#39;m missing something, can anyone offer a reason this wouldn&#39;t work?<br>&gt; <br>&gt;  if someinteger in 0...100<br></p><p>This is a built-in problem with &quot;if case/=&quot;. Starting with the core statement :<br></p><p>if case pattern = value {...}<br></p><p>It&#39;s far easier to read and understand the equivalent switch than the one-liner:<br></p><p>switch (value) {<br>case pattern: ...<br>default: break<br>}<br></p><p>Once you convert to a switch, the &quot;If this value can be matched to this pattern&quot; <br>becomes a lot less mentally weird but there&#39;s also a lot of extra fluff that if case<br>attempts to trim away. Here&#39;s a concrete example.  &quot;In the case that the pattern <br>Test.A(Int) can be matched to this value then bind x to the associated Int value&quot;<br></p><p>let value = Test.A(23)<br></p><p>if case Test.A(let x) = value {<br>    print(x) // will print 23<br>}<br></p><p>Again the switch is a lot more intuitive to read, but contains a lot of unneeded<br>details that can and should be trimmable:<br></p><p>switch (value) {<br>case Test.A(let x): ...<br>default: break<br>}<br></p><p>And here&#39;s the oddest example of this Case/= construct I can think of in terms<br>of the &quot;read through&quot; not matching the actual programming intent of &quot;In the <br>case that the array indices can be matched to this value&quot; <br></p><p>if case array.indices = array.startIndex { print(&quot;strange but yup&quot;) }<br></p><p>And its switch equivalent, which is way more obvious in terms of intent:<br></p><p>switch (array.startIndex) {<br>case array.indices: ...<br>default: break<br>}<br></p><p>Now back to your original point. Could this be expressed better? For sure. I think these are far more readable:<br></p><p>if value in range {...} // vs if range ~=<br>if value matches pattern {...} // vs if case pattern = value<br></p><p>And for these specific examples, they&#39;d look like this in an updated Swift that adopted these changes:<br></p><p>if statusCode in 200...299 { print(&quot;within 200-299&quot;) }<br>if value matches Test.A(let x) { print(x) } // will print 23<br>if array.startIndex in array.indices { print(&quot;the ~= variation&quot;) }<br>if array.startIndex matches array.indices { print (&quot;better example Case/=&quot;) }<br></p><p>That said, I&#39;ve also made my opinion clear over there that the use of &quot;let&quot; and &quot;var&quot;<br>in &quot;if let&quot; unnecessarily overloads constant and variable binding (it&#39;s testing something <br>that actually acts differently than the standalone let due to unwrapping). This got nowhere<br>for a variety of compelling and less compelling reasons. (I&#39;d prefer &quot;if bind&quot; even if it  <br>sacrifices a variable variant.)<br></p><p>I certainly think it&#39;s worth doing at least a [Pitch] over in -evolution with the alternate <br>constructs.<br></p><p>-- E<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160326/d11f7e2f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc2018ce0c170425a51033a54850a538?s=50"></div><header><strong>pattern matching in if improvement?</strong> from <string>Lukas Stabe</string> &lt;ahti333 at gmail.com&gt;<p>March 26, 2016 at 10:00:00pm</p></header><div class="content"><p>I&#39;d love to see `if value matches pattern`. Every time I use `if case` I have to stop and think to remember the weird syntax. I get where it came from, but I think `matches` better describes what happens here (one is immediately reminded of pattern matching).<br></p><p>I don&#39;t know wether this might be unfeasible to do due to compiler performance limitations, but I would support a proposal to replace `if case` with `if value matches pattern`. <br></p><p>An alternative may be to introduce a custom operator that just calls `~=` with the arguments reversed, but imho this should rather be fixed at the language level.<br></p><p>‚Äì Lukas<br></p><p>&gt; On 26 Mar 2016, at 18:13, Erica Sadun via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Mar 26, 2016, at 3:47 PM, Maury Markowitz via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Before I stick my head into the other list, consider:<br>&gt;&gt; <br>&gt;&gt;   if statusCode &gt;= 200 &amp;&amp; statusCode &lt;= 299<br>&gt;&gt; <br>&gt;&gt; I&#39;m sure examples of something like this occur throughout your code. But the actual semantics of the test is hidden here, you&#39;re really testing if statusCode lies within a range. Swift 2.0 has a couple of options for this, but I find them all rather odd. The most recommended is:<br>&gt;&gt; <br>&gt;&gt;   if case 0...100 = someInteger<br>&gt; <br>&gt; While I prefer: <br>&gt; <br>&gt; if 200...299 ~= statusCode { print(&quot;within 200-299&quot;) }<br>&gt; <br>&gt; I see that you&#39;re asking specifically about case/=. But keep that example in mind because I&#39;m<br>&gt; going to circle back to it.<br>&gt; <br>&gt;&gt; This syntax has problems. For one thing, it&#39;s written backwards compared to most people&#39;s code...<br>&gt;&gt; <br>&gt;&gt;   if someinteger == 100<br>&gt;&gt; <br>&gt;&gt; not...<br>&gt;&gt; <br>&gt;&gt;   if 100 == someinteger<br>&gt;&gt; <br>&gt;&gt; so it just *feels* wrong. In addition, the use of &quot;case&quot; seems odd too. And finally, there&#39;s the use of the single equals sign in a test, which goes against everything we&#39;ve learned in C-like languages.<br>&gt;&gt; <br>&gt;&gt; So unless I&#39;m missing something, can anyone offer a reason this wouldn&#39;t work?<br>&gt;&gt; <br>&gt;&gt;  if someinteger in 0...100<br>&gt; <br>&gt; This is a built-in problem with &quot;if case/=&quot;. Starting with the core statement :<br>&gt; <br>&gt; if case pattern = value {...}<br>&gt; <br>&gt; It&#39;s far easier to read and understand the equivalent switch than the one-liner:<br>&gt; <br>&gt; switch (value) {<br>&gt; case pattern: ...<br>&gt; default: break<br>&gt; }<br>&gt; <br>&gt; Once you convert to a switch, the &quot;If this value can be matched to this pattern&quot; <br>&gt; becomes a lot less mentally weird but there&#39;s also a lot of extra fluff that if case<br>&gt; attempts to trim away. Here&#39;s a concrete example.  &quot;In the case that the pattern <br>&gt; Test.A(Int) can be matched to this value then bind x to the associated Int value&quot;<br>&gt; <br>&gt; let value = Test.A(23)<br>&gt; <br>&gt; if case Test.A(let x) = value {<br>&gt;     print(x) // will print 23<br>&gt; }<br>&gt; <br>&gt; Again the switch is a lot more intuitive to read, but contains a lot of unneeded<br>&gt; details that can and should be trimmable:<br>&gt; <br>&gt; switch (value) {<br>&gt; case Test.A(let x): ...<br>&gt; default: break<br>&gt; }<br>&gt; <br>&gt; And here&#39;s the oddest example of this Case/= construct I can think of in terms<br>&gt; of the &quot;read through&quot; not matching the actual programming intent of &quot;In the <br>&gt; case that the array indices can be matched to this value&quot; <br>&gt; <br>&gt; if case array.indices = array.startIndex { print(&quot;strange but yup&quot;) }<br>&gt; <br>&gt; And its switch equivalent, which is way more obvious in terms of intent:<br>&gt; <br>&gt; switch (array.startIndex) {<br>&gt; case array.indices: ...<br>&gt; default: break<br>&gt; }<br>&gt; <br>&gt; Now back to your original point. Could this be expressed better? For sure. I think these are far more readable:<br>&gt; <br>&gt; if value in range {...} // vs if range ~=<br>&gt; if value matches pattern {...} // vs if case pattern = value<br>&gt; <br>&gt; And for these specific examples, they&#39;d look like this in an updated Swift that adopted these changes:<br>&gt; <br>&gt; if statusCode in 200...299 { print(&quot;within 200-299&quot;) }<br>&gt; if value matches Test.A(let x) { print(x) } // will print 23<br>&gt; if array.startIndex in array.indices { print(&quot;the ~= variation&quot;) }<br>&gt; if array.startIndex matches array.indices { print (&quot;better example Case/=&quot;) }<br>&gt; <br>&gt; That said, I&#39;ve also made my opinion clear over there that the use of &quot;let&quot; and &quot;var&quot;<br>&gt; in &quot;if let&quot; unnecessarily overloads constant and variable binding (it&#39;s testing something <br>&gt; that actually acts differently than the standalone let due to unwrapping). This got nowhere<br>&gt; for a variety of compelling and less compelling reasons. (I&#39;d prefer &quot;if bind&quot; even if it  <br>&gt; sacrifices a variable variant.)<br>&gt; <br>&gt; I certainly think it&#39;s worth doing at least a [Pitch] over in -evolution with the alternate <br>&gt; constructs.<br>&gt; <br>&gt; -- E<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160326/ded625e5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[swift-evolution] pattern matching in if improvement?</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>March 27, 2016 at 11:00:00am</p></header><div class="content"><p>I wrote these a while ago and considered proposing that they be added.<br>Might as well throw them into this thread since they are another approach<br>to solving the problem.<br></p><p><br>``` swift<br>import Foundation<br>    // MARK: &lt;<br>    public func &lt;&lt;T : Comparable&gt;(lhs: T, rhs: T) -&gt; (result: Bool,<br>value:T) {<br>        return (lhs &lt; rhs, rhs)<br>    }<br></p><p>    public func &lt;&lt;T : Comparable&gt;(lhs: (result: Bool, value: T), rhs: T) -&gt;<br>Bool {<br>            return lhs.result &amp;&amp; (lhs.value &lt; rhs)<br>        }<br></p><p>    public func &lt;&lt;T : Comparable&gt;(lhs: (Bool, T), rhs: T) -&gt; (Bool, T) {<br>            return (lhs &lt; rhs, rhs)<br>        }<br></p><p>// MARK: &gt;<br>public func &gt;&lt;T : Comparable&gt;(lhs: T, rhs: T) -&gt; (result: Bool, value:T) {<br>    return (lhs &gt; rhs, rhs)<br>    }<br></p><p>public func &gt;&lt;T : Comparable&gt;(lhs: (result: Bool, value: T), rhs: T) -&gt;<br>Bool {<br>    return lhs.result &amp;&amp; (lhs.value &gt; rhs)<br>    }<br></p><p>public func &gt;&lt;T : Comparable&gt;(lhs: (Bool, T), rhs: T) -&gt; (Bool, T) {<br>    return (lhs &gt; rhs, rhs)<br>    }<br>// MARK: &gt;=<br>public func &gt;=&lt;T : Comparable&gt;(lhs: T, rhs: T) -&gt; (result: Bool, value:T) {<br>    return (lhs &gt;= rhs, rhs)<br>    }<br></p><p>public func &gt;=&lt;T : Comparable&gt;(lhs: (result: Bool, value: T), rhs: T) -&gt;<br>Bool {<br>    return lhs.result &amp;&amp; (lhs.value &gt;= rhs)<br>    }<br></p><p>public func &gt;=&lt;T : Comparable&gt;(lhs: (Bool, T), rhs: T) -&gt; (Bool, T) {<br>    return (lhs &gt;= rhs, rhs)<br>    }<br></p><p>// MARK: &lt;=<br>public func &lt;=&lt;T : Comparable&gt;(lhs: T, rhs: T) -&gt; (result: Bool, value:T) {<br>    return (lhs &lt;= rhs, rhs)<br>    }<br></p><p>public func &lt;=&lt;T : Comparable&gt;(lhs: (result: Bool, value: T), rhs: T) -&gt;<br>Bool {<br>    return lhs.result &amp;&amp; (lhs.value &lt;= rhs)<br>    }<br></p><p>public func &lt;=&lt;T : Comparable&gt;(lhs: (Bool, T), rhs: T) -&gt; (Bool, T) {<br>    return (lhs &lt;= rhs, rhs)<br>    }<br></p><p>// MARK: ==<br>public func ==&lt;T : Comparable&gt;(lhs: T, rhs: T) -&gt; (result: Bool, value:T) {<br>    return (lhs == rhs, rhs)<br>    }<br></p><p>public func ==&lt;T : Comparable&gt;(lhs: (result: Bool, value: T), rhs: T) -&gt;<br>Bool {<br>    return lhs.result &amp;&amp; (lhs.value == rhs)<br>    }<br></p><p>public func ==&lt;T : Comparable&gt;(lhs: (Bool, T), rhs: T) -&gt; (Bool, T) {<br>    return (lhs == rhs, rhs)<br>    }<br>let value = 5<br></p><p>if (0 &lt; value) &lt; 10 {<br>    print(&quot;in the middle!&quot;)<br>    } else {<br>    print(&quot;nope&quot;)<br>    }<br></p><p>```<br></p><p>On Sun, Mar 27, 2016 at 5:19 AM, Lukas Stabe via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;d love to see `if value matches pattern`. Every time I use `if case` I<br>have to stop and think to remember the weird syntax. I get where it came<br>from, but I think `matches` better describes what happens here (one is<br>immediately reminded of pattern matching).<br>&gt;<br>&gt; I don&#39;t know wether this might be unfeasible to do due to compiler<br>performance limitations, but I would support a proposal to replace `if<br>case` with `if value matches pattern`.<br>&gt;<br>&gt; An alternative may be to introduce a custom operator that just calls `~=`<br>with the arguments reversed, but imho this should rather be fixed at the<br>language level.<br>&gt;<br>&gt; ‚Äì Lukas<br>&gt;<br>&gt; On 26 Mar 2016, at 18:13, Erica Sadun via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; On Mar 26, 2016, at 3:47 PM, Maury Markowitz via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; Before I stick my head into the other list, consider:<br>&gt;<br>&gt;   if statusCode &gt;= 200 &amp;&amp; statusCode &lt;= 299<br>&gt;<br>&gt; I&#39;m sure examples of something like this occur throughout your code. But<br>the actual semantics of the test is hidden here, you&#39;re really testing if<br>statusCode lies within a range. Swift 2.0 has a couple of options for this,<br>but I find them all rather odd. The most recommended is:<br>&gt;<br>&gt;   if case 0...100 = someInteger<br>&gt;<br>&gt;<br>&gt; While I prefer:<br>&gt;<br>&gt; if 200...299 ~= statusCode { print(&quot;within 200-299&quot;) }<br>&gt;<br>&gt; I see that you&#39;re asking specifically about case/=. But keep that example<br>in mind because I&#39;m<br>&gt; going to circle back to it.<br>&gt;<br>&gt; This syntax has problems. For one thing, it&#39;s written backwards compared<br>to most people&#39;s code...<br>&gt;<br>&gt;   if someinteger == 100<br>&gt;<br>&gt; not...<br>&gt;<br>&gt;   if 100 == someinteger<br>&gt;<br>&gt; so it just *feels* wrong. In addition, the use of &quot;case&quot; seems odd too.<br>And finally, there&#39;s the use of the single equals sign in a test, which<br>goes against everything we&#39;ve learned in C-like languages.<br>&gt;<br>&gt; So unless I&#39;m missing something, can anyone offer a reason this wouldn&#39;t<br>work?<br>&gt;<br>&gt;  if someinteger in 0...100<br>&gt;<br>&gt;<br>&gt; This is a built-in problem with &quot;if case/=&quot;. Starting with the core<br>statement :<br>&gt;<br>&gt; if case pattern = value {...}<br>&gt;<br>&gt; It&#39;s far easier to read and understand the equivalent switch than the<br>one-liner:<br>&gt;<br>&gt; switch (value) {<br>&gt; case pattern: ...<br>&gt; default: break<br>&gt; }<br>&gt;<br>&gt; Once you convert to a switch, the &quot;If this value can be matched to this<br>pattern&quot;<br>&gt; becomes a lot less mentally weird but there&#39;s also a lot of extra fluff<br>that if case<br>&gt; attempts to trim away. Here&#39;s a concrete example.  &quot;In the case that the<br>pattern<br>&gt; Test.A(Int) can be matched to this value then bind x to the associated<br>Int value&quot;<br>&gt;<br>&gt; let value = Test.A(23)<br>&gt;<br>&gt; if case Test.A(let x) = value {<br>&gt;     print(x) // will print 23<br>&gt; }<br>&gt;<br>&gt; Again the switch is a lot more intuitive to read, but contains a lot of<br>unneeded<br>&gt; details that can and should be trimmable:<br>&gt;<br>&gt; switch (value) {<br>&gt; case Test.A(let x): ...<br>&gt; default: break<br>&gt; }<br>&gt;<br>&gt; And here&#39;s the oddest example of this Case/= construct I can think of in<br>terms<br>&gt; of the &quot;read through&quot; not matching the actual programming intent of &quot;In<br>the<br>&gt; case that the array indices can be matched to this value&quot;<br>&gt;<br>&gt; if case array.indices = array.startIndex { print(&quot;strange but yup&quot;) }<br>&gt;<br>&gt; And its switch equivalent, which is way more obvious in terms of intent:<br>&gt;<br>&gt; switch (array.startIndex) {<br>&gt; case array.indices: ...<br>&gt; default: break<br>&gt; }<br>&gt;<br>&gt; Now back to your original point. Could this be expressed better? For<br>sure. I think these are far more readable:<br>&gt;<br>&gt; if value in range {...} // vs if range ~=<br>&gt; if value matches pattern {...} // vs if case pattern = value<br>&gt;<br>&gt; And for these specific examples, they&#39;d look like this in an updated<br>Swift that adopted these changes:<br>&gt;<br>&gt; if statusCode in 200...299 { print(&quot;within 200-299&quot;) }<br>&gt; if value matches Test.A(let x) { print(x) } // will print 23<br>&gt; if array.startIndex in array.indices { print(&quot;the ~= variation&quot;) }<br>&gt; if array.startIndex matches array.indices { print (&quot;better example<br>Case/=&quot;) }<br>&gt;<br>&gt; That said, I&#39;ve also made my opinion clear over there that the use of<br>&quot;let&quot; and &quot;var&quot;<br>&gt; in &quot;if let&quot; unnecessarily overloads constant and variable binding (it&#39;s<br>testing something<br>&gt; that actually acts differently than the standalone let due to<br>unwrapping). This got nowhere<br>&gt; for a variety of compelling and less compelling reasons. (I&#39;d prefer &quot;if<br>bind&quot; even if it<br>&gt; sacrifices a variable variant.)<br>&gt;<br>&gt; I certainly think it&#39;s worth doing at least a [Pitch] over in -evolution<br>with the alternate<br>&gt; constructs.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160327/18db3501/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>pattern matching in if improvement?</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>March 27, 2016 at 05:00:00pm</p></header><div class="content"><p>I&#39;m not where I can check, but is &quot;=~&quot; taken?<br></p><p>Sent from my iPhone<br></p><p>&gt; On Mar 26, 2016, at 22:19, Lukas Stabe via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; An alternative may be to introduce a custom operator that just calls `~=` with the arguments reversed, but imho this should rather be fixed at the language level.<br>&gt; <br>&gt; ‚Äì Lukas<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72853d2b57e37aab89afe61af4f74c62?s=50"></div><header><strong>pattern matching in if improvement?</strong> from <string>Maury Markowitz</string> &lt;maury.markowitz at gmail.com&gt;<p>March 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 26, 2016, at 7:13 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; if 200...299 ~= statusCode { print(&quot;within 200-299&quot;) }<br></p><p>Yes, I should have touched on this one too.<br></p><p>My concern here is one of the concerns of the case version, it&#39;s cart before the horse. General programming practice for tests is something like:<br></p><p>(the thing you want to test) (the test) (what you test against)<br></p><p>This syntax reverses that ordering. Sure, this is a purely stylistic concern, but so much in programming is.<br></p><p>As someone else noted, we could simply allow this to be reversed, but that raises the question of why bother?<br></p><p>We already have the &quot;in&quot; operator. Everyone knows it, because you have to, especially under Swift 3. Using it in the if statement works exactly the same way it does in the for. And it requires nothing new to learn, unlike ~= which is an edge use-case.<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
