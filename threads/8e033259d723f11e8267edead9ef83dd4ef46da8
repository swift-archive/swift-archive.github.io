<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cd2919ebf2f35a905b24e5002b4dd836?s=50"></div><header><strong>Proposal: XCTest Support for Swift Error Handling</strong> from <string>Chris Hanson</string> &lt;chanson at apple.com&gt;<p>January  9, 2016 at 06:00:00pm</p></header><div class="content"><p>We’d like feedback on a proposed design for adding support for Swift error handling to XCTest, attached below. I’ll mostly let the proposal speak for itself, but there are three components to it: Allowing test methods to throw errors, allowing the expressions evaluated by assertions to throw errors, and adding an assertion for checking error handling.<br></p><p>We’d love to hear your feedback. We’re particularly interested in some feedback on the idea of allowing the expressions evaluated by assertions to throw errors; it’s generated some debate because it results in writing test code slightly differently than other code that makes use of Swift error handling, so any thoughts on it would be particularly appreciated.<br></p><p>  -- Chris Hanson (chanson at apple.com &lt;mailto:chanson at apple.com&gt;)<br></p><p><br>XCTest Support for Swift Error Handling<br>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>Author(s): Chris Hanson &lt;https://github.com/eschaton&gt;<br>Status: Review<br>Review manager: TBD<br>Introduction<br>Swift 2 introduced a new error handling mechanism that, for completeness, needs to be accommodated by our testing frameworks. Right now, to write tests that involve methods that may throw an error, a developer needs to incorporate significant boilerplate into their test. We should move this into the framework in several ways, so tests of code that interacts with Swift error handling is concise and intention-revealing.<br></p><p>Motivation<br>Currently, if a developer wants to use a call that may throw an error in a test, they need to use Swift&#39;s do..catch construct in their test because tests are not themselves allowed to throw errors.<br></p><p>As an example, a vending machine object that has had insufficient funds deposited may throw an error if asked to vend an item. A test for that situation could reasonably use the do..catchconstruct to check that this occurs as expected. However, that means all other tests also need to use either a do..catch or try! construct — and the failure of a try! is catastrophic, so do..catch would be preferred simply for better reporting within tests.<br></p><p>func testVendingOneItem() {<br>    do {<br>        vendingMachine.deposit(5)<br>        let item = try vendingMachine.vend(row: 1, column: 1)<br>        XCTAssertEqual(item, &quot;Candy Bar&quot;)<br>    } catch {<br>        XCTFail(&quot;Unexpected failure: \(error)&quot;)<br>    }<br>}<br>If the implementation of VendingMachine.vend(row:column:) changes during development such that it throws an error in this situation, the test will fail as it should.<br></p><p>One other downside of the above is that a failure caught this way will be reported as an expected failure, which would normally be a failure for which XCTest is explicitly testing via an assertion. This failure should ideally be treated as an unexpected failure, as it&#39;s not one that&#39;s anticipated in the execution of the test.<br></p><p>In addition, tests do not currently support throwing an error from within an assertion, requiring any code that throws an error to be invoked outside the assertion itself using the same techniques described above.<br></p><p>Finally, since Swift error handling is a general mechanism that developers should be implementing in their own applications and frameworks, we need to make it straightforward to write tests that ensure code that implements error handling does so correctly.<br></p><p>Proposed solution<br>I propose several related solutions to this issue:<br></p><p>Allow test methods to throw errors.<br>Allow test assertion expressions to throw errors.<br>Add an assertion for checking errors.<br>These solutions combine to make writing tests that involve thrown errors much more succinct.<br></p><p>Allowing Test Methods to Throw Errors<br></p><p>First, we can allow test methods to throw errors if desired, thus allowing the do..catch construct to be omitted when the test isn&#39;t directly checking error handling. This makes the code a developer writes when they&#39;re not explicitly trying to test error handling much cleaner.<br></p><p>Moving the handling of errors thrown by tests into XCTest itself also ensures they can be treated as unexpected failures, since the mechanism to do so is currently private to the framework.<br></p><p>With this, the test from the previous section can become:<br></p><p>func testVendingOneItem() throws {<br>    vendingMachine.deposit(5)<br>    let item = try vendingMachine.vend(row: 1, column: 1)<br>    XCTAssertEqual(item, &quot;Candy Bar&quot;)<br>}<br>This shows much more directly that the test is intended to check a specific non-error case, and that the developer is relying on the framework to handle unexpected errors.<br></p><p>Allowing Test Assertions to Throw Errors<br></p><p>We can also allow the @autoclosure expression that is passed into an assertion to throw an error, and treat that error as an unexpected failure (since the code is being invoked in an assertion that isn&#39;t directly related to error handling). For example:<br></p><p>func testVendingMultipleItemsWithSufficientFunds() {<br>    vendingMachine.deposit(10)<br>    XCTAssertEqual(try vendingMachine.vend(row: 1, column: 1), &quot;Candy Bar&quot;)<br>    XCTAssertEqual(try vendingMachine.vend(row: 1, column: 2), &quot;Chips&quot;)<br>}<br>This can eliminate otherwise-dangerous uses of try! and streamline code that needs to make multiple assertions in a row.<br></p><p>Adding a &quot;Throws Error&quot; Assertion<br></p><p>In order to test code that throws an error, it would be useful to have an assertion that expects an error to be thrown in a particular case. Right now a developer writing code to test that an error is thrown has to test that error themselves:<br></p><p>    func testVendingFailsWithInsufficientFunds() {<br>        vendingMachine.deposit(1)<br>        var vendingFailed = false<br>        do {<br>            _ = try vendingMachine.vend(row: 1, column: 1))<br>        } catch {<br>            vendingFailed = true<br>        }<br>        XCTAssert(vendingFailed)<br>    }<br>If we add an assertion that specifically checks whether an error was thrown, this code will be significantly streamlined:<br></p><p>    func testVendingFailsWithInsufficientFunds() {<br>        vendingMachine.deposit(1)<br>        XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1))<br>    }<br>Of course, some code may want to just detect that an error was thrown, but other code may need to check that the details of the thrown error are correct. We can take advantage of Swift&#39;s trailing closure syntax to enable this, by passing the thrown error (if any) to a closure that can itself contain assertions:<br></p><p>    XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1)) { error in<br>        guard let vendingError = error as? VendingMachineError else {<br>            XCTFail(&quot;Unexpected type of error thrown: \(error)&quot;)<br>            return<br>        }<br>        <br>        XCTAssertEquals(vendingError.item, &quot;Candy Bar&quot;)<br>        XCTAssertEquals(vendingError.price, 5)<br>        XCTAssertEquals(vendingError.message, &quot;A Candy Bar costs 5 coins&quot;)<br>    }<br>This lets a developer very concisely describe an error condition for their code, in whatever level of detail they desire.<br></p><p>Detailed design<br>The design of each of the above components is slightly different, based on the functionality provided.<br></p><p>Tests That Throw<br></p><p>In order to enable test methods to throw an error, we will need to update XCTest to support test methods with a () throws -&gt; Void signature in addition to test methods with a () -&gt; Voidsignature as it already supports.<br></p><p>We will need to ensure tests that do throw an error have that error caught, and that it registers an unexpected failure.<br></p><p>Assertions That Throw<br></p><p>In order to allow assertions to throw an exception, we will need to enhance our existing assertions&#39; @autoclosure expression parameters to add throws to their signature.<br></p><p>Because Swift defines a closure that can throw an error to be a proper supertype of a closure that does not, this will not result in a combinatorial explosion of assertion overrides, and will let developers naturally write code that may throw an error within an assertion.<br></p><p>We will treat any error thrown from within an assertion expression as an unexpected failure because while all assertions represent a test for some form of failure, they&#39;re not specifically checking for a thrown error.<br></p><p>The &quot;Throws Error&quot; Assertion<br></p><p>To write tests for code that throws error, we will add a new assertion function to XCTest with the following prototype:<br></p><p>public func XCTAssertThrowsError(<br>    @autoclosure expression: () throws -&gt; Void,<br>                  _ message: String = &quot;&quot;,<br>                       file: StaticString = __FILE__,<br>                       line: UInt = __LINE__,<br>             _ errorHandler: (error: ErrorType) -&gt; Void = { _ in })<br>Rather than treat an error thrown from its expression as a failure, this will treat the lack of an error thrown from its expression as an expected failure.<br></p><p>Furthermore, so long as an error is thrown, the error will be passed to the errorHandler block passed as a trailing closure, where the developer may make further assertions against it.<br></p><p>In both cases, the new assertion function is generic on an ErrorType in order to ensure that little to no casting will be required in the trailing closure.<br></p><p>Impact on existing code<br>There should be little impact on existing test code because we are only adding features and API, not changing existing features or API.<br></p><p>All existing tests should continue to work as implemented, and can easily adopt the new conventions we&#39;re making available to become more concise and intention-revealing with respect to their error handling as shown above.<br></p><p>Alternatives considered<br>We considered asking developers continue using XCTest as-is, and encouraging them to use Swift&#39;s native error handling to both suppress and check the validity of errors. We also considered adding additional ways of registering failures when doing this, so that developers could register unexpected failures themselves.<br></p><p>While this would result in developers using the language the same way in their tests as in their functional code, this would also result in much more verbose tests. We rejected this approach because such verbosity can be a significant obstacle to testing.<br></p><p>Making it quick and clean to write tests for error handling could also encourage developers to implement error handling in their code as they need it, rather than to try to work around the feature because of any perceived difficulty in testing.<br></p><p>We considered adding the ability to check that a specific error was thrown in XCTAssertThrowsError, but this would require the ErrorType passed to also conform to Equatable, which is also unnecessary given that this can easily be checked in a trailing closure if desired. (In some cases a developer may just want to ensure an error is thrown rather than a specific error is thrown.)<br></p><p>We explicitly chose not to offer a comprehensive suite of DoesNotThrowError assertions for XCTest in Swift, though we do offer such DoesNotThrow assertions for XCTest in Objective-C. We feel these are of limited utility given that our plan is for all assertions (except XCTAssertThrowsError) to treat any thrown error as a failure.<br></p><p>We explicitly chose not to offer any additional support for Objective-C exceptions beyond what we already provide: In the Xcode implementation of XCTest, an Objective-C exception that occurs within one of our existing assertions or tests will result in a test failure; doing more than this is not practical given that it&#39;s possible to neither catch and handle nor generate an Objective-C exception in Swift.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/8e036da8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>Proposal: XCTest Support for Swift Error Handling</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>January 10, 2016 at 04:00:00am</p></header><div class="content"><p>I have on the order of ~700 tests in XCTest in Swift-language projects.  I&#39;m considering migrating away from XCTest, although not over this issue.<br></p><p>This proposal IMO addresses an important problem, but I am not convinced it actually solves it.  #2 &amp; #3 are basically sound API designs.  It is a mystery to me why #3 &quot;generated some debate&quot; as this is a feature I already implement manually, but I can&#39;t address unknown concerns.  I can tell you I implement this, and nothing terrible has happened to me so far.<br></p><p>#1 I would not use.  The rest of this comment explains why.<br></p><p>Currently I write tests about like this:<br></p><p>try! hopefullyNothingBad()<br></p><p>Now this is &quot;bad&quot; because it &quot;crashes&quot; but that&#39;s (big sigh) actually &quot;good&quot; because the debugger stops and/or I get a crash report that identifies at least &quot;some&quot; line where something bad definitely happened.<br></p><p>Now that is not everything I want to know–I want someone to tell me a story of how this error was created deep down in the bowels of my application, how it spent its kindergarten years in the models layer before being passed into a controller where it was rethrown onto a different dispatch queue and finally ended up in my unit test–but we can&#39;t have everything.  So I settle for collecting a line number from the test case and then going hunting by hand.<br></p><p>When the test function throws we no longer even find out a line number in the test case anymore, because the error is passed into XCTest and the information is lost.  We have just the name of the test case (I assume; the proposal is silent on this issue, but that&#39;s the only way I can think of to implement it), and some of my tests are pretty long.  So, that makes it even harder to track down.<br></p><p>This sounds like a small thing but my test coverage is so thorough on mature projects that mostly what I turn up are heisenbugs that reproduce with 2% probability.  So getting the report from the CI that has the most possible detail is critical, because if the report is not thorough enough for you to guess the bug, too bad, because that&#39;s all the information you get and the bug is not reproducible.<br></p><p>For that reason, I won&#39;t use #1.  I hesitate about whether to call it bad idea altogether, or whether it&#39;s just not to my taste.  My sense is it&#39;s probably somewhere in the middle of those two poles.<br></p><p>I would use #2 and #3, assuming that I don&#39;t first migrate out to a non-XCTest framework.<br></p><p><br></p><p>&gt; On Jan 9, 2016, at 8:58 PM, Chris Hanson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We’d like feedback on a proposed design for adding support for Swift error handling to XCTest, attached below. I’ll mostly let the proposal speak for itself, but there are three components to it: Allowing test methods to throw errors, allowing the expressions evaluated by assertions to throw errors, and adding an assertion for checking error handling.<br>&gt; <br>&gt; We’d love to hear your feedback. We’re particularly interested in some feedback on the idea of allowing the expressions evaluated by assertions to throw errors; it’s generated some debate because it results in writing test code slightly differently than other code that makes use of Swift error handling, so any thoughts on it would be particularly appreciated.<br>&gt; <br>&gt;   -- Chris Hanson (chanson at apple.com &lt;mailto:chanson at apple.com&gt;)<br>&gt; <br>&gt; <br>&gt; XCTest Support for Swift Error Handling<br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt; Author(s): Chris Hanson &lt;https://github.com/eschaton&gt;<br>&gt; Status: Review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; Swift 2 introduced a new error handling mechanism that, for completeness, needs to be accommodated by our testing frameworks. Right now, to write tests that involve methods that may throw an error, a developer needs to incorporate significant boilerplate into their test. We should move this into the framework in several ways, so tests of code that interacts with Swift error handling is concise and intention-revealing.<br>&gt; <br>&gt; Motivation<br>&gt; Currently, if a developer wants to use a call that may throw an error in a test, they need to use Swift&#39;s do..catch construct in their test because tests are not themselves allowed to throw errors.<br>&gt; <br>&gt; As an example, a vending machine object that has had insufficient funds deposited may throw an error if asked to vend an item. A test for that situation could reasonably use the do..catchconstruct to check that this occurs as expected. However, that means all other tests also need to use either a do..catch or try! construct — and the failure of a try! is catastrophic, so do..catch would be preferred simply for better reporting within tests.<br>&gt; <br>&gt; func testVendingOneItem() {<br>&gt;     do {<br>&gt;         vendingMachine.deposit(5)<br>&gt;         let item = try vendingMachine.vend(row: 1, column: 1)<br>&gt;         XCTAssertEqual(item, &quot;Candy Bar&quot;)<br>&gt;     } catch {<br>&gt;         XCTFail(&quot;Unexpected failure: \(error)&quot;)<br>&gt;     }<br>&gt; }<br>&gt; If the implementation of VendingMachine.vend(row:column:) changes during development such that it throws an error in this situation, the test will fail as it should.<br>&gt; <br>&gt; One other downside of the above is that a failure caught this way will be reported as an expected failure, which would normally be a failure for which XCTest is explicitly testing via an assertion. This failure should ideally be treated as an unexpected failure, as it&#39;s not one that&#39;s anticipated in the execution of the test.<br>&gt; <br>&gt; In addition, tests do not currently support throwing an error from within an assertion, requiring any code that throws an error to be invoked outside the assertion itself using the same techniques described above.<br>&gt; <br>&gt; Finally, since Swift error handling is a general mechanism that developers should be implementing in their own applications and frameworks, we need to make it straightforward to write tests that ensure code that implements error handling does so correctly.<br>&gt; <br>&gt; Proposed solution<br>&gt; I propose several related solutions to this issue:<br>&gt; <br>&gt; Allow test methods to throw errors.<br>&gt; Allow test assertion expressions to throw errors.<br>&gt; Add an assertion for checking errors.<br>&gt; These solutions combine to make writing tests that involve thrown errors much more succinct.<br>&gt; <br>&gt; Allowing Test Methods to Throw Errors<br>&gt; <br>&gt; First, we can allow test methods to throw errors if desired, thus allowing the do..catch construct to be omitted when the test isn&#39;t directly checking error handling. This makes the code a developer writes when they&#39;re not explicitly trying to test error handling much cleaner.<br>&gt; <br>&gt; Moving the handling of errors thrown by tests into XCTest itself also ensures they can be treated as unexpected failures, since the mechanism to do so is currently private to the framework.<br>&gt; <br>&gt; With this, the test from the previous section can become:<br>&gt; <br>&gt; func testVendingOneItem() throws {<br>&gt;     vendingMachine.deposit(5)<br>&gt;     let item = try vendingMachine.vend(row: 1, column: 1)<br>&gt;     XCTAssertEqual(item, &quot;Candy Bar&quot;)<br>&gt; }<br>&gt; This shows much more directly that the test is intended to check a specific non-error case, and that the developer is relying on the framework to handle unexpected errors.<br>&gt; <br>&gt; Allowing Test Assertions to Throw Errors<br>&gt; <br>&gt; We can also allow the @autoclosure expression that is passed into an assertion to throw an error, and treat that error as an unexpected failure (since the code is being invoked in an assertion that isn&#39;t directly related to error handling). For example:<br>&gt; <br>&gt; func testVendingMultipleItemsWithSufficientFunds() {<br>&gt;     vendingMachine.deposit(10)<br>&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 1), &quot;Candy Bar&quot;)<br>&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 2), &quot;Chips&quot;)<br>&gt; }<br>&gt; This can eliminate otherwise-dangerous uses of try! and streamline code that needs to make multiple assertions in a row.<br>&gt; <br>&gt; Adding a &quot;Throws Error&quot; Assertion<br>&gt; <br>&gt; In order to test code that throws an error, it would be useful to have an assertion that expects an error to be thrown in a particular case. Right now a developer writing code to test that an error is thrown has to test that error themselves:<br>&gt; <br>&gt;     func testVendingFailsWithInsufficientFunds() {<br>&gt;         vendingMachine.deposit(1)<br>&gt;         var vendingFailed = false<br>&gt;         do {<br>&gt;             _ = try vendingMachine.vend(row: 1, column: 1))<br>&gt;         } catch {<br>&gt;             vendingFailed = true<br>&gt;         }<br>&gt;         XCTAssert(vendingFailed)<br>&gt;     }<br>&gt; If we add an assertion that specifically checks whether an error was thrown, this code will be significantly streamlined:<br>&gt; <br>&gt;     func testVendingFailsWithInsufficientFunds() {<br>&gt;         vendingMachine.deposit(1)<br>&gt;         XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1))<br>&gt;     }<br>&gt; Of course, some code may want to just detect that an error was thrown, but other code may need to check that the details of the thrown error are correct. We can take advantage of Swift&#39;s trailing closure syntax to enable this, by passing the thrown error (if any) to a closure that can itself contain assertions:<br>&gt; <br>&gt;     XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1)) { error in<br>&gt;         guard let vendingError = error as? VendingMachineError else {<br>&gt;             XCTFail(&quot;Unexpected type of error thrown: \(error)&quot;)<br>&gt;             return<br>&gt;         }<br>&gt;         <br>&gt;         XCTAssertEquals(vendingError.item, &quot;Candy Bar&quot;)<br>&gt;         XCTAssertEquals(vendingError.price, 5)<br>&gt;         XCTAssertEquals(vendingError.message, &quot;A Candy Bar costs 5 coins&quot;)<br>&gt;     }<br>&gt; This lets a developer very concisely describe an error condition for their code, in whatever level of detail they desire.<br>&gt; <br>&gt; Detailed design<br>&gt; The design of each of the above components is slightly different, based on the functionality provided.<br>&gt; <br>&gt; Tests That Throw<br>&gt; <br>&gt; In order to enable test methods to throw an error, we will need to update XCTest to support test methods with a () throws -&gt; Void signature in addition to test methods with a () -&gt; Voidsignature as it already supports.<br>&gt; <br>&gt; We will need to ensure tests that do throw an error have that error caught, and that it registers an unexpected failure.<br>&gt; <br>&gt; Assertions That Throw<br>&gt; <br>&gt; In order to allow assertions to throw an exception, we will need to enhance our existing assertions&#39; @autoclosure expression parameters to add throws to their signature.<br>&gt; <br>&gt; Because Swift defines a closure that can throw an error to be a proper supertype of a closure that does not, this will not result in a combinatorial explosion of assertion overrides, and will let developers naturally write code that may throw an error within an assertion.<br>&gt; <br>&gt; We will treat any error thrown from within an assertion expression as an unexpected failure because while all assertions represent a test for some form of failure, they&#39;re not specifically checking for a thrown error.<br>&gt; <br>&gt; The &quot;Throws Error&quot; Assertion<br>&gt; <br>&gt; To write tests for code that throws error, we will add a new assertion function to XCTest with the following prototype:<br>&gt; <br>&gt; public func XCTAssertThrowsError(<br>&gt;     @autoclosure expression: () throws -&gt; Void,<br>&gt;                   _ message: String = &quot;&quot;,<br>&gt;                        file: StaticString = __FILE__,<br>&gt;                        line: UInt = __LINE__,<br>&gt;              _ errorHandler: (error: ErrorType) -&gt; Void = { _ in })<br>&gt; Rather than treat an error thrown from its expression as a failure, this will treat the lack of an error thrown from its expression as an expected failure.<br>&gt; <br>&gt; Furthermore, so long as an error is thrown, the error will be passed to the errorHandler block passed as a trailing closure, where the developer may make further assertions against it.<br>&gt; <br>&gt; In both cases, the new assertion function is generic on an ErrorType in order to ensure that little to no casting will be required in the trailing closure.<br>&gt; <br>&gt; Impact on existing code<br>&gt; There should be little impact on existing test code because we are only adding features and API, not changing existing features or API.<br>&gt; <br>&gt; All existing tests should continue to work as implemented, and can easily adopt the new conventions we&#39;re making available to become more concise and intention-revealing with respect to their error handling as shown above.<br>&gt; <br>&gt; Alternatives considered<br>&gt; We considered asking developers continue using XCTest as-is, and encouraging them to use Swift&#39;s native error handling to both suppress and check the validity of errors. We also considered adding additional ways of registering failures when doing this, so that developers could register unexpected failures themselves.<br>&gt; <br>&gt; While this would result in developers using the language the same way in their tests as in their functional code, this would also result in much more verbose tests. We rejected this approach because such verbosity can be a significant obstacle to testing.<br>&gt; <br>&gt; Making it quick and clean to write tests for error handling could also encourage developers to implement error handling in their code as they need it, rather than to try to work around the feature because of any perceived difficulty in testing.<br>&gt; <br>&gt; We considered adding the ability to check that a specific error was thrown in XCTAssertThrowsError, but this would require the ErrorType passed to also conform to Equatable, which is also unnecessary given that this can easily be checked in a trailing closure if desired. (In some cases a developer may just want to ensure an error is thrown rather than a specific error is thrown.)<br>&gt; <br>&gt; We explicitly chose not to offer a comprehensive suite of DoesNotThrowError assertions for XCTest in Swift, though we do offer such DoesNotThrow assertions for XCTest in Objective-C. We feel these are of limited utility given that our plan is for all assertions (except XCTAssertThrowsError) to treat any thrown error as a failure.<br>&gt; <br>&gt; We explicitly chose not to offer any additional support for Objective-C exceptions beyond what we already provide: In the Xcode implementation of XCTest, an Objective-C exception that occurs within one of our existing assertions or tests will result in a test failure; doing more than this is not practical given that it&#39;s possible to neither catch and handle nor generate an Objective-C exception in Swift.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/1fed8001/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Proposal: XCTest Support for Swift Error Handling</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January 10, 2016 at 12:00:00pm</p></header><div class="content"><p>I would love it if we could do a full review of XCtest in general. As there are other things it could help with I.r mocking or allowing us to express tests in a BDD way <br></p><p>Sent from my iPhone<br></p><p>&gt; On 10 Jan 2016, at 10:29, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have on the order of ~700 tests in XCTest in Swift-language projects.  I&#39;m considering migrating away from XCTest, although not over this issue.<br>&gt; <br>&gt; This proposal IMO addresses an important problem, but I am not convinced it actually solves it.  #2 &amp; #3 are basically sound API designs.  It is a mystery to me why #3 &quot;generated some debate&quot; as this is a feature I already implement manually, but I can&#39;t address unknown concerns.  I can tell you I implement this, and nothing terrible has happened to me so far.<br>&gt; <br>&gt; #1 I would not use.  The rest of this comment explains why.<br>&gt; <br>&gt; Currently I write tests about like this:<br>&gt; <br>&gt; try! hopefullyNothingBad()<br>&gt; <br>&gt; Now this is &quot;bad&quot; because it &quot;crashes&quot; but that&#39;s (big sigh) actually &quot;good&quot; because the debugger stops and/or I get a crash report that identifies at least &quot;some&quot; line where something bad definitely happened.<br>&gt; <br>&gt; Now that is not everything I want to know–I want someone to tell me a story of how this error was created deep down in the bowels of my application, how it spent its kindergarten years in the models layer before being passed into a controller where it was rethrown onto a different dispatch queue and finally ended up in my unit test–but we can&#39;t have everything.  So I settle for collecting a line number from the test case and then going hunting by hand.<br>&gt; <br>&gt; When the test function throws we no longer even find out a line number in the test case anymore, because the error is passed into XCTest and the information is lost.  We have just the name of the test case (I assume; the proposal is silent on this issue, but that&#39;s the only way I can think of to implement it), and some of my tests are pretty long.  So, that makes it even harder to track down.<br>&gt; <br>&gt; This sounds like a small thing but my test coverage is so thorough on mature projects that mostly what I turn up are heisenbugs that reproduce with 2% probability.  So getting the report from the CI that has the most possible detail is critical, because if the report is not thorough enough for you to guess the bug, too bad, because that&#39;s all the information you get and the bug is not reproducible.<br>&gt; <br>&gt; For that reason, I won&#39;t use #1.  I hesitate about whether to call it bad idea altogether, or whether it&#39;s just not to my taste.  My sense is it&#39;s probably somewhere in the middle of those two poles.<br>&gt; <br>&gt; I would use #2 and #3, assuming that I don&#39;t first migrate out to a non-XCTest framework.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jan 9, 2016, at 8:58 PM, Chris Hanson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We’d like feedback on a proposed design for adding support for Swift error handling to XCTest, attached below. I’ll mostly let the proposal speak for itself, but there are three components to it: Allowing test methods to throw errors, allowing the expressions evaluated by assertions to throw errors, and adding an assertion for checking error handling.<br>&gt;&gt; <br>&gt;&gt; We’d love to hear your feedback. We’re particularly interested in some feedback on the idea of allowing the expressions evaluated by assertions to throw errors; it’s generated some debate because it results in writing test code slightly differently than other code that makes use of Swift error handling, so any thoughts on it would be particularly appreciated.<br>&gt;&gt; <br>&gt;&gt;   -- Chris Hanson (chanson at apple.com)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; XCTest Support for Swift Error Handling<br>&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt; Author(s): Chris Hanson<br>&gt;&gt; Status: Review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; Swift 2 introduced a new error handling mechanism that, for completeness, needs to be accommodated by our testing frameworks. Right now, to write tests that involve methods that may throw an error, a developer needs to incorporate significant boilerplate into their test. We should move this into the framework in several ways, so tests of code that interacts with Swift error handling is concise and intention-revealing.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; Currently, if a developer wants to use a call that may throw an error in a test, they need to use Swift&#39;s do..catch construct in their test because tests are not themselves allowed to throw errors.<br>&gt;&gt; <br>&gt;&gt; As an example, a vending machine object that has had insufficient funds deposited may throw an error if asked to vend an item. A test for that situation could reasonably use the do..catchconstruct to check that this occurs as expected. However, that means all other tests also need to use either a do..catch or try! construct — and the failure of a try! is catastrophic, so do..catch would be preferred simply for better reporting within tests.<br>&gt;&gt; <br>&gt;&gt; func testVendingOneItem() {<br>&gt;&gt;     do {<br>&gt;&gt;         vendingMachine.deposit(5)<br>&gt;&gt;         let item = try vendingMachine.vend(row: 1, column: 1)<br>&gt;&gt;         XCTAssertEqual(item, &quot;Candy Bar&quot;)<br>&gt;&gt;     } catch {<br>&gt;&gt;         XCTFail(&quot;Unexpected failure: \(error)&quot;)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; If the implementation of VendingMachine.vend(row:column:) changes during development such that it throws an error in this situation, the test will fail as it should.<br>&gt;&gt; <br>&gt;&gt; One other downside of the above is that a failure caught this way will be reported as an expected failure, which would normally be a failure for which XCTest is explicitly testing via an assertion. This failure should ideally be treated as an unexpected failure, as it&#39;s not one that&#39;s anticipated in the execution of the test.<br>&gt;&gt; <br>&gt;&gt; In addition, tests do not currently support throwing an error from within an assertion, requiring any code that throws an error to be invoked outside the assertion itself using the same techniques described above.<br>&gt;&gt; <br>&gt;&gt; Finally, since Swift error handling is a general mechanism that developers should be implementing in their own applications and frameworks, we need to make it straightforward to write tests that ensure code that implements error handling does so correctly.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; I propose several related solutions to this issue:<br>&gt;&gt; <br>&gt;&gt; Allow test methods to throw errors.<br>&gt;&gt; Allow test assertion expressions to throw errors.<br>&gt;&gt; Add an assertion for checking errors.<br>&gt;&gt; These solutions combine to make writing tests that involve thrown errors much more succinct.<br>&gt;&gt; <br>&gt;&gt; Allowing Test Methods to Throw Errors<br>&gt;&gt; <br>&gt;&gt; First, we can allow test methods to throw errors if desired, thus allowing the do..catch construct to be omitted when the test isn&#39;t directly checking error handling. This makes the code a developer writes when they&#39;re not explicitly trying to test error handling much cleaner.<br>&gt;&gt; <br>&gt;&gt; Moving the handling of errors thrown by tests into XCTest itself also ensures they can be treated as unexpected failures, since the mechanism to do so is currently private to the framework.<br>&gt;&gt; <br>&gt;&gt; With this, the test from the previous section can become:<br>&gt;&gt; <br>&gt;&gt; func testVendingOneItem() throws {<br>&gt;&gt;     vendingMachine.deposit(5)<br>&gt;&gt;     let item = try vendingMachine.vend(row: 1, column: 1)<br>&gt;&gt;     XCTAssertEqual(item, &quot;Candy Bar&quot;)<br>&gt;&gt; }<br>&gt;&gt; This shows much more directly that the test is intended to check a specific non-error case, and that the developer is relying on the framework to handle unexpected errors.<br>&gt;&gt; <br>&gt;&gt; Allowing Test Assertions to Throw Errors<br>&gt;&gt; <br>&gt;&gt; We can also allow the @autoclosure expression that is passed into an assertion to throw an error, and treat that error as an unexpected failure (since the code is being invoked in an assertion that isn&#39;t directly related to error handling). For example:<br>&gt;&gt; <br>&gt;&gt; func testVendingMultipleItemsWithSufficientFunds() {<br>&gt;&gt;     vendingMachine.deposit(10)<br>&gt;&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 1), &quot;Candy Bar&quot;)<br>&gt;&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 2), &quot;Chips&quot;)<br>&gt;&gt; }<br>&gt;&gt; This can eliminate otherwise-dangerous uses of try! and streamline code that needs to make multiple assertions in a row.<br>&gt;&gt; <br>&gt;&gt; Adding a &quot;Throws Error&quot; Assertion<br>&gt;&gt; <br>&gt;&gt; In order to test code that throws an error, it would be useful to have an assertion that expects an error to be thrown in a particular case. Right now a developer writing code to test that an error is thrown has to test that error themselves:<br>&gt;&gt; <br>&gt;&gt;     func testVendingFailsWithInsufficientFunds() {<br>&gt;&gt;         vendingMachine.deposit(1)<br>&gt;&gt;         var vendingFailed = false<br>&gt;&gt;         do {<br>&gt;&gt;             _ = try vendingMachine.vend(row: 1, column: 1))<br>&gt;&gt;         } catch {<br>&gt;&gt;             vendingFailed = true<br>&gt;&gt;         }<br>&gt;&gt;         XCTAssert(vendingFailed)<br>&gt;&gt;     }<br>&gt;&gt; If we add an assertion that specifically checks whether an error was thrown, this code will be significantly streamlined:<br>&gt;&gt; <br>&gt;&gt;     func testVendingFailsWithInsufficientFunds() {<br>&gt;&gt;         vendingMachine.deposit(1)<br>&gt;&gt;         XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1))<br>&gt;&gt;     }<br>&gt;&gt; Of course, some code may want to just detect that an error was thrown, but other code may need to check that the details of the thrown error are correct. We can take advantage of Swift&#39;s trailing closure syntax to enable this, by passing the thrown error (if any) to a closure that can itself contain assertions:<br>&gt;&gt; <br>&gt;&gt;     XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1)) { error in<br>&gt;&gt;         guard let vendingError = error as? VendingMachineError else {<br>&gt;&gt;             XCTFail(&quot;Unexpected type of error thrown: \(error)&quot;)<br>&gt;&gt;             return<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         XCTAssertEquals(vendingError.item, &quot;Candy Bar&quot;)<br>&gt;&gt;         XCTAssertEquals(vendingError.price, 5)<br>&gt;&gt;         XCTAssertEquals(vendingError.message, &quot;A Candy Bar costs 5 coins&quot;)<br>&gt;&gt;     }<br>&gt;&gt; This lets a developer very concisely describe an error condition for their code, in whatever level of detail they desire.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; The design of each of the above components is slightly different, based on the functionality provided.<br>&gt;&gt; <br>&gt;&gt; Tests That Throw<br>&gt;&gt; <br>&gt;&gt; In order to enable test methods to throw an error, we will need to update XCTest to support test methods with a () throws -&gt; Void signature in addition to test methods with a () -&gt; Voidsignature as it already supports.<br>&gt;&gt; <br>&gt;&gt; We will need to ensure tests that do throw an error have that error caught, and that it registers an unexpected failure.<br>&gt;&gt; <br>&gt;&gt; Assertions That Throw<br>&gt;&gt; <br>&gt;&gt; In order to allow assertions to throw an exception, we will need to enhance our existing assertions&#39; @autoclosure expression parameters to add throws to their signature.<br>&gt;&gt; <br>&gt;&gt; Because Swift defines a closure that can throw an error to be a proper supertype of a closure that does not, this will not result in a combinatorial explosion of assertion overrides, and will let developers naturally write code that may throw an error within an assertion.<br>&gt;&gt; <br>&gt;&gt; We will treat any error thrown from within an assertion expression as an unexpected failure because while all assertions represent a test for some form of failure, they&#39;re not specifically checking for a thrown error.<br>&gt;&gt; <br>&gt;&gt; The &quot;Throws Error&quot; Assertion<br>&gt;&gt; <br>&gt;&gt; To write tests for code that throws error, we will add a new assertion function to XCTest with the following prototype:<br>&gt;&gt; <br>&gt;&gt; public func XCTAssertThrowsError(<br>&gt;&gt;     @autoclosure expression: () throws -&gt; Void,<br>&gt;&gt;                   _ message: String = &quot;&quot;,<br>&gt;&gt;                        file: StaticString = __FILE__,<br>&gt;&gt;                        line: UInt = __LINE__,<br>&gt;&gt;              _ errorHandler: (error: ErrorType) -&gt; Void = { _ in })<br>&gt;&gt; Rather than treat an error thrown from its expression as a failure, this will treat the lack of an error thrown from its expression as an expected failure.<br>&gt;&gt; <br>&gt;&gt; Furthermore, so long as an error is thrown, the error will be passed to the errorHandler block passed as a trailing closure, where the developer may make further assertions against it.<br>&gt;&gt; <br>&gt;&gt; In both cases, the new assertion function is generic on an ErrorType in order to ensure that little to no casting will be required in the trailing closure.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; There should be little impact on existing test code because we are only adding features and API, not changing existing features or API.<br>&gt;&gt; <br>&gt;&gt; All existing tests should continue to work as implemented, and can easily adopt the new conventions we&#39;re making available to become more concise and intention-revealing with respect to their error handling as shown above.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; We considered asking developers continue using XCTest as-is, and encouraging them to use Swift&#39;s native error handling to both suppress and check the validity of errors. We also considered adding additional ways of registering failures when doing this, so that developers could register unexpected failures themselves.<br>&gt;&gt; <br>&gt;&gt; While this would result in developers using the language the same way in their tests as in their functional code, this would also result in much more verbose tests. We rejected this approach because such verbosity can be a significant obstacle to testing.<br>&gt;&gt; <br>&gt;&gt; Making it quick and clean to write tests for error handling could also encourage developers to implement error handling in their code as they need it, rather than to try to work around the feature because of any perceived difficulty in testing.<br>&gt;&gt; <br>&gt;&gt; We considered adding the ability to check that a specific error was thrown in XCTAssertThrowsError, but this would require the ErrorType passed to also conform to Equatable, which is also unnecessary given that this can easily be checked in a trailing closure if desired. (In some cases a developer may just want to ensure an error is thrown rather than a specific error is thrown.)<br>&gt;&gt; <br>&gt;&gt; We explicitly chose not to offer a comprehensive suite of DoesNotThrowError assertions for XCTest in Swift, though we do offer such DoesNotThrow assertions for XCTest in Objective-C. We feel these are of limited utility given that our plan is for all assertions (except XCTAssertThrowsError) to treat any thrown error as a failure.<br>&gt;&gt; <br>&gt;&gt; We explicitly chose not to offer any additional support for Objective-C exceptions beyond what we already provide: In the Xcode implementation of XCTest, an Objective-C exception that occurs within one of our existing assertions or tests will result in a test failure; doing more than this is not practical given that it&#39;s possible to neither catch and handle nor generate an Objective-C exception in Swift.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/db9f8532/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>Proposal: XCTest Support for Swift Error Handling</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>January 10, 2016 at 03:00:00pm</p></header><div class="content"><p>I&#39;ve been wondering for a while, while writing unit tests, why we still<br>start with &quot;func test[behaviourOfThing]() {&quot; and not &quot;test behaviourOfThing<br>{&quot;. It&#39;s not just about less typing: parsing a function for the &#39;test&#39;<br>prefix is an Objective C holdover, and doesn&#39;t feel Swift to me, and it has<br>tests behaving like functions when - as illustrated in this proposal - they<br>should have different behaviours. It should be clearer when reading code<br>whether a function is a test or a helper function to make tests easier to<br>write.<br></p><p><br></p><p>On Sun, Jan 10, 2016 at 12:34 PM, James Campbell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I would love it if we could do a full review of XCtest in general. As<br>&gt; there are other things it could help with I.r mocking or allowing us to<br>&gt; express tests in a BDD way<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On 10 Jan 2016, at 10:29, Drew Crawford via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I have on the order of ~700 tests in XCTest in Swift-language projects.<br>&gt; I&#39;m considering migrating away from XCTest, although not over this issue.<br>&gt;<br>&gt; This proposal IMO addresses an important problem, but I am not convinced<br>&gt; it actually solves it.  #2 &amp; #3 are basically sound API designs.  It is a<br>&gt; mystery to me why #3 &quot;generated some debate&quot; as this is a feature I already<br>&gt; implement manually, but I can&#39;t address unknown concerns.  I can tell you I<br>&gt; implement this, and nothing terrible has happened to me so far.<br>&gt;<br>&gt; #1 I would not use.  The rest of this comment explains why.<br>&gt;<br>&gt; Currently I write tests about like this:<br>&gt;<br>&gt; try! hopefullyNothingBad()<br>&gt;<br>&gt;<br>&gt; Now this is &quot;bad&quot; because it &quot;crashes&quot; but that&#39;s (big sigh) actually<br>&gt; &quot;good&quot; because the debugger stops and/or I get a crash report that<br>&gt; identifies at least &quot;some&quot; line where something bad definitely happened.<br>&gt;<br>&gt; Now that is not everything I *want* to know–I *want* someone to tell me a<br>&gt; story of how this error was created deep down in the bowels of my<br>&gt; application, how it spent its kindergarten years in the models layer before<br>&gt; being passed into a controller where it was rethrown onto a different<br>&gt; dispatch queue and finally ended up in my unit test–but we can&#39;t have<br>&gt; everything.  So I settle for collecting a line number from the test case<br>&gt; and then going hunting by hand.<br>&gt;<br>&gt; When the test function throws we no longer even find out a line number in<br>&gt; the test case anymore, because the error is passed into XCTest and the<br>&gt; information is lost.  We have just the name of the test case (I assume; the<br>&gt; proposal is silent on this issue, but that&#39;s the only way I can think of to<br>&gt; implement it), and some of my tests are pretty long.  So, that makes it<br>&gt; even harder to track down.<br>&gt;<br>&gt; This sounds like a small thing but my test coverage is so thorough on<br>&gt; mature projects that mostly what I turn up are heisenbugs that reproduce<br>&gt; with 2% probability.  So getting the report from the CI that has the most<br>&gt; possible detail is critical, because if the report is not thorough enough<br>&gt; for you to guess the bug, too bad, because that&#39;s all the information you<br>&gt; get and the bug is not reproducible.<br>&gt;<br>&gt; For that reason, I won&#39;t use #1.  I hesitate about whether to call it bad<br>&gt; idea altogether, or whether it&#39;s just not to my taste.  My sense is it&#39;s<br>&gt; probably somewhere in the middle of those two poles.<br>&gt;<br>&gt; I would use #2 and #3, assuming that I don&#39;t first migrate out to a<br>&gt; non-XCTest framework.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Jan 9, 2016, at 8:58 PM, Chris Hanson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; We’d like feedback on a proposed design for adding support for Swift error<br>&gt; handling to XCTest, attached below. I’ll mostly let the proposal speak for<br>&gt; itself, but there are three components to it: Allowing test methods to<br>&gt; throw errors, allowing the expressions evaluated by assertions to throw<br>&gt; errors, and adding an assertion for checking error handling.<br>&gt;<br>&gt; We’d love to hear your feedback. We’re particularly interested in some<br>&gt; feedback on the idea of allowing the expressions evaluated by assertions to<br>&gt; throw errors; it’s generated some debate because it results in writing test<br>&gt; code slightly differently than other code that makes use of Swift error<br>&gt; handling, so any thoughts on it would be particularly appreciated.<br>&gt;<br>&gt;   -- Chris Hanson (chanson at apple.com)<br>&gt;<br>&gt;<br>&gt; XCTest Support for Swift Error Handling<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;    - Author(s): Chris Hanson &lt;https://github.com/eschaton&gt;<br>&gt;    - Status: *Review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Swift 2 introduced a new error handling mechanism that, for completeness,<br>&gt; needs to be accommodated by our testing frameworks. Right now, to write<br>&gt; tests that involve methods that may throw an error, a developer needs to<br>&gt; incorporate significant boilerplate into their test. We should move this<br>&gt; into the framework in several ways, so tests of code that interacts with<br>&gt; Swift error handling is concise and intention-revealing.<br>&gt; Motivation<br>&gt;<br>&gt; Currently, if a developer wants to use a call that may throw an error in a<br>&gt; test, they need to use Swift&#39;s do..catch construct in their test because<br>&gt; tests are not themselves allowed to throw errors.<br>&gt;<br>&gt; As an example, a vending machine object that has had insufficient funds<br>&gt; deposited may throw an error if asked to vend an item. A test for that<br>&gt; situation could reasonably use the do..catchconstruct to check that this<br>&gt; occurs as expected. However, that means all other tests *also* need to<br>&gt; use either a do..catch or try! construct — and the failure of a try! is<br>&gt; catastrophic, so do..catch would be preferred simply for better reporting<br>&gt; within tests.<br>&gt;<br>&gt; func testVendingOneItem() {<br>&gt;     do {<br>&gt;         vendingMachine.deposit(5)<br>&gt;         let item = try vendingMachine.vend(row: 1, column: 1)<br>&gt;         XCTAssertEqual(item, &quot;Candy Bar&quot;)<br>&gt;     } catch {<br>&gt;         XCTFail(&quot;Unexpected failure: \(error)&quot;)<br>&gt;     }}<br>&gt;<br>&gt; If the implementation of VendingMachine.vend(row:column:) changes during<br>&gt; development such that it throws an error in this situation, the test will<br>&gt; fail as it should.<br>&gt;<br>&gt; One other downside of the above is that a failure caught this way will be<br>&gt; reported as an *expected failure*, which would normally be a failure for<br>&gt; which XCTest is explicitly testing via an assertion. This failure should<br>&gt; ideally be treated as an *unexpected failure*, as it&#39;s not one that&#39;s<br>&gt; anticipated in the execution of the test.<br>&gt;<br>&gt; In addition, tests do not currently support throwing an error from within<br>&gt; an assertion, requiring any code that throws an error to be invoked outside<br>&gt; the assertion itself using the same techniques described above.<br>&gt;<br>&gt; Finally, since Swift error handling is a general mechanism that developers<br>&gt; should be implementing in their own applications and frameworks, we need to<br>&gt; make it straightforward to write tests that ensure code that implements<br>&gt; error handling does so correctly.<br>&gt; Proposed solution<br>&gt;<br>&gt; I propose several related solutions to this issue:<br>&gt;<br>&gt;    1. Allow test methods to throw errors.<br>&gt;    2. Allow test assertion expressions to throw errors.<br>&gt;    3. Add an assertion for checking errors.<br>&gt;<br>&gt; These solutions combine to make writing tests that involve thrown errors<br>&gt; much more succinct.<br>&gt; Allowing Test Methods to Throw Errors<br>&gt;<br>&gt; First, we can allow test methods to throw errors if desired, thus allowing<br>&gt; the do..catch construct to be omitted when the test isn&#39;t directly<br>&gt; checking error handling. This makes the code a developer writes when<br>&gt; they&#39;re not explicitly trying to test error handling much cleaner.<br>&gt;<br>&gt; Moving the handling of errors thrown by tests into XCTest itself also<br>&gt; ensures they can be treated as unexpected failures, since the mechanism to<br>&gt; do so is currently private to the framework.<br>&gt;<br>&gt; With this, the test from the previous section can become:<br>&gt;<br>&gt; func testVendingOneItem() throws {<br>&gt;     vendingMachine.deposit(5)<br>&gt;     let item = try vendingMachine.vend(row: 1, column: 1)<br>&gt;     XCTAssertEqual(item, &quot;Candy Bar&quot;)}<br>&gt;<br>&gt; This shows much more directly that the test is intended to check a<br>&gt; specific non-error case, and that the developer is relying on the framework<br>&gt; to handle unexpected errors.<br>&gt; Allowing Test Assertions to Throw Errors<br>&gt;<br>&gt; We can also allow the @autoclosure expression that is passed into an<br>&gt; assertion to throw an error, and treat that error as an unexpected failure<br>&gt; (since the code is being invoked in an assertion that isn&#39;t directly<br>&gt; related to error handling). For example:<br>&gt;<br>&gt; func testVendingMultipleItemsWithSufficientFunds() {<br>&gt;     vendingMachine.deposit(10)<br>&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 1), &quot;Candy Bar&quot;)<br>&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 2), &quot;Chips&quot;)}<br>&gt;<br>&gt; This can eliminate otherwise-dangerous uses of try! and streamline code<br>&gt; that needs to make multiple assertions in a row.<br>&gt; Adding a &quot;Throws Error&quot; Assertion<br>&gt;<br>&gt; In order to test code that throws an error, it would be useful to have an<br>&gt; assertion that expects an error to be thrown in a particular case. Right<br>&gt; now a developer writing code to test that an error is thrown has to test<br>&gt; that error themselves:<br>&gt;<br>&gt;     func testVendingFailsWithInsufficientFunds() {<br>&gt;         vendingMachine.deposit(1)<br>&gt;         var vendingFailed = false<br>&gt;         do {<br>&gt;             _ = try vendingMachine.vend(row: 1, column: 1))<br>&gt;         } catch {<br>&gt;             vendingFailed = true<br>&gt;         }<br>&gt;         XCTAssert(vendingFailed)<br>&gt;     }<br>&gt;<br>&gt; If we add an assertion that specifically checks whether an error was<br>&gt; thrown, this code will be significantly streamlined:<br>&gt;<br>&gt;     func testVendingFailsWithInsufficientFunds() {<br>&gt;         vendingMachine.deposit(1)<br>&gt;         XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1))<br>&gt;     }<br>&gt;<br>&gt; Of course, some code may want to just detect that an error was thrown, but<br>&gt; other code may need to check that the details of the thrown error are<br>&gt; correct. We can take advantage of Swift&#39;s trailing closure syntax to enable<br>&gt; this, by passing the thrown error (if any) to a closure that can itself<br>&gt; contain assertions:<br>&gt;<br>&gt;     XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1)) { error in<br>&gt;         guard let vendingError = error as? VendingMachineError else {<br>&gt;             XCTFail(&quot;Unexpected type of error thrown: \(error)&quot;)<br>&gt;             return<br>&gt;         }<br>&gt;<br>&gt;         XCTAssertEquals(vendingError.item, &quot;Candy Bar&quot;)<br>&gt;         XCTAssertEquals(vendingError.price, 5)<br>&gt;         XCTAssertEquals(vendingError.message, &quot;A Candy Bar costs 5 coins&quot;)<br>&gt;     }<br>&gt;<br>&gt; This lets a developer very concisely describe an error condition for their<br>&gt; code, in whatever level of detail they desire.<br>&gt; Detailed design<br>&gt;<br>&gt; The design of each of the above components is slightly different, based on<br>&gt; the functionality provided.<br>&gt; Tests That Throw<br>&gt;<br>&gt; In order to enable test methods to throw an error, we will need to update<br>&gt; XCTest to support test methods with a () throws -&gt; Void signature in<br>&gt; addition to test methods with a () -&gt; Voidsignature as it already<br>&gt; supports.<br>&gt;<br>&gt; We will need to ensure tests that do throw an error have that error<br>&gt; caught, and that it registers an unexpected failure.<br>&gt; Assertions That Throw<br>&gt;<br>&gt; In order to allow assertions to throw an exception, we will need to<br>&gt; enhance our existing assertions&#39; @autoclosure expression parameters to<br>&gt; add throws to their signature.<br>&gt;<br>&gt; Because Swift defines a closure that can throw an error to be a proper<br>&gt; supertype of a closure that does not, this *will not* result in a<br>&gt; combinatorial explosion of assertion overrides, and will let developers<br>&gt; naturally write code that may throw an error within an assertion.<br>&gt;<br>&gt; We will treat any error thrown from within an assertion expression as an<br>&gt; *unexpected* failure because while all assertions represent a test for<br>&gt; some form of failure, they&#39;re not specifically checking for a thrown error.<br>&gt; The &quot;Throws Error&quot; Assertion<br>&gt;<br>&gt; To write tests for code that throws error, we will add a new assertion<br>&gt; function to XCTest with the following prototype:<br>&gt;<br>&gt; public func XCTAssertThrowsError(<br>&gt;     @autoclosure expression: () throws -&gt; Void,<br>&gt;                   _ message: String = &quot;&quot;,<br>&gt;                        file: StaticString = __FILE__,<br>&gt;                        line: UInt = __LINE__,<br>&gt;              _ errorHandler: (error: ErrorType) -&gt; Void = { _ in })<br>&gt;<br>&gt; Rather than treat an error thrown from its expression as a failure, this<br>&gt; will treat *the lack of* an error thrown from its expression as an<br>&gt; expected failure.<br>&gt;<br>&gt; Furthermore, so long as an error is thrown, the error will be passed to<br>&gt; the errorHandler block passed as a trailing closure, where the developer<br>&gt; may make further assertions against it.<br>&gt;<br>&gt; In both cases, the new assertion function is generic on an ErrorType in<br>&gt; order to ensure that little to no casting will be required in the trailing<br>&gt; closure.<br>&gt; Impact on existing code<br>&gt;<br>&gt; There should be little impact on existing test code because we are only<br>&gt; adding features and API, not changing existing features or API.<br>&gt;<br>&gt; All existing tests should continue to work as implemented, and can easily<br>&gt; adopt the new conventions we&#39;re making available to become more concise and<br>&gt; intention-revealing with respect to their error handling as shown above.<br>&gt; Alternatives considered<br>&gt;<br>&gt; We considered asking developers continue using XCTest as-is, and<br>&gt; encouraging them to use Swift&#39;s native error handling to both suppress and<br>&gt; check the validity of errors. We also considered adding additional ways of<br>&gt; registering failures when doing this, so that developers could register<br>&gt; unexpected failures themselves.<br>&gt;<br>&gt; While this would result in developers using the language the same way in<br>&gt; their tests as in their functional code, this would also result in much<br>&gt; more verbose tests. We rejected this approach because such verbosity can be<br>&gt; a significant obstacle to testing.<br>&gt;<br>&gt; Making it quick and clean to write tests for error handling could also<br>&gt; encourage developers to implement error handling in their code as they need<br>&gt; it, rather than to try to work around the feature because of any perceived<br>&gt; difficulty in testing.<br>&gt;<br>&gt; We considered adding the ability to check that a specific error was thrown<br>&gt; in XCTAssertThrowsError, but this would require the ErrorType passed to<br>&gt; also conform to Equatable, which is also unnecessary given that this can<br>&gt; easily be checked in a trailing closure if desired. (In some cases a<br>&gt; developer may just want to ensure *an error* is thrown rather than *a<br>&gt; specific error* is thrown.)<br>&gt;<br>&gt; We explicitly chose *not* to offer a comprehensive suite of<br>&gt; DoesNotThrowError assertions for XCTest in Swift, though we do offer such<br>&gt; DoesNotThrow assertions for XCTest in Objective-C. We feel these are of<br>&gt; limited utility given that our plan is for all assertions (except<br>&gt; XCTAssertThrowsError) to treat any thrown error as a failure.<br>&gt;<br>&gt; We explicitly chose not to offer any additional support for Objective-C<br>&gt; exceptions beyond what we already provide: In the Xcode implementation of<br>&gt; XCTest, an Objective-C exception that occurs within one of our existing<br>&gt; assertions or tests will result in a test failure; doing more than this is<br>&gt; not practical given that it&#39;s possible to neither catch and handle nor<br>&gt; generate an Objective-C exception in Swift.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/2b67a5cb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Proposal: XCTest Support for Swift Error Handling</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January 10, 2016 at 04:00:00pm</p></header><div class="content"><p>I wouldn&#39;t mind if we could have something closer to this.<br>http://rspec.info/<br></p><p>On Sun, Jan 10, 2016 at 3:01 PM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt;<br>wrote:<br></p><p>&gt; I&#39;ve been wondering for a while, while writing unit tests, why we still<br>&gt; start with &quot;func test[behaviourOfThing]() {&quot; and not &quot;test behaviourOfThing<br>&gt; {&quot;. It&#39;s not just about less typing: parsing a function for the &#39;test&#39;<br>&gt; prefix is an Objective C holdover, and doesn&#39;t feel Swift to me, and it has<br>&gt; tests behaving like functions when - as illustrated in this proposal - they<br>&gt; should have different behaviours. It should be clearer when reading code<br>&gt; whether a function is a test or a helper function to make tests easier to<br>&gt; write.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sun, Jan 10, 2016 at 12:34 PM, James Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I would love it if we could do a full review of XCtest in general. As<br>&gt;&gt; there are other things it could help with I.r mocking or allowing us to<br>&gt;&gt; express tests in a BDD way<br>&gt;&gt;<br>&gt;&gt; Sent from my iPhone<br>&gt;&gt;<br>&gt;&gt; On 10 Jan 2016, at 10:29, Drew Crawford via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I have on the order of ~700 tests in XCTest in Swift-language projects.<br>&gt;&gt; I&#39;m considering migrating away from XCTest, although not over this issue.<br>&gt;&gt;<br>&gt;&gt; This proposal IMO addresses an important problem, but I am not convinced<br>&gt;&gt; it actually solves it.  #2 &amp; #3 are basically sound API designs.  It is a<br>&gt;&gt; mystery to me why #3 &quot;generated some debate&quot; as this is a feature I already<br>&gt;&gt; implement manually, but I can&#39;t address unknown concerns.  I can tell you I<br>&gt;&gt; implement this, and nothing terrible has happened to me so far.<br>&gt;&gt;<br>&gt;&gt; #1 I would not use.  The rest of this comment explains why.<br>&gt;&gt;<br>&gt;&gt; Currently I write tests about like this:<br>&gt;&gt;<br>&gt;&gt; try! hopefullyNothingBad()<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Now this is &quot;bad&quot; because it &quot;crashes&quot; but that&#39;s (big sigh) actually<br>&gt;&gt; &quot;good&quot; because the debugger stops and/or I get a crash report that<br>&gt;&gt; identifies at least &quot;some&quot; line where something bad definitely happened.<br>&gt;&gt;<br>&gt;&gt; Now that is not everything I *want* to know–I *want* someone to tell me<br>&gt;&gt; a story of how this error was created deep down in the bowels of my<br>&gt;&gt; application, how it spent its kindergarten years in the models layer before<br>&gt;&gt; being passed into a controller where it was rethrown onto a different<br>&gt;&gt; dispatch queue and finally ended up in my unit test–but we can&#39;t have<br>&gt;&gt; everything.  So I settle for collecting a line number from the test case<br>&gt;&gt; and then going hunting by hand.<br>&gt;&gt;<br>&gt;&gt; When the test function throws we no longer even find out a line number in<br>&gt;&gt; the test case anymore, because the error is passed into XCTest and the<br>&gt;&gt; information is lost.  We have just the name of the test case (I assume; the<br>&gt;&gt; proposal is silent on this issue, but that&#39;s the only way I can think of to<br>&gt;&gt; implement it), and some of my tests are pretty long.  So, that makes it<br>&gt;&gt; even harder to track down.<br>&gt;&gt;<br>&gt;&gt; This sounds like a small thing but my test coverage is so thorough on<br>&gt;&gt; mature projects that mostly what I turn up are heisenbugs that reproduce<br>&gt;&gt; with 2% probability.  So getting the report from the CI that has the most<br>&gt;&gt; possible detail is critical, because if the report is not thorough enough<br>&gt;&gt; for you to guess the bug, too bad, because that&#39;s all the information you<br>&gt;&gt; get and the bug is not reproducible.<br>&gt;&gt;<br>&gt;&gt; For that reason, I won&#39;t use #1.  I hesitate about whether to call it bad<br>&gt;&gt; idea altogether, or whether it&#39;s just not to my taste.  My sense is it&#39;s<br>&gt;&gt; probably somewhere in the middle of those two poles.<br>&gt;&gt;<br>&gt;&gt; I would use #2 and #3, assuming that I don&#39;t first migrate out to a<br>&gt;&gt; non-XCTest framework.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 9, 2016, at 8:58 PM, Chris Hanson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; We’d like feedback on a proposed design for adding support for Swift<br>&gt;&gt; error handling to XCTest, attached below. I’ll mostly let the proposal<br>&gt;&gt; speak for itself, but there are three components to it: Allowing test<br>&gt;&gt; methods to throw errors, allowing the expressions evaluated by assertions<br>&gt;&gt; to throw errors, and adding an assertion for checking error handling.<br>&gt;&gt;<br>&gt;&gt; We’d love to hear your feedback. We’re particularly interested in some<br>&gt;&gt; feedback on the idea of allowing the expressions evaluated by assertions to<br>&gt;&gt; throw errors; it’s generated some debate because it results in writing test<br>&gt;&gt; code slightly differently than other code that makes use of Swift error<br>&gt;&gt; handling, so any thoughts on it would be particularly appreciated.<br>&gt;&gt;<br>&gt;&gt;   -- Chris Hanson (chanson at apple.com)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; XCTest Support for Swift Error Handling<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt;    - Author(s): Chris Hanson &lt;https://github.com/eschaton&gt;<br>&gt;&gt;    - Status: *Review*<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; Swift 2 introduced a new error handling mechanism that, for completeness,<br>&gt;&gt; needs to be accommodated by our testing frameworks. Right now, to write<br>&gt;&gt; tests that involve methods that may throw an error, a developer needs to<br>&gt;&gt; incorporate significant boilerplate into their test. We should move this<br>&gt;&gt; into the framework in several ways, so tests of code that interacts with<br>&gt;&gt; Swift error handling is concise and intention-revealing.<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; Currently, if a developer wants to use a call that may throw an error in<br>&gt;&gt; a test, they need to use Swift&#39;s do..catch construct in their test<br>&gt;&gt; because tests are not themselves allowed to throw errors.<br>&gt;&gt;<br>&gt;&gt; As an example, a vending machine object that has had insufficient funds<br>&gt;&gt; deposited may throw an error if asked to vend an item. A test for that<br>&gt;&gt; situation could reasonably use the do..catchconstruct to check that this<br>&gt;&gt; occurs as expected. However, that means all other tests *also* need to<br>&gt;&gt; use either a do..catch or try! construct — and the failure of a try! is<br>&gt;&gt; catastrophic, so do..catch would be preferred simply for better<br>&gt;&gt; reporting within tests.<br>&gt;&gt;<br>&gt;&gt; func testVendingOneItem() {<br>&gt;&gt;     do {<br>&gt;&gt;         vendingMachine.deposit(5)<br>&gt;&gt;         let item = try vendingMachine.vend(row: 1, column: 1)<br>&gt;&gt;         XCTAssertEqual(item, &quot;Candy Bar&quot;)<br>&gt;&gt;     } catch {<br>&gt;&gt;         XCTFail(&quot;Unexpected failure: \(error)&quot;)<br>&gt;&gt;     }}<br>&gt;&gt;<br>&gt;&gt; If the implementation of VendingMachine.vend(row:column:) changes during<br>&gt;&gt; development such that it throws an error in this situation, the test will<br>&gt;&gt; fail as it should.<br>&gt;&gt;<br>&gt;&gt; One other downside of the above is that a failure caught this way will be<br>&gt;&gt; reported as an *expected failure*, which would normally be a failure for<br>&gt;&gt; which XCTest is explicitly testing via an assertion. This failure should<br>&gt;&gt; ideally be treated as an *unexpected failure*, as it&#39;s not one that&#39;s<br>&gt;&gt; anticipated in the execution of the test.<br>&gt;&gt;<br>&gt;&gt; In addition, tests do not currently support throwing an error from within<br>&gt;&gt; an assertion, requiring any code that throws an error to be invoked outside<br>&gt;&gt; the assertion itself using the same techniques described above.<br>&gt;&gt;<br>&gt;&gt; Finally, since Swift error handling is a general mechanism that<br>&gt;&gt; developers should be implementing in their own applications and frameworks,<br>&gt;&gt; we need to make it straightforward to write tests that ensure code that<br>&gt;&gt; implements error handling does so correctly.<br>&gt;&gt; Proposed solution<br>&gt;&gt;<br>&gt;&gt; I propose several related solutions to this issue:<br>&gt;&gt;<br>&gt;&gt;    1. Allow test methods to throw errors.<br>&gt;&gt;    2. Allow test assertion expressions to throw errors.<br>&gt;&gt;    3. Add an assertion for checking errors.<br>&gt;&gt;<br>&gt;&gt; These solutions combine to make writing tests that involve thrown errors<br>&gt;&gt; much more succinct.<br>&gt;&gt; Allowing Test Methods to Throw Errors<br>&gt;&gt;<br>&gt;&gt; First, we can allow test methods to throw errors if desired, thus<br>&gt;&gt; allowing the do..catch construct to be omitted when the test isn&#39;t<br>&gt;&gt; directly checking error handling. This makes the code a developer writes<br>&gt;&gt; when they&#39;re not explicitly trying to test error handling much cleaner.<br>&gt;&gt;<br>&gt;&gt; Moving the handling of errors thrown by tests into XCTest itself also<br>&gt;&gt; ensures they can be treated as unexpected failures, since the mechanism to<br>&gt;&gt; do so is currently private to the framework.<br>&gt;&gt;<br>&gt;&gt; With this, the test from the previous section can become:<br>&gt;&gt;<br>&gt;&gt; func testVendingOneItem() throws {<br>&gt;&gt;     vendingMachine.deposit(5)<br>&gt;&gt;     let item = try vendingMachine.vend(row: 1, column: 1)<br>&gt;&gt;     XCTAssertEqual(item, &quot;Candy Bar&quot;)}<br>&gt;&gt;<br>&gt;&gt; This shows much more directly that the test is intended to check a<br>&gt;&gt; specific non-error case, and that the developer is relying on the framework<br>&gt;&gt; to handle unexpected errors.<br>&gt;&gt; Allowing Test Assertions to Throw Errors<br>&gt;&gt;<br>&gt;&gt; We can also allow the @autoclosure expression that is passed into an<br>&gt;&gt; assertion to throw an error, and treat that error as an unexpected failure<br>&gt;&gt; (since the code is being invoked in an assertion that isn&#39;t directly<br>&gt;&gt; related to error handling). For example:<br>&gt;&gt;<br>&gt;&gt; func testVendingMultipleItemsWithSufficientFunds() {<br>&gt;&gt;     vendingMachine.deposit(10)<br>&gt;&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 1), &quot;Candy Bar&quot;)<br>&gt;&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 2), &quot;Chips&quot;)}<br>&gt;&gt;<br>&gt;&gt; This can eliminate otherwise-dangerous uses of try! and streamline code<br>&gt;&gt; that needs to make multiple assertions in a row.<br>&gt;&gt; Adding a &quot;Throws Error&quot; Assertion<br>&gt;&gt;<br>&gt;&gt; In order to test code that throws an error, it would be useful to have an<br>&gt;&gt; assertion that expects an error to be thrown in a particular case. Right<br>&gt;&gt; now a developer writing code to test that an error is thrown has to test<br>&gt;&gt; that error themselves:<br>&gt;&gt;<br>&gt;&gt;     func testVendingFailsWithInsufficientFunds() {<br>&gt;&gt;         vendingMachine.deposit(1)<br>&gt;&gt;         var vendingFailed = false<br>&gt;&gt;         do {<br>&gt;&gt;             _ = try vendingMachine.vend(row: 1, column: 1))<br>&gt;&gt;         } catch {<br>&gt;&gt;             vendingFailed = true<br>&gt;&gt;         }<br>&gt;&gt;         XCTAssert(vendingFailed)<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; If we add an assertion that specifically checks whether an error was<br>&gt;&gt; thrown, this code will be significantly streamlined:<br>&gt;&gt;<br>&gt;&gt;     func testVendingFailsWithInsufficientFunds() {<br>&gt;&gt;         vendingMachine.deposit(1)<br>&gt;&gt;         XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1))<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; Of course, some code may want to just detect that an error was thrown,<br>&gt;&gt; but other code may need to check that the details of the thrown error are<br>&gt;&gt; correct. We can take advantage of Swift&#39;s trailing closure syntax to enable<br>&gt;&gt; this, by passing the thrown error (if any) to a closure that can itself<br>&gt;&gt; contain assertions:<br>&gt;&gt;<br>&gt;&gt;     XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1)) { error in<br>&gt;&gt;         guard let vendingError = error as? VendingMachineError else {<br>&gt;&gt;             XCTFail(&quot;Unexpected type of error thrown: \(error)&quot;)<br>&gt;&gt;             return<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         XCTAssertEquals(vendingError.item, &quot;Candy Bar&quot;)<br>&gt;&gt;         XCTAssertEquals(vendingError.price, 5)<br>&gt;&gt;         XCTAssertEquals(vendingError.message, &quot;A Candy Bar costs 5 coins&quot;)<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; This lets a developer very concisely describe an error condition for<br>&gt;&gt; their code, in whatever level of detail they desire.<br>&gt;&gt; Detailed design<br>&gt;&gt;<br>&gt;&gt; The design of each of the above components is slightly different, based<br>&gt;&gt; on the functionality provided.<br>&gt;&gt; Tests That Throw<br>&gt;&gt;<br>&gt;&gt; In order to enable test methods to throw an error, we will need to update<br>&gt;&gt; XCTest to support test methods with a () throws -&gt; Void signature in<br>&gt;&gt; addition to test methods with a () -&gt; Voidsignature as it already<br>&gt;&gt; supports.<br>&gt;&gt;<br>&gt;&gt; We will need to ensure tests that do throw an error have that error<br>&gt;&gt; caught, and that it registers an unexpected failure.<br>&gt;&gt; Assertions That Throw<br>&gt;&gt;<br>&gt;&gt; In order to allow assertions to throw an exception, we will need to<br>&gt;&gt; enhance our existing assertions&#39; @autoclosure expression parameters to<br>&gt;&gt; add throws to their signature.<br>&gt;&gt;<br>&gt;&gt; Because Swift defines a closure that can throw an error to be a proper<br>&gt;&gt; supertype of a closure that does not, this *will not* result in a<br>&gt;&gt; combinatorial explosion of assertion overrides, and will let developers<br>&gt;&gt; naturally write code that may throw an error within an assertion.<br>&gt;&gt;<br>&gt;&gt; We will treat any error thrown from within an assertion expression as an<br>&gt;&gt; *unexpected* failure because while all assertions represent a test for<br>&gt;&gt; some form of failure, they&#39;re not specifically checking for a thrown error.<br>&gt;&gt; The &quot;Throws Error&quot; Assertion<br>&gt;&gt;<br>&gt;&gt; To write tests for code that throws error, we will add a new assertion<br>&gt;&gt; function to XCTest with the following prototype:<br>&gt;&gt;<br>&gt;&gt; public func XCTAssertThrowsError(<br>&gt;&gt;     @autoclosure expression: () throws -&gt; Void,<br>&gt;&gt;                   _ message: String = &quot;&quot;,<br>&gt;&gt;                        file: StaticString = __FILE__,<br>&gt;&gt;                        line: UInt = __LINE__,<br>&gt;&gt;              _ errorHandler: (error: ErrorType) -&gt; Void = { _ in })<br>&gt;&gt;<br>&gt;&gt; Rather than treat an error thrown from its expression as a failure, this<br>&gt;&gt; will treat *the lack of* an error thrown from its expression as an<br>&gt;&gt; expected failure.<br>&gt;&gt;<br>&gt;&gt; Furthermore, so long as an error is thrown, the error will be passed to<br>&gt;&gt; the errorHandler block passed as a trailing closure, where the developer<br>&gt;&gt; may make further assertions against it.<br>&gt;&gt;<br>&gt;&gt; In both cases, the new assertion function is generic on an ErrorType in<br>&gt;&gt; order to ensure that little to no casting will be required in the trailing<br>&gt;&gt; closure.<br>&gt;&gt; Impact on existing code<br>&gt;&gt;<br>&gt;&gt; There should be little impact on existing test code because we are only<br>&gt;&gt; adding features and API, not changing existing features or API.<br>&gt;&gt;<br>&gt;&gt; All existing tests should continue to work as implemented, and can easily<br>&gt;&gt; adopt the new conventions we&#39;re making available to become more concise and<br>&gt;&gt; intention-revealing with respect to their error handling as shown above.<br>&gt;&gt; Alternatives considered<br>&gt;&gt;<br>&gt;&gt; We considered asking developers continue using XCTest as-is, and<br>&gt;&gt; encouraging them to use Swift&#39;s native error handling to both suppress and<br>&gt;&gt; check the validity of errors. We also considered adding additional ways of<br>&gt;&gt; registering failures when doing this, so that developers could register<br>&gt;&gt; unexpected failures themselves.<br>&gt;&gt;<br>&gt;&gt; While this would result in developers using the language the same way in<br>&gt;&gt; their tests as in their functional code, this would also result in much<br>&gt;&gt; more verbose tests. We rejected this approach because such verbosity can be<br>&gt;&gt; a significant obstacle to testing.<br>&gt;&gt;<br>&gt;&gt; Making it quick and clean to write tests for error handling could also<br>&gt;&gt; encourage developers to implement error handling in their code as they need<br>&gt;&gt; it, rather than to try to work around the feature because of any perceived<br>&gt;&gt; difficulty in testing.<br>&gt;&gt;<br>&gt;&gt; We considered adding the ability to check that a specific error was<br>&gt;&gt; thrown in XCTAssertThrowsError, but this would require the ErrorType passed<br>&gt;&gt; to also conform to Equatable, which is also unnecessary given that this<br>&gt;&gt; can easily be checked in a trailing closure if desired. (In some cases a<br>&gt;&gt; developer may just want to ensure *an error* is thrown rather than *a<br>&gt;&gt; specific error* is thrown.)<br>&gt;&gt;<br>&gt;&gt; We explicitly chose *not* to offer a comprehensive suite of<br>&gt;&gt; DoesNotThrowError assertions for XCTest in Swift, though we do offer<br>&gt;&gt; such DoesNotThrow assertions for XCTest in Objective-C. We feel these<br>&gt;&gt; are of limited utility given that our plan is for all assertions (except<br>&gt;&gt; XCTAssertThrowsError) to treat any thrown error as a failure.<br>&gt;&gt;<br>&gt;&gt; We explicitly chose not to offer any additional support for Objective-C<br>&gt;&gt; exceptions beyond what we already provide: In the Xcode implementation of<br>&gt;&gt; XCTest, an Objective-C exception that occurs within one of our existing<br>&gt;&gt; assertions or tests will result in a test failure; doing more than this is<br>&gt;&gt; not practical given that it&#39;s possible to neither catch and handle nor<br>&gt;&gt; generate an Objective-C exception in Swift.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br></p><p><br>-- <br> Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/09d35327/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5af07e950f10c7c1df1c44bed055c1eb?s=50"></div><header><strong>Proposal: XCTest Support for Swift Error Handling</strong> from <string>Daniel Steinberg</string> &lt;daniel at dimsumthinking.com&gt;<p>January 10, 2016 at 02:00:00pm</p></header><div class="content"><p>+1 for RSpec-like BDD style support in tests - though that doesn’t feel like a swift-evolution type of discussion<br></p><p><br>&gt; On Jan 10, 2016, at 11:05 AM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I wouldn&#39;t mind if we could have something closer to this. http://rspec.info/ &lt;http://rspec.info/&gt;<br>&gt; <br>&gt; On Sun, Jan 10, 2016 at 3:01 PM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com &lt;mailto:narrativium+swift at gmail.com&gt;&gt; wrote:<br>&gt; I&#39;ve been wondering for a while, while writing unit tests, why we still start with &quot;func test[behaviourOfThing]() {&quot; and not &quot;test behaviourOfThing {&quot;. It&#39;s not just about less typing: parsing a function for the &#39;test&#39; prefix is an Objective C holdover, and doesn&#39;t feel Swift to me, and it has tests behaving like functions when - as illustrated in this proposal - they should have different behaviours. It should be clearer when reading code whether a function is a test or a helper function to make tests easier to write.<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Sun, Jan 10, 2016 at 12:34 PM, James Campbell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I would love it if we could do a full review of XCtest in general. As there are other things it could help with I.r mocking or allowing us to express tests in a BDD way <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On 10 Jan 2016, at 10:29, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I have on the order of ~700 tests in XCTest in Swift-language projects.  I&#39;m considering migrating away from XCTest, although not over this issue.<br>&gt;&gt; <br>&gt;&gt; This proposal IMO addresses an important problem, but I am not convinced it actually solves it.  #2 &amp; #3 are basically sound API designs.  It is a mystery to me why #3 &quot;generated some debate&quot; as this is a feature I already implement manually, but I can&#39;t address unknown concerns.  I can tell you I implement this, and nothing terrible has happened to me so far.<br>&gt;&gt; <br>&gt;&gt; #1 I would not use.  The rest of this comment explains why.<br>&gt;&gt; <br>&gt;&gt; Currently I write tests about like this:<br>&gt;&gt; <br>&gt;&gt; try! hopefullyNothingBad()<br>&gt;&gt; <br>&gt;&gt; Now this is &quot;bad&quot; because it &quot;crashes&quot; but that&#39;s (big sigh) actually &quot;good&quot; because the debugger stops and/or I get a crash report that identifies at least &quot;some&quot; line where something bad definitely happened.<br>&gt;&gt; <br>&gt;&gt; Now that is not everything I want to know–I want someone to tell me a story of how this error was created deep down in the bowels of my application, how it spent its kindergarten years in the models layer before being passed into a controller where it was rethrown onto a different dispatch queue and finally ended up in my unit test–but we can&#39;t have everything.  So I settle for collecting a line number from the test case and then going hunting by hand.<br>&gt;&gt; <br>&gt;&gt; When the test function throws we no longer even find out a line number in the test case anymore, because the error is passed into XCTest and the information is lost.  We have just the name of the test case (I assume; the proposal is silent on this issue, but that&#39;s the only way I can think of to implement it), and some of my tests are pretty long.  So, that makes it even harder to track down.<br>&gt;&gt; <br>&gt;&gt; This sounds like a small thing but my test coverage is so thorough on mature projects that mostly what I turn up are heisenbugs that reproduce with 2% probability.  So getting the report from the CI that has the most possible detail is critical, because if the report is not thorough enough for you to guess the bug, too bad, because that&#39;s all the information you get and the bug is not reproducible.<br>&gt;&gt; <br>&gt;&gt; For that reason, I won&#39;t use #1.  I hesitate about whether to call it bad idea altogether, or whether it&#39;s just not to my taste.  My sense is it&#39;s probably somewhere in the middle of those two poles.<br>&gt;&gt; <br>&gt;&gt; I would use #2 and #3, assuming that I don&#39;t first migrate out to a non-XCTest framework.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 9, 2016, at 8:58 PM, Chris Hanson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We’d like feedback on a proposed design for adding support for Swift error handling to XCTest, attached below. I’ll mostly let the proposal speak for itself, but there are three components to it: Allowing test methods to throw errors, allowing the expressions evaluated by assertions to throw errors, and adding an assertion for checking error handling.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We’d love to hear your feedback. We’re particularly interested in some feedback on the idea of allowing the expressions evaluated by assertions to throw errors; it’s generated some debate because it results in writing test code slightly differently than other code that makes use of Swift error handling, so any thoughts on it would be particularly appreciated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   -- Chris Hanson (chanson at apple.com &lt;mailto:chanson at apple.com&gt;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; XCTest Support for Swift Error Handling<br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt;&gt; Author(s): Chris Hanson &lt;https://github.com/eschaton&gt;<br>&gt;&gt;&gt; Status: Review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; Swift 2 introduced a new error handling mechanism that, for completeness, needs to be accommodated by our testing frameworks. Right now, to write tests that involve methods that may throw an error, a developer needs to incorporate significant boilerplate into their test. We should move this into the framework in several ways, so tests of code that interacts with Swift error handling is concise and intention-revealing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; Currently, if a developer wants to use a call that may throw an error in a test, they need to use Swift&#39;s do..catch construct in their test because tests are not themselves allowed to throw errors.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As an example, a vending machine object that has had insufficient funds deposited may throw an error if asked to vend an item. A test for that situation could reasonably use the do..catchconstruct to check that this occurs as expected. However, that means all other tests also need to use either a do..catch or try! construct — and the failure of a try! is catastrophic, so do..catch would be preferred simply for better reporting within tests.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func testVendingOneItem() {<br>&gt;&gt;&gt;     do {<br>&gt;&gt;&gt;         vendingMachine.deposit(5)<br>&gt;&gt;&gt;         let item = try vendingMachine.vend(row: 1, column: 1)<br>&gt;&gt;&gt;         XCTAssertEqual(item, &quot;Candy Bar&quot;)<br>&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;         XCTFail(&quot;Unexpected failure: \(error)&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; If the implementation of VendingMachine.vend(row:column:) changes during development such that it throws an error in this situation, the test will fail as it should.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One other downside of the above is that a failure caught this way will be reported as an expected failure, which would normally be a failure for which XCTest is explicitly testing via an assertion. This failure should ideally be treated as an unexpected failure, as it&#39;s not one that&#39;s anticipated in the execution of the test.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In addition, tests do not currently support throwing an error from within an assertion, requiring any code that throws an error to be invoked outside the assertion itself using the same techniques described above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, since Swift error handling is a general mechanism that developers should be implementing in their own applications and frameworks, we need to make it straightforward to write tests that ensure code that implements error handling does so correctly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; I propose several related solutions to this issue:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Allow test methods to throw errors.<br>&gt;&gt;&gt; Allow test assertion expressions to throw errors.<br>&gt;&gt;&gt; Add an assertion for checking errors.<br>&gt;&gt;&gt; These solutions combine to make writing tests that involve thrown errors much more succinct.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Allowing Test Methods to Throw Errors<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First, we can allow test methods to throw errors if desired, thus allowing the do..catch construct to be omitted when the test isn&#39;t directly checking error handling. This makes the code a developer writes when they&#39;re not explicitly trying to test error handling much cleaner.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Moving the handling of errors thrown by tests into XCTest itself also ensures they can be treated as unexpected failures, since the mechanism to do so is currently private to the framework.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With this, the test from the previous section can become:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func testVendingOneItem() throws {<br>&gt;&gt;&gt;     vendingMachine.deposit(5)<br>&gt;&gt;&gt;     let item = try vendingMachine.vend(row: 1, column: 1)<br>&gt;&gt;&gt;     XCTAssertEqual(item, &quot;Candy Bar&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; This shows much more directly that the test is intended to check a specific non-error case, and that the developer is relying on the framework to handle unexpected errors.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Allowing Test Assertions to Throw Errors<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We can also allow the @autoclosure expression that is passed into an assertion to throw an error, and treat that error as an unexpected failure (since the code is being invoked in an assertion that isn&#39;t directly related to error handling). For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func testVendingMultipleItemsWithSufficientFunds() {<br>&gt;&gt;&gt;     vendingMachine.deposit(10)<br>&gt;&gt;&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 1), &quot;Candy Bar&quot;)<br>&gt;&gt;&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 2), &quot;Chips&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; This can eliminate otherwise-dangerous uses of try! and streamline code that needs to make multiple assertions in a row.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Adding a &quot;Throws Error&quot; Assertion<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In order to test code that throws an error, it would be useful to have an assertion that expects an error to be thrown in a particular case. Right now a developer writing code to test that an error is thrown has to test that error themselves:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func testVendingFailsWithInsufficientFunds() {<br>&gt;&gt;&gt;         vendingMachine.deposit(1)<br>&gt;&gt;&gt;         var vendingFailed = false<br>&gt;&gt;&gt;         do {<br>&gt;&gt;&gt;             _ = try vendingMachine.vend(row: 1, column: 1))<br>&gt;&gt;&gt;         } catch {<br>&gt;&gt;&gt;             vendingFailed = true<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         XCTAssert(vendingFailed)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; If we add an assertion that specifically checks whether an error was thrown, this code will be significantly streamlined:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func testVendingFailsWithInsufficientFunds() {<br>&gt;&gt;&gt;         vendingMachine.deposit(1)<br>&gt;&gt;&gt;         XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1))<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; Of course, some code may want to just detect that an error was thrown, but other code may need to check that the details of the thrown error are correct. We can take advantage of Swift&#39;s trailing closure syntax to enable this, by passing the thrown error (if any) to a closure that can itself contain assertions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1)) { error in<br>&gt;&gt;&gt;         guard let vendingError = error as? VendingMachineError else {<br>&gt;&gt;&gt;             XCTFail(&quot;Unexpected type of error thrown: \(error)&quot;)<br>&gt;&gt;&gt;             return<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;         XCTAssertEquals(vendingError.item, &quot;Candy Bar&quot;)<br>&gt;&gt;&gt;         XCTAssertEquals(vendingError.price, 5)<br>&gt;&gt;&gt;         XCTAssertEquals(vendingError.message, &quot;A Candy Bar costs 5 coins&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; This lets a developer very concisely describe an error condition for their code, in whatever level of detail they desire.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; The design of each of the above components is slightly different, based on the functionality provided.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Tests That Throw<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In order to enable test methods to throw an error, we will need to update XCTest to support test methods with a () throws -&gt; Void signature in addition to test methods with a () -&gt; Voidsignature as it already supports.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We will need to ensure tests that do throw an error have that error caught, and that it registers an unexpected failure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Assertions That Throw<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In order to allow assertions to throw an exception, we will need to enhance our existing assertions&#39; @autoclosure expression parameters to add throws to their signature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Because Swift defines a closure that can throw an error to be a proper supertype of a closure that does not, this will not result in a combinatorial explosion of assertion overrides, and will let developers naturally write code that may throw an error within an assertion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We will treat any error thrown from within an assertion expression as an unexpected failure because while all assertions represent a test for some form of failure, they&#39;re not specifically checking for a thrown error.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The &quot;Throws Error&quot; Assertion<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To write tests for code that throws error, we will add a new assertion function to XCTest with the following prototype:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func XCTAssertThrowsError(<br>&gt;&gt;&gt;     @autoclosure expression: () throws -&gt; Void,<br>&gt;&gt;&gt;                   _ message: String = &quot;&quot;,<br>&gt;&gt;&gt;                        file: StaticString = __FILE__,<br>&gt;&gt;&gt;                        line: UInt = __LINE__,<br>&gt;&gt;&gt;              _ errorHandler: (error: ErrorType) -&gt; Void = { _ in })<br>&gt;&gt;&gt; Rather than treat an error thrown from its expression as a failure, this will treat the lack of an error thrown from its expression as an expected failure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Furthermore, so long as an error is thrown, the error will be passed to the errorHandler block passed as a trailing closure, where the developer may make further assertions against it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In both cases, the new assertion function is generic on an ErrorType in order to ensure that little to no casting will be required in the trailing closure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; There should be little impact on existing test code because we are only adding features and API, not changing existing features or API.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; All existing tests should continue to work as implemented, and can easily adopt the new conventions we&#39;re making available to become more concise and intention-revealing with respect to their error handling as shown above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; We considered asking developers continue using XCTest as-is, and encouraging them to use Swift&#39;s native error handling to both suppress and check the validity of errors. We also considered adding additional ways of registering failures when doing this, so that developers could register unexpected failures themselves.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While this would result in developers using the language the same way in their tests as in their functional code, this would also result in much more verbose tests. We rejected this approach because such verbosity can be a significant obstacle to testing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Making it quick and clean to write tests for error handling could also encourage developers to implement error handling in their code as they need it, rather than to try to work around the feature because of any perceived difficulty in testing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We considered adding the ability to check that a specific error was thrown in XCTAssertThrowsError, but this would require the ErrorType passed to also conform to Equatable, which is also unnecessary given that this can easily be checked in a trailing closure if desired. (In some cases a developer may just want to ensure an error is thrown rather than a specific error is thrown.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We explicitly chose not to offer a comprehensive suite of DoesNotThrowError assertions for XCTest in Swift, though we do offer such DoesNotThrow assertions for XCTest in Objective-C. We feel these are of limited utility given that our plan is for all assertions (except XCTAssertThrowsError) to treat any thrown error as a failure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We explicitly chose not to offer any additional support for Objective-C exceptions beyond what we already provide: In the Xcode implementation of XCTest, an Objective-C exception that occurs within one of our existing assertions or tests will result in a test failure; doing more than this is not practical given that it&#39;s possible to neither catch and handle nor generate an Objective-C exception in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;  Wizard<br>&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;<br>&gt; +44 7523 279 698<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/dd59519a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: XCTest Support for Swift Error Handling</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 10, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; +1 for RSpec-like BDD style support in tests - though that doesn’t feel like a swift-evolution type of discussion<br></p><p>RSpec sounds like logging: &quot;Build what you want to use, let the community sort out which ideas are best, and maybe in a couple versions we&#39;ll standardize the most popular thing.&quot;<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Proposal: XCTest Support for Swift Error Handling</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January 10, 2016 at 09:00:00pm</p></header><div class="content"><p>Unfortunately a lot of current libraries involve hacks on-top of XCTest. I<br>think this belongs here as we should start having 1st class support.<br></p><p>On Sun, Jan 10, 2016 at 7:07 PM, Daniel Steinberg &lt;daniel at dimsumthinking.com<br>&gt; wrote:<br></p><p>&gt; +1 for RSpec-like BDD style support in tests - though that doesn’t feel<br>&gt; like a swift-evolution type of discussion<br>&gt;<br>&gt;<br>&gt; On Jan 10, 2016, at 11:05 AM, James Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I wouldn&#39;t mind if we could have something closer to this.<br>&gt; http://rspec.info/<br>&gt;<br>&gt; On Sun, Jan 10, 2016 at 3:01 PM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com<br>&gt; &gt; wrote:<br>&gt;<br>&gt;&gt; I&#39;ve been wondering for a while, while writing unit tests, why we still<br>&gt;&gt; start with &quot;func test[behaviourOfThing]() {&quot; and not &quot;test behaviourOfThing<br>&gt;&gt; {&quot;. It&#39;s not just about less typing: parsing a function for the &#39;test&#39;<br>&gt;&gt; prefix is an Objective C holdover, and doesn&#39;t feel Swift to me, and it has<br>&gt;&gt; tests behaving like functions when - as illustrated in this proposal - they<br>&gt;&gt; should have different behaviours. It should be clearer when reading code<br>&gt;&gt; whether a function is a test or a helper function to make tests easier to<br>&gt;&gt; write.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sun, Jan 10, 2016 at 12:34 PM, James Campbell via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I would love it if we could do a full review of XCtest in general. As<br>&gt;&gt;&gt; there are other things it could help with I.r mocking or allowing us to<br>&gt;&gt;&gt; express tests in a BDD way<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 10 Jan 2016, at 10:29, Drew Crawford via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I have on the order of ~700 tests in XCTest in Swift-language projects.<br>&gt;&gt;&gt; I&#39;m considering migrating away from XCTest, although not over this issue.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This proposal IMO addresses an important problem, but I am not convinced<br>&gt;&gt;&gt; it actually solves it.  #2 &amp; #3 are basically sound API designs.  It is a<br>&gt;&gt;&gt; mystery to me why #3 &quot;generated some debate&quot; as this is a feature I already<br>&gt;&gt;&gt; implement manually, but I can&#39;t address unknown concerns.  I can tell you I<br>&gt;&gt;&gt; implement this, and nothing terrible has happened to me so far.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; #1 I would not use.  The rest of this comment explains why.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently I write tests about like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; try! hopefullyNothingBad()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Now this is &quot;bad&quot; because it &quot;crashes&quot; but that&#39;s (big sigh) actually<br>&gt;&gt;&gt; &quot;good&quot; because the debugger stops and/or I get a crash report that<br>&gt;&gt;&gt; identifies at least &quot;some&quot; line where something bad definitely happened.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Now that is not everything I *want* to know–I *want* someone to tell me<br>&gt;&gt;&gt; a story of how this error was created deep down in the bowels of my<br>&gt;&gt;&gt; application, how it spent its kindergarten years in the models layer before<br>&gt;&gt;&gt; being passed into a controller where it was rethrown onto a different<br>&gt;&gt;&gt; dispatch queue and finally ended up in my unit test–but we can&#39;t have<br>&gt;&gt;&gt; everything.  So I settle for collecting a line number from the test case<br>&gt;&gt;&gt; and then going hunting by hand.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When the test function throws we no longer even find out a line number<br>&gt;&gt;&gt; in the test case anymore, because the error is passed into XCTest and the<br>&gt;&gt;&gt; information is lost.  We have just the name of the test case (I assume; the<br>&gt;&gt;&gt; proposal is silent on this issue, but that&#39;s the only way I can think of to<br>&gt;&gt;&gt; implement it), and some of my tests are pretty long.  So, that makes it<br>&gt;&gt;&gt; even harder to track down.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This sounds like a small thing but my test coverage is so thorough on<br>&gt;&gt;&gt; mature projects that mostly what I turn up are heisenbugs that reproduce<br>&gt;&gt;&gt; with 2% probability.  So getting the report from the CI that has the most<br>&gt;&gt;&gt; possible detail is critical, because if the report is not thorough enough<br>&gt;&gt;&gt; for you to guess the bug, too bad, because that&#39;s all the information you<br>&gt;&gt;&gt; get and the bug is not reproducible.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For that reason, I won&#39;t use #1.  I hesitate about whether to call it<br>&gt;&gt;&gt; bad idea altogether, or whether it&#39;s just not to my taste.  My sense is<br>&gt;&gt;&gt; it&#39;s probably somewhere in the middle of those two poles.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I would use #2 and #3, assuming that I don&#39;t first migrate out to a<br>&gt;&gt;&gt; non-XCTest framework.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jan 9, 2016, at 8:58 PM, Chris Hanson via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We’d like feedback on a proposed design for adding support for Swift<br>&gt;&gt;&gt; error handling to XCTest, attached below. I’ll mostly let the proposal<br>&gt;&gt;&gt; speak for itself, but there are three components to it: Allowing test<br>&gt;&gt;&gt; methods to throw errors, allowing the expressions evaluated by assertions<br>&gt;&gt;&gt; to throw errors, and adding an assertion for checking error handling.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We’d love to hear your feedback. We’re particularly interested in some<br>&gt;&gt;&gt; feedback on the idea of allowing the expressions evaluated by assertions to<br>&gt;&gt;&gt; throw errors; it’s generated some debate because it results in writing test<br>&gt;&gt;&gt; code slightly differently than other code that makes use of Swift error<br>&gt;&gt;&gt; handling, so any thoughts on it would be particularly appreciated.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   -- Chris Hanson (chanson at apple.com)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; XCTest Support for Swift Error Handling<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt;&gt;    - Author(s): Chris Hanson &lt;https://github.com/eschaton&gt;<br>&gt;&gt;&gt;    - Status: *Review*<br>&gt;&gt;&gt;    - Review manager: TBD<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift 2 introduced a new error handling mechanism that, for<br>&gt;&gt;&gt; completeness, needs to be accommodated by our testing frameworks. Right<br>&gt;&gt;&gt; now, to write tests that involve methods that may throw an error, a<br>&gt;&gt;&gt; developer needs to incorporate significant boilerplate into their test. We<br>&gt;&gt;&gt; should move this into the framework in several ways, so tests of code that<br>&gt;&gt;&gt; interacts with Swift error handling is concise and intention-revealing.<br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently, if a developer wants to use a call that may throw an error in<br>&gt;&gt;&gt; a test, they need to use Swift&#39;s do..catch construct in their test<br>&gt;&gt;&gt; because tests are not themselves allowed to throw errors.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As an example, a vending machine object that has had insufficient funds<br>&gt;&gt;&gt; deposited may throw an error if asked to vend an item. A test for that<br>&gt;&gt;&gt; situation could reasonably use the do..catchconstruct to check that<br>&gt;&gt;&gt; this occurs as expected. However, that means all other tests *also* need<br>&gt;&gt;&gt; to use either a do..catch or try! construct — and the failure of a try! is<br>&gt;&gt;&gt; catastrophic, so do..catch would be preferred simply for better<br>&gt;&gt;&gt; reporting within tests.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func testVendingOneItem() {<br>&gt;&gt;&gt;     do {<br>&gt;&gt;&gt;         vendingMachine.deposit(5)<br>&gt;&gt;&gt;         let item = try vendingMachine.vend(row: 1, column: 1)<br>&gt;&gt;&gt;         XCTAssertEqual(item, &quot;Candy Bar&quot;)<br>&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;         XCTFail(&quot;Unexpected failure: \(error)&quot;)<br>&gt;&gt;&gt;     }}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If the implementation of VendingMachine.vend(row:column:) changes<br>&gt;&gt;&gt; during development such that it throws an error in this situation, the test<br>&gt;&gt;&gt; will fail as it should.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One other downside of the above is that a failure caught this way will<br>&gt;&gt;&gt; be reported as an *expected failure*, which would normally be a failure<br>&gt;&gt;&gt; for which XCTest is explicitly testing via an assertion. This failure<br>&gt;&gt;&gt; should ideally be treated as an *unexpected failure*, as it&#39;s not one<br>&gt;&gt;&gt; that&#39;s anticipated in the execution of the test.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In addition, tests do not currently support throwing an error from<br>&gt;&gt;&gt; within an assertion, requiring any code that throws an error to be invoked<br>&gt;&gt;&gt; outside the assertion itself using the same techniques described above.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Finally, since Swift error handling is a general mechanism that<br>&gt;&gt;&gt; developers should be implementing in their own applications and frameworks,<br>&gt;&gt;&gt; we need to make it straightforward to write tests that ensure code that<br>&gt;&gt;&gt; implements error handling does so correctly.<br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I propose several related solutions to this issue:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    1. Allow test methods to throw errors.<br>&gt;&gt;&gt;    2. Allow test assertion expressions to throw errors.<br>&gt;&gt;&gt;    3. Add an assertion for checking errors.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; These solutions combine to make writing tests that involve thrown errors<br>&gt;&gt;&gt; much more succinct.<br>&gt;&gt;&gt; Allowing Test Methods to Throw Errors<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; First, we can allow test methods to throw errors if desired, thus<br>&gt;&gt;&gt; allowing the do..catch construct to be omitted when the test isn&#39;t<br>&gt;&gt;&gt; directly checking error handling. This makes the code a developer writes<br>&gt;&gt;&gt; when they&#39;re not explicitly trying to test error handling much cleaner.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Moving the handling of errors thrown by tests into XCTest itself also<br>&gt;&gt;&gt; ensures they can be treated as unexpected failures, since the mechanism to<br>&gt;&gt;&gt; do so is currently private to the framework.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; With this, the test from the previous section can become:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func testVendingOneItem() throws {<br>&gt;&gt;&gt;     vendingMachine.deposit(5)<br>&gt;&gt;&gt;     let item = try vendingMachine.vend(row: 1, column: 1)<br>&gt;&gt;&gt;     XCTAssertEqual(item, &quot;Candy Bar&quot;)}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This shows much more directly that the test is intended to check a<br>&gt;&gt;&gt; specific non-error case, and that the developer is relying on the framework<br>&gt;&gt;&gt; to handle unexpected errors.<br>&gt;&gt;&gt; Allowing Test Assertions to Throw Errors<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We can also allow the @autoclosure expression that is passed into an<br>&gt;&gt;&gt; assertion to throw an error, and treat that error as an unexpected failure<br>&gt;&gt;&gt; (since the code is being invoked in an assertion that isn&#39;t directly<br>&gt;&gt;&gt; related to error handling). For example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func testVendingMultipleItemsWithSufficientFunds() {<br>&gt;&gt;&gt;     vendingMachine.deposit(10)<br>&gt;&gt;&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 1), &quot;Candy Bar&quot;)<br>&gt;&gt;&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 2), &quot;Chips&quot;)}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This can eliminate otherwise-dangerous uses of try! and streamline code<br>&gt;&gt;&gt; that needs to make multiple assertions in a row.<br>&gt;&gt;&gt; Adding a &quot;Throws Error&quot; Assertion<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In order to test code that throws an error, it would be useful to have<br>&gt;&gt;&gt; an assertion that expects an error to be thrown in a particular case. Right<br>&gt;&gt;&gt; now a developer writing code to test that an error is thrown has to test<br>&gt;&gt;&gt; that error themselves:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func testVendingFailsWithInsufficientFunds() {<br>&gt;&gt;&gt;         vendingMachine.deposit(1)<br>&gt;&gt;&gt;         var vendingFailed = false<br>&gt;&gt;&gt;         do {<br>&gt;&gt;&gt;             _ = try vendingMachine.vend(row: 1, column: 1))<br>&gt;&gt;&gt;         } catch {<br>&gt;&gt;&gt;             vendingFailed = true<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         XCTAssert(vendingFailed)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If we add an assertion that specifically checks whether an error was<br>&gt;&gt;&gt; thrown, this code will be significantly streamlined:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func testVendingFailsWithInsufficientFunds() {<br>&gt;&gt;&gt;         vendingMachine.deposit(1)<br>&gt;&gt;&gt;         XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1))<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Of course, some code may want to just detect that an error was thrown,<br>&gt;&gt;&gt; but other code may need to check that the details of the thrown error are<br>&gt;&gt;&gt; correct. We can take advantage of Swift&#39;s trailing closure syntax to enable<br>&gt;&gt;&gt; this, by passing the thrown error (if any) to a closure that can itself<br>&gt;&gt;&gt; contain assertions:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1)) { error in<br>&gt;&gt;&gt;         guard let vendingError = error as? VendingMachineError else {<br>&gt;&gt;&gt;             XCTFail(&quot;Unexpected type of error thrown: \(error)&quot;)<br>&gt;&gt;&gt;             return<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         XCTAssertEquals(vendingError.item, &quot;Candy Bar&quot;)<br>&gt;&gt;&gt;         XCTAssertEquals(vendingError.price, 5)<br>&gt;&gt;&gt;         XCTAssertEquals(vendingError.message, &quot;A Candy Bar costs 5 coins&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This lets a developer very concisely describe an error condition for<br>&gt;&gt;&gt; their code, in whatever level of detail they desire.<br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The design of each of the above components is slightly different, based<br>&gt;&gt;&gt; on the functionality provided.<br>&gt;&gt;&gt; Tests That Throw<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In order to enable test methods to throw an error, we will need to<br>&gt;&gt;&gt; update XCTest to support test methods with a () throws -&gt; Void signature<br>&gt;&gt;&gt; in addition to test methods with a () -&gt; Voidsignature as it already<br>&gt;&gt;&gt; supports.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We will need to ensure tests that do throw an error have that error<br>&gt;&gt;&gt; caught, and that it registers an unexpected failure.<br>&gt;&gt;&gt; Assertions That Throw<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In order to allow assertions to throw an exception, we will need to<br>&gt;&gt;&gt; enhance our existing assertions&#39; @autoclosure expression parameters to<br>&gt;&gt;&gt; add throws to their signature.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Because Swift defines a closure that can throw an error to be a proper<br>&gt;&gt;&gt; supertype of a closure that does not, this *will not* result in a<br>&gt;&gt;&gt; combinatorial explosion of assertion overrides, and will let developers<br>&gt;&gt;&gt; naturally write code that may throw an error within an assertion.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We will treat any error thrown from within an assertion expression as an<br>&gt;&gt;&gt; *unexpected* failure because while all assertions represent a test for<br>&gt;&gt;&gt; some form of failure, they&#39;re not specifically checking for a thrown error.<br>&gt;&gt;&gt; The &quot;Throws Error&quot; Assertion<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; To write tests for code that throws error, we will add a new assertion<br>&gt;&gt;&gt; function to XCTest with the following prototype:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public func XCTAssertThrowsError(<br>&gt;&gt;&gt;     @autoclosure expression: () throws -&gt; Void,<br>&gt;&gt;&gt;                   _ message: String = &quot;&quot;,<br>&gt;&gt;&gt;                        file: StaticString = __FILE__,<br>&gt;&gt;&gt;                        line: UInt = __LINE__,<br>&gt;&gt;&gt;              _ errorHandler: (error: ErrorType) -&gt; Void = { _ in })<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Rather than treat an error thrown from its expression as a failure, this<br>&gt;&gt;&gt; will treat *the lack of* an error thrown from its expression as an<br>&gt;&gt;&gt; expected failure.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Furthermore, so long as an error is thrown, the error will be passed to<br>&gt;&gt;&gt; the errorHandler block passed as a trailing closure, where the<br>&gt;&gt;&gt; developer may make further assertions against it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In both cases, the new assertion function is generic on an ErrorType in<br>&gt;&gt;&gt; order to ensure that little to no casting will be required in the trailing<br>&gt;&gt;&gt; closure.<br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There should be little impact on existing test code because we are only<br>&gt;&gt;&gt; adding features and API, not changing existing features or API.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; All existing tests should continue to work as implemented, and can<br>&gt;&gt;&gt; easily adopt the new conventions we&#39;re making available to become more<br>&gt;&gt;&gt; concise and intention-revealing with respect to their error handling as<br>&gt;&gt;&gt; shown above.<br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We considered asking developers continue using XCTest as-is, and<br>&gt;&gt;&gt; encouraging them to use Swift&#39;s native error handling to both suppress and<br>&gt;&gt;&gt; check the validity of errors. We also considered adding additional ways of<br>&gt;&gt;&gt; registering failures when doing this, so that developers could register<br>&gt;&gt;&gt; unexpected failures themselves.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; While this would result in developers using the language the same way in<br>&gt;&gt;&gt; their tests as in their functional code, this would also result in much<br>&gt;&gt;&gt; more verbose tests. We rejected this approach because such verbosity can be<br>&gt;&gt;&gt; a significant obstacle to testing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Making it quick and clean to write tests for error handling could also<br>&gt;&gt;&gt; encourage developers to implement error handling in their code as they need<br>&gt;&gt;&gt; it, rather than to try to work around the feature because of any perceived<br>&gt;&gt;&gt; difficulty in testing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We considered adding the ability to check that a specific error was<br>&gt;&gt;&gt; thrown in XCTAssertThrowsError, but this would require the ErrorType passed<br>&gt;&gt;&gt; to also conform to Equatable, which is also unnecessary given that this<br>&gt;&gt;&gt; can easily be checked in a trailing closure if desired. (In some cases a<br>&gt;&gt;&gt; developer may just want to ensure *an error* is thrown rather than *a<br>&gt;&gt;&gt; specific error* is thrown.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We explicitly chose *not* to offer a comprehensive suite of<br>&gt;&gt;&gt; DoesNotThrowError assertions for XCTest in Swift, though we do offer<br>&gt;&gt;&gt; such DoesNotThrow assertions for XCTest in Objective-C. We feel these<br>&gt;&gt;&gt; are of limited utility given that our plan is for all assertions (except<br>&gt;&gt;&gt; XCTAssertThrowsError) to treat any thrown error as a failure.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We explicitly chose not to offer any additional support for Objective-C<br>&gt;&gt;&gt; exceptions beyond what we already provide: In the Xcode implementation of<br>&gt;&gt;&gt; XCTest, an Objective-C exception that occurs within one of our existing<br>&gt;&gt;&gt; assertions or tests will result in a test failure; doing more than this is<br>&gt;&gt;&gt; not practical given that it&#39;s possible to neither catch and handle nor<br>&gt;&gt;&gt; generate an Objective-C exception in Swift.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;  Wizard<br>&gt; james at supmenow.com<br>&gt; +44 7523 279 698<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br> Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/252bfb83/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>Proposal: XCTest Support for Swift Error Handling</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>January 10, 2016 at 07:00:00pm</p></header><div class="content"><p>RSpec, Kiwi and similar have hierarchical tests which are good because they<br>reduce duplication and take into account the dependencies of tests - tests<br>on the performance of objects being conditional on the verified successful<br>creation of those objects, or on duplicated circumstances - but they also<br>nest tests into a &#39;pyramid of doom&#39; as we had prior to &quot;if let&quot; allowing<br>multiple bindings.<br></p><p>It&#39;d be nice if we could refactor huge nested structures like that into<br>flatter subtests. Ideally I&#39;d like there to be a way to reduce repetition<br>of duplicated code in tests (e.g. for a series of identical tests<br>determining if a given data structure is valid, a way to call those tests<br>with one command). It&#39;s possible to call XCTest functions in helper<br>functions now, but hard to match any failure messages with the test which<br>called the helper function. Perhaps such sub-test methods could throw a<br>series of test failure messages so this can be determined more easily.<br></p><p><br>On Sun, Jan 10, 2016 at 4:05 PM, James Campbell &lt;james at supmenow.com&gt; wrote:<br></p><p>&gt; I wouldn&#39;t mind if we could have something closer to this.<br>&gt; http://rspec.info/<br>&gt;<br>&gt; On Sun, Jan 10, 2016 at 3:01 PM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com<br>&gt; &gt; wrote:<br>&gt;<br>&gt;&gt; I&#39;ve been wondering for a while, while writing unit tests, why we still<br>&gt;&gt; start with &quot;func test[behaviourOfThing]() {&quot; and not &quot;test behaviourOfThing<br>&gt;&gt; {&quot;. It&#39;s not just about less typing: parsing a function for the &#39;test&#39;<br>&gt;&gt; prefix is an Objective C holdover, and doesn&#39;t feel Swift to me, and it has<br>&gt;&gt; tests behaving like functions when - as illustrated in this proposal - they<br>&gt;&gt; should have different behaviours. It should be clearer when reading code<br>&gt;&gt; whether a function is a test or a helper function to make tests easier to<br>&gt;&gt; write.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sun, Jan 10, 2016 at 12:34 PM, James Campbell via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I would love it if we could do a full review of XCtest in general. As<br>&gt;&gt;&gt; there are other things it could help with I.r mocking or allowing us to<br>&gt;&gt;&gt; express tests in a BDD way<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 10 Jan 2016, at 10:29, Drew Crawford via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I have on the order of ~700 tests in XCTest in Swift-language projects.<br>&gt;&gt;&gt; I&#39;m considering migrating away from XCTest, although not over this issue.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This proposal IMO addresses an important problem, but I am not convinced<br>&gt;&gt;&gt; it actually solves it.  #2 &amp; #3 are basically sound API designs.  It is a<br>&gt;&gt;&gt; mystery to me why #3 &quot;generated some debate&quot; as this is a feature I already<br>&gt;&gt;&gt; implement manually, but I can&#39;t address unknown concerns.  I can tell you I<br>&gt;&gt;&gt; implement this, and nothing terrible has happened to me so far.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; #1 I would not use.  The rest of this comment explains why.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently I write tests about like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; try! hopefullyNothingBad()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Now this is &quot;bad&quot; because it &quot;crashes&quot; but that&#39;s (big sigh) actually<br>&gt;&gt;&gt; &quot;good&quot; because the debugger stops and/or I get a crash report that<br>&gt;&gt;&gt; identifies at least &quot;some&quot; line where something bad definitely happened.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Now that is not everything I *want* to know–I *want* someone to tell me<br>&gt;&gt;&gt; a story of how this error was created deep down in the bowels of my<br>&gt;&gt;&gt; application, how it spent its kindergarten years in the models layer before<br>&gt;&gt;&gt; being passed into a controller where it was rethrown onto a different<br>&gt;&gt;&gt; dispatch queue and finally ended up in my unit test–but we can&#39;t have<br>&gt;&gt;&gt; everything.  So I settle for collecting a line number from the test case<br>&gt;&gt;&gt; and then going hunting by hand.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When the test function throws we no longer even find out a line number<br>&gt;&gt;&gt; in the test case anymore, because the error is passed into XCTest and the<br>&gt;&gt;&gt; information is lost.  We have just the name of the test case (I assume; the<br>&gt;&gt;&gt; proposal is silent on this issue, but that&#39;s the only way I can think of to<br>&gt;&gt;&gt; implement it), and some of my tests are pretty long.  So, that makes it<br>&gt;&gt;&gt; even harder to track down.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This sounds like a small thing but my test coverage is so thorough on<br>&gt;&gt;&gt; mature projects that mostly what I turn up are heisenbugs that reproduce<br>&gt;&gt;&gt; with 2% probability.  So getting the report from the CI that has the most<br>&gt;&gt;&gt; possible detail is critical, because if the report is not thorough enough<br>&gt;&gt;&gt; for you to guess the bug, too bad, because that&#39;s all the information you<br>&gt;&gt;&gt; get and the bug is not reproducible.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For that reason, I won&#39;t use #1.  I hesitate about whether to call it<br>&gt;&gt;&gt; bad idea altogether, or whether it&#39;s just not to my taste.  My sense is<br>&gt;&gt;&gt; it&#39;s probably somewhere in the middle of those two poles.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I would use #2 and #3, assuming that I don&#39;t first migrate out to a<br>&gt;&gt;&gt; non-XCTest framework.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jan 9, 2016, at 8:58 PM, Chris Hanson via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We’d like feedback on a proposed design for adding support for Swift<br>&gt;&gt;&gt; error handling to XCTest, attached below. I’ll mostly let the proposal<br>&gt;&gt;&gt; speak for itself, but there are three components to it: Allowing test<br>&gt;&gt;&gt; methods to throw errors, allowing the expressions evaluated by assertions<br>&gt;&gt;&gt; to throw errors, and adding an assertion for checking error handling.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We’d love to hear your feedback. We’re particularly interested in some<br>&gt;&gt;&gt; feedback on the idea of allowing the expressions evaluated by assertions to<br>&gt;&gt;&gt; throw errors; it’s generated some debate because it results in writing test<br>&gt;&gt;&gt; code slightly differently than other code that makes use of Swift error<br>&gt;&gt;&gt; handling, so any thoughts on it would be particularly appreciated.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   -- Chris Hanson (chanson at apple.com)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; XCTest Support for Swift Error Handling<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt;&gt;    - Author(s): Chris Hanson &lt;https://github.com/eschaton&gt;<br>&gt;&gt;&gt;    - Status: *Review*<br>&gt;&gt;&gt;    - Review manager: TBD<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift 2 introduced a new error handling mechanism that, for<br>&gt;&gt;&gt; completeness, needs to be accommodated by our testing frameworks. Right<br>&gt;&gt;&gt; now, to write tests that involve methods that may throw an error, a<br>&gt;&gt;&gt; developer needs to incorporate significant boilerplate into their test. We<br>&gt;&gt;&gt; should move this into the framework in several ways, so tests of code that<br>&gt;&gt;&gt; interacts with Swift error handling is concise and intention-revealing.<br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently, if a developer wants to use a call that may throw an error in<br>&gt;&gt;&gt; a test, they need to use Swift&#39;s do..catch construct in their test<br>&gt;&gt;&gt; because tests are not themselves allowed to throw errors.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As an example, a vending machine object that has had insufficient funds<br>&gt;&gt;&gt; deposited may throw an error if asked to vend an item. A test for that<br>&gt;&gt;&gt; situation could reasonably use the do..catchconstruct to check that<br>&gt;&gt;&gt; this occurs as expected. However, that means all other tests *also* need<br>&gt;&gt;&gt; to use either a do..catch or try! construct — and the failure of a try! is<br>&gt;&gt;&gt; catastrophic, so do..catch would be preferred simply for better<br>&gt;&gt;&gt; reporting within tests.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func testVendingOneItem() {<br>&gt;&gt;&gt;     do {<br>&gt;&gt;&gt;         vendingMachine.deposit(5)<br>&gt;&gt;&gt;         let item = try vendingMachine.vend(row: 1, column: 1)<br>&gt;&gt;&gt;         XCTAssertEqual(item, &quot;Candy Bar&quot;)<br>&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;         XCTFail(&quot;Unexpected failure: \(error)&quot;)<br>&gt;&gt;&gt;     }}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If the implementation of VendingMachine.vend(row:column:) changes<br>&gt;&gt;&gt; during development such that it throws an error in this situation, the test<br>&gt;&gt;&gt; will fail as it should.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One other downside of the above is that a failure caught this way will<br>&gt;&gt;&gt; be reported as an *expected failure*, which would normally be a failure<br>&gt;&gt;&gt; for which XCTest is explicitly testing via an assertion. This failure<br>&gt;&gt;&gt; should ideally be treated as an *unexpected failure*, as it&#39;s not one<br>&gt;&gt;&gt; that&#39;s anticipated in the execution of the test.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In addition, tests do not currently support throwing an error from<br>&gt;&gt;&gt; within an assertion, requiring any code that throws an error to be invoked<br>&gt;&gt;&gt; outside the assertion itself using the same techniques described above.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Finally, since Swift error handling is a general mechanism that<br>&gt;&gt;&gt; developers should be implementing in their own applications and frameworks,<br>&gt;&gt;&gt; we need to make it straightforward to write tests that ensure code that<br>&gt;&gt;&gt; implements error handling does so correctly.<br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I propose several related solutions to this issue:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    1. Allow test methods to throw errors.<br>&gt;&gt;&gt;    2. Allow test assertion expressions to throw errors.<br>&gt;&gt;&gt;    3. Add an assertion for checking errors.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; These solutions combine to make writing tests that involve thrown errors<br>&gt;&gt;&gt; much more succinct.<br>&gt;&gt;&gt; Allowing Test Methods to Throw Errors<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; First, we can allow test methods to throw errors if desired, thus<br>&gt;&gt;&gt; allowing the do..catch construct to be omitted when the test isn&#39;t<br>&gt;&gt;&gt; directly checking error handling. This makes the code a developer writes<br>&gt;&gt;&gt; when they&#39;re not explicitly trying to test error handling much cleaner.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Moving the handling of errors thrown by tests into XCTest itself also<br>&gt;&gt;&gt; ensures they can be treated as unexpected failures, since the mechanism to<br>&gt;&gt;&gt; do so is currently private to the framework.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; With this, the test from the previous section can become:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func testVendingOneItem() throws {<br>&gt;&gt;&gt;     vendingMachine.deposit(5)<br>&gt;&gt;&gt;     let item = try vendingMachine.vend(row: 1, column: 1)<br>&gt;&gt;&gt;     XCTAssertEqual(item, &quot;Candy Bar&quot;)}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This shows much more directly that the test is intended to check a<br>&gt;&gt;&gt; specific non-error case, and that the developer is relying on the framework<br>&gt;&gt;&gt; to handle unexpected errors.<br>&gt;&gt;&gt; Allowing Test Assertions to Throw Errors<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We can also allow the @autoclosure expression that is passed into an<br>&gt;&gt;&gt; assertion to throw an error, and treat that error as an unexpected failure<br>&gt;&gt;&gt; (since the code is being invoked in an assertion that isn&#39;t directly<br>&gt;&gt;&gt; related to error handling). For example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func testVendingMultipleItemsWithSufficientFunds() {<br>&gt;&gt;&gt;     vendingMachine.deposit(10)<br>&gt;&gt;&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 1), &quot;Candy Bar&quot;)<br>&gt;&gt;&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 2), &quot;Chips&quot;)}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This can eliminate otherwise-dangerous uses of try! and streamline code<br>&gt;&gt;&gt; that needs to make multiple assertions in a row.<br>&gt;&gt;&gt; Adding a &quot;Throws Error&quot; Assertion<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In order to test code that throws an error, it would be useful to have<br>&gt;&gt;&gt; an assertion that expects an error to be thrown in a particular case. Right<br>&gt;&gt;&gt; now a developer writing code to test that an error is thrown has to test<br>&gt;&gt;&gt; that error themselves:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func testVendingFailsWithInsufficientFunds() {<br>&gt;&gt;&gt;         vendingMachine.deposit(1)<br>&gt;&gt;&gt;         var vendingFailed = false<br>&gt;&gt;&gt;         do {<br>&gt;&gt;&gt;             _ = try vendingMachine.vend(row: 1, column: 1))<br>&gt;&gt;&gt;         } catch {<br>&gt;&gt;&gt;             vendingFailed = true<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         XCTAssert(vendingFailed)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If we add an assertion that specifically checks whether an error was<br>&gt;&gt;&gt; thrown, this code will be significantly streamlined:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func testVendingFailsWithInsufficientFunds() {<br>&gt;&gt;&gt;         vendingMachine.deposit(1)<br>&gt;&gt;&gt;         XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1))<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Of course, some code may want to just detect that an error was thrown,<br>&gt;&gt;&gt; but other code may need to check that the details of the thrown error are<br>&gt;&gt;&gt; correct. We can take advantage of Swift&#39;s trailing closure syntax to enable<br>&gt;&gt;&gt; this, by passing the thrown error (if any) to a closure that can itself<br>&gt;&gt;&gt; contain assertions:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1)) { error in<br>&gt;&gt;&gt;         guard let vendingError = error as? VendingMachineError else {<br>&gt;&gt;&gt;             XCTFail(&quot;Unexpected type of error thrown: \(error)&quot;)<br>&gt;&gt;&gt;             return<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         XCTAssertEquals(vendingError.item, &quot;Candy Bar&quot;)<br>&gt;&gt;&gt;         XCTAssertEquals(vendingError.price, 5)<br>&gt;&gt;&gt;         XCTAssertEquals(vendingError.message, &quot;A Candy Bar costs 5 coins&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This lets a developer very concisely describe an error condition for<br>&gt;&gt;&gt; their code, in whatever level of detail they desire.<br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The design of each of the above components is slightly different, based<br>&gt;&gt;&gt; on the functionality provided.<br>&gt;&gt;&gt; Tests That Throw<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In order to enable test methods to throw an error, we will need to<br>&gt;&gt;&gt; update XCTest to support test methods with a () throws -&gt; Void signature<br>&gt;&gt;&gt; in addition to test methods with a () -&gt; Voidsignature as it already<br>&gt;&gt;&gt; supports.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We will need to ensure tests that do throw an error have that error<br>&gt;&gt;&gt; caught, and that it registers an unexpected failure.<br>&gt;&gt;&gt; Assertions That Throw<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In order to allow assertions to throw an exception, we will need to<br>&gt;&gt;&gt; enhance our existing assertions&#39; @autoclosure expression parameters to<br>&gt;&gt;&gt; add throws to their signature.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Because Swift defines a closure that can throw an error to be a proper<br>&gt;&gt;&gt; supertype of a closure that does not, this *will not* result in a<br>&gt;&gt;&gt; combinatorial explosion of assertion overrides, and will let developers<br>&gt;&gt;&gt; naturally write code that may throw an error within an assertion.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We will treat any error thrown from within an assertion expression as an<br>&gt;&gt;&gt; *unexpected* failure because while all assertions represent a test for<br>&gt;&gt;&gt; some form of failure, they&#39;re not specifically checking for a thrown error.<br>&gt;&gt;&gt; The &quot;Throws Error&quot; Assertion<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; To write tests for code that throws error, we will add a new assertion<br>&gt;&gt;&gt; function to XCTest with the following prototype:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public func XCTAssertThrowsError(<br>&gt;&gt;&gt;     @autoclosure expression: () throws -&gt; Void,<br>&gt;&gt;&gt;                   _ message: String = &quot;&quot;,<br>&gt;&gt;&gt;                        file: StaticString = __FILE__,<br>&gt;&gt;&gt;                        line: UInt = __LINE__,<br>&gt;&gt;&gt;              _ errorHandler: (error: ErrorType) -&gt; Void = { _ in })<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Rather than treat an error thrown from its expression as a failure, this<br>&gt;&gt;&gt; will treat *the lack of* an error thrown from its expression as an<br>&gt;&gt;&gt; expected failure.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Furthermore, so long as an error is thrown, the error will be passed to<br>&gt;&gt;&gt; the errorHandler block passed as a trailing closure, where the<br>&gt;&gt;&gt; developer may make further assertions against it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In both cases, the new assertion function is generic on an ErrorType in<br>&gt;&gt;&gt; order to ensure that little to no casting will be required in the trailing<br>&gt;&gt;&gt; closure.<br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There should be little impact on existing test code because we are only<br>&gt;&gt;&gt; adding features and API, not changing existing features or API.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; All existing tests should continue to work as implemented, and can<br>&gt;&gt;&gt; easily adopt the new conventions we&#39;re making available to become more<br>&gt;&gt;&gt; concise and intention-revealing with respect to their error handling as<br>&gt;&gt;&gt; shown above.<br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We considered asking developers continue using XCTest as-is, and<br>&gt;&gt;&gt; encouraging them to use Swift&#39;s native error handling to both suppress and<br>&gt;&gt;&gt; check the validity of errors. We also considered adding additional ways of<br>&gt;&gt;&gt; registering failures when doing this, so that developers could register<br>&gt;&gt;&gt; unexpected failures themselves.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; While this would result in developers using the language the same way in<br>&gt;&gt;&gt; their tests as in their functional code, this would also result in much<br>&gt;&gt;&gt; more verbose tests. We rejected this approach because such verbosity can be<br>&gt;&gt;&gt; a significant obstacle to testing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Making it quick and clean to write tests for error handling could also<br>&gt;&gt;&gt; encourage developers to implement error handling in their code as they need<br>&gt;&gt;&gt; it, rather than to try to work around the feature because of any perceived<br>&gt;&gt;&gt; difficulty in testing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We considered adding the ability to check that a specific error was<br>&gt;&gt;&gt; thrown in XCTAssertThrowsError, but this would require the ErrorType passed<br>&gt;&gt;&gt; to also conform to Equatable, which is also unnecessary given that this<br>&gt;&gt;&gt; can easily be checked in a trailing closure if desired. (In some cases a<br>&gt;&gt;&gt; developer may just want to ensure *an error* is thrown rather than *a<br>&gt;&gt;&gt; specific error* is thrown.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We explicitly chose *not* to offer a comprehensive suite of<br>&gt;&gt;&gt; DoesNotThrowError assertions for XCTest in Swift, though we do offer<br>&gt;&gt;&gt; such DoesNotThrow assertions for XCTest in Objective-C. We feel these<br>&gt;&gt;&gt; are of limited utility given that our plan is for all assertions (except<br>&gt;&gt;&gt; XCTAssertThrowsError) to treat any thrown error as a failure.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We explicitly chose not to offer any additional support for Objective-C<br>&gt;&gt;&gt; exceptions beyond what we already provide: In the Xcode implementation of<br>&gt;&gt;&gt; XCTest, an Objective-C exception that occurs within one of our existing<br>&gt;&gt;&gt; assertions or tests will result in a test failure; doing more than this is<br>&gt;&gt;&gt; not practical given that it&#39;s possible to neither catch and handle nor<br>&gt;&gt;&gt; generate an Objective-C exception in Swift.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;  Wizard<br>&gt; james at supmenow.com<br>&gt; +44 7523 279 698<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/a800acc5/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cd2919ebf2f35a905b24e5002b4dd836?s=50"></div><header><strong>Proposal: XCTest Support for Swift Error Handling</strong> from <string>Chris Hanson</string> &lt;chanson at apple.com&gt;<p>January 10, 2016 at 04:00:00pm</p></header><div class="content"><p>The degree of change to which XCTest is open via the Swift process would be best discussed as a separate thread on either swift-corelibs-xctest or swift-evolution. Please keep this thread to discussion of the error handling proposal. Thanks.<br></p><p>  -- Chris<br></p><p>Sent from my iPad<br></p><p>&gt; On Jan 10, 2016, at 4:34 AM, James Campbell &lt;james at supmenow.com&gt; wrote:<br>&gt; <br>&gt; I would love it if we could do a full review of XCtest in general. As there are other things it could help with I.r mocking or allowing us to express tests in a BDD way <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 10 Jan 2016, at 10:29, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have on the order of ~700 tests in XCTest in Swift-language projects.  I&#39;m considering migrating away from XCTest, although not over this issue.<br>&gt;&gt; <br>&gt;&gt; This proposal IMO addresses an important problem, but I am not convinced it actually solves it.  #2 &amp; #3 are basically sound API designs.  It is a mystery to me why #3 &quot;generated some debate&quot; as this is a feature I already implement manually, but I can&#39;t address unknown concerns.  I can tell you I implement this, and nothing terrible has happened to me so far.<br>&gt;&gt; <br>&gt;&gt; #1 I would not use.  The rest of this comment explains why.<br>&gt;&gt; <br>&gt;&gt; Currently I write tests about like this:<br>&gt;&gt; <br>&gt;&gt; try! hopefullyNothingBad()<br>&gt;&gt; <br>&gt;&gt; Now this is &quot;bad&quot; because it &quot;crashes&quot; but that&#39;s (big sigh) actually &quot;good&quot; because the debugger stops and/or I get a crash report that identifies at least &quot;some&quot; line where something bad definitely happened.<br>&gt;&gt; <br>&gt;&gt; Now that is not everything I want to know–I want someone to tell me a story of how this error was created deep down in the bowels of my application, how it spent its kindergarten years in the models layer before being passed into a controller where it was rethrown onto a different dispatch queue and finally ended up in my unit test–but we can&#39;t have everything.  So I settle for collecting a line number from the test case and then going hunting by hand.<br>&gt;&gt; <br>&gt;&gt; When the test function throws we no longer even find out a line number in the test case anymore, because the error is passed into XCTest and the information is lost.  We have just the name of the test case (I assume; the proposal is silent on this issue, but that&#39;s the only way I can think of to implement it), and some of my tests are pretty long.  So, that makes it even harder to track down.<br>&gt;&gt; <br>&gt;&gt; This sounds like a small thing but my test coverage is so thorough on mature projects that mostly what I turn up are heisenbugs that reproduce with 2% probability.  So getting the report from the CI that has the most possible detail is critical, because if the report is not thorough enough for you to guess the bug, too bad, because that&#39;s all the information you get and the bug is not reproducible.<br>&gt;&gt; <br>&gt;&gt; For that reason, I won&#39;t use #1.  I hesitate about whether to call it bad idea altogether, or whether it&#39;s just not to my taste.  My sense is it&#39;s probably somewhere in the middle of those two poles.<br>&gt;&gt; <br>&gt;&gt; I would use #2 and #3, assuming that I don&#39;t first migrate out to a non-XCTest framework.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 9, 2016, at 8:58 PM, Chris Hanson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We’d like feedback on a proposed design for adding support for Swift error handling to XCTest, attached below. I’ll mostly let the proposal speak for itself, but there are three components to it: Allowing test methods to throw errors, allowing the expressions evaluated by assertions to throw errors, and adding an assertion for checking error handling.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We’d love to hear your feedback. We’re particularly interested in some feedback on the idea of allowing the expressions evaluated by assertions to throw errors; it’s generated some debate because it results in writing test code slightly differently than other code that makes use of Swift error handling, so any thoughts on it would be particularly appreciated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   -- Chris Hanson (chanson at apple.com)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; XCTest Support for Swift Error Handling<br>&gt;&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt;&gt; Author(s): Chris Hanson<br>&gt;&gt;&gt; Status: Review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; Swift 2 introduced a new error handling mechanism that, for completeness, needs to be accommodated by our testing frameworks. Right now, to write tests that involve methods that may throw an error, a developer needs to incorporate significant boilerplate into their test. We should move this into the framework in several ways, so tests of code that interacts with Swift error handling is concise and intention-revealing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; Currently, if a developer wants to use a call that may throw an error in a test, they need to use Swift&#39;s do..catch construct in their test because tests are not themselves allowed to throw errors.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As an example, a vending machine object that has had insufficient funds deposited may throw an error if asked to vend an item. A test for that situation could reasonably use the do..catchconstruct to check that this occurs as expected. However, that means all other tests also need to use either a do..catch or try! construct — and the failure of a try! is catastrophic, so do..catch would be preferred simply for better reporting within tests.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func testVendingOneItem() {<br>&gt;&gt;&gt;     do {<br>&gt;&gt;&gt;         vendingMachine.deposit(5)<br>&gt;&gt;&gt;         let item = try vendingMachine.vend(row: 1, column: 1)<br>&gt;&gt;&gt;         XCTAssertEqual(item, &quot;Candy Bar&quot;)<br>&gt;&gt;&gt;     } catch {<br>&gt;&gt;&gt;         XCTFail(&quot;Unexpected failure: \(error)&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; If the implementation of VendingMachine.vend(row:column:) changes during development such that it throws an error in this situation, the test will fail as it should.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One other downside of the above is that a failure caught this way will be reported as an expected failure, which would normally be a failure for which XCTest is explicitly testing via an assertion. This failure should ideally be treated as an unexpected failure, as it&#39;s not one that&#39;s anticipated in the execution of the test.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In addition, tests do not currently support throwing an error from within an assertion, requiring any code that throws an error to be invoked outside the assertion itself using the same techniques described above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, since Swift error handling is a general mechanism that developers should be implementing in their own applications and frameworks, we need to make it straightforward to write tests that ensure code that implements error handling does so correctly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; I propose several related solutions to this issue:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Allow test methods to throw errors.<br>&gt;&gt;&gt; Allow test assertion expressions to throw errors.<br>&gt;&gt;&gt; Add an assertion for checking errors.<br>&gt;&gt;&gt; These solutions combine to make writing tests that involve thrown errors much more succinct.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Allowing Test Methods to Throw Errors<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First, we can allow test methods to throw errors if desired, thus allowing the do..catch construct to be omitted when the test isn&#39;t directly checking error handling. This makes the code a developer writes when they&#39;re not explicitly trying to test error handling much cleaner.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Moving the handling of errors thrown by tests into XCTest itself also ensures they can be treated as unexpected failures, since the mechanism to do so is currently private to the framework.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With this, the test from the previous section can become:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func testVendingOneItem() throws {<br>&gt;&gt;&gt;     vendingMachine.deposit(5)<br>&gt;&gt;&gt;     let item = try vendingMachine.vend(row: 1, column: 1)<br>&gt;&gt;&gt;     XCTAssertEqual(item, &quot;Candy Bar&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; This shows much more directly that the test is intended to check a specific non-error case, and that the developer is relying on the framework to handle unexpected errors.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Allowing Test Assertions to Throw Errors<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We can also allow the @autoclosure expression that is passed into an assertion to throw an error, and treat that error as an unexpected failure (since the code is being invoked in an assertion that isn&#39;t directly related to error handling). For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func testVendingMultipleItemsWithSufficientFunds() {<br>&gt;&gt;&gt;     vendingMachine.deposit(10)<br>&gt;&gt;&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 1), &quot;Candy Bar&quot;)<br>&gt;&gt;&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 2), &quot;Chips&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; This can eliminate otherwise-dangerous uses of try! and streamline code that needs to make multiple assertions in a row.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Adding a &quot;Throws Error&quot; Assertion<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In order to test code that throws an error, it would be useful to have an assertion that expects an error to be thrown in a particular case. Right now a developer writing code to test that an error is thrown has to test that error themselves:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func testVendingFailsWithInsufficientFunds() {<br>&gt;&gt;&gt;         vendingMachine.deposit(1)<br>&gt;&gt;&gt;         var vendingFailed = false<br>&gt;&gt;&gt;         do {<br>&gt;&gt;&gt;             _ = try vendingMachine.vend(row: 1, column: 1))<br>&gt;&gt;&gt;         } catch {<br>&gt;&gt;&gt;             vendingFailed = true<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         XCTAssert(vendingFailed)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; If we add an assertion that specifically checks whether an error was thrown, this code will be significantly streamlined:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func testVendingFailsWithInsufficientFunds() {<br>&gt;&gt;&gt;         vendingMachine.deposit(1)<br>&gt;&gt;&gt;         XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1))<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; Of course, some code may want to just detect that an error was thrown, but other code may need to check that the details of the thrown error are correct. We can take advantage of Swift&#39;s trailing closure syntax to enable this, by passing the thrown error (if any) to a closure that can itself contain assertions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1)) { error in<br>&gt;&gt;&gt;         guard let vendingError = error as? VendingMachineError else {<br>&gt;&gt;&gt;             XCTFail(&quot;Unexpected type of error thrown: \(error)&quot;)<br>&gt;&gt;&gt;             return<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;         XCTAssertEquals(vendingError.item, &quot;Candy Bar&quot;)<br>&gt;&gt;&gt;         XCTAssertEquals(vendingError.price, 5)<br>&gt;&gt;&gt;         XCTAssertEquals(vendingError.message, &quot;A Candy Bar costs 5 coins&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; This lets a developer very concisely describe an error condition for their code, in whatever level of detail they desire.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; The design of each of the above components is slightly different, based on the functionality provided.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Tests That Throw<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In order to enable test methods to throw an error, we will need to update XCTest to support test methods with a () throws -&gt; Void signature in addition to test methods with a () -&gt; Voidsignature as it already supports.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We will need to ensure tests that do throw an error have that error caught, and that it registers an unexpected failure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Assertions That Throw<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In order to allow assertions to throw an exception, we will need to enhance our existing assertions&#39; @autoclosure expression parameters to add throws to their signature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Because Swift defines a closure that can throw an error to be a proper supertype of a closure that does not, this will not result in a combinatorial explosion of assertion overrides, and will let developers naturally write code that may throw an error within an assertion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We will treat any error thrown from within an assertion expression as an unexpected failure because while all assertions represent a test for some form of failure, they&#39;re not specifically checking for a thrown error.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The &quot;Throws Error&quot; Assertion<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To write tests for code that throws error, we will add a new assertion function to XCTest with the following prototype:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func XCTAssertThrowsError(<br>&gt;&gt;&gt;     @autoclosure expression: () throws -&gt; Void,<br>&gt;&gt;&gt;                   _ message: String = &quot;&quot;,<br>&gt;&gt;&gt;                        file: StaticString = __FILE__,<br>&gt;&gt;&gt;                        line: UInt = __LINE__,<br>&gt;&gt;&gt;              _ errorHandler: (error: ErrorType) -&gt; Void = { _ in })<br>&gt;&gt;&gt; Rather than treat an error thrown from its expression as a failure, this will treat the lack of an error thrown from its expression as an expected failure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Furthermore, so long as an error is thrown, the error will be passed to the errorHandler block passed as a trailing closure, where the developer may make further assertions against it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In both cases, the new assertion function is generic on an ErrorType in order to ensure that little to no casting will be required in the trailing closure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; There should be little impact on existing test code because we are only adding features and API, not changing existing features or API.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; All existing tests should continue to work as implemented, and can easily adopt the new conventions we&#39;re making available to become more concise and intention-revealing with respect to their error handling as shown above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; We considered asking developers continue using XCTest as-is, and encouraging them to use Swift&#39;s native error handling to both suppress and check the validity of errors. We also considered adding additional ways of registering failures when doing this, so that developers could register unexpected failures themselves.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While this would result in developers using the language the same way in their tests as in their functional code, this would also result in much more verbose tests. We rejected this approach because such verbosity can be a significant obstacle to testing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Making it quick and clean to write tests for error handling could also encourage developers to implement error handling in their code as they need it, rather than to try to work around the feature because of any perceived difficulty in testing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We considered adding the ability to check that a specific error was thrown in XCTAssertThrowsError, but this would require the ErrorType passed to also conform to Equatable, which is also unnecessary given that this can easily be checked in a trailing closure if desired. (In some cases a developer may just want to ensure an error is thrown rather than a specific error is thrown.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We explicitly chose not to offer a comprehensive suite of DoesNotThrowError assertions for XCTest in Swift, though we do offer such DoesNotThrow assertions for XCTest in Objective-C. We feel these are of limited utility given that our plan is for all assertions (except XCTAssertThrowsError) to treat any thrown error as a failure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We explicitly chose not to offer any additional support for Objective-C exceptions beyond what we already provide: In the Xcode implementation of XCTest, an Objective-C exception that occurs within one of our existing assertions or tests will result in a test failure; doing more than this is not practical given that it&#39;s possible to neither catch and handle nor generate an Objective-C exception in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/c7c94b22/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal: XCTest Support for Swift Error Handling</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 10, 2016 at 11:00:00am</p></header><div class="content"><p>On Sat, Jan 9, 2016 at 6:58 PM, Chris Hanson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Allowing Test Assertions to Throw Errors<br>&gt;<br>&gt; We can also allow the @autoclosure expression that is passed into an<br>&gt; assertion to throw an error, and treat that error as an unexpected failure<br>&gt; (since the code is being invoked in an assertion that isn&#39;t directly<br>&gt; related to error handling). For example:<br>&gt;<br>&gt; func testVendingMultipleItemsWithSufficientFunds() {<br>&gt;     vendingMachine.deposit(10)<br>&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 1), &quot;Candy Bar&quot;)<br>&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 2), &quot;Chips&quot;)}<br>&gt;<br>&gt;<br>I have significant concerns about doing this.  Consider the following code:<br></p><p>var foo = Foo()<br>do {<br>    XCTAssertEqual(try foo.doSomething(), 42)<br>} catch {<br>    XCTAssertEqual(foo.success, false)<br>}<br></p><p>Adding ‘throws’ to the autoclosures will:<br></p><p>(1) change meaning of existing tests (the example above used to proceed to<br>the catch block in case of errors, and will start failing with this change),<br></p><p>(2) hijacks ‘try’ and defeats its purpose — being able to understand the<br>control flow.  Developers know that if they see a ‘try’, it should match<br>with either a do-catch, or be used in a throwing function.  Adding this API<br>makes the code misleading.<br></p><p>Note that although (2) applies to the XCTAssertThrowsError() API, because<br>the name of that API makes it clear it is doing something special with<br>error handling, I’m not concerned about it.  But adding error handling to<br>regular assertion functions has the potential to create misleading code.<br></p><p>Changing the way control flow works breaks one of the basic language<br>features — substitutability:<br></p><p>let bar1 = try bar()<br>foo(bar1)<br></p><p>should be equivalent to:<br></p><p>foo(try bar())<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/0ee4c193/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: XCTest Support for Swift Error Handling</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 10, 2016 at 05:00:00pm</p></header><div class="content"><p>On Sun, Jan 10, 2016, at 11:18 AM, Dmitri Gribenko via swift-evolution wrote:0<br>&gt; I have significant concerns about doing this.  Consider the following code:<br>&gt;<br>&gt; var foo = Foo() do {    XCTAssertEqual(try foo.doSomething(), 42) }<br>&gt; catch {    XCTAssertEqual(foo.success, false) }<br>&gt;<br>&gt; Adding ‘throws’ to the autoclosures will:<br>&gt;<br>&gt; (1) change meaning of existing tests (the example above used to<br>&gt;     proceed to the catch block in case of errors, and will start<br>&gt;     failing with this change),<br></p><p>Did you actually test this code? Because this code *does not compile<br>today*. You cannot pass a throwing expression to an @autoclosure that<br>takes a non-throwing function. The specific error you get is<br></p><p>error: call can throw, but it is executed in a non-throwing autoclosure<br></p><p>&gt; (2) hijacks ‘try’ and defeats its purpose — being able to understand<br>&gt;     the control flow.  Developers know that if they see a ‘try’, it<br>&gt;     should match with either a do-catch, or be used in a throwing<br>&gt;     function.  Adding this API makes the code misleading.<br></p><p>Or use it in a throwing @autoclosure.<br></p><p>&gt; Note that although (2) applies to the XCTAssertThrowsError() API,<br>&gt; because the name of that API makes it clear it is doing something<br>&gt; special with error handling, I’m not concerned about it.  But adding<br>&gt; error handling to regular assertion functions has the potential to<br>&gt; create misleading code.<br>&gt;<br>&gt; Changing the way control flow works breaks one of the basic language<br>&gt; features — substitutability:<br>&gt;<br>&gt; let bar1 = try bar() foo(bar1)<br>&gt;<br>&gt; should be equivalent to:<br>&gt;<br>&gt; foo(try bar())<br></p><p>@autoclosure already breaks that. Adding error handling to the<br>@autoclosure doesn&#39;t change anything. In fact, breaking that<br>substitutability is basically the whole reason for @autoclosure to<br>exist.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/b7108140/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>Proposal: XCTest Support for Swift Error Handling</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>January 11, 2016 at 06:00:00pm</p></header><div class="content"><p>I think I am in full agreement with Dmitri on this: The XCTAssertThrowsError should be the only one that interacts with errors and that others should not try to hijack the try.<br></p><p>But super-big +1 on the XCTAssertThrowsError being in place to verify error cases; swift-corelibs-foundation is missing a lot of testing of error cases and it would be nice to have an effort to start verifying those (and their structures)<br></p><p>&gt; On Jan 10, 2016, at 11:18 AM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Sat, Jan 9, 2016 at 6:58 PM, Chris Hanson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Allowing Test Assertions to Throw Errors<br>&gt; <br>&gt; We can also allow the @autoclosure expression that is passed into an assertion to throw an error, and treat that error as an unexpected failure (since the code is being invoked in an assertion that isn&#39;t directly related to error handling). For example:<br>&gt; <br>&gt; func testVendingMultipleItemsWithSufficientFunds() {<br>&gt;     vendingMachine.deposit(10)<br>&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 1), &quot;Candy Bar&quot;)<br>&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 2), &quot;Chips&quot;)<br>&gt; }<br>&gt; <br>&gt; I have significant concerns about doing this.  Consider the following code:<br>&gt; <br>&gt; var foo = Foo()<br>&gt; do {<br>&gt;     XCTAssertEqual(try foo.doSomething(), 42)<br>&gt; } catch {<br>&gt;     XCTAssertEqual(foo.success, false)<br>&gt; }<br>&gt; <br>&gt; Adding ‘throws’ to the autoclosures will:<br>&gt; <br>&gt; (1) change meaning of existing tests (the example above used to proceed to the catch block in case of errors, and will start failing with this change),<br>&gt; <br>&gt; (2) hijacks ‘try’ and defeats its purpose — being able to understand the control flow.  Developers know that if they see a ‘try’, it should match with either a do-catch, or be used in a throwing function.  Adding this API makes the code misleading.<br>&gt; <br>&gt; Note that although (2) applies to the XCTAssertThrowsError() API, because the name of that API makes it clear it is doing something special with error handling, I’m not concerned about it.  But adding error handling to regular assertion functions has the potential to create misleading code.<br>&gt; <br>&gt; Changing the way control flow works breaks one of the basic language features — substitutability:<br>&gt; <br>&gt; let bar1 = try bar()<br>&gt; foo(bar1)<br>&gt; <br>&gt; should be equivalent to:<br>&gt; <br>&gt; foo(try bar())<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/a2e2c727/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cd2919ebf2f35a905b24e5002b4dd836?s=50"></div><header><strong>Proposal: XCTest Support for Swift Error Handling</strong> from <string>Chris Hanson</string> &lt;chanson at apple.com&gt;<p>January 11, 2016 at 06:00:00pm</p></header><div class="content"><p>As Kevin Ballard pointed out, the examples give won’t currently compile and give the error “Call can throw, but it is executed in a non-throwing autoclosure.” I also don’t think they match up to what most developers would write. If it did compile, I would expect a developer to either just tack “throws” onto the test method, or to write something more like this:<br></p><p>func testFoo() {<br>    var foo = Foo()<br>    do {<br>        XCTAssertEqual(try foo.doSomething(), 42)<br>    } catch(<br>        XCTFail(&quot;testFoo failed: threw error \(error)&quot;)<br>    }<br>}<br></p><p>Then if they turn out to need easy matching between unexpected failures and individual calls, they will wind up writing multiple do…try blocks in their tests, one per expression that can throw, until they have sufficient granularity that a test failure in a log can instantly pinpoint the code that failed.<br></p><p>I think that would wind up cluttering up tests that are mostly intended not to be about error handling. That’s why I think it’s better to just let all of the assertions catch thrown errors as well, regardless of the substitutability argument; the assertions are already “special” by doing delayed rather than immediate evaluation, so I don’t think we’re really changing them all that much by allowing the assertion expression to throw.<br></p><p>Ultimately, I think allowing assertion expressions to throw makes tests easier to write as well as to read &amp; maintain over time by moving as much of the burden of error handling on the success path to the testing framework itself. In this model, the only error handling code a developer needs to write in their tests is actually testing their error handling.<br></p><p>  -- Chris<br></p><p><br>&gt; On Jan 11, 2016, at 6:15 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; I think I am in full agreement with Dmitri on this: The XCTAssertThrowsError should be the only one that interacts with errors and that others should not try to hijack the try.<br>&gt; <br>&gt; But super-big +1 on the XCTAssertThrowsError being in place to verify error cases; swift-corelibs-foundation is missing a lot of testing of error cases and it would be nice to have an effort to start verifying those (and their structures)<br>&gt; <br>&gt;&gt; On Jan 10, 2016, at 11:18 AM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Sat, Jan 9, 2016 at 6:58 PM, Chris Hanson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Allowing Test Assertions to Throw Errors<br>&gt;&gt; <br>&gt;&gt; We can also allow the @autoclosure expression that is passed into an assertion to throw an error, and treat that error as an unexpected failure (since the code is being invoked in an assertion that isn&#39;t directly related to error handling). For example:<br>&gt;&gt; <br>&gt;&gt; func testVendingMultipleItemsWithSufficientFunds() {<br>&gt;&gt;     vendingMachine.deposit(10)<br>&gt;&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 1), &quot;Candy Bar&quot;)<br>&gt;&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 2), &quot;Chips&quot;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I have significant concerns about doing this.  Consider the following code:<br>&gt;&gt; <br>&gt;&gt; var foo = Foo()<br>&gt;&gt; do {<br>&gt;&gt;     XCTAssertEqual(try foo.doSomething(), 42)<br>&gt;&gt; } catch {<br>&gt;&gt;     XCTAssertEqual(foo.success, false)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Adding ‘throws’ to the autoclosures will:<br>&gt;&gt; <br>&gt;&gt; (1) change meaning of existing tests (the example above used to proceed to the catch block in case of errors, and will start failing with this change),<br>&gt;&gt; <br>&gt;&gt; (2) hijacks ‘try’ and defeats its purpose — being able to understand the control flow.  Developers know that if they see a ‘try’, it should match with either a do-catch, or be used in a throwing function.  Adding this API makes the code misleading.<br>&gt;&gt; <br>&gt;&gt; Note that although (2) applies to the XCTAssertThrowsError() API, because the name of that API makes it clear it is doing something special with error handling, I’m not concerned about it.  But adding error handling to regular assertion functions has the potential to create misleading code.<br>&gt;&gt; <br>&gt;&gt; Changing the way control flow works breaks one of the basic language features — substitutability:<br>&gt;&gt; <br>&gt;&gt; let bar1 = try bar()<br>&gt;&gt; foo(bar1)<br>&gt;&gt; <br>&gt;&gt; should be equivalent to:<br>&gt;&gt; <br>&gt;&gt; foo(try bar())<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/d2993a18/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: XCTest Support for Swift Error Handling</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 10, 2016 at 06:00:00pm</p></header><div class="content"><p>On Sat, Jan 9, 2016, at 06:58 PM, Chris Hanson via swift-evolution wrote:<br>&gt; We’d like feedback on a proposed design for adding support for Swift error handling to XCTest, attached below. I’ll mostly let the proposal speak for itself, but there are three components to it: Allowing test methods to throw errors, allowing the expressions evaluated by assertions to throw errors, and adding an assertion for checking error handling.<br>&gt;  <br>&gt; We’d love to hear your feedback. We’re particularly interested in some feedback on the idea of allowing the expressions evaluated by assertions to throw errors; it’s generated some debate because it results in writing test code slightly differently than other code that makes use of Swift error handling, so any thoughts on it would be particularly appreciated.<br> <br>Very strong +1 to the entire proposal. I&#39;ve been meaning to submit something like this for a while, though not as comprehensive as what you have here. In particular, making all the @autoclosure-accepting functions take a throwing closure and reporting errors as failures solves my biggest annoyance with XCTest. Making the test functions themselves also be able to throw is a neat idea too. And the trailing closure argument to XCTAssertThrowsError is a good idea.<br> <br>The only change I&#39;d like to make to this proposal is to XCTAssertThrowsError. Instead of having it take an autoclosure that returns Void, it should just be generic so it can take a closure that returns any type. That gets rid of the need for `_ =` in the argument, and XCTest could even report the actual return value in the event that the closure does not, in fact, throw an error.<br> <br>I also wonder if maybe there&#39;s some utility in adding an overload to XCTAssertThrowsError that accepts any Equatable ErrorType as the second parameter, to simplify the cases where you do want to test against some specific error that happens to be Equatable. Although I&#39;m not sure how likely it is for any given ErrorType to also be Equatable. The overload might look like<br> <br>public func XCTAssertThrowsError&lt;T, E: ErrorType where E: Equatable&gt;(<br>    @autoclosure expression: () throws -&gt; T,<br>    _ message: String = &quot;&quot;,<br>    file: StaticString = __FILE__,<br>    line: UInt = __LINE__,<br>    _ expectedError: E<br>) {<br>    XCTAssertThrowsError(expression, message, file: file, line: line) { error in<br>        if let error = error as? E {<br>            if error != expectedError {<br>                XCTFail(&quot;Expected error \(expectedError), found error \(error)&quot;)<br>            }<br>        } else {<br>            XCTFail(&quot;Unexpected type of error thrown: \(error)&quot;)<br>        }<br>    }<br>}<br> <br>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/7916b9d1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f921fa5d507b31ef6984fd3d77ae710c?s=50"></div><header><strong>Proposal: XCTest Support for Swift Error Handling</strong> from <string>Brian Gesiak</string> &lt;modocache at gmail.com&gt;<p>January 10, 2016 at 09:00:00pm</p></header><div class="content"><p>Chris: Thank you for also sending this to the swift-corelibs-dev mailing list!<br></p><p>I am in favor of the proposed changes; I think they are a great step<br>forward for testing throwing functions in Swift. That being said, I&#39;ve<br>rarely used Swift error handling in my own applications--until now I<br>have preferred Result&lt;T, U&gt; (see:<br>http://www.sunsetlakesoftware.com/2015/06/12/swift-2-error-handling-practice).<br></p><p>I agree with Kevin Ballard&#39;s proposed amendment to the<br>`XCTAssertThrowsError` parameter type. As-is, I imagine many users of<br>the proposed API would be confused as to why they need to type<br>`XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column:<br>1))`.<br></p><p>&gt; Because Swift defines a closure that can throw an error to be a proper supertype of a closure that does not<br></p><p>Chris: How fortuitous! Glad to hear that we won&#39;t have to append a<br>`throws` to all of our test functions.<br></p><p>&gt; I&#39;m considering migrating away from XCTest, although not over this issue.<br></p><p>Drew: I&#39;d be very interested to hear why. If it&#39;s something you feel<br>can be addressed in swift-corelibs-xctest, please email the<br>swift-corelibs-dev mailing list with your concerns. Otherwise I would<br>be glad if you could send me an email.<br></p><p>- Brian Gesiak<br></p><p><br>On Sun, Jan 10, 2016 at 6:08 PM, Kevin Ballard via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; On Sat, Jan 9, 2016, at 06:58 PM, Chris Hanson via swift-evolution wrote:<br>&gt;<br>&gt; We’d like feedback on a proposed design for adding support for Swift error<br>&gt; handling to XCTest, attached below. I’ll mostly let the proposal speak for<br>&gt; itself, but there are three components to it: Allowing test methods to throw<br>&gt; errors, allowing the expressions evaluated by assertions to throw errors,<br>&gt; and adding an assertion for checking error handling.<br>&gt;<br>&gt; We’d love to hear your feedback. We’re particularly interested in some<br>&gt; feedback on the idea of allowing the expressions evaluated by assertions to<br>&gt; throw errors; it’s generated some debate because it results in writing test<br>&gt; code slightly differently than other code that makes use of Swift error<br>&gt; handling, so any thoughts on it would be particularly appreciated.<br>&gt;<br>&gt;<br>&gt; Very strong +1 to the entire proposal. I&#39;ve been meaning to submit something<br>&gt; like this for a while, though not as comprehensive as what you have here. In<br>&gt; particular, making all the @autoclosure-accepting functions take a throwing<br>&gt; closure and reporting errors as failures solves my biggest annoyance with<br>&gt; XCTest. Making the test functions themselves also be able to throw is a neat<br>&gt; idea too. And the trailing closure argument to XCTAssertThrowsError is a<br>&gt; good idea.<br>&gt;<br>&gt; The only change I&#39;d like to make to this proposal is to<br>&gt; XCTAssertThrowsError. Instead of having it take an autoclosure that returns<br>&gt; Void, it should just be generic so it can take a closure that returns any<br>&gt; type. That gets rid of the need for `_ =` in the argument, and XCTest could<br>&gt; even report the actual return value in the event that the closure does not,<br>&gt; in fact, throw an error.<br>&gt;<br>&gt; I also wonder if maybe there&#39;s some utility in adding an overload to<br>&gt; XCTAssertThrowsError that accepts any Equatable ErrorType as the second<br>&gt; parameter, to simplify the cases where you do want to test against some<br>&gt; specific error that happens to be Equatable. Although I&#39;m not sure how<br>&gt; likely it is for any given ErrorType to also be Equatable. The overload<br>&gt; might look like<br>&gt;<br>&gt; public func XCTAssertThrowsError&lt;T, E: ErrorType where E: Equatable&gt;(<br>&gt;     @autoclosure expression: () throws -&gt; T,<br>&gt;     _ message: String = &quot;&quot;,<br>&gt;     file: StaticString = __FILE__,<br>&gt;     line: UInt = __LINE__,<br>&gt;     _ expectedError: E<br>&gt; ) {<br>&gt;     XCTAssertThrowsError(expression, message, file: file, line: line) {<br>&gt; error in<br>&gt;         if let error = error as? E {<br>&gt;             if error != expectedError {<br>&gt;                 XCTFail(&quot;Expected error \(expectedError), found error<br>&gt; \(error)&quot;)<br>&gt;             }<br>&gt;         } else {<br>&gt;             XCTFail(&quot;Unexpected type of error thrown: \(error)&quot;)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8da0cba30fa0e47cf4fb26ebb968e552?s=50"></div><header><strong>Proposal: XCTest Support for Swift Error Handling</strong> from <string>Jérôme Duquennoy</string> &lt;jerome+swift at duquennoy.fr&gt;<p>January 11, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi everyone,<br></p><p>I did encounter this problem too : I find the error handling model of swift pretty nice, so I use it a lot. And of course, I need to unit test those error cases behaviours of my code.<br></p><p>I don’t think test methods that throws does address the problem : if we do so, we will have only one information, an error was thrown by some line of code.<br>But in the test itself there are very different types of code :<br>- the setup<br>- the execution (the call to the method that is being unit-tested)<br>- the validation code<br></p><p>I need to be able to handle errors differently depending on whether it is thrown in the setup or in the execution.<br>In the first case, the problem is that the test cannot run correctly. It will fail, but not because the tested behaviour failed. I treat those errors with a try!, and if it fails, the test is reported in “error” state by my CI system (crash of the test)<br>In the second case, the tested behaviour is invalide. I need it to fail with an assertion failure, so that the test is reported in “failed” state by my CI system<br></p><p>So on my side, I go for solution 3, but I would also add an assert that no error is thrown. Consider for exemple a case where you have an integer input parameter with a range, but the contract of your API is that if the range is exceeded, the value will be restricted but no error will be thrown. That behaviour should be unit tested, and the assertNoThrow can be useful.<br></p><p>Here is the code I have for those two :<br>extension XCTestCase {<br>  <br>  func XCTAssertThrows(file: String = __FILE__, line: UInt = __LINE__, _ closure:() throws -&gt; Void) -&gt; ErrorType? {<br>    do {<br>      try closure()<br>      XCTFail(&quot;Closure did not throw an error&quot;, file: file, line: line)<br>    } catch {<br>      return error<br>    }<br>    return nil<br>  }<br>  <br>  func XCTAssertNoThrow&lt;T&gt;(file: String = __FILE__, line: UInt = __LINE__, _ closure:() throws -&gt; T) -&gt; T? {<br>    do {<br>      return try closure()<br>    } catch let error {<br>      XCTFail(&quot;Closure throw unexpected error \(error)&quot;, file: file, line: line)<br>    }<br>    return nil;<br>  }<br>  <br>}<br></p><p>This is very close to what you have. Note that the XCTAssertThrows does not return a return value of the block : as the test expects it will throw, there is not reason for it to use a return value, that would only be returned if no error is thrown.<br>It does return the received error, that can later be checked, in a classical setup -&gt; execute -&gt; validate flow.<br></p><p>The test code looks like this :<br>  func testSample() {<br>    // Setup<br>    let test = TestClass()<br>    let error: ErrorType?<br></p><p>    // Execute<br>    error = XCTAssertThrows{<br>      try test.codeThatThrowAnError()<br>    }<br>    <br>    // Validation<br>    XCTAssertEqual(error.someProperty, &quot;someValue&quot;)<br>  }<br></p><p>Jerome<br></p><p><br>&gt; On 10 Jan 2016, at 03:58, Chris Hanson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We’d like feedback on a proposed design for adding support for Swift error handling to XCTest, attached below. I’ll mostly let the proposal speak for itself, but there are three components to it: Allowing test methods to throw errors, allowing the expressions evaluated by assertions to throw errors, and adding an assertion for checking error handling.<br>&gt; <br>&gt; We’d love to hear your feedback. We’re particularly interested in some feedback on the idea of allowing the expressions evaluated by assertions to throw errors; it’s generated some debate because it results in writing test code slightly differently than other code that makes use of Swift error handling, so any thoughts on it would be particularly appreciated.<br>&gt; <br>&gt;   -- Chris Hanson (chanson at apple.com &lt;mailto:chanson at apple.com&gt;)<br>&gt; <br>&gt; <br>&gt; XCTest Support for Swift Error Handling<br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt; Author(s): Chris Hanson &lt;https://github.com/eschaton&gt;<br>&gt; Status: Review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; Swift 2 introduced a new error handling mechanism that, for completeness, needs to be accommodated by our testing frameworks. Right now, to write tests that involve methods that may throw an error, a developer needs to incorporate significant boilerplate into their test. We should move this into the framework in several ways, so tests of code that interacts with Swift error handling is concise and intention-revealing.<br>&gt; <br>&gt; Motivation<br>&gt; Currently, if a developer wants to use a call that may throw an error in a test, they need to use Swift&#39;s do..catch construct in their test because tests are not themselves allowed to throw errors.<br>&gt; <br>&gt; As an example, a vending machine object that has had insufficient funds deposited may throw an error if asked to vend an item. A test for that situation could reasonably use the do..catchconstruct to check that this occurs as expected. However, that means all other tests also need to use either a do..catch or try! construct — and the failure of a try! is catastrophic, so do..catch would be preferred simply for better reporting within tests.<br>&gt; <br>&gt; func testVendingOneItem() {<br>&gt;     do {<br>&gt;         vendingMachine.deposit(5)<br>&gt;         let item = try vendingMachine.vend(row: 1, column: 1)<br>&gt;         XCTAssertEqual(item, &quot;Candy Bar&quot;)<br>&gt;     } catch {<br>&gt;         XCTFail(&quot;Unexpected failure: \(error)&quot;)<br>&gt;     }<br>&gt; }<br>&gt; If the implementation of VendingMachine.vend(row:column:) changes during development such that it throws an error in this situation, the test will fail as it should.<br>&gt; <br>&gt; One other downside of the above is that a failure caught this way will be reported as an expected failure, which would normally be a failure for which XCTest is explicitly testing via an assertion. This failure should ideally be treated as an unexpected failure, as it&#39;s not one that&#39;s anticipated in the execution of the test.<br>&gt; <br>&gt; In addition, tests do not currently support throwing an error from within an assertion, requiring any code that throws an error to be invoked outside the assertion itself using the same techniques described above.<br>&gt; <br>&gt; Finally, since Swift error handling is a general mechanism that developers should be implementing in their own applications and frameworks, we need to make it straightforward to write tests that ensure code that implements error handling does so correctly.<br>&gt; <br>&gt; Proposed solution<br>&gt; I propose several related solutions to this issue:<br>&gt; <br>&gt; Allow test methods to throw errors.<br>&gt; Allow test assertion expressions to throw errors.<br>&gt; Add an assertion for checking errors.<br>&gt; These solutions combine to make writing tests that involve thrown errors much more succinct.<br>&gt; <br>&gt; Allowing Test Methods to Throw Errors<br>&gt; <br>&gt; First, we can allow test methods to throw errors if desired, thus allowing the do..catch construct to be omitted when the test isn&#39;t directly checking error handling. This makes the code a developer writes when they&#39;re not explicitly trying to test error handling much cleaner.<br>&gt; <br>&gt; Moving the handling of errors thrown by tests into XCTest itself also ensures they can be treated as unexpected failures, since the mechanism to do so is currently private to the framework.<br>&gt; <br>&gt; With this, the test from the previous section can become:<br>&gt; <br>&gt; func testVendingOneItem() throws {<br>&gt;     vendingMachine.deposit(5)<br>&gt;     let item = try vendingMachine.vend(row: 1, column: 1)<br>&gt;     XCTAssertEqual(item, &quot;Candy Bar&quot;)<br>&gt; }<br>&gt; This shows much more directly that the test is intended to check a specific non-error case, and that the developer is relying on the framework to handle unexpected errors.<br>&gt; <br>&gt; Allowing Test Assertions to Throw Errors<br>&gt; <br>&gt; We can also allow the @autoclosure expression that is passed into an assertion to throw an error, and treat that error as an unexpected failure (since the code is being invoked in an assertion that isn&#39;t directly related to error handling). For example:<br>&gt; <br>&gt; func testVendingMultipleItemsWithSufficientFunds() {<br>&gt;     vendingMachine.deposit(10)<br>&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 1), &quot;Candy Bar&quot;)<br>&gt;     XCTAssertEqual(try vendingMachine.vend(row: 1, column: 2), &quot;Chips&quot;)<br>&gt; }<br>&gt; This can eliminate otherwise-dangerous uses of try! and streamline code that needs to make multiple assertions in a row.<br>&gt; <br>&gt; Adding a &quot;Throws Error&quot; Assertion<br>&gt; <br>&gt; In order to test code that throws an error, it would be useful to have an assertion that expects an error to be thrown in a particular case. Right now a developer writing code to test that an error is thrown has to test that error themselves:<br>&gt; <br>&gt;     func testVendingFailsWithInsufficientFunds() {<br>&gt;         vendingMachine.deposit(1)<br>&gt;         var vendingFailed = false<br>&gt;         do {<br>&gt;             _ = try vendingMachine.vend(row: 1, column: 1))<br>&gt;         } catch {<br>&gt;             vendingFailed = true<br>&gt;         }<br>&gt;         XCTAssert(vendingFailed)<br>&gt;     }<br>&gt; If we add an assertion that specifically checks whether an error was thrown, this code will be significantly streamlined:<br>&gt; <br>&gt;     func testVendingFailsWithInsufficientFunds() {<br>&gt;         vendingMachine.deposit(1)<br>&gt;         XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1))<br>&gt;     }<br>&gt; Of course, some code may want to just detect that an error was thrown, but other code may need to check that the details of the thrown error are correct. We can take advantage of Swift&#39;s trailing closure syntax to enable this, by passing the thrown error (if any) to a closure that can itself contain assertions:<br>&gt; <br>&gt;     XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1)) { error in<br>&gt;         guard let vendingError = error as? VendingMachineError else {<br>&gt;             XCTFail(&quot;Unexpected type of error thrown: \(error)&quot;)<br>&gt;             return<br>&gt;         }<br>&gt;         <br>&gt;         XCTAssertEquals(vendingError.item, &quot;Candy Bar&quot;)<br>&gt;         XCTAssertEquals(vendingError.price, 5)<br>&gt;         XCTAssertEquals(vendingError.message, &quot;A Candy Bar costs 5 coins&quot;)<br>&gt;     }<br>&gt; This lets a developer very concisely describe an error condition for their code, in whatever level of detail they desire.<br>&gt; <br>&gt; Detailed design<br>&gt; The design of each of the above components is slightly different, based on the functionality provided.<br>&gt; <br>&gt; Tests That Throw<br>&gt; <br>&gt; In order to enable test methods to throw an error, we will need to update XCTest to support test methods with a () throws -&gt; Void signature in addition to test methods with a () -&gt; Voidsignature as it already supports.<br>&gt; <br>&gt; We will need to ensure tests that do throw an error have that error caught, and that it registers an unexpected failure.<br>&gt; <br>&gt; Assertions That Throw<br>&gt; <br>&gt; In order to allow assertions to throw an exception, we will need to enhance our existing assertions&#39; @autoclosure expression parameters to add throws to their signature.<br>&gt; <br>&gt; Because Swift defines a closure that can throw an error to be a proper supertype of a closure that does not, this will not result in a combinatorial explosion of assertion overrides, and will let developers naturally write code that may throw an error within an assertion.<br>&gt; <br>&gt; We will treat any error thrown from within an assertion expression as an unexpected failure because while all assertions represent a test for some form of failure, they&#39;re not specifically checking for a thrown error.<br>&gt; <br>&gt; The &quot;Throws Error&quot; Assertion<br>&gt; <br>&gt; To write tests for code that throws error, we will add a new assertion function to XCTest with the following prototype:<br>&gt; <br>&gt; public func XCTAssertThrowsError(<br>&gt;     @autoclosure expression: () throws -&gt; Void,<br>&gt;                   _ message: String = &quot;&quot;,<br>&gt;                        file: StaticString = __FILE__,<br>&gt;                        line: UInt = __LINE__,<br>&gt;              _ errorHandler: (error: ErrorType) -&gt; Void = { _ in })<br>&gt; Rather than treat an error thrown from its expression as a failure, this will treat the lack of an error thrown from its expression as an expected failure.<br>&gt; <br>&gt; Furthermore, so long as an error is thrown, the error will be passed to the errorHandler block passed as a trailing closure, where the developer may make further assertions against it.<br>&gt; <br>&gt; In both cases, the new assertion function is generic on an ErrorType in order to ensure that little to no casting will be required in the trailing closure.<br>&gt; <br>&gt; Impact on existing code<br>&gt; There should be little impact on existing test code because we are only adding features and API, not changing existing features or API.<br>&gt; <br>&gt; All existing tests should continue to work as implemented, and can easily adopt the new conventions we&#39;re making available to become more concise and intention-revealing with respect to their error handling as shown above.<br>&gt; <br>&gt; Alternatives considered<br>&gt; We considered asking developers continue using XCTest as-is, and encouraging them to use Swift&#39;s native error handling to both suppress and check the validity of errors. We also considered adding additional ways of registering failures when doing this, so that developers could register unexpected failures themselves.<br>&gt; <br>&gt; While this would result in developers using the language the same way in their tests as in their functional code, this would also result in much more verbose tests. We rejected this approach because such verbosity can be a significant obstacle to testing.<br>&gt; <br>&gt; Making it quick and clean to write tests for error handling could also encourage developers to implement error handling in their code as they need it, rather than to try to work around the feature because of any perceived difficulty in testing.<br>&gt; <br>&gt; We considered adding the ability to check that a specific error was thrown in XCTAssertThrowsError, but this would require the ErrorType passed to also conform to Equatable, which is also unnecessary given that this can easily be checked in a trailing closure if desired. (In some cases a developer may just want to ensure an error is thrown rather than a specific error is thrown.)<br>&gt; <br>&gt; We explicitly chose not to offer a comprehensive suite of DoesNotThrowError assertions for XCTest in Swift, though we do offer such DoesNotThrow assertions for XCTest in Objective-C. We feel these are of limited utility given that our plan is for all assertions (except XCTAssertThrowsError) to treat any thrown error as a failure.<br>&gt; <br>&gt; We explicitly chose not to offer any additional support for Objective-C exceptions beyond what we already provide: In the Xcode implementation of XCTest, an Objective-C exception that occurs within one of our existing assertions or tests will result in a test failure; doing more than this is not practical given that it&#39;s possible to neither catch and handle nor generate an Objective-C exception in Swift.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/1fab9cf4/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
