<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>(Draft) Add last(where:) and lastIndex(where:) methods</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>May 10, 2016 at 01:00:00pm</p></header><div class="content"><p>I&#39;ve needed these in the past and used them in other languages—any feedback on this  idea?<br></p><p>Add last(where:) and lastIndex(where:) Methods to Bidirectional Collections<br>The standard library should include methods for finding the last element of a bidirectional collection that matches a predicate, along with the index of that element.<br></p><p>Motivation<br>The standard library currently has (or will soon have) methods that perform a linear search from the beginning of a collection to find an element that matches a predicate:<br></p><p>let a = [20, 30, 10, 40, 20, 30, 10, 40, 20]<br>a.first(where: { $0 &gt; 25 })         // 30<br>a.index(of: 10)                     // 2<br>a.index(where: { $0 &gt; 25 })         // 1<br>Unfortunately, there is no such method that searches from the end of a bidirectional collection. Finding the last of particular kind of element has multiple applications, particularly with text, such as wrapping a long string into lines of a maximum length or trimming whitespace from the beginning and end of a string.<br></p><p>This limitation can be worked around by using the methods above on the reversed collection, but the resulting code is truly dreadful. For example, to find the corresponding last index to a.index(where: { $0 &gt; 25 }), this unholy incantation is required:<br></p><p>(a.reversed().index(where: { $0 &gt; 25 })?.base).flatMap({ a.index(before: $0) })<br>Wat.<br></p><p>Proposed solution<br>Bidirectional collections should include three new methods for symmetry with the existing forward-searching APIs: last(where:), lastIndex(where:), and lastIndex(of:), specifically for collections of Equatable elements.<br></p><p>These additions would remove the need for searching in a reversed collection and allow code like the following:<br></p><p>a.last(where: { $0 &gt; 25 })          // 40<br>a.lastIndex(of: 10)                 // 6<br>a.lastIndex(where: { $0 &gt; 25 })     // 7<br>Much better!<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/494797ba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>(Draft) Add last(where:) and lastIndex(where:) methods</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>May 10, 2016 at 02:00:00pm</p></header><div class="content"><p>I agree with adding more such API’s. <br></p><p>Look at this gist &lt;https://gist.github.com/hooman/e77cc0e955a1db672ae49e45b0038d04&gt; for an implementation of a few more of what I find useful. You can add them to your proposal if you like them and I will be able to help better shape it up. Here is a summary:<br></p><p>public func offset(of index: Index) -&gt; IndexDistance<br>public func index(atOffset offset: IndexDistance) -&gt; Index<br></p><p>public func index(of element: Iterator.Element, from firstIndex: Index) -&gt; Index?<br>public func index(from firstIndex: Index, where predicate: @noescape (Iterator.Element) throws -&gt; Bool) rethrows -&gt; Index?<br>public func index&lt;C: Collection where ...&gt;(of elementSequence: C) -&gt; Index?<br>public func index&lt;C: Collection where ...&gt;(of elementSequence: C, from firstIndex: Index) -&gt; Index?<br></p><p>Look at the comments for the example usage. For `offset` function, see the source code for usage.<br></p><p>Hooman<br></p><p>&gt; On May 10, 2016, at 11:54 AM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve needed these in the past and used them in other languages—any feedback on this  idea?<br>&gt; <br>&gt; Add last(where:) and lastIndex(where:) Methods to Bidirectional Collections<br>&gt; The standard library should include methods for finding the last element of a bidirectional collection that matches a predicate, along with the index of that element.<br>&gt; <br>&gt; Motivation<br>&gt; The standard library currently has (or will soon have) methods that perform a linear search from the beginning of a collection to find an element that matches a predicate:<br>&gt; <br>&gt; let a = [20, 30, 10, 40, 20, 30, 10, 40, 20]<br>&gt; a.first(where: { $0 &gt; 25 })         // 30<br>&gt; a.index(of: 10)                     // 2<br>&gt; a.index(where: { $0 &gt; 25 })         // 1<br>&gt; Unfortunately, there is no such method that searches from the end of a bidirectional collection. Finding the last of particular kind of element has multiple applications, particularly with text, such as wrapping a long string into lines of a maximum length or trimming whitespace from the beginning and end of a string.<br>&gt; <br>&gt; This limitation can be worked around by using the methods above on the reversed collection, but the resulting code is truly dreadful. For example, to find the corresponding last index to a.index(where: { $0 &gt; 25 }), this unholy incantation is required:<br>&gt; <br>&gt; (a.reversed().index(where: { $0 &gt; 25 })?.base).flatMap({ a.index(before: $0) })<br>&gt; Wat.<br>&gt; <br>&gt; Proposed solution<br>&gt; Bidirectional collections should include three new methods for symmetry with the existing forward-searching APIs: last(where:), lastIndex(where:), and lastIndex(of:), specifically for collections of Equatable elements.<br>&gt; <br>&gt; These additions would remove the need for searching in a reversed collection and allow code like the following:<br>&gt; <br>&gt; a.last(where: { $0 &gt; 25 })          // 40<br>&gt; a.lastIndex(of: 10)                 // 6<br>&gt; a.lastIndex(where: { $0 &gt; 25 })     // 7<br>&gt; Much better!<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/e5ab8e89/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>(Draft) Add last(where:) and lastIndex(where:) methods</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>May 10, 2016 at 06:00:00pm</p></header><div class="content"><p>Thanks Hooman! Those do look like useful extensions. I think the proposal should stay focused on the APIs it includes already.<br></p><p>&gt; On May 10, 2016, at 4:18 PM, Hooman Mehr &lt;hooman at mac.com&gt; wrote:<br>&gt; <br>&gt; I agree with adding more such API’s. <br>&gt; <br>&gt; Look at this gist &lt;https://gist.github.com/hooman/e77cc0e955a1db672ae49e45b0038d04&gt; for an implementation of a few more of what I find useful. You can add them to your proposal if you like them and I will be able to help better shape it up. Here is a summary:<br>&gt; <br>&gt; public func offset(of index: Index) -&gt; IndexDistance<br>&gt; public func index(atOffset offset: IndexDistance) -&gt; Index<br></p><p>I like these, but I doubt they would get much traction, since they&#39;re essentially substituting startIndex into existing methods. I have thought it would be nice to have startIndex as the default parameter to those methods, though, so you could write either of these:<br></p><p>	let i = c.index(c.startIndex, offsetBy: 5)		// current<br>	let i = c.index(offsetBy: 5)				// nice addition<br></p><p>&gt; public func index(of element: Iterator.Element, from firstIndex: Index) -&gt; Index?<br>&gt; public func index(from firstIndex: Index, where predicate: @noescape (Iterator.Element) throws -&gt; Bool) rethrows -&gt; Index?<br></p><p>I have the same reaction to these. Because indices are shared between collections and slices, instead of using a starting index, Swift&#39;s collection operations can just work on a slice. So instead of calling<br></p><p>	let i = c.index(of: &quot;A&quot;, from: firstIndex)<br></p><p>you can call<br></p><p>	let i = c.suffix(from: firstIndex).index(of: &quot;A&quot;)<br></p><p>&gt; public func index&lt;C: Collection where ...&gt;(of elementSequence: C) -&gt; Index?<br>&gt; public func index&lt;C: Collection where ...&gt;(of elementSequence: C, from firstIndex: Index) -&gt; Index?<br></p><p>These methods we don&#39;t have at all currently, and could really use! I would definitely support a proposal for finding a subsequence of a collection. There are several algorithms beyond the naive approach, so it would be interesting to see if / how a proposal could use those in a generic context.<br></p><p>Thanks again!<br>Nate<br></p><p>&gt; Look at the comments for the example usage. For `offset` function, see the source code for usage.<br>&gt; <br>&gt; Hooman<br>&gt; <br>&gt;&gt; On May 10, 2016, at 11:54 AM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve needed these in the past and used them in other languages—any feedback on this  idea?<br>&gt;&gt; <br>&gt;&gt; Add last(where:) and lastIndex(where:) Methods to Bidirectional Collections<br>&gt;&gt; The standard library should include methods for finding the last element of a bidirectional collection that matches a predicate, along with the index of that element.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; The standard library currently has (or will soon have) methods that perform a linear search from the beginning of a collection to find an element that matches a predicate:<br>&gt;&gt; <br>&gt;&gt; let a = [20, 30, 10, 40, 20, 30, 10, 40, 20]<br>&gt;&gt; a.first(where: { $0 &gt; 25 })         // 30<br>&gt;&gt; a.index(of: 10)                     // 2<br>&gt;&gt; a.index(where: { $0 &gt; 25 })         // 1<br>&gt;&gt; Unfortunately, there is no such method that searches from the end of a bidirectional collection. Finding the last of particular kind of element has multiple applications, particularly with text, such as wrapping a long string into lines of a maximum length or trimming whitespace from the beginning and end of a string.<br>&gt;&gt; <br>&gt;&gt; This limitation can be worked around by using the methods above on the reversed collection, but the resulting code is truly dreadful. For example, to find the corresponding last index to a.index(where: { $0 &gt; 25 }), this unholy incantation is required:<br>&gt;&gt; <br>&gt;&gt; (a.reversed().index(where: { $0 &gt; 25 })?.base).flatMap({ a.index(before: $0) })<br>&gt;&gt; Wat.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; Bidirectional collections should include three new methods for symmetry with the existing forward-searching APIs: last(where:), lastIndex(where:), and lastIndex(of:), specifically for collections of Equatable elements.<br>&gt;&gt; <br>&gt;&gt; These additions would remove the need for searching in a reversed collection and allow code like the following:<br>&gt;&gt; <br>&gt;&gt; a.last(where: { $0 &gt; 25 })          // 40<br>&gt;&gt; a.lastIndex(of: 10)                 // 6<br>&gt;&gt; a.lastIndex(where: { $0 &gt; 25 })     // 7<br>&gt;&gt; Much better!<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/b2ea9c7d/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>(Draft) Add last(where:) and lastIndex(where:) methods</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>May 11, 2016 at 10:00:00am</p></header><div class="content"><p>Thank you for your comments. <br></p><p>I think additional index manipulation and collection scanning API is needed, and your proposal cover an important part of it.<br></p><p>I also have some clarifications and comments inline:<br></p><p>&gt; On May 10, 2016, at 4:52 PM, Nate Cook &lt;natecook at gmail.com&gt; wrote:<br>&gt; Thanks Hooman! Those do look like useful extensions. I think the proposal should stay focused on the APIs it includes already.<br>&gt;&gt; On May 10, 2016, at 4:18 PM, Hooman Mehr &lt;hooman at mac.com &lt;mailto:hooman at mac.com&gt;&gt; wrote:<br>&gt;&gt; public func offset(of index: Index) -&gt; IndexDistance<br>&gt;&gt; public func index(atOffset offset: IndexDistance) -&gt; Index<br>&gt; <br>&gt; I like these, but I doubt they would get much traction, since they&#39;re essentially substituting startIndex into existing methods. I have thought it would be nice to have startIndex as the default parameter to those methods, though, so you could write either of these:<br>&gt; <br>&gt; 	let i = c.index(c.startIndex, offsetBy: 5)		// current<br>&gt; 	let i = c.index(offsetBy: 5)				// nice addition<br></p><p>That is right. The main function is `offset` that I use a lot and for the reverse, your suggestion seems better. I am using `offset` quite a bit but I don’t know if it is generally as useful for other people as it is for me.<br></p><p>&gt; <br>&gt;&gt; public func index(of element: Iterator.Element, from firstIndex: Index) -&gt; Index?<br>&gt;&gt; public func index(from firstIndex: Index, where predicate: @noescape (Iterator.Element) throws -&gt; Bool) rethrows -&gt; Index?<br>&gt; <br>&gt; I have the same reaction to these. Because indices are shared between collections and slices, instead of using a starting index, Swift&#39;s collection operations can just work on a slice. So instead of calling<br>&gt; <br>&gt; 	let i = c.index(of: &quot;A&quot;, from: firstIndex)<br>&gt; <br>&gt; you can call<br>&gt; <br>&gt; 	let i = c.suffix(from: firstIndex).index(of: &quot;A”)<br></p><p>The point is: The `i` above is an index into the (discarded) slice returned by `suffix()`, not the collection `c`. In general, it does not work correctly on the original collection. The behavior of slice indexes have changed a couple of times and is not totally consistent or guaranteed for different concrete collections. That is the reason I am proposing the above function to provide a sure way to have this functionality working properly and I find it extremely useful. Again I don’t know about others.<br></p><p>It seems that the subject of the interaction between slice indexes and the parent collections need further clarifications and specification from the core Swift team.<br></p><p>&gt; <br>&gt;&gt; public func index&lt;C: Collection where ...&gt;(of elementSequence: C) -&gt; Index?<br>&gt;&gt; public func index&lt;C: Collection where ...&gt;(of elementSequence: C, from firstIndex: Index) -&gt; Index?<br>&gt; <br>&gt; These methods we don&#39;t have at all currently, and could really use! I would definitely support a proposal for finding a subsequence of a collection. There are several algorithms beyond the naive approach, so it would be interesting to see if / how a proposal could use those in a generic context.<br>&gt; <br></p><p>I updated the gist &lt;https://gist.github.com/hooman/e77cc0e955a1db672ae49e45b0038d04&gt;. Besides some corrections and removing a couple of extension constraints, I merged the two functions above into:<br></p><p>public func index&lt;C: Collection where ...&gt;(of elementSequence: C, from firstIndex: Index? = nil) -&gt; Index?<br></p><p>I think the basic implementation in the gist is good enough for many cases and we can specialize for array. As long as the collection and the sub-collection are not huge, performance should be fine.<br></p><p>On the other hand, I am too busy to seriously propose and pursue its addition. If enough people find it worthy of general inclusion into the standard library, somebody will pick it up, but not me.<br></p><p>I didn’t intend to hijack your proposal, but I thought some comments would help clarify things.<br></p><p>Thank you again,<br>Hooman<br></p><p><br>&gt; Thanks again!<br>&gt; Nate<br>&gt; <br>&gt;&gt; Look at the comments for the example usage. For `offset` function, see the source code for usage.<br>&gt;&gt; <br>&gt;&gt; Hooman<br>&gt;&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 11:54 AM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve needed these in the past and used them in other languages—any feedback on this  idea?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Add last(where:) and lastIndex(where:) Methods to Bidirectional Collections<br>&gt;&gt;&gt; The standard library should include methods for finding the last element of a bidirectional collection that matches a predicate, along with the index of that element.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; The standard library currently has (or will soon have) methods that perform a linear search from the beginning of a collection to find an element that matches a predicate:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = [20, 30, 10, 40, 20, 30, 10, 40, 20]<br>&gt;&gt;&gt; a.first(where: { $0 &gt; 25 })         // 30<br>&gt;&gt;&gt; a.index(of: 10)                     // 2<br>&gt;&gt;&gt; a.index(where: { $0 &gt; 25 })         // 1<br>&gt;&gt;&gt; Unfortunately, there is no such method that searches from the end of a bidirectional collection. Finding the last of particular kind of element has multiple applications, particularly with text, such as wrapping a long string into lines of a maximum length or trimming whitespace from the beginning and end of a string.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This limitation can be worked around by using the methods above on the reversed collection, but the resulting code is truly dreadful. For example, to find the corresponding last index to a.index(where: { $0 &gt; 25 }), this unholy incantation is required:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (a.reversed().index(where: { $0 &gt; 25 })?.base).flatMap({ a.index(before: $0) })<br>&gt;&gt;&gt; Wat.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; Bidirectional collections should include three new methods for symmetry with the existing forward-searching APIs: last(where:), lastIndex(where:), and lastIndex(of:), specifically for collections of Equatable elements.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These additions would remove the need for searching in a reversed collection and allow code like the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; a.last(where: { $0 &gt; 25 })          // 40<br>&gt;&gt;&gt; a.lastIndex(of: 10)                 // 6<br>&gt;&gt;&gt; a.lastIndex(where: { $0 &gt; 25 })     // 7<br>&gt;&gt;&gt; Much better!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/3a455270/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/67a361b77f5c6cba256d06ba641f2af8?s=50"></div><header><strong>(Draft) Add last(where:) and lastIndex(where:) methods</strong> from <string>Nate Cook</string> &lt;nate at natecook.com&gt;<p>May 11, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 11, 2016, at 12:32 PM, Hooman Mehr via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thank you for your comments. <br>&gt; <br>&gt; I think additional index manipulation and collection scanning API is needed, and your proposal cover an important part of it.<br>&gt; <br>&gt; I also have some clarifications and comments inline:<br>&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 4:52 PM, Nate Cook &lt;natecook at gmail.com&gt; wrote:<br>&gt;&gt;&gt; Thanks Hooman! Those do look like useful extensions. I think the proposal should stay focused on the APIs it includes already.<br>&gt;&gt;&gt; On May 10, 2016, at 4:18 PM, Hooman Mehr &lt;hooman at mac.com&gt; wrote:<br>&gt;&gt;&gt; public func offset(of index: Index) -&gt; IndexDistance<br>&gt;&gt;&gt; public func index(atOffset offset: IndexDistance) -&gt; Index<br>&gt;&gt; <br>&gt;&gt; I like these, but I doubt they would get much traction, since they&#39;re essentially substituting startIndex into existing methods. I have thought it would be nice to have startIndex as the default parameter to those methods, though, so you could write either of these:<br>&gt;&gt; <br>&gt;&gt; 	let i = c.index(c.startIndex, offsetBy: 5)		// current<br>&gt;&gt; 	let i = c.index(offsetBy: 5)				// nice addition<br>&gt; <br>&gt; That is right. The main function is `offset` that I use a lot and for the reverse, your suggestion seems better. I am using `offset` quite a bit but I don’t know if it is generally as useful for other people as it is for me.<br></p><p>&#39;distance(from:to:)&#39; is the corresponding method to your &#39;offset(of:)&#39;, although it might need a different name if the first parameter were optional. I don&#39;t find it onerous to provide c.startIndex when using that one.<br></p><p>&gt;&gt;&gt; public func index(of element: Iterator.Element, from firstIndex: Index) -&gt; Index?<br>&gt;&gt;&gt; public func index(from firstIndex: Index, where predicate: @noescape (Iterator.Element) throws -&gt; Bool) rethrows -&gt; Index?<br>&gt;&gt; <br>&gt;&gt; I have the same reaction to these. Because indices are shared between collections and slices, instead of using a starting index, Swift&#39;s collection operations can just work on a slice. So instead of calling<br>&gt;&gt; <br>&gt;&gt; 	let i = c.index(of: &quot;A&quot;, from: firstIndex)<br>&gt;&gt; <br>&gt;&gt; you can call<br>&gt;&gt; <br>&gt;&gt; 	let i = c.suffix(from: firstIndex).index(of: &quot;A”)<br>&gt; <br>&gt; The point is: The `i` above is an index into the (discarded) slice returned by `suffix()`, not the collection `c`. In general, it does not work correctly on the original collection. The behavior of slice indexes have changed a couple of times and is not totally consistent or guaranteed for different concrete collections. That is the reason I am proposing the above function to provide a sure way to have this functionality working properly and I find it extremely useful. Again I don’t know about others.<br>&gt; <br>&gt; It seems that the subject of the interaction between slice indexes and the parent collections need further clarifications and specification from the core Swift team.<br></p><p>Indices from slices absolutely should reference the same element(s) in the original collection―the collections system is based in part on that interoperability. If you see any behavior that deviates from this, please file a bug!<br></p><p>&gt;&gt;&gt; public func index&lt;C: Collection where ...&gt;(of elementSequence: C) -&gt; Index?<br>&gt;&gt;&gt; public func index&lt;C: Collection where ...&gt;(of elementSequence: C, from firstIndex: Index) -&gt; Index?<br>&gt;&gt; <br>&gt;&gt; These methods we don&#39;t have at all currently, and could really use! I would definitely support a proposal for finding a subsequence of a collection. There are several algorithms beyond the naive approach, so it would be interesting to see if / how a proposal could use those in a generic context.<br>&gt; <br>&gt; I updated the gist. Besides some corrections and removing a couple of extension constraints, I merged the two functions above into:<br>&gt; <br>&gt; public func index&lt;C: Collection where ...&gt;(of elementSequence: C, from firstIndex: Index? = nil) -&gt; Index?<br>&gt; <br>&gt; I think the basic implementation in the gist is good enough for many cases and we can specialize for array. As long as the collection and the sub-collection are not huge, performance should be fine.<br>&gt; <br>&gt; On the other hand, I am too busy to seriously propose and pursue its addition. If enough people find it worthy of general inclusion into the standard library, somebody will pick it up, but not me.<br>&gt; <br>&gt; I didn’t intend to hijack your proposal, but I thought some comments would help clarify things.<br>&gt; <br>&gt; Thank you again,<br>&gt; Hooman<br></p><p>Nate<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/047494c9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>(Draft) Add last(where:) and lastIndex(where:) methods</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 10, 2016 at 09:00:00pm</p></header><div class="content"><p>If these are to be added, I&#39;d advocate for renaming `index(of:)` and<br>`index(where:)` to `firstIndex(of:)` and `firstIndex(where:)`, respectively.<br></p><p>On Tue, May 10, 2016 at 13:54 Nate Cook via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;ve needed these in the past and used them in other languages—any<br>&gt; feedback on this  idea?<br>&gt; ------------------------------<br>&gt; Add last(where:) and lastIndex(where:) Methods to Bidirectional<br>&gt; Collections<br>&gt;<br>&gt; The standard library should include methods for finding the last element<br>&gt; of a bidirectional collection that matches a predicate, along with the<br>&gt; index of that element.<br>&gt; Motivation<br>&gt;<br>&gt; The standard library currently has (or will soon have) methods that<br>&gt; perform a linear search from the beginning of a collection to find an<br>&gt; element that matches a predicate:<br>&gt;<br>&gt; let a = [20, 30, 10, 40, 20, 30, 10, 40, 20]<br>&gt; a.first(where: { $0 &gt; 25 })         // 30<br>&gt; a.index(of: 10)                     // 2<br>&gt; a.index(where: { $0 &gt; 25 })         // 1<br>&gt;<br>&gt; Unfortunately, there is no such method that searches from the end of a<br>&gt; bidirectional collection. Finding the last of particular kind of element<br>&gt; has multiple applications, particularly with text, such as wrapping a long<br>&gt; string into lines of a maximum length or trimming whitespace from the<br>&gt; beginning and end of a string.<br>&gt;<br>&gt; This limitation can be worked around by using the methods above on the<br>&gt; reversed collection, but the resulting code is truly dreadful. For example,<br>&gt; to find the corresponding last index to a.index(where: { $0 &gt; 25 }), this<br>&gt; unholy incantation is required:<br>&gt;<br>&gt; (a.reversed().index(where: { $0 &gt; 25 })?.base).flatMap({ a.index(before: $0) })<br>&gt;<br>&gt; Wat.<br>&gt; Proposed solution<br>&gt;<br>&gt; Bidirectional collections should include three new methods for symmetry<br>&gt; with the existing forward-searching APIs: last(where:), lastIndex(where:),<br>&gt; and lastIndex(of:), specifically for collections of Equatable elements.<br>&gt;<br>&gt; These additions would remove the need for searching in a reversed<br>&gt; collection and allow code like the following:<br>&gt;<br>&gt; a.last(where: { $0 &gt; 25 })          // 40<br>&gt; a.lastIndex(of: 10)                 // 6<br>&gt; a.lastIndex(where: { $0 &gt; 25 })     // 7<br>&gt;<br>&gt; Much better!<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/21c0903b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>(Draft) Add last(where:) and lastIndex(where:) methods</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>May 10, 2016 at 07:00:00pm</p></header><div class="content"><p>Do these return endIndex or nil on a not-found?<br></p><p>Either can work with different tradeoffs; depends on what you care about...but the choice should be justified and the alternative explained.<br></p><p>&gt; On May 10, 2016, at 13:54, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve needed these in the past and used them in other languages—any feedback on this  idea?<br>&gt; <br>&gt; Add last(where:) and lastIndex(where:) Methods to Bidirectional Collections<br>&gt; The standard library should include methods for finding the last element of a bidirectional collection that matches a predicate, along with the index of that element.<br>&gt; <br>&gt; Motivation<br>&gt; The standard library currently has (or will soon have) methods that perform a linear search from the beginning of a collection to find an element that matches a predicate:<br>&gt; <br>&gt; let a = [20, 30, 10, 40, 20, 30, 10, 40, 20]<br>&gt; a.first(where: { $0 &gt; 25 })         // 30<br>&gt; a.index(of: 10)                     // 2<br>&gt; a.index(where: { $0 &gt; 25 })         // 1<br>&gt; Unfortunately, there is no such method that searches from the end of a bidirectional collection. Finding the last of particular kind of element has multiple applications, particularly with text, such as wrapping a long string into lines of a maximum length or trimming whitespace from the beginning and end of a string.<br>&gt; <br>&gt; This limitation can be worked around by using the methods above on the reversed collection, but the resulting code is truly dreadful. For example, to find the corresponding last index to a.index(where: { $0 &gt; 25 }), this unholy incantation is required:<br>&gt; <br>&gt; (a.reversed().index(where: { $0 &gt; 25 })?.base).flatMap({ a.index(before: $0) })<br>&gt; Wat.<br>&gt; <br>&gt; Proposed solution<br>&gt; Bidirectional collections should include three new methods for symmetry with the existing forward-searching APIs: last(where:), lastIndex(where:), and lastIndex(of:), specifically for collections of Equatable elements.<br>&gt; <br>&gt; These additions would remove the need for searching in a reversed collection and allow code like the following:<br>&gt; <br>&gt; a.last(where: { $0 &gt; 25 })          // 40<br>&gt; a.lastIndex(of: 10)                 // 6<br>&gt; a.lastIndex(where: { $0 &gt; 25 })     // 7<br>&gt; Much better!<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/42626f83/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>(Draft) Add last(where:) and lastIndex(where:) methods</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>May 10, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On May 10, 2016, at 7:27 PM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Do these return endIndex or nil on a not-found?<br>&gt; <br>&gt; Either can work with different tradeoffs; depends on what you care about...but the choice should be justified and the alternative explained.<br></p><p>These return nil when no matching element is found, just like their from-the-beginning counterparts. endIndex would not be appropriate as a return value.<br></p><p>&gt; On May 10, 2016, at 13:54, Nate Cook via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I&#39;ve needed these in the past and used them in other languages—any feedback on this  idea?<br>&gt;&gt; <br>&gt;&gt; Add last(where:) and lastIndex(where:) Methods to Bidirectional Collections<br>&gt;&gt; The standard library should include methods for finding the last element of a bidirectional collection that matches a predicate, along with the index of that element.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; The standard library currently has (or will soon have) methods that perform a linear search from the beginning of a collection to find an element that matches a predicate:<br>&gt;&gt; <br>&gt;&gt; let a = [20, 30, 10, 40, 20, 30, 10, 40, 20]<br>&gt;&gt; a.first(where: { $0 &gt; 25 })         // 30<br>&gt;&gt; a.index(of: 10)                     // 2<br>&gt;&gt; a.index(where: { $0 &gt; 25 })         // 1<br>&gt;&gt; Unfortunately, there is no such method that searches from the end of a bidirectional collection. Finding the last of particular kind of element has multiple applications, particularly with text, such as wrapping a long string into lines of a maximum length or trimming whitespace from the beginning and end of a string.<br>&gt;&gt; <br>&gt;&gt; This limitation can be worked around by using the methods above on the reversed collection, but the resulting code is truly dreadful. For example, to find the corresponding last index to a.index(where: { $0 &gt; 25 }), this unholy incantation is required:<br>&gt;&gt; <br>&gt;&gt; (a.reversed().index(where: { $0 &gt; 25 })?.base).flatMap({ a.index(before: $0) })<br>&gt;&gt; Wat.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; Bidirectional collections should include three new methods for symmetry with the existing forward-searching APIs: last(where:), lastIndex(where:), and lastIndex(of:), specifically for collections of Equatable elements.<br>&gt;&gt; <br>&gt;&gt; These additions would remove the need for searching in a reversed collection and allow code like the following:<br>&gt;&gt; <br>&gt;&gt; a.last(where: { $0 &gt; 25 })          // 40<br>&gt;&gt; a.lastIndex(of: 10)                 // 6<br>&gt;&gt; a.lastIndex(where: { $0 &gt; 25 })     // 7<br>&gt;&gt; Much better!<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/65c50a86/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
