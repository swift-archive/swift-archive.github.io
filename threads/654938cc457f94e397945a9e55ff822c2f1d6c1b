<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7452b650d9bd0dfeecb6b9830f0d892?s=50"></div><header><strong>A native option set construct</strong> from <string>Dan Stenmark</string> &lt;daniel.j.stenmark at gmail.com&gt;<p>December 21, 2015 at 01:00:00pm</p></header><div class="content"><p>One of the things that surprised me is that there still isn’t concise syntax for creating option sets, a pattern I see out in the wild a fair bit.  While Swift 2 did introduce OptionSetType for structs, it still feels somewhat obtuse and non-obvious.  It would be great if we could something like:<br></p><p>options NotSoSecretVariations {<br>	case ProteinStyle,<br>	case AnimalStyle,<br>	case GrilledOnions,<br>	...<br>}<br></p><p>That said, I have a feeling this isn’t the first time the Swift team has come across a pitch like this.  If this really is unfeasible, it would be great and really educational to hear what the challenges are.<br></p><p>Dan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/65496c1b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>A native option set construct</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 21, 2015 at 01:00:00pm</p></header><div class="content"><p>On Dec 21, 2015, at 1:08 PM, Dan Stenmark via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; One of the things that surprised me is that there still isn’t concise syntax for creating option sets, a pattern I see out in the wild a fair bit.  While Swift 2 did introduce OptionSetType for structs, it still feels somewhat obtuse and non-obvious.  It would be great if we could something like:<br>&gt; <br>&gt; options NotSoSecretVariations {<br>&gt; 	case ProteinStyle,<br>&gt; 	case AnimalStyle,<br>&gt; 	case GrilledOnions,<br>&gt; 	...<br>&gt; }<br>&gt; <br>&gt; That said, I have a feeling this isn’t the first time the Swift team has come across a pitch like this.  If this really is unfeasible, it would be great and really educational to hear what the challenges are.<br></p><p>We’ve definitely discussed it, at the same time we were designing the swift 2 era syntax.<br></p><p>The consensus from those discussions is that option sets are set-like and sets don’t/shouldn&#39;t have privileged declaration syntax.  Instead of adding complexity to the core language for this, we’d rather eventually cover this with a hygienic macro system some day.  That would allow option sets to remain a library feature.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/f73ee231/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>A native option set construct</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 21, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; One of the things that surprised me is that there still isn’t concise syntax for creating option sets, a pattern I see out in the wild a fair bit.  While Swift 2 did introduce OptionSetType for structs, it still feels somewhat obtuse and non-obvious.  It would be great if we could something like:<br>&gt; <br>&gt; options NotSoSecretVariations {<br>&gt; 	case ProteinStyle,<br>&gt; 	case AnimalStyle,<br>&gt; 	case GrilledOnions,<br>&gt; 	...<br>&gt; }<br>&gt; <br>&gt; That said, I have a feeling this isn’t the first time the Swift team has come across a pitch like this.  If this really is unfeasible, it would be great and really educational to hear what the challenges are.<br></p><p>Personally, what I&#39;d like to see is the concept of an option separated from that of an option *set*. Once you do that, you can define an individual option simply using an enum, and let the set handle combining the options together.<br></p><p>Here&#39;s what I mean. Take an Objective-C NS_OPTIONS enum:<br></p><p>	typedef NS_OPTIONS(NSUInteger, NSStringCompareOptions) {<br>	    NSCaseInsensitiveSearch = 1,<br>	    NSLiteralSearch = 2,		/* Exact character-by-character equivalence */<br>	    NSBackwardsSearch = 4,		/* Search from end of source string */<br>	    NSAnchoredSearch = 8,		/* Search is limited to start (or end, if NSBackwardsSearch) of source string */<br>	    NSNumericSearch = 64,		/* Added in 10.2; Numbers within strings are compared using numeric value, that is, Foo2.txt &lt; Foo7.txt &lt; Foo25.txt; only applies to compare methods, not find */<br>	    NSDiacriticInsensitiveSearch NS_ENUM_AVAILABLE(10_5, 2_0) = 128, /* If specified, ignores diacritics (o-umlaut == o) */<br>	    NSWidthInsensitiveSearch NS_ENUM_AVAILABLE(10_5, 2_0) = 256, /* If specified, ignores width differences (&#39;a&#39; == UFF41) */<br>	    NSForcedOrderingSearch NS_ENUM_AVAILABLE(10_5, 2_0) = 512, /* If specified, comparisons are forced to return either NSOrderedAscending or NSOrderedDescending if the strings are equivalent but not strictly equal, for stability when sorting (e.g. &quot;aaa&quot; &gt; &quot;AAA&quot; with NSCaseInsensitiveSearch specified) */<br>	    NSRegularExpressionSearch NS_ENUM_AVAILABLE(10_7, 3_2) = 1024    /* Applies to rangeOfString:..., stringByReplacingOccurrencesOfString:..., and replaceOccurrencesOfString:... methods only; the search string is treated as an ICU-compatible regular expression; if set, no other options can apply except NSCaseInsensitiveSearch and NSAnchoredSearch */<br>	};<br></p><p>I think this should be translated to Swift like this:<br></p><p>	enum NSStringCompareOption: Int {<br>	    case CaseInsensitiveSearch = 0	// Because 1 &lt;&lt; 0 == 1<br>	    case LiteralSearch = 1	// 1 &lt;&lt; 1 == 2<br>	    case BackwardsSearch = 2<br>	    case AnchoredSearch = 3<br>	    case NumericSearch = 6	// 1 &lt;&lt; 6 == 64<br>	    case DiacriticInsensitiveSearch = 7<br>	    case WidthInsensitiveSearch = 8<br>	    case ForcedOrderingSearch = 9<br>	    case RegularExpressionSearch = 10<br>	}<br></p><p>Meanwhile, a method taking NSStringCompareOptions like this:<br></p><p>	- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask;<br></p><p>Should be translated as:<br></p><p>	func compare(string: NSString, options mask: OptionSet&lt;NSStringCompareOption&gt;) -&gt; NSComparisonResult<br></p><p>OptionSet would be a generic type like this:<br></p><p>	struct OptionSet&lt;Option: RawRepresentable where Option.RawValue: IntegerType&gt;: SetAlgebraType, RawRepresentable {<br>	    typealias Element = Option<br>	    typealias RawValue = Option.RawValue<br>	    ...<br>	}<br></p><p>This definition should work for any NS_OPTIONS where the options are non-overlapping. I&#39;m not sure if that&#39;s *every* option set in the Apple frameworks, but I think it&#39;s the vast majority of them. (The incompatible ones could use the existing mechanism.) And to create your own option set, all you have to do is write an enum with an integer raw type that has less than 32 or 64 cases, depending on your target. You don&#39;t even have to specify the raw values—the default ones will work fine.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>A native option set construct</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 21, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 2:38 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; One of the things that surprised me is that there still isn’t concise syntax for creating option sets, a pattern I see out in the wild a fair bit.  While Swift 2 did introduce OptionSetType for structs, it still feels somewhat obtuse and non-obvious.  It would be great if we could something like:<br>&gt;&gt; <br>&gt;&gt; options NotSoSecretVariations {<br>&gt;&gt; 	case ProteinStyle,<br>&gt;&gt; 	case AnimalStyle,<br>&gt;&gt; 	case GrilledOnions,<br>&gt;&gt; 	...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; That said, I have a feeling this isn’t the first time the Swift team has come across a pitch like this.  If this really is unfeasible, it would be great and really educational to hear what the challenges are.<br>&gt; <br>&gt; Personally, what I&#39;d like to see is the concept of an option separated from that of an option *set*. Once you do that, you can define an individual option simply using an enum, and let the set handle combining the options together.<br>&gt; <br>&gt; Here&#39;s what I mean. Take an Objective-C NS_OPTIONS enum:<br>&gt; <br>&gt; 	typedef NS_OPTIONS(NSUInteger, NSStringCompareOptions) {<br>&gt; 	    NSCaseInsensitiveSearch = 1,<br>&gt; 	    NSLiteralSearch = 2,		/* Exact character-by-character equivalence */<br>&gt; 	    NSBackwardsSearch = 4,		/* Search from end of source string */<br>&gt; 	    NSAnchoredSearch = 8,		/* Search is limited to start (or end, if NSBackwardsSearch) of source string */<br>&gt; 	    NSNumericSearch = 64,		/* Added in 10.2; Numbers within strings are compared using numeric value, that is, Foo2.txt &lt; Foo7.txt &lt; Foo25.txt; only applies to compare methods, not find */<br>&gt; 	    NSDiacriticInsensitiveSearch NS_ENUM_AVAILABLE(10_5, 2_0) = 128, /* If specified, ignores diacritics (o-umlaut == o) */<br>&gt; 	    NSWidthInsensitiveSearch NS_ENUM_AVAILABLE(10_5, 2_0) = 256, /* If specified, ignores width differences (&#39;a&#39; == UFF41) */<br>&gt; 	    NSForcedOrderingSearch NS_ENUM_AVAILABLE(10_5, 2_0) = 512, /* If specified, comparisons are forced to return either NSOrderedAscending or NSOrderedDescending if the strings are equivalent but not strictly equal, for stability when sorting (e.g. &quot;aaa&quot; &gt; &quot;AAA&quot; with NSCaseInsensitiveSearch specified) */<br>&gt; 	    NSRegularExpressionSearch NS_ENUM_AVAILABLE(10_7, 3_2) = 1024    /* Applies to rangeOfString:..., stringByReplacingOccurrencesOfString:..., and replaceOccurrencesOfString:... methods only; the search string is treated as an ICU-compatible regular expression; if set, no other options can apply except NSCaseInsensitiveSearch and NSAnchoredSearch */<br>&gt; 	};<br>&gt; <br>&gt; I think this should be translated to Swift like this:<br>&gt; <br>&gt; 	enum NSStringCompareOption: Int {<br>&gt; 	    case CaseInsensitiveSearch = 0	// Because 1 &lt;&lt; 0 == 1<br>&gt; 	    case LiteralSearch = 1	// 1 &lt;&lt; 1 == 2<br>&gt; 	    case BackwardsSearch = 2<br>&gt; 	    case AnchoredSearch = 3<br>&gt; 	    case NumericSearch = 6	// 1 &lt;&lt; 6 == 64<br>&gt; 	    case DiacriticInsensitiveSearch = 7<br>&gt; 	    case WidthInsensitiveSearch = 8<br>&gt; 	    case ForcedOrderingSearch = 9<br>&gt; 	    case RegularExpressionSearch = 10<br>&gt; 	}<br>&gt; <br>&gt; Meanwhile, a method taking NSStringCompareOptions like this:<br>&gt; <br>&gt; 	- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask;<br>&gt; <br>&gt; Should be translated as:<br>&gt; <br>&gt; 	func compare(string: NSString, options mask: OptionSet&lt;NSStringCompareOption&gt;) -&gt; NSComparisonResult<br>&gt; <br>&gt; OptionSet would be a generic type like this:<br>&gt; <br>&gt; 	struct OptionSet&lt;Option: RawRepresentable where Option.RawValue: IntegerType&gt;: SetAlgebraType, RawRepresentable {<br>&gt; 	    typealias Element = Option<br>&gt; 	    typealias RawValue = Option.RawValue<br>&gt; 	    ...<br>&gt; 	}<br>&gt; <br>&gt; This definition should work for any NS_OPTIONS where the options are non-overlapping. I&#39;m not sure if that&#39;s *every* option set in the Apple frameworks, but I think it&#39;s the vast majority of them. (The incompatible ones could use the existing mechanism.) And to create your own option set, all you have to do is write an enum with an integer raw type that has less than 32 or 64 cases, depending on your target. You don&#39;t even have to specify the raw values—the default ones will work fine.<br></p><p>One reason we preserved the NS_OPTIONS model, where single options share the same type as option sets, is that it allows for API evolution. A library can break a single option down into multiple refined options while still offering the original option as the union of the new ones. So you can go from:<br></p><p>public struct LaundryOptions: OptionSetType {<br>  public static let EnergyStar = 1<br>}<br></p><p>to:<br></p><p>public struct LaundryOptions: OptionSetType {<br>  public static let EnergyStar: LaundryOptions = [.LowWater, .LowHeat]<br>  public static let LowWater = 1, LowHeat = 2<br>}<br></p><p>without breaking client code (or at least, client code that doesn&#39;t attempt to inspect the option set itself).<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
