<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>October 15, 2016 at 06:00:00pm</p></header><div class="content"><p>on Fri Oct 14 2016, Paul Cantrell &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; A late-arriving strong +1 for me. The index-related stuff is elegant and much needed. I’m surprised<br>&gt; to learn that dict.keys and dict.values are copies and not already<br>&gt; views! <br></p><p>They are views.<br></p><p>&gt; Clearly they should be.<br>&gt;<br>&gt; Question: I hit a closely related performance wall just last week, doing something like this:<br>&gt;<br>&gt;     for k in dict.keys {<br>&gt;         dict.values[k].append(1)<br>&gt;     }<br>&gt;<br>&gt; I assume / hope the proposal would also support this?<br>&gt;<br>&gt;     for i in dict.indices {<br>&gt;         dict.values[i].append(1)<br>&gt;     }<br>&gt;<br>&gt; …or would it be this?<br>&gt;<br>&gt;     for i in dict.keys.indices {<br>&gt;         dict.values[i].append(1)<br>&gt;     }<br>&gt;<br>&gt; …or either?<br>&gt;<br>&gt; Cheers, P<br>&gt;<br>&gt;&gt; On Oct 11, 2016, at 4:28 PM, Nate Cook via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal addresses significant unexpected performance gaps when using dictionaries. It<br>&gt; introduces type-specific collections for a Dictionary instance&#39;s keys and values properties.<br>&gt;&gt; <br>&gt;&gt; New DictionaryKeys and DictionaryValues collections provide efficient key lookup and mutable access to dictionary values, enabling updates to be performed in-place and allowing copy-on-write optimization of stored values.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; This proposal address two problems:<br>&gt;&gt; <br>&gt;&gt; The Dictionary type keys implementation is inefficient, because LazyMapCollection doesn&#39;t know how to forward lookups to the underlying dictionary storage.<br>&gt;&gt; Dictionaries do not offer value-mutating APIs. The mutating key-based subscript wraps values in an Optional. This prevents types with copy-on-write optimizations from recognizing they are singly referenced.<br>&gt;&gt; This proposal uses the following [String: [Int]] dictionary to demonstrate these problems:<br>&gt;&gt; <br>&gt;&gt; var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-dictkeys-search&gt;Inefficient dict.keys Search<br>&gt;&gt; <br>&gt;&gt; Swift coders normally test key membership using nil checks or underscored optional bindings:<br>&gt;&gt; <br>&gt;&gt; if dict[&quot;one&quot;] != nil {<br>&gt;&gt;     // ...<br>&gt;&gt; }<br>&gt;&gt; if let _ = dict[&quot;one&quot;] {<br>&gt;&gt;     // ...<br>&gt;&gt; }<br>&gt;&gt; These approaches provide the expected performance of a dictionary lookup but they read neither well nor &quot;Swifty&quot;. Checking keys reads much better but introduces a serious performance penalty: this approach requires a linear search through a dictionary&#39;s keys to find a match.<br>&gt;&gt; <br>&gt;&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;&gt;     // ...<br>&gt;&gt; }<br>&gt;&gt; A similar dynamic plays out when comparing dict.index(forKey:) and dict.keys.index(of:).<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-value-mutation&gt;Inefficient Value Mutation<br>&gt;&gt; <br>&gt;&gt; Dictionary values can be modified through the keyed subscript by direct reassignment or by using optional chaining. Both of these statements append 1 to the array stored by the key &quot;one&quot;:<br>&gt;&gt; <br>&gt;&gt; // Direct re-assignment<br>&gt;&gt; dict[&quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1]<br>&gt;&gt; <br>&gt;&gt; // Optional chaining<br>&gt;&gt; dict[&quot;one&quot;]?.append(1)<br>&gt;&gt; Both approaches present problems. The first is complex and hard to read. The second ignores the case where &quot;one&quot; is not a key in the dictionary. It forces its check into a higher branch and encourages forced unwrapping. Furthermore, neither approach allows the array to grow in place. They introduce an unnecessary copy of the array&#39;s contents even though dict is the sole holder of its storage.<br>&gt;&gt; <br>&gt;&gt; Adding mutation to a dictionary&#39;s index-based subscripting isn&#39;t possible. Changing a key stored at a particular index would almost certainly modify its hash value, rendering the index incorrect. This violates the requirements of the MutableCollection protocol.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#proposed-solution&gt;Proposed Solution<br>&gt;&gt; <br>&gt;&gt; This proposal adds a custom collection for the keys and values dictionary properties. This follows the example set by String, which presents multiple views of its contents. A new DictionaryKeys collection introduces efficient key lookup, while a new DictionaryValues collection provides a mutable collection interface to dictionary values.<br>&gt;&gt; <br>&gt;&gt; These changes introduce a simple and efficient way of checking whether a dictionary includes a key:<br>&gt;&gt; <br>&gt;&gt; // Performant<br>&gt;&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;&gt;     // ...<br>&gt;&gt; }<br>&gt;&gt; As a mutable collection, values enables modification without copies or clumsy code:<br>&gt;&gt; <br>&gt;&gt; if let i = dict.index(forKey: &quot;one&quot;) {<br>&gt;&gt;     dict.values[i].append(1)  // no copy here<br>&gt;&gt; } else {<br>&gt;&gt;     dict[&quot;one&quot;] = [1]<br>&gt;&gt; }<br>&gt;&gt; Both the keys and values collections share the same index type as Dictionary. This allows the above sample to be rewritten as:<br>&gt;&gt; <br>&gt;&gt; // Using `dict.keys.index(of:)`<br>&gt;&gt; if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;&gt;     dict.values[i].append(1)<br>&gt;&gt; } else {<br>&gt;&gt;     dict[&quot;one&quot;] = [1]<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; The standard library introduces two new collection types: DictionaryKeys and DictionaryValues.<br>&gt;&gt; A Dictionary&#39;s keys and values property types change from LazyMapCollection to these new types. <br>&gt;&gt; The new collection types are not directly constructable. They are presented only as views into a dictionary.<br>&gt;&gt; struct Dictionary&lt;Key: Hashable, Value&gt;: ... {<br>&gt;&gt;     var keys: DictionaryKeys&lt;Key, Value&gt; { get }<br>&gt;&gt;     var values: DictionaryValues&lt;Key, Value&gt; { get set }<br>&gt;&gt; <br>&gt;&gt;     // Remaining declarations<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; /// A collection view of a dictionary&#39;s keys.<br>&gt;&gt; struct DictionaryKeys&lt;Key: Hashable, Value&gt;: Collection {<br>&gt;&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;&gt;     subscript(i: Index) -&gt; Key { get }<br>&gt;&gt; <br>&gt;&gt;     // Other `Collection` requirements<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; /// A mutable collection view of a dictionary&#39;s values.<br>&gt;&gt; struct DictionaryValues&lt;Key: Hashable, Value&gt;: MutableCollection {<br>&gt;&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;&gt;     subscript(i: Index) -&gt; Value { get set }<br>&gt;&gt; <br>&gt;&gt;     // Other `Collection` requirements<br>&gt;&gt; }<br>&gt;&gt; A sample implementation of this proposal can be found in this branch &lt;https://github.com/natecook1000/swift/tree/nc-dictionary&gt;.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; The performance improvements of using the new DictionaryKeys type and the mutability of the DictionaryValuescollection are both additive in nature.<br>&gt;&gt; <br>&gt;&gt; Most uses of these properties are transitory in nature. Adopting this proposal should not produce a major impact on existing code. The only impact on existing code exists where a program explicitly specifies the type of a dictionary&#39;s keysor values property. The fix is to change the specified type. <br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The Generics Manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt;<br>&gt; lists nested generics as a goal. This could impact the naming and structure of these new collection<br>&gt; types.<br>&gt;&gt; <br>&gt;&gt; Instead of DictionaryKeys&lt;Key, Value&gt; and DictionaryValues&lt;Key, Value&gt;, these types could be<br>&gt; Dictionary&lt;Key, Value&gt;.Keys and Dictionary&lt;Key, Value&gt;.Values. However, because many types in the<br>&gt; standard library may be revisited once such a feature is available (indices, iterators, etc.), the<br>&gt; current lack of nesting shouldn&#39;t prevent consideration of this proposal.<br>&gt;&gt; <br>&gt;&gt; It could be possible to add additional compiler features that manage mutation through existing<br>&gt; key-based subscripting without the copy-on-write problems of the current implementation. I don&#39;t<br>&gt; know enough about how that would be implemented to speak to its feasibility or level of effort. Such<br>&gt; a feature would reduce the need for a mutable DictionaryValues collection.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>October 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 15, 2016, at 8:34 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Oct 14 2016, Paul Cantrell &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; A late-arriving strong +1 for me. The index-related stuff is elegant and much needed. I’m surprised<br>&gt;&gt; to learn that dict.keys and dict.values are copies and not already<br>&gt;&gt; views! <br>&gt; <br>&gt; They are views.<br></p><p><br>Oh, OK. I stand … er, type … corrected! I was thinking of this bit of the proposal:<br></p><p>&gt; this approach requires a linear search through a dictionary&#39;s keys to find a match.<br>&gt; <br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>I had wrongly assumed in the past that contains() would forward to an efficient lookup against the underlying dictionary. That’s what surprised me. It clearly deserves fixing.<br></p><p>From that, I made the incorrect leap to assuming that dict.keys made a copy. On more careful rereading and a visit to the docs for LazyMapCollection, the problem is much clearer to me now! Thanks as always for setting me right on the details.<br></p><p>Cheers, P<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161016/6119456d/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
