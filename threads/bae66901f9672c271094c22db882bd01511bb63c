<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Implementation of Type Erasers</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>September 15, 2016 at 08:00:00am</p></header><div class="content"><p>on Tue Sep 06 2016, Chris Eidhof &lt;swift-dev-AT-swift.org&gt; wrote:<br></p><p>&gt; Thanks! That explains a lot.<br>&gt;<br>&gt; In my version, performance only is improved by 10%, so I&#39;m not sure if the<br>&gt; tradeoff is worth it:<br>&gt;<br>&gt; In the isolated case of AnyIterator, there&#39;s only one method, so the sizeof<br>&gt; is the same (and the performance is worth it). In the case of AnySequence,<br>&gt; it would be a lot more work to write the implementation (and the size would<br>&gt; change a lot). Having two different mechanisms for type erasure seems like<br>&gt; it might confuse things even more.<br></p><p>We&#39;ll happily take a litte more implementation complexity in exchange<br>for performance gains.  10% is nothing to sneeze at.<br></p><p>&gt; On Mon, Sep 5, 2016 at 9:50 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Mon, Sep 5, 2016 at 11:13 AM, Chris Eidhof via swift-dev<br>&gt;&gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; &gt; Hello swift-dev,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I was wondering why type erasers (e.g. for AnyIterator) are implemented<br>&gt;&gt; the<br>&gt;&gt; &gt; way they are. I would implement AnyIterator like this:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; final class MyAnyIterator&lt;A&gt;: IteratorProtocol {<br>&gt;&gt; &gt;     var nextImpl: () -&gt; A?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     init&lt;I: IteratorProtocol&gt;(iterator: I) where I.Element == A {<br>&gt;&gt; &gt;         var copy = iterator<br>&gt;&gt; &gt;         nextImpl = { copy.next() }<br>&gt;&gt; &gt;     }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     func next() -&gt; A? {<br>&gt;&gt; &gt;         return nextImpl()<br>&gt;&gt; &gt;     }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Instead, it is implemented in a class which contains a box.<br>&gt;&gt;<br>&gt;&gt; Your approach requires adding a new closure property for every method<br>&gt;&gt; that is forwarded.  Subclassing does not require that.<br>&gt;&gt;<br>&gt;&gt; If you see a case where performance is not good, we would appreciate a<br>&gt;&gt; bugreport at https://bugs.swift.org/ .  Please attach a self-contained<br>&gt;&gt; reproducer.  Thank you.<br>&gt;&gt;<br>&gt;&gt; Dmitri<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ade0c334ecff1448bb96f5f733bf1f83?s=50"></div><header><strong>Implementation of Type Erasers</strong> from <string>Chris Eidhof</string> &lt;chris at eidhof.nl&gt;<p>September 19, 2016 at 09:00:00am</p></header><div class="content"><p>Hm. I&#39;m not sure if the performance difference is a hard limitation because<br>of implementation decisions, or if it would be possible to make the current<br>implementation as fast as the closure-based implementation. I don&#39;t<br>understand enough about the codegen (and about possible optimizations) to<br>make that decision. Anyone who&#39;s willing to help me there?<br></p><p>On Thu, Sep 15, 2016 at 5:01 PM, Dave Abrahams via swift-dev &lt;<br>swift-dev at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Tue Sep 06 2016, Chris Eidhof &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; Thanks! That explains a lot.<br>&gt; &gt;<br>&gt; &gt; In my version, performance only is improved by 10%, so I&#39;m not sure if<br>&gt; the<br>&gt; &gt; tradeoff is worth it:<br>&gt; &gt;<br>&gt; &gt; In the isolated case of AnyIterator, there&#39;s only one method, so the<br>&gt; sizeof<br>&gt; &gt; is the same (and the performance is worth it). In the case of<br>&gt; AnySequence,<br>&gt; &gt; it would be a lot more work to write the implementation (and the size<br>&gt; would<br>&gt; &gt; change a lot). Having two different mechanisms for type erasure seems<br>&gt; like<br>&gt; &gt; it might confuse things even more.<br>&gt;<br>&gt; We&#39;ll happily take a litte more implementation complexity in exchange<br>&gt; for performance gains.  10% is nothing to sneeze at.<br>&gt;<br>&gt; &gt; On Mon, Sep 5, 2016 at 9:50 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Mon, Sep 5, 2016 at 11:13 AM, Chris Eidhof via swift-dev<br>&gt; &gt;&gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt; Hello swift-dev,<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; I was wondering why type erasers (e.g. for AnyIterator) are<br>&gt; implemented<br>&gt; &gt;&gt; the<br>&gt; &gt;&gt; &gt; way they are. I would implement AnyIterator like this:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; final class MyAnyIterator&lt;A&gt;: IteratorProtocol {<br>&gt; &gt;&gt; &gt;     var nextImpl: () -&gt; A?<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;     init&lt;I: IteratorProtocol&gt;(iterator: I) where I.Element == A {<br>&gt; &gt;&gt; &gt;         var copy = iterator<br>&gt; &gt;&gt; &gt;         nextImpl = { copy.next() }<br>&gt; &gt;&gt; &gt;     }<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;     func next() -&gt; A? {<br>&gt; &gt;&gt; &gt;         return nextImpl()<br>&gt; &gt;&gt; &gt;     }<br>&gt; &gt;&gt; &gt; }<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Instead, it is implemented in a class which contains a box.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Your approach requires adding a new closure property for every method<br>&gt; &gt;&gt; that is forwarded.  Subclassing does not require that.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; If you see a case where performance is not good, we would appreciate a<br>&gt; &gt;&gt; bugreport at https://bugs.swift.org/ .  Please attach a self-contained<br>&gt; &gt;&gt; reproducer.  Thank you.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Dmitri<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; &gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; &gt;&gt;<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br></p><p><br></p><p>-- <br>Chris Eidhof<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160919/1121a799/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ade0c334ecff1448bb96f5f733bf1f83?s=50"></div><header><strong>Implementation of Type Erasers</strong> from <string>Chris Eidhof</string> &lt;chris at eidhof.nl&gt;<p>September 19, 2016 at 09:00:00am</p></header><div class="content"><p>Oh, also: for AnyIterator it was a pretty clear performance gain (in my<br>testing). I haven&#39;t tested other erasers such as AnySequence, but even if<br>they&#39;re faster, they will have to store more closures (instead of a single<br>base pointer) and will thus have memory overhead...<br></p><p>On Mon, Sep 19, 2016 at 9:43 AM, Chris Eidhof &lt;chris at eidhof.nl&gt; wrote:<br></p><p>&gt; Hm. I&#39;m not sure if the performance difference is a hard limitation<br>&gt; because of implementation decisions, or if it would be possible to make the<br>&gt; current implementation as fast as the closure-based implementation. I don&#39;t<br>&gt; understand enough about the codegen (and about possible optimizations) to<br>&gt; make that decision. Anyone who&#39;s willing to help me there?<br>&gt;<br>&gt; On Thu, Sep 15, 2016 at 5:01 PM, Dave Abrahams via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Tue Sep 06 2016, Chris Eidhof &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; Thanks! That explains a lot.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In my version, performance only is improved by 10%, so I&#39;m not sure if<br>&gt;&gt; the<br>&gt;&gt; &gt; tradeoff is worth it:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In the isolated case of AnyIterator, there&#39;s only one method, so the<br>&gt;&gt; sizeof<br>&gt;&gt; &gt; is the same (and the performance is worth it). In the case of<br>&gt;&gt; AnySequence,<br>&gt;&gt; &gt; it would be a lot more work to write the implementation (and the size<br>&gt;&gt; would<br>&gt;&gt; &gt; change a lot). Having two different mechanisms for type erasure seems<br>&gt;&gt; like<br>&gt;&gt; &gt; it might confuse things even more.<br>&gt;&gt;<br>&gt;&gt; We&#39;ll happily take a litte more implementation complexity in exchange<br>&gt;&gt; for performance gains.  10% is nothing to sneeze at.<br>&gt;&gt;<br>&gt;&gt; &gt; On Mon, Sep 5, 2016 at 9:50 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Mon, Sep 5, 2016 at 11:13 AM, Chris Eidhof via swift-dev<br>&gt;&gt; &gt;&gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt; &gt; Hello swift-dev,<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; I was wondering why type erasers (e.g. for AnyIterator) are<br>&gt;&gt; implemented<br>&gt;&gt; &gt;&gt; the<br>&gt;&gt; &gt;&gt; &gt; way they are. I would implement AnyIterator like this:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; final class MyAnyIterator&lt;A&gt;: IteratorProtocol {<br>&gt;&gt; &gt;&gt; &gt;     var nextImpl: () -&gt; A?<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;     init&lt;I: IteratorProtocol&gt;(iterator: I) where I.Element == A {<br>&gt;&gt; &gt;&gt; &gt;         var copy = iterator<br>&gt;&gt; &gt;&gt; &gt;         nextImpl = { copy.next() }<br>&gt;&gt; &gt;&gt; &gt;     }<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;     func next() -&gt; A? {<br>&gt;&gt; &gt;&gt; &gt;         return nextImpl()<br>&gt;&gt; &gt;&gt; &gt;     }<br>&gt;&gt; &gt;&gt; &gt; }<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Instead, it is implemented in a class which contains a box.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Your approach requires adding a new closure property for every method<br>&gt;&gt; &gt;&gt; that is forwarded.  Subclassing does not require that.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; If you see a case where performance is not good, we would appreciate a<br>&gt;&gt; &gt;&gt; bugreport at https://bugs.swift.org/ .  Please attach a self-contained<br>&gt;&gt; &gt;&gt; reproducer.  Thank you.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Dmitri<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; &gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt; &gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Chris Eidhof<br>&gt;<br></p><p><br></p><p>-- <br>Chris Eidhof<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160919/9425d468/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
