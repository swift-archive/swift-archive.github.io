<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Rationalizing Sequence end-operation names</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 23, 2016 at 12:00:00am</p></header><div class="content"><p>As previously threatened mentioned, I&#39;ve written a draft proposal to fix a number of naming issues with APIs operating on the beginning and end of Sequences and Collections:<br></p><p>• Inconsistent use of `prefix`/`suffix` vs. `first`/`last`<br>• Confusing naming of `drop` methods<br>• Ambiguous naming of `index(of:/where:)` and `drop(while:)`<br>• `prefix(upTo:)`, `prefix(through:)`, and `suffix(from:)` shouldn&#39;t be part of this family at all<br></p><p>To fix this, I propose:<br></p><p>• Renaming all methods which operate on more than one element at the beginning/end to use &quot;prefix&quot; or &quot;suffix&quot;, not &quot;first&quot; or &quot;last&quot;<br>• Renaming `index(of:/where:)` to `earliestIndex(…)` and `first(where:)` to `earliest(where:)`<br>• Renaming the `drop` methods to use `removing`<br>• Redesigning `prefix(upTo:)`, `prefix(through:)` and `suffix(from:)` as subscripts with &quot;partial&quot; ranges, like `people[..&lt;idx]` or perhaps `people[nil..&lt;idx]`.<br></p><p>Since that last point requires significant redesign, including the introduction of new types, I have also included an alternative design which uses `people[to: idx]` instead.<br></p><p>This proposal does not seek to add new functionality; it merely renames or (in the case of the &quot;aggressive&quot; subscript option) redesigns existing functionality. I do, however, discuss (without making many judgements about their wisdom) how these changes might affect the naming of functionality we might add in future versions of Swift.<br></p><p>I would mainly like feedback on the two most open questions left in this proposal:<br></p><p>• The choice of `removing` to replace `drop`<br>• The decision about whether to use `people[..&lt;idx]`, `people[nil..&lt;idx]`, or `people[to: idx]`.<br></p><p>But I&#39;d also like comments on the rest of the proposal, and on whether I should split the prefix(upTo:/through:)/suffix(from:) changes into a separate proposal from the rest.<br></p><p>I suspect this will cause a firestorm of bikeshedding, so please try to keep your suggestions grounded. Don&#39;t just suggest a name; articulate why it&#39;s a better choice than what we already have or what this proposal suggests. Only you can prevent our first *three*-hundred-message bikeshedding thread.<br></p><p>Thanks for your attention!<br></p><p>(P.S. The proposal below includes several huge tables which may cause some mail clients to become very pouty and refuse to eat their supper. You may want to read the proposal at &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430 &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430&gt;&gt; instead.)<br></p><p>Rationalizing Sequence end-operation names<br>Proposal: SE-NNNN &lt;https://gist.github.com/brentdax/NNNN-sequence-end-op.md&gt;<br>Author: Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>Status: Draft<br>Review manager: TBD<br> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#introduction&gt;Introduction<br></p><p>Sequence and Collection offer many special operations which access or manipulate its first or last elements, but they are plagued by inconsistent naming which can make it difficult to find inverses or remember what the standard library offers. I propose that we standardize these names so they follow consistent, predictable patterns.<br></p><p>Swift-evolution thread: Pending &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#scope&gt;Scope<br></p><p>This proposal is not intended to add or remove any functionality; it merely renames and redesigns existing operations. Adding new operations is out of scope for this proposal unless it&#39;s incidental to the new designs.<br></p><p>Nonetheless, I do want the new designs to support adding more operations in the future. The names I&#39;ve chosen are informed by some of the speculative APIs discussed in &quot;Future directions&quot;, although I think they are perfectly sensible names even if nothing else changes.<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#motivation&gt;Motivation<br></p><p>The Sequence and Collection protocols offer a wide variety of APIs which are defined to operate on, or from, one end of the sequence:<br></p><p>Operand	Get	Index	Exclude	Remove (1)	Pop (1)	Equate (2)<br>Fixed Size						<br>First 1	C.first	-	S.dropFirst()	C.removeFirst()	C.popFirst()	-<br>Last 1	C.last	-	S.dropLast()	C.removeLast()	C.popLast()	-<br>First (n: Int)	S.prefix(_:)	-	S.dropFirst(_:)	C.removeFirst(_:)	-	S.starts(with:)<br>  ...with closure	S.prefix(while:)	-	S.drop(while:)	-	-	S.starts(with:isEquivalent:)<br>Last (n: Int)	S.suffix(_:)	-	S.dropLast(_:)	C.removeLast(_:)	-	-<br>  ...with closure	-	-	-	-	-	-<br>Searching From End						<br>First matching element	-	C.index(of:)	-	-	-	-<br>  ...with closure	S.first(where:)	C.index(where:)	-	-	-	-<br>Last matching element	-	-	-	-	-	-<br>  ...with closure	-	-	-	-	-	-<br>Based on Index						<br>startIndex ..&lt; (i: Index)	C.prefix(upTo:)	-	-	-	-	-<br>startIndex ... (i: Index)	C.prefix(through:)	-	-	-	-	-<br>(i: Index) ..&lt; endIndex	C.suffix(from:)	-	-	-	-	-<br>I have included several blank rows for operands which fit the APIs&#39; patterns, even if they don&#39;t happen to have any operations currently.<br></p><p>Type abbreviations:<br></p><p>S = Sequence<br>C = Collection (or a sub-protocol like BidirectionalCollection)<br>Notes:<br></p><p>remove and pop both mutate the array to delete the indicated element(s), but remove assumes as a precondition that the indicated elements exist, while pop checks whether or not they exist.<br></p><p>String and NSString have bespoke versions of first n and last n Equate operations, in the form of their hasPrefix and hasSuffix methods.<br></p><p>Leaving aside the question of whether any gaps in these tables ought to be filled, I see a number of issues with existing terminology.<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#inconsistent-use-of-prefix-and-suffix&gt;Inconsistent use of prefix and suffix<br></p><p>Some APIs which operate on a variable number of elements anchored at one end or the other use the terms prefix or suffix:<br></p><p>Sequence.prefix(_:) and Sequence.suffix(_:)<br>Sequence.prefix(while:)<br>String.hasPrefix(_:) and String.hasSuffix(_:)<br>Others, however, use first or last:<br></p><p>Sequence.dropFirst(_:) and Sequence.dropLast(_:)<br>Sequence.removeFirst(_:) and Sequence.removeLast(_:)<br>Still others use neither:<br></p><p>Sequence.starts(with:)<br>Sequence.drop(while:)<br>These methods are all closely related, but because of this inconsistent terminology, they fail to form predictable method families.<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#first-has-multiple-meanings&gt;first has multiple meanings<br></p><p>The word first can mean three different things in these APIs:<br></p><p>Just the very first element of the sequence.<br></p><p>A subsequence of elements anchored at the beginning of the sequence, as mentioned in the last point.<br></p><p>The first element encountered in the sequence which matches a given criterion when walking from the beginning of the sequence towards the end.<br></p><p>It would be nice to have more clarity here.<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#drop-is-misleading-and-scary&gt;drop is misleading and scary<br></p><p>In a Swift context, I believe the drop methods are actively confusing:<br></p><p>drop does not have the -ing or -ed suffix normally used for a nonmutating method.<br></p><p>drop has strong associations with destructive operations; it&#39;s the term used, for instance, for deleting whole tables in SQL. Even dropping would probably sound more like a mutating operation than alternatives.<br></p><p>As previously mentioned, the use of dropFirst and dropLast for single-drop operations and multiple-drop operations breaks up method families.<br></p><p>drop, dropFirst, and dropLast are terms of art, so we allow them a certain amount of leeway. However, I believe the drop functions go well beyond what we should permit. They are relatively uncommon operations, associated primarily with functional languages rather than mainstream object-oriented or imperative languages, and their violation of the normal Swift naming guidelines is especially misleading.<br></p><p>The term-of-art exception is not a suicide pact; it is meant to aid understanding by importing common terminology, not bind us to follow every decision made by any language that came before us. In this case, I think we should ignore precedent and forge our own path.<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#unstated-direction-of-operation&gt;Unstated direction of operation<br></p><p>Several APIs could theoretically be implemented by working from either end of the sequence, and would return different results depending on the direction, but do not indicate the direction in their names:<br></p><p>Sequence.drop(while:)<br>Collection.index(of:)<br>Adding a direction to these APIs would make their behavior clearer and permit us to offer opposite-end equivalents in the future. (Unmerged swift-evolution pull request 329 &lt;https://github.com/apple/swift-evolution/pull/329&gt; would add lastIndex methods.)<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#the-index-base-name-has-been-polluted&gt;The index(...) base name has been polluted<br></p><p>Swift 3&#39;s new collection model placed a number of low-level index manipulating operations on the base method name index. These now share that name with index(of:) and index(where:), which are much higher-level operations. This may be confusing for users looking for high-level operations; the only real relationship between the two sets of operations is that they both return an index.<br></p><p>It would be nice to separate these two groups of methods into different families.<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#operations-taking-an-index-are-really-slicing&gt;Operations taking an index are really slicing<br></p><p>prefix(upTo:), prefix(through:), and suffix(from:) at first appear to belong to the same family as the other prefix and suffix methods, but deeper examination reveals otherwise. They are the only operations which take indices, and they don&#39;t cleanly extend to the other operations which belong to these families. (For instance, it would not make sense to add a dropPrefix(upTo:) method; it would be equivalent to suffix(from:).)<br></p><p>Also, on Int-indexed collections like Array, prefix(_:) and prefix(upTo:) are identical, but there is little relationship between suffix(_:) and suffix(from:), which is confusing.<br></p><p>suffix(from:) is a particularly severe source of confusion. The other suffix APIs all have parameters relative to the endof the collection, but suffix(from:)&#39;s index is still relative to the beginning of the array. This is obvious if you think deeply about the meaning of an index, but we don&#39;t really want to force our users to stare at a strange API until they have an epiphany.<br></p><p>I believe these operations have much more in common with slicing a collection using a range, and that reimagining them as slicing APIs will be more fruitful.<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#why-does-it-matter&gt;Why does it matter?<br></p><p>Many of these APIs are only occasionally necessary, so it&#39;s important that they be easy to find when needed and easy to understand when read. If you know that prefix(10) will get the first ten elements but don&#39;t know what its inverse is, you will probably not guess that it&#39;s dropFirst(10). The confusing, conflicting names in these APIs are a barrier to users adopting them where appropriate.<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#proposed-solution&gt;Proposed solution<br></p><p>We sever the index-taking APIs from the others, forming two separate families, which I will call the &quot;Sequence-end operations&quot; and the &quot;index-based operations&quot;. We then consider and redesign them along separate lines.<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#sequence-end-operations&gt;Sequence-end operations<br></p><p>Each of these APIs should be renamed to use a directional word based on its row in the table:<br></p><p>Operand	Directional word<br>Fixed Size	<br>First 1	first<br>Last 1	last<br>First (n: Int)	prefix<br>  ...with closure	prefix<br>Last (n: Int)	suffix<br>  ...with closure	suffix<br>Searching From End	<br>First matching element	earliest<br>  ...with closure	earliest<br>Last matching element	latest<br>  ...with closure	latest<br>To accomplish this, starts(with:) should be renamed to hasPrefix(_:), and other APIs should have directional words replaced or added as appropriate.<br></p><p>Additionally, the word drop in the &quot;Exclude&quot; APIs should be replaced with removing. These operations omit the same elements which the remove operations delete, so even though the types are not always the same (removing returns SubSequence, not Self), I think they are similar enough to deserve to be treated as nonmutating forms.<br></p><p>These changes yield (altered names bold):<br></p><p>Operand	Get	Index	Exclude	Remove (1)	Pop (1)	Equate (2)<br>Fixed Size						<br>First 1	C.first	-	S.removingFirst()	C.removeFirst()	C.popFirst()	-<br>Last 1	C.last	-	S.removingLast()	C.removeLast()	C.popLast()	-<br>First (n: Int)	S.prefix(_:)	-	S.removingPrefix(_:)	C.removePrefix(_:)	-	S.hasPrefix(_:)<br>  ...with closure	S.prefix(while:)	-	S.removingPrefix(while:)	-	-	S.hasPrefix(_:isEquivalent:)<br>Last (n: Int)	S.suffix(_:)	-	S.removingSuffix(_:)	C.removeSuffix(_:)	-	-<br>  ...with closure	-	-	-	-	-	-<br>Searching From End						<br>First matching element	-	C.earliestIndex(of:)	-	-	-	-<br>  ...with closure	S.earliest(where:)	C.earliestIndex(where:)	-	-	-	-<br>Last matching element	-	-	-	-	-	-<br>  ...with closure	-	-	-	-	-	-<br> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#alternative-to-removing&gt;Alternative to removing<br></p><p>If the type differences are seen as disqualifying removing as a replacement for drop, I suggest using skipping instead.<br></p><p>There are, of course, many possible alternatives to skipping; this is almost a perfect subject for bikeshedding. I&#39;ve chosen skipping because:<br></p><p>It is not an uncommon word, unlike (say) omitting. This means non-native English speakers and schoolchildren are more likely to recognize it.<br></p><p>It is an -ing verb, unlike (say) without. This makes it fit common Swift naming patterns more closely.<br></p><p>It does not imply danger, unlike (say) dropping, nor some sort of ongoing process, unlike (say) ignoring. This makes its behavior more obvious.<br></p><p>If you want to suggest an alternative on swift-evolution, please do not merely mention a synonym; rather, explain why it is an improvement on either these axes or other ones. (I would be particularly interested in names other than removing which draw an analogy to something else in Swift.)<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#index-based-operations&gt;Index-based operations<br></p><p>Because these APIs look up elements based on their indices, I believe these operations should be exposed as subscripts, and ideally should look like other slicing operations.<br></p><p>My primary design is rather ambitious, introducing two new types and either two operator overloads, or four unary forms of existing binary operators. I therefore present a more conservative alternative as well.<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#preferred-ambitious-option&gt;Preferred (ambitious) option<br></p><p>let head = people[..&lt;i]<br>let tail = people[i..&lt;]<br>let rearrangedPeople = tail + head<br>Or this small variation:<br></p><p>let head = people[nil ..&lt; i]<br>let tail = people[i ..&lt; nil]<br>let rearrangedPeople = tail + head<br>The operators would construct instances of a new pair of types, IncompleteRange (for ..&lt;) and IncompleteClosedRange (for ...), and Collection would include new subscripts taking these types. These would probably have default implementations which constructed an equivalent Range or ClosedRange using startIndex and endIndex, then passed the resulting range through to the existing subscripts.<br></p><p>I prefer this option because it offers an elegant syntax immediately recognizable as a form of slicing, and provides a straightforward way for a future version of Swift to extend other Range-handling Collection operations, like replaceSubrange(_:with:) and removeSubrange(_:), to handle subranges bound by the ends of the Collection.<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#alternative-conservative-option&gt;Alternative (conservative) option<br></p><p>let head = people[to: i]<br>let tail = people[from: i]<br>let rearrangedPeople = tail + head<br>This would be a simple changing of the methods into subscripts; no additional types or operators would be needed. I have changed upTo: into just to: to match the pattern set by stride(from:to:by:).<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#detailed-design&gt;Detailed design<br></p><p>Draft note: This section is a mere sketch and should probably be expanded before submitting for a pull request.<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#sequence-end-operations-1&gt;Sequence-end operations<br></p><p>The following methods should be renamed as follows wherever they appear in the standard library. These are simple textual substitutions; we propose no changes whatsoever to types, parameter interpretations, or other semantics.<br></p><p>Old method	New method<br>dropFirst() -&gt; SubSequence	removingFirst() -&gt; SubSequence<br>dropLast() -&gt; SubSequence	removingLast() -&gt; SubSequence<br>dropFirst(_ n: Int) -&gt; SubSequence	removingPrefix(_ n: Int) -&gt; SubSequence<br>drop(@noescape while predicate: (Iterator.Element) throws -&gt; Bool) rethrows -&gt; SubSequence	removingPrefix(@noescape while predicate: (Iterator.Element) throws -&gt; Bool) rethrows -&gt; SubSequence<br>dropLast(_ n: Int) -&gt; SubSequence	removingSuffix(_ n: Int) -&gt; SubSequence<br>removeFirst(_ n: Int)	removePrefix(_ n: Int)<br>removeLast(_ n: Int)	removeSuffix(_ n: Int)<br>starts&lt;PossiblePrefix: Sequence&gt;(with possiblePrefix: PossiblePrefix) -&gt; Bool where ...	hasPrefix&lt;PossiblePrefix: Sequence&gt;(_ possiblePrefix: PossiblePrefix) -&gt; Bool where ...<br>starts&lt;PossiblePrefix : Sequence&gt;(with possiblePrefix: PossiblePrefix, isEquivalent: @noescape (Iterator.Element, Iterator.Element) throws -&gt; Bool) rethrows -&gt; Bool where ...	hasPrefix&lt;PossiblePrefix : Sequence&gt;(_ possiblePrefix: PossiblePrefix, isEquivalent: @noescape (Iterator.Element, Iterator.Element) throws -&gt; Bool) rethrows -&gt; Bool where ...<br>first(where predicate: @noescape (Iterator.Element) throws -&gt; Bool) rethrows -&gt; Iterator.Element?	earliest(where predicate: @noescape (Iterator.Element) throws -&gt; Bool) rethrows -&gt; Iterator.Element?<br>index(of element: Iterator.Element) -&gt; Index?	earliestIndex(of element: Iterator.Element) -&gt; Index?<br>index(where predicate: @noescape (Iterator.Element) throws -&gt; Bool) rethrows -&gt; Index?	earliestIndex(where predicate: @noescape (Iterator.Element) throws -&gt; Bool) rethrows -&gt; Index?<br> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#index-based-operations-1&gt;Index-based operations<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#preferred-ambitious-option-1&gt;Preferred (ambitious) option<br></p><p>Implementation would be roughly as follows:<br></p><p>Add a pair of new types, IncompleteRange and IncompleteClosedRange, with definitions like:<br></p><p>struct IncompleteRange&lt;Bound: Comparable&gt; {<br>   var lowerBound: Bound?<br>   var upperBound: Bound?<br></p><p>   func completed(with bounds: Range&lt;Bound&gt;) -&gt; Range&lt;Bound&gt; {<br>       return (lowerBound ?? bounds.lowerBound) ..&lt; (upperBound ?? bounds.upperBound)<br>   }<br>}<br>// And likewise for `IncompleteClosedRange`<br>Either add prefix and postfix ..&lt; and ... operators, or overload the existing infix ..&lt; and ... operators, to construct an IncompleteRange or IncompleteClosedRange. For the prefix/postfix operators, this would look like:<br></p><p>postfix func ..&lt; &lt;Bound: Comparable&gt;(lowerBound: Bound) -&gt; IncompleteRange&lt;Bound&gt; {<br>   return IncompleteRange(lowerBound: lowerBound, upperBound: nil)<br>}<br>prefix func ..&lt; &lt;Bound: Comparable&gt;(upperBound: Bound) -&gt; IncompleteRange&lt;Bound&gt; {<br>      return IncompleteRange(lowerBound: nil, upperBound: upperBound)<br>}<br>// And likewise for `...` and `IncompleteClosedRange`<br>Add a pair of IncompleteRange and IncompleteClosedRange subscripts to Collection:<br></p><p>extension Collection {<br>   subscript (range: IncompleteRange&lt;Index&gt;) -&gt; SubSequence {<br>       return self[range.completed(with: startIndex ..&lt; endIndex)]<br>   }<br>   // And likewise for `IncompleteClosedRange`<br>}<br> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#alternative-conservative-option-1&gt;Alternative (conservative) option<br></p><p>The three methods below will be replaced with equivalent subscripts in all types conforming to Collection or a sub-protocol:<br></p><p>Old method	New subscript<br>prefix(upTo end: Index) -&gt; SubSequence	subscript(to end: Index) -&gt; SubSequence<br>prefix(through position: Index) -&gt; SubSequence	subscript(through position: Index) -&gt; SubSequence<br>func suffix(from start: Index) -&gt; SubSequence	subscript(from start: Index) -&gt; SubSequence<br> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#impact-on-existing-code&gt;Impact on existing code<br></p><p>Obviously, any code using these APIs under their old names or designs would have to be transitioned to the new names and designs.<br></p><p>The sequence-end operations would be by far the simplest to handle; these are simple renamings and could be handed by @available(renamed:) and migration support. The only complication is that some overloads have transitioned to a new base name, while others have stayed with the old one, but I suspect the migrator is up to this task.<br></p><p>The preferred option for index-based operations is more difficult to migrate. The patterns would be roughly:<br></p><p>collection.prefix(upTo: i)    =&gt; collection[..&lt;i] or collection[nil ..&lt; i]<br>collection.prefix(through: i) =&gt; collection[...i] or collection[nil ... i]<br>collection.suffix(from: i)    =&gt; collection[i..&lt;] or collection[i ..&lt; nil]<br>A custom fix-it would be ideal, but is probably not absolutely necessary here; an @available(message:) would do in a pinch. Presumably this would have to be a special case in the migrator as well.<br></p><p>The alternative option for index-based operations would be simpler to fix-it and migrate—we need merely change references from the method to the subscript with the same (or similar, for upTo) parameter labels. I&#39;m not sure if @available(renamed:) supports changing a method to a subscript.<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#alternatives-considered&gt;Alternatives considered<br></p><p>I considered many alternatives to removing or skipping, some of which are discussed in the section about them.<br></p><p>Rather than using earliest and latest, I considered using first and last for the &quot;First matching&quot; and &quot;Last matching&quot; categories. However, I didn&#39;t like the thought of overloading a property with a function, and I felt like earliest and latest actually have different semantics (searching for the match closest to a particular end) than first and last (manipulating the element at that end).<br></p><p>I considered using first and last as the basis for both single-element and multiple-element operations (such that prefix(3) would become first(3), etc.), but:<br></p><p>These seemed like distinct functionalities, particularly since their types are different.<br></p><p>I&#39;m not comfortable with heavily overloading a property with a bunch of methods, and didn&#39;t want to make firstand last into methods.<br></p><p>Most APIs work fine, but hasFirst(_:) is atrocious, and I see no better alternative which includes the word first.<br></p><p>I considered moving first and last to Sequence and possibly making them methods, but my understanding is that the core team has considered and rejected this approach in the past.<br></p><p>I considered moving removingFirst and removingLast to Collection and making them properties, to match firstand last, but this seemed like the sort of foolish consistency that Ralph Waldo Emerson warned of.<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#future-directions&gt;Future directions<br></p><p>Note: The rest of this proposal is highly speculative and there&#39;s probably no need to read further.<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#other-sequence-api-cleanups&gt;Other Sequence API cleanups<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#seriously-source-breaking&gt;Seriously source-breaking<br></p><p>There is an ongoing discussion about which, if any, of map, flatMap, filter, and reduce ought to be renamed to more closely match Swift naming conventions. There is also discussion about relabeling many closure parameters.<br></p><p>The &quot;Future directions&quot; section below suggests every(where:) as an alternative to filter which could be extended in ways compatible with this proposal.<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#significantly-source-breaking&gt;Significantly source-breaking<br></p><p>The removeSubrange(_:) and replaceSubrange(_:with:) APIs are rather oddly named. They might be better renamed to, for instance, remove(in:) and replace(in:with:).<br></p><p>It is not clear how important removingFirst() and removingLast() actually are, given that they&#39;re exactly equivalent to removingPrefix(1) and removingSuffix(1), and their corresponding &quot;get&quot; members are on Collection instead of Sequence. They could be removed.<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#slightly-source-breaking&gt;Slightly source-breaking<br></p><p>removeFirst/Last() and popFirst/Last() are very nearly redundant; their only difference is that the removemethods have a non-Optional return type and require the collection not be empty, while the pop methods have an Optional return type and return nil if it&#39;s empty.<br></p><p>These operations could be merged, with the remove operations taking on the preconditions of the current popoperations; additionally, removePrefix(_:) and removeSuffix(_:) could drop their equivalent preconditions requiring that the elements being removed exist. These changes would simplify the standard library and make these methods more closely parallel the equivalent removing methods, which do not have similar preconditions.<br></p><p>Performance-critical code which wants to avoid the checks necessary to remove these preconditions could switch to remove(at:) and removeSubrange(_:), which would continue to reject invalid indices.<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#adding-sequence-and-collection-operations&gt;Adding sequence and collection operations<br></p><p>This exercise in renaming suggests all sorts of other APIs we might add, and a few we might rename.<br></p><p>In general, I have not attempted to carefully scrutinize the usefulness of each of these APIs; instead, I have merely listed the ones which I can imagine some kind of use for. The main exception is the &quot;Pop&quot; operation; I can imagine several different, and rather incompatible, ways to extend it, and I&#39;m not going to take the time to sort out my thoughts merely to write a &quot;Future directions&quot; section.<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#filling-in-the-sequence-end-api-table&gt;Filling in the sequence-end API table<br></p><p>The gaps in the table suggest a number of APIs we could offer in the future. Here, I have filled in all options which are at least coherent:<br></p><p>Operand	Get	Index	Exclude	Remove (1)	Pop (1)	Equate (2)<br>Fixed Size						<br>First 1	C.first	C.firstIndex	S.removingFirst()	C.removeFirst()	C.popFirst()	-<br>Last 1	C.last	C.lastIndex	S.removingLast()	C.removeLast()	C.popLast()	-<br>First (n: Int)	S.prefix(_:)	C.prefixIndex(_:)	S.removingPrefix(_:)	C.removePrefix(_:)	-	S.hasPrefix(_:)<br>  ...with closure	S.prefix(while:)	C.prefixIndex(while:)	S.removingPrefix(while:)	C.removePrefix(while:)	-	S.hasPrefix(_:isEquivalent:)<br>Last (n: Int)	S.suffix(_:)	C.suffixIndex(_:)	S.removingSuffix(_:)	C.removeSuffix(_:)	-	S.hasSuffix(_:)<br>  ...with closure	S.suffix(while:)	C.suffixIndex(while:)	S.removingSuffix(while:)	C.removeSuffix(while:)	-	S.hasSuffix(_:isEquivalent:)<br>Searching From End						<br>First matching element	S.earliest(_:)	C.earliestIndex(of:)	S.removingEarliest(_:)	C.removeEarliest(_:)	-	-<br>  ...with closure	S.earliest(where:)	C.earliestIndex(where:)	S.removingEarliest(where:)	C.removeEarliest(where:)	-	-<br>Last matching element	S.latest(_:)	C.latestIndex(of:)	S.removingLatest(_:)	C.removeLatest(_:)	-	-<br>  ...with closure	S.latest(where:)	C.latestIndex(where:)	S.removingLatest(where:)	C.removeLatest(where:)	-	-<br>To explain a few entries which might not be immediately obvious: firstIndex and lastIndex would be nil if the collection is empty, and lastIndex would be the index before endIndex. prefixIndex would return the last index of the prefix, and suffixIndex would return the first index of the suffix; alternatively, these could be named with Indices and return ranges. earliest(_:) and latest(_:) would return the first and last element equal to the provided value; on a Set, they would be roughly equivalent to NSSet.member(_:).<br></p><p>The changes I consider most worthy include:<br></p><p>Adding corresponding last, suffix, and latest methods for all first, prefix, and earliest methods.<br></p><p>Adding corresponding while: versions of all appropriate prefix/suffix APIs.<br></p><p>Ones that could be useful, but can usually be emulated with more work:<br></p><p>Adding remove/removing-by-content APIs.<br></p><p>Adding prefix/suffixIndex(while:).<br></p><p>Ones that are mere conveniences or may not have strong use cases:<br></p><p>first/lastIndex and prefix/suffixIndex(_:).<br></p><p>earliest/latest(_:).<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#all-and-every-as-operands&gt;&quot;All&quot; and &quot;Every&quot; as operands<br></p><p>One could imagine adding rows to this table for &quot;all&quot; and &quot;every matching&quot;. In addition to creating some useful new API, this would also suggest some interesting renaming for existing APIs:<br></p><p>allIndices would be a name for indices.<br></p><p>removeAll() is actually an existing name which happens to fit this pattern.<br></p><p>every(where:) would be a name for filter. Though I believe filter is a strong term of art, I do note that every(where:) does not cause confusion about the sense of its test, a major complaint about filter.<br></p><p>In the table below, bold indicates new functionality; italics indicates existing functionality renamed to fit this pattern.<br></p><p>Operand	Get	Index	Exclude	Remove (1)	Pop (1)	Equate (2)<br>Fixed Size						<br>First 1	C.first	C.firstIndex	S.removingFirst()	C.removeFirst()	C.popFirst()	-<br>Last 1	C.last	C.lastIndex	S.removingLast()	C.removeLast()	C.popLast()	-<br>First (n: Int)	S.prefix(_:)	C.prefixIndex(_:)	S.removingPrefix(_:)	C.removePrefix(_:)	-	S.hasPrefix(_:)<br>  ...with closure	S.prefix(while:)	C.prefixIndex(while:)	S.removingPrefix(while:)	C.removePrefix(while:)	-	S.hasPrefix(_:isEquivalent:)<br>Last (n: Int)	S.suffix(_:)	C.suffixIndex(_:)	S.removingSuffix(_:)	C.removeSuffix(_:)	-	S.hasSuffix(_:)<br>  ...with closure	S.suffix(while:)	C.suffixIndex(while:)	S.removingSuffix(while:)	C.removeSuffix(while:)	-	S.hasSuffix(_:isEquivalent:)<br>All	-	allIndices	-	C.removeAll()	-	-<br>Searching From End						<br>First matching element	S.earliest(_:)	C.earliestIndex(of:)	S.removingEarliest(_:)	C.removeEarliest(_:)	-	-<br>  ...with closure	S.earliest(where:)	C.earliestIndex(where:)	S.removingEarliest(where:)	C.removeEarliest(where:)	-	-<br>Last matching element	S.latest(_:)	C.latestIndex(of:)	S.removingLatest(_:)	C.removeLatest(_:)	-	-<br>  ...with closure	S.latest(where:)	C.latestIndex(where:)	S.removingLatest(where:)	C.removeLatest(where:)	-	-<br>Every matching element	S.every(_:)	C.everyIndex(of:)	S.removingEvery(_:)	C.removeEvery(_:)	-	-<br>  ...with closure	S.every(where:)	C.everyIndex(where:)	S.removingEvery(where:)	C.removeEvery(where:)	-	-<br>An alternative to the every methods is to give them names based on all or any, but these tend to require breaks from the naming patterns of the matching earliest and latest methods to remain grammatical.<br></p><p> &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#additional-index-based-operations&gt;Additional index-based operations<br></p><p>Though accessing a range of elements bounded by the end of the collection is useful, it might be useful to extend that ability to other range-based collection APIs. IncompleteRange would make this especially easy; we would simply overload Range-taking APIs to permit IncompleteRanges as well. However, we could also provide variants of these APIs which take a to:, through:, or from: index parameter in place of an index range.<br></p><p>Candidates include:<br></p><p>MutableCollection.subscript(bounds: Range&lt;Index&gt;) { set }, making the subscripts in this proposal mutable.<br></p><p>RangeReplaceableCollection.removeSubrange(\_:)<br></p><p>RangeReplaceableCollection.replaceSubrange(\_:with:)<br></p><p>The various Range parameters in String (although these might be better replaced with slice-based APIs).<br></p><p><br>-- <br>Brent Royal-Gordon<br>Architechies<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/923947a2/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/426fbd3d9b662663dc5647b08c4e3410?s=50"></div><header><strong>[Draft] Rationalizing Sequence end-operation names</strong> from <string>Anders Ha</string> &lt;hello at andersio.co&gt;<p>June 24, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On 23 Jun 2016, at 3:19 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; As previously threatened mentioned, I&#39;ve written a draft proposal to fix a number of naming issues with APIs operating on the beginning and end of Sequences and Collections:<br>&gt; <br>&gt; • Inconsistent use of `prefix`/`suffix` vs. `first`/`last`<br>&gt; • Confusing naming of `drop` methods<br>&gt; • Ambiguous naming of `index(of:/where:)` and `drop(while:)`<br>&gt; • `prefix(upTo:)`, `prefix(through:)`, and `suffix(from:)` shouldn&#39;t be part of this family at all<br>&gt; <br>&gt; To fix this, I propose:<br>&gt; <br>&gt; • Renaming all methods which operate on more than one element at the beginning/end to use &quot;prefix&quot; or &quot;suffix&quot;, not &quot;first&quot; or &quot;last&quot;<br></p><p>Just want to point out that `prefix` and `suffix` may introduce ambiguity, as they are also imperative verbs. For example, `S.prefix(1)` can be inferred as prefixing `1` to the sequence, instead of retrieving the prefix of the sequence.<br></p><p>IMO `skip`, as an alternative listed in the proposal, would convey the intention better and clearer, and it has roots in the sequence-like constructs of reactive programming libraries (e.g. RxSwift and ReactiveCocoa).<br></p><p><br>&gt; • Renaming `index(of:/where:)` to `earliestIndex(…)` and `first(where:)` to `earliest(where:)`<br>&gt; • Renaming the `drop` methods to use `removing`<br>&gt; • Redesigning `prefix(upTo:)`, `prefix(through:)` and `suffix(from:)` as subscripts with &quot;partial&quot; ranges, like `people[..&lt;idx]` or perhaps `people[nil..&lt;idx]`.<br>&gt; <br>&gt; Since that last point requires significant redesign, including the introduction of new types, I have also included an alternative design which uses `people[to: idx]` instead.<br>&gt; <br>&gt; This proposal does not seek to add new functionality; it merely renames or (in the case of the &quot;aggressive&quot; subscript option) redesigns existing functionality. I do, however, discuss (without making many judgements about their wisdom) how these changes might affect the naming of functionality we might add in future versions of Swift.<br>&gt; <br>&gt; I would mainly like feedback on the two most open questions left in this proposal:<br>&gt; <br>&gt; • The choice of `removing` to replace `drop`<br>&gt; • The decision about whether to use `people[..&lt;idx]`, `people[nil..&lt;idx]`, or `people[to: idx]`.<br>&gt; <br>&gt; But I&#39;d also like comments on the rest of the proposal, and on whether I should split the prefix(upTo:/through:)/suffix(from:) changes into a separate proposal from the rest.<br>&gt; <br>&gt; I suspect this will cause a firestorm of bikeshedding, so please try to keep your suggestions grounded. Don&#39;t just suggest a name; articulate why it&#39;s a better choice than what we already have or what this proposal suggests. Only you can prevent our first *three*-hundred-message bikeshedding thread.<br>&gt; <br>&gt; Thanks for your attention!<br>&gt; <br>&gt; (P.S. The proposal below includes several huge tables which may cause some mail clients to become very pouty and refuse to eat their supper. You may want to read the proposal at &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430 &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430&gt;&gt; instead.)<br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/df0face8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Rationalizing Sequence end-operation names</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 27, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Just want to point out that `prefix` and `suffix` may introduce ambiguity, as they are also imperative verbs. For example, `S.prefix(1)` can be inferred as prefixing `1` to the sequence, instead of retrieving the prefix of the sequence.<br></p><p>While that is true, I think the types will usually explain what&#39;s going on—`prefix` takes an `Int` (not an `Element`) and returns a `SubSequence` (not `Void`), and is also `nonmutating`. That seems like enough contextual hints to tell you what&#39;s going on.<br></p><p>&gt; IMO `skip`, as an alternative listed in the proposal, would convey the intention better and clearer, and it has roots in the sequence-like constructs of reactive programming libraries (e.g. RxSwift and ReactiveCocoa).<br></p><p>That&#39;s an interesting and very, very relevant precedent. Thanks for mentioning it!<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Draft] Rationalizing Sequence end-operation names</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 23, 2016 at 08:00:00pm</p></header><div class="content"><p>Most of your proposal look great to me! Comments inline:<br></p><p>&gt; On 23 Jun 2016, at 09:19, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; As previously threatened mentioned, I&#39;ve written a draft proposal to fix a number of naming issues with APIs operating on the beginning and end of Sequences and Collections:<br>&gt; <br>&gt; • Inconsistent use of `prefix`/`suffix` vs. `first`/`last`<br>&gt; • Confusing naming of `drop` methods<br>&gt; • Ambiguous naming of `index(of:/where:)` and `drop(while:)`<br>&gt; • `prefix(upTo:)`, `prefix(through:)`, and `suffix(from:)` shouldn&#39;t be part of this family at all<br>&gt; <br>&gt; To fix this, I propose:<br>&gt; <br>&gt; • Renaming all methods which operate on more than one element at the beginning/end to use &quot;prefix&quot; or &quot;suffix&quot;, not &quot;first&quot; or &quot;last&quot;<br>&gt; • Renaming `index(of:/where:)` to `earliestIndex(…)` and `first(where:)` to `earliest(where:)`<br>&gt; • Renaming the `drop` methods to use `removing`<br></p><p>+! Everything above, I strongly agree with!<br></p><p>&gt; • Redesigning `prefix(upTo:)`, `prefix(through:)` and `suffix(from:)` as subscripts with &quot;partial&quot; ranges, like `people[..&lt;idx]` or perhaps `people[nil..&lt;idx]`.<br></p><p>I’m not a fan of the subscript solutions. They both introduce new types which seems very heavyweight for such a small use case. I’d vote for keeping the current functions.<br></p><p>&gt; Since that last point requires significant redesign, including the introduction of new types, I have also included an alternative design which uses `people[to: idx]` instead.<br>&gt; <br>&gt; This proposal does not seek to add new functionality; it merely renames or (in the case of the &quot;aggressive&quot; subscript option) redesigns existing functionality. I do, however, discuss (without making many judgements about their wisdom) how these changes might affect the naming of functionality we might add in future versions of Swift.<br>&gt; <br>&gt; I would mainly like feedback on the two most open questions left in this proposal:<br>&gt; <br>&gt; • The choice of `removing` to replace `drop`<br></p><p>Yep, heavily agree with you on `removing`.<br></p><p>&gt; • The decision about whether to use `people[..&lt;idx]`, `people[nil..&lt;idx]`, or `people[to: idx]`.<br></p><p>None of the above, as stated previously :)<br></p><p>&gt; But I&#39;d also like comments on the rest of the proposal, and on whether I should split the prefix(upTo:/through:)/suffix(from:) changes into a separate proposal from the rest.<br>&gt; <br>&gt; I suspect this will cause a firestorm of bikeshedding, so please try to keep your suggestions grounded. Don&#39;t just suggest a name; articulate why it&#39;s a better choice than what we already have or what this proposal suggests. Only you can prevent our first *three*-hundred-message bikeshedding thread.<br>&gt; <br>&gt; Thanks for your attention!<br>&gt; <br>&gt; (P.S. The proposal below includes several huge tables which may cause some mail clients to become very pouty and refuse to eat their supper. You may want to read the proposal at &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430 &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430&gt;&gt; instead.)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/d1446854/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Rationalizing Sequence end-operation names</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 28, 2016 at 04:00:00am</p></header><div class="content"><p>Addressing the same issue from several people:<br></p><p>&gt; On Jun 23, 2016, at 11:28 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; I’m not a fan of the subscript solutions. They both introduce new types which seems very heavyweight for such a small use case. I’d vote for keeping the current functions.<br></p><p>&gt; On Jun 23, 2016, at 10:46 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Ditto, not a fan of a subscript solution here. It is true that `suffix(from:)` seems weird at first, but it is literally nonsensical to interpret the single argument any other way, partly because of the mandatory argument label but mostly because a &quot;suffix&quot; that doesn&#39;t go to the end isn&#39;t a suffix.<br></p><p><br>&gt; On Jun 23, 2016, at 1:06 PM, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1, because [separate point snipped] they match the <br>&gt; theme you are proposing, while subscripts do not.<br></p><p>Superficially, `prefix(upTo:)`, `prefix(through:)` and `suffix(from:)` appear to be prefix and suffix operations, but I think that&#39;s actually a poor way to model them.<br></p><p>The problem is most obvious when you look at `suffix(from:)`. Imagine you have a four-element array:<br></p><p>	Elements:	a	b	c	d<br>	Indices:		[0]	[1]	[2]	[3]<br></p><p>`prefix(2)` and `suffix(2)` will select the first and last two elements, respectively.<br></p><p>	Elements:	a	b	c	d<br>	Indices:		[0]	[1]	[2]	[3]<br>	prefix(2)		^^	^^<br>	suffix(2)				^^	^^<br></p><p>And for a four-element array, so will `prefix(upTo:)` and `suffix(from:)`.<br></p><p>	Elements:	a	b	c	d<br>	Indices:		[0]	[1]	[2]	[3]<br>	prefix(2)		^^	^^<br>	  upTo: 2		^^	^^<br>	suffix(2)				^^	^^<br>	  from: 2				^^	^^<br></p><p>However, if you insert an element in the middle of the array, a funny thing happens:<br></p><p>	Elements:	a	b	c	e	d<br>	Indices:		[0]	[1]	[2]	[3]	[4]<br>	prefix(2)		^^	^^<br>	  upTo: 2		^^	^^<br>	suffix(2)					^^	^^<br>	  from: 2				^^	^^	^^<br></p><p>Unlike the other methods, adding additional elements changed the length of `suffix(from:)`&#39;s return value. That indicates to me that it is *not* a suffix operation at all.<br></p><p>Now, the simplest way to resolve this is to say that `suffix(from:)` is actually misnamed; it should be `removingPrefix(upTo:)`. That will work for arrays, but not necessarily for other collections.<br></p><p>For instance, I&#39;ve sketched a LinkedList type here: &lt;https://gist.github.com/brentdax/20fba60dd782045faa1cfefcde298874&gt; The important thing to note about this type is that it uses an opaque index which always points to the same node, even if you insert or remove other nodes. Thus, unlike an array, inserting or removing an element before a particular element doesn&#39;t invalidate its index. (If you&#39;re wondering, the Collection documentation doesn&#39;t seem to imply this is a forbidden design.)<br></p><p>Now let&#39;s build a linked list of four elements. Since this time we have non-integer indices, I&#39;ll call them i0, i1, etc.<br></p><p>	Elements:	a	b	c	d<br>	Indices:		[i0]	[i1]	[i2]	[i3]<br>	prefix(2)		^^	^^<br>	  upTo: i2		^^	^^<br>	suffix(2)				^^	^^<br>	  from: i2				^^	^^<br></p><p>Now what happens if we insert a new element at `j`, a new index between `i0` and `i1`?<br></p><p>	Elements: 	a	e	b	c	d<br>	Indices:		[i0]	[j]	[i1]	[i2]	[i3]<br>	prefix(2)		^^	^^<br>	  upTo: i2		^^	^^	^^<br>	suffix(2)					^^	^^<br>	  from: i2					^^	^^<br></p><p>How about that? We see the same anomalous expansion behavior, but from the start instead of the end of the linked list. We can, of course, expand both of them:<br></p><p>	Elements: 	a	e	b	c	f	d<br>	Indices:		[i0]	[j]	[i1]	[i2]	[k]	[i3]<br>	prefix(2)		^^	^^<br>	  upTo: i2		^^	^^	^^<br>	suffix(2)						^^	^^<br>	  from: i2					^^	^^	^^<br></p><p>This is not behavior you get out of *any* of the other prefix or suffix methods. What *do* you get this behavior from? Range subscripts. `linkedList[i0..&lt;i2]` would behave in exactly the same way this does.<br></p><p>That&#39;s why I say in the proposal that:<br></p><p>&gt; prefix(upTo:), prefix(through:), and suffix(from:) at first appear to belong to the same family as the other prefix and suffix methods, but deeper examination reveals otherwise.<br></p><p><br>These operations behave differently under mutation than the other `prefix` calls, but very similarly to other range operations. Thus, I prefer to think of them as a funny range operation, not a `prefix` or `suffix` operation.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Draft] Rationalizing Sequence end-operation names</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June 28, 2016 at 11:00:00pm</p></header><div class="content"><p>Hi Brent,<br></p><p>Will an IncompleteRange always be able to be translated into the same concrete Range? i.e., the missing bound is just a stand in for startIndex or endIndex right? It seems unfortunate to have this throw away value that is only used as an intermediary. Especially when Collection already has an intermediary in the form of Index.<br></p><p><br>What if instead, you ask a collection for a prefix or suffix range from an index?<br></p><p>c.indexes(preceding: Index, inclusive: Bool)<br>c.indexes(succeeding: Index, inclusive: Bool)<br></p><p>These then return a Range or ClosedRange. This I believe would resolve the ‘suffix’ naming issue you have highlighted here, as instead of asking for a suffix from the *collection*, you are asking the all successors of an *index*.<br></p><p><br>Then subscripts are also added to retrieve slices. The subscripts already infer the use of indexes, so there is no need to add additional words here.<br></p><p>c[preceding: Index, inclusive: Bool]<br>c[succeeding: Index, inclusive: Bool]<br></p><p>This is a variation of your proposed conservative index-based operation.<br></p><p><br>Also, for the removing- base operations:<br></p><p>c[withoutPreceding: Index, inclusive: Bool]<br>c[withoutSucceeding: Index, inclusive: Bool]<br></p><p>c.remove(preceding: Index, inclusive: Bool)<br>c.remove(succeeding: Index, inclusive: Bool)<br></p><p><br>I think the words ‘preceding’ and ‘succeeding’ fit in well with the concept of ‘earliest’ and ‘latest’. Note I originally tried writing without the additional ‘inclusive’ parameter until I realised succeeding would have to be inclusive for the current suffix behaviour. It appears to make the API more complicated, but it may help to be more explicit wrt index inclusiveness that simple prefix and suffix methods ignore, and also the use of indexes instead of distances (or perhaps iteration counts?).<br></p><p><br>Hope some of this is useful! (I might be completely missing the mark)<br></p><p>Patrick<br></p><p><br>&gt; On 28 Jun 2016, at 9:46 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Addressing the same issue from several people:<br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 11:28 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m not a fan of the subscript solutions. They both introduce new types which seems very heavyweight for such a small use case. I’d vote for keeping the current functions.<br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 10:46 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Ditto, not a fan of a subscript solution here. It is true that `suffix(from:)` seems weird at first, but it is literally nonsensical to interpret the single argument any other way, partly because of the mandatory argument label but mostly because a &quot;suffix&quot; that doesn&#39;t go to the end isn&#39;t a suffix.<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 1:06 PM, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1, because [separate point snipped] they match the <br>&gt;&gt; theme you are proposing, while subscripts do not.<br>&gt; <br>&gt; Superficially, `prefix(upTo:)`, `prefix(through:)` and `suffix(from:)` appear to be prefix and suffix operations, but I think that&#39;s actually a poor way to model them.<br>&gt; <br>&gt; The problem is most obvious when you look at `suffix(from:)`. Imagine you have a four-element array:<br>&gt; <br>&gt; 	Elements:	a	b	c	d<br>&gt; 	Indices:		[0]	[1]	[2]	[3]<br>&gt; <br>&gt; `prefix(2)` and `suffix(2)` will select the first and last two elements, respectively.<br>&gt; <br>&gt; 	Elements:	a	b	c	d<br>&gt; 	Indices:		[0]	[1]	[2]	[3]<br>&gt; 	prefix(2)		^^	^^<br>&gt; 	suffix(2)				^^	^^<br>&gt; <br>&gt; And for a four-element array, so will `prefix(upTo:)` and `suffix(from:)`.<br>&gt; <br>&gt; 	Elements:	a	b	c	d<br>&gt; 	Indices:		[0]	[1]	[2]	[3]<br>&gt; 	prefix(2)		^^	^^<br>&gt; 	  upTo: 2		^^	^^<br>&gt; 	suffix(2)				^^	^^<br>&gt; 	  from: 2				^^	^^<br>&gt; <br>&gt; However, if you insert an element in the middle of the array, a funny thing happens:<br>&gt; <br>&gt; 	Elements:	a	b	c	e	d<br>&gt; 	Indices:		[0]	[1]	[2]	[3]	[4]<br>&gt; 	prefix(2)		^^	^^<br>&gt; 	  upTo: 2		^^	^^<br>&gt; 	suffix(2)					^^	^^<br>&gt; 	  from: 2				^^	^^	^^<br>&gt; <br>&gt; Unlike the other methods, adding additional elements changed the length of `suffix(from:)`&#39;s return value. That indicates to me that it is *not* a suffix operation at all.<br>&gt; <br>&gt; Now, the simplest way to resolve this is to say that `suffix(from:)` is actually misnamed; it should be `removingPrefix(upTo:)`. That will work for arrays, but not necessarily for other collections.<br>&gt; <br>&gt; For instance, I&#39;ve sketched a LinkedList type here: &lt;https://gist.github.com/brentdax/20fba60dd782045faa1cfefcde298874&gt; The important thing to note about this type is that it uses an opaque index which always points to the same node, even if you insert or remove other nodes. Thus, unlike an array, inserting or removing an element before a particular element doesn&#39;t invalidate its index. (If you&#39;re wondering, the Collection documentation doesn&#39;t seem to imply this is a forbidden design.)<br>&gt; <br>&gt; Now let&#39;s build a linked list of four elements. Since this time we have non-integer indices, I&#39;ll call them i0, i1, etc.<br>&gt; <br>&gt; 	Elements:	a	b	c	d<br>&gt; 	Indices:		[i0]	[i1]	[i2]	[i3]<br>&gt; 	prefix(2)		^^	^^<br>&gt; 	  upTo: i2		^^	^^<br>&gt; 	suffix(2)				^^	^^<br>&gt; 	  from: i2				^^	^^<br>&gt; <br>&gt; Now what happens if we insert a new element at `j`, a new index between `i0` and `i1`?<br>&gt; <br>&gt; 	Elements: 	a	e	b	c	d<br>&gt; 	Indices:		[i0]	[j]	[i1]	[i2]	[i3]<br>&gt; 	prefix(2)		^^	^^<br>&gt; 	  upTo: i2		^^	^^	^^<br>&gt; 	suffix(2)					^^	^^<br>&gt; 	  from: i2					^^	^^<br>&gt; <br>&gt; How about that? We see the same anomalous expansion behavior, but from the start instead of the end of the linked list. We can, of course, expand both of them:<br>&gt; <br>&gt; 	Elements: 	a	e	b	c	f	d<br>&gt; 	Indices:		[i0]	[j]	[i1]	[i2]	[k]	[i3]<br>&gt; 	prefix(2)		^^	^^<br>&gt; 	  upTo: i2		^^	^^	^^<br>&gt; 	suffix(2)						^^	^^<br>&gt; 	  from: i2					^^	^^	^^<br>&gt; <br>&gt; This is not behavior you get out of *any* of the other prefix or suffix methods. What *do* you get this behavior from? Range subscripts. `linkedList[i0..&lt;i2]` would behave in exactly the same way this does.<br>&gt; <br>&gt; That&#39;s why I say in the proposal that:<br>&gt; <br>&gt;&gt; prefix(upTo:), prefix(through:), and suffix(from:) at first appear to belong to the same family as the other prefix and suffix methods, but deeper examination reveals otherwise.<br>&gt; <br>&gt; <br>&gt; These operations behave differently under mutation than the other `prefix` calls, but very similarly to other range operations. Thus, I prefer to think of them as a funny range operation, not a `prefix` or `suffix` operation.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Draft] Rationalizing Sequence end-operation names</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 28, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 28 Jun 2016, at 13:46, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; Unlike the other methods, adding additional elements changed the length of `suffix(from:)`&#39;s return value. That indicates to me that it is *not* a suffix operation at all.<br></p><p>I don&#39;t agree with your reasoning here. It *is* an operation that returns the suffix (the end of the sequence) but starting from an index. The fact that indices index from the start of the array and that the function will return an array of a different length depending on the argument does not make the result of the operation less of a suffix. It is still returning the end of the array.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft] Rationalizing Sequence end-operation names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 28, 2016 at 01:00:00pm</p></header><div class="content"><p>On Tue, Jun 28, 2016 at 1:25 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; &gt; On 28 Jun 2016, at 13:46, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Unlike the other methods, adding additional elements changed the length<br>&gt; of `suffix(from:)`&#39;s return value. That indicates to me that it is *not* a<br>&gt; suffix operation at all.<br>&gt;<br>&gt; I don&#39;t agree with your reasoning here. It *is* an operation that returns<br>&gt; the suffix (the end of the sequence) but starting from an index. The fact<br>&gt; that indices index from the start of the array and that the function will<br>&gt; return an array of a different length depending on the argument does not<br>&gt; make the result of the operation less of a suffix. It is still returning<br>&gt; the end of the array.<br>&gt;<br></p><p>I was in the midst of writing a reply along the same lines, so I figured<br>I&#39;d add to David&#39;s reply here. There are two characteristics I would expect<br>from a method named &quot;prefix&quot; or &quot;suffix&quot;.<br></p><p>First, it should return a subsequence containing zero to count elements.<br>(By contrast, something named &quot;first&quot; should return nil or one element, but<br>certainly no more.)<br></p><p>Second, in the case of &quot;prefix&quot;, the first element of the subsequence (if<br>any) should be the first element of the sequence; in the case of &quot;suffix&quot;,<br>the last element of the subsequence (if any) should be the last element of<br>the sequence.<br></p><p>Now, `suffix(from:)` fulfills both of those expectations. Like David, I do<br>not understand how you arrive at the interpretation that a &quot;suffix<br>operation&quot; should be one that returns a fixed number of elements.<br></p><p>Replacing the word &quot;suffix&quot; with square brackets is inferior, IMO, because<br>at the call site the reader cannot immediately tell that the two<br>characteristics I named above would hold. First, depending on what is<br>inside the square brackets, a subscript could return a subsequence or it<br>could return a single element. Second, depending on what is inside the<br>square brackets, a subsequence could start or end anywhere. By contrast,<br>the words &quot;prefix&quot; and &quot;suffix&quot; clearly communicate what sort of<br>subsequence you&#39;ll get back without inspection of the argument.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/33bacf45/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Rationalizing Sequence end-operation names</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 28, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; I was in the midst of writing a reply along the same lines, so I figured I&#39;d add to David&#39;s reply here. There are two characteristics I would expect from a method named &quot;prefix&quot; or &quot;suffix&quot;.<br>&gt; <br>&gt; First, it should return a subsequence containing zero to count elements. (By contrast, something named &quot;first&quot; should return nil or one element, but certainly no more.)<br>&gt; <br>&gt; Second, in the case of &quot;prefix&quot;, the first element of the subsequence (if any) should be the first element of the sequence; in the case of &quot;suffix&quot;, the last element of the subsequence (if any) should be the last element of the sequence.<br></p><p>I would phrase these things slightly differently. In my thinking, a method with `prefix` or `suffix` in its name:<br></p><p>	1. Operates on a subsequence at the beginning/end of the sequence,<br></p><p>	2. Measured *relative* to the beginning/end.<br></p><p>An index-based operation doesn&#39;t fit this definition because an index is not *relative* to anything—it&#39;s an *absolute* position within the sequence.<br></p><p>Put another way, in my view, &quot;prefix&quot; and &quot;suffix&quot; don&#39;t merely mean &quot;anchored at the beginning/end&quot;. A prefix or suffix is attached to a &quot;middle&quot;. There is no middle in the index-based operations.<br></p><p>It is, of course, very possible to use methods to express what the index-based operations do:<br></p><p>	friends.upTo(i)<br>	friends.through(i)<br>	friends.from(i)<br></p><p>But at this point, we&#39;ve basically arrived at `friends[to: i]` etc.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Draft] Rationalizing Sequence end-operation names</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 29, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On 29 Jun 2016, at 00:40, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; 	2. Measured *relative* to the beginning/end.<br></p><p>This is the crux of our disagreement :) I don’t agree with point number 2.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/398ecf96/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft] Rationalizing Sequence end-operation names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 28, 2016 at 11:00:00pm</p></header><div class="content"><p>I understand that that&#39;s your thinking. I just don&#39;t understand how you<br>arrived at your rule (2). It&#39;s not in the dictionary definition of the<br>words prefix and suffix. Nor do I find any documentation of such a rule in<br>Swift. Nor do I think you&#39;ve shown that such a rule is necessary for<br>clearing up some actual confusion. Nor do I see that applying the rule and<br>using subscripts yields a superior solution to what we currently have.<br>On Tue, Jun 28, 2016 at 5:40 PM Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; I was in the midst of writing a reply along the same lines, so I figured<br>&gt; I&#39;d add to David&#39;s reply here. There are two characteristics I would expect<br>&gt; from a method named &quot;prefix&quot; or &quot;suffix&quot;.<br>&gt; &gt;<br>&gt; &gt; First, it should return a subsequence containing zero to count elements.<br>&gt; (By contrast, something named &quot;first&quot; should return nil or one element, but<br>&gt; certainly no more.)<br>&gt; &gt;<br>&gt; &gt; Second, in the case of &quot;prefix&quot;, the first element of the subsequence<br>&gt; (if any) should be the first element of the sequence; in the case of<br>&gt; &quot;suffix&quot;, the last element of the subsequence (if any) should be the last<br>&gt; element of the sequence.<br>&gt;<br>&gt; I would phrase these things slightly differently. In my thinking, a method<br>&gt; with `prefix` or `suffix` in its name:<br>&gt;<br>&gt;         1. Operates on a subsequence at the beginning/end of the sequence,<br>&gt;<br>&gt;         2. Measured *relative* to the beginning/end.<br>&gt;<br>&gt; An index-based operation doesn&#39;t fit this definition because an index is<br>&gt; not *relative* to anything—it&#39;s an *absolute* position within the sequence.<br>&gt;<br>&gt; Put another way, in my view, &quot;prefix&quot; and &quot;suffix&quot; don&#39;t merely mean<br>&gt; &quot;anchored at the beginning/end&quot;. A prefix or suffix is attached to a<br>&gt; &quot;middle&quot;. There is no middle in the index-based operations.<br>&gt;<br>&gt; It is, of course, very possible to use methods to express what the<br>&gt; index-based operations do:<br>&gt;<br>&gt;         friends.upTo(i)<br>&gt;         friends.through(i)<br>&gt;         friends.from(i)<br>&gt;<br>&gt; But at this point, we&#39;ve basically arrived at `friends[to: i]` etc.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/49c4468b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Rationalizing Sequence end-operation names</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 29, 2016 at 09:00:00am</p></header><div class="content"><p>@brent: i noticed that you have the habit of redacting out the name of the people from your replies. Considering you seem to be the only one, and how much clarity it removes from the dialog, do you think you could perhaps reconsider?<br>Regards<br>LM<br>(From mobile)<br></p><p>On Jun 29, 2016, at 12:40 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; I was in the midst of writing a reply along the same lines, so I figured I&#39;d add to David&#39;s reply here. There are two characteristics I would expect from a method named &quot;prefix&quot; or &quot;suffix&quot;.<br>&gt;&gt; <br>&gt;&gt; First, it should return a subsequence containing zero to count elements. (By contrast, something named &quot;first&quot; should return nil or one element, but certainly no more.)<br>&gt;&gt; <br>&gt;&gt; Second, in the case of &quot;prefix&quot;, the first element of the subsequence (if any) should be the first element of the sequence; in the case of &quot;suffix&quot;, the last element of the subsequence (if any) should be the last element of the sequence.<br>&gt; <br>&gt; I would phrase these things slightly differently. In my thinking, a method with `prefix` or `suffix` in its name:<br>&gt; <br>&gt;    1. Operates on a subsequence at the beginning/end of the sequence,<br>&gt; <br>&gt;    2. Measured *relative* to the beginning/end.<br>&gt; <br>&gt; An index-based operation doesn&#39;t fit this definition because an index is not *relative* to anything—it&#39;s an *absolute* position within the sequence.<br>&gt; <br>&gt; Put another way, in my view, &quot;prefix&quot; and &quot;suffix&quot; don&#39;t merely mean &quot;anchored at the beginning/end&quot;. A prefix or suffix is attached to a &quot;middle&quot;. There is no middle in the index-based operations.<br>&gt; <br>&gt; It is, of course, very possible to use methods to express what the index-based operations do:<br>&gt; <br>&gt;    friends.upTo(i)<br>&gt;    friends.through(i)<br>&gt;    friends.from(i)<br>&gt; <br>&gt; But at this point, we&#39;ve basically arrived at `friends[to: i]` etc.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Draft] Rationalizing Sequence end-operation names</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 23, 2016 at 08:00:00pm</p></header><div class="content"><p>Most of your proposal look great to me! Comments inline:<br></p><p>&gt; On 23 Jun 2016, at 09:19, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As previously threatened mentioned, I&#39;ve written a draft proposal to fix a number of naming issues with APIs operating on the beginning and end of Sequences and Collections:<br>&gt; <br>&gt; • Inconsistent use of `prefix`/`suffix` vs. `first`/`last`<br>&gt; • Confusing naming of `drop` methods<br>&gt; • Ambiguous naming of `index(of:/where:)` and `drop(while:)`<br>&gt; • `prefix(upTo:)`, `prefix(through:)`, and `suffix(from:)` shouldn&#39;t be part of this family at all<br>&gt; <br>&gt; To fix this, I propose:<br>&gt; <br>&gt; • Renaming all methods which operate on more than one element at the beginning/end to use &quot;prefix&quot; or &quot;suffix&quot;, not &quot;first&quot; or &quot;last&quot;<br>&gt; • Renaming `index(of:/where:)` to `earliestIndex(…)` and `first(where:)` to `earliest(where:)`<br>&gt; • Renaming the `drop` methods to use `removing`<br></p><p>+! Everything above, I strongly agree with!<br></p><p>&gt; • Redesigning `prefix(upTo:)`, `prefix(through:)` and `suffix(from:)` as subscripts with &quot;partial&quot; ranges, like `people[..&lt;idx]` or perhaps `people[nil..&lt;idx]`.<br></p><p>I’m not a fan of the subscript solutions. They both introduce new types which seems very heavyweight for such a small use case. I’d vote for keeping the current functions.<br></p><p>&gt; Since that last point requires significant redesign, including the introduction of new types, I have also included an alternative design which uses `people[to: idx]` instead.<br>&gt; <br>&gt; This proposal does not seek to add new functionality; it merely renames or (in the case of the &quot;aggressive&quot; subscript option) redesigns existing functionality. I do, however, discuss (without making many judgements about their wisdom) how these changes might affect the naming of functionality we might add in future versions of Swift.<br>&gt; <br>&gt; I would mainly like feedback on the two most open questions left in this proposal:<br>&gt; <br>&gt; • The choice of `removing` to replace `drop`<br></p><p>Yep, heavily agree with you on `removing`.<br></p><p>&gt; • The decision about whether to use `people[..&lt;idx]`, `people[nil..&lt;idx]`, or `people[to: idx]`.<br></p><p>None of the above, as stated previously :)<br></p><p>&gt; But I&#39;d also like comments on the rest of the proposal, and on whether I should split the prefix(upTo:/through:)/suffix(from:) changes into a separate proposal from the rest.<br>&gt; <br>&gt; I suspect this will cause a firestorm of bikeshedding, so please try to keep your suggestions grounded. Don&#39;t just suggest a name; articulate why it&#39;s a better choice than what we already have or what this proposal suggests. Only you can prevent our first *three*-hundred-message bikeshedding thread.<br>&gt; <br>&gt; Thanks for your attention!<br>&gt; <br>&gt; (P.S. The proposal below includes several huge tables which may cause some mail clients to become very pouty and refuse to eat their supper. You may want to read the proposal at &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430 &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430&gt;&gt; instead.)<br>&gt; <br>&gt; Rationalizing Sequence end-operation names<br>&gt; Proposal: SE-NNNN &lt;https://gist.github.com/brentdax/NNNN-sequence-end-op.md&gt;<br>&gt; Author: Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>&gt; Status: Draft<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#introduction&gt;Introduction<br>&gt; <br>&gt; Sequence and Collection offer many special operations which access or manipulate its first or last elements, but they are plagued by inconsistent naming which can make it difficult to find inverses or remember what the standard library offers. I propose that we standardize these names so they follow consistent, predictable patterns.<br>&gt; <br>&gt; Swift-evolution thread: Pending &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#scope&gt;Scope<br>&gt; <br>&gt; This proposal is not intended to add or remove any functionality; it merely renames and redesigns existing operations. Adding new operations is out of scope for this proposal unless it&#39;s incidental to the new designs.<br>&gt; <br>&gt; Nonetheless, I do want the new designs to support adding more operations in the future. The names I&#39;ve chosen are informed by some of the speculative APIs discussed in &quot;Future directions&quot;, although I think they are perfectly sensible names even if nothing else changes.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#motivation&gt;Motivation<br>&gt; <br>&gt; The Sequence and Collection protocols offer a wide variety of APIs which are defined to operate on, or from, one end of the sequence:<br>&gt; <br>&gt; Operand	Get	Index	Exclude	Remove (1)	Pop (1)	Equate (2)<br>&gt; Fixed Size						<br>&gt; First 1	C.first	-	S.dropFirst()	C.removeFirst()	C.popFirst()	-<br>&gt; Last 1	C.last	-	S.dropLast()	C.removeLast()	C.popLast()	-<br>&gt; First (n: Int)	S.prefix(_:)	-	S.dropFirst(_:)	C.removeFirst(_:)	-	S.starts(with:)<br>&gt;   ...with closure	S.prefix(while:)	-	S.drop(while:)	-	-	S.starts(with:isEquivalent:)<br>&gt; Last (n: Int)	S.suffix(_:)	-	S.dropLast(_:)	C.removeLast(_:)	-	-<br>&gt;   ...with closure	-	-	-	-	-	-<br>&gt; Searching From End						<br>&gt; First matching element	-	C.index(of:)	-	-	-	-<br>&gt;   ...with closure	S.first(where:)	C.index(where:)	-	-	-	-<br>&gt; Last matching element	-	-	-	-	-	-<br>&gt;   ...with closure	-	-	-	-	-	-<br>&gt; Based on Index						<br>&gt; startIndex ..&lt; (i: Index)	C.prefix(upTo:)	-	-	-	-	-<br>&gt; startIndex ... (i: Index)	C.prefix(through:)	-	-	-	-	-<br>&gt; (i: Index) ..&lt; endIndex	C.suffix(from:)	-	-	-	-	-<br>&gt; I have included several blank rows for operands which fit the APIs&#39; patterns, even if they don&#39;t happen to have any operations currently.<br>&gt; <br>&gt; Type abbreviations:<br>&gt; <br>&gt; S = Sequence<br>&gt; C = Collection (or a sub-protocol like BidirectionalCollection)<br>&gt; Notes:<br>&gt; <br>&gt; remove and pop both mutate the array to delete the indicated element(s), but remove assumes as a precondition that the indicated elements exist, while pop checks whether or not they exist.<br>&gt; <br>&gt; String and NSString have bespoke versions of first n and last n Equate operations, in the form of their hasPrefix and hasSuffix methods.<br>&gt; <br>&gt; Leaving aside the question of whether any gaps in these tables ought to be filled, I see a number of issues with existing terminology.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#inconsistent-use-of-prefix-and-suffix&gt;Inconsistent use of prefix and suffix<br>&gt; <br>&gt; Some APIs which operate on a variable number of elements anchored at one end or the other use the terms prefix or suffix:<br>&gt; <br>&gt; Sequence.prefix(_:) and Sequence.suffix(_:)<br>&gt; Sequence.prefix(while:)<br>&gt; String.hasPrefix(_:) and String.hasSuffix(_:)<br>&gt; Others, however, use first or last:<br>&gt; <br>&gt; Sequence.dropFirst(_:) and Sequence.dropLast(_:)<br>&gt; Sequence.removeFirst(_:) and Sequence.removeLast(_:)<br>&gt; Still others use neither:<br>&gt; <br>&gt; Sequence.starts(with:)<br>&gt; Sequence.drop(while:)<br>&gt; These methods are all closely related, but because of this inconsistent terminology, they fail to form predictable method families.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#first-has-multiple-meanings&gt;first has multiple meanings<br>&gt; <br>&gt; The word first can mean three different things in these APIs:<br>&gt; <br>&gt; Just the very first element of the sequence.<br>&gt; <br>&gt; A subsequence of elements anchored at the beginning of the sequence, as mentioned in the last point.<br>&gt; <br>&gt; The first element encountered in the sequence which matches a given criterion when walking from the beginning of the sequence towards the end.<br>&gt; <br>&gt; It would be nice to have more clarity here.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#drop-is-misleading-and-scary&gt;drop is misleading and scary<br>&gt; <br>&gt; In a Swift context, I believe the drop methods are actively confusing:<br>&gt; <br>&gt; drop does not have the -ing or -ed suffix normally used for a nonmutating method.<br>&gt; <br>&gt; drop has strong associations with destructive operations; it&#39;s the term used, for instance, for deleting whole tables in SQL. Even dropping would probably sound more like a mutating operation than alternatives.<br>&gt; <br>&gt; As previously mentioned, the use of dropFirst and dropLast for single-drop operations and multiple-drop operations breaks up method families.<br>&gt; <br>&gt; drop, dropFirst, and dropLast are terms of art, so we allow them a certain amount of leeway. However, I believe the drop functions go well beyond what we should permit. They are relatively uncommon operations, associated primarily with functional languages rather than mainstream object-oriented or imperative languages, and their violation of the normal Swift naming guidelines is especially misleading.<br>&gt; <br>&gt; The term-of-art exception is not a suicide pact; it is meant to aid understanding by importing common terminology, not bind us to follow every decision made by any language that came before us. In this case, I think we should ignore precedent and forge our own path.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#unstated-direction-of-operation&gt;Unstated direction of operation<br>&gt; <br>&gt; Several APIs could theoretically be implemented by working from either end of the sequence, and would return different results depending on the direction, but do not indicate the direction in their names:<br>&gt; <br>&gt; Sequence.drop(while:)<br>&gt; Collection.index(of:)<br>&gt; Adding a direction to these APIs would make their behavior clearer and permit us to offer opposite-end equivalents in the future. (Unmerged swift-evolution pull request 329 &lt;https://github.com/apple/swift-evolution/pull/329&gt; would add lastIndex methods.)<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#the-index-base-name-has-been-polluted&gt;The index(...) base name has been polluted<br>&gt; <br>&gt; Swift 3&#39;s new collection model placed a number of low-level index manipulating operations on the base method name index. These now share that name with index(of:) and index(where:), which are much higher-level operations. This may be confusing for users looking for high-level operations; the only real relationship between the two sets of operations is that they both return an index.<br>&gt; <br>&gt; It would be nice to separate these two groups of methods into different families.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#operations-taking-an-index-are-really-slicing&gt;Operations taking an index are really slicing<br>&gt; <br>&gt; prefix(upTo:), prefix(through:), and suffix(from:) at first appear to belong to the same family as the other prefix and suffix methods, but deeper examination reveals otherwise. They are the only operations which take indices, and they don&#39;t cleanly extend to the other operations which belong to these families. (For instance, it would not make sense to add a dropPrefix(upTo:) method; it would be equivalent to suffix(from:).)<br>&gt; <br>&gt; Also, on Int-indexed collections like Array, prefix(_:) and prefix(upTo:) are identical, but there is little relationship between suffix(_:) and suffix(from:), which is confusing.<br>&gt; <br>&gt; suffix(from:) is a particularly severe source of confusion. The other suffix APIs all have parameters relative to the endof the collection, but suffix(from:)&#39;s index is still relative to the beginning of the array. This is obvious if you think deeply about the meaning of an index, but we don&#39;t really want to force our users to stare at a strange API until they have an epiphany.<br>&gt; <br>&gt; I believe these operations have much more in common with slicing a collection using a range, and that reimagining them as slicing APIs will be more fruitful.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#why-does-it-matter&gt;Why does it matter?<br>&gt; <br>&gt; Many of these APIs are only occasionally necessary, so it&#39;s important that they be easy to find when needed and easy to understand when read. If you know that prefix(10) will get the first ten elements but don&#39;t know what its inverse is, you will probably not guess that it&#39;s dropFirst(10). The confusing, conflicting names in these APIs are a barrier to users adopting them where appropriate.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; We sever the index-taking APIs from the others, forming two separate families, which I will call the &quot;Sequence-end operations&quot; and the &quot;index-based operations&quot;. We then consider and redesign them along separate lines.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#sequence-end-operations&gt;Sequence-end operations<br>&gt; <br>&gt; Each of these APIs should be renamed to use a directional word based on its row in the table:<br>&gt; <br>&gt; Operand	Directional word<br>&gt; Fixed Size	<br>&gt; First 1	first<br>&gt; Last 1	last<br>&gt; First (n: Int)	prefix<br>&gt;   ...with closure	prefix<br>&gt; Last (n: Int)	suffix<br>&gt;   ...with closure	suffix<br>&gt; Searching From End	<br>&gt; First matching element	earliest<br>&gt;   ...with closure	earliest<br>&gt; Last matching element	latest<br>&gt;   ...with closure	latest<br>&gt; To accomplish this, starts(with:) should be renamed to hasPrefix(_:), and other APIs should have directional words replaced or added as appropriate.<br>&gt; <br>&gt; Additionally, the word drop in the &quot;Exclude&quot; APIs should be replaced with removing. These operations omit the same elements which the remove operations delete, so even though the types are not always the same (removing returns SubSequence, not Self), I think they are similar enough to deserve to be treated as nonmutating forms.<br>&gt; <br>&gt; These changes yield (altered names bold):<br>&gt; <br>&gt; Operand	Get	Index	Exclude	Remove (1)	Pop (1)	Equate (2)<br>&gt; Fixed Size						<br>&gt; First 1	C.first	-	S.removingFirst()	C.removeFirst()	C.popFirst()	-<br>&gt; Last 1	C.last	-	S.removingLast()	C.removeLast()	C.popLast()	-<br>&gt; First (n: Int)	S.prefix(_:)	-	S.removingPrefix(_:)	C.removePrefix(_:)	-	S.hasPrefix(_:)<br>&gt;   ...with closure	S.prefix(while:)	-	S.removingPrefix(while:)	-	-	S.hasPrefix(_:isEquivalent:)<br>&gt; Last (n: Int)	S.suffix(_:)	-	S.removingSuffix(_:)	C.removeSuffix(_:)	-	-<br>&gt;   ...with closure	-	-	-	-	-	-<br>&gt; Searching From End						<br>&gt; First matching element	-	C.earliestIndex(of:)	-	-	-	-<br>&gt;   ...with closure	S.earliest(where:)	C.earliestIndex(where:)	-	-	-	-<br>&gt; Last matching element	-	-	-	-	-	-<br>&gt;   ...with closure	-	-	-	-	-	-<br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#alternative-to-removing&gt;Alternative to removing<br>&gt; <br>&gt; If the type differences are seen as disqualifying removing as a replacement for drop, I suggest using skipping instead.<br>&gt; <br>&gt; There are, of course, many possible alternatives to skipping; this is almost a perfect subject for bikeshedding. I&#39;ve chosen skipping because:<br>&gt; <br>&gt; It is not an uncommon word, unlike (say) omitting. This means non-native English speakers and schoolchildren are more likely to recognize it.<br>&gt; <br>&gt; It is an -ing verb, unlike (say) without. This makes it fit common Swift naming patterns more closely.<br>&gt; <br>&gt; It does not imply danger, unlike (say) dropping, nor some sort of ongoing process, unlike (say) ignoring. This makes its behavior more obvious.<br>&gt; <br>&gt; If you want to suggest an alternative on swift-evolution, please do not merely mention a synonym; rather, explain why it is an improvement on either these axes or other ones. (I would be particularly interested in names other than removing which draw an analogy to something else in Swift.)<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#index-based-operations&gt;Index-based operations<br>&gt; <br>&gt; Because these APIs look up elements based on their indices, I believe these operations should be exposed as subscripts, and ideally should look like other slicing operations.<br>&gt; <br>&gt; My primary design is rather ambitious, introducing two new types and either two operator overloads, or four unary forms of existing binary operators. I therefore present a more conservative alternative as well.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#preferred-ambitious-option&gt;Preferred (ambitious) option<br>&gt; <br>&gt; let head = people[..&lt;i]<br>&gt; let tail = people[i..&lt;]<br>&gt; let rearrangedPeople = tail + head<br>&gt; Or this small variation:<br>&gt; <br>&gt; let head = people[nil ..&lt; i]<br>&gt; let tail = people[i ..&lt; nil]<br>&gt; let rearrangedPeople = tail + head<br>&gt; The operators would construct instances of a new pair of types, IncompleteRange (for ..&lt;) and IncompleteClosedRange (for ...), and Collection would include new subscripts taking these types. These would probably have default implementations which constructed an equivalent Range or ClosedRange using startIndex and endIndex, then passed the resulting range through to the existing subscripts.<br>&gt; <br>&gt; I prefer this option because it offers an elegant syntax immediately recognizable as a form of slicing, and provides a straightforward way for a future version of Swift to extend other Range-handling Collection operations, like replaceSubrange(_:with:) and removeSubrange(_:), to handle subranges bound by the ends of the Collection.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#alternative-conservative-option&gt;Alternative (conservative) option<br>&gt; <br>&gt; let head = people[to: i]<br>&gt; let tail = people[from: i]<br>&gt; let rearrangedPeople = tail + head<br>&gt; This would be a simple changing of the methods into subscripts; no additional types or operators would be needed. I have changed upTo: into just to: to match the pattern set by stride(from:to:by:).<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#detailed-design&gt;Detailed design<br>&gt; <br>&gt; Draft note: This section is a mere sketch and should probably be expanded before submitting for a pull request.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#sequence-end-operations-1&gt;Sequence-end operations<br>&gt; <br>&gt; The following methods should be renamed as follows wherever they appear in the standard library. These are simple textual substitutions; we propose no changes whatsoever to types, parameter interpretations, or other semantics.<br>&gt; <br>&gt; Old method	New method<br>&gt; dropFirst() -&gt; SubSequence	removingFirst() -&gt; SubSequence<br>&gt; dropLast() -&gt; SubSequence	removingLast() -&gt; SubSequence<br>&gt; dropFirst(_ n: Int) -&gt; SubSequence	removingPrefix(_ n: Int) -&gt; SubSequence<br>&gt; drop(@noescape while predicate: (Iterator.Element) throws -&gt; Bool) rethrows -&gt; SubSequence	removingPrefix(@noescape while predicate: (Iterator.Element) throws -&gt; Bool) rethrows -&gt; SubSequence<br>&gt; dropLast(_ n: Int) -&gt; SubSequence	removingSuffix(_ n: Int) -&gt; SubSequence<br>&gt; removeFirst(_ n: Int)	removePrefix(_ n: Int)<br>&gt; removeLast(_ n: Int)	removeSuffix(_ n: Int)<br>&gt; starts&lt;PossiblePrefix: Sequence&gt;(with possiblePrefix: PossiblePrefix) -&gt; Bool where ...	hasPrefix&lt;PossiblePrefix: Sequence&gt;(_ possiblePrefix: PossiblePrefix) -&gt; Bool where ...<br>&gt; starts&lt;PossiblePrefix : Sequence&gt;(with possiblePrefix: PossiblePrefix, isEquivalent: @noescape (Iterator.Element, Iterator.Element) throws -&gt; Bool) rethrows -&gt; Bool where ...	hasPrefix&lt;PossiblePrefix : Sequence&gt;(_ possiblePrefix: PossiblePrefix, isEquivalent: @noescape (Iterator.Element, Iterator.Element) throws -&gt; Bool) rethrows -&gt; Bool where ...<br>&gt; first(where predicate: @noescape (Iterator.Element) throws -&gt; Bool) rethrows -&gt; Iterator.Element?	earliest(where predicate: @noescape (Iterator.Element) throws -&gt; Bool) rethrows -&gt; Iterator.Element?<br>&gt; index(of element: Iterator.Element) -&gt; Index?	earliestIndex(of element: Iterator.Element) -&gt; Index?<br>&gt; index(where predicate: @noescape (Iterator.Element) throws -&gt; Bool) rethrows -&gt; Index?	earliestIndex(where predicate: @noescape (Iterator.Element) throws -&gt; Bool) rethrows -&gt; Index?<br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#index-based-operations-1&gt;Index-based operations<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#preferred-ambitious-option-1&gt;Preferred (ambitious) option<br>&gt; <br>&gt; Implementation would be roughly as follows:<br>&gt; <br>&gt; Add a pair of new types, IncompleteRange and IncompleteClosedRange, with definitions like:<br>&gt; <br>&gt; struct IncompleteRange&lt;Bound: Comparable&gt; {<br>&gt;    var lowerBound: Bound?<br>&gt;    var upperBound: Bound?<br>&gt; <br>&gt;    func completed(with bounds: Range&lt;Bound&gt;) -&gt; Range&lt;Bound&gt; {<br>&gt;        return (lowerBound ?? bounds.lowerBound) ..&lt; (upperBound ?? bounds.upperBound)<br>&gt;    }<br>&gt; }<br>&gt; // And likewise for `IncompleteClosedRange`<br>&gt; Either add prefix and postfix ..&lt; and ... operators, or overload the existing infix ..&lt; and ... operators, to construct an IncompleteRange or IncompleteClosedRange. For the prefix/postfix operators, this would look like:<br>&gt; <br>&gt; postfix func ..&lt; &lt;Bound: Comparable&gt;(lowerBound: Bound) -&gt; IncompleteRange&lt;Bound&gt; {<br>&gt;    return IncompleteRange(lowerBound: lowerBound, upperBound: nil)<br>&gt; }<br>&gt; prefix func ..&lt; &lt;Bound: Comparable&gt;(upperBound: Bound) -&gt; IncompleteRange&lt;Bound&gt; {<br>&gt;       return IncompleteRange(lowerBound: nil, upperBound: upperBound)<br>&gt; }<br>&gt; // And likewise for `...` and `IncompleteClosedRange`<br>&gt; Add a pair of IncompleteRange and IncompleteClosedRange subscripts to Collection:<br>&gt; <br>&gt; extension Collection {<br>&gt;    subscript (range: IncompleteRange&lt;Index&gt;) -&gt; SubSequence {<br>&gt;        return self[range.completed(with: startIndex ..&lt; endIndex)]<br>&gt;    }<br>&gt;    // And likewise for `IncompleteClosedRange`<br>&gt; }<br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#alternative-conservative-option-1&gt;Alternative (conservative) option<br>&gt; <br>&gt; The three methods below will be replaced with equivalent subscripts in all types conforming to Collection or a sub-protocol:<br>&gt; <br>&gt; Old method	New subscript<br>&gt; prefix(upTo end: Index) -&gt; SubSequence	subscript(to end: Index) -&gt; SubSequence<br>&gt; prefix(through position: Index) -&gt; SubSequence	subscript(through position: Index) -&gt; SubSequence<br>&gt; func suffix(from start: Index) -&gt; SubSequence	subscript(from start: Index) -&gt; SubSequence<br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; Obviously, any code using these APIs under their old names or designs would have to be transitioned to the new names and designs.<br>&gt; <br>&gt; The sequence-end operations would be by far the simplest to handle; these are simple renamings and could be handed by @available(renamed:) and migration support. The only complication is that some overloads have transitioned to a new base name, while others have stayed with the old one, but I suspect the migrator is up to this task.<br>&gt; <br>&gt; The preferred option for index-based operations is more difficult to migrate. The patterns would be roughly:<br>&gt; <br>&gt; collection.prefix(upTo: i)    =&gt; collection[..&lt;i] or collection[nil ..&lt; i]<br>&gt; collection.prefix(through: i) =&gt; collection[...i] or collection[nil ... i]<br>&gt; collection.suffix(from: i)    =&gt; collection[i..&lt;] or collection[i ..&lt; nil]<br>&gt; A custom fix-it would be ideal, but is probably not absolutely necessary here; an @available(message:) would do in a pinch. Presumably this would have to be a special case in the migrator as well.<br>&gt; <br>&gt; The alternative option for index-based operations would be simpler to fix-it and migrate—we need merely change references from the method to the subscript with the same (or similar, for upTo) parameter labels. I&#39;m not sure if @available(renamed:) supports changing a method to a subscript.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; I considered many alternatives to removing or skipping, some of which are discussed in the section about them.<br>&gt; <br>&gt; Rather than using earliest and latest, I considered using first and last for the &quot;First matching&quot; and &quot;Last matching&quot; categories. However, I didn&#39;t like the thought of overloading a property with a function, and I felt like earliest and latest actually have different semantics (searching for the match closest to a particular end) than first and last (manipulating the element at that end).<br>&gt; <br>&gt; I considered using first and last as the basis for both single-element and multiple-element operations (such that prefix(3) would become first(3), etc.), but:<br>&gt; <br>&gt; These seemed like distinct functionalities, particularly since their types are different.<br>&gt; <br>&gt; I&#39;m not comfortable with heavily overloading a property with a bunch of methods, and didn&#39;t want to make firstand last into methods.<br>&gt; <br>&gt; Most APIs work fine, but hasFirst(_:) is atrocious, and I see no better alternative which includes the word first.<br>&gt; <br>&gt; I considered moving first and last to Sequence and possibly making them methods, but my understanding is that the core team has considered and rejected this approach in the past.<br>&gt; <br>&gt; I considered moving removingFirst and removingLast to Collection and making them properties, to match firstand last, but this seemed like the sort of foolish consistency that Ralph Waldo Emerson warned of.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#future-directions&gt;Future directions<br>&gt; <br>&gt; Note: The rest of this proposal is highly speculative and there&#39;s probably no need to read further.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#other-sequence-api-cleanups&gt;Other Sequence API cleanups<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#seriously-source-breaking&gt;Seriously source-breaking<br>&gt; <br>&gt; There is an ongoing discussion about which, if any, of map, flatMap, filter, and reduce ought to be renamed to more closely match Swift naming conventions. There is also discussion about relabeling many closure parameters.<br>&gt; <br>&gt; The &quot;Future directions&quot; section below suggests every(where:) as an alternative to filter which could be extended in ways compatible with this proposal.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#significantly-source-breaking&gt;Significantly source-breaking<br>&gt; <br>&gt; The removeSubrange(_:) and replaceSubrange(_:with:) APIs are rather oddly named. They might be better renamed to, for instance, remove(in:) and replace(in:with:).<br>&gt; <br>&gt; It is not clear how important removingFirst() and removingLast() actually are, given that they&#39;re exactly equivalent to removingPrefix(1) and removingSuffix(1), and their corresponding &quot;get&quot; members are on Collection instead of Sequence. They could be removed.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#slightly-source-breaking&gt;Slightly source-breaking<br>&gt; <br>&gt; removeFirst/Last() and popFirst/Last() are very nearly redundant; their only difference is that the removemethods have a non-Optional return type and require the collection not be empty, while the pop methods have an Optional return type and return nil if it&#39;s empty.<br>&gt; <br>&gt; These operations could be merged, with the remove operations taking on the preconditions of the current popoperations; additionally, removePrefix(_:) and removeSuffix(_:) could drop their equivalent preconditions requiring that the elements being removed exist. These changes would simplify the standard library and make these methods more closely parallel the equivalent removing methods, which do not have similar preconditions.<br>&gt; <br>&gt; Performance-critical code which wants to avoid the checks necessary to remove these preconditions could switch to remove(at:) and removeSubrange(_:), which would continue to reject invalid indices.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#adding-sequence-and-collection-operations&gt;Adding sequence and collection operations<br>&gt; <br>&gt; This exercise in renaming suggests all sorts of other APIs we might add, and a few we might rename.<br>&gt; <br>&gt; In general, I have not attempted to carefully scrutinize the usefulness of each of these APIs; instead, I have merely listed the ones which I can imagine some kind of use for. The main exception is the &quot;Pop&quot; operation; I can imagine several different, and rather incompatible, ways to extend it, and I&#39;m not going to take the time to sort out my thoughts merely to write a &quot;Future directions&quot; section.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#filling-in-the-sequence-end-api-table&gt;Filling in the sequence-end API table<br>&gt; <br>&gt; The gaps in the table suggest a number of APIs we could offer in the future. Here, I have filled in all options which are at least coherent:<br>&gt; <br>&gt; Operand	Get	Index	Exclude	Remove (1)	Pop (1)	Equate (2)<br>&gt; Fixed Size						<br>&gt; First 1	C.first	C.firstIndex	S.removingFirst()	C.removeFirst()	C.popFirst()	-<br>&gt; Last 1	C.last	C.lastIndex	S.removingLast()	C.removeLast()	C.popLast()	-<br>&gt; First (n: Int)	S.prefix(_:)	C.prefixIndex(_:)	S.removingPrefix(_:)	C.removePrefix(_:)	-	S.hasPrefix(_:)<br>&gt;   ...with closure	S.prefix(while:)	C.prefixIndex(while:)	S.removingPrefix(while:)	C.removePrefix(while:)	-	S.hasPrefix(_:isEquivalent:)<br>&gt; Last (n: Int)	S.suffix(_:)	C.suffixIndex(_:)	S.removingSuffix(_:)	C.removeSuffix(_:)	-	S.hasSuffix(_:)<br>&gt;   ...with closure	S.suffix(while:)	C.suffixIndex(while:)	S.removingSuffix(while:)	C.removeSuffix(while:)	-	S.hasSuffix(_:isEquivalent:)<br>&gt; Searching From End						<br>&gt; First matching element	S.earliest(_:)	C.earliestIndex(of:)	S.removingEarliest(_:)	C.removeEarliest(_:)	-	-<br>&gt;   ...with closure	S.earliest(where:)	C.earliestIndex(where:)	S.removingEarliest(where:)	C.removeEarliest(where:)	-	-<br>&gt; Last matching element	S.latest(_:)	C.latestIndex(of:)	S.removingLatest(_:)	C.removeLatest(_:)	-	-<br>&gt;   ...with closure	S.latest(where:)	C.latestIndex(where:)	S.removingLatest(where:)	C.removeLatest(where:)	-	-<br>&gt; To explain a few entries which might not be immediately obvious: firstIndex and lastIndex would be nil if the collection is empty, and lastIndex would be the index before endIndex. prefixIndex would return the last index of the prefix, and suffixIndex would return the first index of the suffix; alternatively, these could be named with Indices and return ranges. earliest(_:) and latest(_:) would return the first and last element equal to the provided value; on a Set, they would be roughly equivalent to NSSet.member(_:).<br>&gt; <br>&gt; The changes I consider most worthy include:<br>&gt; <br>&gt; Adding corresponding last, suffix, and latest methods for all first, prefix, and earliest methods.<br>&gt; <br>&gt; Adding corresponding while: versions of all appropriate prefix/suffix APIs.<br>&gt; <br>&gt; Ones that could be useful, but can usually be emulated with more work:<br>&gt; <br>&gt; Adding remove/removing-by-content APIs.<br>&gt; <br>&gt; Adding prefix/suffixIndex(while:).<br>&gt; <br>&gt; Ones that are mere conveniences or may not have strong use cases:<br>&gt; <br>&gt; first/lastIndex and prefix/suffixIndex(_:).<br>&gt; <br>&gt; earliest/latest(_:).<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#all-and-every-as-operands&gt;&quot;All&quot; and &quot;Every&quot; as operands<br>&gt; <br>&gt; One could imagine adding rows to this table for &quot;all&quot; and &quot;every matching&quot;. In addition to creating some useful new API, this would also suggest some interesting renaming for existing APIs:<br>&gt; <br>&gt; allIndices would be a name for indices.<br>&gt; <br>&gt; removeAll() is actually an existing name which happens to fit this pattern.<br>&gt; <br>&gt; every(where:) would be a name for filter. Though I believe filter is a strong term of art, I do note that every(where:) does not cause confusion about the sense of its test, a major complaint about filter.<br>&gt; <br>&gt; In the table below, bold indicates new functionality; italics indicates existing functionality renamed to fit this pattern.<br>&gt; <br>&gt; Operand	Get	Index	Exclude	Remove (1)	Pop (1)	Equate (2)<br>&gt; Fixed Size						<br>&gt; First 1	C.first	C.firstIndex	S.removingFirst()	C.removeFirst()	C.popFirst()	-<br>&gt; Last 1	C.last	C.lastIndex	S.removingLast()	C.removeLast()	C.popLast()	-<br>&gt; First (n: Int)	S.prefix(_:)	C.prefixIndex(_:)	S.removingPrefix(_:)	C.removePrefix(_:)	-	S.hasPrefix(_:)<br>&gt;   ...with closure	S.prefix(while:)	C.prefixIndex(while:)	S.removingPrefix(while:)	C.removePrefix(while:)	-	S.hasPrefix(_:isEquivalent:)<br>&gt; Last (n: Int)	S.suffix(_:)	C.suffixIndex(_:)	S.removingSuffix(_:)	C.removeSuffix(_:)	-	S.hasSuffix(_:)<br>&gt;   ...with closure	S.suffix(while:)	C.suffixIndex(while:)	S.removingSuffix(while:)	C.removeSuffix(while:)	-	S.hasSuffix(_:isEquivalent:)<br>&gt; All	-	allIndices	-	C.removeAll()	-	-<br>&gt; Searching From End						<br>&gt; First matching element	S.earliest(_:)	C.earliestIndex(of:)	S.removingEarliest(_:)	C.removeEarliest(_:)	-	-<br>&gt;   ...with closure	S.earliest(where:)	C.earliestIndex(where:)	S.removingEarliest(where:)	C.removeEarliest(where:)	-	-<br>&gt; Last matching element	S.latest(_:)	C.latestIndex(of:)	S.removingLatest(_:)	C.removeLatest(_:)	-	-<br>&gt;   ...with closure	S.latest(where:)	C.latestIndex(where:)	S.removingLatest(where:)	C.removeLatest(where:)	-	-<br>&gt; Every matching element	S.every(_:)	C.everyIndex(of:)	S.removingEvery(_:)	C.removeEvery(_:)	-	-<br>&gt;   ...with closure	S.every(where:)	C.everyIndex(where:)	S.removingEvery(where:)	C.removeEvery(where:)	-	-<br>&gt; An alternative to the every methods is to give them names based on all or any, but these tend to require breaks from the naming patterns of the matching earliest and latest methods to remain grammatical.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/024d26c2b68b88323989540c06261430#additional-index-based-operations&gt;Additional index-based operations<br>&gt; <br>&gt; Though accessing a range of elements bounded by the end of the collection is useful, it might be useful to extend that ability to other range-based collection APIs. IncompleteRange would make this especially easy; we would simply overload Range-taking APIs to permit IncompleteRanges as well. However, we could also provide variants of these APIs which take a to:, through:, or from: index parameter in place of an index range.<br>&gt; <br>&gt; Candidates include:<br>&gt; <br>&gt; MutableCollection.subscript(bounds: Range&lt;Index&gt;) { set }, making the subscripts in this proposal mutable.<br>&gt; <br>&gt; RangeReplaceableCollection.removeSubrange(\_:)<br>&gt; <br>&gt; RangeReplaceableCollection.replaceSubrange(\_:with:)<br>&gt; <br>&gt; The various Range parameters in String (although these might be better replaced with slice-based APIs).<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/72c6b7ff/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[Draft] Rationalizing Sequence end-operation names</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>June 23, 2016 at 11:00:00pm</p></header><div class="content"><p>I like this draft. Quickly:<br></p><p>- “removing” sounds more destructive than “skipping”, so I’d lean towards using “skipping”. I would be happy with either, though.<br>- there are two different labels for predicates (where and while). “where” is probably the better label. (some previous discussion had seemingly arrived to that conclusion: http://article.gmane.org/gmane.comp.lang.swift.evolution/16334/)<br></p><p>I like the idea of making the index-based slicing operations look more like slicing operations. I have on occasion wanted the operators you describe in the “aggressive” option; I approve.<br></p><p>Cheers,<br>Guillaume Lessard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft] Rationalizing Sequence end-operation names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 24, 2016 at 12:00:00am</p></header><div class="content"><p>On Fri, Jun 24, 2016 at 12:45 AM, Guillaume Lessard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I like this draft. Quickly:<br>&gt;<br>&gt; - “removing” sounds more destructive than “skipping”, so I’d lean towards<br>&gt; using “skipping”. I would be happy with either, though.<br>&gt; - there are two different labels for predicates (where and while). “where”<br>&gt; is probably the better label. (some previous discussion had seemingly<br>&gt; arrived to that conclusion:<br>&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/16334/)<br>&gt;<br></p><p>I think this is going to the distinction that &quot;where&quot; is now supposed to<br>correspond to &quot;continue&quot; inside a loop if the predicate isn&#39;t satisfied,<br>whereas &quot;while&quot; is supposed to correspond to &quot;break&quot; inside a loop if the<br>predicate isn&#39;t satisfied. Then again, I&#39;ve argued elsewhere on this list<br>that the distinction isn&#39;t nearly as obvious as some seem to think it is,<br>and I think we have another demonstration of that here :)<br></p><p><br>&gt;<br>&gt; I like the idea of making the index-based slicing operations look more<br>&gt; like slicing operations. I have on occasion wanted the operators you<br>&gt; describe in the “aggressive” option; I approve.<br>&gt;<br>&gt; Cheers,<br>&gt; Guillaume Lessard<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/5c15db63/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Rationalizing Sequence end-operation names</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 27, 2016 at 09:00:00pm</p></header><div class="content"><p>I apologize for not getting the threading right in this email, Anton; Mail seems to have glitched and lost your message.<br></p><p>&gt; • Renaming `index(of:/where:)` to `earliestIndex(…)` and `first(where:)`<br>&gt; to `earliest(where:)`<br>&gt; <br>&gt; -1, because `index` is considered state-of-art. `first` does not exist in<br>&gt; all languages, but `earliest` is used nowhere.<br></p><p>&gt; • Redesigning `prefix(upTo:)`, `prefix(through:)` and `suffix(from:)` as<br>&gt; subscripts with &quot;partial&quot; ranges, like `people[..&lt;idx]` or perhaps<br>&gt; `people[nil..&lt;idx]`.<br>&gt; <br>&gt; -1, because prefix and suffix are state-of-art again, plus they match the<br>&gt; theme you are proposing, while subscripts do not.<br></p><p>I know that there are terms of art in this area, but I am explicitly ignoring them. This paragraph appears in the `drop` section, but it really applies to the entire proposal:<br></p><p>&gt;&gt; The term-of-art exception is not a suicide pact; it is meant to aid understanding by importing common terminology, not bind us to follow every decision made by any language that came before us. In this case, I think we should ignore precedent and forge our own path.<br></p><p>Almost every change in this proposal violates the term-of-art rule. I&#39;m proposing them anyway because, in my opinion, we have too closely followed many weak terms of art in an area which would benefit more from a design with consistent, simple rules.<br></p><p>I will address the prefix/suffix thing in a joint reply to you and several others, but your complaints about `index` are, I believe, unique.<br></p><p>`index` is not a strong term of art; in my survey of a few languages that , languages seem to use &quot;find&quot;, &quot;index&quot;, or both, but in a number of different ways. In alphabetical order by function/method name:<br></p><p>• Haskell: `elemIndex`<br>• C++: `find`<br>• Python: `find` and `index` (the former returns a sentinel value on error; the latter throws)<br>• Javascript: `findIndex`<br>• Ruby: `find_index`<br>• Perl: `first_index` (in List::MoreUtils)<br>• Objective-C: `indexOf:`<br>• Java: `indexOf`<br>• Scala: `indexOf`<br>• C#: `IndexOf`<br></p><p>Moreover, &lt;https://github.com/apple/swift-evolution/pull/329&gt; presents a compelling reason to add a direction to these methods: so we can provide a matching set of index-finding methods from the end of the collection. Languages in this list which offer one usually end up creating two asymmetrically-named methods, like `indexOf` and `lastIndexOf`. I don&#39;t think that&#39;s a good solution.<br></p><p>You are quite right that `earliest` is a novel invention, unprecedented in other languages as far as I know. I think there&#39;s value in distinguishing between the &quot;first&quot; operations (which operate on the sequence&#39;s very first element without doing any searching) and the &quot;earliest&quot; operations (which perform a usually linear search from the beginning of the collection to the end). I also think that, if you look at the tables in &quot;Adding sequence and collection operations&quot;, some of the potential methods in that table might be confusing if the &quot;earliest&quot; operations instead use &quot;first&quot;. For instance, `removeFirst()` would remove the very first element, while `removeFirst(_:)` would search for a matching element and remove it.<br></p><p>Nevertheless, it *is* possible to use `first` instead of `earliest`, and in fact my decision to post the version using `earliest` was a last-minute one. I think `earliest` is a cleaner solution, but `first` is a reasonable alternative.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
