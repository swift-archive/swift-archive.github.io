<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0143: Conditional Conformances</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>September 29, 2016 at 10:00:00pm</p></header><div class="content"><p>Obviously I&#39;m a huge +1 for this feature, but I have some concerns and<br>questions about the particulars.<br></p><p>on Wed Sep 28 2016, Joe Groff &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of “Conditional Conformances” begins now and runs through October 7. The proposal is available here:<br>&gt;<br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0143-conditional-conformances.md<br>&gt; Reviews are an important part of the Swift evolution process. All<br>&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at<br>&gt; the top of the message:<br>&gt;<br>&gt; Proposal link: <br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0143-conditional-conformances.md<br></p><p><br>&gt; ## Proposed solution<br>&gt;<br>&gt; In a nutshell, the proposed solution is to allow a constrained<br>&gt; extension of a `struct`, `enum`, or `class` (but [not a<br>&gt; protocol](#alternatives-considered)) to declare protocol<br>&gt; conformances. No additional syntax is necessary for this change,<br>&gt; because it already exists in the grammar; rather, this proposal<br>&gt; removes the limitation that results in the following error:<br>&gt; <br>&gt; ```<br>&gt; t.swift:1:1: error: extension of type &#39;Array&#39; with constraints cannot have an inheritance clause<br>&gt; extension Array: Equatable where Element: Equatable { }<br>&gt; ^                ~~~~~~~~~<br>&gt; ```<br>&gt; <br>&gt; Conditional conformances can only be used when the additional<br>&gt; requirements of the constrained extension are satisfied. For example,<br>&gt; given the aforementioned `Array` conformance to `Equatable`:<br>&gt; <br>&gt; ```swift<br>&gt; func f&lt;T: Equatable&gt;(_: T) { ... }<br>&gt; <br>&gt; struct NotEquatable { }<br>&gt; <br>&gt; func test(a1: [Int], a2: [NotEquatable]) {<br>&gt;   f(a1)    // okay: [Int] conforms to Equatable because Int conforms to Equatable<br>&gt;   f(a2)    // error: [NotEquatable] does not conform to Equatable because NotEquatable has no conformance to Equatable<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; Conditional conformances also have a run-time aspect, because a<br>&gt; dynamic check for a protocol conformance might rely on the evaluation<br>&gt; of the extra requirements needed to successfully use a conditional<br>&gt; conformance. For example:<br>&gt; <br>&gt; ```swift<br>&gt; protocol P {<br>&gt;   func doSomething()<br>&gt; }<br>&gt; <br>&gt; struct S: P {<br>&gt;   func doSomething() { print(&quot;S&quot;) }<br>&gt; }<br>&gt; <br>&gt; // Array conforms to P if it&#39;s element type conforms to P<br>&gt; extension Array: P where Element: P {<br>&gt;   func doSomething() {<br>&gt;     for value in self {<br>&gt;       value.doSomething()<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; // Dynamically query and use conformance to P.<br>&gt; func doSomethingIfP(_ value: Any) {<br>&gt;   if let p = value as? P {<br>&gt;     p.doSomething()<br>&gt;   } else {<br>&gt;     print(&quot;Not a P&quot;)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; doSomethingIfP([S(), S(), S()]) // prints &quot;S&quot; three times<br>&gt; doSomethingIfP([1, 2, 3])       // prints &quot;Not a P&quot;<br>&gt; ```<br>&gt; <br>&gt; The `if-let` in `doSomethingIfP(_:)` dynamically queries whether the<br>&gt; type stored in `value` conforms to the protocol `P`. In the case of an<br>&gt; `Array`, that conformance is conditional, which requires another<br>&gt; dynamic lookup to determine whether the element type conforms to `P`:<br>&gt; in the first call to `doSomethingIfP(_:)`, the lookup finds the<br>&gt; conformance of `S` to `P`. In the second case, there is no conformance<br>&gt; of `Int` to `P`, so the conditional conformance cannot be used. The<br>&gt; desire for this dynamic behavior motivates some of the design<br>&gt; decisions in this proposal.<br></p><p>Whether a dynamic evaluation is required at this point seems to depend<br>on how you represent conformance.  Saying “Array conforms conditionally”<br>treats Array as a type, but it might be simpler to treat Array as a<br>family of concrete types.  I always envisined it this way: at the moment<br>a module using the concrete type Array&lt;Foo&gt; comes together with an<br>extension (either in that module or in another) that makes Array&lt;T&gt;<br>conform to Equatable depending on properties of T, that extension is<br>evaluated and Array&lt;Foo&gt; is marked as conforming or not.  Then asking<br>about a type&#39;s conformance is always a simple thing.  But I suppose<br>which approach wins is dependent on many factors, and the other way can<br>be thought of as adding lazy evaluation to the basic model, so if this<br>adds nothing to your thinking please excuse the static.<br></p><p>&gt; ## Detailed design<br>&gt;<br>&gt; Most of the semantics of conditional conformances are<br>&gt; obvious. However, there are a number of issues (mostly involving<br>&gt; multiple conformances) that require more in-depth design.<br>&gt; <br>&gt; ### Disallow overlapping conformances<br>&gt; With conditional conformances, it is possible to express that a given<br>&gt; generic type can conform to the same protocol in two different ways,<br>&gt; depending on the capabilities of its type arguments. For example:<br>&gt; <br>&gt; ```swift<br>&gt; struct SomeWrapper&lt;Wrapped&gt; {<br>&gt;   let wrapped: Wrapped<br>&gt; }<br>&gt; <br>&gt; protocol HasIdentity {<br>&gt;   static func ===(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; extension SomeWrapper: Equatable where Wrapped: Equatable {<br>&gt;   static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>&gt;     return lhs.wrapped == rhs.wrapped<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; extension SomeWrapper: Equatable where Wrapped: HasIdentity {<br>&gt;   static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>&gt;     return lhs.wrapped === rhs.wrapped<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; Note that, for an arbitrary type `T`, there are four potential answers to<br>&gt; the question of whether `SomeWrapper&lt;T&gt;` conforms to `Equatable`:<br>&gt; <br>&gt; 1. No, it does not conform because `T` is neither `Equatable` nor<br>&gt; `HasIdentity`.<br>&gt; 2. Yes, it conforms via the first extension of `SomeWrapper` because<br>&gt; `T` conforms to `Equatable`.<br>&gt; 3. Yes, it conforms via the second extension of `SomeWrapper` because<br>&gt; `T` conforms to `HasIdentity`.<br>&gt; 4. Ambiguity, because `T` conforms to both `Equatable` and<br>&gt; `HasIdentity`.<br></p><p>Arguably in this case you could say yes it conforms and it doesn&#39;t<br>matter which extension you use because there&#39;s only one sensible<br>semantics for Equatable.  Other protocols are less obvious, though<br>(c.f. Int&#39;s conformance to Monoid with +/0 vs */1).<br></p><p>&gt; It is due to the possibility of #4 occurring that we refer to the two<br>&gt; conditional conformances in the example as *overlapping*. There are<br>&gt; designs that would allow one to address the ambiguity, for example, by<br>&gt; writing a third conditional conformance that addresses #4:<br>&gt; <br>&gt; ```swift<br>&gt; // Possible tie-breaker conformance<br>&gt; extension SomeWrapper: Equatable where Wrapped: Equatable &amp; HasIdentity, {<br>&gt;   static func ==(lhs: SomeWrapper&lt;Wrapped&gt;, rhs: SomeWrapper&lt;Wrapper&gt;) -&gt; Bool {<br>&gt;     return lhs.wrapped == rhs.wrapped<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; The design is consistent, because this third conditional conformance<br>&gt; is more *specialized* the either of the first two conditional<br>&gt; conformances, meaning that its requirements are a strict superset of<br>&gt; the requirements of those two conditional conformances. However, there<br>&gt; are a few downsides to such a system:<br>&gt; <br>&gt; 1. To address all possible ambiguities, one has to write a conditional<br>&gt; conformance for every plausible combination of overlapping<br>&gt; requirements. To *statically* resolve all ambiguities, one must also<br>&gt; cover nonsensical combinations where the two requirements are mutually<br>&gt; exclusive (or invent a way to state mutual-exclusivity).<br>&gt;<br>&gt; 2. It is no longer possible to uniquely say what is required to make a<br>&gt; generic type conform to a protocol, because there might be several<br>&gt; unrelated possibilities. This makes reasoning about the whole system<br>&gt; more complex, because it admits divergent interfaces for the same<br>&gt; generic type based on their type arguments. <br></p><p>I&#39;m pretty sure we already have that.  Array&lt;T&gt; would have hashValue if<br>T were hashable, and &lt; if T were comparable, and never the twain shall<br>meet.<br></p><p>&gt; At its extreme, this invites the kind of cleverness we&#39;ve seen in the<br>&gt; C++ community with template metaprogramming, which is something Swift<br>&gt; has sought to avoid.<br>&gt;<br>&gt; 3. All of the disambiguation machinery required at compile time (e.g.,<br>&gt; to determine whether one conditional conformance is more specialized<br>&gt; than another to order them) also needs to implements in the run-time,<br>&gt; as part of the dynamic casting machinery. One must also address the<br>&gt; possibility of ambiguities occurring at run-time. This is both a sharp<br>&gt; increase in the complexity of the system and a potential run-time<br>&gt; performance hazard.<br>&gt; <br>&gt; For these reasons, this proposal *bans overlapping conformances*<br>&gt; entirely. While the resulting system is less flexible than one that<br>&gt; allowed overlapping conformances, the gain in simplicity in this<br>&gt; potentially-confusing area is well worth the cost. Moreover, this ban<br>&gt; follows with existing Swift rules regarding multiple conformances,<br>&gt; which prohibit the same type from conforming to the same protocol in<br>&gt; two different ways:<br>&gt; <br>&gt; ```swift<br>&gt; protocol P { }<br>&gt; <br>&gt; struct S : P { }<br>&gt; extension S : P { } // error: S already conforms to P<br>&gt; ```<br></p><p>I think that&#39;s the real answer to “why don&#39;t we want to allow it?”<br></p><p>Also, these overlapping constraints are effectively equivalent to “or”<br>constraints, which I think we know are trouble, from a type checking<br>POV.<br></p><p>[By the way, what is the status of our enforcement of this rule across<br>modules?  I do think that library interop will eventually oblige us to<br>allow different overlapping conformances to appear in separate modules<br>that don&#39;t also define the conforming type].<br></p><p>&gt; ### Implied conditional conformances <br>&gt; <br>&gt; Stating conformance to a protocol implicitly states conformances to<br>&gt; any of the protocols that it inherits. This is the case in Swift<br>&gt; today, although most developers likely don&#39;t realize the rules it<br>&gt; follows. For example:<br>&gt; <br>&gt; ```swift<br>&gt; protocol P { }<br>&gt; protocol Q : P { }<br>&gt; protocol R : P { }<br>&gt; <br>&gt; struct X1 { }<br>&gt; struct X2 { }<br>&gt; struct X3 { }<br>&gt; <br>&gt; extension X1: Q { }  // implies conformance to P<br>&gt; <br>&gt; extension X2: Q { }  // would imply conformance to P, but...<br>&gt; extension X2: P { }  // explicitly-stated conformance to P &quot;wins&quot;<br></p><p>What difference does it make which one “wins?”  Even if P had<br>requirements and we were fulfilling them in these extensions, my mental<br>model has always been that they get thrown into a big soup and we let<br>overload resolution sort it out (or declare ambiguity).  So I&#39;ve never<br>had any idea that “winning” was happening.<br></p><p>&gt; extension X3: Q { }  // implies conformance to P<br>&gt; extension X3: R { }  // also implies conformance to P<br>&gt;                      // one will &quot;win&quot;; which is unspecified<br>&gt; ```<br>&gt; <br>&gt; With conditional conformances, the question of which extension &quot;wins&quot;<br>&gt; the implied conformance begins to matter, because the extensions might<br>&gt; have different constraints on them. For example:<br>&gt; <br>&gt; ```swift<br>&gt; struct X4&lt;T&gt; { }<br>&gt; <br>&gt; extension X4: Q where T: Q { }  // implies conformance to P<br>&gt; extension X4: R where T: R { }  // error: implies overlapping conformance to P<br>&gt; ```<br>&gt; <br>&gt; Both of these constrained extensions imply a conformance to `P`, but<br>&gt; the actual `P` implied conformances to `P` are overlapping and,<br>&gt; therefore, result in an error.<br></p><p>Doesn&#39;t this break, then?<br></p><p>   protocol Equatable { ... }<br>   protocol Comparable : Equatable { ... }<br>   protocol Hashable : Equatable { ... }<br></p><p>   extension Array : Comparable where T : Comparable {}<br>   extension Array : Hashable where T : Hashable {}<br></p><p>I hope not, beause personally, I don&#39;t see how breaking the ability to<br>do things like that could be acceptable.  The protocols such as<br>Equatable et al. that form the components of “Regular” types are *going*<br>to be inherited by many other protocols, so this isn&#39;t just going to<br>happen in a nice localized context, either.<br></p><p>&gt; However, in cases where there is a reasonable ordering between the two<br>&gt; constrained extensions (i.e., one is more specialized than the other),<br>&gt; the less specialized constrained extension should &quot;win&quot; the implied<br>&gt; conformance. <br></p><p>“Less specialized wins” is surprising at the very least!  I&#39;ve only ever<br>seen the opposite rule (e.g. in overload resolution).  What&#39;s the<br>rationale for this approach?<br></p><p>&gt; Continuing the example from above:<br>&gt; <br>&gt; ```swift<br>&gt; protocol S: R { }<br>&gt; <br>&gt; struct X5&lt;T&gt; { }<br>&gt; <br>&gt; extension X5: S where T: S { }<br>&gt; <br>&gt; // This last extension &quot;wins&quot; the implied conformance to P, because<br>&gt; // the extension where &quot;T: R&quot; is less specialized than the one<br>&gt; // where &quot;T: S&quot;.<br>&gt; extension X5: R where T: R { }<br>&gt; ```<br>&gt;<br>&gt; Thus, the rule for placing implied conformances is to pick the *least<br>&gt; specialized* extension that implies the conformance. If there is more<br>&gt; than one such extension, then either:<br>&gt; <br>&gt; 1. All such extensions are not constrained extensions (i.e., they have<br>&gt; no requirements beyond what the type requires), in which case Swift<br>&gt; can continue to choose arbitrarily among the extensions, <br></p><p>Surely that can&#39;t be the right long-term design?<br></p><p>&gt; or<br>&gt; <br>&gt; 2. All such extensions are constrained extensions, in which case the<br>&gt; program is ill-formed due to the ambiguity. The developer can<br>&gt; explicitly specify conformance to the protocol to disambiguate.<br></p><p>I&#39;m really concerned about the understandability of this model.  It<br>doesn&#39;t seem rational or consistent with other choices in the<br>language. Now maybe I&#39;m missing something, but in that case I think you<br>haven&#39;t given a clear/precise enough description of the rules.  But the<br>next section looks like it might clear things up for me...<br></p><p>...(I&#39;m sorry to say it didn&#39;t)<br></p><p>&gt; ### Overloading across constrained extensions<br>&gt; <br>&gt; One particularly important aspect of the placement rule for implied<br>&gt; conformances is that it affects which declarations are used to satisfy<br>&gt; a particular requirement. For example:<br>&gt; <br>&gt; <br>&gt; ```swift<br>&gt; protocol P {<br>&gt;   func f()<br>&gt; }<br>&gt; <br>&gt; protocol Q: P { }<br>&gt; protocol R: Q { }<br>&gt; <br>&gt; struct X1&lt;T&gt; { }<br>&gt; <br>&gt; extension X1: Q where T: Q {           // note: implied conformance to P here<br>&gt;   func f() {<br>&gt;     // #1: basic implementation of &#39;f()&#39;<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; extension X1: R where T: R {<br>&gt;   func f() {<br>&gt;     // #2: superfast implementation of f() using some knowledge of &#39;R&#39;<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; struct X2: R {<br>&gt;   func f() { }<br>&gt; }<br>&gt; <br>&gt; (X1&lt;X2&gt;() as P).f() // calls #1, which was used to satisfy the requirement for &#39;f&#39;<br>&gt; X1&lt;X2&gt;().f()        // calls #2, which is preferred by overload resolution<br>&gt; ```<br>&gt; <br>&gt; Effectively, when satisfying a protocol requirement, one can only<br>&gt; choose from members of the type that are guaranteed to available<br>&gt; within the extension with which the conformance is associated. <br></p><p>AFAICT, this is the first time that an extension&#39;s association to a<br>conformance has ever been visible in the user model, and I am not sure<br>that we want to expose it.  I&#39;m *not* saying we *don&#39;t* want to; I&#39;m<br>saying it isn&#39;t obvious why we should.<br></p><p>&gt; In this case, the conformance to `P` is placed on the first extension<br>&gt; of `X1`, so the only `f()` that can be considered is the `f()` within<br>&gt; that extension: the `f()` in the second extension won&#39;t necessarily<br>&gt; always be available, because `T` may not conform to `R`. <br></p><p>I don&#39;t see how that&#39;s any different from the `f()` in the first<br>extension, which won&#39;t necessarily always be available because `T` may<br>not conform to `Q`.<br></p><p>&gt; Hence, the call that treats an `X1&lt;X2&gt;` as a `P` gets the first<br>&gt; implementation of `X1.f()`. When using the concrete type `X1&lt;X2&gt;`,<br>&gt; where `X2` conforms to `R`, both `X.f()` implementations are<br>&gt; visible... and the second is more specialized.<br>&gt; <br>&gt; Technically, this issue is no different from surprises where (e.g.) a<br>&gt; member added to a concrete type in a different module won&#39;t affect an<br>&gt; existing protocol conformance. <br></p><p>Let me be absolutely clear that I&#39;m *not* questioning this scheme on<br>those grounds.  I think it makes sense for static and dynamic (or<br>generic) behaviors of the same spelling to differ sometimes, and it&#39;s<br>even a useful design tool (c.f. someCollection.lazy).  However, the fact<br>that it arises in some situations and is even sometimes the best design<br>choice doesn&#39;t mean that&#39;s the way *this* feature should act in *this*<br>situation.  I can&#39;t tell whether you&#39;re suggesting:<br></p><p>a) type safety demands this behavior<br>b) it&#39;s the only behavior that&#39;s efficiently implementable<br>c) it&#39;s actually the best behavior for the common use cases, or<br>d) something else<br></p><p>&gt; The existing ideas to mediate these problems---warning for<br>&gt; nearly-matching functions when they are declared in concrete types,<br>&gt; for example---will likely be sufficient to help surprised users. That<br>&gt; said, this proposal may increase the likelihood of such problems<br>&gt; showing up.<br>&gt; <br>&gt; ## Source compatibility<br>&gt; <br>&gt; From the language perspective, conditional conformances are purely<br>&gt; additive. They introduce no new syntax, but instead provide semantics<br>&gt; for existing syntax---an extension that both declares a protocol<br>&gt; conformance and has a `where` clause---whose use currently results in<br>&gt; a type checker failure. That said, this is a feature that is expected<br>&gt; to be widely adopted within the Swift standard library, which may<br>&gt; indirectly affect source compatibility.<br>&gt; <br>&gt; ## Effect on ABI Stability<br>&gt; <br>&gt; As noted above, there are a number of places where the standard<br>&gt; library is expected to adopt this feature, which fall into two<br>&gt; classes:<br>&gt; <br>&gt; 1. Improve composability: the example in the<br>&gt; [introduction](#introduction) made `Array` conform to `Equatable` when<br>&gt; its element type does; there are many places in the Swift standard<br>&gt; library that could benefit from this form of conditional conformance,<br>&gt; particularly so that collections and other types that contain values<br>&gt; (e.g., `Optional`) can compose better with generic algorithms. Most of<br>&gt; these changes won&#39;t be ABI- or source-breaking, because they&#39;re<br>&gt; additive.<br>&gt; <br>&gt; 2. Eliminating repetition: the `lazy` wrappers described in the<br>&gt; [motivation](#motivation) section could be collapsed into a single<br>&gt; wrapper with several conditional conformances. A similar refactoring<br>&gt; could also be applied to the range abstractions and slice types in the<br>&gt; standard library, making the library itself simpler and smaller. All<br>&gt; of these changes are potentially source-breaking and ABI-breaking,<br>&gt; because they would remove types that could be used in Swift 3<br>&gt; code. However, there are mitigations: generic typealiases could<br>&gt; provide source compatibility to Swift 3 clients, and the ABI-breaking<br>&gt; aspect is only relevant if conditional conformances and the standard<br>&gt; library changes they imply aren&#39;t part of Swift 4.<br></p><p>I think the description “eliminating repetition” does a disservice to<br>the actual impact of this feature.  It will result in a massive decrease<br>in API surface area, which simplifies the implementation of the library,<br>yes, but also makes it far more accessible to users.<br></p><p>&gt; Aside from the standard library, conditional conformances have an<br>&gt; impact on the Swift runtime, which will require specific support to<br>&gt; handle dynamic casting. If that runtime support is not available once<br>&gt; ABI stability has been declared, then introducing conditional<br>&gt; conformances in a later language version either means the feature<br>&gt; cannot be deployed backward or that it would provide only more<br>&gt; limited, static behavior when used on older runtimes. <br></p><p>It would also mean carrying forward all that implementation and API<br>complexity for the forseeable future.<br></p><p>&gt; Hence, there is significant motivation for doing this feature as part<br>&gt; of Swift 4. Even if we waited to introduce conditional conformances,<br>&gt; we would want to include a hook in the runtime to allow them to be<br>&gt; implemented later, to avoid future backward-compatibility issues.<br>&gt; <br>&gt; ## Effect on Resilience<br>&gt; <br>&gt; One of the primary goals of Swift 4 is resilience, which allows<br>&gt; libraries to evolve without breaking binary compatibility with the<br>&gt; applications that use them. While the specific details of the impact<br>&gt; of conditional conformances on resilience will be captured in a<br>&gt; more-complete proposal on resilience, possible rules are summarized<br>&gt; here:<br>&gt; <br>&gt; * A conditional conformance cannot be removed in the new version of a<br>&gt; library, because existing clients might depend on it.<br></p><p>I think that applies to all conformances.<br></p><p>&gt; * A conditional conformance can be added in a new version of a<br>&gt; library, roughly following the rules described in the [library<br>&gt; evolution<br>&gt; document](https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst#new-conformances). The<br>&gt; conformance itself will need to be annotated with the version in which<br>&gt; it was introduced.<br></p><p>Presumably this is an ABI-preserving but potentially source-breaking<br>change, because of the implied conformance ambiguity issues you<br>mentioned earlier... and because of changing overload resolution, etc.?<br></p><p>&gt; * A conditional conformance can be *generalized* in a new version of<br>&gt; the library, i.e., it can be effectively replaced by a (possibly<br>&gt; conditional) conformance in a new version of the library that is less<br>&gt; specialized than the conditional conformance in the older version of<br>&gt; the library. For example.<br>&gt; <br>&gt;   ```swift<br>&gt;   public struct X&lt;T&gt; { }<br>&gt;   <br>&gt;   // Conformance in version 1.0<br>&gt;   public extension X: Sequence where T: Collection { ... }<br>&gt;   <br>&gt;   // Can be replaced by this less-specialized conformance in version 1.1<br>&gt;   public extension X: Sequence where T: Sequence { ... }<br>&gt;   ```<br>&gt;   <br>&gt;   Such conformances would likely need some kind of annotation.<br></p><p>Ditto?<br></p><p>&gt; ## Alternatives considered<br>&gt; <br>&gt; The most common request related to conditional conformances is to allow a (constrained) protocol extension to declare conformance to a protocol. For example:<br>&gt; <br>&gt; ```swift<br>&gt; extension Collection: Equatable where Iterator.Element: Equatable {<br>&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;     // ...<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; This protocol extension will make any `Collection` of `Equatable`<br>&gt; elements `Equatable`, which is a powerful feature that could be put to<br>&gt; good use. Introducing conditional conformances for protocol extensions<br>&gt; would exacerbate the problem of overlapping conformances, because it<br>&gt; would be unreasonable to say that the existence of the above protocol<br>&gt; extension means that no type that conforms to `Collection` could<br>&gt; declare its own conformance to `Equatable`, conditional or otherwise.<br></p><p>...which is part of why I think we need better rules about overlap than<br>the ones proposed here.  I anticipate a repetition of the pattern we<br>have today, where Array provides == and != but can&#39;t conform to<br>Equatable, just on a different level.  That has always felt wrong.  Now<br>we&#39;ll do the same thing with Collection, so *at least* you don&#39;t have to<br>write the == operator when you write the conditional conformance.<br> <br>&gt; There are several potential solutions to the problem of overlapping<br>&gt; conformances (e.g., admitting some form of overlapping conformances<br>&gt; that can be resolved at runtime or introducing the notion of<br>&gt; conformances that cannot be queried a runtime), but the feature is<br>&gt; large enough to warrant a separate proposal that explores the<br>&gt; solutions in greater depth.<br></p><p>I think the problem and solutions need to be explored in greater depth<br>now.<br></p><p>&gt;<br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature,<br>&gt; how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0143: Conditional Conformances</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September 30, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Sep 29, 2016, at 10:16 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Obviously I&#39;m a huge +1 for this feature, but I have some concerns and<br>&gt; questions about the particulars.<br>&gt; <br>&gt; on Wed Sep 28 2016, Joe Groff &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Conditional conformances also have a run-time aspect, because a<br>&gt;&gt; dynamic check for a protocol conformance might rely on the evaluation<br>&gt;&gt; of the extra requirements needed to successfully use a conditional<br>&gt;&gt; conformance. For example:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; protocol P {<br>&gt;&gt;  func doSomething()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: P {<br>&gt;&gt;  func doSomething() { print(&quot;S&quot;) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Array conforms to P if it&#39;s element type conforms to P<br>&gt;&gt; extension Array: P where Element: P {<br>&gt;&gt;  func doSomething() {<br>&gt;&gt;    for value in self {<br>&gt;&gt;      value.doSomething()<br>&gt;&gt;    }<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Dynamically query and use conformance to P.<br>&gt;&gt; func doSomethingIfP(_ value: Any) {<br>&gt;&gt;  if let p = value as? P {<br>&gt;&gt;    p.doSomething()<br>&gt;&gt;  } else {<br>&gt;&gt;    print(&quot;Not a P&quot;)<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; doSomethingIfP([S(), S(), S()]) // prints &quot;S&quot; three times<br>&gt;&gt; doSomethingIfP([1, 2, 3])       // prints &quot;Not a P&quot;<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; The `if-let` in `doSomethingIfP(_:)` dynamically queries whether the<br>&gt;&gt; type stored in `value` conforms to the protocol `P`. In the case of an<br>&gt;&gt; `Array`, that conformance is conditional, which requires another<br>&gt;&gt; dynamic lookup to determine whether the element type conforms to `P`:<br>&gt;&gt; in the first call to `doSomethingIfP(_:)`, the lookup finds the<br>&gt;&gt; conformance of `S` to `P`. In the second case, there is no conformance<br>&gt;&gt; of `Int` to `P`, so the conditional conformance cannot be used. The<br>&gt;&gt; desire for this dynamic behavior motivates some of the design<br>&gt;&gt; decisions in this proposal.<br>&gt; <br>&gt; Whether a dynamic evaluation is required at this point seems to depend<br>&gt; on how you represent conformance.  Saying “Array conforms conditionally”<br>&gt; treats Array as a type, but it might be simpler to treat Array as a<br>&gt; family of concrete types.<br></p><p>This is already the case in the runtime; we specialize the metadata for generic types.<br></p><p>&gt;  I always envisined it this way: at the moment<br>&gt; a module using the concrete type Array&lt;Foo&gt; comes together with an<br>&gt; extension (either in that module or in another) that makes Array&lt;T&gt;<br>&gt; conform to Equatable depending on properties of T, that extension is<br>&gt; evaluated and Array&lt;Foo&gt; is marked as conforming or not.<br></p><p>If the protocol, Array, and Foo all come from different modules, this process happens at runtime. Yes, the optimizer could specialize the conformance at compile time in many common cases, but you can’t see every possible specialization without whole-program analysis, so it doesn’t change the model.<br></p><p><br>&gt;  Then asking<br>&gt; about a type&#39;s conformance is always a simple thing.  But I suppose<br>&gt; which approach wins is dependent on many factors, and the other way can<br>&gt; be thought of as adding lazy evaluation to the basic model, so if this<br>&gt; adds nothing to your thinking please excuse the static.<br></p><p>Without whole-program information, you need to have the runtime capability (or disallow the use of this feature in runtime queries). Static specialization can be considered an optimization to this model.<br></p><p>&gt;&gt; Note that, for an arbitrary type `T`, there are four potential answers to<br>&gt;&gt; the question of whether `SomeWrapper&lt;T&gt;` conforms to `Equatable`:<br>&gt;&gt; <br>&gt;&gt; 1. No, it does not conform because `T` is neither `Equatable` nor<br>&gt;&gt; `HasIdentity`.<br>&gt;&gt; 2. Yes, it conforms via the first extension of `SomeWrapper` because<br>&gt;&gt; `T` conforms to `Equatable`.<br>&gt;&gt; 3. Yes, it conforms via the second extension of `SomeWrapper` because<br>&gt;&gt; `T` conforms to `HasIdentity`.<br>&gt;&gt; 4. Ambiguity, because `T` conforms to both `Equatable` and<br>&gt;&gt; `HasIdentity`.<br>&gt; <br>&gt; Arguably in this case you could say yes it conforms and it doesn&#39;t<br>&gt; matter which extension you use because there&#39;s only one sensible<br>&gt; semantics for Equatable.<br></p><p>Sure, we know the semantics of these protocols: === should imply ==.<br></p><p>&gt;  Other protocols are less obvious, though<br>&gt; (c.f. Int&#39;s conformance to Monoid with +/0 vs */1).<br></p><p>Right.<br></p><p>&gt;&gt; 2. It is no longer possible to uniquely say what is required to make a<br>&gt;&gt; generic type conform to a protocol, because there might be several<br>&gt;&gt; unrelated possibilities. This makes reasoning about the whole system<br>&gt;&gt; more complex, because it admits divergent interfaces for the same<br>&gt;&gt; generic type based on their type arguments. <br>&gt; <br>&gt; I&#39;m pretty sure we already have that.  Array&lt;T&gt; would have hashValue if<br>&gt; T were hashable, and &lt; if T were comparable, and never the twain shall<br>&gt; meet.<br></p><p>The first sentence of (2) meant “to a *given* protocol”, not just “to any protocol.&quot; But, yes, you’re right that (e.g.) overloading across differently-constrained extensions and protocol extensions means dealing with divergent interfaces… and it’s been a problem for type checker and humans both.<br></p><p>&gt; <br>&gt;&gt; At its extreme, this invites the kind of cleverness we&#39;ve seen in the<br>&gt;&gt; C++ community with template metaprogramming, which is something Swift<br>&gt;&gt; has sought to avoid.<br>&gt;&gt; <br>&gt;&gt; 3. All of the disambiguation machinery required at compile time (e.g.,<br>&gt;&gt; to determine whether one conditional conformance is more specialized<br>&gt;&gt; than another to order them) also needs to implements in the run-time,<br>&gt;&gt; as part of the dynamic casting machinery. One must also address the<br>&gt;&gt; possibility of ambiguities occurring at run-time. This is both a sharp<br>&gt;&gt; increase in the complexity of the system and a potential run-time<br>&gt;&gt; performance hazard.<br>&gt;&gt; <br>&gt;&gt; For these reasons, this proposal *bans overlapping conformances*<br>&gt;&gt; entirely. While the resulting system is less flexible than one that<br>&gt;&gt; allowed overlapping conformances, the gain in simplicity in this<br>&gt;&gt; potentially-confusing area is well worth the cost. Moreover, this ban<br>&gt;&gt; follows with existing Swift rules regarding multiple conformances,<br>&gt;&gt; which prohibit the same type from conforming to the same protocol in<br>&gt;&gt; two different ways:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; protocol P { }<br>&gt;&gt; <br>&gt;&gt; struct S : P { }<br>&gt;&gt; extension S : P { } // error: S already conforms to P<br>&gt;&gt; ```<br>&gt; <br>&gt; I think that&#39;s the real answer to “why don&#39;t we want to allow it?”<br>&gt; <br>&gt; Also, these overlapping constraints are effectively equivalent to “or”<br>&gt; constraints, which I think we know are trouble, from a type checking<br>&gt; POV.<br></p><p>Right.<br></p><p>&gt; <br>&gt; [By the way, what is the status of our enforcement of this rule across<br>&gt; modules?  I do think that library interop will eventually oblige us to<br>&gt; allow different overlapping conformances to appear in separate modules<br>&gt; that don&#39;t also define the conforming type].<br></p><p>IIRC, we get runtime failures for overlapping conformances across modules.<br></p><p>&gt;&gt; ### Implied conditional conformances <br>&gt;&gt; <br>&gt;&gt; Stating conformance to a protocol implicitly states conformances to<br>&gt;&gt; any of the protocols that it inherits. This is the case in Swift<br>&gt;&gt; today, although most developers likely don&#39;t realize the rules it<br>&gt;&gt; follows. For example:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; protocol P { }<br>&gt;&gt; protocol Q : P { }<br>&gt;&gt; protocol R : P { }<br>&gt;&gt; <br>&gt;&gt; struct X1 { }<br>&gt;&gt; struct X2 { }<br>&gt;&gt; struct X3 { }<br>&gt;&gt; <br>&gt;&gt; extension X1: Q { }  // implies conformance to P<br>&gt;&gt; <br>&gt;&gt; extension X2: Q { }  // would imply conformance to P, but...<br>&gt;&gt; extension X2: P { }  // explicitly-stated conformance to P &quot;wins&quot;<br>&gt; <br>&gt; What difference does it make which one “wins?”  Even if P had<br>&gt; requirements and we were fulfilling them in these extensions, my mental<br>&gt; model has always been that they get thrown into a big soup and we let<br>&gt; overload resolution sort it out (or declare ambiguity).  So I&#39;ve never<br>&gt; had any idea that “winning” was happening.<br></p><p>In Swift 3, it doesn’t actually matter who “wins”: it’s just an implementation detail whose only user-visible effect right now is on the near-miss diagnostics for @objc optional requirements. My obtuse way of saying this in the proposal was to point out that, with conditional conformances, now it *does* matter to the user model, because overload resolution would get different answers depending on which extension is asking the question.<br></p><p>&gt;&gt; extension X3: Q { }  // implies conformance to P<br>&gt;&gt; extension X3: R { }  // also implies conformance to P<br>&gt;&gt;                     // one will &quot;win&quot;; which is unspecified<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; With conditional conformances, the question of which extension &quot;wins&quot;<br>&gt;&gt; the implied conformance begins to matter, because the extensions might<br>&gt;&gt; have different constraints on them. For example:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; struct X4&lt;T&gt; { }<br>&gt;&gt; <br>&gt;&gt; extension X4: Q where T: Q { }  // implies conformance to P<br>&gt;&gt; extension X4: R where T: R { }  // error: implies overlapping conformance to P<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Both of these constrained extensions imply a conformance to `P`, but<br>&gt;&gt; the actual `P` implied conformances to `P` are overlapping and,<br>&gt;&gt; therefore, result in an error.<br>&gt; <br>&gt; Doesn&#39;t this break, then?<br>&gt; <br>&gt;   protocol Equatable { ... }<br>&gt;   protocol Comparable : Equatable { ... }<br>&gt;   protocol Hashable : Equatable { ... }<br>&gt; <br>&gt;   extension Array : Comparable where T : Comparable {}<br>&gt;   extension Array : Hashable where T : Hashable {}<br>&gt; <br>&gt; I hope not, beause personally, I don&#39;t see how breaking the ability to<br>&gt; do things like that could be acceptable.  The protocols such as<br>&gt; Equatable et al. that form the components of “Regular” types are *going*<br>&gt; to be inherited by many other protocols, so this isn&#39;t just going to<br>&gt; happen in a nice localized context, either.<br></p><p>The above is ill-formed as written, because we can’t associate ‘Equatable’ with either conformance without excluding the other—and putting it in both places would create an overlapping conformance. So, the fix is to explicitly spell out the Equatable conformance:<br></p><p>	extension Array: Equatable where T: Equatable { } okay! this is the Equatable conformance for Array<br></p><p>Note that this conformance is less-specialized than both the “Array: Comparable” and “Array: Hashable” conformances, which is important: one cannot satisfy “Hashable” (or “Comparable”) without satisfying “Equatable”, so that Equatable conformance has to exist and has to be usable from the Hashable and Comparable conformances.<br></p><p>&gt; <br>&gt;&gt; However, in cases where there is a reasonable ordering between the two<br>&gt;&gt; constrained extensions (i.e., one is more specialized than the other),<br>&gt;&gt; the less specialized constrained extension should &quot;win&quot; the implied<br>&gt;&gt; conformance. <br>&gt; <br>&gt; “Less specialized wins” is surprising at the very least!  I&#39;ve only ever<br>&gt; seen the opposite rule (e.g. in overload resolution).  What&#39;s the<br>&gt; rationale for this approach?<br></p><p>You need the most-general implementation so that conformance can be used by other constrained extensions, the way the ‘Array: Equatable’ gets used by ‘Array: Hashable’ and ‘Array: Comparable’.<br></p><p>&gt; <br>&gt;&gt; Continuing the example from above:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; protocol S: R { }<br>&gt;&gt; <br>&gt;&gt; struct X5&lt;T&gt; { }<br>&gt;&gt; <br>&gt;&gt; extension X5: S where T: S { }<br>&gt;&gt; <br>&gt;&gt; // This last extension &quot;wins&quot; the implied conformance to P, because<br>&gt;&gt; // the extension where &quot;T: R&quot; is less specialized than the one<br>&gt;&gt; // where &quot;T: S&quot;.<br>&gt;&gt; extension X5: R where T: R { }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Thus, the rule for placing implied conformances is to pick the *least<br>&gt;&gt; specialized* extension that implies the conformance. If there is more<br>&gt;&gt; than one such extension, then either:<br>&gt;&gt; <br>&gt;&gt; 1. All such extensions are not constrained extensions (i.e., they have<br>&gt;&gt; no requirements beyond what the type requires), in which case Swift<br>&gt;&gt; can continue to choose arbitrarily among the extensions, <br>&gt; <br>&gt; Surely that can&#39;t be the right long-term design?<br></p><p>When all of the extensions are unconstrained, it still doesn’t matter to the user where the conformance goes. In truth, this rule extends to groups of extensions that have the *same* constraints—it doesn’t matter which one we pick.<br></p><p>&gt; <br>&gt;&gt; or<br>&gt;&gt; <br>&gt;&gt; 2. All such extensions are constrained extensions, in which case the<br>&gt;&gt; program is ill-formed due to the ambiguity. The developer can<br>&gt;&gt; explicitly specify conformance to the protocol to disambiguate.<br>&gt; <br>&gt; I&#39;m really concerned about the understandability of this model.  It<br>&gt; doesn&#39;t seem rational or consistent with other choices in the<br>&gt; language. Now maybe I&#39;m missing something, but in that case I think you<br>&gt; haven&#39;t given a clear/precise enough description of the rules.  But the<br>&gt; next section looks like it might clear things up for me...<br>&gt; <br>&gt; ...(I&#39;m sorry to say it didn’t)<br></p><p>While the exposition can be improved somewhat, placement of implied conformances is fairly tricky and low-level. It will surface to the user in cases where the user writes something like your Comparable/Hashable example:<br></p><p>&gt;   extension Array : Comparable where T : Comparable {}<br>&gt;   extension Array : Hashable where T : Hashable {}<br></p><p><br>and the compiler needs to complain about the inability to place ‘Equatable’ in a way that directs the user to the correct answer without exposing them to the entire chain of reasoning we’re going through. The diagnostic would need some thought:<br></p><p>	error: ‘Array&#39; requires an explicit conformance to ‘Equatable’ due to conflicting implied conformances (from ‘Comparable’ and ‘Hashable’)<br></p><p>We can easily produce a Fix-It to create the skeleton of the conformance:<br></p><p>	extension Array: Equatable {<br>	  // … <br>	}<br></p><p>With some heroics involving, e.g., intersecting the requirements, we might be able to have the Fix-It put in a guess at the ‘where’ clause:<br></p><p>	extension Array: Equatable where T: Equatable {<br>	  // … <br>	}<br></p><p>but that might not be necessary.<br></p><p>Now, I do think it’s important to note that neither of the Comparable or Hashable conformances we’ve shown actually has what Equatable needs—it doesn’t provide an ‘==‘ operator. The problems become clearer if we try to write that in both places:<br></p><p>	extension Array: Comparable where T: Comparable {<br>	  static func ==(lhs: Self, rhs: Self) -&gt; Bool { … }<br>	}<br></p><p>	extension Array: Comparable where T: Comparable {<br>	  static func ==(lhs: Self, rhs: Self) -&gt; Bool { … }<br>	}<br></p><p>Which ‘==‘ makes Array Equatable? The answer depends on the capabilities of ’T’.<br></p><p><br>&gt;&gt; ### Overloading across constrained extensions<br>&gt;&gt; <br>&gt;&gt; One particularly important aspect of the placement rule for implied<br>&gt;&gt; conformances is that it affects which declarations are used to satisfy<br>&gt;&gt; a particular requirement. For example:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; protocol P {<br>&gt;&gt;  func f()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol Q: P { }<br>&gt;&gt; protocol R: Q { }<br>&gt;&gt; <br>&gt;&gt; struct X1&lt;T&gt; { }<br>&gt;&gt; <br>&gt;&gt; extension X1: Q where T: Q {           // note: implied conformance to P here<br>&gt;&gt;  func f() {<br>&gt;&gt;    // #1: basic implementation of &#39;f()&#39;<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension X1: R where T: R {<br>&gt;&gt;  func f() {<br>&gt;&gt;    // #2: superfast implementation of f() using some knowledge of &#39;R&#39;<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct X2: R {<br>&gt;&gt;  func f() { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; (X1&lt;X2&gt;() as P).f() // calls #1, which was used to satisfy the requirement for &#39;f&#39;<br>&gt;&gt; X1&lt;X2&gt;().f()        // calls #2, which is preferred by overload resolution<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Effectively, when satisfying a protocol requirement, one can only<br>&gt;&gt; choose from members of the type that are guaranteed to available<br>&gt;&gt; within the extension with which the conformance is associated. <br>&gt; <br>&gt; AFAICT, this is the first time that an extension&#39;s association to a<br>&gt; conformance has ever been visible in the user model, and I am not sure<br>&gt; that we want to expose it.  I&#39;m *not* saying we *don&#39;t* want to; I&#39;m<br>&gt; saying it isn&#39;t obvious why we should.<br></p><p>I guess it’s technically been visible in cross-module cases—you can see where the implied protocols ended up in the generated interface of a compiled module—but nobody noticed or cared, so it’s not really part of the model. It might be that we don’t need to make this concept visible at all—we just need to tell users when we require them to write an explicit conformance. We could even omit the “why” from the diagnostic.<br></p><p>&gt; <br>&gt;&gt; In this case, the conformance to `P` is placed on the first extension<br>&gt;&gt; of `X1`, so the only `f()` that can be considered is the `f()` within<br>&gt;&gt; that extension: the `f()` in the second extension won&#39;t necessarily<br>&gt;&gt; always be available, because `T` may not conform to `R`. <br>&gt; <br>&gt; I don&#39;t see how that&#39;s any different from the `f()` in the first<br>&gt; extension, which won&#39;t necessarily always be available because `T` may<br>&gt; not conform to `Q`.<br></p><p>If you’re looking from the point of view of the first extension, T does conform to P. That’s the “placement” part: when you say that a conformance is placed on a particular extension, it’s requirements are satisfied based on the constraints of that extension.<br></p><p>&gt; <br>&gt;&gt; Hence, the call that treats an `X1&lt;X2&gt;` as a `P` gets the first<br>&gt;&gt; implementation of `X1.f()`. When using the concrete type `X1&lt;X2&gt;`,<br>&gt;&gt; where `X2` conforms to `R`, both `X.f()` implementations are<br>&gt;&gt; visible... and the second is more specialized.<br>&gt;&gt; <br>&gt;&gt; Technically, this issue is no different from surprises where (e.g.) a<br>&gt;&gt; member added to a concrete type in a different module won&#39;t affect an<br>&gt;&gt; existing protocol conformance. <br>&gt; <br>&gt; Let me be absolutely clear that I&#39;m *not* questioning this scheme on<br>&gt; those grounds.  I think it makes sense for static and dynamic (or<br>&gt; generic) behaviors of the same spelling to differ sometimes, and it&#39;s<br>&gt; even a useful design tool (c.f. someCollection.lazy).  However, the fact<br>&gt; that it arises in some situations and is even sometimes the best design<br>&gt; choice doesn&#39;t mean that&#39;s the way *this* feature should act in *this*<br>&gt; situation.  I can&#39;t tell whether you&#39;re suggesting:<br>&gt; <br>&gt; a) type safety demands this behavior<br>&gt; b) it&#39;s the only behavior that&#39;s efficiently implementable<br>&gt; c) it&#39;s actually the best behavior for the common use cases, or<br>&gt; d) something else<br></p><p>It’s weakened forms of (a)-(c):<br></p><p>aa) It’s guaranteed to provide type safety, without the possibility for run-time ambiguities or other failures<br>bb) It’s efficiently implementable and fits well into the existing model. I know of partial solutions that allow some late resolution here that are efficiently implementable and can maintain a lack of run-time failures, but they require nontrivial engineering effort and I don’t know how to generalize them<br>cc) I suspect that the vast majority of use cases don’t need this kind of late resolution<br></p><p><br>&gt;&gt; 2. Eliminating repetition: the `lazy` wrappers described in the<br>&gt;&gt; [motivation](#motivation) section could be collapsed into a single<br>&gt;&gt; wrapper with several conditional conformances. A similar refactoring<br>&gt;&gt; could also be applied to the range abstractions and slice types in the<br>&gt;&gt; standard library, making the library itself simpler and smaller. All<br>&gt;&gt; of these changes are potentially source-breaking and ABI-breaking,<br>&gt;&gt; because they would remove types that could be used in Swift 3<br>&gt;&gt; code. However, there are mitigations: generic typealiases could<br>&gt;&gt; provide source compatibility to Swift 3 clients, and the ABI-breaking<br>&gt;&gt; aspect is only relevant if conditional conformances and the standard<br>&gt;&gt; library changes they imply aren&#39;t part of Swift 4.<br>&gt; <br>&gt; I think the description “eliminating repetition” does a disservice to<br>&gt; the actual impact of this feature.  It will result in a massive decrease<br>&gt; in API surface area, which simplifies the implementation of the library,<br>&gt; yes, but also makes it far more accessible to users.<br></p><p>Okay, fair point.<br></p><p>&gt; <br>&gt;&gt; Aside from the standard library, conditional conformances have an<br>&gt;&gt; impact on the Swift runtime, which will require specific support to<br>&gt;&gt; handle dynamic casting. If that runtime support is not available once<br>&gt;&gt; ABI stability has been declared, then introducing conditional<br>&gt;&gt; conformances in a later language version either means the feature<br>&gt;&gt; cannot be deployed backward or that it would provide only more<br>&gt;&gt; limited, static behavior when used on older runtimes. <br>&gt; <br>&gt; It would also mean carrying forward all that implementation and API<br>&gt; complexity for the forseeable future.<br></p><p>Yup.<br></p><p>&gt; <br>&gt;&gt; Hence, there is significant motivation for doing this feature as part<br>&gt;&gt; of Swift 4. Even if we waited to introduce conditional conformances,<br>&gt;&gt; we would want to include a hook in the runtime to allow them to be<br>&gt;&gt; implemented later, to avoid future backward-compatibility issues.<br>&gt;&gt; <br>&gt;&gt; ## Effect on Resilience<br>&gt;&gt; <br>&gt;&gt; One of the primary goals of Swift 4 is resilience, which allows<br>&gt;&gt; libraries to evolve without breaking binary compatibility with the<br>&gt;&gt; applications that use them. While the specific details of the impact<br>&gt;&gt; of conditional conformances on resilience will be captured in a<br>&gt;&gt; more-complete proposal on resilience, possible rules are summarized<br>&gt;&gt; here:<br>&gt;&gt; <br>&gt;&gt; * A conditional conformance cannot be removed in the new version of a<br>&gt;&gt; library, because existing clients might depend on it.<br>&gt; <br>&gt; I think that applies to all conformances.<br></p><p>Yes, it does.<br></p><p>&gt; <br>&gt;&gt; * A conditional conformance can be added in a new version of a<br>&gt;&gt; library, roughly following the rules described in the [library<br>&gt;&gt; evolution<br>&gt;&gt; document](https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst#new-conformances). The<br>&gt;&gt; conformance itself will need to be annotated with the version in which<br>&gt;&gt; it was introduced.<br>&gt; <br>&gt; Presumably this is an ABI-preserving but potentially source-breaking<br>&gt; change, because of the implied conformance ambiguity issues you<br>&gt; mentioned earlier... and because of changing overload resolution, etc.?<br></p><p>Yeah, the issue here is that the conditional conformance would overlap existing concrete conformances, so you would need to remove those concrete conformances… except when using an old version of the library.<br></p><p>&gt;&gt; * A conditional conformance can be *generalized* in a new version of<br>&gt;&gt; the library, i.e., it can be effectively replaced by a (possibly<br>&gt;&gt; conditional) conformance in a new version of the library that is less<br>&gt;&gt; specialized than the conditional conformance in the older version of<br>&gt;&gt; the library. For example.<br>&gt;&gt; <br>&gt;&gt;  ```swift<br>&gt;&gt;  public struct X&lt;T&gt; { }<br>&gt;&gt; <br>&gt;&gt;  // Conformance in version 1.0<br>&gt;&gt;  public extension X: Sequence where T: Collection { ... }<br>&gt;&gt; <br>&gt;&gt;  // Can be replaced by this less-specialized conformance in version 1.1<br>&gt;&gt;  public extension X: Sequence where T: Sequence { ... }<br>&gt;&gt;  ```<br>&gt;&gt; <br>&gt;&gt;  Such conformances would likely need some kind of annotation.<br>&gt; <br>&gt; Ditto?<br></p><p>Yup.<br></p><p>&gt; <br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The most common request related to conditional conformances is to allow a (constrained) protocol extension to declare conformance to a protocol. For example:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; extension Collection: Equatable where Iterator.Element: Equatable {<br>&gt;&gt;  static func ==(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;    // ...<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; This protocol extension will make any `Collection` of `Equatable`<br>&gt;&gt; elements `Equatable`, which is a powerful feature that could be put to<br>&gt;&gt; good use. Introducing conditional conformances for protocol extensions<br>&gt;&gt; would exacerbate the problem of overlapping conformances, because it<br>&gt;&gt; would be unreasonable to say that the existence of the above protocol<br>&gt;&gt; extension means that no type that conforms to `Collection` could<br>&gt;&gt; declare its own conformance to `Equatable`, conditional or otherwise.<br>&gt; <br>&gt; ...which is part of why I think we need better rules about overlap than<br>&gt; the ones proposed here.  I anticipate a repetition of the pattern we<br>&gt; have today, where Array provides == and != but can&#39;t conform to<br>&gt; Equatable, just on a different level.  That has always felt wrong.  Now<br>&gt; we&#39;ll do the same thing with Collection, so *at least* you don&#39;t have to<br>&gt; write the == operator when you write the conditional conformance.<br></p><p>Yes, there will be repetition. To be concrete, one would end up with this:<br></p><p>extension RangeReplaceableCollection where Iterator.Element: Equatable {<br>  static func ==(lhs: Self, rhs: Self) -&gt; Bool {<br>    // implement == efficiently...<br>  }<br>}<br></p><p>but each type that forms to Collection will still have to state its conformance to Equatable, even though it will often be empty, e.g.,<br></p><p>	extension Array: Equatable where Element: Equatable { }<br></p><p>We are still in a better place than we were in Swift 3, where there was *no* way to make Array conform to Equatable, but in these cases it’ll still feel boilerplate-y.<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0143: Conditional Conformances</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>September 30, 2016 at 01:00:00pm</p></header><div class="content"><p>on Fri Sep 30 2016, Douglas Gregor &lt;dgregor-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Sep 29, 2016, at 10:16 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Obviously I&#39;m a huge +1 for this feature, but I have some concerns and<br>&gt;&gt; questions about the particulars.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; on Wed Sep 28 2016, Joe Groff &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Conditional conformances also have a run-time aspect, because a<br>&gt;&gt;&gt; dynamic check for a protocol conformance might rely on the evaluation<br>&gt;&gt;&gt; of the extra requirements needed to successfully use a conditional<br>&gt;&gt;&gt; conformance. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;  func doSomething()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S: P {<br>&gt;&gt;&gt;  func doSomething() { print(&quot;S&quot;) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Array conforms to P if it&#39;s element type conforms to P<br>&gt;&gt;&gt; extension Array: P where Element: P {<br>&gt;&gt;&gt;  func doSomething() {<br>&gt;&gt;&gt;    for value in self {<br>&gt;&gt;&gt;      value.doSomething()<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Dynamically query and use conformance to P.<br>&gt;&gt;&gt; func doSomethingIfP(_ value: Any) {<br>&gt;&gt;&gt;  if let p = value as? P {<br>&gt;&gt;&gt;    p.doSomething()<br>&gt;&gt;&gt;  } else {<br>&gt;&gt;&gt;    print(&quot;Not a P&quot;)<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; doSomethingIfP([S(), S(), S()]) // prints &quot;S&quot; three times<br>&gt;&gt;&gt; doSomethingIfP([1, 2, 3])       // prints &quot;Not a P&quot;<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The `if-let` in `doSomethingIfP(_:)` dynamically queries whether the<br>&gt;&gt;&gt; type stored in `value` conforms to the protocol `P`. In the case of an<br>&gt;&gt;&gt; `Array`, that conformance is conditional, which requires another<br>&gt;&gt;&gt; dynamic lookup to determine whether the element type conforms to `P`:<br>&gt;&gt;&gt; in the first call to `doSomethingIfP(_:)`, the lookup finds the<br>&gt;&gt;&gt; conformance of `S` to `P`. In the second case, there is no conformance<br>&gt;&gt;&gt; of `Int` to `P`, so the conditional conformance cannot be used. The<br>&gt;&gt;&gt; desire for this dynamic behavior motivates some of the design<br>&gt;&gt;&gt; decisions in this proposal.<br>&gt;&gt; <br>&gt;&gt; Whether a dynamic evaluation is required at this point seems to depend<br>&gt;&gt; on how you represent conformance.  Saying “Array conforms conditionally”<br>&gt;&gt; treats Array as a type, but it might be simpler to treat Array as a<br>&gt;&gt; family of concrete types.<br>&gt;<br>&gt; This is already the case in the runtime; we specialize the metadata for generic types.<br>&gt;<br>&gt;&gt;  I always envisined it this way: at the moment<br>&gt;&gt; a module using the concrete type Array&lt;Foo&gt; comes together with an<br>&gt;&gt; extension (either in that module or in another) that makes Array&lt;T&gt;<br>&gt;&gt; conform to Equatable depending on properties of T, that extension is<br>&gt;&gt; evaluated and Array&lt;Foo&gt; is marked as conforming or not.<br>&gt;<br>&gt; If the protocol, Array, and Foo all come from different modules, this<br>&gt; process happens at runtime. Yes, the optimizer could specialize the<br>&gt; conformance at compile time in many common cases, but you can’t see<br>&gt; every possible specialization without whole-program analysis, so it<br>&gt; doesn’t change the model.<br>&gt;<br>&gt;&gt;  Then asking<br>&gt;&gt; about a type&#39;s conformance is always a simple thing.  But I suppose<br>&gt;&gt; which approach wins is dependent on many factors, and the other way can<br>&gt;&gt; be thought of as adding lazy evaluation to the basic model, so if this<br>&gt;&gt; adds nothing to your thinking please excuse the static.<br>&gt;<br>&gt; Without whole-program information, you need to have the runtime<br>&gt; capability (or disallow the use of this feature in runtime<br>&gt; queries). Static specialization can be considered an optimization to<br>&gt; this model.<br></p><p>I know it has to happen at runtime in the worst case.  I was suggesting<br>it could happen at load time rather than as a complication of the<br>dynamic cast machinery.  In principle all the load-time information can<br>be usefully cached on-disk.<br></p><p>&gt;&gt;&gt; Note that, for an arbitrary type `T`, there are four potential answers to<br>&gt;&gt;&gt; the question of whether `SomeWrapper&lt;T&gt;` conforms to `Equatable`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. No, it does not conform because `T` is neither `Equatable` nor<br>&gt;&gt;&gt; `HasIdentity`.<br>&gt;&gt;&gt; 2. Yes, it conforms via the first extension of `SomeWrapper` because<br>&gt;&gt;&gt; `T` conforms to `Equatable`.<br>&gt;&gt;&gt; 3. Yes, it conforms via the second extension of `SomeWrapper` because<br>&gt;&gt;&gt; `T` conforms to `HasIdentity`.<br>&gt;&gt;&gt; 4. Ambiguity, because `T` conforms to both `Equatable` and<br>&gt;&gt;&gt; `HasIdentity`.<br>&gt;&gt; <br>&gt;&gt; Arguably in this case you could say yes it conforms and it doesn&#39;t<br>&gt;&gt; matter which extension you use because there&#39;s only one sensible<br>&gt;&gt; semantics for Equatable.<br>&gt;<br>&gt; Sure, we know the semantics of these protocols: === should imply ==.<br>&gt;<br>&gt;&gt;  Other protocols are less obvious, though<br>&gt;&gt; (c.f. Int&#39;s conformance to Monoid with +/0 vs */1).<br>&gt;<br>&gt; Right.<br>&gt;<br>&gt;&gt;&gt; 2. It is no longer possible to uniquely say what is required to make a<br>&gt;&gt;&gt; generic type conform to a protocol, because there might be several<br>&gt;&gt;&gt; unrelated possibilities. This makes reasoning about the whole system<br>&gt;&gt;&gt; more complex, because it admits divergent interfaces for the same<br>&gt;&gt;&gt; generic type based on their type arguments. <br>&gt;&gt; <br>&gt;&gt; I&#39;m pretty sure we already have that.  Array&lt;T&gt; would have hashValue if<br>&gt;&gt; T were hashable, and &lt; if T were comparable, and never the twain shall<br>&gt;&gt; meet.<br>&gt;<br>&gt; The first sentence of (2) meant “to a *given* protocol”, not just “to<br>&gt; any protocol.&quot; <br></p><p>I don&#39;t think I misunderstood that.<br></p><p>&gt; But, yes, you’re right that (e.g.) overloading across<br>&gt; differently-constrained extensions and protocol extensions means<br>&gt; dealing with divergent interfaces… and it’s been a problem for type<br>&gt; checker and humans both.<br></p><p>But that&#39;s not going away, so what&#39;s the point in bringing it up?<br></p><p>&gt;&gt;&gt; At its extreme, this invites the kind of cleverness we&#39;ve seen in the<br>&gt;&gt;&gt; C++ community with template metaprogramming, which is something Swift<br>&gt;&gt;&gt; has sought to avoid.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. All of the disambiguation machinery required at compile time (e.g.,<br>&gt;&gt;&gt; to determine whether one conditional conformance is more specialized<br>&gt;&gt;&gt; than another to order them) also needs to implements in the run-time,<br>&gt;&gt;&gt; as part of the dynamic casting machinery. One must also address the<br>&gt;&gt;&gt; possibility of ambiguities occurring at run-time. This is both a sharp<br>&gt;&gt;&gt; increase in the complexity of the system and a potential run-time<br>&gt;&gt;&gt; performance hazard.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For these reasons, this proposal *bans overlapping conformances*<br>&gt;&gt;&gt; entirely. While the resulting system is less flexible than one that<br>&gt;&gt;&gt; allowed overlapping conformances, the gain in simplicity in this<br>&gt;&gt;&gt; potentially-confusing area is well worth the cost. Moreover, this ban<br>&gt;&gt;&gt; follows with existing Swift rules regarding multiple conformances,<br>&gt;&gt;&gt; which prohibit the same type from conforming to the same protocol in<br>&gt;&gt;&gt; two different ways:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; protocol P { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S : P { }<br>&gt;&gt;&gt; extension S : P { } // error: S already conforms to P<br>&gt;&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; I think that&#39;s the real answer to “why don&#39;t we want to allow it?”<br>&gt;&gt; <br>&gt;&gt; Also, these overlapping constraints are effectively equivalent to “or”<br>&gt;&gt; constraints, which I think we know are trouble, from a type checking<br>&gt;&gt; POV.<br>&gt;<br>&gt; Right.<br>&gt;&gt; <br>&gt;&gt; [By the way, what is the status of our enforcement of this rule across<br>&gt;&gt; modules?  I do think that library interop will eventually oblige us to<br>&gt;&gt; allow different overlapping conformances to appear in separate modules<br>&gt;&gt; that don&#39;t also define the conforming type].<br>&gt;<br>&gt; IIRC, we get runtime failures for overlapping conformances across<br>&gt; modules.<br></p><p>Ick.  Not that I know of a better answer...<br></p><p>&gt;&gt;&gt; ### Implied conditional conformances <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Stating conformance to a protocol implicitly states conformances to<br>&gt;&gt;&gt; any of the protocols that it inherits. This is the case in Swift<br>&gt;&gt;&gt; today, although most developers likely don&#39;t realize the rules it<br>&gt;&gt;&gt; follows. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; protocol P { }<br>&gt;&gt;&gt; protocol Q : P { }<br>&gt;&gt;&gt; protocol R : P { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X1 { }<br>&gt;&gt;&gt; struct X2 { }<br>&gt;&gt;&gt; struct X3 { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X1: Q { }  // implies conformance to P<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X2: Q { }  // would imply conformance to P, but...<br>&gt;&gt;&gt; extension X2: P { }  // explicitly-stated conformance to P &quot;wins&quot;<br>&gt;&gt; <br>&gt;&gt; What difference does it make which one “wins?”  Even if P had<br>&gt;&gt; requirements and we were fulfilling them in these extensions, my mental<br>&gt;&gt; model has always been that they get thrown into a big soup and we let<br>&gt;&gt; overload resolution sort it out (or declare ambiguity).  So I&#39;ve never<br>&gt;&gt; had any idea that “winning” was happening.<br>&gt;<br>&gt; In Swift 3, it doesn’t actually matter who “wins”: it’s just an<br>&gt; implementation detail whose only user-visible effect right now is on<br>&gt; the near-miss diagnostics for @objc optional requirements. My obtuse<br>&gt; way of saying this in the proposal was to point out that, with<br>&gt; conditional conformances, now it *does* matter to the user model,<br>&gt; because overload resolution would get different answers depending on<br>&gt; which extension is asking the question.<br>&gt;<br>&gt;&gt;&gt; extension X3: Q { }  // implies conformance to P<br>&gt;&gt;&gt; extension X3: R { }  // also implies conformance to P<br>&gt;&gt;&gt;                     // one will &quot;win&quot;; which is unspecified<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With conditional conformances, the question of which extension &quot;wins&quot;<br>&gt;&gt;&gt; the implied conformance begins to matter, because the extensions might<br>&gt;&gt;&gt; have different constraints on them. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; struct X4&lt;T&gt; { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X4: Q where T: Q { }  // implies conformance to P<br>&gt;&gt;&gt; extension X4: R where T: R { }  // error: implies overlapping conformance to P<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Both of these constrained extensions imply a conformance to `P`, but<br>&gt;&gt;&gt; the actual `P` implied conformances to `P` are overlapping and,<br>&gt;&gt;&gt; therefore, result in an error.<br>&gt;&gt; <br>&gt;&gt; Doesn&#39;t this break, then?<br>&gt;&gt; <br>&gt;&gt;   protocol Equatable { ... }<br>&gt;&gt;   protocol Comparable : Equatable { ... }<br>&gt;&gt;   protocol Hashable : Equatable { ... }<br>&gt;&gt; <br>&gt;&gt;   extension Array : Comparable where T : Comparable {}<br>&gt;&gt;   extension Array : Hashable where T : Hashable {}<br>&gt;&gt; <br>&gt;&gt; I hope not, beause personally, I don&#39;t see how breaking the ability to<br>&gt;&gt; do things like that could be acceptable.  The protocols such as<br>&gt;&gt; Equatable et al. that form the components of “Regular” types are *going*<br>&gt;&gt; to be inherited by many other protocols, so this isn&#39;t just going to<br>&gt;&gt; happen in a nice localized context, either.<br>&gt;<br>&gt; The above is ill-formed as written, because we can’t associate<br>&gt; ‘Equatable’ with either conformance without excluding the other—and<br>&gt; putting it in both places would create an overlapping conformance. <br></p><p>(like we said in your office) I don&#39;t think the key issue is the<br>association of conformances here, but where the Equatable *requirement*<br>is getting satisfied.<br></p><p>&gt;<br>&gt; So, the fix is to explicitly spell out the Equatable conformance:<br>&gt;<br>&gt; 	extension Array: Equatable where T: Equatable { } okay! this is the Equatable conformance for Array<br></p><p>This isn&#39;t a terrible answer.<br></p><p>If we could know that no extensions related to the Comparable or<br>Hashable conformance were supplying the Equatable requirement, I think<br>we could allow it to be omitted, though.  I bet you&#39;re going to tell me<br>we can&#39;t know that, but isn&#39;t it enough to use the information we have<br>statically at the time we see the above extensions?<br></p><p>&gt; Note that this conformance is less-specialized than both the “Array:<br>&gt; Comparable” and “Array: Hashable” conformances, which is important:<br>&gt; one cannot satisfy “Hashable” (or “Comparable”) without satisfying<br>&gt; “Equatable”, so that Equatable conformance has to exist and has to be<br>&gt; usable from the Hashable and Comparable conformances.<br></p><p>Suppose I had written:<br></p><p>extension Array where T: Equatable {<br>    static func ==(x: Array, y: Array) -&gt; Bool { ... }<br>}<br></p><p>Why isn&#39;t that enough to allow me to avoid writing the Equatable<br>conformance?  I&#39;m not asking because I think it&#39;s important to avoid it<br>once I&#39;ve written all of the above.  I&#39;m just trying to probe/understand<br>the model.<br></p><p>&gt;&gt;&gt; However, in cases where there is a reasonable ordering between the two<br>&gt;&gt;&gt; constrained extensions (i.e., one is more specialized than the other),<br>&gt;&gt;&gt; the less specialized constrained extension should &quot;win&quot; the implied<br>&gt;&gt;&gt; conformance. <br>&gt;&gt; <br>&gt;&gt; “Less specialized wins” is surprising at the very least!  I&#39;ve only ever<br>&gt;&gt; seen the opposite rule (e.g. in overload resolution).  What&#39;s the<br>&gt;&gt; rationale for this approach?<br>&gt;<br>&gt; You need the most-general implementation so that conformance can be<br>&gt; used by other constrained extensions, the way the ‘Array: Equatable’<br>&gt; gets used by ‘Array: Hashable’ and ‘Array: Comparable’.<br></p><p>Are you sure we don&#39;t want the most specialized common ancestor of all<br>the constrained extensions?<br></p><p>&gt;&gt;&gt; Continuing the example from above:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; protocol S: R { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X5&lt;T&gt; { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X5: S where T: S { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // This last extension &quot;wins&quot; the implied conformance to P, because<br>&gt;&gt;&gt; // the extension where &quot;T: R&quot; is less specialized than the one<br>&gt;&gt;&gt; // where &quot;T: S&quot;.<br>&gt;&gt;&gt; extension X5: R where T: R { }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thus, the rule for placing implied conformances is to pick the *least<br>&gt;&gt;&gt; specialized* extension that implies the conformance. If there is more<br>&gt;&gt;&gt; than one such extension, then either:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. All such extensions are not constrained extensions (i.e., they have<br>&gt;&gt;&gt; no requirements beyond what the type requires), in which case Swift<br>&gt;&gt;&gt; can continue to choose arbitrarily among the extensions, <br>&gt;&gt; <br>&gt;&gt; Surely that can&#39;t be the right long-term design?<br>&gt;<br>&gt; When all of the extensions are unconstrained, it still doesn’t matter<br>&gt; to the user where the conformance goes. In truth, this rule extends to<br>&gt; groups of extensions that have the *same* constraints—it doesn’t<br>&gt; matter which one we pick.<br></p><p>Seems to me it does if they define different semantics!  What am I<br>missing?<br></p><p>&gt;&gt;&gt; or<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. All such extensions are constrained extensions, in which case the<br>&gt;&gt;&gt; program is ill-formed due to the ambiguity. The developer can<br>&gt;&gt;&gt; explicitly specify conformance to the protocol to disambiguate.<br>&gt;&gt; <br>&gt;&gt; I&#39;m really concerned about the understandability of this model.  It<br>&gt;&gt; doesn&#39;t seem rational or consistent with other choices in the<br>&gt;&gt; language. Now maybe I&#39;m missing something, but in that case I think you<br>&gt;&gt; haven&#39;t given a clear/precise enough description of the rules.  But the<br>&gt;&gt; next section looks like it might clear things up for me...<br>&gt;&gt; <br>&gt;&gt; ...(I&#39;m sorry to say it didn’t)<br>&gt;<br>&gt; While the exposition can be improved somewhat, placement of implied<br>&gt; conformances is fairly tricky and low-level. It will surface to the<br>&gt; user in cases where the user writes something like your<br>&gt; Comparable/Hashable example:<br>&gt;<br>&gt;&gt;   extension Array : Comparable where T : Comparable {}<br>&gt;&gt;   extension Array : Hashable where T : Hashable {}<br>&gt;<br>&gt; and the compiler needs to complain about the inability to place<br>&gt; ‘Equatable’ in a way that directs the user to the correct answer<br>&gt; without exposing them to the entire chain of reasoning we’re going<br>&gt; through. The diagnostic would need some thought:<br>&gt;<br>&gt; 	error: ‘Array&#39; requires an explicit conformance to ‘Equatable’<br>&gt; 	due to conflicting implied conformances (from ‘Comparable’ and<br>&gt; 	‘Hashable’)<br></p><p>If we&#39;re not making this illegal:<br></p><p>      extension Foo : Comparable { ... }<br>      extension Foo : Hashable { ... }<br>      // extension Foo : Equatable { ... }<br></p><p>I think it&#39;s going to be tough for people to understand why the<br>overlapping implied conformances are a problem in the other case.<br></p><p>&gt; We can easily produce a Fix-It to create the skeleton of the<br>&gt; conformance:<br>&gt;<br>&gt; 	extension Array: Equatable {<br>&gt; 	  // … <br>&gt; 	}<br>&gt;<br>&gt; With some heroics involving, e.g., intersecting the requirements, we might be able to have the Fix-It put in a guess at the ‘where’ clause:<br>&gt;<br>&gt; 	extension Array: Equatable where T: Equatable {<br>&gt; 	  // … <br>&gt; 	}<br>&gt;<br>&gt; but that might not be necessary.<br>&gt;<br>&gt; Now, I do think it’s important to note that neither of the Comparable<br>&gt; or Hashable conformances we’ve shown actually has what Equatable<br>&gt; needs—it doesn’t provide an ‘==‘ operator. The problems become clearer<br>&gt; if we try to write that in both places:<br>&gt;<br>&gt; 	extension Array: Comparable where T: Comparable {<br>&gt; 	  static func ==(lhs: Self, rhs: Self) -&gt; Bool { … }<br>&gt; 	}<br>&gt;<br>&gt; 	extension Array: Comparable where T: Comparable {<br>&gt; 	  static func ==(lhs: Self, rhs: Self) -&gt; Bool { … }<br>&gt; 	}<br>&gt;<br>&gt; Which ‘==‘ makes Array Equatable? The answer depends on the<br>&gt; capabilities of ’T’.<br></p><p>Yes, but we weren&#39;t discussing that scenario.  Can&#39;t we treat these<br>cases differently?<br></p><p>&gt;&gt;&gt; ### Overloading across constrained extensions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One particularly important aspect of the placement rule for implied<br>&gt;&gt;&gt; conformances is that it affects which declarations are used to satisfy<br>&gt;&gt;&gt; a particular requirement. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;  func f()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Q: P { }<br>&gt;&gt;&gt; protocol R: Q { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X1&lt;T&gt; { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X1: Q where T: Q {           // note: implied conformance to P here<br>&gt;&gt;&gt;  func f() {<br>&gt;&gt;&gt;    // #1: basic implementation of &#39;f()&#39;<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension X1: R where T: R {<br>&gt;&gt;&gt;  func f() {<br>&gt;&gt;&gt;    // #2: superfast implementation of f() using some knowledge of &#39;R&#39;<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X2: R {<br>&gt;&gt;&gt;  func f() { }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (X1&lt;X2&gt;() as P).f() // calls #1, which was used to satisfy the requirement for &#39;f&#39;<br>&gt;&gt;&gt; X1&lt;X2&gt;().f()        // calls #2, which is preferred by overload resolution<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Effectively, when satisfying a protocol requirement, one can only<br>&gt;&gt;&gt; choose from members of the type that are guaranteed to available<br>&gt;&gt;&gt; within the extension with which the conformance is associated. <br>&gt;&gt; <br>&gt;&gt; AFAICT, this is the first time that an extension&#39;s association to a<br>&gt;&gt; conformance has ever been visible in the user model, and I am not sure<br>&gt;&gt; that we want to expose it.  I&#39;m *not* saying we *don&#39;t* want to; I&#39;m<br>&gt;&gt; saying it isn&#39;t obvious why we should.<br>&gt;<br>&gt; I guess it’s technically been visible in cross-module cases—you can<br>&gt; see where the implied protocols ended up in the generated interface of<br>&gt; a compiled module—but nobody noticed or cared, so it’s not really part<br>&gt; of the model. It might be that we don’t need to make this concept<br>&gt; visible at all—we just need to tell users when we require them to<br>&gt; write an explicit conformance. We could even omit the “why” from the<br>&gt; diagnostic.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; In this case, the conformance to `P` is placed on the first extension<br>&gt;&gt;&gt; of `X1`, so the only `f()` that can be considered is the `f()` within<br>&gt;&gt;&gt; that extension: the `f()` in the second extension won&#39;t necessarily<br>&gt;&gt;&gt; always be available, because `T` may not conform to `R`. <br>&gt;&gt; <br>&gt;&gt; I don&#39;t see how that&#39;s any different from the `f()` in the first<br>&gt;&gt; extension, which won&#39;t necessarily always be available because `T` may<br>&gt;&gt; not conform to `Q`.<br>&gt;<br>&gt; If you’re looking from the point of view of the first extension, T<br>&gt; does conform to P. That’s the “placement” part: when you say that a<br>&gt; conformance is placed on a particular extension, it’s requirements are<br>&gt; satisfied based on the constraints of that extension.<br></p><p>Oh, I see, you&#39;re explaining the effects of your chosen semantics, not<br>justifying them, here.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; Hence, the call that treats an `X1&lt;X2&gt;` as a `P` gets the first<br>&gt;&gt;&gt; implementation of `X1.f()`. When using the concrete type `X1&lt;X2&gt;`,<br>&gt;&gt;&gt; where `X2` conforms to `R`, both `X.f()` implementations are<br>&gt;&gt;&gt; visible... and the second is more specialized.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Technically, this issue is no different from surprises where (e.g.) a<br>&gt;&gt;&gt; member added to a concrete type in a different module won&#39;t affect an<br>&gt;&gt;&gt; existing protocol conformance. <br>&gt;&gt; <br>&gt;&gt; Let me be absolutely clear that I&#39;m *not* questioning this scheme on<br>&gt;&gt; those grounds.  I think it makes sense for static and dynamic (or<br>&gt;&gt; generic) behaviors of the same spelling to differ sometimes, and it&#39;s<br>&gt;&gt; even a useful design tool (c.f. someCollection.lazy).  However, the fact<br>&gt;&gt; that it arises in some situations and is even sometimes the best design<br>&gt;&gt; choice doesn&#39;t mean that&#39;s the way *this* feature should act in *this*<br>&gt;&gt; situation.  I can&#39;t tell whether you&#39;re suggesting:<br>&gt;&gt; <br>&gt;&gt; a) type safety demands this behavior<br>&gt;&gt; b) it&#39;s the only behavior that&#39;s efficiently implementable<br>&gt;&gt; c) it&#39;s actually the best behavior for the common use cases, or<br>&gt;&gt; d) something else<br>&gt;<br>&gt; It’s weakened forms of (a)-(c):<br>&gt;<br>&gt; aa) It’s guaranteed to provide type safety, without the possibility<br>&gt; for run-time ambiguities or other failures<br>&gt; <br>&gt; bb) It’s efficiently implementable and fits well into the existing<br>&gt; model. I know of partial solutions that allow some late resolution<br>&gt; here that are efficiently implementable and can maintain a lack of<br>&gt; run-time failures, but they require nontrivial engineering effort and<br>&gt; I don’t know how to generalize them <br>&gt;<br>&gt; cc) I suspect that the vast majority of use cases don’t need this kind<br>&gt; of late resolution<br>&gt;<br>&gt;&gt;&gt; 2. Eliminating repetition: the `lazy` wrappers described in the<br>&gt;&gt;&gt; [motivation](#motivation) section could be collapsed into a single<br>&gt;&gt;&gt; wrapper with several conditional conformances. A similar refactoring<br>&gt;&gt;&gt; could also be applied to the range abstractions and slice types in the<br>&gt;&gt;&gt; standard library, making the library itself simpler and smaller. All<br>&gt;&gt;&gt; of these changes are potentially source-breaking and ABI-breaking,<br>&gt;&gt;&gt; because they would remove types that could be used in Swift 3<br>&gt;&gt;&gt; code. However, there are mitigations: generic typealiases could<br>&gt;&gt;&gt; provide source compatibility to Swift 3 clients, and the ABI-breaking<br>&gt;&gt;&gt; aspect is only relevant if conditional conformances and the standard<br>&gt;&gt;&gt; library changes they imply aren&#39;t part of Swift 4.<br>&gt;&gt; <br>&gt;&gt; I think the description “eliminating repetition” does a disservice to<br>&gt;&gt; the actual impact of this feature.  It will result in a massive decrease<br>&gt;&gt; in API surface area, which simplifies the implementation of the library,<br>&gt;&gt; yes, but also makes it far more accessible to users.<br>&gt;<br>&gt; Okay, fair point.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; Aside from the standard library, conditional conformances have an<br>&gt;&gt;&gt; impact on the Swift runtime, which will require specific support to<br>&gt;&gt;&gt; handle dynamic casting. If that runtime support is not available once<br>&gt;&gt;&gt; ABI stability has been declared, then introducing conditional<br>&gt;&gt;&gt; conformances in a later language version either means the feature<br>&gt;&gt;&gt; cannot be deployed backward or that it would provide only more<br>&gt;&gt;&gt; limited, static behavior when used on older runtimes. <br>&gt;&gt; <br>&gt;&gt; It would also mean carrying forward all that implementation and API<br>&gt;&gt; complexity for the forseeable future.<br>&gt;<br>&gt; Yup.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; Hence, there is significant motivation for doing this feature as part<br>&gt;&gt;&gt; of Swift 4. Even if we waited to introduce conditional conformances,<br>&gt;&gt;&gt; we would want to include a hook in the runtime to allow them to be<br>&gt;&gt;&gt; implemented later, to avoid future backward-compatibility issues.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Effect on Resilience<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One of the primary goals of Swift 4 is resilience, which allows<br>&gt;&gt;&gt; libraries to evolve without breaking binary compatibility with the<br>&gt;&gt;&gt; applications that use them. While the specific details of the impact<br>&gt;&gt;&gt; of conditional conformances on resilience will be captured in a<br>&gt;&gt;&gt; more-complete proposal on resilience, possible rules are summarized<br>&gt;&gt;&gt; here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * A conditional conformance cannot be removed in the new version of a<br>&gt;&gt;&gt; library, because existing clients might depend on it.<br>&gt;&gt; <br>&gt;&gt; I think that applies to all conformances.<br>&gt;<br>&gt; Yes, it does.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; * A conditional conformance can be added in a new version of a<br>&gt;&gt;&gt; library, roughly following the rules described in the [library<br>&gt;&gt;&gt; evolution<br>&gt;&gt;&gt; document](https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst#new-conformances). The<br>&gt;&gt;&gt; conformance itself will need to be annotated with the version in which<br>&gt;&gt;&gt; it was introduced.<br>&gt;&gt; <br>&gt;&gt; Presumably this is an ABI-preserving but potentially source-breaking<br>&gt;&gt; change, because of the implied conformance ambiguity issues you<br>&gt;&gt; mentioned earlier... and because of changing overload resolution, etc.?<br>&gt;<br>&gt; Yeah, the issue here is that the conditional conformance would overlap<br>&gt; existing concrete conformances, so you would need to remove those<br>&gt; concrete conformances… except when using an old version of the<br>&gt; library.<br>&gt;<br>&gt;&gt;&gt; * A conditional conformance can be *generalized* in a new version of<br>&gt;&gt;&gt; the library, i.e., it can be effectively replaced by a (possibly<br>&gt;&gt;&gt; conditional) conformance in a new version of the library that is less<br>&gt;&gt;&gt; specialized than the conditional conformance in the older version of<br>&gt;&gt;&gt; the library. For example.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  ```swift<br>&gt;&gt;&gt;  public struct X&lt;T&gt; { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  // Conformance in version 1.0<br>&gt;&gt;&gt;  public extension X: Sequence where T: Collection { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  // Can be replaced by this less-specialized conformance in version 1.1<br>&gt;&gt;&gt;  public extension X: Sequence where T: Sequence { ... }<br>&gt;&gt;&gt;  ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Such conformances would likely need some kind of annotation.<br>&gt;&gt; <br>&gt;&gt; Ditto?<br>&gt;<br>&gt; Yup.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The most common request related to conditional conformances is to<br>&gt;&gt;&gt; allow a (constrained) protocol extension to declare conformance to<br>&gt;&gt;&gt; a protocol. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; extension Collection: Equatable where Iterator.Element: Equatable {<br>&gt;&gt;&gt;  static func ==(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;    // ...<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This protocol extension will make any `Collection` of `Equatable`<br>&gt;&gt;&gt; elements `Equatable`, which is a powerful feature that could be put to<br>&gt;&gt;&gt; good use. Introducing conditional conformances for protocol extensions<br>&gt;&gt;&gt; would exacerbate the problem of overlapping conformances, because it<br>&gt;&gt;&gt; would be unreasonable to say that the existence of the above protocol<br>&gt;&gt;&gt; extension means that no type that conforms to `Collection` could<br>&gt;&gt;&gt; declare its own conformance to `Equatable`, conditional or otherwise.<br>&gt;&gt; <br>&gt;&gt; ...which is part of why I think we need better rules about overlap than<br>&gt;&gt; the ones proposed here.  I anticipate a repetition of the pattern we<br>&gt;&gt; have today, where Array provides == and != but can&#39;t conform to<br>&gt;&gt; Equatable, just on a different level.  That has always felt wrong.  Now<br>&gt;&gt; we&#39;ll do the same thing with Collection, so *at least* you don&#39;t have to<br>&gt;&gt; write the == operator when you write the conditional conformance.<br>&gt;<br>&gt; Yes, there will be repetition. To be concrete, one would end up with this:<br>&gt;<br>&gt; extension RangeReplaceableCollection where Iterator.Element: Equatable {<br>&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;     // implement == efficiently...<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; but each type that forms to Collection will still have to state its<br>&gt; conformance to Equatable, even though it will often be empty, e.g.,<br>&gt;<br>&gt; 	extension Array: Equatable where Element: Equatable { }<br>&gt;<br>&gt; We are still in a better place than we were in Swift 3, where there<br>&gt; was *no* way to make Array conform to Equatable, but in these cases<br>&gt; it’ll still feel boilerplate-y.<br></p><p>Yes, a step forward is a step forward.<br></p><p>Thanks!<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0143: Conditional Conformances</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September 30, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Sep 30, 2016, at 1:41 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Sep 30 2016, Douglas Gregor &lt;dgregor-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Sep 29, 2016, at 10:16 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Obviously I&#39;m a huge +1 for this feature, but I have some concerns and<br>&gt;&gt;&gt; questions about the particulars.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Wed Sep 28 2016, Joe Groff &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Conditional conformances also have a run-time aspect, because a<br>&gt;&gt;&gt;&gt; dynamic check for a protocol conformance might rely on the evaluation<br>&gt;&gt;&gt;&gt; of the extra requirements needed to successfully use a conditional<br>&gt;&gt;&gt;&gt; conformance. For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt; func doSomething()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct S: P {<br>&gt;&gt;&gt;&gt; func doSomething() { print(&quot;S&quot;) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Array conforms to P if it&#39;s element type conforms to P<br>&gt;&gt;&gt;&gt; extension Array: P where Element: P {<br>&gt;&gt;&gt;&gt; func doSomething() {<br>&gt;&gt;&gt;&gt;   for value in self {<br>&gt;&gt;&gt;&gt;     value.doSomething()<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Dynamically query and use conformance to P.<br>&gt;&gt;&gt;&gt; func doSomethingIfP(_ value: Any) {<br>&gt;&gt;&gt;&gt; if let p = value as? P {<br>&gt;&gt;&gt;&gt;   p.doSomething()<br>&gt;&gt;&gt;&gt; } else {<br>&gt;&gt;&gt;&gt;   print(&quot;Not a P&quot;)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; doSomethingIfP([S(), S(), S()]) // prints &quot;S&quot; three times<br>&gt;&gt;&gt;&gt; doSomethingIfP([1, 2, 3])       // prints &quot;Not a P&quot;<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The `if-let` in `doSomethingIfP(_:)` dynamically queries whether the<br>&gt;&gt;&gt;&gt; type stored in `value` conforms to the protocol `P`. In the case of an<br>&gt;&gt;&gt;&gt; `Array`, that conformance is conditional, which requires another<br>&gt;&gt;&gt;&gt; dynamic lookup to determine whether the element type conforms to `P`:<br>&gt;&gt;&gt;&gt; in the first call to `doSomethingIfP(_:)`, the lookup finds the<br>&gt;&gt;&gt;&gt; conformance of `S` to `P`. In the second case, there is no conformance<br>&gt;&gt;&gt;&gt; of `Int` to `P`, so the conditional conformance cannot be used. The<br>&gt;&gt;&gt;&gt; desire for this dynamic behavior motivates some of the design<br>&gt;&gt;&gt;&gt; decisions in this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Whether a dynamic evaluation is required at this point seems to depend<br>&gt;&gt;&gt; on how you represent conformance.  Saying “Array conforms conditionally”<br>&gt;&gt;&gt; treats Array as a type, but it might be simpler to treat Array as a<br>&gt;&gt;&gt; family of concrete types.<br>&gt;&gt; <br>&gt;&gt; This is already the case in the runtime; we specialize the metadata for generic types.<br>&gt;&gt; <br>&gt;&gt;&gt; I always envisined it this way: at the moment<br>&gt;&gt;&gt; a module using the concrete type Array&lt;Foo&gt; comes together with an<br>&gt;&gt;&gt; extension (either in that module or in another) that makes Array&lt;T&gt;<br>&gt;&gt;&gt; conform to Equatable depending on properties of T, that extension is<br>&gt;&gt;&gt; evaluated and Array&lt;Foo&gt; is marked as conforming or not.<br>&gt;&gt; <br>&gt;&gt; If the protocol, Array, and Foo all come from different modules, this<br>&gt;&gt; process happens at runtime. Yes, the optimizer could specialize the<br>&gt;&gt; conformance at compile time in many common cases, but you can’t see<br>&gt;&gt; every possible specialization without whole-program analysis, so it<br>&gt;&gt; doesn’t change the model.<br>&gt;&gt; <br>&gt;&gt;&gt; Then asking<br>&gt;&gt;&gt; about a type&#39;s conformance is always a simple thing.  But I suppose<br>&gt;&gt;&gt; which approach wins is dependent on many factors, and the other way can<br>&gt;&gt;&gt; be thought of as adding lazy evaluation to the basic model, so if this<br>&gt;&gt;&gt; adds nothing to your thinking please excuse the static.<br>&gt;&gt; <br>&gt;&gt; Without whole-program information, you need to have the runtime<br>&gt;&gt; capability (or disallow the use of this feature in runtime<br>&gt;&gt; queries). Static specialization can be considered an optimization to<br>&gt;&gt; this model.<br>&gt; <br>&gt; I know it has to happen at runtime in the worst case.  I was suggesting<br>&gt; it could happen at load time rather than as a complication of the<br>&gt; dynamic cast machinery.  In principle all the load-time information can<br>&gt; be usefully cached on-disk.<br></p><p>You can’t compute it at load time, either. There might be sane cases, but here’s a fun one involving existential metatypes:<br></p><p>	protocol P { <br>	  static func makeArray() -&gt; [Self] { return [self] }<br>	}<br></p><p>	extension Int: P { }<br></p><p>	extension Array: P where Element: P { }<br></p><p>	func thwartLoadTime(kind: String) {<br>		let meta: P.Type<br>		if kind == “Int” { meta = Int.self }<br>		else { meta = String.self }<br></p><p>		let array: [Any] = meta.makeArray() // Sweet, now I have an array of … something.<br>		print(array is P)         // true or false?<br>	}<br></p><p>&gt;&gt; But, yes, you’re right that (e.g.) overloading across<br>&gt;&gt; differently-constrained extensions and protocol extensions means<br>&gt;&gt; dealing with divergent interfaces… and it’s been a problem for type<br>&gt;&gt; checker and humans both.<br>&gt; <br>&gt; But that&#39;s not going away, so what&#39;s the point in bringing it up?<br></p><p>I don’t want us to introduce new features that make the problem worse, which allowing overlapping conformances would.<br></p><p>&gt;&gt;&gt; <br>&gt;&gt;&gt; Doesn&#39;t this break, then?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  protocol Equatable { ... }<br>&gt;&gt;&gt;  protocol Comparable : Equatable { ... }<br>&gt;&gt;&gt;  protocol Hashable : Equatable { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  extension Array : Comparable where T : Comparable {}<br>&gt;&gt;&gt;  extension Array : Hashable where T : Hashable {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hope not, beause personally, I don&#39;t see how breaking the ability to<br>&gt;&gt;&gt; do things like that could be acceptable.  The protocols such as<br>&gt;&gt;&gt; Equatable et al. that form the components of “Regular” types are *going*<br>&gt;&gt;&gt; to be inherited by many other protocols, so this isn&#39;t just going to<br>&gt;&gt;&gt; happen in a nice localized context, either.<br>&gt;&gt; <br>&gt;&gt; The above is ill-formed as written, because we can’t associate<br>&gt;&gt; ‘Equatable’ with either conformance without excluding the other—and<br>&gt;&gt; putting it in both places would create an overlapping conformance. <br>&gt; <br>&gt; (like we said in your office) I don&#39;t think the key issue is the<br>&gt; association of conformances here, but where the Equatable *requirement*<br>&gt; is getting satisfied.<br></p><p>Yes, that’s true in the user-facing model.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; So, the fix is to explicitly spell out the Equatable conformance:<br>&gt;&gt; <br>&gt;&gt; 	extension Array: Equatable where T: Equatable { } okay! this is the Equatable conformance for Array<br>&gt; <br>&gt; This isn&#39;t a terrible answer.<br></p><p>I think it’s actually a rather good answer: this implementation of Equatable is more general/more reusable than either the Comparable or Hashable versions.<br></p><p>&gt; <br>&gt; If we could know that no extensions related to the Comparable or<br>&gt; Hashable conformance were supplying the Equatable requirement, I think<br>&gt; we could allow it to be omitted, though.  I bet you&#39;re going to tell me<br>&gt; we can&#39;t know that, but isn&#39;t it enough to use the information we have<br>&gt; statically at the time we see the above extensions?<br></p><p>The question you would have to answer is, effectively, “is there a single == to satisfy Equatable that works for all of the constrained extensions?” If you have find declarations to satisfy all of the requirements of the protocol in question, such that each of the constrained extensions can use that one set of declarations to satisfy the same protocol, then maybe it’s plausible… but the result won’t necessarily be as general as “extension Array: Equatable where T: Equatable”. <br></p><p>It’s also another “global” solver, because it needs to satisfy *all* of the requirements of the protocol and *all* of the conditional conformances that imply conformance to that protocol simultaneously to come up with a correct answer. For example, we might have several implementations of == that might work:<br></p><p>extension RangeReplaceableCollection where Element: Equatable {<br>	static func ==(lhs: Self, rhs: Self) -&gt; Bool { /*use ==*/ }<br>}<br></p><p>extension RangeReplaceableCollection where Element: Comparable {<br>	static func ==(lhs: Self, rhs: Self) -&gt; Bool { /*use &lt; and &gt; because we can */ }<br>}<br></p><p>The second == is the better one for &quot;extension Array : Comparable where T : Comparable&quot; but is inapplicable for &quot;extension Array : Hashable where T : Hashable”, so we have to choose the first… <br></p><p>That falls apart if the overlapping conditional conformances are in different modules, of course, because if we only see the &quot;extension Array : Comparable where T : Comparable”, we’ll pick the second ‘==‘… and whoever comes up with &quot;extension Array : Hashable where T : Hashable” in another module will get a failure. The explicit solution of requiring &quot;extension Array: Equatable where T: Equatable” addresses this problem by getting the user involved in creating the appropriate generalization.<br></p><p>&gt; <br>&gt;&gt; Note that this conformance is less-specialized than both the “Array:<br>&gt;&gt; Comparable” and “Array: Hashable” conformances, which is important:<br>&gt;&gt; one cannot satisfy “Hashable” (or “Comparable”) without satisfying<br>&gt;&gt; “Equatable”, so that Equatable conformance has to exist and has to be<br>&gt;&gt; usable from the Hashable and Comparable conformances.<br>&gt; <br>&gt; Suppose I had written:<br>&gt; <br>&gt; extension Array where T: Equatable {<br>&gt;    static func ==(x: Array, y: Array) -&gt; Bool { ... }<br>&gt; }<br>&gt; <br>&gt; Why isn&#39;t that enough to allow me to avoid writing the Equatable<br>&gt; conformance?  I&#39;m not asking because I think it&#39;s important to avoid it<br>&gt; once I&#39;ve written all of the above.  I&#39;m just trying to probe/understand<br>&gt; the model.<br></p><p>If you allowed the above to fix the problem, the answer to the question “when does Array&lt;T&gt;” conform to Equatable?” is still “if T is Hashable or T is Comparable”, which isn’t what we want. We want “it’s Equatable”.<br></p><p>&gt; <br>&gt;&gt;&gt;&gt; However, in cases where there is a reasonable ordering between the two<br>&gt;&gt;&gt;&gt; constrained extensions (i.e., one is more specialized than the other),<br>&gt;&gt;&gt;&gt; the less specialized constrained extension should &quot;win&quot; the implied<br>&gt;&gt;&gt;&gt; conformance. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; “Less specialized wins” is surprising at the very least!  I&#39;ve only ever<br>&gt;&gt;&gt; seen the opposite rule (e.g. in overload resolution).  What&#39;s the<br>&gt;&gt;&gt; rationale for this approach?<br>&gt;&gt; <br>&gt;&gt; You need the most-general implementation so that conformance can be<br>&gt;&gt; used by other constrained extensions, the way the ‘Array: Equatable’<br>&gt;&gt; gets used by ‘Array: Hashable’ and ‘Array: Comparable’.<br>&gt; <br>&gt; Are you sure we don&#39;t want the most specialized common ancestor of all<br>&gt; the constrained extensions?<br></p><p>Yes, that’s correct.<br></p><p>&gt; <br>&gt;&gt;&gt;&gt; Continuing the example from above:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; protocol S: R { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct X5&lt;T&gt; { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension X5: S where T: S { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // This last extension &quot;wins&quot; the implied conformance to P, because<br>&gt;&gt;&gt;&gt; // the extension where &quot;T: R&quot; is less specialized than the one<br>&gt;&gt;&gt;&gt; // where &quot;T: S&quot;.<br>&gt;&gt;&gt;&gt; extension X5: R where T: R { }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thus, the rule for placing implied conformances is to pick the *least<br>&gt;&gt;&gt;&gt; specialized* extension that implies the conformance. If there is more<br>&gt;&gt;&gt;&gt; than one such extension, then either:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. All such extensions are not constrained extensions (i.e., they have<br>&gt;&gt;&gt;&gt; no requirements beyond what the type requires), in which case Swift<br>&gt;&gt;&gt;&gt; can continue to choose arbitrarily among the extensions, <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Surely that can&#39;t be the right long-term design?<br>&gt;&gt; <br>&gt;&gt; When all of the extensions are unconstrained, it still doesn’t matter<br>&gt;&gt; to the user where the conformance goes. In truth, this rule extends to<br>&gt;&gt; groups of extensions that have the *same* constraints—it doesn’t<br>&gt;&gt; matter which one we pick.<br>&gt; <br>&gt; Seems to me it does if they define different semantics!  What am I<br>&gt; missing?<br></p><p>If they have the same constraints, they’ll have the same overload-resolution behavior when picking declarations to satisfy requirements.<br></p><p>&gt; <br>&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. All such extensions are constrained extensions, in which case the<br>&gt;&gt;&gt;&gt; program is ill-formed due to the ambiguity. The developer can<br>&gt;&gt;&gt;&gt; explicitly specify conformance to the protocol to disambiguate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m really concerned about the understandability of this model.  It<br>&gt;&gt;&gt; doesn&#39;t seem rational or consistent with other choices in the<br>&gt;&gt;&gt; language. Now maybe I&#39;m missing something, but in that case I think you<br>&gt;&gt;&gt; haven&#39;t given a clear/precise enough description of the rules.  But the<br>&gt;&gt;&gt; next section looks like it might clear things up for me...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ...(I&#39;m sorry to say it didn’t)<br>&gt;&gt; <br>&gt;&gt; While the exposition can be improved somewhat, placement of implied<br>&gt;&gt; conformances is fairly tricky and low-level. It will surface to the<br>&gt;&gt; user in cases where the user writes something like your<br>&gt;&gt; Comparable/Hashable example:<br>&gt;&gt; <br>&gt;&gt;&gt;  extension Array : Comparable where T : Comparable {}<br>&gt;&gt;&gt;  extension Array : Hashable where T : Hashable {}<br>&gt;&gt; <br>&gt;&gt; and the compiler needs to complain about the inability to place<br>&gt;&gt; ‘Equatable’ in a way that directs the user to the correct answer<br>&gt;&gt; without exposing them to the entire chain of reasoning we’re going<br>&gt;&gt; through. The diagnostic would need some thought:<br>&gt;&gt; <br>&gt;&gt; 	error: ‘Array&#39; requires an explicit conformance to ‘Equatable’<br>&gt;&gt; 	due to conflicting implied conformances (from ‘Comparable’ and<br>&gt;&gt; 	‘Hashable’)<br>&gt; <br>&gt; If we&#39;re not making this illegal:<br>&gt; <br>&gt;      extension Foo : Comparable { ... }<br>&gt;      extension Foo : Hashable { ... }<br>&gt;      // extension Foo : Equatable { ... }<br>&gt; <br>&gt; I think it&#39;s going to be tough for people to understand why the<br>&gt; overlapping implied conformances are a problem in the other case.<br></p><p>Given the negative feedback we got when I tried to require this before, I don’t think it’s wise to require it except in those cases where it is necessary for conditional conformances. And, of course, it would be a source-breaking change to go back and require this for non-conditional conformances.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160930/e469592d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0143: Conditional Conformances</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>September 30, 2016 at 05:00:00pm</p></header><div class="content"><p>on Fri Sep 30 2016, Douglas Gregor &lt;dgregor-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Sep 30, 2016, at 1:41 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Sep 30 2016, Douglas Gregor &lt;dgregor-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Sep 29, 2016, at 10:16 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Obviously I&#39;m a huge +1 for this feature, but I have some concerns and<br>&gt;&gt;&gt;&gt; questions about the particulars.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Wed Sep 28 2016, Joe Groff &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Conditional conformances also have a run-time aspect, because a<br>&gt;&gt;&gt;&gt;&gt; dynamic check for a protocol conformance might rely on the evaluation<br>&gt;&gt;&gt;&gt;&gt; of the extra requirements needed to successfully use a conditional<br>&gt;&gt;&gt;&gt;&gt; conformance. For example:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt; func doSomething()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct S: P {<br>&gt;&gt;&gt;&gt;&gt; func doSomething() { print(&quot;S&quot;) }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Array conforms to P if it&#39;s element type conforms to P<br>&gt;&gt;&gt;&gt;&gt; extension Array: P where Element: P {<br>&gt;&gt;&gt;&gt;&gt; func doSomething() {<br>&gt;&gt;&gt;&gt;&gt;   for value in self {<br>&gt;&gt;&gt;&gt;&gt;     value.doSomething()<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Dynamically query and use conformance to P.<br>&gt;&gt;&gt;&gt;&gt; func doSomethingIfP(_ value: Any) {<br>&gt;&gt;&gt;&gt;&gt; if let p = value as? P {<br>&gt;&gt;&gt;&gt;&gt;   p.doSomething()<br>&gt;&gt;&gt;&gt;&gt; } else {<br>&gt;&gt;&gt;&gt;&gt;   print(&quot;Not a P&quot;)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; doSomethingIfP([S(), S(), S()]) // prints &quot;S&quot; three times<br>&gt;&gt;&gt;&gt;&gt; doSomethingIfP([1, 2, 3])       // prints &quot;Not a P&quot;<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The `if-let` in `doSomethingIfP(_:)` dynamically queries whether the<br>&gt;&gt;&gt;&gt;&gt; type stored in `value` conforms to the protocol `P`. In the case of an<br>&gt;&gt;&gt;&gt;&gt; `Array`, that conformance is conditional, which requires another<br>&gt;&gt;&gt;&gt;&gt; dynamic lookup to determine whether the element type conforms to `P`:<br>&gt;&gt;&gt;&gt;&gt; in the first call to `doSomethingIfP(_:)`, the lookup finds the<br>&gt;&gt;&gt;&gt;&gt; conformance of `S` to `P`. In the second case, there is no conformance<br>&gt;&gt;&gt;&gt;&gt; of `Int` to `P`, so the conditional conformance cannot be used. The<br>&gt;&gt;&gt;&gt;&gt; desire for this dynamic behavior motivates some of the design<br>&gt;&gt;&gt;&gt;&gt; decisions in this proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Whether a dynamic evaluation is required at this point seems to depend<br>&gt;&gt;&gt;&gt; on how you represent conformance.  Saying “Array conforms conditionally”<br>&gt;&gt;&gt;&gt; treats Array as a type, but it might be simpler to treat Array as a<br>&gt;&gt;&gt;&gt; family of concrete types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is already the case in the runtime; we specialize the metadata for generic types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I always envisined it this way: at the moment<br>&gt;&gt;&gt;&gt; a module using the concrete type Array&lt;Foo&gt; comes together with an<br>&gt;&gt;&gt;&gt; extension (either in that module or in another) that makes Array&lt;T&gt;<br>&gt;&gt;&gt;&gt; conform to Equatable depending on properties of T, that extension is<br>&gt;&gt;&gt;&gt; evaluated and Array&lt;Foo&gt; is marked as conforming or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the protocol, Array, and Foo all come from different modules, this<br>&gt;&gt;&gt; process happens at runtime. Yes, the optimizer could specialize the<br>&gt;&gt;&gt; conformance at compile time in many common cases, but you can’t see<br>&gt;&gt;&gt; every possible specialization without whole-program analysis, so it<br>&gt;&gt;&gt; doesn’t change the model.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Then asking<br>&gt;&gt;&gt;&gt; about a type&#39;s conformance is always a simple thing.  But I suppose<br>&gt;&gt;&gt;&gt; which approach wins is dependent on many factors, and the other way can<br>&gt;&gt;&gt;&gt; be thought of as adding lazy evaluation to the basic model, so if this<br>&gt;&gt;&gt;&gt; adds nothing to your thinking please excuse the static.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Without whole-program information, you need to have the runtime<br>&gt;&gt;&gt; capability (or disallow the use of this feature in runtime<br>&gt;&gt;&gt; queries). Static specialization can be considered an optimization to<br>&gt;&gt;&gt; this model.<br>&gt;&gt; <br>&gt;&gt; I know it has to happen at runtime in the worst case.  I was suggesting<br>&gt;&gt; it could happen at load time rather than as a complication of the<br>&gt;&gt; dynamic cast machinery.  In principle all the load-time information can<br>&gt;&gt; be usefully cached on-disk.<br>&gt;<br>&gt; You can’t compute it at load time, either. There might be sane cases, but here’s a fun one involving existential metatypes:<br>&gt;<br>&gt; 	protocol P { <br>&gt; 	  static func makeArray() -&gt; [Self] { return [self] }<br>&gt; 	}<br>&gt;<br>&gt; 	extension Int: P { }<br>&gt;<br>&gt; 	extension Array: P where Element: P { }<br>&gt;<br>&gt; 	func thwartLoadTime(kind: String) {<br>&gt; 		let meta: P.Type<br>&gt; 		if kind == “Int” { meta = Int.self }<br>&gt; 		else { meta = String.self }<br>&gt;<br>&gt; 		let array: [Any] = meta.makeArray() // Sweet, now I have an array of … something.<br>&gt; 		print(array is P)         // true or false?<br>&gt; 	}<br></p><p>And some people think Swift isn&#39;t dynamic enough?! ;-)<br></p><p>&gt;&gt;&gt; But, yes, you’re right that (e.g.) overloading across<br>&gt;&gt;&gt; differently-constrained extensions and protocol extensions means<br>&gt;&gt;&gt; dealing with divergent interfaces… and it’s been a problem for type<br>&gt;&gt;&gt; checker and humans both.<br>&gt;&gt; <br>&gt;&gt; But that&#39;s not going away, so what&#39;s the point in bringing it up?<br>&gt;<br>&gt; I don’t want us to introduce new features that make the problem worse, which allowing overlapping conformances would.<br>&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Doesn&#39;t this break, then?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  protocol Equatable { ... }<br>&gt;&gt;&gt;&gt;  protocol Comparable : Equatable { ... }<br>&gt;&gt;&gt;&gt;  protocol Hashable : Equatable { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  extension Array : Comparable where T : Comparable {}<br>&gt;&gt;&gt;&gt;  extension Array : Hashable where T : Hashable {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I hope not, beause personally, I don&#39;t see how breaking the ability to<br>&gt;&gt;&gt;&gt; do things like that could be acceptable.  The protocols such as<br>&gt;&gt;&gt;&gt; Equatable et al. that form the components of “Regular” types are *going*<br>&gt;&gt;&gt;&gt; to be inherited by many other protocols, so this isn&#39;t just going to<br>&gt;&gt;&gt;&gt; happen in a nice localized context, either.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The above is ill-formed as written, because we can’t associate<br>&gt;&gt;&gt; ‘Equatable’ with either conformance without excluding the other—and<br>&gt;&gt;&gt; putting it in both places would create an overlapping conformance. <br>&gt;&gt; <br>&gt;&gt; (like we said in your office) I don&#39;t think the key issue is the<br>&gt;&gt; association of conformances here, but where the Equatable *requirement*<br>&gt;&gt; is getting satisfied.<br>&gt;<br>&gt; Yes, that’s true in the user-facing model.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, the fix is to explicitly spell out the Equatable conformance:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	extension Array: Equatable where T: Equatable { } okay! this is the Equatable conformance for Array<br>&gt;&gt; <br>&gt;&gt; This isn&#39;t a terrible answer.<br>&gt;<br>&gt; I think it’s actually a rather good answer: this implementation of<br>&gt; Equatable is more general/more reusable than either the Comparable or<br>&gt; Hashable versions.<br></p><p>Excellent point; that changes my view of this quite a bit, actually.<br></p><p>&gt;&gt; If we could know that no extensions related to the Comparable or<br>&gt;&gt; Hashable conformance were supplying the Equatable requirement, I think<br>&gt;&gt; we could allow it to be omitted, though.  I bet you&#39;re going to tell me<br>&gt;&gt; we can&#39;t know that, but isn&#39;t it enough to use the information we have<br>&gt;&gt; statically at the time we see the above extensions?<br>&gt;<br>&gt; The question you would have to answer is, effectively, “is there a<br>&gt; single == to satisfy Equatable that works for all of the constrained<br>&gt; extensions?” If you have find declarations to satisfy all of the<br>&gt; requirements of the protocol in question, such that each of the<br>&gt; constrained extensions can use that one set of declarations to satisfy<br>&gt; the same protocol, then maybe it’s plausible… but the result won’t<br>&gt; necessarily be as general as “extension Array: Equatable where T:<br>&gt; Equatable”.<br>&gt;<br>&gt; It’s also another “global” solver, because it needs to satisfy *all*<br>&gt; of the requirements of the protocol and *all* of the conditional<br>&gt; conformances that imply conformance to that protocol simultaneously to<br>&gt; come up with a correct answer. For example, we might have several<br>&gt; implementations of == that might work:<br>&gt;<br>&gt; extension RangeReplaceableCollection where Element: Equatable {<br>&gt; 	static func ==(lhs: Self, rhs: Self) -&gt; Bool { /*use ==*/ }<br>&gt; }<br>&gt;<br>&gt; extension RangeReplaceableCollection where Element: Comparable {<br>&gt; 	static func ==(lhs: Self, rhs: Self) -&gt; Bool { /*use &lt; and &gt; because we can */ }<br>&gt; }<br>&gt;<br>&gt; The second == is the better one for &quot;extension Array : Comparable<br>&gt; where T : Comparable&quot; but is inapplicable for &quot;extension Array :<br>&gt; Hashable where T : Hashable”, so we have to choose the first…<br>&gt;<br>&gt; That falls apart if the overlapping conditional conformances are in<br>&gt; different modules, of course, because if we only see the &quot;extension<br>&gt; Array : Comparable where T : Comparable”, we’ll pick the second ‘==‘…<br>&gt; and whoever comes up with &quot;extension Array : Hashable where T :<br>&gt; Hashable” in another module will get a failure. The explicit solution<br>&gt; of requiring &quot;extension Array: Equatable where T: Equatable” addresses<br>&gt; this problem by getting the user involved in creating the appropriate<br>&gt; generalization.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; Note that this conformance is less-specialized than both the “Array:<br>&gt;&gt;&gt; Comparable” and “Array: Hashable” conformances, which is important:<br>&gt;&gt;&gt; one cannot satisfy “Hashable” (or “Comparable”) without satisfying<br>&gt;&gt;&gt; “Equatable”, so that Equatable conformance has to exist and has to be<br>&gt;&gt;&gt; usable from the Hashable and Comparable conformances.<br>&gt;&gt; <br>&gt;&gt; Suppose I had written:<br>&gt;&gt; <br>&gt;&gt; extension Array where T: Equatable {<br>&gt;&gt;    static func ==(x: Array, y: Array) -&gt; Bool { ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Why isn&#39;t that enough to allow me to avoid writing the Equatable<br>&gt;&gt; conformance?  I&#39;m not asking because I think it&#39;s important to avoid it<br>&gt;&gt; once I&#39;ve written all of the above.  I&#39;m just trying to probe/understand<br>&gt;&gt; the model.<br>&gt;<br>&gt; If you allowed the above to fix the problem, the answer to the<br>&gt; question “when does Array&lt;T&gt;” conform to Equatable?” is still “if T is<br>&gt; Hashable or T is Comparable”, which isn’t what we want. We want “it’s<br>&gt; Equatable”.<br></p><p>Yep.<br></p><p>&gt;&gt;&gt;&gt;&gt; However, in cases where there is a reasonable ordering between the two<br>&gt;&gt;&gt;&gt;&gt; constrained extensions (i.e., one is more specialized than the other),<br>&gt;&gt;&gt;&gt;&gt; the less specialized constrained extension should &quot;win&quot; the implied<br>&gt;&gt;&gt;&gt;&gt; conformance. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; “Less specialized wins” is surprising at the very least!  I&#39;ve only ever<br>&gt;&gt;&gt;&gt; seen the opposite rule (e.g. in overload resolution).  What&#39;s the<br>&gt;&gt;&gt;&gt; rationale for this approach?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You need the most-general implementation so that conformance can be<br>&gt;&gt;&gt; used by other constrained extensions, the way the ‘Array: Equatable’<br>&gt;&gt;&gt; gets used by ‘Array: Hashable’ and ‘Array: Comparable’.<br>&gt;&gt; <br>&gt;&gt; Are you sure we don&#39;t want the most specialized common ancestor of all<br>&gt;&gt; the constrained extensions?<br>&gt;<br>&gt; Yes, that’s correct.<br></p><p>We do or don&#39;t want that?<br></p><p>&gt;&gt;&gt;&gt;&gt; Continuing the example from above:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; protocol S: R { }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct X5&lt;T&gt; { }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension X5: S where T: S { }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // This last extension &quot;wins&quot; the implied conformance to P, because<br>&gt;&gt;&gt;&gt;&gt; // the extension where &quot;T: R&quot; is less specialized than the one<br>&gt;&gt;&gt;&gt;&gt; // where &quot;T: S&quot;.<br>&gt;&gt;&gt;&gt;&gt; extension X5: R where T: R { }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thus, the rule for placing implied conformances is to pick the *least<br>&gt;&gt;&gt;&gt;&gt; specialized* extension that implies the conformance. If there is more<br>&gt;&gt;&gt;&gt;&gt; than one such extension, then either:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. All such extensions are not constrained extensions (i.e., they have<br>&gt;&gt;&gt;&gt;&gt; no requirements beyond what the type requires), in which case Swift<br>&gt;&gt;&gt;&gt;&gt; can continue to choose arbitrarily among the extensions, <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Surely that can&#39;t be the right long-term design?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When all of the extensions are unconstrained, it still doesn’t matter<br>&gt;&gt;&gt; to the user where the conformance goes. In truth, this rule extends to<br>&gt;&gt;&gt; groups of extensions that have the *same* constraints—it doesn’t<br>&gt;&gt;&gt; matter which one we pick.<br>&gt;&gt; <br>&gt;&gt; Seems to me it does if they define different semantics!  What am I<br>&gt;&gt; missing?<br>&gt;<br>&gt; If they have the same constraints, they’ll have the same<br>&gt; overload-resolution behavior when picking declarations to satisfy<br>&gt; requirements.<br></p><p>Ya lost me here.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. All such extensions are constrained extensions, in which case the<br>&gt;&gt;&gt;&gt;&gt; program is ill-formed due to the ambiguity. The developer can<br>&gt;&gt;&gt;&gt;&gt; explicitly specify conformance to the protocol to disambiguate.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m really concerned about the understandability of this model.  It<br>&gt;&gt;&gt;&gt; doesn&#39;t seem rational or consistent with other choices in the<br>&gt;&gt;&gt;&gt; language. Now maybe I&#39;m missing something, but in that case I think you<br>&gt;&gt;&gt;&gt; haven&#39;t given a clear/precise enough description of the rules.  But the<br>&gt;&gt;&gt;&gt; next section looks like it might clear things up for me...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ...(I&#39;m sorry to say it didn’t)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While the exposition can be improved somewhat, placement of implied<br>&gt;&gt;&gt; conformances is fairly tricky and low-level. It will surface to the<br>&gt;&gt;&gt; user in cases where the user writes something like your<br>&gt;&gt;&gt; Comparable/Hashable example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  extension Array : Comparable where T : Comparable {}<br>&gt;&gt;&gt;&gt;  extension Array : Hashable where T : Hashable {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and the compiler needs to complain about the inability to place<br>&gt;&gt;&gt; ‘Equatable’ in a way that directs the user to the correct answer<br>&gt;&gt;&gt; without exposing them to the entire chain of reasoning we’re going<br>&gt;&gt;&gt; through. The diagnostic would need some thought:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	error: ‘Array&#39; requires an explicit conformance to ‘Equatable’<br>&gt;&gt;&gt; 	due to conflicting implied conformances (from ‘Comparable’ and<br>&gt;&gt;&gt; 	‘Hashable’)<br>&gt;&gt; <br>&gt;&gt; If we&#39;re not making this illegal:<br>&gt;&gt; <br>&gt;&gt;      extension Foo : Comparable { ... }<br>&gt;&gt;      extension Foo : Hashable { ... }<br>&gt;&gt;      // extension Foo : Equatable { ... }<br>&gt;&gt; <br>&gt;&gt; I think it&#39;s going to be tough for people to understand why the<br>&gt;&gt; overlapping implied conformances are a problem in the other case.<br>&gt;<br>&gt; Given the negative feedback we got when I tried to require this<br>&gt; before, I don’t think it’s wise to require it except in those cases<br>&gt; where it is necessary for conditional conformances. And, of course, it<br>&gt; would be a source-breaking change to go back and require this for<br>&gt; non-conditional conformances.<br></p><p>I&#39;m not saying we should make the above illegal!  I&#39;m saying we need a<br>better way to explain why the conditional case doesn&#39;t work.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0143: Conditional Conformances</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>October  5, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Sep 30, 2016, at 5:59 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Sep 30 2016, Douglas Gregor &lt;dgregor-AT-apple.com &lt;http://dgregor-at-apple.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Sep 30, 2016, at 1:41 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Sep 30 2016, Douglas Gregor &lt;dgregor-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; However, in cases where there is a reasonable ordering between the two<br>&gt;&gt;&gt;&gt;&gt;&gt; constrained extensions (i.e., one is more specialized than the other),<br>&gt;&gt;&gt;&gt;&gt;&gt; the less specialized constrained extension should &quot;win&quot; the implied<br>&gt;&gt;&gt;&gt;&gt;&gt; conformance. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; “Less specialized wins” is surprising at the very least!  I&#39;ve only ever<br>&gt;&gt;&gt;&gt;&gt; seen the opposite rule (e.g. in overload resolution).  What&#39;s the<br>&gt;&gt;&gt;&gt;&gt; rationale for this approach?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You need the most-general implementation so that conformance can be<br>&gt;&gt;&gt;&gt; used by other constrained extensions, the way the ‘Array: Equatable’<br>&gt;&gt;&gt;&gt; gets used by ‘Array: Hashable’ and ‘Array: Comparable’.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are you sure we don&#39;t want the most specialized common ancestor of all<br>&gt;&gt;&gt; the constrained extensions?<br>&gt;&gt; <br>&gt;&gt; Yes, that’s correct.<br>&gt; <br>&gt; We do or don&#39;t want that?<br></p><p>We want the most specialized common ancestor, i.e., the best implementation that can be used by all of the extensions that imply a conformance to Equatable.<br></p><p>&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Continuing the example from above:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol S: R { }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; struct X5&lt;T&gt; { }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension X5: S where T: S { }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // This last extension &quot;wins&quot; the implied conformance to P, because<br>&gt;&gt;&gt;&gt;&gt;&gt; // the extension where &quot;T: R&quot; is less specialized than the one<br>&gt;&gt;&gt;&gt;&gt;&gt; // where &quot;T: S&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt; extension X5: R where T: R { }<br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thus, the rule for placing implied conformances is to pick the *least<br>&gt;&gt;&gt;&gt;&gt;&gt; specialized* extension that implies the conformance. If there is more<br>&gt;&gt;&gt;&gt;&gt;&gt; than one such extension, then either:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1. All such extensions are not constrained extensions (i.e., they have<br>&gt;&gt;&gt;&gt;&gt;&gt; no requirements beyond what the type requires), in which case Swift<br>&gt;&gt;&gt;&gt;&gt;&gt; can continue to choose arbitrarily among the extensions, <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Surely that can&#39;t be the right long-term design?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When all of the extensions are unconstrained, it still doesn’t matter<br>&gt;&gt;&gt;&gt; to the user where the conformance goes. In truth, this rule extends to<br>&gt;&gt;&gt;&gt; groups of extensions that have the *same* constraints—it doesn’t<br>&gt;&gt;&gt;&gt; matter which one we pick.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Seems to me it does if they define different semantics!  What am I<br>&gt;&gt;&gt; missing?<br>&gt;&gt; <br>&gt;&gt; If they have the same constraints, they’ll have the same<br>&gt;&gt; overload-resolution behavior when picking declarations to satisfy<br>&gt;&gt; requirements.<br>&gt; <br>&gt; Ya lost me here.<br></p><p>Consider this simplistic example:<br></p><p>protocol P {<br>  func f()<br>}<br>protocol Q: P { }<br>protocol R: P { }<br></p><p>struct X { }<br>extension X: P { }<br>extension X {<br>  func f() { … }<br>}<br></p><p>It doesn’t actually matter whether the declaration of X’s conformance to P is placed on the first extension or on the second extension. It’ll still use that same ‘f’ to satisfy P’s requirement. This is still to if we have two conditional conformances where the extensions have the same requirements.<br></p><p>struct Y&lt;T&gt; { }<br>extension T: P where T: P { }<br>extension T: P where T: P {<br>  func f() { … }<br>}<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2. All such extensions are constrained extensions, in which case the<br>&gt;&gt;&gt;&gt;&gt;&gt; program is ill-formed due to the ambiguity. The developer can<br>&gt;&gt;&gt;&gt;&gt;&gt; explicitly specify conformance to the protocol to disambiguate.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m really concerned about the understandability of this model.  It<br>&gt;&gt;&gt;&gt;&gt; doesn&#39;t seem rational or consistent with other choices in the<br>&gt;&gt;&gt;&gt;&gt; language. Now maybe I&#39;m missing something, but in that case I think you<br>&gt;&gt;&gt;&gt;&gt; haven&#39;t given a clear/precise enough description of the rules.  But the<br>&gt;&gt;&gt;&gt;&gt; next section looks like it might clear things up for me...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ...(I&#39;m sorry to say it didn’t)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While the exposition can be improved somewhat, placement of implied<br>&gt;&gt;&gt;&gt; conformances is fairly tricky and low-level. It will surface to the<br>&gt;&gt;&gt;&gt; user in cases where the user writes something like your<br>&gt;&gt;&gt;&gt; Comparable/Hashable example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension Array : Comparable where T : Comparable {}<br>&gt;&gt;&gt;&gt;&gt; extension Array : Hashable where T : Hashable {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and the compiler needs to complain about the inability to place<br>&gt;&gt;&gt;&gt; ‘Equatable’ in a way that directs the user to the correct answer<br>&gt;&gt;&gt;&gt; without exposing them to the entire chain of reasoning we’re going<br>&gt;&gt;&gt;&gt; through. The diagnostic would need some thought:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	error: ‘Array&#39; requires an explicit conformance to ‘Equatable’<br>&gt;&gt;&gt;&gt; 	due to conflicting implied conformances (from ‘Comparable’ and<br>&gt;&gt;&gt;&gt; 	‘Hashable’)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we&#39;re not making this illegal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     extension Foo : Comparable { ... }<br>&gt;&gt;&gt;     extension Foo : Hashable { ... }<br>&gt;&gt;&gt;     // extension Foo : Equatable { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it&#39;s going to be tough for people to understand why the<br>&gt;&gt;&gt; overlapping implied conformances are a problem in the other case.<br>&gt;&gt; <br>&gt;&gt; Given the negative feedback we got when I tried to require this<br>&gt;&gt; before, I don’t think it’s wise to require it except in those cases<br>&gt;&gt; where it is necessary for conditional conformances. And, of course, it<br>&gt;&gt; would be a source-breaking change to go back and require this for<br>&gt;&gt; non-conditional conformances.<br>&gt; <br>&gt; I&#39;m not saying we should make the above illegal!  I&#39;m saying we need a<br>&gt; better way to explain why the conditional case doesn&#39;t work.<br></p><p>Ah; that I agree with .<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161005/f95ceed8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
