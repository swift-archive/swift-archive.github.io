<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>October  7, 2016 at 08:00:00am</p></header><div class="content"><p>Hello community,<br></p><p>From all the proposals which has gone into Swift 3, [SE-0025] Scoped Access Level is the only one I’m having second thoughts about. Before launching a discussion around it, I’m curious to know if it&#39;s worth discussing it or if the “ship has sailed”. As the plan is to allow future versions of Swift to break source-compatibility in certain rare scenarios, perhaps we have a chance to reconsider certain proposals?<br></p><p>Regards,<br>David.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/d530cd80/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>October  7, 2016 at 09:00:00am</p></header><div class="content"><p>Do language ships ever sail?<br></p><p>New POV’s should always be welcome.<br></p><p>Just spit it out…<br></p><p>Rien.<br></p><p><br></p><p>&gt; On 07 Oct 2016, at 08:39, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello community,<br>&gt; <br>&gt; From all the proposals which has gone into Swift 3, [SE-0025] Scoped Access Level is the only one I’m having second thoughts about. Before launching a discussion around it, I’m curious to know if it&#39;s worth discussing it or if the “ship has sailed”. As the plan is to allow future versions of Swift to break source-compatibility in certain rare scenarios, perhaps we have a chance to reconsider certain proposals?<br>&gt; <br>&gt; Regards,<br>&gt; David.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October  7, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 7 Oct 2016, at 07:39, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello community,<br>&gt; <br>&gt; From all the proposals which has gone into Swift 3, [SE-0025] Scoped Access Level is the only one I’m having second thoughts about. Before launching a discussion around it, I’m curious to know if it&#39;s worth discussing it or if the “ship has sailed”. As the plan is to allow future versions of Swift to break source-compatibility in certain rare scenarios, perhaps we have a chance to reconsider certain proposals?<br>&gt; <br>&gt; Regards,<br>&gt; David.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>What in particular don&#39;t you like about it?<br></p><p>Personally I still don&#39;t like the use of fileprivate as the keyword, I was very much in favour of a bracketed system like:<br></p><p>	private(scope)		Current private (I think, it doesn&#39;t appear to be equivalent to protected in other languages anyway so I wouldn&#39;t call it type).<br>	private(file)		Current fileprivate<br>	private(module)	Current internal/default when omitted<br>	public			Current public<br></p><p>I favour this because it groups all restrictive access levels under private (since they&#39;re all some form of private) with an optional modifier that&#39;s explicit about what it&#39;s for. Also, it would have scope to move things like final into a modifier too, so you might declare a method as public(final), or public(open) if that&#39;s implemented later and so-on. Just seems like a generally more flexible setup that also reduces the number of keywords required.<br></p><p>Some may feel it&#39;s noisy, but personally I don&#39;t see it as a problem as it always comes before the func/var/let keyword, generics and function name, so it&#39;s not like it&#39;s near anything where the (minor) noise reduces readability.<br></p><p>But yeah, having used the new fileprivate for a little while I just don&#39;t like it; it may partly come down to the fact that I use fileprivate a lot more than I use regular private. If we were to adopt the above scheme I would recommend that private(file) be the default for use of the plain private keyword, unless we gain the ability to specify private(type) (i.e- protected in most other languages), as private(scope) seems like it&#39;s the less common, at least in my experience.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/06a3d6d5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>October  7, 2016 at 02:00:00pm</p></header><div class="content"><p>On 07.10.2016 11:24, Haravikk via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On 7 Oct 2016, at 07:39, David Hart via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hello community,<br>&gt;&gt;<br>&gt;&gt; From all the proposals which has gone into Swift 3, *[SE-0025] Scoped<br>&gt;&gt; Access Level* is the only one I’m having second thoughts about. Before<br>&gt;&gt; launching a discussion around it, I’m curious to know if it&#39;s worth<br>&gt;&gt; discussing it or if the “ship has sailed”. As the plan is to allow future<br>&gt;&gt; versions of Swift to break source-compatibility in certain rare<br>&gt;&gt; scenarios, perhaps we have a chance to reconsider certain proposals?<br>&gt;&gt;<br>&gt;&gt; Regards,<br>&gt;&gt; David.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; What in particular don&#39;t you like about it?<br>&gt;<br>&gt; Personally I still don&#39;t like the use of fileprivate as the keyword, I was<br>&gt; very much in favour of a bracketed system like:<br></p><p>FWIW, I fully agree with you and I do believe your suggestion just much <br>better than current status quo. It is much clearer what private(module) <br>means than &#39;internal&#39; and private(scope) than just &#39;private&#39;, private(file) <br>is 1000% better than fileprivate ;-). Currently IMO names are not <br>consistent : if we have &#39;fileprivate&#39;, then we need &#39;scopeprivate&#39; and <br>&#39;moduleprivate&#39;.. but these are just ugly(just like fileprivate ;-) )<br>IMO<br></p><p>&gt;<br>&gt; private(scope)Current private (I think, it doesn&#39;t appear to be equivalent<br>&gt; to protected in other languages anyway so I wouldn&#39;t call it type).<br>&gt; private(file)Current fileprivate<br>&gt; private(module)Current internal/default when omitted<br>&gt; publicCurrent public<br>&gt;<br>&gt; I favour this because it groups all restrictive access levels under private<br>&gt; (since they&#39;re all some form of private) with an optional modifier that&#39;s<br>&gt; explicit about what it&#39;s for. Also, it would have scope to move things like<br>&gt; final into a modifier too, so you might declare a method as public(final),<br>&gt; or public(open) if that&#39;s implemented later and so-on. Just seems like a<br>&gt; generally more flexible setup that also reduces the number of keywords<br>&gt; required.<br>&gt;<br>&gt; Some may feel it&#39;s noisy, but personally I don&#39;t see it as a problem as it<br>&gt; always comes before the func/var/let keyword, generics and function name,<br>&gt; so it&#39;s not like it&#39;s near anything where the (minor) noise reduces<br>&gt; readability.<br>&gt;<br>&gt; But yeah, having used the new fileprivate for a little while I just don&#39;t<br>&gt; like it; it may partly come down to the fact that I use fileprivate a lot<br>&gt; more than I use regular private. If we were to adopt the above scheme I<br>&gt; would recommend that private(file) be the default for use of the plain<br>&gt; private keyword, unless we gain the ability to specify private(type) (i.e-<br>&gt; protected in most other languages), as private(scope) seems like it&#39;s the<br>&gt; less common, at least in my experience.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October  7, 2016 at 11:00:00am</p></header><div class="content"><p>I agree that the keywords could be improved, but private(file) access<br>should not be what &#39;private&#39; means by itself. If I put just &#39;private&#39; in<br>front of something I really mean it should be private to this scope, the<br>most private. I also think the more common use-case would be private(scope)<br>over private(file), you might find if you refactor a bit that a lot of your<br>fileprivate can become private or instead - it&#39;s possible that fileprivate<br>is encouraging you to put things into one file when they should be in<br>multiple files with a better defined &#39;internal&#39; API.<br></p><p>I like the *concept* that &#39;private&#39; is the most private and then it can be<br>relaxed by modifiers (file) (module) (perhaps-other-stuff), but I&#39;m not<br>convinced that &#39;private&#39; is really an appropriate word for something that<br>is accessible anywhere within a module. Though I agree that &#39;internal&#39;<br>doesn&#39;t really mean much to someone learning the language, and suffers the<br>exact same problem (internal to what?) whereas private(module) does express<br>that a bit better.<br></p><p>On Fri, 7 Oct 2016 at 09:26 Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 7 Oct 2016, at 07:39, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hello community,<br>&gt;<br>&gt; From all the proposals which has gone into Swift 3, *[SE-0025] Scoped<br>&gt; Access Level* is the only one I’m having second thoughts about. Before<br>&gt; launching a discussion around it, I’m curious to know if it&#39;s worth<br>&gt; discussing it or if the “ship has sailed”. As the plan is to allow future<br>&gt; versions of Swift to break source-compatibility in certain rare scenarios,<br>&gt; perhaps we have a chance to reconsider certain proposals?<br>&gt;<br>&gt; Regards,<br>&gt; David.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; What in particular don&#39;t you like about it?<br>&gt;<br>&gt; Personally I still don&#39;t like the use of fileprivate as the keyword, I was<br>&gt; very much in favour of a bracketed system like:<br>&gt;<br>&gt; private(scope) Current private (I think, it doesn&#39;t appear to be<br>&gt; equivalent to protected in other languages anyway so I wouldn&#39;t call it<br>&gt; type).<br>&gt; private(file) Current fileprivate<br>&gt; private(module) Current internal/default when omitted<br>&gt; public Current public<br>&gt;<br>&gt; I favour this because it groups all restrictive access levels under<br>&gt; private (since they&#39;re all some form of private) with an optional modifier<br>&gt; that&#39;s explicit about what it&#39;s for. Also, it would have scope to move<br>&gt; things like final into a modifier too, so you might declare a method as<br>&gt; public(final), or public(open) if that&#39;s implemented later and so-on. Just<br>&gt; seems like a generally more flexible setup that also reduces the number of<br>&gt; keywords required.<br>&gt;<br>&gt; Some may feel it&#39;s noisy, but personally I don&#39;t see it as a problem as it<br>&gt; always comes before the func/var/let keyword, generics and function name,<br>&gt; so it&#39;s not like it&#39;s near anything where the (minor) noise reduces<br>&gt; readability.<br>&gt;<br>&gt; But yeah, having used the new fileprivate for a little while I just don&#39;t<br>&gt; like it; it may partly come down to the fact that I use fileprivate a lot<br>&gt; more than I use regular private. If we were to adopt the above scheme I<br>&gt; would recommend that private(file) be the default for use of the plain<br>&gt; private keyword, unless we gain the ability to specify private(type) (i.e-<br>&gt; protected in most other languages), as private(scope) seems like it&#39;s the<br>&gt; less common, at least in my experience.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/a23037dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October  7, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On 7 Oct 2016, at 12:11, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt; <br>&gt; I agree that the keywords could be improved, but private(file) access should not be what &#39;private&#39; means by itself. If I put just &#39;private&#39; in front of something I really mean it should be private to this scope, the most private. I also think the more common use-case would be private(scope) over private(file), you might find if you refactor a bit that a lot of your fileprivate can become private or instead - it&#39;s possible that fileprivate is encouraging you to put things into one file when they should be in multiple files with a better defined &#39;internal&#39; API.<br>&gt; <br>&gt; I like the *concept* that &#39;private&#39; is the most private and then it can be relaxed by modifiers (file) (module) (perhaps-other-stuff), but I&#39;m not convinced that &#39;private&#39; is really an appropriate word for something that is accessible anywhere within a module. Though I agree that &#39;internal&#39; doesn&#39;t really mean much to someone learning the language, and suffers the exact same problem (internal to what?) whereas private(module) does express that a bit better.<br></p><p>Yeah I&#39;m a bit undecided on that point myself; like I say I&#39;d really prefer something like private(type) to be the default for my own use-case, but not only do we not have that it probably wouldn&#39;t suit everyone anyway, I think it&#39;s just more that my habit is to implement by extension within the same file. With that in mind maybe scope is the better default for it as you say.<br></p><p>I&#39;m not sure what the OP really wanted to raise on the subject, but if there&#39;s interest for this style of access modifier and it&#39;s in-scope for Swift 4 then I could do a proposal for it as a specific request.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9f3e3f9871fd088e42df4509aa724367?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Adriano Ferreira</string> &lt;adriano.ferreira at me.com&gt;<p>October  7, 2016 at 10:00:00am</p></header><div class="content"><p>+1<br></p><p>I would also rather have:<br></p><p>private(scope)<br>private(file)<br>private(module)<br>etc…<br></p><p>— A<br></p><p>&gt; On Oct 7, 2016, at 4:24 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 7 Oct 2016, at 07:39, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello community,<br>&gt;&gt; <br>&gt;&gt; From all the proposals which has gone into Swift 3, [SE-0025] Scoped Access Level is the only one I’m having second thoughts about. Before launching a discussion around it, I’m curious to know if it&#39;s worth discussing it or if the “ship has sailed”. As the plan is to allow future versions of Swift to break source-compatibility in certain rare scenarios, perhaps we have a chance to reconsider certain proposals?<br>&gt;&gt; <br>&gt;&gt; Regards,<br>&gt;&gt; David.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; What in particular don&#39;t you like about it?<br>&gt; <br>&gt; Personally I still don&#39;t like the use of fileprivate as the keyword, I was very much in favour of a bracketed system like:<br>&gt; <br>&gt; 	private(scope)		Current private (I think, it doesn&#39;t appear to be equivalent to protected in other languages anyway so I wouldn&#39;t call it type).<br>&gt; 	private(file)		Current fileprivate<br>&gt; 	private(module)	Current internal/default when omitted<br>&gt; 	public			Current public<br>&gt; <br>&gt; I favour this because it groups all restrictive access levels under private (since they&#39;re all some form of private) with an optional modifier that&#39;s explicit about what it&#39;s for. Also, it would have scope to move things like final into a modifier too, so you might declare a method as public(final), or public(open) if that&#39;s implemented later and so-on. Just seems like a generally more flexible setup that also reduces the number of keywords required.<br>&gt; <br>&gt; Some may feel it&#39;s noisy, but personally I don&#39;t see it as a problem as it always comes before the func/var/let keyword, generics and function name, so it&#39;s not like it&#39;s near anything where the (minor) noise reduces readability.<br>&gt; <br>&gt; But yeah, having used the new fileprivate for a little while I just don&#39;t like it; it may partly come down to the fact that I use fileprivate a lot more than I use regular private. If we were to adopt the above scheme I would recommend that private(file) be the default for use of the plain private keyword, unless we gain the ability to specify private(type) (i.e- protected in most other languages), as private(scope) seems like it&#39;s the less common, at least in my experience.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/6a6605f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October  7, 2016 at 05:00:00pm</p></header><div class="content"><p>Even if these access modifier names seem to make sense, I don’t really see the need of the reconsideration here.<br></p><p>private(scope)  == private<br>private(file)   == fileprivate<br>private(module) == internal<br>Lhs does add more noise, and if I had to tell, fileprivate actually reads well and better than private(file).<br></p><p>Which problem isn’t solved here yet? I might be blind and don’t read between the lines.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 7. Oktober 2016 um 16:03:07, Adriano Ferreira via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>+1<br></p><p>I would also rather have:<br></p><p>private(scope)<br>private(file)<br>private(module)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/f5d67afb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October  7, 2016 at 03:00:00pm</p></header><div class="content"><p>While no topic is formally off the table, to revisit a topic requires fresh<br>insight. `private(file)` was suggested at the time and rejected in favor of<br>`fileprivate`, and we really don&#39;t need another rehash of how much each<br>person likes one or the other.<br>On Fri, Oct 7, 2016 at 09:02 Adriano Ferreira via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1<br>&gt;<br>&gt; I would also rather have:<br>&gt;<br>&gt; private(scope)<br>&gt; private(file)<br>&gt; private(module)<br>&gt; etc…<br>&gt;<br>&gt; — A<br>&gt;<br>&gt; On Oct 7, 2016, at 4:24 AM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 7 Oct 2016, at 07:39, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hello community,<br>&gt;<br>&gt; From all the proposals which has gone into Swift 3, *[SE-0025] Scoped<br>&gt; Access Level* is the only one I’m having second thoughts about. Before<br>&gt; launching a discussion around it, I’m curious to know if it&#39;s worth<br>&gt; discussing it or if the “ship has sailed”. As the plan is to allow future<br>&gt; versions of Swift to break source-compatibility in certain rare scenarios,<br>&gt; perhaps we have a chance to reconsider certain proposals?<br>&gt;<br>&gt; Regards,<br>&gt; David.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; What in particular don&#39;t you like about it?<br>&gt;<br>&gt; Personally I still don&#39;t like the use of fileprivate as the keyword, I was<br>&gt; very much in favour of a bracketed system like:<br>&gt;<br>&gt; private(scope) Current private (I think, it doesn&#39;t appear to be<br>&gt; equivalent to protected in other languages anyway so I wouldn&#39;t call it<br>&gt; type).<br>&gt; private(file) Current fileprivate<br>&gt; private(module) Current internal/default when omitted<br>&gt; public Current public<br>&gt;<br>&gt; I favour this because it groups all restrictive access levels under<br>&gt; private (since they&#39;re all some form of private) with an optional modifier<br>&gt; that&#39;s explicit about what it&#39;s for. Also, it would have scope to move<br>&gt; things like final into a modifier too, so you might declare a method as<br>&gt; public(final), or public(open) if that&#39;s implemented later and so-on. Just<br>&gt; seems like a generally more flexible setup that also reduces the number of<br>&gt; keywords required.<br>&gt;<br>&gt; Some may feel it&#39;s noisy, but personally I don&#39;t see it as a problem as it<br>&gt; always comes before the func/var/let keyword, generics and function name,<br>&gt; so it&#39;s not like it&#39;s near anything where the (minor) noise reduces<br>&gt; readability.<br>&gt;<br>&gt; But yeah, having used the new fileprivate for a little while I just don&#39;t<br>&gt; like it; it may partly come down to the fact that I use fileprivate a lot<br>&gt; more than I use regular private. If we were to adopt the above scheme I<br>&gt; would recommend that private(file) be the default for use of the plain<br>&gt; private keyword, unless we gain the ability to specify private(type) (i.e-<br>&gt; protected in most other languages), as private(scope) seems like it&#39;s the<br>&gt; less common, at least in my experience.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/d4f30648/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>October  7, 2016 at 09:00:00am</p></header><div class="content"><p>I&#39;d prefer to use public(file), etc over private. You are determining which code has access over which code doesn&#39;t.  I don&#39;t think its that confusing to say the default is just public(module)<br></p><p>Sent with my Thumbs<br></p><p>&gt; On Oct 7, 2016, at 9:21 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; While no topic is formally off the table, to revisit a topic requires fresh insight. `private(file)` was suggested at the time and rejected in favor of `fileprivate`, and we really don&#39;t need another rehash of how much each person likes one or the other.<br>&gt;&gt; On Fri, Oct 7, 2016 at 09:02 Adriano Ferreira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt; I would also rather have:<br>&gt;&gt; <br>&gt;&gt; private(scope)<br>&gt;&gt; private(file)<br>&gt;&gt; private(module)<br>&gt;&gt; etc…<br>&gt;&gt; <br>&gt;&gt; — A<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 7, 2016, at 4:24 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 7 Oct 2016, at 07:39, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; From all the proposals which has gone into Swift 3, [SE-0025] Scoped Access Level is the only one I’m having second thoughts about. Before launching a discussion around it, I’m curious to know if it&#39;s worth discussing it or if the “ship has sailed”. As the plan is to allow future versions of Swift to break source-compatibility in certain rare scenarios, perhaps we have a chance to reconsider certain proposals?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt; David.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What in particular don&#39;t you like about it?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally I still don&#39;t like the use of fileprivate as the keyword, I was very much in favour of a bracketed system like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	private(scope)		Current private (I think, it doesn&#39;t appear to be equivalent to protected in other languages anyway so I wouldn&#39;t call it type).<br>&gt;&gt;&gt; 	private(file)		Current fileprivate<br>&gt;&gt;&gt; 	private(module)	Current internal/default when omitted<br>&gt;&gt;&gt; 	public			Current public<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I favour this because it groups all restrictive access levels under private (since they&#39;re all some form of private) with an optional modifier that&#39;s explicit about what it&#39;s for. Also, it would have scope to move things like final into a modifier too, so you might declare a method as public(final), or public(open) if that&#39;s implemented later and so-on. Just seems like a generally more flexible setup that also reduces the number of keywords required.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some may feel it&#39;s noisy, but personally I don&#39;t see it as a problem as it always comes before the func/var/let keyword, generics and function name, so it&#39;s not like it&#39;s near anything where the (minor) noise reduces readability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But yeah, having used the new fileprivate for a little while I just don&#39;t like it; it may partly come down to the fact that I use fileprivate a lot more than I use regular private. If we were to adopt the above scheme I would recommend that private(file) be the default for use of the plain private keyword, unless we gain the ability to specify private(type) (i.e- protected in most other languages), as private(scope) seems like it&#39;s the less common, at least in my experience.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/24a37fe4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>October  7, 2016 at 06:00:00pm</p></header><div class="content"><p>I’m +1 on the following:<br></p><p>current<br>new<br>private<br>private<br>fileprivate<br>private(file)<br>internal<br>private(module)<br>public<br>public<br>open<br>open<br>The only thing that keeps bothering me is private(set) and how it will harmonize with this proposed scheme.<br></p><p><br>Regards,<br>Adrian Kashivskyy<br></p><p>&gt; Wiadomość napisana przez David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; w dniu 07.10.2016, o godz. 17:54:<br>&gt; <br>&gt; I&#39;d prefer to use public(file), etc over private. You are determining which code has access over which code doesn&#39;t.  I don&#39;t think its that confusing to say the default is just public(module)<br>&gt; <br>&gt; Sent with my Thumbs<br>&gt; <br>&gt; On Oct 7, 2016, at 9:21 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; While no topic is formally off the table, to revisit a topic requires fresh insight. `private(file)` was suggested at the time and rejected in favor of `fileprivate`, and we really don&#39;t need another rehash of how much each person likes one or the other.<br>&gt;&gt; On Fri, Oct 7, 2016 at 09:02 Adriano Ferreira via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt; I would also rather have:<br>&gt;&gt; <br>&gt;&gt; private(scope)<br>&gt;&gt; private(file)<br>&gt;&gt; private(module)<br>&gt;&gt; etc…<br>&gt;&gt; <br>&gt;&gt; — A<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 7, 2016, at 4:24 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 7 Oct 2016, at 07:39, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; From all the proposals which has gone into Swift 3, [SE-0025] Scoped Access Level is the only one I’m having second thoughts about. Before launching a discussion around it, I’m curious to know if it&#39;s worth discussing it or if the “ship has sailed”. As the plan is to allow future versions of Swift to break source-compatibility in certain rare scenarios, perhaps we have a chance to reconsider certain proposals?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt; David.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What in particular don&#39;t you like about it?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally I still don&#39;t like the use of fileprivate as the keyword, I was very much in favour of a bracketed system like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	private(scope)		Current private (I think, it doesn&#39;t appear to be equivalent to protected in other languages anyway so I wouldn&#39;t call it type).<br>&gt;&gt;&gt; 	private(file)		Current fileprivate<br>&gt;&gt;&gt; 	private(module)	Current internal/default when omitted<br>&gt;&gt;&gt; 	public			Current public<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I favour this because it groups all restrictive access levels under private (since they&#39;re all some form of private) with an optional modifier that&#39;s explicit about what it&#39;s for. Also, it would have scope to move things like final into a modifier too, so you might declare a method as public(final), or public(open) if that&#39;s implemented later and so-on. Just seems like a generally more flexible setup that also reduces the number of keywords required.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some may feel it&#39;s noisy, but personally I don&#39;t see it as a problem as it always comes before the func/var/let keyword, generics and function name, so it&#39;s not like it&#39;s near anything where the (minor) noise reduces readability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But yeah, having used the new fileprivate for a little while I just don&#39;t like it; it may partly come down to the fact that I use fileprivate a lot more than I use regular private. If we were to adopt the above scheme I would recommend that private(file) be the default for use of the plain private keyword, unless we gain the ability to specify private(type) (i.e- protected in most other languages), as private(scope) seems like it&#39;s the less common, at least in my experience.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/4f06701a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>October  7, 2016 at 06:00:00pm</p></header><div class="content"><p>I started the topic, but I also believe like you that the fileprivate vs private(file) discussion has already been thoroughly discussed and nothing new has been brought up. That’s not what I want to discuss.<br></p><p>I instead want to share my experience using private and fileprivate since release. Here are my thoughts:<br></p><p>We should start with the premise that the proposal has added a substantial amount of complexity:<br>It has added an extra modifier and access level to learn.<br>It has complicated the access level rules with Inner types as mentioned in the Complications with private types section of the proposal.<br>I have seen many people (twitter, work, slack) be confused about the difference between private and fileprivate at the global level. The answer is none, which shows that both modifiers are not very orthogonal.<br>Since release, I saw people prefer one over the other, as a matter of style. They tend to always use fileprivate or always using private. In the latter case, functions and properties get clumped in the same class scope instead of be written through multiple extensions.<br>I have the impression that the motivations for the proposal are much less real in practice:<br>The first motivation stated is: &quot;It is not clear whether the implementation details are meant to be completely hidden or can be shared with some related code without the danger of misusing the APIs marked as private.” I’ve found that to be fairly rare in practice because the implementation details only used to leak inside the same file, which greatly reduces the dangers.<br>The second motivation stated is: &quot;It forces a one class per file structure, which is very limiting.&quot; First of all, this is partly false. I think it forces putting classes which share implementation details in the same file, which I don’t think is necessarily a bad thing.<br></p><p>To summarise, it seems that the confusion the proposal brought over semantics and style are not worth the limited benefits that it brought. I’d be tempted to backtrack the proposal and re-introduce private as a file scoped access-level and deprecate fileprivate.<br></p><p>Thoughts?<br>David.<br></p><p>&gt; On 7 Oct 2016, at 17:21, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; While no topic is formally off the table, to revisit a topic requires fresh insight. `private(file)` was suggested at the time and rejected in favor of `fileprivate`, and we really don&#39;t need another rehash of how much each person likes one or the other.<br>&gt; On Fri, Oct 7, 2016 at 09:02 Adriano Ferreira via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; +1<br>&gt; <br>&gt; I would also rather have:<br>&gt; <br>&gt; private(scope)<br>&gt; private(file)<br>&gt; private(module)<br>&gt; etc…<br>&gt; <br>&gt; — A<br>&gt; <br>&gt;&gt; On Oct 7, 2016, at 4:24 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 7 Oct 2016, at 07:39, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From all the proposals which has gone into Swift 3, [SE-0025] Scoped Access Level is the only one I’m having second thoughts about. Before launching a discussion around it, I’m curious to know if it&#39;s worth discussing it or if the “ship has sailed”. As the plan is to allow future versions of Swift to break source-compatibility in certain rare scenarios, perhaps we have a chance to reconsider certain proposals?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt; David.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; What in particular don&#39;t you like about it?<br>&gt;&gt; <br>&gt;&gt; Personally I still don&#39;t like the use of fileprivate as the keyword, I was very much in favour of a bracketed system like:<br>&gt;&gt; <br>&gt;&gt; 	private(scope)		Current private (I think, it doesn&#39;t appear to be equivalent to protected in other languages anyway so I wouldn&#39;t call it type).<br>&gt;&gt; 	private(file)		Current fileprivate<br>&gt;&gt; 	private(module)	Current internal/default when omitted<br>&gt;&gt; 	public			Current public<br>&gt;&gt; <br>&gt;&gt; I favour this because it groups all restrictive access levels under private (since they&#39;re all some form of private) with an optional modifier that&#39;s explicit about what it&#39;s for. Also, it would have scope to move things like final into a modifier too, so you might declare a method as public(final), or public(open) if that&#39;s implemented later and so-on. Just seems like a generally more flexible setup that also reduces the number of keywords required.<br>&gt;&gt; <br>&gt;&gt; Some may feel it&#39;s noisy, but personally I don&#39;t see it as a problem as it always comes before the func/var/let keyword, generics and function name, so it&#39;s not like it&#39;s near anything where the (minor) noise reduces readability.<br>&gt;&gt; <br>&gt;&gt; But yeah, having used the new fileprivate for a little while I just don&#39;t like it; it may partly come down to the fact that I use fileprivate a lot more than I use regular private. If we were to adopt the above scheme I would recommend that private(file) be the default for use of the plain private keyword, unless we gain the ability to specify private(type) (i.e- protected in most other languages), as private(scope) seems like it&#39;s the less common, at least in my experience.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/438b373d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>October  7, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 9:13 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To summarise, it seems that the confusion the proposal brought over semantics and style are not worth the limited benefits that it brought. I’d be tempted to backtrack the proposal and re-introduce private as a file scoped access-level and deprecate fileprivate.<br></p><p>This is my personal preference, to back out the fileprivate/private change before Swift becomes any more crystallized. That being said, I think the bar for &#39;novel insight&#39; has to be very high for something like this to be a wise idea, lest we end up endlessly revisiting every idea that wasn&#39;t unanimously popular. Do we have any evidence the new access control system is proving a hindrance to developers, or specific information we didn&#39;t have during the original discussion?<br></p><p>Austin<br></p><p>&gt; <br>&gt; Thoughts?<br>&gt; David.<br>&gt; <br>&gt;&gt; On 7 Oct 2016, at 17:21, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; While no topic is formally off the table, to revisit a topic requires fresh insight. `private(file)` was suggested at the time and rejected in favor of `fileprivate`, and we really don&#39;t need another rehash of how much each person likes one or the other.<br>&gt;&gt; On Fri, Oct 7, 2016 at 09:02 Adriano Ferreira via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt; I would also rather have:<br>&gt;&gt; <br>&gt;&gt; private(scope)<br>&gt;&gt; private(file)<br>&gt;&gt; private(module)<br>&gt;&gt; etc…<br>&gt;&gt; <br>&gt;&gt; — A<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 7, 2016, at 4:24 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 7 Oct 2016, at 07:39, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; From all the proposals which has gone into Swift 3, [SE-0025] Scoped Access Level is the only one I’m having second thoughts about. Before launching a discussion around it, I’m curious to know if it&#39;s worth discussing it or if the “ship has sailed”. As the plan is to allow future versions of Swift to break source-compatibility in certain rare scenarios, perhaps we have a chance to reconsider certain proposals?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt; David.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What in particular don&#39;t you like about it?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally I still don&#39;t like the use of fileprivate as the keyword, I was very much in favour of a bracketed system like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	private(scope)		Current private (I think, it doesn&#39;t appear to be equivalent to protected in other languages anyway so I wouldn&#39;t call it type).<br>&gt;&gt;&gt; 	private(file)		Current fileprivate<br>&gt;&gt;&gt; 	private(module)	Current internal/default when omitted<br>&gt;&gt;&gt; 	public			Current public<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I favour this because it groups all restrictive access levels under private (since they&#39;re all some form of private) with an optional modifier that&#39;s explicit about what it&#39;s for. Also, it would have scope to move things like final into a modifier too, so you might declare a method as public(final), or public(open) if that&#39;s implemented later and so-on. Just seems like a generally more flexible setup that also reduces the number of keywords required.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some may feel it&#39;s noisy, but personally I don&#39;t see it as a problem as it always comes before the func/var/let keyword, generics and function name, so it&#39;s not like it&#39;s near anything where the (minor) noise reduces readability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But yeah, having used the new fileprivate for a little while I just don&#39;t like it; it may partly come down to the fact that I use fileprivate a lot more than I use regular private. If we were to adopt the above scheme I would recommend that private(file) be the default for use of the plain private keyword, unless we gain the ability to specify private(type) (i.e- protected in most other languages), as private(scope) seems like it&#39;s the less common, at least in my experience.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/7df2e32d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>October  7, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 9:13 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I started the topic, but I also believe like you that the fileprivate vs private(file) discussion has already been thoroughly discussed and nothing new has been brought up. That’s not what I want to discuss.<br>&gt; <br>&gt; I instead want to share my experience using private and fileprivate since release. Here are my thoughts:<br>&gt; <br>&gt; We should start with the premise that the proposal has added a substantial amount of complexity:<br>&gt; It has added an extra modifier and access level to learn.<br>&gt; It has complicated the access level rules with Inner types as mentioned in the Complications with private types section of the proposal.<br>&gt; I have seen many people (twitter, work, slack) be confused about the difference between private and fileprivate at the global level. The answer is none, which shows that both modifiers are not very orthogonal.<br>&gt; Since release, I saw people prefer one over the other, as a matter of style. They tend to always use fileprivate or always using private. In the latter case, functions and properties get clumped in the same class scope instead of be written through multiple extensions.<br>&gt; I have the impression that the motivations for the proposal are much less real in practice:<br>&gt; The first motivation stated is: &quot;It is not clear whether the implementation details are meant to be completely hidden or can be shared with some related code without the danger of misusing the APIs marked as private.” I’ve found that to be fairly rare in practice because the implementation details only used to leak inside the same file, which greatly reduces the dangers.<br>&gt; The second motivation stated is: &quot;It forces a one class per file structure, which is very limiting.&quot; First of all, this is partly false. I think it forces putting classes which share implementation details in the same file, which I don’t think is necessarily a bad thing.<br>&gt; <br>&gt; To summarise, it seems that the confusion the proposal brought over semantics and style are not worth the limited benefits that it brought. I’d be tempted to backtrack the proposal and re-introduce private as a file scoped access-level and deprecate fileprivate.<br>&gt; <br>&gt; Thoughts?<br>&gt; David.<br>&gt; <br></p><p><br>I agree. The minor benefit that fileprivate brings is not worth the cognitive overhead it introduces. We should just admit it was a mistake and back it out. We can avoid source-breaking changes by making fileprivate a synonym for private and provide fixits/warnings for a release to give people a chance to move off it.<br></p><p><br></p><p>Russ<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/793ee813/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>October  7, 2016 at 02:00:00pm</p></header><div class="content"><p>I third this sentiment. fileprivate is a nice idea and very clearly has<br>its uses (which is why the proposal got traction in the first place),<br>but when  combined with the other access levels, the language feature as<br>a whole feels arbitrary. In practical use, files that I felt were nicely<br>encapsulated and hiding implementation details are now a scattered mix<br>of access levels, adding cognitive load and making the code look<br>unorganized for having the gall to use extensions to split up<br>functionality.<br></p><p>Sincerely,<br>  Zachary Waldowski<br>  zach at waldowski.me<br></p><p><br>On Fri, Oct 7, 2016, at 01:55 PM, Russ Bishop via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On Oct 7, 2016, at 9:13 AM, David Hart via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I started the topic, but I also believe like you that the<br>&gt;&gt; *fileprivate* vs *private(file)* discussion has already been<br>&gt;&gt; thoroughly discussed and nothing new has been brought up. That’s not<br>&gt;&gt; what I want to discuss.<br>&gt;&gt;<br>&gt;&gt; I instead want to share my experience using *private* and<br>&gt;&gt; *fileprivate* since release. Here are my thoughts:<br>&gt;&gt;<br>&gt;&gt;  1. We should start with the premise that the proposal has added a<br>&gt;&gt;     substantial amount of complexity:<br>&gt;&gt;    1. It has added an extra modifier and access level to learn.<br>&gt;&gt;    2. It has complicated the access level rules with Inner types as<br>&gt;&gt;       mentioned in the *Complications with private types* section of<br>&gt;&gt;       the proposal.<br>&gt;&gt;    3. I have seen many people (twitter, work, slack) be confused<br>&gt;&gt;       about the difference between *private* and *fileprivate* at the<br>&gt;&gt;       global level. The answer is none, which shows that both<br>&gt;&gt;       modifiers are not very orthogonal.<br>&gt;&gt;    4. Since release, I saw people prefer one over the other, as a<br>&gt;&gt;       matter of style. They tend to always use *fileprivate* or<br>&gt;&gt;       always using *private*. In the latter case, functions and<br>&gt;&gt;       properties get clumped in the same class scope instead of be<br>&gt;&gt;       written through multiple extensions.<br>&gt;&gt;  2. I have the impression that the motivations for the proposal are<br>&gt;&gt;     much less real in practice:<br>&gt;&gt;    1. The first motivation stated is: *&quot;It is not clear whether the<br>&gt;&gt;       implementation details are meant to be completely hidden or can<br>&gt;&gt;       be shared with some related code without the danger of misusing<br>&gt;&gt;       the APIs marked as private.”* I’ve found that to be fairly rare<br>&gt;&gt;       in practice because the implementation details only used to<br>&gt;&gt;       leak inside the same file, which greatly reduces the dangers.<br>&gt;&gt;    2. The second motivation stated is: *&quot;It forces a one class per<br>&gt;&gt;       file structure, which is very limiting.&quot; *First of all, this is<br>&gt;&gt;       partly false. I think it forces putting classes which share<br>&gt;&gt;       implementation details in the same file, which I don’t think is<br>&gt;&gt;       necessarily a bad thing.<br>&gt;&gt;<br>&gt;&gt; To summarise, it seems that the confusion the proposal brought over<br>&gt;&gt; semantics and style are not worth the limited benefits that it<br>&gt;&gt; brought. I’d be tempted to backtrack the proposal and re-introduce<br>&gt;&gt; private as a file scoped access-level and deprecate fileprivate.<br>&gt;&gt;<br>&gt;&gt; Thoughts?<br>&gt;&gt; David.<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; I agree. The minor benefit that fileprivate brings is not worth the<br>&gt; cognitive overhead it introduces. We should just admit it was a<br>&gt; mistake and back it out. We can avoid source-breaking changes by<br>&gt; making fileprivate a synonym for private and provide fixits/warnings<br>&gt; for a release to give people a chance to move off it.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Russ<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/476b7b6f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>October  7, 2016 at 09:00:00pm</p></header><div class="content"><p>So are folks saying remove the concept of file private and keep the new<br>private behavior? ...or revert the whole thing? Also based on what do we<br>really see an issue with the addition of fileprivate? It seems more theory<br>then examples of problems in the discussions I have seen.<br></p><p>-Shawn<br>On Fri, Oct 7, 2016 at 2:05 PM Zach Waldowski via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I third this sentiment. fileprivate is a nice idea and very clearly has<br>&gt; its uses (which is why the proposal got traction in the first place), but<br>&gt; when combined with the other access levels, the language feature as a whole<br>&gt; feels arbitrary. In practical use, files that I felt were nicely<br>&gt; encapsulated and hiding implementation details are now a scattered mix of<br>&gt; access levels, adding cognitive load and making the code look unorganized<br>&gt; for having the gall to use extensions to split up functionality.<br>&gt;<br>&gt; Sincerely,<br>&gt;   Zachary Waldowski<br>&gt;   zach at waldowski.me<br>&gt;<br>&gt;<br>&gt; On Fri, Oct 7, 2016, at 01:55 PM, Russ Bishop via swift-evolution wrote:<br>&gt;<br>&gt;<br>&gt; On Oct 7, 2016, at 9:13 AM, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I started the topic, but I also believe like you that the *fileprivate*<br>&gt; vs *private(file)* discussion has already been thoroughly discussed and<br>&gt; nothing new has been brought up. That’s not what I want to discuss.<br>&gt;<br>&gt; I instead want to share my experience using *private* and *fileprivate*<br>&gt; since release. Here are my thoughts:<br>&gt;<br>&gt;<br>&gt;    1. We should start with the premise that the proposal has added a<br>&gt;    substantial amount of complexity:<br>&gt;    1. It has added an extra modifier and access level to learn.<br>&gt;       2. It has complicated the access level rules with Inner types as<br>&gt;       mentioned in the *Complications with private types* section of the<br>&gt;       proposal.<br>&gt;       3. I have seen many people (twitter, work, slack) be confused about<br>&gt;       the difference between *private* and *fileprivate* at the global<br>&gt;       level. The answer is none, which shows that both modifiers are not very<br>&gt;       orthogonal.<br>&gt;       4. Since release, I saw people prefer one over the other, as a<br>&gt;       matter of style. They tend to always use *fileprivate* or always<br>&gt;       using *private*. In the latter case, functions and properties get<br>&gt;       clumped in the same class scope instead of be written through multiple<br>&gt;       extensions.<br>&gt;       2. I have the impression that the motivations for the proposal are<br>&gt;    much less real in practice:<br>&gt;    1. The first motivation stated is: *&quot;It is not clear whether the<br>&gt;       implementation details are meant to be completely hidden or can be shared<br>&gt;       with some related code without the danger of misusing the APIs marked as<br>&gt;       private.”* I’ve found that to be fairly rare in practice because<br>&gt;       the implementation details only used to leak inside the same file, which<br>&gt;       greatly reduces the dangers.<br>&gt;       2. The second motivation stated is: *&quot;It forces a one class per<br>&gt;       file structure, which is very limiting.&quot; *First of all, this is<br>&gt;       partly false. I think it forces putting classes which share implementation<br>&gt;       details in the same file, which I don’t think is necessarily a bad thing.<br>&gt;<br>&gt;<br>&gt; To summarise, it seems that the confusion the proposal brought over<br>&gt; semantics and style are not worth the limited benefits that it brought. I’d<br>&gt; be tempted to backtrack the proposal and re-introduce private as a file<br>&gt; scoped access-level and deprecate fileprivate.<br>&gt;<br>&gt; Thoughts?<br>&gt; David.<br>&gt;<br>&gt;<br>&gt;<br>&gt; I agree. The minor benefit that fileprivate brings is not worth the<br>&gt; cognitive overhead it introduces. We should just admit it was a mistake and<br>&gt; back it out. We can avoid source-breaking changes by making fileprivate a<br>&gt; synonym for private and provide fixits/warnings for a release to give<br>&gt; people a chance to move off it.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Russ<br>&gt;<br>&gt; *_______________________________________________*<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/bf045563/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>October  7, 2016 at 02:00:00pm</p></header><div class="content"><p>On Fri, Oct 7, 2016, at 02:08 PM, Shawn Erickson via swift-evolution wrote:<br>&gt; Also based on what do we really see an issue with the addition of<br>&gt; fileprivate? It seems more theory then examples of problems in the<br>&gt; discussions I have seen.<br></p><p>I&#39;ve migrated multiple projects, both for my own use and for clients.<br>I&#39;ve taught Swift 3 to my colleagues as we upgrade, and have to help<br>seasoned developers through confusion. I&#39;ve taught Swift 3 to people who<br>don&#39;t know Swift, and have to help novice developers through confusion.<br>I watch as other developers fight this, such as on Twitter, while<br>fileprivate is a joke unto its own. That&#39;s hardly theoretical.<br></p><p>Sincerely,<br>  Zachary Waldowski<br>  zach at waldowski.me<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/84a83ffc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>October  7, 2016 at 09:00:00pm</p></header><div class="content"><p>I do see dislike of the name, I get that, I among others pushed for<br>alternate naming (kinda preferred keeping &quot;private&quot; at file scope).<br></p><p>What isn&#39;t clear to me is - at least for some - folks asking to remove it<br>what they actually mean... or what confusion actually exists other then<br>being something new / different then the past. I prefer to not rush to<br>quickly to remove something because of noise early in the adoption /<br>availability of Swift 3.<br></p><p>It seems like some folks may not realize the the old &quot;private&quot; basically<br>changed its name to &quot;fileprivate&quot; without any behavior change in its<br>&quot;protection&quot; scope. So when voting to remove fileprivate do they want to<br>lose file scoping as well or are they asking for the new private to change<br>back to be file scope (e.g. lose the new private scoping). I also have seen<br>some of the &quot;mocking&quot; of this feature being based on assuming that file<br>scope was added and serves no purpose when in fact we always had file<br>private scoping.<br></p><p>-Shawn<br></p><p>On Fri, Oct 7, 2016 at 2:17 PM Zach Waldowski via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Fri, Oct 7, 2016, at 02:08 PM, Shawn Erickson via swift-evolution wrote:<br>&gt;<br>&gt; Also based on what do we really see an issue with the addition of<br>&gt; fileprivate? It seems more theory then examples of problems in the<br>&gt; discussions I have seen.<br>&gt;<br>&gt;<br>&gt; I&#39;ve migrated multiple projects, both for my own use and for clients. I&#39;ve<br>&gt; taught Swift 3 to my colleagues as we upgrade, and have to help seasoned<br>&gt; developers through confusion. I&#39;ve taught Swift 3 to people who don&#39;t know<br>&gt; Swift, and have to help novice developers through confusion. I watch as<br>&gt; other developers fight this, such as on Twitter, while fileprivate is a<br>&gt; joke unto its own. That&#39;s hardly theoretical.<br>&gt;<br>&gt; Sincerely,<br>&gt;   Zachary Waldowski<br>&gt;   zach at waldowski.me<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/d2eef1c0/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>October  7, 2016 at 09:00:00pm</p></header><div class="content"><p>I actually feel exactly the opposite of this—personally I thought `private`<br>was fine the way it was when it meant `fileprivate` and I had no real need<br>for `private` as it exists in Swift 3.<br></p><p>`fileprivate` is useful because it lets me organize my code in such a way<br>that I divide large types (for example, those that conform to many<br>delegates/other protocols) into multiple extensions in the same file. Any<br>state or helpers that I want to keep in the main class can be defined as<br>`fileprivate` and still be accessible throughout that file, without leaking<br>them into the rest of my module if they were defined as `internal`.<br></p><p>On the other hand, `private` would mostly just protect me from myself at a<br>very small level. In all the Swift code that I&#39;ve written (this is my<br>anecdotal experience, of course, and I know others differ), it&#39;s rare that<br>I&#39;ve found a strong reason to or benefit from locking something down as<br>`private` instead of `fileprivate`.<br></p><p>Of course, one could argue that `fileprivate` is also protecting me from<br>myself, just a file-based level instead of a scope-based level, but I think<br>it would be more harmful to encourage leaking abstractions out of a file<br>and into a module than it would to leak them out of a scope and into a<br>single file. The affected surface area is much smaller in the latter case.<br></p><p>One possible compromise that pops into my head would be to let `private`<br>not apply to a scope but to a type and also to only those extensions on<br>that type that are visible in the same file—that may have already been<br>discussed during the review of the original proposal. I don&#39;t know what the<br>complexity of it would be.<br></p><p>Either way, I would be strongly against anything that removes<br>`fileprivate`. I don&#39;t find much use for `private` and nobody is forcing me<br>to use it, so I don&#39;t. On the other hand, removing `fileprivate` would<br>prevent a design and code organization pattern that I enjoy about Swift.<br></p><p><br></p><p>On Fri, Oct 7, 2016 at 2:06 PM Zach Waldowski via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I third this sentiment. fileprivate is a nice idea and very clearly has<br>&gt; its uses (which is why the proposal got traction in the first place), but<br>&gt; when combined with the other access levels, the language feature as a whole<br>&gt; feels arbitrary. In practical use, files that I felt were nicely<br>&gt; encapsulated and hiding implementation details are now a scattered mix of<br>&gt; access levels, adding cognitive load and making the code look unorganized<br>&gt; for having the gall to use extensions to split up functionality.<br>&gt;<br>&gt; Sincerely,<br>&gt;   Zachary Waldowski<br>&gt;   zach at waldowski.me<br>&gt;<br>&gt;<br>&gt; On Fri, Oct 7, 2016, at 01:55 PM, Russ Bishop via swift-evolution wrote:<br>&gt;<br>&gt;<br>&gt; On Oct 7, 2016, at 9:13 AM, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I started the topic, but I also believe like you that the *fileprivate*<br>&gt; vs *private(file)* discussion has already been thoroughly discussed and<br>&gt; nothing new has been brought up. That’s not what I want to discuss.<br>&gt;<br>&gt; I instead want to share my experience using *private* and *fileprivate*<br>&gt; since release. Here are my thoughts:<br>&gt;<br>&gt;<br>&gt;    1. We should start with the premise that the proposal has added a<br>&gt;    substantial amount of complexity:<br>&gt;    1. It has added an extra modifier and access level to learn.<br>&gt;       2. It has complicated the access level rules with Inner types as<br>&gt;       mentioned in the *Complications with private types* section of the<br>&gt;       proposal.<br>&gt;       3. I have seen many people (twitter, work, slack) be confused about<br>&gt;       the difference between *private* and *fileprivate* at the global<br>&gt;       level. The answer is none, which shows that both modifiers are not very<br>&gt;       orthogonal.<br>&gt;       4. Since release, I saw people prefer one over the other, as a<br>&gt;       matter of style. They tend to always use *fileprivate* or always<br>&gt;       using *private*. In the latter case, functions and properties get<br>&gt;       clumped in the same class scope instead of be written through multiple<br>&gt;       extensions.<br>&gt;       2. I have the impression that the motivations for the proposal are<br>&gt;    much less real in practice:<br>&gt;    1. The first motivation stated is: *&quot;It is not clear whether the<br>&gt;       implementation details are meant to be completely hidden or can be shared<br>&gt;       with some related code without the danger of misusing the APIs marked as<br>&gt;       private.”* I’ve found that to be fairly rare in practice because<br>&gt;       the implementation details only used to leak inside the same file, which<br>&gt;       greatly reduces the dangers.<br>&gt;       2. The second motivation stated is: *&quot;It forces a one class per<br>&gt;       file structure, which is very limiting.&quot; *First of all, this is<br>&gt;       partly false. I think it forces putting classes which share implementation<br>&gt;       details in the same file, which I don’t think is necessarily a bad thing.<br>&gt;<br>&gt;<br>&gt; To summarise, it seems that the confusion the proposal brought over<br>&gt; semantics and style are not worth the limited benefits that it brought. I’d<br>&gt; be tempted to backtrack the proposal and re-introduce private as a file<br>&gt; scoped access-level and deprecate fileprivate.<br>&gt;<br>&gt; Thoughts?<br>&gt; David.<br>&gt;<br>&gt;<br>&gt;<br>&gt; I agree. The minor benefit that fileprivate brings is not worth the<br>&gt; cognitive overhead it introduces. We should just admit it was a mistake and<br>&gt; back it out. We can avoid source-breaking changes by making fileprivate a<br>&gt; synonym for private and provide fixits/warnings for a release to give<br>&gt; people a chance to move off it.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Russ<br>&gt;<br>&gt; *_______________________________________________*<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/3a5b0ad6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>October  8, 2016 at 08:00:00am</p></header><div class="content"><p>+1 for me.<br></p><p>I see a little benefit for teams that have multiple people working on a single file (not necessarily at the same time) where a case can be made for a distinction between fileprivate and private. Other than that there is imo no benefit. So to me the question is “is the benefit to those teams worth the burden on the rest of us”?<br></p><p>I honestly do not know the answer to that.<br></p><p>Personally I come down on the side of reverting this change.<br></p><p>Btw: I was not present during the original discussion. If I had been I would have tried to make a case for a “friends list”. In which each scope could have a list of “friends” that have “private” access. This has the advantage that all external access to the scope would be documentation in that scope, and it would open up the possibility of granting private access to closures outside the file the scope was defined in. (private would then become class-private and fileprivate could be eliminated)<br></p><p>Rien.<br></p><p>&gt; On 07 Oct 2016, at 23:44, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I actually feel exactly the opposite of this—personally I thought `private` was fine the way it was when it meant `fileprivate` and I had no real need for `private` as it exists in Swift 3.<br>&gt; <br>&gt; `fileprivate` is useful because it lets me organize my code in such a way that I divide large types (for example, those that conform to many delegates/other protocols) into multiple extensions in the same file. Any state or helpers that I want to keep in the main class can be defined as `fileprivate` and still be accessible throughout that file, without leaking them into the rest of my module if they were defined as `internal`.<br>&gt; <br>&gt; On the other hand, `private` would mostly just protect me from myself at a very small level. In all the Swift code that I&#39;ve written (this is my anecdotal experience, of course, and I know others differ), it&#39;s rare that I&#39;ve found a strong reason to or benefit from locking something down as `private` instead of `fileprivate`.<br>&gt; <br>&gt; Of course, one could argue that `fileprivate` is also protecting me from myself, just a file-based level instead of a scope-based level, but I think it would be more harmful to encourage leaking abstractions out of a file and into a module than it would to leak them out of a scope and into a single file. The affected surface area is much smaller in the latter case.<br>&gt; <br>&gt; One possible compromise that pops into my head would be to let `private` not apply to a scope but to a type and also to only those extensions on that type that are visible in the same file—that may have already been discussed during the review of the original proposal. I don&#39;t know what the complexity of it would be.<br>&gt; <br>&gt; Either way, I would be strongly against anything that removes `fileprivate`. I don&#39;t find much use for `private` and nobody is forcing me to use it, so I don&#39;t. On the other hand, removing `fileprivate` would prevent a design and code organization pattern that I enjoy about Swift.<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Fri, Oct 7, 2016 at 2:06 PM Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I third this sentiment. fileprivate is a nice idea and very clearly has its uses (which is why the proposal got traction in the first place), but when combined with the other access levels, the language feature as a whole feels arbitrary. In practical use, files that I felt were nicely encapsulated and hiding implementation details are now a scattered mix of access levels, adding cognitive load and making the code look unorganized for having the gall to use extensions to split up functionality.<br>&gt; <br>&gt; Sincerely,<br>&gt;   Zachary Waldowski<br>&gt;   zach at waldowski.me<br>&gt; <br>&gt; <br>&gt; On Fri, Oct 7, 2016, at 01:55 PM, Russ Bishop via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 7, 2016, at 9:13 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I started the topic, but I also believe like you that the fileprivate vs private(file) discussion has already been thoroughly discussed and nothing new has been brought up. That’s not what I want to discuss.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I instead want to share my experience using private and fileprivate since release. Here are my thoughts:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	• We should start with the premise that the proposal has added a substantial amount of complexity:<br>&gt;&gt;&gt; 		• It has added an extra modifier and access level to learn.<br>&gt;&gt;&gt; 		• It has complicated the access level rules with Inner types as mentioned in the Complications with private types section of the proposal.<br>&gt;&gt;&gt; 		• I have seen many people (twitter, work, slack) be confused about the difference between private and fileprivate at the global level. The answer is none, which shows that both modifiers are not very orthogonal.<br>&gt;&gt;&gt; 		• Since release, I saw people prefer one over the other, as a matter of style. They tend to always use fileprivate or always using private. In the latter case, functions and properties get clumped in the same class scope instead of be written through multiple extensions.<br>&gt;&gt;&gt; 	• I have the impression that the motivations for the proposal are much less real in practice:<br>&gt;&gt;&gt; 		• The first motivation stated is: &quot;It is not clear whether the implementation details are meant to be completely hidden or can be shared with some related code without the danger of misusing the APIs marked as private.” I’ve found that to be fairly rare in practice because the implementation details only used to leak inside the same file, which greatly reduces the dangers.<br>&gt;&gt;&gt; 		• The second motivation stated is: &quot;It forces a one class per file structure, which is very limiting.&quot; First of all, this is partly false. I think it forces putting classes which share implementation details in the same file, which I don’t think is necessarily a bad thing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To summarise, it seems that the confusion the proposal brought over semantics and style are not worth the limited benefits that it brought. I’d be tempted to backtrack the proposal and re-introduce private as a file scoped access-level and deprecate fileprivate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; David.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I agree. The minor benefit that fileprivate brings is not worth the cognitive overhead it introduces. We should just admit it was a mistake and back it out. We can avoid source-breaking changes by making fileprivate a synonym for private and provide fixits/warnings for a release to give people a chance to move off it.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Russ<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/68d21c811b4f037d9cbd43013319f9b4?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Muse M</string> &lt;james.lei65 at gmail.com&gt;<p>October  8, 2016 at 03:00:00pm</p></header><div class="content"><p>I would rather consider using a new keyword that could make it clearer<br>without looking up for description.<br></p><p>New                        Current<br>moduleprivate over internal<br></p><p><br></p><p>On Sat, Oct 8, 2016 at 2:44 PM, Rien via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 for me.<br>&gt;<br>&gt; I see a little benefit for teams that have multiple people working on a<br>&gt; single file (not necessarily at the same time) where a case can be made for<br>&gt; a distinction between fileprivate and private. Other than that there is imo<br>&gt; no benefit. So to me the question is “is the benefit to those teams worth<br>&gt; the burden on the rest of us”?<br>&gt;<br>&gt; I honestly do not know the answer to that.<br>&gt;<br>&gt; Personally I come down on the side of reverting this change.<br>&gt;<br>&gt; Btw: I was not present during the original discussion. If I had been I<br>&gt; would have tried to make a case for a “friends list”. In which each scope<br>&gt; could have a list of “friends” that have “private” access. This has the<br>&gt; advantage that all external access to the scope would be documentation in<br>&gt; that scope, and it would open up the possibility of granting private access<br>&gt; to closures outside the file the scope was defined in. (private would then<br>&gt; become class-private and fileprivate could be eliminated)<br>&gt;<br>&gt; Rien.<br>&gt;<br>&gt; &gt; On 07 Oct 2016, at 23:44, Tony Allevato via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I actually feel exactly the opposite of this—personally I thought<br>&gt; `private` was fine the way it was when it meant `fileprivate` and I had no<br>&gt; real need for `private` as it exists in Swift 3.<br>&gt; &gt;<br>&gt; &gt; `fileprivate` is useful because it lets me organize my code in such a<br>&gt; way that I divide large types (for example, those that conform to many<br>&gt; delegates/other protocols) into multiple extensions in the same file. Any<br>&gt; state or helpers that I want to keep in the main class can be defined as<br>&gt; `fileprivate` and still be accessible throughout that file, without leaking<br>&gt; them into the rest of my module if they were defined as `internal`.<br>&gt; &gt;<br>&gt; &gt; On the other hand, `private` would mostly just protect me from myself at<br>&gt; a very small level. In all the Swift code that I&#39;ve written (this is my<br>&gt; anecdotal experience, of course, and I know others differ), it&#39;s rare that<br>&gt; I&#39;ve found a strong reason to or benefit from locking something down as<br>&gt; `private` instead of `fileprivate`.<br>&gt; &gt;<br>&gt; &gt; Of course, one could argue that `fileprivate` is also protecting me from<br>&gt; myself, just a file-based level instead of a scope-based level, but I think<br>&gt; it would be more harmful to encourage leaking abstractions out of a file<br>&gt; and into a module than it would to leak them out of a scope and into a<br>&gt; single file. The affected surface area is much smaller in the latter case.<br>&gt; &gt;<br>&gt; &gt; One possible compromise that pops into my head would be to let `private`<br>&gt; not apply to a scope but to a type and also to only those extensions on<br>&gt; that type that are visible in the same file—that may have already been<br>&gt; discussed during the review of the original proposal. I don&#39;t know what the<br>&gt; complexity of it would be.<br>&gt; &gt;<br>&gt; &gt; Either way, I would be strongly against anything that removes<br>&gt; `fileprivate`. I don&#39;t find much use for `private` and nobody is forcing me<br>&gt; to use it, so I don&#39;t. On the other hand, removing `fileprivate` would<br>&gt; prevent a design and code organization pattern that I enjoy about Swift.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Fri, Oct 7, 2016 at 2:06 PM Zach Waldowski via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; I third this sentiment. fileprivate is a nice idea and very clearly has<br>&gt; its uses (which is why the proposal got traction in the first place), but<br>&gt; when combined with the other access levels, the language feature as a whole<br>&gt; feels arbitrary. In practical use, files that I felt were nicely<br>&gt; encapsulated and hiding implementation details are now a scattered mix of<br>&gt; access levels, adding cognitive load and making the code look unorganized<br>&gt; for having the gall to use extensions to split up functionality.<br>&gt; &gt;<br>&gt; &gt; Sincerely,<br>&gt; &gt;   Zachary Waldowski<br>&gt; &gt;   zach at waldowski.me<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Fri, Oct 7, 2016, at 01:55 PM, Russ Bishop via swift-evolution wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Oct 7, 2016, at 9:13 AM, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I started the topic, but I also believe like you that the fileprivate<br>&gt; vs private(file) discussion has already been thoroughly discussed and<br>&gt; nothing new has been brought up. That’s not what I want to discuss.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I instead want to share my experience using private and fileprivate<br>&gt; since release. Here are my thoughts:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;     • We should start with the premise that the proposal has added a<br>&gt; substantial amount of complexity:<br>&gt; &gt;&gt;&gt;             • It has added an extra modifier and access level to learn.<br>&gt; &gt;&gt;&gt;             • It has complicated the access level rules with Inner<br>&gt; types as mentioned in the Complications with private types section of the<br>&gt; proposal.<br>&gt; &gt;&gt;&gt;             • I have seen many people (twitter, work, slack) be<br>&gt; confused about the difference between private and fileprivate at the global<br>&gt; level. The answer is none, which shows that both modifiers are not very<br>&gt; orthogonal.<br>&gt; &gt;&gt;&gt;             • Since release, I saw people prefer one over the other,<br>&gt; as a matter of style. They tend to always use fileprivate or always using<br>&gt; private. In the latter case, functions and properties get clumped in the<br>&gt; same class scope instead of be written through multiple extensions.<br>&gt; &gt;&gt;&gt;     • I have the impression that the motivations for the proposal are<br>&gt; much less real in practice:<br>&gt; &gt;&gt;&gt;             • The first motivation stated is: &quot;It is not clear whether<br>&gt; the implementation details are meant to be completely hidden or can be<br>&gt; shared with some related code without the danger of misusing the APIs<br>&gt; marked as private.” I’ve found that to be fairly rare in practice because<br>&gt; the implementation details only used to leak inside the same file, which<br>&gt; greatly reduces the dangers.<br>&gt; &gt;&gt;&gt;             • The second motivation stated is: &quot;It forces a one class<br>&gt; per file structure, which is very limiting.&quot; First of all, this is partly<br>&gt; false. I think it forces putting classes which share implementation details<br>&gt; in the same file, which I don’t think is necessarily a bad thing.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; To summarise, it seems that the confusion the proposal brought over<br>&gt; semantics and style are not worth the limited benefits that it brought. I’d<br>&gt; be tempted to backtrack the proposal and re-introduce private as a file<br>&gt; scoped access-level and deprecate fileprivate.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Thoughts?<br>&gt; &gt;&gt;&gt; David.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I agree. The minor benefit that fileprivate brings is not worth the<br>&gt; cognitive overhead it introduces. We should just admit it was a mistake and<br>&gt; back it out. We can avoid source-breaking changes by making fileprivate a<br>&gt; synonym for private and provide fixits/warnings for a release to give<br>&gt; people a chance to move off it.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Russ<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161008/b178bb4f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 7 Oct 2016, at 22:44, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; personally I thought `private` was fine the way it was when it meant `fileprivate` and I had no real need for `private` as it exists in Swift 3.<br></p><p>I have to agree with this; I wasn&#39;t especially comfortable with the change (or the eventual choice of keyword style) and in practice I just don&#39;t find it useful. I haven&#39;t used the new &quot;private&quot; even once since it was added, except by accident, the only form of private I use is fileprivate.<br></p><p>I&#39;ve happily embraced the conform through extension style in Swift, and really when it comes down to it the new private access level just isn&#39;t compatible with that style of development. It&#39;s only really useful for hiding details of something you add in one specific section, which I almost never do (and when I do I just mark it fileprivate in case I can re-use it).<br></p><p>Maybe some people do find it useful, but I&#39;d prefer fileprivate to be the default behaviour of private; the current (scoped?) private access level seems far more limited, thus more deserving of a less convenient keyword, or some kind of modifier on private. But personally I&#39;d be fine with removing it, as I don&#39;t think it really adds anything that fileprivate doesn&#39;t already cover.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October  8, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 8 Oct 2016, at 11:31, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 7 Oct 2016, at 22:44, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; personally I thought `private` was fine the way it was when it meant `fileprivate` and I had no real need for `private` as it exists in Swift 3.<br>&gt; <br>&gt; I have to agree with this; I wasn&#39;t especially comfortable with the change (or the eventual choice of keyword style) and in practice I just don&#39;t find it useful. I haven&#39;t used the new &quot;private&quot; even once since it was added, except by accident, the only form of private I use is fileprivate.<br>&gt; <br>&gt; I&#39;ve happily embraced the conform through extension style in Swift, and really when it comes down to it the new private access level just isn&#39;t compatible with that style of development. It&#39;s only really useful for hiding details of something you add in one specific section, which I almost never do (and when I do I just mark it fileprivate in case I can re-use it).<br>&gt; <br>&gt; Maybe some people do find it useful, but I&#39;d prefer fileprivate to be the default behaviour of private; the current (scoped?) private access level seems far more limited, thus more deserving of a less convenient keyword, or some kind of modifier on private. But personally I&#39;d be fine with removing it, as I don&#39;t think it really adds anything that fileprivate doesn&#39;t already cover.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>Sometimes you have multiple types inside a single file (because you want to share some fileprivate stuff but not make it internal), so it’s handy for that.<br></p><p>But you’re right that the syntax is totally ugly. I think access control is actually once of the biggest weak points of Swift - we should have a way for more arbitrary access control, similar to “friend classes” in C++. So then all of your types don’t need to be stuffed inside the same file in order to share semi-private implementation details. “Internal” is scoped to modules, but many people have also expressed the desire for sub-modules or namespaces and often resort to nasty things like caseless enums or empty structs (why nasty? because they don’t really define types - they’re just used for grouping purposes, and we should have a separate construct for that). So then we may need some way for these sub-modules to share some semi-private implementation details, etc…<br></p><p>I would prefer if we could define some kind of access-domain, and you could assign members or types to those domains. We could possibly have some kind of user-defined access-domains, which you could opt-in to in order to see more details about a type (so you could expose it for subclassing purposes, like “protected”, or in any other more arbitrary way).<br></p><p>So it might look something like:<br></p><p>@access-domain TabBarStuff // the domain itself has an access-domain<br></p><p>class TabController {<br>    var tabs: [Tab]<br></p><p>    access(public) func closeTab(at: Int) { … }<br>    access(TabBarStuff) func close(tab: Tab) { … }<br>}<br></p><p>// Another file. Must be in the same module due to access-domain “TabBarStuff”’s visibility<br></p><p>class Tab {<br>   unowned var controller : TabController access(TabBarStuff)<br></p><p>    func close() { controller.close(tab: self) }<br>}<br></p><p>In this case, our API design means that in TabController.close(tab:), we will never get a Tab from a different TabController. This is a nice feature to have, but it requires TabController and Tab to share a member which is not visible to other types. Currently, that means we must have types or extensions scattered around in different files to accommodate for access levels.<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161008/ed3eaeb6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>October  8, 2016 at 11:00:00am</p></header><div class="content"><p>I agree something like you suggest will give a lot of flexibility without -<br>I think - the IMHO quirkiness of friends in C++. It seems like the access<br>domains must? be limited to inside a module to avoid potential surprises<br>from outside the module?<br></p><p>-Shawn<br></p><p>On Sat, Oct 8, 2016 at 3:38 AM Karl via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 8 Oct 2016, at 11:31, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 7 Oct 2016, at 22:44, Tony Allevato via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; personally I thought `private` was fine the way it was when it meant<br>&gt; `fileprivate` and I had no real need for `private` as it exists in Swift 3.<br>&gt;<br>&gt;<br>&gt; I have to agree with this; I wasn&#39;t especially comfortable with the change<br>&gt; (or the eventual choice of keyword style) and in practice I just don&#39;t find<br>&gt; it useful. I haven&#39;t used the new &quot;private&quot; even once since it was added,<br>&gt; except by accident, the only form of private I use is fileprivate.<br>&gt;<br>&gt; I&#39;ve happily embraced the conform through extension style in Swift, and<br>&gt; really when it comes down to it the new private access level just isn&#39;t<br>&gt; compatible with that style of development. It&#39;s only really useful for<br>&gt; hiding details of something you add in one specific section, which I almost<br>&gt; never do (and when I do I just mark it fileprivate in case I can re-use it).<br>&gt;<br>&gt; Maybe some people do find it useful, but I&#39;d prefer fileprivate to be the<br>&gt; default behaviour of private; the current (scoped?) private access level<br>&gt; seems far more limited, thus more deserving of a less convenient keyword,<br>&gt; or some kind of modifier on private. But personally I&#39;d be fine with<br>&gt; removing it, as I don&#39;t think it really adds anything that fileprivate<br>&gt; doesn&#39;t already cover.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; Sometimes you have multiple types inside a single file (because you want<br>&gt; to share some fileprivate stuff but not make it internal), so it’s handy<br>&gt; for that.<br>&gt;<br>&gt; But you’re right that the syntax is totally ugly. I think access control<br>&gt; is actually once of the biggest weak points of Swift - we should have a way<br>&gt; for more arbitrary access control, similar to “friend classes” in C++. So<br>&gt; then all of your types don’t need to be stuffed inside the same file in<br>&gt; order to share semi-private implementation details. “Internal” is scoped to<br>&gt; modules, but many people have also expressed the desire for sub-modules or<br>&gt; namespaces and often resort to nasty things like caseless enums or empty<br>&gt; structs (why nasty? because they don’t really define types - they’re just<br>&gt; used for grouping purposes, and we should have a separate construct for<br>&gt; that). So then we may need some way for these sub-modules to share some<br>&gt; semi-private implementation details, etc…<br>&gt;<br>&gt; I would prefer if we could define some kind of access-domain, and you<br>&gt; could assign members or types to those domains. We could possibly have some<br>&gt; kind of user-defined access-domains, which you could opt-in to in order to<br>&gt; see more details about a type (so you could expose it for subclassing<br>&gt; purposes, like “protected”, or in any other more arbitrary way).<br>&gt;<br>&gt; So it might look something like:<br>&gt;<br>&gt; *@access-domain TabBarStuff* // the domain itself has an access-domain<br>&gt;<br>&gt; class TabController {<br>&gt;     var tabs: [Tab]<br>&gt;<br>&gt;     *access(public)* func closeTab(at: Int) { … }<br>&gt;     *access(TabBarStuff)* func close(tab: Tab) { … }<br>&gt; }<br>&gt;<br>&gt; // Another file. Must be in the same module due to access-domain<br>&gt; “TabBarStuff”’s visibility<br>&gt;<br>&gt; class Tab {<br>&gt;    unowned var controller : TabController *access(TabBarStuff)*<br>&gt;<br>&gt;     func close() { *controller.close(tab: self)* }<br>&gt; }<br>&gt;<br>&gt; In this case, our API design means that in TabController.close(tab:), we<br>&gt; will never get a Tab from a different TabController. This is a nice feature<br>&gt; to have, but it requires TabController and Tab to share a member which is<br>&gt; not visible to other types. Currently, that means we must have types or<br>&gt; extensions scattered around in different files to accommodate for access<br>&gt; levels.<br>&gt;<br>&gt; Karl<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161008/4abad887/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October  8, 2016 at 02:00:00pm</p></header><div class="content"><p>I was thinking that the domains themselves could be associated with a domain, so you could create alternate domains which are also publicly-visible, but distinct from the default, “public” domain.<br></p><p>For example, if you have a bunch of methods which should be visible to subclasses, but you don’t want them to clutter your regular interface. Perhaps they have names which are confusingly-similar to the public API. I believe that is what “protected” is typically used for.<br></p><p>&gt; On 8 Oct 2016, at 13:28, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt; <br>&gt; I agree something like you suggest will give a lot of flexibility without - I think - the IMHO quirkiness of friends in C++. It seems like the access domains must? be limited to inside a module to avoid potential surprises from outside the module?<br>&gt; <br>&gt; -Shawn<br>&gt; <br>&gt; On Sat, Oct 8, 2016 at 3:38 AM Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On 8 Oct 2016, at 11:31, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 7 Oct 2016, at 22:44, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; personally I thought `private` was fine the way it was when it meant `fileprivate` and I had no real need for `private` as it exists in Swift 3.<br>&gt;&gt; <br>&gt;&gt; I have to agree with this; I wasn&#39;t especially comfortable with the change (or the eventual choice of keyword style) and in practice I just don&#39;t find it useful. I haven&#39;t used the new &quot;private&quot; even once since it was added, except by accident, the only form of private I use is fileprivate.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve happily embraced the conform through extension style in Swift, and really when it comes down to it the new private access level just isn&#39;t compatible with that style of development. It&#39;s only really useful for hiding details of something you add in one specific section, which I almost never do (and when I do I just mark it fileprivate in case I can re-use it).<br>&gt;&gt; <br>&gt;&gt; Maybe some people do find it useful, but I&#39;d prefer fileprivate to be the default behaviour of private; the current (scoped?) private access level seems far more limited, thus more deserving of a less convenient keyword, or some kind of modifier on private. But personally I&#39;d be fine with removing it, as I don&#39;t think it really adds anything that fileprivate doesn&#39;t already cover.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; Sometimes you have multiple types inside a single file (because you want to share some fileprivate stuff but not make it internal), so it’s handy for that.<br>&gt; <br>&gt; But you’re right that the syntax is totally ugly. I think access control is actually once of the biggest weak points of Swift - we should have a way for more arbitrary access control, similar to “friend classes” in C++. So then all of your types don’t need to be stuffed inside the same file in order to share semi-private implementation details. “Internal” is scoped to modules, but many people have also expressed the desire for sub-modules or namespaces and often resort to nasty things like caseless enums or empty structs (why nasty? because they don’t really define types - they’re just used for grouping purposes, and we should have a separate construct for that). So then we may need some way for these sub-modules to share some semi-private implementation details, etc…<br>&gt; <br>&gt; I would prefer if we could define some kind of access-domain, and you could assign members or types to those domains. We could possibly have some kind of user-defined access-domains, which you could opt-in to in order to see more details about a type (so you could expose it for subclassing purposes, like “protected”, or in any other more arbitrary way).<br>&gt; <br>&gt; So it might look something like:<br>&gt; <br>&gt; @access-domain TabBarStuff // the domain itself has an access-domain<br>&gt; <br>&gt; class TabController {<br>&gt;     var tabs: [Tab]<br>&gt; <br>&gt;     access(public) func closeTab(at: Int) { … }<br>&gt;     access(TabBarStuff) func close(tab: Tab) { … }<br>&gt; }<br>&gt; <br>&gt; // Another file. Must be in the same module due to access-domain “TabBarStuff”’s visibility<br>&gt; <br>&gt; class Tab {<br>&gt;    unowned var controller : TabController access(TabBarStuff)<br>&gt; <br>&gt;     func close() { controller.close(tab: self) }<br>&gt; }<br>&gt; <br>&gt; In this case, our API design means that in TabController.close(tab:), we will never get a Tab from a different TabController. This is a nice feature to have, but it requires TabController and Tab to share a member which is not visible to other types. Currently, that means we must have types or extensions scattered around in different files to accommodate for access levels.<br>&gt; <br>&gt; Karl<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161008/0e31b979/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6e0bf2aabb9fc16782586e834dc6e2d7?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Braeden Profile</string> &lt;jhaezhyr12 at gmail.com&gt;<p>October  8, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; <br>&gt; On Oct 8, 2016, at 6:58 AM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I was thinking that the domains themselves could be associated with a domain, so you could create alternate domains which are also publicly-visible, but distinct from the default, “public” domain.<br>&gt; <br>&gt; For example, if you have a bunch of methods which should be visible to subclasses, but you don’t want them to clutter your regular interface. Perhaps they have names which are confusingly-similar to the public API. I believe that is what “protected” is typically used for.<br></p><p>Yes, but “protected&quot; was specifically put down by the core team, seeing that any code from outside the library should see the class as one well-designed whole, not something with complicated, visible implementation details.  If your class-internal methods are confusing (and aren’t necessary for normal use), they shouldn’t be made public in any way.  Subclasses would too easily confuse the distinction between your implementation methods and your public ones.<br></p><p>For what it’s worth, I was only confused by “private” and “fileprivate” for a minute or two until I looked up the actual proposal.  I haven’t had trouble with it, and it does actually provide more flexibility for code access at the file level than we had before.  Even if the syntax is clunky.<br></p><p>&gt; <br>&gt;&gt; On 8 Oct 2016, at 13:28, Shawn Erickson &lt;shawnce at gmail.com &lt;mailto:shawnce at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree something like you suggest will give a lot of flexibility without - I think - the IMHO quirkiness of friends in C++. It seems like the access domains must? be limited to inside a module to avoid potential surprises from outside the module?<br>&gt;&gt; <br>&gt;&gt; -Shawn<br>&gt;&gt; <br>&gt;&gt; On Sat, Oct 8, 2016 at 3:38 AM Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 8 Oct 2016, at 11:31, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 7 Oct 2016, at 22:44, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; personally I thought `private` was fine the way it was when it meant `fileprivate` and I had no real need for `private` as it exists in Swift 3.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have to agree with this; I wasn&#39;t especially comfortable with the change (or the eventual choice of keyword style) and in practice I just don&#39;t find it useful. I haven&#39;t used the new &quot;private&quot; even once since it was added, except by accident, the only form of private I use is fileprivate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve happily embraced the conform through extension style in Swift, and really when it comes down to it the new private access level just isn&#39;t compatible with that style of development. It&#39;s only really useful for hiding details of something you add in one specific section, which I almost never do (and when I do I just mark it fileprivate in case I can re-use it).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe some people do find it useful, but I&#39;d prefer fileprivate to be the default behaviour of private; the current (scoped?) private access level seems far more limited, thus more deserving of a less convenient keyword, or some kind of modifier on private. But personally I&#39;d be fine with removing it, as I don&#39;t think it really adds anything that fileprivate doesn&#39;t already cover.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sometimes you have multiple types inside a single file (because you want to share some fileprivate stuff but not make it internal), so it’s handy for that.<br>&gt;&gt; <br>&gt;&gt; But you’re right that the syntax is totally ugly. I think access control is actually once of the biggest weak points of Swift - we should have a way for more arbitrary access control, similar to “friend classes” in C++. So then all of your types don’t need to be stuffed inside the same file in order to share semi-private implementation details. “Internal” is scoped to modules, but many people have also expressed the desire for sub-modules or namespaces and often resort to nasty things like caseless enums or empty structs (why nasty? because they don’t really define types - they’re just used for grouping purposes, and we should have a separate construct for that). So then we may need some way for these sub-modules to share some semi-private implementation details, etc…<br>&gt;&gt; <br>&gt;&gt; I would prefer if we could define some kind of access-domain, and you could assign members or types to those domains. We could possibly have some kind of user-defined access-domains, which you could opt-in to in order to see more details about a type (so you could expose it for subclassing purposes, like “protected”, or in any other more arbitrary way).<br>&gt;&gt; <br>&gt;&gt; So it might look something like:<br>&gt;&gt; <br>&gt;&gt; @access-domain TabBarStuff // the domain itself has an access-domain<br>&gt;&gt; <br>&gt;&gt; class TabController {<br>&gt;&gt;     var tabs: [Tab]<br>&gt;&gt; <br>&gt;&gt;     access(public) func closeTab(at: Int) { … }<br>&gt;&gt;     access(TabBarStuff) func close(tab: Tab) { … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Another file. Must be in the same module due to access-domain “TabBarStuff”’s visibility<br>&gt;&gt; <br>&gt;&gt; class Tab {<br>&gt;&gt;    unowned var controller : TabController access(TabBarStuff)<br>&gt;&gt; <br>&gt;&gt;     func close() { controller.close(tab: self) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In this case, our API design means that in TabController.close(tab:), we will never get a Tab from a different TabController. This is a nice feature to have, but it requires TabController and Tab to share a member which is not visible to other types. Currently, that means we must have types or extensions scattered around in different files to accommodate for access levels.<br>&gt;&gt; <br>&gt;&gt; Karl<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161008/004f5c39/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October  8, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 8 Oct 2016, at 16:47, Braeden Profile &lt;jhaezhyr12 at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 8, 2016, at 6:58 AM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I was thinking that the domains themselves could be associated with a domain, so you could create alternate domains which are also publicly-visible, but distinct from the default, “public” domain.<br>&gt;&gt; <br>&gt;&gt; For example, if you have a bunch of methods which should be visible to subclasses, but you don’t want them to clutter your regular interface. Perhaps they have names which are confusingly-similar to the public API. I believe that is what “protected” is typically used for.<br>&gt; <br>&gt; Yes, but “protected&quot; was specifically put down by the core team, seeing that any code from outside the library should see the class as one well-designed whole, not something with complicated, visible implementation details.  If your class-internal methods are confusing (and aren’t necessary for normal use), they shouldn’t be made public in any way.  Subclasses would too easily confuse the distinction between your implementation methods and your public ones.<br>&gt; <br>&gt; For what it’s worth, I was only confused by “private” and “fileprivate” for a minute or two until I looked up the actual proposal.  I haven’t had trouble with it, and it does actually provide more flexibility for code access at the file level than we had before.  Even if the syntax is clunky.<br></p><p>I’m not saying that (file)private is confusing - it’s very clear about what it does. But it is limiting; anything that wants access to those semi-private details needs to live in the same file. That’s clearly not scalable. Enormous files many thousands of lines long are easy for the compiler to digest, but less easy for humans to understand and navigate. In fact, I believe this whole “file-based” access control originally came out of the compiler’s implementation details.<br></p><p>What it would basically come down to is that the interface of the object would be separated in to blocks based on your access privileges. When viewing the interface, it wouldn’t look much different to an extension:<br></p><p>access(public) class TabController {<br>   var tabs : [Tab] { get }<br>   func closeTab(at: Int)<br>}<br></p><p>access(TabBarStuff) extension TabController {<br>    func close(tab: Tab)<br>}<br></p><p>I definitely want something between internal and fileprivate, at least. I don’t see any reason at all why objects shouldn’t be allowed to present optional “slices” of their interface to appropriate clients. In fact, that is what access control is all about. I just want to generalise it to allow for user-defined visibility scopes (as well as the default ones for public, module, file and scope). That leads to the question of what visibility those user-defined scopes would have; and if you leave them entirely open to adopt any scope (except themselves), then you end up with the ability to slice your API for different use-cases. Or we could be boring and limit them to the module they are defined in.<br></p><p>The whole reason I’m bringing this up is because I don’t like the “file” part of fileprivate. How I split my files up is a readability decision.<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161008/c5f991d3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>October  8, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Oct 8, 2016, at 12:02 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On 8 Oct 2016, at 16:47, Braeden Profile &lt;jhaezhyr12 at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Oct 8, 2016, at 6:58 AM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was thinking that the domains themselves could be associated with a domain, so you could create alternate domains which are also publicly-visible, but distinct from the default, “public” domain.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, if you have a bunch of methods which should be visible to subclasses, but you don’t want them to clutter your regular interface. Perhaps they have names which are confusingly-similar to the public API. I believe that is what “protected” is typically used for.<br>&gt;&gt; <br>&gt;&gt; Yes, but “protected&quot; was specifically put down by the core team, seeing that any code from outside the library should see the class as one well-designed whole, not something with complicated, visible implementation details.  If your class-internal methods are confusing (and aren’t necessary for normal use), they shouldn’t be made public in any way.  Subclasses would too easily confuse the distinction between your implementation methods and your public ones.<br>&gt;&gt; <br>&gt;&gt; For what it’s worth, I was only confused by “private” and “fileprivate” for a minute or two until I looked up the actual proposal.  I haven’t had trouble with it, and it does actually provide more flexibility for code access at the file level than we had before.  Even if the syntax is clunky.<br>&gt; <br>&gt; I’m not saying that (file)private is confusing - it’s very clear about what it does. But it is limiting; anything that wants access to those semi-private details needs to live in the same file. That’s clearly not scalable. Enormous files many thousands of lines long are easy for the compiler to digest, but less easy for humans to understand and navigate. In fact, I believe this whole “file-based” access control originally came out of the compiler’s implementation details.<br>&gt; <br>&gt; What it would basically come down to is that the interface of the object would be separated in to blocks based on your access privileges. When viewing the interface, it wouldn’t look much different to an extension:<br>&gt; <br>&gt; access(public) class TabController {<br>&gt;    var tabs : [Tab] { get }<br>&gt;    func closeTab(at: Int)<br>&gt; }<br>&gt; <br>&gt; access(TabBarStuff) extension TabController {<br>&gt;     func close(tab: Tab)<br>&gt; }<br>&gt; <br>&gt; I definitely want something between internal and fileprivate, at least. I don’t see any reason at all why objects shouldn’t be allowed to present optional “slices” of their interface to appropriate clients. In fact, that is what access control is all about. I just want to generalise it to allow for user-defined visibility scopes (as well as the default ones for public, module, file and scope). That leads to the question of what visibility those user-defined scopes would have; and if you leave them entirely open to adopt any scope (except themselves), then you end up with the ability to slice your API for different use-cases. Or we could be boring and limit them to the module they are defined in.<br>&gt; <br>&gt; The whole reason I’m bringing this up is because I don’t like the “file” part of fileprivate. How I split my files up is a readability decision.<br></p><p>It seems to me that some kind of submodule facility is probably the best way to accomplish what you describe here.<br></p><p>&gt; <br>&gt; Karl<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161008/92f1a477/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>October  8, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 08 Oct 2016, at 19:17, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Oct 8, 2016, at 12:02 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 8 Oct 2016, at 16:47, Braeden Profile &lt;jhaezhyr12 at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 8, 2016, at 6:58 AM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was thinking that the domains themselves could be associated with a domain, so you could create alternate domains which are also publicly-visible, but distinct from the default, “public” domain.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example, if you have a bunch of methods which should be visible to subclasses, but you don’t want them to clutter your regular interface. Perhaps they have names which are confusingly-similar to the public API. I believe that is what “protected” is typically used for.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, but “protected&quot; was specifically put down by the core team, seeing that any code from outside the library should see the class as one well-designed whole, not something with complicated, visible implementation details.  If your class-internal methods are confusing (and aren’t necessary for normal use), they shouldn’t be made public in any way.  Subclasses would too easily confuse the distinction between your implementation methods and your public ones.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For what it’s worth, I was only confused by “private” and “fileprivate” for a minute or two until I looked up the actual proposal.  I haven’t had trouble with it, and it does actually provide more flexibility for code access at the file level than we had before.  Even if the syntax is clunky.<br>&gt;&gt; <br>&gt;&gt; I’m not saying that (file)private is confusing - it’s very clear about what it does. But it is limiting; anything that wants access to those semi-private details needs to live in the same file. That’s clearly not scalable. Enormous files many thousands of lines long are easy for the compiler to digest, but less easy for humans to understand and navigate. In fact, I believe this whole “file-based” access control originally came out of the compiler’s implementation details.<br>&gt;&gt; <br>&gt;&gt; What it would basically come down to is that the interface of the object would be separated in to blocks based on your access privileges. When viewing the interface, it wouldn’t look much different to an extension:<br>&gt;&gt; <br>&gt;&gt; access(public) class TabController {<br>&gt;&gt;    var tabs : [Tab] { get }<br>&gt;&gt;    func closeTab(at: Int)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; access(TabBarStuff) extension TabController {<br>&gt;&gt;     func close(tab: Tab)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I definitely want something between internal and fileprivate, at least. I don’t see any reason at all why objects shouldn’t be allowed to present optional “slices” of their interface to appropriate clients. In fact, that is what access control is all about. I just want to generalise it to allow for user-defined visibility scopes (as well as the default ones for public, module, file and scope). That leads to the question of what visibility those user-defined scopes would have; and if you leave them entirely open to adopt any scope (except themselves), then you end up with the ability to slice your API for different use-cases. Or we could be boring and limit them to the module they are defined in.<br>&gt;&gt; <br>&gt;&gt; The whole reason I’m bringing this up is because I don’t like the “file” part of fileprivate. How I split my files up is a readability decision.<br>&gt; <br>&gt; It seems to me that some kind of submodule facility is probably the best way to accomplish what you describe here.<br></p><p>fileextension MyClass.swift<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; Karl<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October  8, 2016 at 02:00:00pm</p></header><div class="content"><p>On Sat, Oct 8, 2016 at 12:02 PM, Karl via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 8 Oct 2016, at 16:47, Braeden Profile &lt;jhaezhyr12 at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Oct 8, 2016, at 6:58 AM, Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I was thinking that the domains themselves could be associated with a<br>&gt; domain, so you could create alternate domains which are also<br>&gt; publicly-visible, but distinct from the default, “public” domain.<br>&gt;<br>&gt; For example, if you have a bunch of methods which should be visible to<br>&gt; subclasses, but you don’t want them to clutter your regular interface.<br>&gt; Perhaps they have names which are confusingly-similar to the public API. I<br>&gt; believe that is what “protected” is typically used for.<br>&gt;<br>&gt;<br>&gt; Yes, but “protected&quot; was specifically put down by the core team, seeing<br>&gt; that any code from outside the library should see the class as one<br>&gt; well-designed whole, not something with complicated, visible implementation<br>&gt; details.  If your class-internal methods are confusing (and aren’t<br>&gt; necessary for normal use), they shouldn’t be made public in any way.<br>&gt; Subclasses would too easily confuse the distinction between your<br>&gt; implementation methods and your public ones.<br>&gt;<br>&gt; For what it’s worth, I was only confused by “private” and “fileprivate”<br>&gt; for a minute or two until I looked up the actual proposal.  I haven’t had<br>&gt; trouble with it, and it does actually provide more flexibility for code<br>&gt; access at the file level than we had before.  Even if the syntax is clunky.<br>&gt;<br>&gt;<br>&gt; I’m not saying that (file)private is confusing - it’s very clear about<br>&gt; what it does. But it is limiting; anything that wants access to those<br>&gt; semi-private details needs to live in the same file. That’s clearly not<br>&gt; scalable. Enormous files many thousands of lines long are easy for the<br>&gt; compiler to digest, but less easy for humans to understand and navigate. In<br>&gt; fact, I believe this whole “file-based” access control originally came out<br>&gt; of the compiler’s implementation details.<br>&gt;<br></p><p>I&#39;m interested in more information about this. What sorts of code have you<br>been writing where a file would have to be thousands of lines long in order<br>to accommodate `fileprivate`? Many entire modules are only thousands of<br>lines long--is there a reason this code couldn&#39;t be refactored into a<br>module of its own? As mentioned by Matthew, isn&#39;t this calling for some<br>notion of submodules?<br></p><p>What it would basically come down to is that the interface of the object<br>&gt; would be separated in to blocks based on your access privileges. When<br>&gt; viewing the interface, it wouldn’t look much different to an extension:<br>&gt;<br>&gt; *access(public)* class TabController {<br>&gt;    var tabs : [Tab] { get }<br>&gt;    func closeTab(at: Int)<br>&gt; }<br>&gt;<br>&gt; *access(TabBarStuff)* extension TabController {<br>&gt;     func close(tab: Tab)<br>&gt; }<br>&gt;<br>&gt; I definitely want something between internal and fileprivate, at least. I<br>&gt; don’t see any reason at all why objects shouldn’t be allowed to present<br>&gt; optional “slices” of their interface to appropriate clients. In fact, that<br>&gt; is what access control is all about. I just want to generalise it to allow<br>&gt; for user-defined visibility scopes (as well as the default ones for public,<br>&gt; module, file and scope). That leads to the question of what visibility<br>&gt; those user-defined scopes would have; and if you leave them entirely open<br>&gt; to adopt any scope (except themselves), then you end up with the ability to<br>&gt; slice your API for different use-cases. Or we could be boring and limit<br>&gt; them to the module they are defined in.<br>&gt;<br>&gt; The whole reason I’m bringing this up is because I don’t like the “file”<br>&gt; part of fileprivate. How I split my files up is a readability decision.<br>&gt;<br>&gt; Karl<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161008/55e6435a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>October  8, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Oct 8, 2016, at 2:01 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Sat, Oct 8, 2016 at 12:02 PM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On 8 Oct 2016, at 16:47, Braeden Profile &lt;jhaezhyr12 at gmail.com &lt;mailto:jhaezhyr12 at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Oct 8, 2016, at 6:58 AM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was thinking that the domains themselves could be associated with a domain, so you could create alternate domains which are also publicly-visible, but distinct from the default, “public” domain.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, if you have a bunch of methods which should be visible to subclasses, but you don’t want them to clutter your regular interface. Perhaps they have names which are confusingly-similar to the public API. I believe that is what “protected” is typically used for.<br>&gt;&gt; <br>&gt;&gt; Yes, but “protected&quot; was specifically put down by the core team, seeing that any code from outside the library should see the class as one well-designed whole, not something with complicated, visible implementation details.  If your class-internal methods are confusing (and aren’t necessary for normal use), they shouldn’t be made public in any way.  Subclasses would too easily confuse the distinction between your implementation methods and your public ones.<br>&gt;&gt; <br>&gt;&gt; For what it’s worth, I was only confused by “private” and “fileprivate” for a minute or two until I looked up the actual proposal.  I haven’t had trouble with it, and it does actually provide more flexibility for code access at the file level than we had before.  Even if the syntax is clunky.<br>&gt; <br>&gt; I’m not saying that (file)private is confusing - it’s very clear about what it does. But it is limiting; anything that wants access to those semi-private details needs to live in the same file. That’s clearly not scalable. Enormous files many thousands of lines long are easy for the compiler to digest, but less easy for humans to understand and navigate. In fact, I believe this whole “file-based” access control originally came out of the compiler’s implementation details.<br>&gt; <br>&gt; I&#39;m interested in more information about this. What sorts of code have you been writing where a file would have to be thousands of lines long in order to accommodate `fileprivate`? Many entire modules are only thousands of lines long--is there a reason this code couldn&#39;t be refactored into a module of its own? As mentioned by Matthew, isn&#39;t this calling for some notion of submodules?<br></p><p>There are rather significant optimization barriers at module boundaries right now.  These do not exist for the standard library due to its tight relationship with the compiler, but for the moment it is a non-trivial concern for 3rd party code that is performance sensitive.  This is effectively a language pressure in the direction of larger modules, at least for some domains.  (Hopefully this pressure will eventually be alleviated - there has been at least some talk in that direction)<br></p><p>&gt; <br>&gt; What it would basically come down to is that the interface of the object would be separated in to blocks based on your access privileges. When viewing the interface, it wouldn’t look much different to an extension:<br>&gt; <br>&gt; access(public) class TabController {<br>&gt;    var tabs : [Tab] { get }<br>&gt;    func closeTab(at: Int)<br>&gt; }<br>&gt; <br>&gt; access(TabBarStuff) extension TabController {<br>&gt;     func close(tab: Tab)<br>&gt; }<br>&gt; <br>&gt; I definitely want something between internal and fileprivate, at least. I don’t see any reason at all why objects shouldn’t be allowed to present optional “slices” of their interface to appropriate clients. In fact, that is what access control is all about. I just want to generalise it to allow for user-defined visibility scopes (as well as the default ones for public, module, file and scope). That leads to the question of what visibility those user-defined scopes would have; and if you leave them entirely open to adopt any scope (except themselves), then you end up with the ability to slice your API for different use-cases. Or we could be boring and limit them to the module they are defined in.<br>&gt; <br>&gt; The whole reason I’m bringing this up is because I don’t like the “file” part of fileprivate. How I split my files up is a readability decision.<br>&gt; <br>&gt; Karl<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161008/9c826672/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October  8, 2016 at 03:00:00pm</p></header><div class="content"><p>On Sat, Oct 8, 2016 at 2:15 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Oct 8, 2016, at 2:01 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Sat, Oct 8, 2016 at 12:02 PM, Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On 8 Oct 2016, at 16:47, Braeden Profile &lt;jhaezhyr12 at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Oct 8, 2016, at 6:58 AM, Karl via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I was thinking that the domains themselves could be associated with a<br>&gt;&gt; domain, so you could create alternate domains which are also<br>&gt;&gt; publicly-visible, but distinct from the default, “public” domain.<br>&gt;&gt;<br>&gt;&gt; For example, if you have a bunch of methods which should be visible to<br>&gt;&gt; subclasses, but you don’t want them to clutter your regular interface.<br>&gt;&gt; Perhaps they have names which are confusingly-similar to the public API. I<br>&gt;&gt; believe that is what “protected” is typically used for.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, but “protected&quot; was specifically put down by the core team, seeing<br>&gt;&gt; that any code from outside the library should see the class as one<br>&gt;&gt; well-designed whole, not something with complicated, visible implementation<br>&gt;&gt; details.  If your class-internal methods are confusing (and aren’t<br>&gt;&gt; necessary for normal use), they shouldn’t be made public in any way.<br>&gt;&gt; Subclasses would too easily confuse the distinction between your<br>&gt;&gt; implementation methods and your public ones.<br>&gt;&gt;<br>&gt;&gt; For what it’s worth, I was only confused by “private” and “fileprivate”<br>&gt;&gt; for a minute or two until I looked up the actual proposal.  I haven’t had<br>&gt;&gt; trouble with it, and it does actually provide more flexibility for code<br>&gt;&gt; access at the file level than we had before.  Even if the syntax is clunky.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I’m not saying that (file)private is confusing - it’s very clear about<br>&gt;&gt; what it does. But it is limiting; anything that wants access to those<br>&gt;&gt; semi-private details needs to live in the same file. That’s clearly not<br>&gt;&gt; scalable. Enormous files many thousands of lines long are easy for the<br>&gt;&gt; compiler to digest, but less easy for humans to understand and navigate. In<br>&gt;&gt; fact, I believe this whole “file-based” access control originally came out<br>&gt;&gt; of the compiler’s implementation details.<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;m interested in more information about this. What sorts of code have you<br>&gt; been writing where a file would have to be thousands of lines long in order<br>&gt; to accommodate `fileprivate`? Many entire modules are only thousands of<br>&gt; lines long--is there a reason this code couldn&#39;t be refactored into a<br>&gt; module of its own? As mentioned by Matthew, isn&#39;t this calling for some<br>&gt; notion of submodules?<br>&gt;<br>&gt;<br>&gt; There are rather significant optimization barriers at module boundaries<br>&gt; right now.  These do not exist for the standard library due to its tight<br>&gt; relationship with the compiler, but for the moment it is a non-trivial<br>&gt; concern for 3rd party code that is performance sensitive.  This is<br>&gt; effectively a language pressure in the direction of larger modules, at<br>&gt; least for some domains.  (Hopefully this pressure will eventually be<br>&gt; alleviated - there has been at least some talk in that direction)<br>&gt;<br></p><p>Great point. IMO, it&#39;d be important to identify how much of the desire for<br>additional varieties of access modifiers represent workarounds to compiler<br>limitations, because we&#39;d be better off making optimization across module<br>boundaries work better if that&#39;s the root of the issue. Certainly, also,<br>submodules are a discussion that, having made a brief appearance at the end<br>of Swift 3 evolution, would be ripe for Swift 4 phase 2.<br></p><p>As for this topic about additional access modifiers, I&#39;d like to understand<br>what current use cases motivate them that arise because the current syntax<br>is insufficiently expressive, rather than compiler shortcomings or the lack<br>of other features that are on the horizon. The latter sorts of motivation,<br>IMO, would be more definitively addressed by tackling the root problem;<br>adding additional syntax in order to work around compiler limitations seems<br>as best inelegant.<br></p><p><br>&gt; What it would basically come down to is that the interface of the object<br>&gt;&gt; would be separated in to blocks based on your access privileges. When<br>&gt;&gt; viewing the interface, it wouldn’t look much different to an extension:<br>&gt;&gt;<br>&gt;&gt; *access(public)* class TabController {<br>&gt;&gt;    var tabs : [Tab] { get }<br>&gt;&gt;    func closeTab(at: Int)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; *access(TabBarStuff)* extension TabController {<br>&gt;&gt;     func close(tab: Tab)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; I definitely want something between internal and fileprivate, at least. I<br>&gt;&gt; don’t see any reason at all why objects shouldn’t be allowed to present<br>&gt;&gt; optional “slices” of their interface to appropriate clients. In fact, that<br>&gt;&gt; is what access control is all about. I just want to generalise it to allow<br>&gt;&gt; for user-defined visibility scopes (as well as the default ones for public,<br>&gt;&gt; module, file and scope). That leads to the question of what visibility<br>&gt;&gt; those user-defined scopes would have; and if you leave them entirely open<br>&gt;&gt; to adopt any scope (except themselves), then you end up with the ability to<br>&gt;&gt; slice your API for different use-cases. Or we could be boring and limit<br>&gt;&gt; them to the module they are defined in.<br>&gt;&gt;<br>&gt;&gt; The whole reason I’m bringing this up is because I don’t like the “file”<br>&gt;&gt; part of fileprivate. How I split my files up is a readability decision.<br>&gt;&gt;<br>&gt;&gt; Karl<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161008/0dcc242a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>October  8, 2016 at 05:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Oct 8, 2016, at 3:24 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Sat, Oct 8, 2016 at 2:15 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 8, 2016, at 2:01 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Oct 8, 2016 at 12:02 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 8 Oct 2016, at 16:47, Braeden Profile &lt;jhaezhyr12 at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 8, 2016, at 6:58 AM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I was thinking that the domains themselves could be associated with a domain, so you could create alternate domains which are also publicly-visible, but distinct from the default, “public” domain.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For example, if you have a bunch of methods which should be visible to subclasses, but you don’t want them to clutter your regular interface. Perhaps they have names which are confusingly-similar to the public API. I believe that is what “protected” is typically used for.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, but “protected&quot; was specifically put down by the core team, seeing that any code from outside the library should see the class as one well-designed whole, not something with complicated, visible implementation details.  If your class-internal methods are confusing (and aren’t necessary for normal use), they shouldn’t be made public in any way.  Subclasses would too easily confuse the distinction between your implementation methods and your public ones.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For what it’s worth, I was only confused by “private” and “fileprivate” for a minute or two until I looked up the actual proposal.  I haven’t had trouble with it, and it does actually provide more flexibility for code access at the file level than we had before.  Even if the syntax is clunky.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not saying that (file)private is confusing - it’s very clear about what it does. But it is limiting; anything that wants access to those semi-private details needs to live in the same file. That’s clearly not scalable. Enormous files many thousands of lines long are easy for the compiler to digest, but less easy for humans to understand and navigate. In fact, I believe this whole “file-based” access control originally came out of the compiler’s implementation details.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m interested in more information about this. What sorts of code have you been writing where a file would have to be thousands of lines long in order to accommodate `fileprivate`? Many entire modules are only thousands of lines long--is there a reason this code couldn&#39;t be refactored into a module of its own? As mentioned by Matthew, isn&#39;t this calling for some notion of submodules?<br>&gt;&gt; <br>&gt;&gt; There are rather significant optimization barriers at module boundaries right now.  These do not exist for the standard library due to its tight relationship with the compiler, but for the moment it is a non-trivial concern for 3rd party code that is performance sensitive.  This is effectively a language pressure in the direction of larger modules, at least for some domains.  (Hopefully this pressure will eventually be alleviated - there has been at least some talk in that direction)<br>&gt; <br>&gt; Great point. IMO, it&#39;d be important to identify how much of the desire for additional varieties of access modifiers represent workarounds to compiler limitations, because we&#39;d be better off making optimization across module boundaries work better if that&#39;s the root of the issue. Certainly, also, submodules are a discussion that, having made a brief appearance at the end of Swift 3 evolution, would be ripe for Swift 4 phase 2.<br>&gt; <br>&gt; As for this topic about additional access modifiers, I&#39;d like to understand what current use cases motivate them that arise because the current syntax is insufficiently expressive, rather than compiler shortcomings or the lack of other features that are on the horizon. The latter sorts of motivation, IMO, would be more definitively addressed by tackling the root problem; adding additional syntax in order to work around compiler limitations seems as best inelegant.<br></p><p>I agree completely.  We definitely don&#39;t want to add features motivated only by current limitations.  <br></p><p>IMO there is plenty of motivation for submodules from a number of different angles.  If we do add them I think allowing an access control distinction between submodule and whole module makes a lot of sense.   That isn&#39;t sufficient motivation on its own of course, but is still very relevant to any discussion of any access level between fileprivate and internal.  I also believe it is very likely to be the best and most natural solution.  <br></p><p>That said, it&#39;s always good to keep pushing for better concrete examples and use cases.<br></p><p>As for the cross-module performance issue, I very much hope to see that solved independent of any new features (aside from perhaps some annotations that help the optimizer and give it more room to work by restricting our future options for change).<br></p><p><br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What it would basically come down to is that the interface of the object would be separated in to blocks based on your access privileges. When viewing the interface, it wouldn’t look much different to an extension:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; access(public) class TabController {<br>&gt;&gt;&gt;&gt;    var tabs : [Tab] { get }<br>&gt;&gt;&gt;&gt;    func closeTab(at: Int)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; access(TabBarStuff) extension TabController {<br>&gt;&gt;&gt;&gt;     func close(tab: Tab)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I definitely want something between internal and fileprivate, at least. I don’t see any reason at all why objects shouldn’t be allowed to present optional “slices” of their interface to appropriate clients. In fact, that is what access control is all about. I just want to generalise it to allow for user-defined visibility scopes (as well as the default ones for public, module, file and scope). That leads to the question of what visibility those user-defined scopes would have; and if you leave them entirely open to adopt any scope (except themselves), then you end up with the ability to slice your API for different use-cases. Or we could be boring and limit them to the module they are defined in.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The whole reason I’m bringing this up is because I don’t like the “file” part of fileprivate. How I split my files up is a readability decision.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Karl<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161008/6e0e219a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October  8, 2016 at 10:00:00pm</p></header><div class="content"><p>Very much agree with essentially all of that.<br></p><p>Personally, I&#39;d also want to explore whether any submodule scope could just<br>subsume fileprivate (i.e., files not otherwise in a submodule behave as<br>though they are their own submodule for access control purposes) rather<br>than occupy another slot between it and internal, but that&#39;s a discussion<br>we can postpone until a submodule proposal takes shape.<br></p><p>On Sat, Oct 8, 2016 at 17:27 Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Oct 8, 2016, at 3:24 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Sat, Oct 8, 2016 at 2:15 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Oct 8, 2016, at 2:01 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Sat, Oct 8, 2016 at 12:02 PM, Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 8 Oct 2016, at 16:47, Braeden Profile &lt;jhaezhyr12 at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Oct 8, 2016, at 6:58 AM, Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I was thinking that the domains themselves could be associated with a<br>&gt; domain, so you could create alternate domains which are also<br>&gt; publicly-visible, but distinct from the default, “public” domain.<br>&gt;<br>&gt; For example, if you have a bunch of methods which should be visible to<br>&gt; subclasses, but you don’t want them to clutter your regular interface.<br>&gt; Perhaps they have names which are confusingly-similar to the public API. I<br>&gt; believe that is what “protected” is typically used for.<br>&gt;<br>&gt;<br>&gt; Yes, but “protected&quot; was specifically put down by the core team, seeing<br>&gt; that any code from outside the library should see the class as one<br>&gt; well-designed whole, not something with complicated, visible implementation<br>&gt; details.  If your class-internal methods are confusing (and aren’t<br>&gt; necessary for normal use), they shouldn’t be made public in any way.<br>&gt; Subclasses would too easily confuse the distinction between your<br>&gt; implementation methods and your public ones.<br>&gt;<br>&gt; For what it’s worth, I was only confused by “private” and “fileprivate”<br>&gt; for a minute or two until I looked up the actual proposal.  I haven’t had<br>&gt; trouble with it, and it does actually provide more flexibility for code<br>&gt; access at the file level than we had before.  Even if the syntax is clunky.<br>&gt;<br>&gt;<br>&gt; I’m not saying that (file)private is confusing - it’s very clear about<br>&gt; what it does. But it is limiting; anything that wants access to those<br>&gt; semi-private details needs to live in the same file. That’s clearly not<br>&gt; scalable. Enormous files many thousands of lines long are easy for the<br>&gt; compiler to digest, but less easy for humans to understand and navigate. In<br>&gt; fact, I believe this whole “file-based” access control originally came out<br>&gt; of the compiler’s implementation details.<br>&gt;<br>&gt;<br>&gt; I&#39;m interested in more information about this. What sorts of code have you<br>&gt; been writing where a file would have to be thousands of lines long in order<br>&gt; to accommodate `fileprivate`? Many entire modules are only thousands of<br>&gt; lines long--is there a reason this code couldn&#39;t be refactored into a<br>&gt; module of its own? As mentioned by Matthew, isn&#39;t this calling for some<br>&gt; notion of submodules?<br>&gt;<br>&gt;<br>&gt; There are rather significant optimization barriers at module boundaries<br>&gt; right now.  These do not exist for the standard library due to its tight<br>&gt; relationship with the compiler, but for the moment it is a non-trivial<br>&gt; concern for 3rd party code that is performance sensitive.  This is<br>&gt; effectively a language pressure in the direction of larger modules, at<br>&gt; least for some domains.  (Hopefully this pressure will eventually be<br>&gt; alleviated - there has been at least some talk in that direction)<br>&gt;<br>&gt;<br>&gt; Great point. IMO, it&#39;d be important to identify how much of the desire for<br>&gt; additional varieties of access modifiers represent workarounds to compiler<br>&gt; limitations, because we&#39;d be better off making optimization across module<br>&gt; boundaries work better if that&#39;s the root of the issue. Certainly, also,<br>&gt; submodules are a discussion that, having made a brief appearance at the end<br>&gt; of Swift 3 evolution, would be ripe for Swift 4 phase 2.<br>&gt;<br>&gt; As for this topic about additional access modifiers, I&#39;d like to<br>&gt; understand what current use cases motivate them that arise because the<br>&gt; current syntax is insufficiently expressive, rather than compiler<br>&gt; shortcomings or the lack of other features that are on the horizon. The<br>&gt; latter sorts of motivation, IMO, would be more definitively addressed by<br>&gt; tackling the root problem; adding additional syntax in order to work around<br>&gt; compiler limitations seems as best inelegant.<br>&gt;<br>&gt;<br>&gt; I agree completely.  We definitely don&#39;t want to add features motivated<br>&gt; only by current limitations.<br>&gt;<br>&gt; IMO there is plenty of motivation for submodules from a number of<br>&gt; different angles.  If we do add them I think allowing an access control<br>&gt; distinction between submodule and whole module makes a lot of sense.   That<br>&gt; isn&#39;t sufficient motivation on its own of course, but is still very<br>&gt; relevant to any discussion of any access level between fileprivate and<br>&gt; internal.  I also believe it is very likely to be the best and most natural<br>&gt; solution.<br>&gt;<br>&gt; That said, it&#39;s always good to keep pushing for better concrete examples<br>&gt; and use cases.<br>&gt;<br>&gt; As for the cross-module performance issue, I very much hope to see that<br>&gt; solved independent of any new features (aside from perhaps some annotations<br>&gt; that help the optimizer and give it more room to work by restricting our<br>&gt; future options for change).<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; What it would basically come down to is that the interface of the object<br>&gt; would be separated in to blocks based on your access privileges. When<br>&gt; viewing the interface, it wouldn’t look much different to an extension:<br>&gt;<br>&gt; *access(public)* class TabController {<br>&gt;    var tabs : [Tab] { get }<br>&gt;    func closeTab(at: Int)<br>&gt; }<br>&gt;<br>&gt; *access(TabBarStuff)* extension TabController {<br>&gt;     func close(tab: Tab)<br>&gt; }<br>&gt;<br>&gt; I definitely want something between internal and fileprivate, at least. I<br>&gt; don’t see any reason at all why objects shouldn’t be allowed to present<br>&gt; optional “slices” of their interface to appropriate clients. In fact, that<br>&gt; is what access control is all about. I just want to generalise it to allow<br>&gt; for user-defined visibility scopes (as well as the default ones for public,<br>&gt; module, file and scope). That leads to the question of what visibility<br>&gt; those user-defined scopes would have; and if you leave them entirely open<br>&gt; to adopt any scope (except themselves), then you end up with the ability to<br>&gt; slice your API for different use-cases. Or we could be boring and limit<br>&gt; them to the module they are defined in.<br>&gt;<br>&gt; The whole reason I’m bringing this up is because I don’t like the “file”<br>&gt; part of fileprivate. How I split my files up is a readability decision.<br>&gt;<br>&gt; Karl<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161008/c8a82c61/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>October  8, 2016 at 06:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Oct 8, 2016, at 5:58 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Very much agree with essentially all of that.<br>&gt; <br>&gt; Personally, I&#39;d also want to explore whether any submodule scope could just subsume fileprivate (i.e., files not otherwise in a submodule behave as though they are their own submodule for access control purposes) rather than occupy another slot between it and internal, but that&#39;s a discussion we can postpone until a submodule proposal takes shape.<br>&gt; <br></p><p>That&#39;s an interesting thought.  Files are such a concrete unit of scope that I think I would still prefer to see the file level access control as well, but I&#39;m open to seeing specifics of other ideas when the time is right (which afaik is not Swift 4 phase 1).<br></p><p>&gt;&gt; On Sat, Oct 8, 2016 at 17:27 Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 8, 2016, at 3:24 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Oct 8, 2016 at 2:15 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 8, 2016, at 2:01 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sat, Oct 8, 2016 at 12:02 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 8 Oct 2016, at 16:47, Braeden Profile &lt;jhaezhyr12 at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 8, 2016, at 6:58 AM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I was thinking that the domains themselves could be associated with a domain, so you could create alternate domains which are also publicly-visible, but distinct from the default, “public” domain.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For example, if you have a bunch of methods which should be visible to subclasses, but you don’t want them to clutter your regular interface. Perhaps they have names which are confusingly-similar to the public API. I believe that is what “protected” is typically used for.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, but “protected&quot; was specifically put down by the core team, seeing that any code from outside the library should see the class as one well-designed whole, not something with complicated, visible implementation details.  If your class-internal methods are confusing (and aren’t necessary for normal use), they shouldn’t be made public in any way.  Subclasses would too easily confuse the distinction between your implementation methods and your public ones.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For what it’s worth, I was only confused by “private” and “fileprivate” for a minute or two until I looked up the actual proposal.  I haven’t had trouble with it, and it does actually provide more flexibility for code access at the file level than we had before.  Even if the syntax is clunky.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not saying that (file)private is confusing - it’s very clear about what it does. But it is limiting; anything that wants access to those semi-private details needs to live in the same file. That’s clearly not scalable. Enormous files many thousands of lines long are easy for the compiler to digest, but less easy for humans to understand and navigate. In fact, I believe this whole “file-based” access control originally came out of the compiler’s implementation details.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m interested in more information about this. What sorts of code have you been writing where a file would have to be thousands of lines long in order to accommodate `fileprivate`? Many entire modules are only thousands of lines long--is there a reason this code couldn&#39;t be refactored into a module of its own? As mentioned by Matthew, isn&#39;t this calling for some notion of submodules?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are rather significant optimization barriers at module boundaries right now.  These do not exist for the standard library due to its tight relationship with the compiler, but for the moment it is a non-trivial concern for 3rd party code that is performance sensitive.  This is effectively a language pressure in the direction of larger modules, at least for some domains.  (Hopefully this pressure will eventually be alleviated - there has been at least some talk in that direction)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Great point. IMO, it&#39;d be important to identify how much of the desire for additional varieties of access modifiers represent workarounds to compiler limitations, because we&#39;d be better off making optimization across module boundaries work better if that&#39;s the root of the issue. Certainly, also, submodules are a discussion that, having made a brief appearance at the end of Swift 3 evolution, would be ripe for Swift 4 phase 2.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for this topic about additional access modifiers, I&#39;d like to understand what current use cases motivate them that arise because the current syntax is insufficiently expressive, rather than compiler shortcomings or the lack of other features that are on the horizon. The latter sorts of motivation, IMO, would be more definitively addressed by tackling the root problem; adding additional syntax in order to work around compiler limitations seems as best inelegant.<br>&gt;&gt; <br>&gt;&gt; I agree completely.  We definitely don&#39;t want to add features motivated only by current limitations.  <br>&gt;&gt; <br>&gt;&gt; IMO there is plenty of motivation for submodules from a number of different angles.  If we do add them I think allowing an access control distinction between submodule and whole module makes a lot of sense.   That isn&#39;t sufficient motivation on its own of course, but is still very relevant to any discussion of any access level between fileprivate and internal.  I also believe it is very likely to be the best and most natural solution.  <br>&gt;&gt; <br>&gt;&gt; That said, it&#39;s always good to keep pushing for better concrete examples and use cases.<br>&gt;&gt; <br>&gt;&gt; As for the cross-module performance issue, I very much hope to see that solved independent of any new features (aside from perhaps some annotations that help the optimizer and give it more room to work by restricting our future options for change).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What it would basically come down to is that the interface of the object would be separated in to blocks based on your access privileges. When viewing the interface, it wouldn’t look much different to an extension:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; access(public) class TabController {<br>&gt;&gt;&gt;&gt;    var tabs : [Tab] { get }<br>&gt;&gt;&gt;&gt;    func closeTab(at: Int)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; access(TabBarStuff) extension TabController {<br>&gt;&gt;&gt;&gt;     func close(tab: Tab)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I definitely want something between internal and fileprivate, at least. I don’t see any reason at all why objects shouldn’t be allowed to present optional “slices” of their interface to appropriate clients. In fact, that is what access control is all about. I just want to generalise it to allow for user-defined visibility scopes (as well as the default ones for public, module, file and scope). That leads to the question of what visibility those user-defined scopes would have; and if you leave them entirely open to adopt any scope (except themselves), then you end up with the ability to slice your API for different use-cases. Or we could be boring and limit them to the module they are defined in.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The whole reason I’m bringing this up is because I don’t like the “file” part of fileprivate. How I split my files up is a readability decision.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Karl<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161008/30c4b6fe/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>October 10, 2016 at 05:00:00pm</p></header><div class="content"><p>On Oct 8, 2016, at 12:15 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There are rather significant optimization barriers at module boundaries right now.  These do not exist for the standard library due to its tight relationship with the compiler, but for the moment it is a non-trivial concern for 3rd party code that is performance sensitive.  This is effectively a language pressure in the direction of larger modules, at least for some domains.  (Hopefully this pressure will eventually be alleviated - there has been at least some talk in that direction)<br></p><p>Indeed, I expect that this will be a big focus over the next year.  The resilience model and ABI stability drive the urgency of getting this worked out.<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October  8, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 8 Oct 2016, at 21:01, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Sat, Oct 8, 2016 at 12:02 PM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On 8 Oct 2016, at 16:47, Braeden Profile &lt;jhaezhyr12 at gmail.com &lt;mailto:jhaezhyr12 at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Oct 8, 2016, at 6:58 AM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was thinking that the domains themselves could be associated with a domain, so you could create alternate domains which are also publicly-visible, but distinct from the default, “public” domain.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, if you have a bunch of methods which should be visible to subclasses, but you don’t want them to clutter your regular interface. Perhaps they have names which are confusingly-similar to the public API. I believe that is what “protected” is typically used for.<br>&gt;&gt; <br>&gt;&gt; Yes, but “protected&quot; was specifically put down by the core team, seeing that any code from outside the library should see the class as one well-designed whole, not something with complicated, visible implementation details.  If your class-internal methods are confusing (and aren’t necessary for normal use), they shouldn’t be made public in any way.  Subclasses would too easily confuse the distinction between your implementation methods and your public ones.<br>&gt;&gt; <br>&gt;&gt; For what it’s worth, I was only confused by “private” and “fileprivate” for a minute or two until I looked up the actual proposal.  I haven’t had trouble with it, and it does actually provide more flexibility for code access at the file level than we had before.  Even if the syntax is clunky.<br>&gt; <br>&gt; I’m not saying that (file)private is confusing - it’s very clear about what it does. But it is limiting; anything that wants access to those semi-private details needs to live in the same file. That’s clearly not scalable. Enormous files many thousands of lines long are easy for the compiler to digest, but less easy for humans to understand and navigate. In fact, I believe this whole “file-based” access control originally came out of the compiler’s implementation details.<br>&gt; <br>&gt; I&#39;m interested in more information about this. What sorts of code have you been writing where a file would have to be thousands of lines long in order to accommodate `fileprivate`? Many entire modules are only thousands of lines long--is there a reason this code couldn&#39;t be refactored into a module of its own? As mentioned by Matthew, isn&#39;t this calling for some notion of submodules?<br>&gt; <br></p><p>The tab controller was one example:<br></p><p>- final class TabController : UIViewController<br>- final class TabControllerView : UIView<br>- final class Tab : UIView<br></p><p>All of these required knowledge of semi-private implementation details of each-other due to the API I wanted to achieve. I wasn’t interested in factoring out the interfaces in to protocols because they’re all final classes and only supposed to be used with each other. For example, Tab.close() called a fileprivate function in TabController to actually close the tab given an instance of the underlying TabItem data structure.<br></p><p>In that case, submodules wouldn’t really help. I could technically define the TabController as a submodule and use “internal”, but that’s also much less than optimal. I want to expose a handful of functions to a handful of other types (and not expose those functions anywhere else - e.g. from my module-internal UIViewControllers which happen to contain a TabController). Also, how would I expose things from the TabController module to the outer module without making it fully &quot;public”?<br></p><p><br></p><p>&gt; What it would basically come down to is that the interface of the object would be separated in to blocks based on your access privileges. When viewing the interface, it wouldn’t look much different to an extension:<br>&gt; <br>&gt; access(public) class TabController {<br>&gt;    var tabs : [Tab] { get }<br>&gt;    func closeTab(at: Int)<br>&gt; }<br>&gt; <br>&gt; access(TabBarStuff) extension TabController {<br>&gt;     func close(tab: Tab)<br>&gt; }<br>&gt; <br>&gt; I definitely want something between internal and fileprivate, at least. I don’t see any reason at all why objects shouldn’t be allowed to present optional “slices” of their interface to appropriate clients. In fact, that is what access control is all about. I just want to generalise it to allow for user-defined visibility scopes (as well as the default ones for public, module, file and scope). That leads to the question of what visibility those user-defined scopes would have; and if you leave them entirely open to adopt any scope (except themselves), then you end up with the ability to slice your API for different use-cases. Or we could be boring and limit them to the module they are defined in.<br>&gt; <br>&gt; The whole reason I’m bringing this up is because I don’t like the “file” part of fileprivate. How I split my files up is a readability decision.<br>&gt; <br>&gt; Karl<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161008/828214da/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October  8, 2016 at 03:00:00pm</p></header><div class="content"><p>On Sat, Oct 8, 2016 at 3:24 PM, Karl &lt;razielim at gmail.com&gt; wrote:<br></p><p>&gt;<br>&gt; On 8 Oct 2016, at 21:01, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Sat, Oct 8, 2016 at 12:02 PM, Karl via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On 8 Oct 2016, at 16:47, Braeden Profile &lt;jhaezhyr12 at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Oct 8, 2016, at 6:58 AM, Karl via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I was thinking that the domains themselves could be associated with a<br>&gt;&gt; domain, so you could create alternate domains which are also<br>&gt;&gt; publicly-visible, but distinct from the default, “public” domain.<br>&gt;&gt;<br>&gt;&gt; For example, if you have a bunch of methods which should be visible to<br>&gt;&gt; subclasses, but you don’t want them to clutter your regular interface.<br>&gt;&gt; Perhaps they have names which are confusingly-similar to the public API. I<br>&gt;&gt; believe that is what “protected” is typically used for.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, but “protected&quot; was specifically put down by the core team, seeing<br>&gt;&gt; that any code from outside the library should see the class as one<br>&gt;&gt; well-designed whole, not something with complicated, visible implementation<br>&gt;&gt; details.  If your class-internal methods are confusing (and aren’t<br>&gt;&gt; necessary for normal use), they shouldn’t be made public in any way.<br>&gt;&gt; Subclasses would too easily confuse the distinction between your<br>&gt;&gt; implementation methods and your public ones.<br>&gt;&gt;<br>&gt;&gt; For what it’s worth, I was only confused by “private” and “fileprivate”<br>&gt;&gt; for a minute or two until I looked up the actual proposal.  I haven’t had<br>&gt;&gt; trouble with it, and it does actually provide more flexibility for code<br>&gt;&gt; access at the file level than we had before.  Even if the syntax is clunky.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I’m not saying that (file)private is confusing - it’s very clear about<br>&gt;&gt; what it does. But it is limiting; anything that wants access to those<br>&gt;&gt; semi-private details needs to live in the same file. That’s clearly not<br>&gt;&gt; scalable. Enormous files many thousands of lines long are easy for the<br>&gt;&gt; compiler to digest, but less easy for humans to understand and navigate. In<br>&gt;&gt; fact, I believe this whole “file-based” access control originally came out<br>&gt;&gt; of the compiler’s implementation details.<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;m interested in more information about this. What sorts of code have you<br>&gt; been writing where a file would have to be thousands of lines long in order<br>&gt; to accommodate `fileprivate`? Many entire modules are only thousands of<br>&gt; lines long--is there a reason this code couldn&#39;t be refactored into a<br>&gt; module of its own? As mentioned by Matthew, isn&#39;t this calling for some<br>&gt; notion of submodules?<br>&gt;<br>&gt;<br>&gt; The tab controller was one example:<br>&gt;<br>&gt; - final class TabController : UIViewController<br>&gt; - final class TabControllerView : UIView<br>&gt; - final class Tab : UIView<br>&gt;<br>&gt; All of these required knowledge of semi-private implementation details of<br>&gt; each-other due to the API I wanted to achieve. I wasn’t interested in<br>&gt; factoring out the interfaces in to protocols because they’re all final<br>&gt; classes and only supposed to be used with each other. For example,<br>&gt; Tab.close() called a fileprivate function in TabController to actually<br>&gt; close the tab given an instance of the underlying TabItem data structure.<br>&gt;<br></p><p>That&#39;s interesting. And if you put all the uses of `fileprivate` members of<br>TabController in the same file, that file would be thousands of lines long?<br>Have you explored options where you nest types (e.g. `TabController.View`,<br>which would be able to access private members of `TabController`?)<br></p><p>In that case, submodules wouldn’t really help. I could technically define<br>&gt; the TabController as a submodule and use “internal”, but that’s also much<br>&gt; less than optimal. I want to expose a handful of functions to a handful of<br>&gt; other types (and not expose those functions anywhere else - e.g. from my<br>&gt; module-internal UIViewControllers which happen to contain a TabController).<br>&gt; Also, how would I expose things from the TabController module to the outer<br>&gt; module without making it fully &quot;public”?<br>&gt;<br></p><p>If you want to expose only a handful of functions to a handful of other<br>types, it sounds like that would be a good use case for `fileprivate` that<br>would result in a very readable file, no?<br></p><p>&gt; What it would basically come down to is that the interface of the object<br>&gt;&gt; would be separated in to blocks based on your access privileges. When<br>&gt;&gt; viewing the interface, it wouldn’t look much different to an extension:<br>&gt;&gt;<br>&gt;&gt; *access(public)* class TabController {<br>&gt;&gt;    var tabs : [Tab] { get }<br>&gt;&gt;    func closeTab(at: Int)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; *access(TabBarStuff)* extension TabController {<br>&gt;&gt;     func close(tab: Tab)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; I definitely want something between internal and fileprivate, at least. I<br>&gt;&gt; don’t see any reason at all why objects shouldn’t be allowed to present<br>&gt;&gt; optional “slices” of their interface to appropriate clients. In fact, that<br>&gt;&gt; is what access control is all about. I just want to generalise it to allow<br>&gt;&gt; for user-defined visibility scopes (as well as the default ones for public,<br>&gt;&gt; module, file and scope). That leads to the question of what visibility<br>&gt;&gt; those user-defined scopes would have; and if you leave them entirely open<br>&gt;&gt; to adopt any scope (except themselves), then you end up with the ability to<br>&gt;&gt; slice your API for different use-cases. Or we could be boring and limit<br>&gt;&gt; them to the module they are defined in.<br>&gt;&gt;<br>&gt;&gt; The whole reason I’m bringing this up is because I don’t like the “file”<br>&gt;&gt; part of fileprivate. How I split my files up is a readability decision.<br>&gt;&gt;<br>&gt;&gt; Karl<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161008/8ac4e3df/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c60436f08b7b107f0bb0848c31297fa?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Alex Blewitt</string> &lt;alblue at apple.com&gt;<p>October 10, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 8 Oct 2016, at 20:01, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Sat, Oct 8, 2016 at 12:02 PM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On 8 Oct 2016, at 16:47, Braeden Profile &lt;jhaezhyr12 at gmail.com &lt;mailto:jhaezhyr12 at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Oct 8, 2016, at 6:58 AM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was thinking that the domains themselves could be associated with a domain, so you could create alternate domains which are also publicly-visible, but distinct from the default, “public” domain.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, if you have a bunch of methods which should be visible to subclasses, but you don’t want them to clutter your regular interface. Perhaps they have names which are confusingly-similar to the public API. I believe that is what “protected” is typically used for.<br>&gt;&gt; <br>&gt;&gt; Yes, but “protected&quot; was specifically put down by the core team, seeing that any code from outside the library should see the class as one well-designed whole, not something with complicated, visible implementation details.  If your class-internal methods are confusing (and aren’t necessary for normal use), they shouldn’t be made public in any way.  Subclasses would too easily confuse the distinction between your implementation methods and your public ones.<br>&gt;&gt; <br>&gt;&gt; For what it’s worth, I was only confused by “private” and “fileprivate” for a minute or two until I looked up the actual proposal.  I haven’t had trouble with it, and it does actually provide more flexibility for code access at the file level than we had before.  Even if the syntax is clunky.<br>&gt; <br>&gt; I’m not saying that (file)private is confusing - it’s very clear about what it does. But it is limiting; anything that wants access to those semi-private details needs to live in the same file. That’s clearly not scalable. Enormous files many thousands of lines long are easy for the compiler to digest, but less easy for humans to understand and navigate. In fact, I believe this whole “file-based” access control originally came out of the compiler’s implementation details.<br>&gt; <br>&gt; I&#39;m interested in more information about this. What sorts of code have you been writing where a file would have to be thousands of lines long in order to accommodate `fileprivate`? Many entire modules are only thousands of lines long--is there a reason this code couldn&#39;t be refactored into a module of its own? As mentioned by Matthew, isn&#39;t this calling for some notion of submodules?<br></p><p>I&#39;m implementing NSDecimal in Swift and it uses fileprivate to wrap up scope for internal implementation details. The implementation that I&#39;ve got on my GitHub account is currently at 885 lines; but I&#39;m still working on other parts and my currently checked out version has 1125 lines of code, in a single file.<br></p><p>https://github.com/alblue/swift-corelibs-foundation/blob/nsdecimal/Foundation/NSDecimal.swift &lt;https://github.com/alblue/swift-corelibs-foundation/blob/nsdecimal/Foundation/NSDecimal.swift&gt;<br></p><p>Submodules aren&#39;t the right answer here, because Foundation as a while is a module that won&#39;t be split apart. And for performance reasons, you want the internal functions (defined fileprivate) to be considered as eligible for optimisation by the compiler in the absence of (say) whole module optimisation.<br></p><p>Right now, the only way to do that is to have the fiileprivate implementations in the same file as the rest of the implementation.<br></p><p>Alex<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/b7d19319/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 10, 2016 at 12:00:00pm</p></header><div class="content"><p>I don&#39;t find this example persuasive, because:<br></p><p>1125 LOC is on the long side for a single file, but not by any means<br>&quot;thousands&quot; of LOC.<br></p><p>In any case, having hacked on corelibs-foundation myself, my sense is that<br>its files are organized in such a way that NSDecimal would be expected to<br>be implemented in a single file regardless of length.<br></p><p>If Swift had submodules, there&#39;s no reason to say that Foundation wouldn&#39;t<br>make use of them to organize its types.<br></p><p>Even if you wished to share implementation details between, say, a<br>hypothetically split up NSDecimal and Decimal, fileprivate members of<br>NSDecimal could simply be internal instead, as is done elsewhere in<br>corelibs-foundation. Note by comparison that, for implementation reasons,<br>stdlib doesn&#39;t use fileprivate scope and all implementation details are<br>internal or even public and underscored. A compelling argument for more<br>fine-grained controls here would demonstrate how internal scope in stdlib<br>or corelibs-foundation actually led to a bug that could have been<br>prevented--I don&#39;t think any such bug exists.<br>On Mon, Oct 10, 2016 at 04:30 Alex Blewitt &lt;alblue at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On 8 Oct 2016, at 20:01, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Sat, Oct 8, 2016 at 12:02 PM, Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 8 Oct 2016, at 16:47, Braeden Profile &lt;jhaezhyr12 at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Oct 8, 2016, at 6:58 AM, Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I was thinking that the domains themselves could be associated with a<br>&gt; domain, so you could create alternate domains which are also<br>&gt; publicly-visible, but distinct from the default, “public” domain.<br>&gt;<br>&gt; For example, if you have a bunch of methods which should be visible to<br>&gt; subclasses, but you don’t want them to clutter your regular interface.<br>&gt; Perhaps they have names which are confusingly-similar to the public API. I<br>&gt; believe that is what “protected” is typically used for.<br>&gt;<br>&gt;<br>&gt; Yes, but “protected&quot; was specifically put down by the core team, seeing<br>&gt; that any code from outside the library should see the class as one<br>&gt; well-designed whole, not something with complicated, visible implementation<br>&gt; details.  If your class-internal methods are confusing (and aren’t<br>&gt; necessary for normal use), they shouldn’t be made public in any way.<br>&gt; Subclasses would too easily confuse the distinction between your<br>&gt; implementation methods and your public ones.<br>&gt;<br>&gt; For what it’s worth, I was only confused by “private” and “fileprivate”<br>&gt; for a minute or two until I looked up the actual proposal.  I haven’t had<br>&gt; trouble with it, and it does actually provide more flexibility for code<br>&gt; access at the file level than we had before.  Even if the syntax is clunky.<br>&gt;<br>&gt;<br>&gt; I’m not saying that (file)private is confusing - it’s very clear about<br>&gt; what it does. But it is limiting; anything that wants access to those<br>&gt; semi-private details needs to live in the same file. That’s clearly not<br>&gt; scalable. Enormous files many thousands of lines long are easy for the<br>&gt; compiler to digest, but less easy for humans to understand and navigate. In<br>&gt; fact, I believe this whole “file-based” access control originally came out<br>&gt; of the compiler’s implementation details.<br>&gt;<br>&gt;<br>&gt; I&#39;m interested in more information about this. What sorts of code have you<br>&gt; been writing where a file would have to be thousands of lines long in order<br>&gt; to accommodate `fileprivate`? Many entire modules are only thousands of<br>&gt; lines long--is there a reason this code couldn&#39;t be refactored into a<br>&gt; module of its own? As mentioned by Matthew, isn&#39;t this calling for some<br>&gt; notion of submodules?<br>&gt;<br>&gt;<br>&gt; I&#39;m implementing NSDecimal in Swift and it uses fileprivate to wrap up<br>&gt; scope for internal implementation details. The implementation that I&#39;ve got<br>&gt; on my GitHub account is currently at 885 lines; but I&#39;m still working on<br>&gt; other parts and my currently checked out version has 1125 lines of code, in<br>&gt; a single file.<br>&gt;<br>&gt;<br>&gt; https://github.com/alblue/swift-corelibs-foundation/blob/nsdecimal/Foundation/NSDecimal.swift<br>&gt;<br>&gt; Submodules aren&#39;t the right answer here, because Foundation as a while is<br>&gt; a module that won&#39;t be split apart. And for performance reasons, you want<br>&gt; the internal functions (defined fileprivate) to be considered as eligible<br>&gt; for optimisation by the compiler in the absence of (say) whole module<br>&gt; optimisation.<br>&gt;<br>&gt; Right now, the only way to do that is to have the fiileprivate<br>&gt; implementations in the same file as the rest of the implementation.<br>&gt;<br>&gt; Alex<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/648e9ae5/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>October  8, 2016 at 05:00:00pm</p></header><div class="content"><p>As far as I can see, almost all people, who talk here, agree that private /<br>fileprivate distinction brought more harm than good. Despite corresponding<br>proposal being accepted.<br>I think, it means that current mailing-list system is failing. Let&#39;s accept<br>it, gmane looks and feels ugly by comparison to forums. And using email<br>limits the number of people involved by an order of magnitude.<br>What we need is popularization of SE, reaching as many developers as we<br>can, using simple voting, likes, and so on.<br></p><p>2016-10-08 12:31 GMT+03:00 Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt;<br>&gt; &gt; On 7 Oct 2016, at 22:44, Tony Allevato via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; personally I thought `private` was fine the way it was when it meant<br>&gt; `fileprivate` and I had no real need for `private` as it exists in Swift 3.<br>&gt;<br>&gt; I have to agree with this; I wasn&#39;t especially comfortable with the change<br>&gt; (or the eventual choice of keyword style) and in practice I just don&#39;t find<br>&gt; it useful. I haven&#39;t used the new &quot;private&quot; even once since it was added,<br>&gt; except by accident, the only form of private I use is fileprivate.<br>&gt;<br>&gt; I&#39;ve happily embraced the conform through extension style in Swift, and<br>&gt; really when it comes down to it the new private access level just isn&#39;t<br>&gt; compatible with that style of development. It&#39;s only really useful for<br>&gt; hiding details of something you add in one specific section, which I almost<br>&gt; never do (and when I do I just mark it fileprivate in case I can re-use it).<br>&gt;<br>&gt; Maybe some people do find it useful, but I&#39;d prefer fileprivate to be the<br>&gt; default behaviour of private; the current (scoped?) private access level<br>&gt; seems far more limited, thus more deserving of a less convenient keyword,<br>&gt; or some kind of modifier on private. But personally I&#39;d be fine with<br>&gt; removing it, as I don&#39;t think it really adds anything that fileprivate<br>&gt; doesn&#39;t already cover.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161008/aac3b478/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>October 13, 2016 at 02:00:00pm</p></header><div class="content"><p>On Sat, Oct 8, 2016, at 07:42 AM, Anton Zhilin via swift-evolution wrote:<br>&gt; As far as I can see, almost all people, who talk here, agree that<br>&gt; private / fileprivate distinction brought more harm than good. Despite<br>&gt; corresponding proposal being accepted.<br>&gt; I think, it means that current mailing-list system is failing. Let&#39;s<br>&gt; accept it, gmane looks and feels ugly by comparison to forums. And<br>&gt; using email limits the number of people involved by an order of<br>&gt; magnitude.<br>&gt; What we need is popularization of SE, reaching as many developers as<br>&gt; we can, using simple voting, likes, and so on.<br></p><p>This is a bad conclusion. Discussions like this naturally attract people<br>who are unhappy with the status quo. So it&#39;s no surprise that you&#39;re<br>seeing a lot of people say they don&#39;t like private. Personally, I *love*<br>having the new private and I use it almost everywhere. It&#39;s very rare<br>for me to write fileprivate and when I do, it&#39;s an intentional decision.<br>And the only reason I even saw this thread is because someone linked it<br>to me on Slack.<br></p><p>-Kevin Ballard<br></p><p>&gt; 2016-10-08 12:31 GMT+03:00 Haravikk via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; &gt; On 7 Oct 2016, at 22:44, Tony Allevato via swift-evolution &lt;swift-<br>&gt;&gt; &gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;  &gt; personally I thought `private` was fine the way it was when it<br>&gt;&gt;  &gt; meant `fileprivate` and I had no real need for `private` as it<br>&gt;&gt;  &gt; exists in Swift 3.<br>&gt;&gt;<br>&gt;&gt; I have to agree with this; I wasn&#39;t especially comfortable with the<br>&gt;&gt; change (or the eventual choice of keyword style) and in practice I<br>&gt;&gt; just don&#39;t find it useful. I haven&#39;t used the new &quot;private&quot; even once<br>&gt;&gt; since it was added, except by accident, the only form of private I<br>&gt;&gt; use is fileprivate.<br>&gt;&gt;<br>&gt;&gt;  I&#39;ve happily embraced the conform through extension style in Swift,<br>&gt;&gt;  and really when it comes down to it the new private access level<br>&gt;&gt;  just isn&#39;t compatible with that style of development. It&#39;s only<br>&gt;&gt;  really useful for hiding details of something you add in one<br>&gt;&gt;  specific section, which I almost never do (and when I do I just mark<br>&gt;&gt;  it fileprivate in case I can re-use it).<br>&gt;&gt;<br>&gt;&gt;  Maybe some people do find it useful, but I&#39;d prefer fileprivate to<br>&gt;&gt;  be the default behaviour of private; the current (scoped?) private<br>&gt;&gt;  access level seems far more limited, thus more deserving of a less<br>&gt;&gt;  convenient keyword, or some kind of modifier on private. But<br>&gt;&gt;  personally I&#39;d be fine with removing it, as I don&#39;t think it really<br>&gt;&gt;  adds anything that fileprivate doesn&#39;t already cover.<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161013/0c828113/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b0a8a8751387599c6d98c36808e8916c?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>William Sumner</string> &lt;prestonsumner at me.com&gt;<p>October  7, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 3:05 PM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I third this sentiment. fileprivate is a nice idea and very clearly has its uses (which is why the proposal got traction in the first place), but when combined with the other access levels, the language feature as a whole feels arbitrary. In practical use, files that I felt were nicely encapsulated and hiding implementation details are now a scattered mix of access levels, adding cognitive load and making the code look unorganized for having the gall to use extensions to split up functionality.<br>&gt; <br>&gt; Sincerely,<br>&gt;   Zachary Waldowski<br>&gt;   zach at waldowski.me &lt;mailto:zach at waldowski.me&gt;<br></p><p>Beyond the textual change of using a different modifier name, I don’t see how the encapsulation and organization of code could be affected. Really, there’s not much point in rehashing prior discussion of SE-0025 unless there’s a previously unconsidered angle.<br></p><p>Preston<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/18434c02/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>October  7, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 15:15, William Sumner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 7, 2016, at 3:05 PM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I third this sentiment. fileprivate is a nice idea and very clearly has its uses (which is why the proposal got traction in the first place), but when combined with the other access levels, the language feature as a whole feels arbitrary. In practical use, files that I felt were nicely encapsulated and hiding implementation details are now a scattered mix of access levels, adding cognitive load and making the code look unorganized for having the gall to use extensions to split up functionality.<br>&gt;&gt; <br>&gt;&gt; Sincerely,<br>&gt;&gt;   Zachary Waldowski<br>&gt;&gt;   zach at waldowski.me &lt;mailto:zach at waldowski.me&gt;<br>&gt; <br>&gt; Beyond the textual change of using a different modifier name, I don’t see how the encapsulation and organization of code could be affected. Really, there’s not much point in rehashing prior discussion of SE-0025 unless there’s a previously unconsidered angle.<br></p><p>I strongly agree with this sentiment. SE-0025 was very heavily discussed, and while many people were not satisfied with the solution we went with (including me!), it was what the core team and community converged on. I don&#39;t expect us to change access control again until and unless we decide to change the model in some way, and even then I think we&#39;ll want to go through extra effort to maintain compatibility with Swift 3. As has been mentioned repeatedly, the bar for source-breaking changes is much higher than it was in the first few months of swift-evolution.<br></p><p>I actually consider it very lucky that most of our changes so far have been fairly non-controversial. Everybody has a different idea of what would make Swift a better language, and all of us well-meaning. But when those ideas conflict, some group is going to end up unhappy. I&#39;m actually very glad that (a) we haven&#39;t had too many of these cases, and (b) even when we have, people have been able to accept it and move on to contributing to the next issue.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/4c341b1e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>October  7, 2016 at 07:00:00pm</p></header><div class="content"><p>While I agree that private/fileprivate didn&#39;t change much… I have to say<br>that I wish we had simply kept private as is and ended up with private,<br>internal, public, and open. It is more tricky to explain than it is worth.<br></p><p>TJ<br></p><p><br>On Fri, Oct 7, 2016 at 6:56 PM, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Oct 7, 2016, at 15:15, William Sumner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Oct 7, 2016, at 3:05 PM, Zach Waldowski via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I third this sentiment. fileprivate is a nice idea and very clearly has<br>&gt; its uses (which is why the proposal got traction in the first place), but<br>&gt; when combined with the other access levels, the language feature as a whole<br>&gt; feels arbitrary. In practical use, files that I felt were nicely<br>&gt; encapsulated and hiding implementation details are now a scattered mix of<br>&gt; access levels, adding cognitive load and making the code look unorganized<br>&gt; for having the gall to use extensions to split up functionality.<br>&gt;<br>&gt; Sincerely,<br>&gt;   Zachary Waldowski<br>&gt;   zach at waldowski.me<br>&gt;<br>&gt;<br>&gt; Beyond the textual change of using a different modifier name, I don’t see<br>&gt; how the encapsulation and organization of code could be affected. Really,<br>&gt; there’s not much point in rehashing prior discussion of SE-0025 unless<br>&gt; there’s a previously unconsidered angle.<br>&gt;<br>&gt;<br>&gt; I *strongly* agree with this sentiment. SE-0025 was *very* heavily<br>&gt; discussed, and while many people were not satisfied with the solution we<br>&gt; went with (including me!), it was what the core team and community<br>&gt; converged on. I don&#39;t expect us to change access control again until and<br>&gt; unless we decide to change the model in some way, and even then I think<br>&gt; we&#39;ll want to go through extra effort to maintain compatibility with Swift<br>&gt; 3. As has been mentioned repeatedly, the bar for source-breaking changes is<br>&gt; much higher than it was in the first few months of swift-evolution.<br>&gt;<br>&gt; I actually consider it very lucky that most of our changes so far have<br>&gt; been fairly non-controversial. Everybody has a different idea of what would<br>&gt; make Swift a better language, and all of us well-meaning. But when those<br>&gt; ideas conflict, some group is going to end up unhappy. I&#39;m actually very<br>&gt; glad that (a) we haven&#39;t had too many of these cases, and (b) even when we<br>&gt; have, people have been able to accept it and move on to contributing to the<br>&gt; next issue.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/9ca9b6e9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>October  7, 2016 at 04:00:00pm</p></header><div class="content"><p>On Fri, Oct 7, 2016, at 03:56 PM, Jordan Rose wrote:<br>&gt; SE-0025 was *very* heavily discussed, and while many people were not<br>&gt; satisfied with the solution we went with (including me!), it was what<br>&gt; the core team and community converged on.<br></p><p>Politely playing the Devil&#39;s Advocate: it was still fairly early on in<br>the lifecycle of swift-evolution, particularly for the 3 cycle; the<br>discussion was heavily weighted towards the people who wanted a change,<br>versus those who were happy with the status quo. I don&#39;t like playing<br>the Silent Majority card, as it&#39;s a horribly weak fallacy, but it is<br>what it is.<br></p><p>(responding up-thread now to William…)<br></p><p>&gt;&gt;&gt; On Oct 7, 2016, at 15:15, William Sumner via swift-evolution &lt;swift-<br>&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Really, there’s not much point in rehashing prior discussion of SE-<br>&gt;&gt;&gt; 0025 unless there’s a previously unconsidered angle.<br></p><p>The new information is that Swift 3 is in the wild. People have gotten<br>to use it, users both new and old, and have been dismayed and confused,<br>respectively, with the change.<br></p><p>I appreciate the need for the community to keep pushing forward and not<br>constantly revisit and counter-proposal things, I really do. It&#39;s why I<br>was glad it seemed like &quot;requiring `self.`&quot; was laid to bed so<br>conclusively. But this isn&#39;t like C-style for loops, I&#39;m not clinging to<br>my guns and incrementors; we&#39;ve taken something that enjoyed a quite<br>simple mental model, even though it was limited compared to other<br>languages, and made it arbitrarily more complex.<br></p><p>Having come to a consensus (which I disagree happened; more the clock<br>ran ) shouldn&#39;t mean it&#39;s locked in stone forever. In fact, the<br>potential for reconsidering was mentioned by many in response to the<br>blowback to sealed-by-default, and was  used for justification as to why<br>it &quot;had&quot; to be considered for Swift 3.<br></p><p>It&#39;s important to recognize our mistakes and not get into the trap of<br>thinking the mailing list is the ground truth of all  Swift users.<br></p><p>Best —<br>Zach<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/04cdb4b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/45196398e9685000d195ec626d477f0e?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Trans</string> &lt;transfire at gmail.com&gt;<p>October  7, 2016 at 07:00:00pm</p></header><div class="content"><p>Private access that limits exposure to extensions and subclasses is<br>the bane of reusability. It sucks in Java and it sucks in Swift. As<br>far as I know Ruby is the only language that seems to get that.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6e0bf2aabb9fc16782586e834dc6e2d7?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Braeden Profile</string> &lt;jhaezhyr12 at gmail.com&gt;<p>October  7, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; On Oct 7, 2016, at 5:46 PM, Trans via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Private access that limits exposure to extensions and subclasses is<br>&gt; the bane of reusability. It sucks in Java and it sucks in Swift. As<br>&gt; far as I know Ruby is the only language that seems to get that.<br></p><p>Agreed.  Reading this thread, almost everyone’s presented actual use cases would be fixed if we could do something functionally equivalent to private(type) (even if that’s not the best syntax).  If we could have the ability to write extensions for a type throughout a module and access its private properties (and private subtypes, methods, etc.), then the ugliness introduced by fileprivate would be all but eliminated.  That’s an access level I would love.<br></p><p>I do want to mention, though, that while I would enjoy C++-style type-level private, I don’t want protected.  The rationale for avoiding that in Swift is fantastic.<br></p><p>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October  7, 2016 at 09:00:00pm</p></header><div class="content"><p>On Fri, Oct 7, 2016 at 8:49 PM, Braeden Profile via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt;<br>&gt; &gt; On Oct 7, 2016, at 5:46 PM, Trans via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Private access that limits exposure to extensions and subclasses is<br>&gt; &gt; the bane of reusability. It sucks in Java and it sucks in Swift. As<br>&gt; &gt; far as I know Ruby is the only language that seems to get that.<br>&gt;<br>&gt; Agreed.  Reading this thread, almost everyone’s presented actual use cases<br>&gt; would be fixed if we could do something functionally equivalent to<br>&gt; private(type) (even if that’s not the best syntax).  If we could have the<br>&gt; ability to write extensions for a type throughout a module and access its<br>&gt; private properties (and private subtypes, methods, etc.), then the ugliness<br>&gt; introduced by fileprivate would be all but eliminated.  That’s an access<br>&gt; level I would love.<br>&gt;<br>&gt; I do want to mention, though, that while I would enjoy C++-style<br>&gt; type-level private, I don’t want protected.  The rationale for avoiding<br>&gt; that in Swift is fantastic.<br></p><p><br>If I recall correctly, this idea was also put forward during the original<br>SE-0025 discussions. However, the design we have now was chosen over this<br>alternative and others. I was one of those people who didn&#39;t really like<br>the new private, didn&#39;t like `fileprivate`, and generally felt that<br>alternative designs (or even the Swift 2 status quo) could be superior.<br>But, the discussion was had, all of these viewpoints and more were aired<br>and mulled over, and a consensus was reached. It&#39;d have to be some<br>startling new insight to justify yet another change for Swift 4.<br></p><p>&gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/564505a6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>October  8, 2016 at 08:00:00am</p></header><div class="content"><p>Comments inline:<br></p><p>&gt; On 8 Oct 2016, at 00:56, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Oct 7, 2016, at 15:15, William Sumner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Oct 7, 2016, at 3:05 PM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I third this sentiment. fileprivate is a nice idea and very clearly has its uses (which is why the proposal got traction in the first place), but when  combined with the other access levels, the language feature as a whole feels arbitrary. In practical use, files that I felt were nicely encapsulated and hiding implementation details are now a scattered mix of access levels, adding cognitive load and making the code look unorganized for having the gall to use extensions to split up functionality.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sincerely,<br>&gt;&gt;&gt;   Zachary Waldowski<br>&gt;&gt;&gt;   zach at waldowski.me<br>&gt;&gt; <br>&gt;&gt; Beyond the textual change of using a different modifier name, I don’t see how the encapsulation and organization of code could be affected. Really, there’s not much point in rehashing prior discussion of SE-0025 unless there’s a previously unconsidered angle.<br>&gt; <br>&gt; I strongly agree with this sentiment. SE-0025 was very heavily discussed, and while many people were not satisfied with the solution we went with (including me!), it was what the core team and community converged on. I don&#39;t expect us to change access control again until and unless we decide to change the model in some way, and even then I think we&#39;ll want to go through extra effort to maintain compatibility with Swift 3. As has been mentioned repeatedly, the bar for source-breaking changes is much higher than it was in the first few months of swift-evolution.<br>&gt; <br>&gt; I actually consider it very lucky that most of our changes so far have been fairly non-controversial.<br></p><p>I agree. But I think this one is different, and that&#39;s why I brought it up :)<br></p><p>&gt; Everybody has a different idea of what would make Swift a better language, and all of us well-meaning. But when those ideas conflict, some group is going to end up unhappy. I&#39;m actually very glad that (a) we haven&#39;t had too many of these cases, and (b) even when we have, people have been able to accept it and move on to contributing to the next issue.<br></p><p>For me, this is not a question of people being unhappy. I&#39;ve seen create confusion to both old and new Swift developers.<br></p><p>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161008/58fbeb67/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>October 10, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 3:56 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 7, 2016, at 15:15, William Sumner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 7, 2016, at 3:05 PM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I third this sentiment. fileprivate is a nice idea and very clearly has its uses (which is why the proposal got traction in the first place), but when combined with the other access levels, the language feature as a whole feels arbitrary. In practical use, files that I felt were nicely encapsulated and hiding implementation details are now a scattered mix of access levels, adding cognitive load and making the code look unorganized for having the gall to use extensions to split up functionality.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sincerely,<br>&gt;&gt;&gt;   Zachary Waldowski<br>&gt;&gt;&gt;   zach at waldowski.me &lt;mailto:zach at waldowski.me&gt;<br>&gt;&gt; <br>&gt;&gt; Beyond the textual change of using a different modifier name, I don’t see how the encapsulation and organization of code could be affected. Really, there’s not much point in rehashing prior discussion of SE-0025 unless there’s a previously unconsidered angle.<br>&gt; <br>&gt; I strongly agree with this sentiment. SE-0025 was very heavily discussed, and while many people were not satisfied with the solution we went with (including me!), it was what the core team and community converged on. I don&#39;t expect us to change access control again until and unless we decide to change the model in some way, and even then I think we&#39;ll want to go through extra effort to maintain compatibility with Swift 3. As has been mentioned repeatedly, the bar for source-breaking changes is much higher than it was in the first few months of swift-evolution.<br>&gt; <br>&gt; I actually consider it very lucky that most of our changes so far have been fairly non-controversial. Everybody has a different idea of what would make Swift a better language, and all of us well-meaning. But when those ideas conflict, some group is going to end up unhappy. I&#39;m actually very glad that (a) we haven&#39;t had too many of these cases, and (b) even when we have, people have been able to accept it and move on to contributing to the next issue.<br></p><p><br>Strong agreement here as well. This proposal has been litigated numerous times already, and the bar for source-breaking changes is much higher now. To effectively re-open the discussion would require a proposal that significant changes the model with a lot of evidence that such a new model is a drastic improvement over what we have now. “Back out SE-0025” is not a viable option now.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/000a94b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>October 10, 2016 at 11:00:00pm</p></header><div class="content"><p>Unfortunately, my agreement may come off a bit backhanded. IMHO, the “fileprivate” problem is due to SE-0025 trying to add sophistication to access control too fast. <br></p><p>My observation is that Swift developers as a whole really have not yet come to a conclusion that the permissions already present in the language were truly insufficient for large scale software development.  More so, *how* they are insufficient wasn’t clearly represented - for instance, I’ve heard complaints that files become too large by having to bundle dependent extensions and classes, but SE-0025 did little to target their desire for a more manageable codebase. Instead, it allows them to make sections of those large files “more private”.<br></p><p>I’m convinced as the Swift language and other Swift-based projects both gain more maturity, we will be able to get a holistic view of how access control should work and how it should correlate to project structure. Before then, any change may simply do more harm than good.<br></p><p>-DW<br></p><p>&gt; On Oct 10, 2016, at 10:59 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Oct 7, 2016, at 3:56 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; On Oct 7, 2016, at 15:15, William Sumner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Oct 7, 2016, at 3:05 PM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Beyond the textual change of using a different modifier name, I don’t see how the encapsulation and organization of code could be affected. Really, there’s not much point in rehashing prior discussion of SE-0025 unless there’s a previously unconsidered angle.<br>&gt;&gt; <br>&gt;&gt; I strongly agree with this sentiment. SE-0025 was very heavily discussed, and while many people were not satisfied with the solution we went with (including me!), it was what the core team and community converged on. I don&#39;t expect us to change access control again until and unless we decide to change the model in some way, and even then I think we&#39;ll want to go through extra effort to maintain compatibility with Swift 3. As has been mentioned repeatedly, the bar for source-breaking changes is much higher than it was in the first few months of swift-evolution.<br>&gt;&gt; <br>&gt;&gt; I actually consider it very lucky that most of our changes so far have been fairly non-controversial. Everybody has a different idea of what would make Swift a better language, and all of us well-meaning. But when those ideas conflict, some group is going to end up unhappy. I&#39;m actually very glad that (a) we haven&#39;t had too many of these cases, and (b) even when we have, people have been able to accept it and move on to contributing to the next issue.<br>&gt; <br>&gt; <br>&gt; Strong agreement here as well. This proposal has been litigated numerous times already, and the bar for source-breaking changes is much higher now. To effectively re-open the discussion would require a proposal that significant changes the model with a lot of evidence that such a new model is a drastic improvement over what we have now. “Back out SE-0025” is not a viable option now.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/b0760fa7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>October 12, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Oct 10, 2016, at 9:59 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 7, 2016, at 3:56 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Oct 7, 2016, at 15:15, William Sumner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 7, 2016, at 3:05 PM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I third this sentiment. fileprivate is a nice idea and very clearly has its uses (which is why the proposal got traction in the first place), but when combined with the other access levels, the language feature as a whole feels arbitrary. In practical use, files that I felt were nicely encapsulated and hiding implementation details are now a scattered mix of access levels, adding cognitive load and making the code look unorganized for having the gall to use extensions to split up functionality.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sincerely,<br>&gt;&gt;&gt;&gt;   Zachary Waldowski<br>&gt;&gt;&gt;&gt;   zach at waldowski.me &lt;mailto:zach at waldowski.me&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Beyond the textual change of using a different modifier name, I don’t see how the encapsulation and organization of code could be affected. Really, there’s not much point in rehashing prior discussion of SE-0025 unless there’s a previously unconsidered angle.<br>&gt;&gt; <br>&gt;&gt; I strongly agree with this sentiment. SE-0025 was very heavily discussed, and while many people were not satisfied with the solution we went with (including me!), it was what the core team and community converged on. I don&#39;t expect us to change access control again until and unless we decide to change the model in some way, and even then I think we&#39;ll want to go through extra effort to maintain compatibility with Swift 3. As has been mentioned repeatedly, the bar for source-breaking changes is much higher than it was in the first few months of swift-evolution.<br>&gt;&gt; <br>&gt;&gt; I actually consider it very lucky that most of our changes so far have been fairly non-controversial. Everybody has a different idea of what would make Swift a better language, and all of us well-meaning. But when those ideas conflict, some group is going to end up unhappy. I&#39;m actually very glad that (a) we haven&#39;t had too many of these cases, and (b) even when we have, people have been able to accept it and move on to contributing to the next issue.<br>&gt; <br>&gt; <br>&gt; Strong agreement here as well. This proposal has been litigated numerous times already, and the bar for source-breaking changes is much higher now. To effectively re-open the discussion would require a proposal that significant changes the model with a lot of evidence that such a new model is a drastic improvement over what we have now. “Back out SE-0025” is not a viable option now.<br>&gt; <br>&gt; 	- Doug<br></p><p>Not really. This proposal could be backed out without source-breaking changes by treating private as a synonym for fileprivate and we’d have Swift 2 behavior without breaking source. If the core team doesn’t want to consider that then we can just move on and live with it. <br></p><p>Everyone needs to disagree and commit at one time or another. It just irks me because it’s so ugly :)<br></p><p>Russ<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/1e6cfc20/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>October 12, 2016 at 10:00:00pm</p></header><div class="content"><p>On Oct 12, 2016, at 9:56 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I actually consider it very lucky that most of our changes so far have been fairly non-controversial. Everybody has a different idea of what would make Swift a better language, and all of us well-meaning. But when those ideas conflict, some group is going to end up unhappy. I&#39;m actually very glad that (a) we haven&#39;t had too many of these cases, and (b) even when we have, people have been able to accept it and move on to contributing to the next issue.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Strong agreement here as well. This proposal has been litigated numerous times already, and the bar for source-breaking changes is much higher now. To effectively re-open the discussion would require a proposal that significant changes the model with a lot of evidence that such a new model is a drastic improvement over what we have now. “Back out SE-0025” is not a viable option now.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt; <br>&gt; Not really. This proposal could be backed out without source-breaking changes by treating private as a synonym for fileprivate and we’d have Swift 2 behavior without breaking source. If the core team doesn’t want to consider that then we can just move on and live with it. <br></p><p>Not speaking for the core team, just MHO:<br></p><p>I agree with Russ here, and with others who have said upthread that the “thing that has changed” is that we are starting to get usage experience with fileprivate vs private.  I think we all understand the value of having fewer access control levels, and so if “private” isn’t conceptually pulling its weight, then it is reasonable to consider phasing it out.<br></p><p>That said, there is no specific rush to have this discussion, and I think it is reasonable to put a pretty high burden of proof on someone who wants to drive such a proposal.  For example, if we had the discussion in the spring timeframe, we should have a pretty large body of Swift 3 code readily at hand (e.g. SwiftPM packages and other various github repos).<br></p><p>Given that, it should be easy enough to see how widely private is actually being used in practice.  If it is very rare, then the argument to ditch it (make it a synonym for fileprivate, and eventually phasing out fileprivate) is strong.  If lots of people are using private and only some are using fileprivate, then the discussion is quite different.<br></p><p>-Chris<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/1e4ec42b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f5f87c6d6b2f41c3ac647171eb30e34?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Jean-Daniel</string> &lt;dev at xenonium.com&gt;<p>October 13, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Le 13 oct. 2016 à 07:52, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; On Oct 12, 2016, at 9:56 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; I actually consider it very lucky that most of our changes so far have been fairly non-controversial. Everybody has a different idea of what would make Swift a better language, and all of us well-meaning. But when those ideas conflict, some group is going to end up unhappy. I&#39;m actually very glad that (a) we haven&#39;t had too many of these cases, and (b) even when we have, people have been able to accept it and move on to contributing to the next issue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Strong agreement here as well. This proposal has been litigated numerous times already, and the bar for source-breaking changes is much higher now. To effectively re-open the discussion would require a proposal that significant changes the model with a lot of evidence that such a new model is a drastic improvement over what we have now. “Back out SE-0025” is not a viable option now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; Not really. This proposal could be backed out without source-breaking changes by treating private as a synonym for fileprivate and we’d have Swift 2 behavior without breaking source. If the core team doesn’t want to consider that then we can just move on and live with it. <br>&gt; <br>&gt; Not speaking for the core team, just MHO:<br>&gt; <br>&gt; I agree with Russ here, and with others who have said upthread that the “thing that has changed” is that we are starting to get usage experience with fileprivate vs private.  I think we all understand the value of having fewer access control levels, and so if “private” isn’t conceptually pulling its weight, then it is reasonable to consider phasing it out.<br>&gt; <br>&gt; That said, there is no specific rush to have this discussion, and I think it is reasonable to put a pretty high burden of proof on someone who wants to drive such a proposal.  For example, if we had the discussion in the spring timeframe, we should have a pretty large body of Swift 3 code readily at hand (e.g. SwiftPM packages and other various github repos).<br>&gt; <br>&gt; Given that, it should be easy enough to see how widely private is actually being used in practice.  If it is very rare, then the argument to ditch it (make it a synonym for fileprivate, and eventually phasing out fileprivate) is strong.  If lots of people are using private and only some are using fileprivate, then the discussion is quite different.<br>&gt; <br>&gt; -Chris<br></p><p>I don’t think monitoring the usage of private vs fileprivate is fair. By default, people will use private until they encounter visibility issues and discover they need to change to fileprivate. So private will probably being use far more than fileprivate.<br>Nonetheless it does not mean people chosen private because it effectively reduce the visibility to the class scope, but just because it is easier to discover and to type than fileprivate and fit in many cases.<br></p><p>I tend to write class will all ivars private by default (as it is a sensible default), and then, when I start to write extensions and other parts, I have to switch to fileprivate for a bunch of ivars. It create an inconsistent mess in my ivars declaration as it is difficult to know if an ivar is private because I has to be, or because I didn’t encounter a case that need it to be fileprivate instead.<br></p><p>Honestly, I don’t see any value in the introduction of fileprivate.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161013/4693ac05/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>October 13, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 13 Oct 2016, at 08:25, Jean-Daniel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 13 oct. 2016 à 07:52, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; On Oct 12, 2016, at 9:56 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I actually consider it very lucky that most of our changes so far have been fairly non-controversial. Everybody has a different idea of what would make Swift a better language, and all of us well-meaning. But when those ideas conflict, some group is going to end up unhappy. I&#39;m actually very glad that (a) we haven&#39;t had too many of these cases, and (b) even when we have, people have been able to accept it and move on to contributing to the next issue.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Strong agreement here as well. This proposal has been litigated numerous times already, and the bar for source-breaking changes is much higher now. To effectively re-open the discussion would require a proposal that significant changes the model with a lot of evidence that such a new model is a drastic improvement over what we have now. “Back out SE-0025” is not a viable option now.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not really. This proposal could be backed out without source-breaking changes by treating private as a synonym for fileprivate and we’d have Swift 2 behavior without breaking source. If the core team doesn’t want to consider that then we can just move on and live with it. <br>&gt;&gt; <br>&gt;&gt; Not speaking for the core team, just MHO:<br>&gt;&gt; <br>&gt;&gt; I agree with Russ here, and with others who have said upthread that the “thing that has changed” is that we are starting to get usage experience with fileprivate vs private.  I think we all understand the value of having fewer access control levels, and so if “private” isn’t conceptually pulling its weight, then it is reasonable to consider phasing it out.<br>&gt;&gt; <br>&gt;&gt; That said, there is no specific rush to have this discussion, and I think it is reasonable to put a pretty high burden of proof on someone who wants to drive such a proposal.  For example, if we had the discussion in the spring timeframe, we should have a pretty large body of Swift 3 code readily at hand (e.g. SwiftPM packages and other various github repos).<br>&gt;&gt; <br>&gt;&gt; Given that, it should be easy enough to see how widely private is actually being used in practice.  If it is very rare, then the argument to ditch it (make it a synonym for fileprivate, and eventually phasing out fileprivate) is strong.  If lots of people are using private and only some are using fileprivate, then the discussion is quite different.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; I don’t think monitoring the usage of private vs fileprivate is fair. By default, people will use private until they encounter visibility issues and discover they need to change to fileprivate. So private will probably being use far more than fileprivate.<br>&gt; Nonetheless it does not mean people chosen private because it effectively reduce the visibility to the class scope, but just because it is easier to discover and to type than fileprivate and fit in many cases.<br>&gt; <br>&gt; I tend to write class will all ivars private by default (as it is a sensible default), and then, when I start to write extensions and other parts, I have to switch to fileprivate for a bunch of ivars. It create an inconsistent mess in my ivars declaration as it is difficult to know if an ivar is private because I has to be, or because I didn’t encounter a case that need it to be fileprivate instead.<br>&gt; <br>&gt; Honestly, I don’t see any value in the introduction of fileprivate.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>I also agree that monitoring the usage of private vs fileprivate is not fair. I now use private heavily simply because I don’t want the burden of mixing private and fileprivate (and find the name of fileprivate slightly verbose/ugly). But that does not mean I would vote for keeping private. I would still vote for going back to Swift 2 behaviour. But I agree that we can wait until the summer to look at this again.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161013/33e4eb79/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>October 13, 2016 at 07:00:00pm</p></header><div class="content"><p>I question the practicality of &quot;use private heavily simply because I don’t want the burden of mixing private and fileprivate&quot;. In our experience in converting a very mature Swift application, we had no choice but to use both because we wanted private as much as possible but that&#39;s too restrictive in some cases. The granularity private and fileprivate provide is definitey a welcome change.<br></p><p>Daniel Duan<br>Sent from my iPhone<br></p><p>&gt; On Oct 13, 2016, at 3:11 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On 13 Oct 2016, at 08:25, Jean-Daniel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Le 13 oct. 2016 à 07:52, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Oct 12, 2016, at 9:56 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; I actually consider it very lucky that most of our changes so far have been fairly non-controversial. Everybody has a different idea of what would make Swift a better language, and all of us well-meaning. But when those ideas conflict, some group is going to end up unhappy. I&#39;m actually very glad that (a) we haven&#39;t had too many of these cases, and (b) even when we have, people have been able to accept it and move on to contributing to the next issue.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Strong agreement here as well. This proposal has been litigated numerous times already, and the bar for source-breaking changes is much higher now. To effectively re-open the discussion would require a proposal that significant changes the model with a lot of evidence that such a new model is a drastic improvement over what we have now. “Back out SE-0025” is not a viable option now.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not really. This proposal could be backed out without source-breaking changes by treating private as a synonym for fileprivate and we’d have Swift 2 behavior without breaking source. If the core team doesn’t want to consider that then we can just move on and live with it. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not speaking for the core team, just MHO:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with Russ here, and with others who have said upthread that the “thing that has changed” is that we are starting to get usage experience with fileprivate vs private.  I think we all understand the value of having fewer access control levels, and so if “private” isn’t conceptually pulling its weight, then it is reasonable to consider phasing it out.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That said, there is no specific rush to have this discussion, and I think it is reasonable to put a pretty high burden of proof on someone who wants to drive such a proposal.  For example, if we had the discussion in the spring timeframe, we should have a pretty large body of Swift 3 code readily at hand (e.g. SwiftPM packages and other various github repos).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given that, it should be easy enough to see how widely private is actually being used in practice.  If it is very rare, then the argument to ditch it (make it a synonym for fileprivate, and eventually phasing out fileprivate) is strong.  If lots of people are using private and only some are using fileprivate, then the discussion is quite different.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; I don’t think monitoring the usage of private vs fileprivate is fair. By default, people will use private until they encounter visibility issues and discover they need to change to fileprivate. So private will probably being use far more than fileprivate.<br>&gt;&gt; Nonetheless it does not mean people chosen private because it effectively reduce the visibility to the class scope, but just because it is easier to discover and to type than fileprivate and fit in many cases.<br>&gt;&gt; <br>&gt;&gt; I tend to write class will all ivars private by default (as it is a sensible default), and then, when I start to write extensions and other parts, I have to switch to fileprivate for a bunch of ivars. It create an inconsistent mess in my ivars declaration as it is difficult to know if an ivar is private because I has to be, or because I didn’t encounter a case that need it to be fileprivate instead.<br>&gt;&gt; <br>&gt;&gt; Honestly, I don’t see any value in the introduction of fileprivate.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; I also agree that monitoring the usage of private vs fileprivate is not fair. I now use private heavily simply because I don’t want the burden of mixing private and fileprivate (and find the name of fileprivate slightly verbose/ugly). But that does not mean I would vote for keeping private. I would still vote for going back to Swift 2 behaviour. But I agree that we can wait until the summer to look at this again.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161013/5ec31dc6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>October 13, 2016 at 08:00:00pm</p></header><div class="content"><p>fileprivate  is not essential but I also would like to defend keeping it, at least for now. <br></p><p>I find it useful in practice. In some cases, I can’t put a declaration in the global file scope (where fileprivate and private are essentially the same thing). For example, for organizational reasons I may have multiple protocol conformance extension blocks which use some “private” functions that are useful in more than one of those protocol extensions in the same file. <br></p><p>In the future, the  introduction of submodules and having submodule-internal scope may eliminate most use cases for fileprivate. But still, we may not want the overhead of introducing submodules just to get the effect of a simple fileprivate.<br></p><p><br>&gt; On Oct 13, 2016, at 7:44 PM, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I question the practicality of &quot;use private heavily simply because I don’t want the burden of mixing private and fileprivate&quot;. In our experience in converting a very mature Swift application, we had no choice but to use both because we wanted private as much as possible but that&#39;s too restrictive in some cases. The granularity private and fileprivate provide is definitey a welcome change.<br>&gt; <br>&gt; Daniel Duan<br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Oct 13, 2016, at 3:11 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 13 Oct 2016, at 08:25, Jean-Daniel via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 13 oct. 2016 à 07:52, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 12, 2016, at 9:56 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I actually consider it very lucky that most of our changes so far have been fairly non-controversial. Everybody has a different idea of what would make Swift a better language, and all of us well-meaning. But when those ideas conflict, some group is going to end up unhappy. I&#39;m actually very glad that (a) we haven&#39;t had too many of these cases, and (b) even when we have, people have been able to accept it and move on to contributing to the next issue.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Strong agreement here as well. This proposal has been litigated numerous times already, and the bar for source-breaking changes is much higher now. To effectively re-open the discussion would require a proposal that significant changes the model with a lot of evidence that such a new model is a drastic improvement over what we have now. “Back out SE-0025” is not a viable option now.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Not really. This proposal could be backed out without source-breaking changes by treating private as a synonym for fileprivate and we’d have Swift 2 behavior without breaking source. If the core team doesn’t want to consider that then we can just move on and live with it. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not speaking for the core team, just MHO:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with Russ here, and with others who have said upthread that the “thing that has changed” is that we are starting to get usage experience with fileprivate vs private.  I think we all understand the value of having fewer access control levels, and so if “private” isn’t conceptually pulling its weight, then it is reasonable to consider phasing it out.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That said, there is no specific rush to have this discussion, and I think it is reasonable to put a pretty high burden of proof on someone who wants to drive such a proposal.  For example, if we had the discussion in the spring timeframe, we should have a pretty large body of Swift 3 code readily at hand (e.g. SwiftPM packages and other various github repos).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Given that, it should be easy enough to see how widely private is actually being used in practice.  If it is very rare, then the argument to ditch it (make it a synonym for fileprivate, and eventually phasing out fileprivate) is strong.  If lots of people are using private and only some are using fileprivate, then the discussion is quite different.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think monitoring the usage of private vs fileprivate is fair. By default, people will use private until they encounter visibility issues and discover they need to change to fileprivate. So private will probably being use far more than fileprivate.<br>&gt;&gt;&gt; Nonetheless it does not mean people chosen private because it effectively reduce the visibility to the class scope, but just because it is easier to discover and to type than fileprivate and fit in many cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I tend to write class will all ivars private by default (as it is a sensible default), and then, when I start to write extensions and other parts, I have to switch to fileprivate for a bunch of ivars. It create an inconsistent mess in my ivars declaration as it is difficult to know if an ivar is private because I has to be, or because I didn’t encounter a case that need it to be fileprivate instead.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Honestly, I don’t see any value in the introduction of fileprivate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; I also agree that monitoring the usage of private vs fileprivate is not fair. I now use private heavily simply because I don’t want the burden of mixing private and fileprivate (and find the name of fileprivate slightly verbose/ugly). But that does not mean I would vote for keeping private. I would still vote for going back to Swift 2 behaviour. But I agree that we can wait until the summer to look at this again.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161013/8dc02260/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>October 14, 2016 at 12:00:00am</p></header><div class="content"><p>Daniel, I would be interested to hear what, exactly, are the benefits your<br>project has realized from the new “private” compared to the old “private”<br>(which is now called “fileprivate”).<br></p><p>Were there problems caused by the old “private” that have been solved by<br>the new “private”? Major problems? Minor annoyances?<br></p><p>• • •<br></p><p>As I see it, two significant drawbacks of the new “private” are increased<br>complexity in the access control model, and encumbrance of the old<br>“private” with the unwieldy moniker “fileprivate”.<br></p><p>If the new “private” has brought real benefits sufficient to outweigh its<br>complexity cost then I think it should stay, and if not it should go. Thus<br>I am curious to see what benefits it has in practice.<br></p><p>• • •<br></p><p>Regardless of whether the new “private” is pulling its weight, I believe we<br>should find a shorter name for “fileprivate”.<br></p><p>And I think Xiaodi has the right idea: whensoever in the future we decide<br>to introduce submodules, it would be best if they subsumed the file scope.<br>In essence, a submodule would be the mechanism for parceling out code which<br>currently must reside in a single file (because it relies on “fileprivate”<br>which is the old “private”).<br></p><p>That way a submodule could comprise several interrelated pieces which need<br>to share privy details, while preserving their natural separation into<br>distinct files. So it makes sense that we should find a replacement for<br>“fileprivate” which is copacetic to submodules.<br></p><p>Actually, now that I write it down, I wonder if perhaps “privy” might work<br>as a keyword. It is short, it means “being party to shared secret<br>knowledge”, and its spelling conveys a sense of “private-ish”.<br></p><p>The other ideas I’ve come up with have shortcomings, such as “local” which<br>has a pre-existing incompatible meaning in programming (otherwise it would<br>be great), or “folio” which is not an adjective (and also isn’t ideal for<br>the single-file case).<br></p><p>But “privy” just might work.<br></p><p>Nevin<br></p><p><br>On Thu, Oct 13, 2016 at 10:44 PM, Daniel Duan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I question the practicality of &quot;use private heavily simply because I<br>&gt; don’t want the burden of mixing private and fileprivate&quot;. In our experience<br>&gt; in converting a very mature Swift application, we had no choice but to use<br>&gt; both because we wanted private as much as possible but that&#39;s too<br>&gt; restrictive in some cases. The granularity private and fileprivate provide<br>&gt; is definitey a welcome change.<br>&gt;<br>&gt; Daniel Duan<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On Oct 13, 2016, at 3:11 AM, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 13 Oct 2016, at 08:25, Jean-Daniel via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Le 13 oct. 2016 à 07:52, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; On Oct 12, 2016, at 9:56 PM, Russ Bishop via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I actually consider it very lucky that most of our changes so far have<br>&gt; been fairly non-controversial. Everybody has a different idea of what would<br>&gt; make Swift a better language, and all of us well-meaning. But when those<br>&gt; ideas conflict, some group is going to end up unhappy. I&#39;m actually very<br>&gt; glad that (a) we haven&#39;t had too many of these cases, and (b) even when we<br>&gt; have, people have been able to accept it and move on to contributing to the<br>&gt; next issue.<br>&gt;<br>&gt;<br>&gt; Strong agreement here as well. This proposal has been litigated numerous<br>&gt; times already, and the bar for source-breaking changes is much higher now.<br>&gt; To effectively re-open the discussion would require a proposal that<br>&gt; significant changes the model with a lot of evidence that such a new model<br>&gt; is a drastic improvement over what we have now. “Back out SE-0025” is not a<br>&gt; viable option now.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt; Not really. This proposal could be backed out without source-breaking<br>&gt; changes by treating private as a synonym for fileprivate and we’d have<br>&gt; Swift 2 behavior without breaking source. If the core team doesn’t want to<br>&gt; consider that then we can just move on and live with it.<br>&gt;<br>&gt;<br>&gt; Not speaking for the core team, just MHO:<br>&gt;<br>&gt; I agree with Russ here, and with others who have said upthread that the<br>&gt; “thing that has changed” is that we are starting to get usage experience<br>&gt; with fileprivate vs private.  I think we all understand the value of having<br>&gt; fewer access control levels, and so if “private” isn’t conceptually pulling<br>&gt; its weight, then it is reasonable to consider phasing it out.<br>&gt;<br>&gt; That said, there is no specific rush to have this discussion, and I think<br>&gt; it is reasonable to put a pretty high burden of proof on someone who wants<br>&gt; to drive such a proposal.  For example, if we had the discussion in the<br>&gt; spring timeframe, we should have a pretty large body of Swift 3 code<br>&gt; readily at hand (e.g. SwiftPM packages and other various github repos).<br>&gt;<br>&gt; Given that, it should be easy enough to see how widely private is actually<br>&gt; being used in practice.  If it is very rare, then the argument to ditch it<br>&gt; (make it a synonym for fileprivate, and eventually phasing out fileprivate)<br>&gt; is strong.  If lots of people are using private and only some are using<br>&gt; fileprivate, then the discussion is quite different.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; I don’t think monitoring the usage of private vs fileprivate is fair. By<br>&gt; default, people will use private until they encounter visibility issues and<br>&gt; discover they need to change to fileprivate. So private will probably being<br>&gt; use far more than fileprivate.<br>&gt; Nonetheless it does not mean people chosen private because it effectively<br>&gt; reduce the visibility to the class scope, but just because it is easier to<br>&gt; discover and to type than fileprivate and fit in many cases.<br>&gt;<br>&gt; I tend to write class will all ivars private by default (as it is a<br>&gt; sensible default), and then, when I start to write extensions and other<br>&gt; parts, I have to switch to fileprivate for a bunch of ivars. It create an<br>&gt; inconsistent mess in my ivars declaration as it is difficult to know if an<br>&gt; ivar is private because I has to be, or because I didn’t encounter a case<br>&gt; that need it to be fileprivate instead.<br>&gt;<br>&gt; Honestly, I don’t see any value in the introduction of fileprivate.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; I also agree that monitoring the usage of private vs fileprivate is not<br>&gt; fair. I now use private heavily simply because I don’t want the burden of<br>&gt; mixing private and fileprivate (and find the name of fileprivate slightly<br>&gt; verbose/ugly). But that does not mean I would vote for keeping private. I<br>&gt; would still vote for going back to Swift 2 behaviour. But I agree that we<br>&gt; can wait until the summer to look at this again.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161014/a03ce4da/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>October 14, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 14 Oct 2016, at 06:03, Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Daniel, I would be interested to hear what, exactly, are the benefits your project has realized from the new “private” compared to the old “private” (which is now called “fileprivate”).<br>&gt; <br>&gt; Were there problems caused by the old “private” that have been solved by the new “private”? Major problems? Minor annoyances?<br>&gt; <br></p><p>Yes please.<br>To me, access levels seem to be more about communication than about problem solving. I.e. if I make something ‘private’ then I am communicating to the outside world “hey don’t touch this”. And if it ain’t private then “go ahead, change this any way you like”. But imo they don’t solve an actual programming problem. No?<br></p><p>Rien<br></p><p><br></p><p>&gt; • • •<br>&gt; <br>&gt; As I see it, two significant drawbacks of the new “private” are increased complexity in the access control model, and encumbrance of the old “private” with the unwieldy moniker “fileprivate”.<br>&gt; <br>&gt; If the new “private” has brought real benefits sufficient to outweigh its complexity cost then I think it should stay, and if not it should go. Thus I am curious to see what benefits it has in practice.<br>&gt; <br>&gt; • • •<br>&gt; <br>&gt; Regardless of whether the new “private” is pulling its weight, I believe we should find a shorter name for “fileprivate”.<br>&gt; <br>&gt; And I think Xiaodi has the right idea: whensoever in the future we decide to introduce submodules, it would be best if they subsumed the file scope. In essence, a submodule would be the mechanism for parceling out code which currently must reside in a single file (because it relies on “fileprivate” which is the old “private”).<br>&gt; <br>&gt; That way a submodule could comprise several interrelated pieces which need to share privy details, while preserving their natural separation into distinct files. So it makes sense that we should find a replacement for “fileprivate” which is copacetic to submodules.<br>&gt; <br>&gt; Actually, now that I write it down, I wonder if perhaps “privy” might work as a keyword. It is short, it means “being party to shared secret knowledge”, and its spelling conveys a sense of “private-ish”.<br>&gt; <br>&gt; The other ideas I’ve come up with have shortcomings, such as “local” which has a pre-existing incompatible meaning in programming (otherwise it would be great), or “folio” which is not an adjective (and also isn’t ideal for the single-file case).<br>&gt; <br>&gt; But “privy” just might work.<br>&gt; <br>&gt; Nevin<br>&gt; <br>&gt; <br>&gt; On Thu, Oct 13, 2016 at 10:44 PM, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I question the practicality of &quot;use private heavily simply because I don’t want the burden of mixing private and fileprivate&quot;. In our experience in converting a very mature Swift application, we had no choice but to use both because we wanted private as much as possible but that&#39;s too restrictive in some cases. The granularity private and fileprivate provide is definitey a welcome change.<br>&gt; <br>&gt; Daniel Duan<br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Oct 13, 2016, at 3:11 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 13 Oct 2016, at 08:25, Jean-Daniel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 13 oct. 2016 à 07:52, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 12, 2016, at 9:56 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I actually consider it very lucky that most of our changes so far have been fairly non-controversial. Everybody has a different idea of what would make Swift a better language, and all of us well-meaning. But when those ideas conflict, some group is going to end up unhappy. I&#39;m actually very glad that (a) we haven&#39;t had too many of these cases, and (b) even when we have, people have been able to accept it and move on to contributing to the next issue.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Strong agreement here as well. This proposal has been litigated numerous times already, and the bar for source-breaking changes is much higher now. To effectively re-open the discussion would require a proposal that significant changes the model with a lot of evidence that such a new model is a drastic improvement over what we have now. “Back out SE-0025” is not a viable option now.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Not really. This proposal could be backed out without source-breaking changes by treating private as a synonym for fileprivate and we’d have Swift 2 behavior without breaking source. If the core team doesn’t want to consider that then we can just move on and live with it. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not speaking for the core team, just MHO:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with Russ here, and with others who have said upthread that the “thing that has changed” is that we are starting to get usage experience with fileprivate vs private.  I think we all understand the value of having fewer access control levels, and so if “private” isn’t conceptually pulling its weight, then it is reasonable to consider phasing it out.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That said, there is no specific rush to have this discussion, and I think it is reasonable to put a pretty high burden of proof on someone who wants to drive such a proposal.  For example, if we had the discussion in the spring timeframe, we should have a pretty large body of Swift 3 code readily at hand (e.g. SwiftPM packages and other various github repos).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Given that, it should be easy enough to see how widely private is actually being used in practice.  If it is very rare, then the argument to ditch it (make it a synonym for fileprivate, and eventually phasing out fileprivate) is strong.  If lots of people are using private and only some are using fileprivate, then the discussion is quite different.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think monitoring the usage of private vs fileprivate is fair. By default, people will use private until they encounter visibility issues and discover they need to change to fileprivate. So private will probably being use far more than fileprivate.<br>&gt;&gt;&gt; Nonetheless it does not mean people chosen private because it effectively reduce the visibility to the class scope, but just because it is easier to discover and to type than fileprivate and fit in many cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I tend to write class will all ivars private by default (as it is a sensible default), and then, when I start to write extensions and other parts, I have to switch to fileprivate for a bunch of ivars. It create an inconsistent mess in my ivars declaration as it is difficult to know if an ivar is private because I has to be, or because I didn’t encounter a case that need it to be fileprivate instead.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Honestly, I don’t see any value in the introduction of fileprivate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; I also agree that monitoring the usage of private vs fileprivate is not fair. I now use private heavily simply because I don’t want the burden of mixing private and fileprivate (and find the name of fileprivate slightly verbose/ugly). But that does not mean I would vote for keeping private. I would still vote for going back to Swift 2 behaviour. But I agree that we can wait until the summer to look at this again.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>October 14, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Oct 13, 2016, at 9:03 PM, Nevin Brackett-Rozinsky &lt;nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt; <br>&gt; Daniel, I would be interested to hear what, exactly, are the benefits your project has realized from the new “private” compared to the old “private” (which is now called “fileprivate”).<br>&gt; <br></p><p>There&#39;s no amazing insight here. The benefit is more granular control. The more people work on a project, the more useful this becomes.<br></p><p>You might as well ask &quot;why not make everything public&quot; if private and fileprivate makes no difference to you.<br></p><p>&gt; Were there problems caused by the old “private” that have been solved by the new “private”? Major problems? Minor annoyances?<br>&gt; <br>&gt; • • •<br>&gt; <br>&gt; As I see it, two significant drawbacks of the new “private” are increased complexity in the access control model, and encumbrance of the old “private” with the unwieldy moniker “fileprivate”.<br>&gt; <br></p><p>The first drawback is a truism: every language addition of feature makes it more complex. So we need to measure the benefit with other costs, which brings us to your second &quot;drawback&quot;. I&#39;m having a hard time understanding it. Is it too hard to type? If so, as an Objective-C survivor I disagree. The experience of reading code is harder and therefore more important than that of authoring code. &quot;fileprivate&quot; was chosen over many other alternatives because it&#39;s obvious to the reader. A shorter but equally obvious name would have been nice. But &quot;unwieldy&quot; is not enough reason to justify such source-breaking change at the moment.<br></p><p><br>&gt; If the new “private” has brought real benefits sufficient to outweigh its complexity cost then I think it should stay, and if not it should go. Thus I am curious to see what benefits it has in practice.<br>&gt; <br>&gt; • • •<br>&gt; <br>&gt; Regardless of whether the new “private” is pulling its weight, I believe we should find a shorter name for “fileprivate”.<br>&gt; <br>&gt; And I think Xiaodi has the right idea: whensoever in the future we decide to introduce submodules, it would be best if they subsumed the file scope. In essence, a submodule would be the mechanism for parceling out code which currently must reside in a single file (because it relies on “fileprivate” which is the old “private”).<br>&gt; <br>&gt; That way a submodule could comprise several interrelated pieces which need to share privy details, while preserving their natural separation into distinct files. So it makes sense that we should find a replacement for “fileprivate” which is copacetic to submodules.<br>&gt; <br>&gt; Actually, now that I write it down, I wonder if perhaps “privy” might work as a keyword. It is short, it means “being party to shared secret knowledge”, and its spelling conveys a sense of “private-ish”.<br>&gt; <br>&gt; The other ideas I’ve come up with have shortcomings, such as “local” which has a pre-existing incompatible meaning in programming (otherwise it would be great), or “folio” which is not an adjective (and also isn’t ideal for the single-file case).<br>&gt; <br>&gt; But “privy” just might work.<br>&gt; <br>&gt; Nevin<br>&gt; <br>&gt; <br>&gt;&gt; On Thu, Oct 13, 2016 at 10:44 PM, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I question the practicality of &quot;use private heavily simply because I don’t want the burden of mixing private and fileprivate&quot;. In our experience in converting a very mature Swift application, we had no choice but to use both because we wanted private as much as possible but that&#39;s too restrictive in some cases. The granularity private and fileprivate provide is definitey a welcome change.<br>&gt;&gt; <br>&gt;&gt; Daniel Duan<br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 13, 2016, at 3:11 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 13 Oct 2016, at 08:25, Jean-Daniel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 13 oct. 2016 à 07:52, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 12, 2016, at 9:56 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I actually consider it very lucky that most of our changes so far have been fairly non-controversial. Everybody has a different idea of what would make Swift a better language, and all of us well-meaning. But when those ideas conflict, some group is going to end up unhappy. I&#39;m actually very glad that (a) we haven&#39;t had too many of these cases, and (b) even when we have, people have been able to accept it and move on to contributing to the next issue.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Strong agreement here as well. This proposal has been litigated numerous times already, and the bar for source-breaking changes is much higher now. To effectively re-open the discussion would require a proposal that significant changes the model with a lot of evidence that such a new model is a drastic improvement over what we have now. “Back out SE-0025” is not a viable option now.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Not really. This proposal could be backed out without source-breaking changes by treating private as a synonym for fileprivate and we’d have Swift 2 behavior without breaking source. If the core team doesn’t want to consider that then we can just move on and live with it. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Not speaking for the core team, just MHO:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree with Russ here, and with others who have said upthread that the “thing that has changed” is that we are starting to get usage experience with fileprivate vs private.  I think we all understand the value of having fewer access control levels, and so if “private” isn’t conceptually pulling its weight, then it is reasonable to consider phasing it out.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That said, there is no specific rush to have this discussion, and I think it is reasonable to put a pretty high burden of proof on someone who wants to drive such a proposal.  For example, if we had the discussion in the spring timeframe, we should have a pretty large body of Swift 3 code readily at hand (e.g. SwiftPM packages and other various github repos).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Given that, it should be easy enough to see how widely private is actually being used in practice.  If it is very rare, then the argument to ditch it (make it a synonym for fileprivate, and eventually phasing out fileprivate) is strong.  If lots of people are using private and only some are using fileprivate, then the discussion is quite different.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t think monitoring the usage of private vs fileprivate is fair. By default, people will use private until they encounter visibility issues and discover they need to change to fileprivate. So private will probably being use far more than fileprivate.<br>&gt;&gt;&gt;&gt; Nonetheless it does not mean people chosen private because it effectively reduce the visibility to the class scope, but just because it is easier to discover and to type than fileprivate and fit in many cases.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I tend to write class will all ivars private by default (as it is a sensible default), and then, when I start to write extensions and other parts, I have to switch to fileprivate for a bunch of ivars. It create an inconsistent mess in my ivars declaration as it is difficult to know if an ivar is private because I has to be, or because I didn’t encounter a case that need it to be fileprivate instead.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Honestly, I don’t see any value in the introduction of fileprivate.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I also agree that monitoring the usage of private vs fileprivate is not fair. I now use private heavily simply because I don’t want the burden of mixing private and fileprivate (and find the name of fileprivate slightly verbose/ugly). But that does not mean I would vote for keeping private. I would still vote for going back to Swift 2 behaviour. But I agree that we can wait until the summer to look at this again.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161014/fa9514e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>October 14, 2016 at 05:00:00pm</p></header><div class="content"><p>On Fri, Oct 14, 2016 at 11:51 AM, Daniel Duan &lt;daniel at duan.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Oct 13, 2016, at 9:03 PM, Nevin Brackett-Rozinsky &lt;<br>&gt; nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt;<br>&gt; Daniel, I would be interested to hear what, exactly, are the benefits your<br>&gt; project has realized from the new “private” compared to the old “private”<br>&gt; (which is now called “fileprivate”).<br>&gt;<br>&gt; There&#39;s no amazing insight here. The benefit is more granular control. The<br>&gt; more people work on a project, the more useful this becomes.<br>&gt;<br></p><p>More granular control *within a single file*. That is where I have a hard<br>time imagining the benefits, and thus am asking for details.<br></p><p>If there are multiple types within a single file, it is usually because<br>they need to share implementation details.<br></p><p>The only things that I see which scope-based access (the new “private”)<br>brings to the table are:<br>• Scope-private members from other parts of the file are unavailable (and<br>thus don’t show in autocomplete).<br>• Different extensions of a type can have scope-private members with the<br>same name as each other.<br></p><p>The former seems negligible, because you are working *within the same<br>file*. The API that a type vends within its own file is hardly worth<br>optimizing for.<br></p><p>And the latter I would say is an anti-feature. Using multiple different<br>members with the same name in extensions just makes it harder to rearrange<br>the implementation, because those scope-private members will collide if<br>moved into the same extension.<br></p><p>So I *really* don’t see the benefits. Yes, I understand that there is now<br>more granular control over access within a single file. I am asking for<br>examples of how that additional granularity provides *benefits*.<br></p><p><br> On Fri, Oct 14, 2016 at 11:51 AM, Daniel Duan &lt;daniel at duan.org&gt; wrote:<br></p><p>&gt; You might as well ask &quot;why not make everything public&quot; if private and<br>&gt; fileprivate makes no difference to you.<br>&gt;<br></p><p>That is not a fair assertion at all. The API which a type vends to other<br>files within its module, and to clients outside its module, are significant<br>parts of a quality and maintainable design.<br></p><p>I do not think the API which a type vends *within its own file* warrants<br>such lofty prioritization.<br></p><p><br></p><p>&gt; On Fri, Oct 14, 2016 at 11:51 AM, Daniel Duan &lt;daniel at duan.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Oct 13, 2016, at 9:03 PM, Nevin Brackett-Rozinsky &lt;<br>&gt;&gt; nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt; As I see it, two significant drawbacks of the new “private” are increased<br>&gt; complexity in the access control model, and encumbrance of the old<br>&gt; “private” with the unwieldy moniker “fileprivate”.<br>&gt;<br>&gt; The first drawback is a truism: every language addition of feature makes<br>&gt; it more complex.<br>&gt;<br></p><p>You can’t just write off the complexity cost like that. The new scope-based<br>“private” access level brings *substantial* complexity, to both the<br>implementation and the mental programming model. It creates *unutterable*<br>access levels, where a scope can see a member of another scope, but cannot<br>create its own member with the same access level.<br></p><p><br>On Fri, Oct 14, 2016 at 11:51 AM, Daniel Duan &lt;daniel at duan.org&gt; wrote:<br>&gt;<br>&gt; So we need to measure the benefit with other costs, which brings us to<br>&gt; your second &quot;drawback&quot;. I&#39;m having a hard time understanding it. Is it too<br>&gt; hard to type? If so, as an Objective-C survivor I disagree. The experience<br>&gt; of reading code is harder and therefore more important than that of<br>&gt; authoring code. &quot;fileprivate&quot; was chosen over many other alternatives<br>&gt; because it&#39;s obvious to the reader. A shorter but equally obvious name<br>&gt; would have been nice. But &quot;unwieldy&quot; is not enough reason to justify such<br>&gt; source-breaking change at the moment.<br>&gt;<br></p><p>Right, “unwieldy” is not enough to justify a source-breaking change. I<br>entirely agree.<br></p><p>It is the *complexity* of the current model that would justify the<br>source-breaking change, if it does not have real benefits which stand on<br>their own and outweigh the costs.<br></p><p>What unwieldiness *does* justify is a non-breaking change, such as<br>introducing “privy” (or something else) as a synonym for “fileprivate”,<br>then eventually deprecating and removing the latter.<br></p><p>• • •<br></p><p>I will also note that the principal practical effect of SE-0025 was<br>“Replace a small number of occurrences of ‘private’ with ‘fileprivate’.”<br></p><p>That is essentially all it did to source code. It brought a significant<br>increase to the complexity of the access control model, in order to make a<br>few member declarations lengthier and more awkward.<br></p><p>Maybe there are other benefits, but I have not seen them.<br></p><p>• • •<br></p><p>Let me reiterate my stance: if the new scope-based “private” has benefits<br>which outweigh its complexity cost, then we should keep it. Otherwise we<br>should get rid of scope-based access control and reinstate the old<br>file-based “private”.<br></p><p>Furthermore, we should rename “fileprivate” to something shorter and less<br>awkward, which will play nice with submodules. If “private” is off the<br>table then I propose “privy”, though I welcome other suggestions.<br></p><p> Nevin<br></p><p>If the new “private” has brought real benefits sufficient to outweigh its<br>&gt; complexity cost then I think it should stay, and if not it should go. Thus<br>&gt; I am curious to see what benefits it has in practice.<br>&gt;<br>&gt; • • •<br>&gt;<br>&gt; Regardless of whether the new “private” is pulling its weight, I believe<br>&gt; we should find a shorter name for “fileprivate”.<br>&gt;<br>&gt; And I think Xiaodi has the right idea: whensoever in the future we decide<br>&gt; to introduce submodules, it would be best if they subsumed the file scope.<br>&gt; In essence, a submodule would be the mechanism for parceling out code which<br>&gt; currently must reside in a single file (because it relies on “fileprivate”<br>&gt; which is the old “private”).<br>&gt;<br>&gt; That way a submodule could comprise several interrelated pieces which need<br>&gt; to share privy details, while preserving their natural separation into<br>&gt; distinct files. So it makes sense that we should find a replacement for<br>&gt; “fileprivate” which is copacetic to submodules.<br>&gt;<br>&gt; Actually, now that I write it down, I wonder if perhaps “privy” might work<br>&gt; as a keyword. It is short, it means “being party to shared secret<br>&gt; knowledge”, and its spelling conveys a sense of “private-ish”.<br>&gt;<br>&gt; The other ideas I’ve come up with have shortcomings, such as “local” which<br>&gt; has a pre-existing incompatible meaning in programming (otherwise it would<br>&gt; be great), or “folio” which is not an adjective (and also isn’t ideal for<br>&gt; the single-file case).<br>&gt;<br>&gt; But “privy” just might work.<br>&gt;<br>&gt; Nevin<br>&gt;<br>&gt;<br>&gt; On Thu, Oct 13, 2016 at 10:44 PM, Daniel Duan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I question the practicality of &quot;use private heavily simply because I<br>&gt;&gt; don’t want the burden of mixing private and fileprivate&quot;. In our experience<br>&gt;&gt; in converting a very mature Swift application, we had no choice but to use<br>&gt;&gt; both because we wanted private as much as possible but that&#39;s too<br>&gt;&gt; restrictive in some cases. The granularity private and fileprivate provide<br>&gt;&gt; is definitey a welcome change.<br>&gt;&gt;<br>&gt;&gt; Daniel Duan<br>&gt;&gt; Sent from my iPhone<br>&gt;&gt;<br>&gt;&gt; On Oct 13, 2016, at 3:11 AM, David Hart via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 13 Oct 2016, at 08:25, Jean-Daniel via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Le 13 oct. 2016 à 07:52, Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; On Oct 12, 2016, at 9:56 PM, Russ Bishop via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I actually consider it very lucky that most of our changes so far have<br>&gt;&gt; been fairly non-controversial. Everybody has a different idea of what would<br>&gt;&gt; make Swift a better language, and all of us well-meaning. But when those<br>&gt;&gt; ideas conflict, some group is going to end up unhappy. I&#39;m actually very<br>&gt;&gt; glad that (a) we haven&#39;t had too many of these cases, and (b) even when we<br>&gt;&gt; have, people have been able to accept it and move on to contributing to the<br>&gt;&gt; next issue.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Strong agreement here as well. This proposal has been litigated numerous<br>&gt;&gt; times already, and the bar for source-breaking changes is much higher now.<br>&gt;&gt; To effectively re-open the discussion would require a proposal that<br>&gt;&gt; significant changes the model with a lot of evidence that such a new model<br>&gt;&gt; is a drastic improvement over what we have now. “Back out SE-0025” is not a<br>&gt;&gt; viable option now.<br>&gt;&gt;<br>&gt;&gt; - Doug<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Not really. This proposal could be backed out without source-breaking<br>&gt;&gt; changes by treating private as a synonym for fileprivate and we’d have<br>&gt;&gt; Swift 2 behavior without breaking source. If the core team doesn’t want to<br>&gt;&gt; consider that then we can just move on and live with it.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Not speaking for the core team, just MHO:<br>&gt;&gt;<br>&gt;&gt; I agree with Russ here, and with others who have said upthread that the<br>&gt;&gt; “thing that has changed” is that we are starting to get usage experience<br>&gt;&gt; with fileprivate vs private.  I think we all understand the value of having<br>&gt;&gt; fewer access control levels, and so if “private” isn’t conceptually pulling<br>&gt;&gt; its weight, then it is reasonable to consider phasing it out.<br>&gt;&gt;<br>&gt;&gt; That said, there is no specific rush to have this discussion, and I think<br>&gt;&gt; it is reasonable to put a pretty high burden of proof on someone who wants<br>&gt;&gt; to drive such a proposal.  For example, if we had the discussion in the<br>&gt;&gt; spring timeframe, we should have a pretty large body of Swift 3 code<br>&gt;&gt; readily at hand (e.g. SwiftPM packages and other various github repos).<br>&gt;&gt;<br>&gt;&gt; Given that, it should be easy enough to see how widely private is<br>&gt;&gt; actually being used in practice.  If it is very rare, then the argument to<br>&gt;&gt; ditch it (make it a synonym for fileprivate, and eventually phasing out<br>&gt;&gt; fileprivate) is strong.  If lots of people are using private and only some<br>&gt;&gt; are using fileprivate, then the discussion is quite different.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don’t think monitoring the usage of private vs fileprivate is fair. By<br>&gt;&gt; default, people will use private until they encounter visibility issues and<br>&gt;&gt; discover they need to change to fileprivate. So private will probably being<br>&gt;&gt; use far more than fileprivate.<br>&gt;&gt; Nonetheless it does not mean people chosen private because it effectively<br>&gt;&gt; reduce the visibility to the class scope, but just because it is easier to<br>&gt;&gt; discover and to type than fileprivate and fit in many cases.<br>&gt;&gt;<br>&gt;&gt; I tend to write class will all ivars private by default (as it is a<br>&gt;&gt; sensible default), and then, when I start to write extensions and other<br>&gt;&gt; parts, I have to switch to fileprivate for a bunch of ivars. It create an<br>&gt;&gt; inconsistent mess in my ivars declaration as it is difficult to know if an<br>&gt;&gt; ivar is private because I has to be, or because I didn’t encounter a case<br>&gt;&gt; that need it to be fileprivate instead.<br>&gt;&gt;<br>&gt;&gt; Honestly, I don’t see any value in the introduction of fileprivate.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I also agree that monitoring the usage of private vs fileprivate is not<br>&gt;&gt; fair. I now use private heavily simply because I don’t want the burden of<br>&gt;&gt; mixing private and fileprivate (and find the name of fileprivate slightly<br>&gt;&gt; verbose/ugly). But that does not mean I would vote for keeping private. I<br>&gt;&gt; would still vote for going back to Swift 2 behaviour. But I agree that we<br>&gt;&gt; can wait until the summer to look at this again.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161014/5a10a928/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>October 19, 2016 at 01:00:00pm</p></header><div class="content"><p>On Fri, Oct 14, 2016, at 02:54 PM, Nevin Brackett-Rozinsky via swift-evolution wrote:<br>&gt; On Fri, Oct 14, 2016 at 11:51 AM, Daniel Duan &lt;daniel at duan.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Oct 13, 2016, at 9:03 PM, Nevin Brackett-Rozinsky<br>&gt;&gt; &lt;nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt;&gt;&gt; Daniel, I would be interested to hear what, exactly, are the<br>&gt;&gt;&gt; benefits your project has realized from the new “private” compared<br>&gt;&gt;&gt; to the old “private” (which is now called “fileprivate”).<br>&gt;&gt;<br>&gt;&gt; There&#39;s no amazing insight here. The benefit is more granular<br>&gt;&gt; control. The more people work on a project, the more useful this<br>&gt;&gt; becomes.<br>&gt;&gt;<br>&gt;<br>&gt; More granular control *within a single file*. That is where I have a<br>&gt; hard time imagining the benefits, and thus am asking for details.<br>&gt;<br>&gt; If there are multiple types within a single file, it is usually<br>&gt; because they need to share implementation details.<br></p><p>Just because they need to share some implementation details doesn&#39;t mean<br>they should share all of them. Or better yet, a private/fileprivate type<br>in a file doesn&#39;t have to share any implementation details, it can<br>define a proper API that it exposes to the rest of the file while<br>keeping its implementation details private, just as it would if it were<br>an internal or public type.<br></p><p>&gt; The only things that I see which scope-based access (the new<br>&gt; “private”) brings to the table are:<br>&gt; • Scope-private members from other parts of the file are unavailable<br>&gt; (and thus don’t show in autocomplete).<br>&gt; • Different extensions of a type can have scope-private members with<br>&gt; the same name as each other.<br>&gt;<br>&gt; The former seems negligible, because you are working *within the same<br>&gt; file*. The API that a type vends within its own file is hardly worth<br>&gt; optimizing for.<br>&gt;<br>&gt; And the latter I would say is an anti-feature. Using multiple<br>&gt; different members with the same name in extensions just makes it<br>&gt; harder to rearrange the implementation, because those scope-private<br>&gt; members will collide if moved into the same extension.<br>&gt;<br>&gt; So I *really* don’t see the benefits. Yes, I understand that there is<br>&gt; now more granular control over access within a single file. I am<br>&gt; asking for examples of how that additional granularity provides<br>&gt; *benefits*.<br></p><p>Just because you&#39;re within a single file doesn&#39;t mean you need to throw<br>away the principles of API design. Sure, it&#39;s not nearly as important as<br>something that&#39;s more widely-visible, but that&#39;s not the same thing as<br>saying it&#39;s not important at all. Careful control of implementation<br>details vs exposed API even within a single file is still useful, either<br>because it&#39;s much easier to make the type public if desired, or because<br>it makes any future refactoring much easier. And it also helps you to<br>reason about the code as you&#39;re looking at it, because when you&#39;re<br>looking at a private declaration, you only have to consider the<br>immediate enclosing scope, as opposed to a fileprivate declaration where<br>you have to consider the whole file.<br></p><p>-Kevin Ballard<br></p><p>&gt;  On Fri, Oct 14, 2016 at 11:51 AM, Daniel Duan<br>&gt;  &lt;daniel at duan.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; You might as well ask &quot;why not make everything public&quot; if private and<br>&gt;&gt; fileprivate makes no difference to you.<br>&gt;<br>&gt; That is not a fair assertion at all. The API which a type vends to<br>&gt; other files within its module, and to clients outside its module, are<br>&gt; significant parts of a quality and maintainable design.<br>&gt;<br>&gt; I do not think the API which a type vends *within its own file*<br>&gt; warrants such lofty prioritization.<br>&gt;<br>&gt;<br>&gt;&gt; On Fri, Oct 14, 2016 at 11:51 AM, Daniel Duan<br>&gt;&gt; &lt;daniel at duan.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Oct 13, 2016, at 9:03 PM, Nevin Brackett-Rozinsky<br>&gt;&gt;&gt; &lt;nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As I see it, two significant drawbacks of the new “private” are<br>&gt;&gt;&gt; increased complexity in the access control model, and encumbrance of<br>&gt;&gt;&gt; the old “private” with the unwieldy moniker “fileprivate”.<br>&gt;&gt;<br>&gt;&gt; The first drawback is a truism: every language addition of feature<br>&gt;&gt; makes it more complex.<br>&gt;<br>&gt; You can’t just write off the complexity cost like that. The new scope-<br>&gt; based “private” access level brings *substantial* complexity, to both<br>&gt; the implementation and the mental programming model. It creates<br>&gt; *unutterable* access levels, where a scope can see a member of another<br>&gt; scope, but cannot create its own member with the same access level.<br>&gt;<br>&gt;<br>&gt;&gt; On Fri, Oct 14, 2016 at 11:51 AM, Daniel Duan<br>&gt;&gt; &lt;daniel at duan.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; So we need to measure the benefit with other costs, which brings us<br>&gt;&gt; to your second &quot;drawback&quot;. I&#39;m having a hard time understanding it.<br>&gt;&gt; Is it too hard to type? If so, as an Objective-C survivor I disagree.<br>&gt;&gt; The experience of reading code is harder and therefore more important<br>&gt;&gt; than that of authoring code. &quot;fileprivate&quot; was chosen over many other<br>&gt;&gt; alternatives because it&#39;s obvious to the reader. A shorter but<br>&gt;&gt; equally obvious name would have been nice. But &quot;unwieldy&quot; is not<br>&gt;&gt; enough reason to justify such source-breaking change at the moment.<br>&gt;<br>&gt; Right, “unwieldy” is not enough to justify a source-breaking change. I<br>&gt; entirely agree.<br>&gt;<br>&gt; It is the *complexity* of the current model that would justify the source-<br>&gt; breaking change, if it does not have real benefits which stand on<br>&gt; their own and outweigh the costs.<br>&gt;<br>&gt; What unwieldiness *does* justify is a non-breaking change, such as<br>&gt; introducing “privy” (or something else) as a synonym for<br>&gt; “fileprivate”, then eventually deprecating and removing the latter.<br>&gt;<br>&gt; • • •<br>&gt;<br>&gt; I will also note that the principal practical effect of SE-0025 was<br>&gt; “Replace a small number of occurrences of ‘private’ with<br>&gt; ‘fileprivate’.”<br>&gt;<br>&gt; That is essentially all it did to source code. It brought a<br>&gt; significant increase to the complexity of the access control model, in<br>&gt; order to make a few member declarations lengthier and more awkward.<br>&gt;<br>&gt; Maybe there are other benefits, but I have not seen them.<br>&gt;<br>&gt; • • •<br>&gt;<br>&gt; Let me reiterate my stance: if the new scope-based “private” has<br>&gt; benefits which outweigh its complexity cost, then we should keep it.<br>&gt; Otherwise we should get rid of scope-based access control and<br>&gt; reinstate the old file-based “private”.<br>&gt;<br>&gt; Furthermore, we should rename “fileprivate” to something shorter and<br>&gt; less awkward, which will play nice with submodules. If “private” is<br>&gt; off the table then I propose “privy”, though I welcome other<br>&gt; suggestions.<br>&gt;<br>&gt;  Nevin<br>&gt;<br>&gt;&gt;&gt; If the new “private” has brought real benefits sufficient to<br>&gt;&gt;&gt; outweigh its complexity cost then I think it should stay, and if not<br>&gt;&gt;&gt; it should go. Thus I am curious to see what benefits it has in<br>&gt;&gt;&gt; practice.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; • • •<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Regardless of whether the new “private” is pulling its weight, I<br>&gt;&gt;&gt; believe we should find a shorter name for “fileprivate”.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And I think Xiaodi has the right idea: whensoever in the future we<br>&gt;&gt;&gt; decide to introduce submodules, it would be best if they subsumed<br>&gt;&gt;&gt; the file scope. In essence, a submodule would be the mechanism for<br>&gt;&gt;&gt; parceling out code which currently must reside in a single file<br>&gt;&gt;&gt; (because it relies on “fileprivate” which is the old “private”).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That way a submodule could comprise several interrelated pieces<br>&gt;&gt;&gt; which need to share privy details, while preserving their natural<br>&gt;&gt;&gt; separation into distinct files. So it makes sense that we should<br>&gt;&gt;&gt; find a replacement for “fileprivate” which is copacetic to<br>&gt;&gt;&gt; submodules.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Actually, now that I write it down, I wonder if perhaps “privy”<br>&gt;&gt;&gt; might work as a keyword. It is short, it means “being party to<br>&gt;&gt;&gt; shared secret knowledge”, and its spelling conveys a sense of<br>&gt;&gt;&gt; “private-ish”.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The other ideas I’ve come up with have shortcomings, such as “local”<br>&gt;&gt;&gt; which has a pre-existing incompatible meaning in programming<br>&gt;&gt;&gt; (otherwise it would be great), or “folio” which is not an adjective<br>&gt;&gt;&gt; (and also isn’t ideal for the single-file case).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But “privy” just might work.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Nevin<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Thu, Oct 13, 2016 at 10:44 PM, Daniel Duan via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; I question the practicality of &quot;use private heavily simply because<br>&gt;&gt;&gt;&gt; I don’t want the burden of mixing private and fileprivate&quot;. In our<br>&gt;&gt;&gt;&gt; experience in converting a very mature Swift application, we had no<br>&gt;&gt;&gt;&gt; choice but to use both because we wanted private as much as<br>&gt;&gt;&gt;&gt; possible but that&#39;s too restrictive in some cases. The granularity<br>&gt;&gt;&gt;&gt; private and fileprivate provide is definitey a welcome change.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Daniel Duan<br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Oct 13, 2016, at 3:11 AM, David Hart via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On 13 Oct 2016, at 08:25, Jean-Daniel via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 13 oct. 2016 à 07:52, Chris Lattner via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 12, 2016, at 9:56 PM, Russ Bishop via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I actually consider it very lucky that most of our changes so<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; far have been fairly non-controversial. Everybody has a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; different idea of what would make Swift a better language,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and all of us well-meaning. But when those ideas conflict,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; some group is going to end up unhappy. I&#39;m actually very glad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that (a) we haven&#39;t had too many of these cases, and (b) even<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; when we have, people have been able to accept it and move on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to contributing to the next issue.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Strong agreement here as well. This proposal has been<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; litigated numerous times already, and the bar for source-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; breaking changes is much higher now. To effectively re-open<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the discussion would require a proposal that significant<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; changes the model with a lot of evidence that such a new model<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is a drastic improvement over what we have now. “Back out SE-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 0025” is not a viable option now.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not really. This proposal could be backed out without source-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; breaking changes by treating private as a synonym for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fileprivate and we’d have Swift 2 behavior without breaking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; source. If the core team doesn’t want to consider that then we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can just move on and live with it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not speaking for the core team, just MHO:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I agree with Russ here, and with others who have said upthread<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that the “thing that has changed” is that we are starting to get<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; usage experience with fileprivate vs private.  I think we all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; understand the value of having fewer access control levels, and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; so if “private” isn’t conceptually pulling its weight, then it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is reasonable to consider phasing it out.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That said, there is no specific rush to have this discussion,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and I think it is reasonable to put a pretty high burden of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; proof on someone who wants to drive such a proposal.  For<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; example, if we had the discussion in the spring timeframe, we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; should have a pretty large body of Swift 3 code readily at hand<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (e.g. SwiftPM packages and other various github repos).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Given that, it should be easy enough to see how widely private<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is actually being used in practice.  If it is very rare, then<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the argument to ditch it (make it a synonym for fileprivate, and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; eventually phasing out fileprivate) is strong.  If lots of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; people are using private and only some are using fileprivate,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; then the discussion is quite different.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I don’t think monitoring the usage of private vs fileprivate is<br>&gt;&gt;&gt;&gt;&gt;&gt; fair. By default, people will use private until they encounter<br>&gt;&gt;&gt;&gt;&gt;&gt; visibility issues and discover they need to change to<br>&gt;&gt;&gt;&gt;&gt;&gt; fileprivate. So private will probably being use far more than<br>&gt;&gt;&gt;&gt;&gt;&gt; fileprivate.<br>&gt;&gt;&gt;&gt;&gt;&gt; Nonetheless it does not mean people chosen private because it<br>&gt;&gt;&gt;&gt;&gt;&gt; effectively reduce the visibility to the class scope, but just<br>&gt;&gt;&gt;&gt;&gt;&gt; because it is easier to discover and to type than fileprivate and<br>&gt;&gt;&gt;&gt;&gt;&gt; fit in many cases.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I tend to write class will all ivars private by default (as it is<br>&gt;&gt;&gt;&gt;&gt;&gt; a sensible default), and then, when I start to write extensions<br>&gt;&gt;&gt;&gt;&gt;&gt; and other parts, I have to switch to fileprivate for a bunch of<br>&gt;&gt;&gt;&gt;&gt;&gt; ivars. It create an inconsistent mess in my ivars declaration as<br>&gt;&gt;&gt;&gt;&gt;&gt; it is difficult to know if an ivar is private because I has to<br>&gt;&gt;&gt;&gt;&gt;&gt; be, or because I didn’t encounter a case that need it to be<br>&gt;&gt;&gt;&gt;&gt;&gt; fileprivate instead.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Honestly, I don’t see any value in the introduction of<br>&gt;&gt;&gt;&gt;&gt;&gt; fileprivate.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I also agree that monitoring the usage of private vs fileprivate<br>&gt;&gt;&gt;&gt;&gt; is not fair. I now use private heavily simply because I don’t want<br>&gt;&gt;&gt;&gt;&gt; the burden of mixing private and fileprivate (and find the name of<br>&gt;&gt;&gt;&gt;&gt; fileprivate slightly verbose/ugly). But that does not mean I would<br>&gt;&gt;&gt;&gt;&gt; vote for keeping private. I would still vote for going back to<br>&gt;&gt;&gt;&gt;&gt; Swift 2 behaviour. But I agree that we can wait until the summer<br>&gt;&gt;&gt;&gt;&gt; to look at this again.<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;  swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/5e11bf72/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>October 14, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On Oct 13, 2016, at 1:25 AM, Jean-Daniel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I don’t think monitoring the usage of private vs fileprivate is fair. By default, people will use private until they encounter visibility issues and discover they need to change to fileprivate. So private will probably being use far more than fileprivate.<br>&gt; Nonetheless it does not mean people chosen private because it effectively reduce the visibility to the class scope, but just because it is easier to discover and to type than fileprivate and fit in many cases.<br></p><p>How is that an argument against private, though? If private is used far more often than fileprivate, then this suggests that the vast amount of the time, the scope it provides is what is appropriate. The enlarged scope provided by fileprivate, then, is needed for what are essentially edge cases. It makes little sense, to my mind, to replace the mainstream option with the niche one.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161014/19e06aac/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>October  7, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 6, 2016, at 11:39 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello community,<br>&gt; <br>&gt; From all the proposals which has gone into Swift 3, [SE-0025] Scoped Access Level is the only one I’m having second thoughts about. Before launching a discussion around it, I’m curious to know if it&#39;s worth discussing it or if the “ship has sailed”. As the plan is to allow future versions of Swift to break source-compatibility in certain rare scenarios, perhaps we have a chance to reconsider certain proposals?<br></p><p>We are always willing to consider new input, but any source breaking change has to provide overwhelming rationale for it being worth the cost to the community.<br></p><p>-Chris<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/4af24908/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>private &amp; fileprivate</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>October 15, 2016 at 04:00:00pm</p></header><div class="content"><p>This discussion is getting longer than I thought… guess it&#39;s because we can&#39;t spend our energy for proposals that introduce new features ;-)<br></p><p>I had some &quot;hope&quot; that SE-0025 would be dismissed when one of the deadlines passed without an implementation, and I was thinking about proposing to drop it — but the feature has been finished before I started writing.<br></p><p>Personally, I don&#39;t have problems with &quot;new private&quot;, but it is a whole access level that&#39;s actually not needed for regular coding:<br>Considering the importance of playgrounds, it&#39;s desirable to be be able to teach about information hiding, which doesn&#39;t work with fileprivate — but real applications normally consist of several source files, and this use case is still my focus.<br>In this setup, the benefit of two access levels whose only difference can be neutralized by a very tiny reorganization of code is just theoretical.<br></p><p>With Swift 3, the number of access levels nearly doubled, but even with an impressive number of five options, there are still many intends that can&#39;t be expressed, so we traded a limited (but simple) system for a slightly more complex one that still lacks power.<br></p><p>What itches me most in this aspect is the strong preference for small, additive changes, which discourages a holistic take on big topics like this.<br></p><p>- Tino<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
