<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47c04e83c5e36a3e3c498ce99baab9f4?s=50"></div><header><strong>Setter methods for vars</strong> from <string>Austin Feight</string> &lt;austin at chexology.com&gt;<p>June 28, 2016 at 02:00:00pm</p></header><div class="content"><p>*Proposal:*<br></p><p>I propose adding setter methods to vars, which could look something like<br>this: `ApiClient().fetchUsers().then(#set(users))`<br></p><p>Initially I thought it should work like this:<br>`ApiClient().fetchUsers().then(users.set)`<br>but to accomplish a line of code that flows grammatically, I believe<br>putting &quot;set&quot; where it would naturally fall if the code was being read as a<br>sentence is more Swifty.<br></p><p>*Rationale:*<br></p><p>The following code makes me smile:<br></p><p>ApiClient().fetchUsers().then(displayUsers)<br></p><p>It exemplifies the beauty of Swift. First-class functions make this line of<br>code read very well. Consider some alternatives:<br></p><p>1. ApiClient().fetchUsers().then { displayUsers($0) }<br>2. ApiClient().fetchUsers().then { users in displayUsers(users) }<br>3. ApiClient().fetchUsers().then { (users: [User]) in displayUsers(users) }<br></p><p>Using the lessons learned from Swift API Design Guidelines (WWDC 2016<br>Session 403) having an emphasis on clarity, my analysis of the alternatives<br>is:<br></p><p>1. $0 adds no additional information as to the type or explanation of what<br>the argument is, thus adding nothing to the line of code for clarity, and<br>therefore should be omitted<br>2. adding &quot;users&quot; also adds nothing to the clarity of the code. The<br>function, properly, contains the information necessary to reason about the<br>argument it takes and what it does, and therefore adding &quot;users&quot; is<br>redundant<br>3. Not only is &quot;users&quot; redundant, but also is the explicit type label. The<br>`displayUsers` method will only accept one type of argument, so we&#39;re<br>duplicating information that the compiler (and autocomplete) already gives<br>us<br></p><p>With this I conclude that `ApiClient().fetchUsers().then(displayUsers)` is<br>the Swiftiest option.<br>I want to extend this same logic to when I find myself writing code like<br>this:<br></p><p>ApiClient().fetchUsers().then { users in<br>  self.users = users<br>}<br></p><p>or alternatively, because &quot;users&quot; is likely redundant information again,<br></p><p>ApiClient().fetchUsers().then { self.users = $0 }<br></p><p>Personally I steer clear of `$0` as much as possible, because I very rarely<br>feel that it provides the information necessary for code clarity. But<br>beyond that, this code no longer reads as nicely as the code we had before.<br></p><p>Whereas `ApiClient().fetchUsers().then(displayUsers)` flows nicely as a<br>sentence and reads grammatically, `ApiClient().fetchUsers().then {<br>self.users = $0 }` no longer does.<br></p><p>I think this feature could have a simple implementation where the compiler<br>replaces `#set(X)` with `{ X = $0 }`, and I believe it would go a long way<br>with respect to code clarity, especially when X is something longer like<br>`self.view.bounds.origin.x`<br></p><p><br>Looking forward to hearing thoughts from the community,<br></p><p>*Austin Feight*<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/dab7496b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>Setter methods for vars</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>June 28, 2016 at 11:00:00am</p></header><div class="content"><p>I donâ€™t understand how <br></p><p>    ApiClient().fetchUsers().then(#set(users))<br></p><p>leads to <br></p><p>    ApiClient().fetchUsers().then(displayUsers)<br></p><p>Could you clarify with a more extensive example?<br>What does the function then() do?<br></p><p>-Kenny<br></p><p><br>&gt; On Jun 28, 2016, at 11:18 AM, Austin Feight via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Proposal:<br>&gt; <br>&gt; I propose adding setter methods to vars, which could look something like this: `ApiClient().fetchUsers().then(#set(users))`<br>&gt; <br>&gt; Initially I thought it should work like this: `ApiClient().fetchUsers().then(users.set)`<br>&gt; but to accomplish a line of code that flows grammatically, I believe putting &quot;set&quot; where it would naturally fall if the code was being read as a sentence is more Swifty.<br>&gt; <br>&gt; Rationale:<br>&gt; <br>&gt; The following code makes me smile:<br>&gt; <br>&gt; ApiClient().fetchUsers().then(displayUsers)<br>&gt; <br>&gt; It exemplifies the beauty of Swift. First-class functions make this line of code read very well. Consider some alternatives:<br>&gt; <br>&gt; 1. ApiClient().fetchUsers().then { displayUsers($0) }<br>&gt; 2. ApiClient().fetchUsers().then { users in displayUsers(users) }<br>&gt; 3. ApiClient().fetchUsers().then { (users: [User]) in displayUsers(users) }<br>&gt; <br>&gt; Using the lessons learned from Swift API Design Guidelines (WWDC 2016 Session 403) having an emphasis on clarity, my analysis of the alternatives is:<br>&gt; <br>&gt; 1. $0 adds no additional information as to the type or explanation of what the argument is, thus adding nothing to the line of code for clarity, and therefore should be omitted<br>&gt; 2. adding &quot;users&quot; also adds nothing to the clarity of the code. The function, properly, contains the information necessary to reason about the argument it takes and what it does, and therefore adding &quot;users&quot; is redundant<br>&gt; 3. Not only is &quot;users&quot; redundant, but also is the explicit type label. The `displayUsers` method will only accept one type of argument, so we&#39;re duplicating information that the compiler (and autocomplete) already gives us<br>&gt; <br>&gt; With this I conclude that `ApiClient().fetchUsers().then(displayUsers)` is the Swiftiest option.<br>&gt; I want to extend this same logic to when I find myself writing code like this:<br>&gt; <br>&gt; ApiClient().fetchUsers().then { users in<br>&gt;   self.users = users<br>&gt; }<br>&gt; <br>&gt; or alternatively, because &quot;users&quot; is likely redundant information again,<br>&gt; <br>&gt; ApiClient().fetchUsers().then { self.users = $0 }<br>&gt; <br>&gt; Personally I steer clear of `$0` as much as possible, because I very rarely feel that it provides the information necessary for code clarity. But beyond that, this code no longer reads as nicely as the code we had before. <br>&gt; <br>&gt; Whereas `ApiClient().fetchUsers().then(displayUsers)` flows nicely as a sentence and reads grammatically, `ApiClient().fetchUsers().then { self.users = $0 }` no longer does.<br>&gt; <br>&gt; I think this feature could have a simple implementation where the compiler replaces `#set(X)` with `{ X = $0 }`, and I believe it would go a long way with respect to code clarity, especially when X is something longer like `self.view.bounds.origin.x`<br>&gt; <br>&gt; <br>&gt; Looking forward to hearing thoughts from the community,<br>&gt; Austin Feight<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>Setter methods for vars</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June 28, 2016 at 10:00:00pm</p></header><div class="content"><p>So you&#39;re proposing that `#set(aVariableName)` should translate to `{aVariableName=$0}`, right? Where aVariableName can be any valid lvalue like `self.users` or `users` or `vc.viewControllers`..<br></p><p>I think this would be a good extension to Swift. (`users.set` does not work BTW, because maybe the `users` object has a `set` property.. maybe I wanted to refer to the `set` property which also happens to refer to a closure value.)<br></p><p>`#set(aVariableName)` also feels consistent with the `#keyPath(aVariableName)` property and falls into a similar category. Maybe `#setter(aVariableName)` would be even more clear? Furthermore, I want to additionally propose to introduce `#get(aVariableName)` (or `#getter(aVariableName)`) too.<br></p><p>-Michael<br></p><p>&gt; Am 28.06.2016 um 20:18 schrieb Austin Feight via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Proposal:<br>&gt; <br>&gt; I propose adding setter methods to vars, which could look something like this: `ApiClient().fetchUsers().then(#set(users))`<br>&gt; <br>&gt; Initially I thought it should work like this: `ApiClient().fetchUsers().then(users.set)`<br>&gt; but to accomplish a line of code that flows grammatically, I believe putting &quot;set&quot; where it would naturally fall if the code was being read as a sentence is more Swifty.<br>&gt; <br>&gt; Rationale:<br>&gt; <br>&gt; The following code makes me smile:<br>&gt; <br>&gt; ApiClient().fetchUsers().then(displayUsers)<br>&gt; <br>&gt; It exemplifies the beauty of Swift. First-class functions make this line of code read very well. Consider some alternatives:<br>&gt; <br>&gt; 1. ApiClient().fetchUsers().then { displayUsers($0) }<br>&gt; 2. ApiClient().fetchUsers().then { users in displayUsers(users) }<br>&gt; 3. ApiClient().fetchUsers().then { (users: [User]) in displayUsers(users) }<br>&gt; <br>&gt; Using the lessons learned from Swift API Design Guidelines (WWDC 2016 Session 403) having an emphasis on clarity, my analysis of the alternatives is:<br>&gt; <br>&gt; 1. $0 adds no additional information as to the type or explanation of what the argument is, thus adding nothing to the line of code for clarity, and therefore should be omitted<br>&gt; 2. adding &quot;users&quot; also adds nothing to the clarity of the code. The function, properly, contains the information necessary to reason about the argument it takes and what it does, and therefore adding &quot;users&quot; is redundant<br>&gt; 3. Not only is &quot;users&quot; redundant, but also is the explicit type label. The `displayUsers` method will only accept one type of argument, so we&#39;re duplicating information that the compiler (and autocomplete) already gives us<br>&gt; <br>&gt; With this I conclude that `ApiClient().fetchUsers().then(displayUsers)` is the Swiftiest option.<br>&gt; I want to extend this same logic to when I find myself writing code like this:<br>&gt; <br>&gt; ApiClient().fetchUsers().then { users in<br>&gt;   self.users = users<br>&gt; }<br>&gt; <br>&gt; or alternatively, because &quot;users&quot; is likely redundant information again,<br>&gt; <br>&gt; ApiClient().fetchUsers().then { self.users = $0 }<br>&gt; <br>&gt; Personally I steer clear of `$0` as much as possible, because I very rarely feel that it provides the information necessary for code clarity. But beyond that, this code no longer reads as nicely as the code we had before. <br>&gt; <br>&gt; Whereas `ApiClient().fetchUsers().then(displayUsers)` flows nicely as a sentence and reads grammatically, `ApiClient().fetchUsers().then { self.users = $0 }` no longer does.<br>&gt; <br>&gt; I think this feature could have a simple implementation where the compiler replaces `#set(X)` with `{ X = $0 }`, and I believe it would go a long way with respect to code clarity, especially when X is something longer like `self.view.bounds.origin.x`<br>&gt; <br>&gt; <br>&gt; Looking forward to hearing thoughts from the community,<br>&gt; Austin Feight<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Setter methods for vars</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 29, 2016 at 12:00:00am</p></header><div class="content"><p>This looks like lenses. I think we need to wait until after Swift 3 to discuss it, and come up with a bigger design that ties to reflexion.<br></p><p>&gt; On 28 Jun 2016, at 22:04, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; So you&#39;re proposing that `#set(aVariableName)` should translate to `{aVariableName=$0}`, right? Where aVariableName can be any valid lvalue like `self.users` or `users` or `vc.viewControllers`..<br>&gt; <br>&gt; I think this would be a good extension to Swift. (`users.set` does not work BTW, because maybe the `users` object has a `set` property.. maybe I wanted to refer to the `set` property which also happens to refer to a closure value.)<br>&gt; <br>&gt; `#set(aVariableName)` also feels consistent with the `#keyPath(aVariableName)` property and falls into a similar category. Maybe `#setter(aVariableName)` would be even more clear? Furthermore, I want to additionally propose to introduce `#get(aVariableName)` (or `#getter(aVariableName)`) too.<br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt;&gt; Am 28.06.2016 um 20:18 schrieb Austin Feight via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Proposal:<br>&gt;&gt; <br>&gt;&gt; I propose adding setter methods to vars, which could look something like this: `ApiClient().fetchUsers().then(#set(users))`<br>&gt;&gt; <br>&gt;&gt; Initially I thought it should work like this: `ApiClient().fetchUsers().then(users.set)`<br>&gt;&gt; but to accomplish a line of code that flows grammatically, I believe putting &quot;set&quot; where it would naturally fall if the code was being read as a sentence is more Swifty.<br>&gt;&gt; <br>&gt;&gt; Rationale:<br>&gt;&gt; <br>&gt;&gt; The following code makes me smile:<br>&gt;&gt; <br>&gt;&gt; ApiClient().fetchUsers().then(displayUsers)<br>&gt;&gt; <br>&gt;&gt; It exemplifies the beauty of Swift. First-class functions make this line of code read very well. Consider some alternatives:<br>&gt;&gt; <br>&gt;&gt; 1. ApiClient().fetchUsers().then { displayUsers($0) }<br>&gt;&gt; 2. ApiClient().fetchUsers().then { users in displayUsers(users) }<br>&gt;&gt; 3. ApiClient().fetchUsers().then { (users: [User]) in displayUsers(users) }<br>&gt;&gt; <br>&gt;&gt; Using the lessons learned from Swift API Design Guidelines (WWDC 2016 Session 403) having an emphasis on clarity, my analysis of the alternatives is:<br>&gt;&gt; <br>&gt;&gt; 1. $0 adds no additional information as to the type or explanation of what the argument is, thus adding nothing to the line of code for clarity, and therefore should be omitted<br>&gt;&gt; 2. adding &quot;users&quot; also adds nothing to the clarity of the code. The function, properly, contains the information necessary to reason about the argument it takes and what it does, and therefore adding &quot;users&quot; is redundant<br>&gt;&gt; 3. Not only is &quot;users&quot; redundant, but also is the explicit type label. The `displayUsers` method will only accept one type of argument, so we&#39;re duplicating information that the compiler (and autocomplete) already gives us<br>&gt;&gt; <br>&gt;&gt; With this I conclude that `ApiClient().fetchUsers().then(displayUsers)` is the Swiftiest option.<br>&gt;&gt; I want to extend this same logic to when I find myself writing code like this:<br>&gt;&gt; <br>&gt;&gt; ApiClient().fetchUsers().then { users in<br>&gt;&gt;  self.users = users<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; or alternatively, because &quot;users&quot; is likely redundant information again,<br>&gt;&gt; <br>&gt;&gt; ApiClient().fetchUsers().then { self.users = $0 }<br>&gt;&gt; <br>&gt;&gt; Personally I steer clear of `$0` as much as possible, because I very rarely feel that it provides the information necessary for code clarity. But beyond that, this code no longer reads as nicely as the code we had before. <br>&gt;&gt; <br>&gt;&gt; Whereas `ApiClient().fetchUsers().then(displayUsers)` flows nicely as a sentence and reads grammatically, `ApiClient().fetchUsers().then { self.users = $0 }` no longer does.<br>&gt;&gt; <br>&gt;&gt; I think this feature could have a simple implementation where the compiler replaces `#set(X)` with `{ X = $0 }`, and I believe it would go a long way with respect to code clarity, especially when X is something longer like `self.view.bounds.origin.x`<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Looking forward to hearing thoughts from the community,<br>&gt;&gt; Austin Feight<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>Setter methods for vars</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June 29, 2016 at 01:00:00am</p></header><div class="content"><p>Really?? Or we just have #set and #get and no lenses, and it&#39;s done for Swift 3?<br></p><p>I never heard of lenses (Google does not help here). Was this serious or were you joking? Unless you can explain why #set and #get without lenses would be bad... or maybe #set and #get *are* lenses, in which case I&#39;m not sure what you were trying to say. Reflexion -&gt; Reflection?<br></p><p>-Michael<br></p><p>&gt; Am 29.06.2016 um 00:55 schrieb David Hart via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; This looks like lenses. I think we need to wait until after Swift 3 to discuss it, and come up with a bigger design that ties to reflexion.<br>&gt; <br>&gt;&gt; On 28 Jun 2016, at 22:04, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; So you&#39;re proposing that `#set(aVariableName)` should translate to `{aVariableName=$0}`, right? Where aVariableName can be any valid lvalue like `self.users` or `users` or `vc.viewControllers`..<br>&gt;&gt; <br>&gt;&gt; I think this would be a good extension to Swift. (`users.set` does not work BTW, because maybe the `users` object has a `set` property.. maybe I wanted to refer to the `set` property which also happens to refer to a closure value.)<br>&gt;&gt; <br>&gt;&gt; `#set(aVariableName)` also feels consistent with the `#keyPath(aVariableName)` property and falls into a similar category. Maybe `#setter(aVariableName)` would be even more clear? Furthermore, I want to additionally propose to introduce `#get(aVariableName)` (or `#getter(aVariableName)`) too.<br>&gt;&gt; <br>&gt;&gt; -Michael<br>&gt;&gt; <br>&gt;&gt;&gt; Am 28.06.2016 um 20:18 schrieb Austin Feight via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose adding setter methods to vars, which could look something like this: `ApiClient().fetchUsers().then(#set(users))`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Initially I thought it should work like this: `ApiClient().fetchUsers().then(users.set)`<br>&gt;&gt;&gt; but to accomplish a line of code that flows grammatically, I believe putting &quot;set&quot; where it would naturally fall if the code was being read as a sentence is more Swifty.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Rationale:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The following code makes me smile:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ApiClient().fetchUsers().then(displayUsers)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It exemplifies the beauty of Swift. First-class functions make this line of code read very well. Consider some alternatives:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. ApiClient().fetchUsers().then { displayUsers($0) }<br>&gt;&gt;&gt; 2. ApiClient().fetchUsers().then { users in displayUsers(users) }<br>&gt;&gt;&gt; 3. ApiClient().fetchUsers().then { (users: [User]) in displayUsers(users) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using the lessons learned from Swift API Design Guidelines (WWDC 2016 Session 403) having an emphasis on clarity, my analysis of the alternatives is:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. $0 adds no additional information as to the type or explanation of what the argument is, thus adding nothing to the line of code for clarity, and therefore should be omitted<br>&gt;&gt;&gt; 2. adding &quot;users&quot; also adds nothing to the clarity of the code. The function, properly, contains the information necessary to reason about the argument it takes and what it does, and therefore adding &quot;users&quot; is redundant<br>&gt;&gt;&gt; 3. Not only is &quot;users&quot; redundant, but also is the explicit type label. The `displayUsers` method will only accept one type of argument, so we&#39;re duplicating information that the compiler (and autocomplete) already gives us<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With this I conclude that `ApiClient().fetchUsers().then(displayUsers)` is the Swiftiest option.<br>&gt;&gt;&gt; I want to extend this same logic to when I find myself writing code like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ApiClient().fetchUsers().then { users in<br>&gt;&gt;&gt; self.users = users<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or alternatively, because &quot;users&quot; is likely redundant information again,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ApiClient().fetchUsers().then { self.users = $0 }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally I steer clear of `$0` as much as possible, because I very rarely feel that it provides the information necessary for code clarity. But beyond that, this code no longer reads as nicely as the code we had before. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Whereas `ApiClient().fetchUsers().then(displayUsers)` flows nicely as a sentence and reads grammatically, `ApiClient().fetchUsers().then { self.users = $0 }` no longer does.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this feature could have a simple implementation where the compiler replaces `#set(X)` with `{ X = $0 }`, and I believe it would go a long way with respect to code clarity, especially when X is something longer like `self.view.bounds.origin.x`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Looking forward to hearing thoughts from the community,<br>&gt;&gt;&gt; Austin Feight<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Setter methods for vars</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 28, 2016 at 06:00:00pm</p></header><div class="content"><p>Lens are a term from functional programming theory (I think largely Haskell in particular?). I don&#39;t know much about it, but here&#39;s somewhere to start: https://www21.in.tum.de/teaching/fp/SS15/papers/17.pdf<br></p><p>l8r<br>Sean<br></p><p>Sent from my iPad<br></p><p>&gt; On Jun 28, 2016, at 6:11 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Really?? Or we just have #set and #get and no lenses, and it&#39;s done for Swift 3?<br>&gt; <br>&gt; I never heard of lenses (Google does not help here). Was this serious or were you joking? Unless you can explain why #set and #get without lenses would be bad... or maybe #set and #get *are* lenses, in which case I&#39;m not sure what you were trying to say. Reflexion -&gt; Reflection?<br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt;&gt; Am 29.06.2016 um 00:55 schrieb David Hart via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; This looks like lenses. I think we need to wait until after Swift 3 to discuss it, and come up with a bigger design that ties to reflexion.<br>&gt;&gt; <br>&gt;&gt;&gt; On 28 Jun 2016, at 22:04, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So you&#39;re proposing that `#set(aVariableName)` should translate to `{aVariableName=$0}`, right? Where aVariableName can be any valid lvalue like `self.users` or `users` or `vc.viewControllers`..<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this would be a good extension to Swift. (`users.set` does not work BTW, because maybe the `users` object has a `set` property.. maybe I wanted to refer to the `set` property which also happens to refer to a closure value.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `#set(aVariableName)` also feels consistent with the `#keyPath(aVariableName)` property and falls into a similar category. Maybe `#setter(aVariableName)` would be even more clear? Furthermore, I want to additionally propose to introduce `#get(aVariableName)` (or `#getter(aVariableName)`) too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 28.06.2016 um 20:18 schrieb Austin Feight via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I propose adding setter methods to vars, which could look something like this: `ApiClient().fetchUsers().then(#set(users))`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Initially I thought it should work like this: `ApiClient().fetchUsers().then(users.set)`<br>&gt;&gt;&gt;&gt; but to accomplish a line of code that flows grammatically, I believe putting &quot;set&quot; where it would naturally fall if the code was being read as a sentence is more Swifty.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Rationale:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The following code makes me smile:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ApiClient().fetchUsers().then(displayUsers)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It exemplifies the beauty of Swift. First-class functions make this line of code read very well. Consider some alternatives:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. ApiClient().fetchUsers().then { displayUsers($0) }<br>&gt;&gt;&gt;&gt; 2. ApiClient().fetchUsers().then { users in displayUsers(users) }<br>&gt;&gt;&gt;&gt; 3. ApiClient().fetchUsers().then { (users: [User]) in displayUsers(users) }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Using the lessons learned from Swift API Design Guidelines (WWDC 2016 Session 403) having an emphasis on clarity, my analysis of the alternatives is:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. $0 adds no additional information as to the type or explanation of what the argument is, thus adding nothing to the line of code for clarity, and therefore should be omitted<br>&gt;&gt;&gt;&gt; 2. adding &quot;users&quot; also adds nothing to the clarity of the code. The function, properly, contains the information necessary to reason about the argument it takes and what it does, and therefore adding &quot;users&quot; is redundant<br>&gt;&gt;&gt;&gt; 3. Not only is &quot;users&quot; redundant, but also is the explicit type label. The `displayUsers` method will only accept one type of argument, so we&#39;re duplicating information that the compiler (and autocomplete) already gives us<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With this I conclude that `ApiClient().fetchUsers().then(displayUsers)` is the Swiftiest option.<br>&gt;&gt;&gt;&gt; I want to extend this same logic to when I find myself writing code like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ApiClient().fetchUsers().then { users in<br>&gt;&gt;&gt;&gt; self.users = users<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or alternatively, because &quot;users&quot; is likely redundant information again,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ApiClient().fetchUsers().then { self.users = $0 }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Personally I steer clear of `$0` as much as possible, because I very rarely feel that it provides the information necessary for code clarity. But beyond that, this code no longer reads as nicely as the code we had before. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Whereas `ApiClient().fetchUsers().then(displayUsers)` flows nicely as a sentence and reads grammatically, `ApiClient().fetchUsers().then { self.users = $0 }` no longer does.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think this feature could have a simple implementation where the compiler replaces `#set(X)` with `{ X = $0 }`, and I believe it would go a long way with respect to code clarity, especially when X is something longer like `self.view.bounds.origin.x`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Looking forward to hearing thoughts from the community,<br>&gt;&gt;&gt;&gt; Austin Feight<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/4e65c4d8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>Setter methods for vars</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June 29, 2016 at 01:00:00am</p></header><div class="content"><p>Haha, I think if we support lenses we should also support a QBit structure, because lenses are just special cases for QBits ;) That said, I think it&#39;s unlikely that lenses will be supported in Swift 4. We should wait for Swift 5 when the full QBit-library will be introduced (hardware-accellerated of course, but it deploys back until the iPhone 6S.)<br></p><p>Good night guys (it&#39;s 1:30 am in my time zone...)<br></p><p>-Michael<br></p><p>&gt; Am 29.06.2016 um 01:22 schrieb Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Lens are a term from functional programming theory (I think largely Haskell in particular?). I don&#39;t know much about it, but here&#39;s somewhere to start: https://www21.in.tum.de/teaching/fp/SS15/papers/17.pdf<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Jun 28, 2016, at 6:11 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Really?? Or we just have #set and #get and no lenses, and it&#39;s done for Swift 3?<br>&gt;&gt; <br>&gt;&gt; I never heard of lenses (Google does not help here). Was this serious or were you joking? Unless you can explain why #set and #get without lenses would be bad... or maybe #set and #get *are* lenses, in which case I&#39;m not sure what you were trying to say. Reflexion -&gt; Reflection?<br>&gt;&gt; <br>&gt;&gt; -Michael<br>&gt;&gt; <br>&gt;&gt;&gt; Am 29.06.2016 um 00:55 schrieb David Hart via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This looks like lenses. I think we need to wait until after Swift 3 to discuss it, and come up with a bigger design that ties to reflexion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 28 Jun 2016, at 22:04, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So you&#39;re proposing that `#set(aVariableName)` should translate to `{aVariableName=$0}`, right? Where aVariableName can be any valid lvalue like `self.users` or `users` or `vc.viewControllers`..<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think this would be a good extension to Swift. (`users.set` does not work BTW, because maybe the `users` object has a `set` property.. maybe I wanted to refer to the `set` property which also happens to refer to a closure value.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `#set(aVariableName)` also feels consistent with the `#keyPath(aVariableName)` property and falls into a similar category. Maybe `#setter(aVariableName)` would be even more clear? Furthermore, I want to additionally propose to introduce `#get(aVariableName)` (or `#getter(aVariableName)`) too.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 28.06.2016 um 20:18 schrieb Austin Feight via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposal:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I propose adding setter methods to vars, which could look something like this: `ApiClient().fetchUsers().then(#set(users))`<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Initially I thought it should work like this: `ApiClient().fetchUsers().then(users.set)`<br>&gt;&gt;&gt;&gt;&gt; but to accomplish a line of code that flows grammatically, I believe putting &quot;set&quot; where it would naturally fall if the code was being read as a sentence is more Swifty.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Rationale:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The following code makes me smile:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ApiClient().fetchUsers().then(displayUsers)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It exemplifies the beauty of Swift. First-class functions make this line of code read very well. Consider some alternatives:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. ApiClient().fetchUsers().then { displayUsers($0) }<br>&gt;&gt;&gt;&gt;&gt; 2. ApiClient().fetchUsers().then { users in displayUsers(users) }<br>&gt;&gt;&gt;&gt;&gt; 3. ApiClient().fetchUsers().then { (users: [User]) in displayUsers(users) }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Using the lessons learned from Swift API Design Guidelines (WWDC 2016 Session 403) having an emphasis on clarity, my analysis of the alternatives is:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. $0 adds no additional information as to the type or explanation of what the argument is, thus adding nothing to the line of code for clarity, and therefore should be omitted<br>&gt;&gt;&gt;&gt;&gt; 2. adding &quot;users&quot; also adds nothing to the clarity of the code. The function, properly, contains the information necessary to reason about the argument it takes and what it does, and therefore adding &quot;users&quot; is redundant<br>&gt;&gt;&gt;&gt;&gt; 3. Not only is &quot;users&quot; redundant, but also is the explicit type label. The `displayUsers` method will only accept one type of argument, so we&#39;re duplicating information that the compiler (and autocomplete) already gives us<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With this I conclude that `ApiClient().fetchUsers().then(displayUsers)` is the Swiftiest option.<br>&gt;&gt;&gt;&gt;&gt; I want to extend this same logic to when I find myself writing code like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ApiClient().fetchUsers().then { users in<br>&gt;&gt;&gt;&gt;&gt; self.users = users<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; or alternatively, because &quot;users&quot; is likely redundant information again,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ApiClient().fetchUsers().then { self.users = $0 }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Personally I steer clear of `$0` as much as possible, because I very rarely feel that it provides the information necessary for code clarity. But beyond that, this code no longer reads as nicely as the code we had before. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Whereas `ApiClient().fetchUsers().then(displayUsers)` flows nicely as a sentence and reads grammatically, `ApiClient().fetchUsers().then { self.users = $0 }` no longer does.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think this feature could have a simple implementation where the compiler replaces `#set(X)` with `{ X = $0 }`, and I believe it would go a long way with respect to code clarity, especially when X is something longer like `self.view.bounds.origin.x`<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Looking forward to hearing thoughts from the community,<br>&gt;&gt;&gt;&gt;&gt; Austin Feight<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47c04e83c5e36a3e3c498ce99baab9f4?s=50"></div><header><strong>Setter methods for vars</strong> from <string>Austin Feight</string> &lt;austin at chexology.com&gt;<p>June 28, 2016 at 07:00:00pm</p></header><div class="content"><p>Built-in lenses would solve this issue and much more, didn&#39;t know it was on<br>the list already!<br></p><p>*Austin Feight *| Chief Shipping Officer<br></p><p><br>150 E. 52nd Street, 22nd Floor, New York, NY 10022<br>www.chexology.com &lt;http://www.coatchex.com/&gt; | www.austindfeight.com<br></p><p>On Tue, Jun 28, 2016 at 7:33 PM, Michael Peternell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Haha, I think if we support lenses we should also support a QBit<br>&gt; structure, because lenses are just special cases for QBits ;) That said, I<br>&gt; think it&#39;s unlikely that lenses will be supported in Swift 4. We should<br>&gt; wait for Swift 5 when the full QBit-library will be introduced<br>&gt; (hardware-accellerated of course, but it deploys back until the iPhone 6S.)<br>&gt;<br>&gt; Good night guys (it&#39;s 1:30 am in my time zone...)<br>&gt;<br>&gt; -Michael<br>&gt;<br>&gt; &gt; Am 29.06.2016 um 01:22 schrieb Sean Heber via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt; Lens are a term from functional programming theory (I think largely<br>&gt; Haskell in particular?). I don&#39;t know much about it, but here&#39;s somewhere<br>&gt; to start: https://www21.in.tum.de/teaching/fp/SS15/papers/17.pdf<br>&gt; &gt;<br>&gt; &gt; l8r<br>&gt; &gt; Sean<br>&gt; &gt;<br>&gt; &gt; Sent from my iPad<br>&gt; &gt;<br>&gt; &gt; On Jun 28, 2016, at 6:11 PM, Michael Peternell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; Really?? Or we just have #set and #get and no lenses, and it&#39;s done for<br>&gt; Swift 3?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I never heard of lenses (Google does not help here). Was this serious<br>&gt; or were you joking? Unless you can explain why #set and #get without lenses<br>&gt; would be bad... or maybe #set and #get *are* lenses, in which case I&#39;m not<br>&gt; sure what you were trying to say. Reflexion -&gt; Reflection?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Michael<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Am 29.06.2016 um 00:55 schrieb David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This looks like lenses. I think we need to wait until after Swift 3 to<br>&gt; discuss it, and come up with a bigger design that ties to reflexion.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On 28 Jun 2016, at 22:04, Michael Peternell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; So you&#39;re proposing that `#set(aVariableName)` should translate to<br>&gt; `{aVariableName=$0}`, right? Where aVariableName can be any valid lvalue<br>&gt; like `self.users` or `users` or `vc.viewControllers`..<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I think this would be a good extension to Swift. (`users.set` does<br>&gt; not work BTW, because maybe the `users` object has a `set` property.. maybe<br>&gt; I wanted to refer to the `set` property which also happens to refer to a<br>&gt; closure value.)<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; `#set(aVariableName)` also feels consistent with the<br>&gt; `#keyPath(aVariableName)` property and falls into a similar category. Maybe<br>&gt; `#setter(aVariableName)` would be even more clear? Furthermore, I want to<br>&gt; additionally propose to introduce `#get(aVariableName)` (or<br>&gt; `#getter(aVariableName)`) too.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; -Michael<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Am 28.06.2016 um 20:18 schrieb Austin Feight via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Proposal:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I propose adding setter methods to vars, which could look something<br>&gt; like this: `ApiClient().fetchUsers().then(#set(users))`<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Initially I thought it should work like this:<br>&gt; `ApiClient().fetchUsers().then(users.set)`<br>&gt; &gt;&gt;&gt;&gt;&gt; but to accomplish a line of code that flows grammatically, I believe<br>&gt; putting &quot;set&quot; where it would naturally fall if the code was being read as a<br>&gt; sentence is more Swifty.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Rationale:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; The following code makes me smile:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; ApiClient().fetchUsers().then(displayUsers)<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; It exemplifies the beauty of Swift. First-class functions make this<br>&gt; line of code read very well. Consider some alternatives:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; 1. ApiClient().fetchUsers().then { displayUsers($0) }<br>&gt; &gt;&gt;&gt;&gt;&gt; 2. ApiClient().fetchUsers().then { users in displayUsers(users) }<br>&gt; &gt;&gt;&gt;&gt;&gt; 3. ApiClient().fetchUsers().then { (users: [User]) in<br>&gt; displayUsers(users) }<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Using the lessons learned from Swift API Design Guidelines (WWDC<br>&gt; 2016 Session 403) having an emphasis on clarity, my analysis of the<br>&gt; alternatives is:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; 1. $0 adds no additional information as to the type or explanation<br>&gt; of what the argument is, thus adding nothing to the line of code for<br>&gt; clarity, and therefore should be omitted<br>&gt; &gt;&gt;&gt;&gt;&gt; 2. adding &quot;users&quot; also adds nothing to the clarity of the code. The<br>&gt; function, properly, contains the information necessary to reason about the<br>&gt; argument it takes and what it does, and therefore adding &quot;users&quot; is<br>&gt; redundant<br>&gt; &gt;&gt;&gt;&gt;&gt; 3. Not only is &quot;users&quot; redundant, but also is the explicit type<br>&gt; label. The `displayUsers` method will only accept one type of argument, so<br>&gt; we&#39;re duplicating information that the compiler (and autocomplete) already<br>&gt; gives us<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; With this I conclude that<br>&gt; `ApiClient().fetchUsers().then(displayUsers)` is the Swiftiest option.<br>&gt; &gt;&gt;&gt;&gt;&gt; I want to extend this same logic to when I find myself writing code<br>&gt; like this:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; ApiClient().fetchUsers().then { users in<br>&gt; &gt;&gt;&gt;&gt;&gt; self.users = users<br>&gt; &gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; or alternatively, because &quot;users&quot; is likely redundant information<br>&gt; again,<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; ApiClient().fetchUsers().then { self.users = $0 }<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Personally I steer clear of `$0` as much as possible, because I very<br>&gt; rarely feel that it provides the information necessary for code clarity.<br>&gt; But beyond that, this code no longer reads as nicely as the code we had<br>&gt; before.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Whereas `ApiClient().fetchUsers().then(displayUsers)` flows nicely<br>&gt; as a sentence and reads grammatically, `ApiClient().fetchUsers().then {<br>&gt; self.users = $0 }` no longer does.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I think this feature could have a simple implementation where the<br>&gt; compiler replaces `#set(X)` with `{ X = $0 }`, and I believe it would go a<br>&gt; long way with respect to code clarity, especially when X is something<br>&gt; longer like `self.view.bounds.origin.x`<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Looking forward to hearing thoughts from the community,<br>&gt; &gt;&gt;&gt;&gt;&gt; Austin Feight<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/743eec75/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Setter methods for vars</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 28, 2016 at 11:00:00pm</p></header><div class="content"><p>As an additive feature it&#39;s unlikely to be considered in the Swift 3<br>timeline anyway. You can search the list archive for previous discussion on<br>lenses. I think David is saying that this proposal looks like it&#39;s asking<br>for a special case where a more general solution might be appropriate.<br>On Tue, Jun 28, 2016 at 6:11 PM Michael Peternell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Really?? Or we just have #set and #get and no lenses, and it&#39;s done for<br>&gt; Swift 3?<br>&gt;<br>&gt; I never heard of lenses (Google does not help here). Was this serious or<br>&gt; were you joking? Unless you can explain why #set and #get without lenses<br>&gt; would be bad... or maybe #set and #get *are* lenses, in which case I&#39;m not<br>&gt; sure what you were trying to say. Reflexion -&gt; Reflection?<br>&gt;<br>&gt; -Michael<br>&gt;<br>&gt; &gt; Am 29.06.2016 um 00:55 schrieb David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt; This looks like lenses. I think we need to wait until after Swift 3 to<br>&gt; discuss it, and come up with a bigger design that ties to reflexion.<br>&gt; &gt;<br>&gt; &gt;&gt; On 28 Jun 2016, at 22:04, Michael Peternell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; So you&#39;re proposing that `#set(aVariableName)` should translate to<br>&gt; `{aVariableName=$0}`, right? Where aVariableName can be any valid lvalue<br>&gt; like `self.users` or `users` or `vc.viewControllers`..<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I think this would be a good extension to Swift. (`users.set` does not<br>&gt; work BTW, because maybe the `users` object has a `set` property.. maybe I<br>&gt; wanted to refer to the `set` property which also happens to refer to a<br>&gt; closure value.)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; `#set(aVariableName)` also feels consistent with the<br>&gt; `#keyPath(aVariableName)` property and falls into a similar category. Maybe<br>&gt; `#setter(aVariableName)` would be even more clear? Furthermore, I want to<br>&gt; additionally propose to introduce `#get(aVariableName)` (or<br>&gt; `#getter(aVariableName)`) too.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Michael<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Am 28.06.2016 um 20:18 schrieb Austin Feight via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Proposal:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I propose adding setter methods to vars, which could look something<br>&gt; like this: `ApiClient().fetchUsers().then(#set(users))`<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Initially I thought it should work like this:<br>&gt; `ApiClient().fetchUsers().then(users.set)`<br>&gt; &gt;&gt;&gt; but to accomplish a line of code that flows grammatically, I believe<br>&gt; putting &quot;set&quot; where it would naturally fall if the code was being read as a<br>&gt; sentence is more Swifty.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Rationale:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The following code makes me smile:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; ApiClient().fetchUsers().then(displayUsers)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; It exemplifies the beauty of Swift. First-class functions make this<br>&gt; line of code read very well. Consider some alternatives:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; 1. ApiClient().fetchUsers().then { displayUsers($0) }<br>&gt; &gt;&gt;&gt; 2. ApiClient().fetchUsers().then { users in displayUsers(users) }<br>&gt; &gt;&gt;&gt; 3. ApiClient().fetchUsers().then { (users: [User]) in<br>&gt; displayUsers(users) }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Using the lessons learned from Swift API Design Guidelines (WWDC 2016<br>&gt; Session 403) having an emphasis on clarity, my analysis of the alternatives<br>&gt; is:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; 1. $0 adds no additional information as to the type or explanation of<br>&gt; what the argument is, thus adding nothing to the line of code for clarity,<br>&gt; and therefore should be omitted<br>&gt; &gt;&gt;&gt; 2. adding &quot;users&quot; also adds nothing to the clarity of the code. The<br>&gt; function, properly, contains the information necessary to reason about the<br>&gt; argument it takes and what it does, and therefore adding &quot;users&quot; is<br>&gt; redundant<br>&gt; &gt;&gt;&gt; 3. Not only is &quot;users&quot; redundant, but also is the explicit type label.<br>&gt; The `displayUsers` method will only accept one type of argument, so we&#39;re<br>&gt; duplicating information that the compiler (and autocomplete) already gives<br>&gt; us<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; With this I conclude that<br>&gt; `ApiClient().fetchUsers().then(displayUsers)` is the Swiftiest option.<br>&gt; &gt;&gt;&gt; I want to extend this same logic to when I find myself writing code<br>&gt; like this:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; ApiClient().fetchUsers().then { users in<br>&gt; &gt;&gt;&gt; self.users = users<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; or alternatively, because &quot;users&quot; is likely redundant information<br>&gt; again,<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; ApiClient().fetchUsers().then { self.users = $0 }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Personally I steer clear of `$0` as much as possible, because I very<br>&gt; rarely feel that it provides the information necessary for code clarity.<br>&gt; But beyond that, this code no longer reads as nicely as the code we had<br>&gt; before.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Whereas `ApiClient().fetchUsers().then(displayUsers)` flows nicely as<br>&gt; a sentence and reads grammatically, `ApiClient().fetchUsers().then {<br>&gt; self.users = $0 }` no longer does.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I think this feature could have a simple implementation where the<br>&gt; compiler replaces `#set(X)` with `{ X = $0 }`, and I believe it would go a<br>&gt; long way with respect to code clarity, especially when X is something<br>&gt; longer like `self.view.bounds.origin.x`<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Looking forward to hearing thoughts from the community,<br>&gt; &gt;&gt;&gt; Austin Feight<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/b048019d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Setter methods for vars</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 29, 2016 at 06:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jun 29, 2016, at 1:11 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Really?? Or we just have #set and #get and no lenses, and it&#39;s done for Swift 3?<br>&gt; <br>&gt; I never heard of lenses (Google does not help here). Was this serious or were you joking?<br></p><p>http://days2012.scala-lang.org/sites/days2012/files/morris_lenses.pdf<br></p><p>Not a joke at all. Read first sentence for brief definition.<br></p><p>&gt; Unless you can explain why #set and #get without lenses would be bad... or maybe #set and #get *are* lenses, in which case I&#39;m not sure what you were trying to say. Reflexion -&gt; Reflection?<br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt;&gt; Am 29.06.2016 um 00:55 schrieb David Hart via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; This looks like lenses. I think we need to wait until after Swift 3 to discuss it, and come up with a bigger design that ties to reflexion.<br>&gt;&gt; <br>&gt;&gt;&gt; On 28 Jun 2016, at 22:04, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So you&#39;re proposing that `#set(aVariableName)` should translate to `{aVariableName=$0}`, right? Where aVariableName can be any valid lvalue like `self.users` or `users` or `vc.viewControllers`..<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this would be a good extension to Swift. (`users.set` does not work BTW, because maybe the `users` object has a `set` property.. maybe I wanted to refer to the `set` property which also happens to refer to a closure value.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `#set(aVariableName)` also feels consistent with the `#keyPath(aVariableName)` property and falls into a similar category. Maybe `#setter(aVariableName)` would be even more clear? Furthermore, I want to additionally propose to introduce `#get(aVariableName)` (or `#getter(aVariableName)`) too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 28.06.2016 um 20:18 schrieb Austin Feight via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I propose adding setter methods to vars, which could look something like this: `ApiClient().fetchUsers().then(#set(users))`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Initially I thought it should work like this: `ApiClient().fetchUsers().then(users.set)`<br>&gt;&gt;&gt;&gt; but to accomplish a line of code that flows grammatically, I believe putting &quot;set&quot; where it would naturally fall if the code was being read as a sentence is more Swifty.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Rationale:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The following code makes me smile:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ApiClient().fetchUsers().then(displayUsers)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It exemplifies the beauty of Swift. First-class functions make this line of code read very well. Consider some alternatives:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. ApiClient().fetchUsers().then { displayUsers($0) }<br>&gt;&gt;&gt;&gt; 2. ApiClient().fetchUsers().then { users in displayUsers(users) }<br>&gt;&gt;&gt;&gt; 3. ApiClient().fetchUsers().then { (users: [User]) in displayUsers(users) }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Using the lessons learned from Swift API Design Guidelines (WWDC 2016 Session 403) having an emphasis on clarity, my analysis of the alternatives is:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. $0 adds no additional information as to the type or explanation of what the argument is, thus adding nothing to the line of code for clarity, and therefore should be omitted<br>&gt;&gt;&gt;&gt; 2. adding &quot;users&quot; also adds nothing to the clarity of the code. The function, properly, contains the information necessary to reason about the argument it takes and what it does, and therefore adding &quot;users&quot; is redundant<br>&gt;&gt;&gt;&gt; 3. Not only is &quot;users&quot; redundant, but also is the explicit type label. The `displayUsers` method will only accept one type of argument, so we&#39;re duplicating information that the compiler (and autocomplete) already gives us<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With this I conclude that `ApiClient().fetchUsers().then(displayUsers)` is the Swiftiest option.<br>&gt;&gt;&gt;&gt; I want to extend this same logic to when I find myself writing code like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ApiClient().fetchUsers().then { users in<br>&gt;&gt;&gt;&gt; self.users = users<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or alternatively, because &quot;users&quot; is likely redundant information again,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ApiClient().fetchUsers().then { self.users = $0 }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Personally I steer clear of `$0` as much as possible, because I very rarely feel that it provides the information necessary for code clarity. But beyond that, this code no longer reads as nicely as the code we had before. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Whereas `ApiClient().fetchUsers().then(displayUsers)` flows nicely as a sentence and reads grammatically, `ApiClient().fetchUsers().then { self.users = $0 }` no longer does.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think this feature could have a simple implementation where the compiler replaces `#set(X)` with `{ X = $0 }`, and I believe it would go a long way with respect to code clarity, especially when X is something longer like `self.view.bounds.origin.x`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Looking forward to hearing thoughts from the community,<br>&gt;&gt;&gt;&gt; Austin Feight<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Setter methods for vars</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 29, 2016 at 08:00:00am</p></header><div class="content"><p>I did mean reflection, sorry for the typo :) what I wanted to say in more detail is that if we go with this syntax now (and I&#39;m fairly sure we won&#39;t because it&#39;s an additive feature), we may regret it post Swift 3 because if a more general implementation requires a different syntax, we are stuck.<br></p><p>Lenses tie well with reflection if for example an advanced equivalent of Mirror returns to you a list of the lenses for the properties of the object. It would allow us, for example, to write serialization libraries much more easily. Add property behaviours to the mix, and now we&#39;re going somewhere ;)<br></p><p>&gt; On 29 Jun 2016, at 01:11, michael.peternell at gmx.at wrote:<br>&gt; <br>&gt; Really?? Or we just have #set and #get and no lenses, and it&#39;s done for Swift 3?<br>&gt; <br>&gt; I never heard of lenses (Google does not help here). Was this serious or were you joking? Unless you can explain why #set and #get without lenses would be bad... or maybe #set and #get *are* lenses, in which case I&#39;m not sure what you were trying to say. Reflexion -&gt; Reflection?<br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt;&gt; Am 29.06.2016 um 00:55 schrieb David Hart via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; This looks like lenses. I think we need to wait until after Swift 3 to discuss it, and come up with a bigger design that ties to reflexion.<br>&gt;&gt; <br>&gt;&gt;&gt; On 28 Jun 2016, at 22:04, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So you&#39;re proposing that `#set(aVariableName)` should translate to `{aVariableName=$0}`, right? Where aVariableName can be any valid lvalue like `self.users` or `users` or `vc.viewControllers`..<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this would be a good extension to Swift. (`users.set` does not work BTW, because maybe the `users` object has a `set` property.. maybe I wanted to refer to the `set` property which also happens to refer to a closure value.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `#set(aVariableName)` also feels consistent with the `#keyPath(aVariableName)` property and falls into a similar category. Maybe `#setter(aVariableName)` would be even more clear? Furthermore, I want to additionally propose to introduce `#get(aVariableName)` (or `#getter(aVariableName)`) too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 28.06.2016 um 20:18 schrieb Austin Feight via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I propose adding setter methods to vars, which could look something like this: `ApiClient().fetchUsers().then(#set(users))`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Initially I thought it should work like this: `ApiClient().fetchUsers().then(users.set)`<br>&gt;&gt;&gt;&gt; but to accomplish a line of code that flows grammatically, I believe putting &quot;set&quot; where it would naturally fall if the code was being read as a sentence is more Swifty.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Rationale:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The following code makes me smile:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ApiClient().fetchUsers().then(displayUsers)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It exemplifies the beauty of Swift. First-class functions make this line of code read very well. Consider some alternatives:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. ApiClient().fetchUsers().then { displayUsers($0) }<br>&gt;&gt;&gt;&gt; 2. ApiClient().fetchUsers().then { users in displayUsers(users) }<br>&gt;&gt;&gt;&gt; 3. ApiClient().fetchUsers().then { (users: [User]) in displayUsers(users) }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Using the lessons learned from Swift API Design Guidelines (WWDC 2016 Session 403) having an emphasis on clarity, my analysis of the alternatives is:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. $0 adds no additional information as to the type or explanation of what the argument is, thus adding nothing to the line of code for clarity, and therefore should be omitted<br>&gt;&gt;&gt;&gt; 2. adding &quot;users&quot; also adds nothing to the clarity of the code. The function, properly, contains the information necessary to reason about the argument it takes and what it does, and therefore adding &quot;users&quot; is redundant<br>&gt;&gt;&gt;&gt; 3. Not only is &quot;users&quot; redundant, but also is the explicit type label. The `displayUsers` method will only accept one type of argument, so we&#39;re duplicating information that the compiler (and autocomplete) already gives us<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With this I conclude that `ApiClient().fetchUsers().then(displayUsers)` is the Swiftiest option.<br>&gt;&gt;&gt;&gt; I want to extend this same logic to when I find myself writing code like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ApiClient().fetchUsers().then { users in<br>&gt;&gt;&gt;&gt; self.users = users<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or alternatively, because &quot;users&quot; is likely redundant information again,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ApiClient().fetchUsers().then { self.users = $0 }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Personally I steer clear of `$0` as much as possible, because I very rarely feel that it provides the information necessary for code clarity. But beyond that, this code no longer reads as nicely as the code we had before. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Whereas `ApiClient().fetchUsers().then(displayUsers)` flows nicely as a sentence and reads grammatically, `ApiClient().fetchUsers().then { self.users = $0 }` no longer does.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think this feature could have a simple implementation where the compiler replaces `#set(X)` with `{ X = $0 }`, and I believe it would go a long way with respect to code clarity, especially when X is something longer like `self.view.bounds.origin.x`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Looking forward to hearing thoughts from the community,<br>&gt;&gt;&gt;&gt; Austin Feight<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
