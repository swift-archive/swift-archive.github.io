<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>For-loop revisited</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>February 26, 2016 at 03:00:00am</p></header><div class="content"><p>In technical and scientific programming, one often encounters loops<br>based on iterating and changing numerical values (e.g. floats, integers, doubles)<br>varying values from positive to negative or reversed with arbitrary<br>step sizes which also could be positive and negative, and <br>not bound to or based on collections or arrays.. <br>For example in this function which is part of a Swift/SceneKit app for Apple TV I am <br>currently constructing: <br></p><p>   // generate a matrix of tiles in space: <br>  // ( i don&#39;t care how many tiles, i even don&#39;t know,<br>  //  all i want is a certain area covered with tiles ) : <br></p><p>    func addTileMatrix(z z: Float )<br>    {<br>        let w:Float = 20<br>        let h:Float = 5<br>        let l:Float = 5<br>        <br>        for var x:Float = -60;    x &lt; 60;    x += w * 1.2<br>        {<br>            for var y:Float = -30;    y &lt; 60;    y += h * 1.2<br>            {<br>               let pos = SCNVector3(x: x,   y: y,   z: z)<br>                <br>                let tile = TGStaticTile(pos: pos,<br>                                w:  CGFloat(w), h: CGFloat(h), l: CGFloat(l),<br>                                color: UIColor.randomColor(), naam: &quot;Tile\(tiles.count + 1)&quot;)<br></p><p>                tiles.append(tile)<br>           }<br>        }<br>    }<br></p><p>As you can see, it relies completely on classical C-style for loops. As I see it, in this case<br>the classical for-loops in this function provide an easily understood, elegant and compact <br>way to generate the objects I need.<br></p><p>For reasons not all really convincing me, a lot of us want to drop the C-Style for-loop. <br>It is by some even considered to be error-prone, really? Something so simple as this? <br>In this perspective, one could argue that nearly all programming statements are error-prone... <br></p><p>Yes I have read Erica Sadun&#39;s proposal SE-0007 &quot;Remove C-Style for-loops with conditions and incrementers.&quot;  <br>In this document, the first classical for-loop offered for comparison is a really bad pointer based example, <br>a typical nightmare C or C++ construct.also: imho the offered alternative with for-in..  alternative is <br>not really much better. (actually imho Swift should not use (even unsafe) pointers at all , <br>but simply pass contiguous byte/word arrays only) In most cases however, the usage of <br>classical for loops can also be reasonably well structured, as in my example above.<br></p><p>Still, if one wants to get rid of the classical for-loop,  (and in many cases I do as well) <br>then there should be equivalents for iterating with non-collection values, like coordinates as in the above example.<br></p><p>Yes, by deploying the Stride library function, it is possible to convert my example <br>to the one below without the ancient for loop construct like so, as tested in Playground: <br></p><p>   let w:Float = 20  // i need Floats (see the example above) <br>    let h:Float = 5<br>    <br>    for var x:Float in (Float(-60.0)).stride(to: Float(60.0), by:  w * 1.2)<br>    {<br>        for var y:Float in (Float(-30.0)).stride(to: Float(60.0), by:  h * 1.2)<br>        {<br>            print(&quot;x = \(x)    y = \(y)&quot;)<br>        }<br>    }<br></p><p>The above works but imho it is really ugly. Not really an improvement over<br>the classical for-loop I think. <br></p><p>(btw. in the above  example. the compiler (which I think in most cases is superb!) <br>mistakingly recommends me to change the for-loop vars x and y to &#39;let&#39;..)<br></p><p>Imho all this casting between floating point types should be done implicitly, but<br>I&#39;ve already brought this topic forward here on the forum. <br>OK, let&#39;s clean it up a little: use a single floating point type here (Double):<br></p><p>let w = 20.0<br>let h = 5.0<br>    <br>for var x in (-60.0).stride(to: 60.0, by:  w * 1.2)<br>{<br>    for var y in (30.0).stride(to: -60.0, by:  -h * 1.2)<br>    {<br>        print(&quot;x = \(x)    y = \(y)&quot;)<br>    }<br>}<br></p><p>(btw: If I don&#39;t put () around -60 , then the compiler complains with<br>&quot;Unary operator &#39;-&#39; cannot be applied to an operand of type &#39;StrideTo&lt;Double&gt;&#39; &quot;<br>Could this be a compiler error? Shouldn&#39;t it first instantiate or evaluate the <br>numerical object,before glueing the .stride()  to it? ) <br></p><p>Although the for loops now have no mixed numerical types, imho, this still looks ugly. <br>One has to write too much code and it also needs &quot;indirect thought paths&quot; <br>like when using Objective C..  If I use for-loops, I don&#39;t want to think about library functions <br>like stride (btw nowhere described in the Swift manual !) <br></p><p>Assuming that the Swift for...in.. can only work with a one dimensional array or collection:<br>then:<br>Suppose for a moment that one is iterating with very small incrementing or <br>decrementing values in a relatively large range: Unless the compiler is smart enough<br>to recognize this, the stride function will allocate and deliver to the for-loop a huge vector<br>collection or array, with maybe ten thousands of values.. making it all extremely inefficient.<br>This is of course an unacceptable disadvantage for often used iterating control statements.<br></p><p><br>To improve this I&#39;d suggest why not simply let the compiler handle the iteration set up internally <br>like it has been done for almost half a century in most other programming languages?<br>I would suggest to add these new for loop variants to Swift, as an integral part of the Swift language. <br></p><p><br>for var n from 10 to 1 by -1  { }    //  looping backwards<br></p><p>for var n from -10 to 12   // here, the compiler assumes and increment value of 1, no &quot;by&quot; is needed.<br></p><p>for var x: Float from -60.0 to 120 by 0.01 { }  // this one has many iterations! <br></p><p>for var d from 0.0 to abyss by -rate {} <br></p><p><br>I&#39;d suggest also: All literals and vars behind the &quot;from&quot;  should whenever possible be<br>implicitly converted to the loop var&#39;s type (var x here)<br></p><p>There&#39;s another huge advantage here. Now that the compiler sees a &quot;from&quot; it would<br>expect 2 or 3 values instead of a (sometimes huge) one dimensional vector.<br>(it needs to go through each value in the vector, because the vector contens<br>are unpredictable.)<br>Range and increment are now well defined, so the compiler is now able to generate<br>very efficient low level code which  would be so much faster <br>that allocating and iterating through a vector.<br></p><p>As you can see, these for-loop variants are really clean and easy to understand. <br>Even those with little programming experience will grasp immediately what is<br> going on here!<br></p><p>Swift was / is also intended to offer an easy entry level for<br>those new to programming, much easier that starting with Objective C.<br>So, I&#39;d kindly suggest keep it simple, whenever possible. <br></p><p>Kind Regards<br>Ted<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>For-loop revisited</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>February 25, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; OK, let&#39;s clean it up a little: use a single floating point type here (Double):<br>&gt; <br>&gt; let w = 20.0<br>&gt; let h = 5.0<br>&gt; <br>&gt; for var x in (-60.0).stride(to: 60.0, by:  w * 1.2)<br>&gt; {<br>&gt;    for var y in (30.0).stride(to: -60.0, by:  -h * 1.2)<br>&gt;    {<br>&gt;        print(&quot;x = \(x)    y = \(y)&quot;)<br>&gt;    }<br>&gt; }<br></p><p>For what it&#39;s worth, you can keep the Floats and things can still be simple:<br></p><p>    let w: Float = 20<br>    let h: Float = 5<br>    for x in Float(-60).stride(to: 60, by: w * 1.2) {<br>        for y in Float(30).stride(to: -60, by: -h * 1.2) {<br>            print(&quot;x = \(x) y = \(y)&quot;)<br>        }<br>    }<br></p><p>Inference makes it possible to use integer literals and avoid explicit casts most places.<br></p><p>(To be honest, I&#39;m not sure why the `Float(-60)` and `Float(30)` are required. I would assume that the presence of `w` and `-h` as `by:` arguments would allow the other arguments to be inferred.)<br></p><p>Stephen<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>For-loop revisited</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 26, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 26 Feb 2016, at 02:11, ted van gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; for var n from 10 to 1 by -1  { }    //  looping backwards<br></p><p>This is currently possible with:<br></p><p>	for var n in (1 … 10).reverse()<br></p><p>Which I find pretty simple personally, though being able to do 10 … 1 would be nice.<br></p><p>&gt; for var n from -10 to 12   // here, the compiler assumes and increment value of 1, no &quot;by&quot; is needed.<br></p><p>The following already does this one as-is:<br></p><p>	for var n in -10 … 12<br></p><p>&gt; for var x: Float from -60.0 to 120 by 0.01 { }  // this one has many iterations!<br>&gt; for var d from 0.0 to abyss by -rate {} <br></p><p>These two definitely make more of a case for this. I’m not so sure about introducing new keywords for this though.<br></p><p>Personally I think that what we need is a more flexible type for the … and ..&lt; operators that is simple two related values in any order, which Range could be instantiated from with more strict conditions (must be low to high) for things like grabbing arrays slices and so-on where the order matters. The basic non-Range would then be optimised for use with loops to give us the greater flexibility without having to do stuff like using .reverse().<br></p><p>Plus ideally the new type would be capable of representing a full range of values; I really don’t like that Range&lt;UInt8&gt; is currently limited to 0-254 inclusive, since the endIndex is always exclusive, but that’s another topic really.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/78922879/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>For-loop revisited</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>February 26, 2016 at 05:00:00pm</p></header><div class="content"><p>Hello Haravikk,<br></p><p>Thank you. Yes I know this is possible,<br>but my main point is that   for..in..    always expects an instance of some sort of a collection.<br></p><p>e.g for this for-loop:<br></p><p>for var x in -60.0.stride(to: 60.0, by:  0.001) <br></p><p><br>What I don’t know: (can’t find yet)<br>&gt;&gt;  Will in this case a large collection with 120000 elements of Double be created by .stride?<br> or<br>&gt;&gt;  Does .stride(), which in the end uses a descendant of SequenceType, just calculate a new value each time   for..in..   uses .next() on this collection? <br>I hope the latter is true.  <br></p><p>Can someone clarify this perhaps? <br></p><p>Still , I’d rather see a for variant with “from”<br></p><p>e.g.<br></p><p>    for  x from xmin to xmax by xstep  { }<br></p><p>    for x from xmax to xmin by -xstep  { } <br></p><p>    for apple from 1 to applesInTruck  { }<br></p><p>No need for collections in these cases,<br></p><p>Shouldn&#39;t be that hard to implement? <br></p><p>kind regards<br>Ted<br></p><p><br></p><p>ted van gaalen<br></p><p><br></p><p>&gt; On 26.02.2016, at 12:45, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 26 Feb 2016, at 02:11, ted van gaalen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; for var n from 10 to 1 by -1  { }    //  looping backwards<br>&gt; <br>&gt; This is currently possible with:<br>&gt; <br>&gt; 	for var n in (1 … 10).reverse()<br>&gt; <br>&gt; Which I find pretty simple personally, though being able to do 10 … 1 would be nice.<br>&gt; <br>&gt;&gt; for var n from -10 to 12   // here, the compiler assumes and increment value of 1, no &quot;by&quot; is needed.<br>&gt; <br>&gt; The following already does this one as-is:<br>&gt; <br>&gt; 	for var n in -10 … 12<br>&gt; <br>&gt;&gt; for var x: Float from -60.0 to 120 by 0.01 { }  // this one has many iterations!<br>&gt;&gt; for var d from 0.0 to abyss by -rate {} <br>&gt; <br>&gt; These two definitely make more of a case for this. I’m not so sure about introducing new keywords for this though.<br>&gt; <br>&gt; Personally I think that what we need is a more flexible type for the … and ..&lt; operators that is simple two related values in any order, which Range could be instantiated from with more strict conditions (must be low to high) for things like grabbing arrays slices and so-on where the order matters. The basic non-Range would then be optimised for use with loops to give us the greater flexibility without having to do stuff like using .reverse().<br>&gt; <br>&gt; Plus ideally the new type would be capable of representing a full range of values; I really don’t like that Range&lt;UInt8&gt; is currently limited to 0-254 inclusive, since the endIndex is always exclusive, but that’s another topic really.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/5b698022/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>For-loop revisited</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February 26, 2016 at 01:00:00pm</p></header><div class="content"><p>Well... I&#39;m against the removal of C style for loop, but it is gone. (I do<br>not think the `for ... in ...`  is a replacement.) And I&#39;m against the<br>removal of `++` and `--` operator as well. For years to come whenever<br>anyone asks me about it I&#39;m going to say that I was against the removal. ;-)<br></p><p>I like the `for ... from ... to .. by ...` syntax. This would be a<br>replacement for the C style loop, not the `for ... in ... ` that, as I see,<br>is a very welcome addition but not a replacement.<br></p><p>-Van<br></p><p>On Fri, Feb 26, 2016 at 1:07 PM, Ted F.A. van Gaalen via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Haravikk,<br>&gt;<br>&gt; Thank you. Yes I know this is possible,<br>&gt; but my main point is that   for..in..    always expects an instance of<br>&gt; some sort of a collection.<br>&gt;<br>&gt; e.g for this for-loop:<br>&gt;<br>&gt; for var x in -60.0.stride(to: 60.0, by:  0.001)<br>&gt;<br>&gt;<br>&gt; What I don’t know: (can’t find yet)<br>&gt; &gt;&gt;  Will in this case a large collection with 120000 elements of Double be<br>&gt; created by .stride?<br>&gt;  or<br>&gt; &gt;&gt;  Does .stride(), which in the end uses a descendant of SequenceType,<br>&gt; just calculate a new value each time   for..in..   uses .next() on this<br>&gt; collection?<br>&gt; I hope the latter is true.<br>&gt;<br>&gt; Can someone clarify this perhaps?<br>&gt;<br>&gt; Still , I’d rather see a for variant with “from”<br>&gt;<br>&gt; e.g.<br>&gt;<br>&gt;     for  x from xmin to xmax by xstep  { }<br>&gt;<br>&gt;     for x from xmax to xmin by -xstep  { }<br>&gt;<br>&gt;     for apple from 1 to applesInTruck  { }<br>&gt;<br>&gt; No need for collections in these cases,<br>&gt;<br>&gt; Shouldn&#39;t be that hard to implement?<br>&gt;<br>&gt; kind regards<br>&gt; Ted<br>&gt;<br>&gt;<br>&gt;<br>&gt; ted van gaalen<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 26.02.2016, at 12:45, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 26 Feb 2016, at 02:11, ted van gaalen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; for var n from 10 to 1 by -1  { }    //  looping backwards<br>&gt;<br>&gt;<br>&gt; This is currently possible with:<br>&gt;<br>&gt; for var n in (1 … 10).reverse()<br>&gt;<br>&gt; Which I find pretty simple personally, though being able to do 10 … 1<br>&gt; would be nice.<br>&gt;<br>&gt; for var n from -10 to 12   // here, the compiler assumes and increment<br>&gt; value of 1, no &quot;by&quot; is needed.<br>&gt;<br>&gt;<br>&gt; The following already does this one as-is:<br>&gt;<br>&gt; for var n in -10 … 12<br>&gt;<br>&gt; for var x: Float from -60.0 to 120 by 0.01 { }  // this one has many<br>&gt; iterations!<br>&gt; for var d from 0.0 to abyss by -rate {}<br>&gt;<br>&gt;<br>&gt; These two definitely make more of a case for this. I’m not so sure about<br>&gt; introducing new keywords for this though.<br>&gt;<br>&gt; Personally I think that what we need is a more flexible type for the … and<br>&gt; ..&lt; operators that is simple two related values in any order, which Range<br>&gt; could be instantiated from with more strict conditions (must be low to<br>&gt; high) for things like grabbing arrays slices and so-on where the order<br>&gt; matters. The basic non-Range would then be optimised for use with loops to<br>&gt; give us the greater flexibility without having to do stuff like using<br>&gt; .reverse().<br>&gt;<br>&gt; Plus ideally the new type would be capable of representing a full range of<br>&gt; values; I really don’t like that Range&lt;UInt8&gt; is currently limited to 0-254<br>&gt; inclusive, since the endIndex is always exclusive, but that’s another topic<br>&gt; really.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/0d925bbd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>For-loop revisited</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>February 26, 2016 at 06:00:00pm</p></header><div class="content"><p>I also do like the for..in.. naturally: when collections are involved.<br>like:  <br>    for croc in crocodiles  <br>    for candidate in presidentialCandidates.sort( { $0.IQ &gt; $1.IQ} )  //...<br>etc.<br></p><p><br>I also see no reason to remove ++ and —  <br>but i can live with it. <br></p><p><br></p><p>Ted<br></p><p>&gt; On 26.02.2016, at 17:21, Vanderlei Martinelli &lt;vmartinelli at alecrim.com&gt; wrote:<br>&gt; <br>&gt; Well... I&#39;m against the removal of C style for loop, but it is gone. (I do not think the `for ... in ...`  is a replacement.) And I&#39;m against the removal of `++` and `--` operator as well. For years to come whenever anyone asks me about it I&#39;m going to say that I was against the removal. ;-)<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>For-loop revisited</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>February 26, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 26, 2016, at 9:07 AM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &gt;&gt;  Does .stride(), which in the end uses a descendant of SequenceType, just calculate a new value each time   for..in..   uses .next() on this collection? <br></p><p>this.<br></p><p>&gt;     for  x from xmin to xmax by xstep  { }<br>&gt; <br>&gt;     for x from xmax to xmin by -xstep  { } <br>&gt; <br>&gt;     for apple from 1 to applesInTruck  { }<br>&gt; <br>&gt; No need for collections in these cases,<br></p><p>As the thread for removal of C-style for showed in benchmarks, using a range or stride does not have a performance impact under optimization. Such new syntax would need to stand on its own as a second alternative to using ranges/strides. <br></p><p>Considering that it would require reserving three new keywords (‘from’, ‘to’, and ‘by’) this will be a hard argument to make.<br></p><p>-DW<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4139 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/f00e5400/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>For-loop revisited</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>February 27, 2016 at 12:00:00am</p></header><div class="content"><p>Thanks for clarifying, David<br></p><p>However, to me, it still remains awkward and indirect to <br>use collections in cases where they are not necessary at all. <br></p><p>About reserved words: <br>The sub-keywords  (‘from’, ‘to’, and ‘by’)  <br>are context dependent and will almost certainly <br>not be used on their own, rather always together<br>with a primary keyword.<br></p><p>An advanced compiler should be able to<br>determine from the context of a statement <br>if words used in that statement act as keywords or not! <br></p><p>For instance the PL/1 language from &lt; 1970 , far ahead of its time,  **1**<br>in spite of being very extensive, has no reserved words at all.<br></p><p>Most people will not use reserved words as identifiers because this is confusing.  <br></p><p>I will write a Swift proposal next week for<br>for .. from .. to.. [by.. ] ,<br>in spite of all of its functionality being <br>already present in the classical for ;; loop.  <br></p><p>I still cannot find a reason why it should be removed.<br>As with any other language construct,<br>it really depends on how one uses it.<br>Like with any other language elements in Swift,<br>it’s very easy to create a mess, no one can prevent this.<br></p><p>Of course, I would use a  for..in.. <br>if dealing with a collection: using a <br>classic for ;;  for that is clearly not an advantage.<br></p><p>TedvG<br></p><p><br></p><p>  **1**    As a source of inspiration, one might find this interesting:<br>https://en.wikibooks.org/wiki/Software_Engineers_Handbook/Language_Dictionary/PLI#Looping_Statements<br></p><p>Ted<br></p><p>&gt; On 26.02.2016, at 21:52, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 26, 2016, at 9:07 AM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Does .stride(), which in the end uses a descendant of SequenceType, just calculate a new value each time   for..in..   uses .next() on this collection? <br>&gt; <br>&gt; this.<br>&gt; <br>&gt;&gt;    for  x from xmin to xmax by xstep  { }<br>&gt;&gt; <br>&gt;&gt;    for x from xmax to xmin by -xstep  { } <br>&gt;&gt; <br>&gt;&gt;    for apple from 1 to applesInTruck  { }<br>&gt;&gt; <br>&gt;&gt; No need for collections in these cases,<br>&gt; <br>&gt; As the thread for removal of C-style for showed in benchmarks, using a range or stride does not have a performance impact under optimization. Such new syntax would need to stand on its own as a second alternative to using ranges/strides. <br>&gt; <br>&gt; Considering that it would require reserving three new keywords (‘from’, ‘to’, and ‘by’) this will be a hard argument to make.<br>&gt; <br>&gt; -DW<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/a38a0921/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>For-loop revisited</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>March  8, 2016 at 06:00:00pm</p></header><div class="content"><p>I&#39;m a bit late to the discussion but how about something like this:<br></p><p>for x in (0..&lt;5).by(0.3) { ... }<br>// or<br>for x in (0..&lt;5).strideBy(0.3) { ... }<br>// or<br>for x in stride(0..&lt;5, by: 0.3) { ... }<br></p><p>Greetings<br>- Maximilian<br></p><p>&gt; Am 27.02.2016 um 00:31 schrieb Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Thanks for clarifying, David<br>&gt; <br>&gt; However, to me, it still remains awkward and indirect to <br>&gt; use collections in cases where they are not necessary at all. <br>&gt; <br>&gt; About reserved words: <br>&gt; The sub-keywords  (‘from’, ‘to’, and ‘by’)  <br>&gt; are context dependent and will almost certainly <br>&gt; not be used on their own, rather always together<br>&gt; with a primary keyword.<br>&gt; <br>&gt; An advanced compiler should be able to<br>&gt; determine from the context of a statement <br>&gt; if words used in that statement act as keywords or not! <br>&gt; <br>&gt; For instance the PL/1 language from &lt; 1970 , far ahead of its time,  **1**<br>&gt; in spite of being very extensive, has no reserved words at all.<br>&gt; <br>&gt; Most people will not use reserved words as identifiers because this is confusing.  <br>&gt; <br>&gt; I will write a Swift proposal next week for<br>&gt; for .. from .. to.. [by.. ] ,<br>&gt; in spite of all of its functionality being <br>&gt; already present in the classical for ;; loop.  <br>&gt; <br>&gt; I still cannot find a reason why it should be removed.<br>&gt; As with any other language construct,<br>&gt; it really depends on how one uses it.<br>&gt; Like with any other language elements in Swift,<br>&gt; it’s very easy to create a mess, no one can prevent this.<br>&gt; <br>&gt; Of course, I would use a  for..in.. <br>&gt; if dealing with a collection: using a <br>&gt; classic for ;;  for that is clearly not an advantage.<br>&gt; <br>&gt; TedvG<br>&gt; <br>&gt; <br>&gt; <br>&gt;   **1**    As a source of inspiration, one might find this interesting:<br>&gt; https://en.wikibooks.org/wiki/Software_Engineers_Handbook/Language_Dictionary/PLI#Looping_Statements<br>&gt; <br>&gt; Ted<br>&gt; <br>&gt;&gt;&gt; On 26.02.2016, at 21:52, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 26, 2016, at 9:07 AM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Does .stride(), which in the end uses a descendant of SequenceType, just calculate a new value each time   for..in..   uses .next() on this collection?<br>&gt;&gt; <br>&gt;&gt; this.<br>&gt;&gt; <br>&gt;&gt;&gt;    for  x from xmin to xmax by xstep  { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    for x from xmax to xmin by -xstep  { } <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    for apple from 1 to applesInTruck  { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No need for collections in these cases,<br>&gt;&gt; <br>&gt;&gt; As the thread for removal of C-style for showed in benchmarks, using a range or stride does not have a performance impact under optimization. Such new syntax would need to stand on its own as a second alternative to using ranges/strides. <br>&gt;&gt; <br>&gt;&gt; Considering that it would require reserving three new keywords (‘from’, ‘to’, and ‘by’) this will be a hard argument to make.<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/2306135d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>For-loop revisited</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>March  9, 2016 at 12:00:00am</p></header><div class="content"><p>@Sebastien: Note: your previous email was received by me only and not CC-ed to swift-evolution.<br></p><p>Hello Maximillian<br></p><p>Thanks, but your examples are still for..in.. using pseudo-collections.<br></p><p>My point was, and still is, having a clean and fast iteration statement in Swift,<br>easy to use, without the need to use (pseudo) collections, as with .stride.<br></p><p>Again, if you use for..in.. on collections, that is where the for..in.. <br>really shines!  I use it all the time when I have to handle<br>collection like arrays dictionaries. etc.. So far so good.<br></p><p>However, in the real world, especially when working with technical <br>and scientific data and for instance in time critical applications <br>like 3D presentations fast iterations become a necessity.<br>E.g. I am currently writing an Apple TV 3D app based on SceneKit<br>with lots of SCNNode objects. For instance about 300 (geometric) <br>blocks for each which I have to update it’s 3D positions as fast as <br>possible. x,y, and z coordinates in (now 3 nested for-loop) <br>If I have to do that with .stride. the overhead time is simply too much!<br>Also because it needs to be don within the rendering interval time.<br>Using for..in.. loops would make it exceed this small time frame.<br></p><p>(as a side note I might assume (but assuming is a bad<br>thing in software engineering) that many colleagues here<br>do not build apps such as described in the previous paragraph,<br>(i hope i am wrong) and therefore do not miss these for<br>statements, not to mention the classical for-loop. )   <br></p><p>Here follows an example, clearly showing the difference:<br>The version without a GeneratorType/SequenceType<br>is more than twice as fast! Take a look at the coding,<br>it should then be clear why. <br></p><p>As tested in Xcode Playground:<br> <br></p><p>import Foundation<br></p><p>// I wrote this function not only to test but also<br>// implemented floating point comparison tolerance<br>// and backwards striding: it is still based<br>// on SequenceType each time a value is<br>// fetched it has to go through his generator<br>// instances, no wonder it it runs twice as slow.<br></p><p><br>public struct StriderGenerator : GeneratorType<br>{<br>    private let low: Double<br>    private let high: Double<br>    private var step : Double<br>    private var tol  : Double<br></p><p>    private var iterator  = 0<br></p><p>    private let moveForward: Bool<br>    <br>    private var done  = false<br>   <br>    <br>    <br>    public init(from: Double, to: Double, by: Double, tolerance: Double)<br>    {<br>        step = by<br>        if from &lt; to<br>        {<br>            low  = from<br>            high = to<br>            moveForward = true<br>        }<br>        else<br>        {<br>            low  = to<br>            high = from<br>            moveForward = false<br>        }<br>        self.tol   = tolerance * 0.5  // center it.<br>    }<br>    <br>    /// return next value or nil, if no next<br>    /// element exists.<br>    <br>    public mutating func next() -&gt; Double?<br>    {<br>        let current:Double<br>        if done<br>        {<br>            return nil<br>        }<br>        <br>        if moveForward<br>        {<br>            current = low + Double(iterator) * step<br>        }<br>        else<br>        {<br>            current = high - Double(iterator) * step<br>        }<br>        iterator += 1<br>        <br>        <br>        // done if exceeding low or highlimits + tolerance<br>        <br>        done = current &gt; high   + tol  ||<br>               current &lt; low    - tol<br>        <br>        if done<br>        {<br>            return nil<br>        }<br>        else<br>        {<br>            return current<br>        }<br>    }<br>}<br></p><p><br>public struct Strider : SequenceType   // Aragorn<br>{<br>    private let start:  Double<br>    private let end:    Double<br>    private let step:   Double<br>    private let tol:    Double<br></p><p>    init(from: Double, to: Double, by: Double, tolerance : Double)<br>    {<br>        _precondition(by &gt; 0.0 ,<br>            &quot;Init of struct Strider: &#39;by:...&#39; value must be &gt; 0.0.&quot;)<br>        _precondition(abs(by) &gt; tolerance,<br>            &quot;Init of struct Strider: &#39;by:...&#39; value must be &gt; tolerance.&quot;)<br>        _precondition(tolerance &gt;= 0.0,<br>            &quot;Init of struct Strider: tolerance:... value must be &gt;= 0.0&quot;)<br>        <br>        start = from<br>        end   = to;<br>        step  = by<br>        tol   = tolerance<br>    }<br>    <br>    /// Return a *generator* over the elements of this *sequence*.<br>    <br>    public func generate() -&gt; StriderGenerator<br>    {<br>        return StriderGenerator(from: start, to: end, by: step, tolerance:  tol)<br>    }<br>}<br></p><p>public extension Double<br>{<br>    <br>    public func strider(to to: Double, by: Double, tolerance: Double ) -&gt; Strider<br>    {<br>        return Strider( from: self, to: to, by: by, tolerance: tolerance)<br>    }<br>}<br></p><p>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br>// This function written by me yesterday, is a very simple iterator<br>// without unnecessary calls to an instance of an iterator. sequence type.<br>// why should it? All direct logic is completely within the function.<br>// this function is more than twice as fast as the one above.<br>// Just pass it a block, continue and break are not yet implemented<br>// but could be an extra block parameter. <br></p><p>func iterate(from from: Double,<br>                    to: Double,<br>                    by: Double,<br>                 block: (v: Double) -&gt; Void)<br>{<br>    let low:  Double<br>    let high: Double<br>    <br>    var current = from<br>    <br>    let moveForward = from &lt;= to<br>    if moveForward<br>    {<br>        low  = from<br>        high = to<br>    }<br>    else<br>    {<br>        low  = to<br>        high = from<br>    }<br>    <br>    var iterator = 0<br></p><p>    while current &gt;= low  &amp;&amp;<br>          current &lt;= high<br>    {<br>        block(v: current)  // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br>        <br>        iterator += 1     // ++ !<br>        if moveForward<br>        {<br>            current = low + Double(iterator) * by<br>        }<br>        else<br>        {<br>            current = high - Double(iterator) * by<br>        }<br>    }<br>}<br></p><p>/////////////////////////////////////////////////////////////////////////////////////////////////////<br>// Here are test of both methods: they are trivial<br>// sum up all iteration values.<br></p><p>func testWithStrideFor()  // Test with swift lib strider function<br>{<br>    var total = 0.0<br>    <br>    for value in 0.0.strider(to: 100.0, by: 0.01, tolerance:  0.0001 )<br>    {<br>        total += value<br>    }<br>    print(&quot;total\(total)&quot;)<br>}<br></p><p><br>func testWithTedsFor() // Test with my iterate function above:<br>{<br>    var total = 0.0<br>    <br>    iterate(from: 0.0, to: 100.0, by: 0.01,  block:<br>        {<br>            (value: Double) in<br>            total += value<br>        }<br>    )<br>    print(&quot;total\(total)&quot;)<br>}<br></p><p>// Here both methods are compared<br></p><p>func test()<br>{<br>    <br>    let start1 = NSDate();<br>    testWithStrideFor()<br>    let end1 = NSDate();<br>    <br>    let elapsed1 =  end1.timeIntervalSinceDate(start1)<br>    <br>    let start2 = NSDate();<br>    testWithTedsFor()<br>    let end2 = NSDate();<br>    <br>    let elapsed2 =  end2.timeIntervalSinceDate(start2)<br>    <br>    print(&quot;Test result (in seconds): &quot;)<br>    print(&quot;Time test1: with Strider    = \(elapsed1)&quot;)<br>    print(&quot;Time test2: without Strider = \(elapsed2)&quot;)<br>    print(&quot;The difference:             = \(abs(elapsed1 - elapsed2))&quot;)<br>}<br></p><p>test()<br>////////////////////////////////////////////////////////////////////////////////////////////////<br>// test results:<br>total500050.0<br>total500050.0<br>Test result (in seconds): <br>Time test1: with Strider       = 10.1978410482407<br>Time test2: without Strider = 4.94159704446793<br>The difference:                   = 5.25624400377274<br></p><p>The latter iterator function without the strider is<br>is more than twice as fast, which is not exactly<br>a miracle.<br></p><p>It is highly probable that if both methods were precompiled,<br>possibly optimized by hand, and integrated in the<br>Swift language, they  would be even much faster.<br>Especially the method without the strider, because<br>it has about 60% less coding, and doesn’t go shopping<br>each time around to get the next() value.<br></p><p>however please implement<br></p><p>for v from v1 to v2 by vstep<br></p><p>simple, isn’t it?<br></p><p><br></p><p>I not really happy writing all this, but it seems to be necessary <br>because a replacement is needed  for the classical for ;;  <br>statement which wil be removed, without offering a <br>decent alternative!<br>I use them at many places and I have to <br>unnecessarily convert them<br></p><p>Why not simply leave them in as they do not <br>stand other Swift elements in the way.<br>If you don’t like the for ;; or even i++  <br>just don’t use them. it’s as easy as that.  <br></p><p>Kind regards<br>Ted<br></p><p><br></p><p><br></p><p> <br></p><p><br>&gt; On 08.03.2016, at 18:29, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m a bit late to the discussion but how about something like this:<br>&gt; <br>&gt; for x in (0..&lt;5).by(0.3) { ... }<br>&gt; // or<br>&gt; for x in (0..&lt;5).strideBy(0.3) { ... }<br>&gt; // or<br>&gt; for x in stride(0..&lt;5, by: 0.3) { ... }<br>&gt; <br>&gt; Greetings<br>&gt; - Maximilian<br>&gt; <br>&gt; Am 27.02.2016 um 00:31 schrieb Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; Thanks for clarifying, David<br>&gt;&gt; <br>&gt;&gt; However, to me, it still remains awkward and indirect to <br>&gt;&gt; use collections in cases where they are not necessary at all. <br>&gt;&gt; <br>&gt;&gt; About reserved words: <br>&gt;&gt; The sub-keywords  (‘from’, ‘to’, and ‘by’)  <br>&gt;&gt; are context dependent and will almost certainly <br>&gt;&gt; not be used on their own, rather always together<br>&gt;&gt; with a primary keyword.<br>&gt;&gt; <br>&gt;&gt; An advanced compiler should be able to<br>&gt;&gt; determine from the context of a statement <br>&gt;&gt; if words used in that statement act as keywords or not! <br>&gt;&gt; <br>&gt;&gt; For instance the PL/1 language from &lt; 1970 , far ahead of its time,  **1**<br>&gt;&gt; in spite of being very extensive, has no reserved words at all.<br>&gt;&gt; <br>&gt;&gt; Most people will not use reserved words as identifiers because this is confusing.  <br>&gt;&gt; <br>&gt;&gt; I will write a Swift proposal next week for<br>&gt;&gt; for .. from .. to.. [by.. ] ,<br>&gt;&gt; in spite of all of its functionality being <br>&gt;&gt; already present in the classical for ;; loop.  <br>&gt;&gt; <br>&gt;&gt; I still cannot find a reason why it should be removed.<br>&gt;&gt; As with any other language construct,<br>&gt;&gt; it really depends on how one uses it.<br>&gt;&gt; Like with any other language elements in Swift,<br>&gt;&gt; it’s very easy to create a mess, no one can prevent this.<br>&gt;&gt; <br>&gt;&gt; Of course, I would use a  for..in.. <br>&gt;&gt; if dealing with a collection: using a <br>&gt;&gt; classic for ;;  for that is clearly not an advantage.<br>&gt;&gt; <br>&gt;&gt; TedvG<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;   **1**    As a source of inspiration, one might find this interesting:<br>&gt;&gt; https://en.wikibooks.org/wiki/Software_Engineers_Handbook/Language_Dictionary/PLI#Looping_Statements<br>&gt;&gt; <br>&gt;&gt; Ted<br>&gt;&gt; <br>&gt;&gt;&gt; On 26.02.2016, at 21:52, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 26, 2016, at 9:07 AM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Does .stride(), which in the end uses a descendant of SequenceType, just calculate a new value each time   for..in..   uses .next() on this collection? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    for  x from xmin to xmax by xstep  { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    for x from xmax to xmin by -xstep  { } <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    for apple from 1 to applesInTruck  { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No need for collections in these cases,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As the thread for removal of C-style for showed in benchmarks, using a range or stride does not have a performance impact under optimization. Such new syntax would need to stand on its own as a second alternative to using ranges/strides. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Considering that it would require reserving three new keywords (‘from’, ‘to’, and ‘by’) this will be a hard argument to make.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -DW<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>For-loop revisited</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>March  9, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On 09 Mar 2016, at 00:01, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; However, in the real world, especially when working with technical <br>&gt; and scientific data and for instance in time critical applications <br>&gt; like 3D presentations fast iterations become a necessity.<br></p><p>There is no reason why collection-based iteration can’t be as fast as a classical C for loop. The compiler should be able to optimise all the overhead away. , even unroll shorter loops. Maybe it doesn’t do it yet. I’d rather see resources invested into improving the compiler to inline/unroll code better where appropriate rather then introducing additional syntax to support a marginal use case. <br></p><p>— Taras<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>For-loop revisited</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>March  9, 2016 at 01:00:00pm</p></header><div class="content"><p>Sometimes programmers directives and runtime knowledge are essential though and the compilers should be optimised but not held to a practically impossible standards. Beside not letting their best people having the best manufacturing process (as well as a nice dose of politics), there is a reason why architectures like IA-64 (which still intrigue me :)) had competitive problems against archs which trusted runtime decisions a lot more.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 9 Mar 2016, at 12:21, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 09 Mar 2016, at 00:01, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; However, in the real world, especially when working with technical <br>&gt;&gt; and scientific data and for instance in time critical applications <br>&gt;&gt; like 3D presentations fast iterations become a necessity.<br>&gt; <br>&gt; There is no reason why collection-based iteration can’t be as fast as a classical C for loop. The compiler should be able to optimise all the overhead away. , even unroll shorter loops. Maybe it doesn’t do it yet. I’d rather see resources invested into improving the compiler to inline/unroll code better where appropriate rather then introducing additional syntax to support a marginal use case. <br>&gt; <br>&gt; — Taras<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>For-loop revisited</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>March  9, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi Goffredo,<br>sorry, I don’t understand you msg very well,<br>i now assume you state that compilers cannot be improved beyond practical limits?<br>TedvG<br>&gt; On 09.03.2016, at 14:25, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Sometimes programmers directives and runtime knowledge are essential though and the compilers should be optimised but not held to a practically impossible standards. Beside not letting their best people having the best manufacturing process (as well as a nice dose of politics), there is a reason why architectures like IA-64 (which still intrigue me :)) had competitive problems against archs which trusted runtime decisions a lot more.<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 9 Mar 2016, at 12:21, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 09 Mar 2016, at 00:01, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, in the real world, especially when working with technical <br>&gt;&gt;&gt; and scientific data and for instance in time critical applications <br>&gt;&gt;&gt; like 3D presentations fast iterations become a necessity.<br>&gt;&gt; <br>&gt;&gt; There is no reason why collection-based iteration can’t be as fast as a classical C for loop. The compiler should be able to optimise all the overhead away. , even unroll shorter loops. Maybe it doesn’t do it yet. I’d rather see resources invested into improving the compiler to inline/unroll code better where appropriate rather then introducing additional syntax to support a marginal use case. <br>&gt;&gt; <br>&gt;&gt; — Taras<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>For-loop revisited</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>March  9, 2016 at 03:00:00pm</p></header><div class="content"><p>No, just that there may be things puny humans might do in terms of compiler hints that the compiler may have no knowledge of. Less and less of them perhaps.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 9 Mar 2016, at 14:00, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi Goffredo,<br>&gt; sorry, I don’t understand you msg very well,<br>&gt; i now assume you state that compilers cannot be improved beyond practical limits?<br>&gt; TedvG<br>&gt;&gt; On 09.03.2016, at 14:25, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sometimes programmers directives and runtime knowledge are essential though and the compilers should be optimised but not held to a practically impossible standards. Beside not letting their best people having the best manufacturing process (as well as a nice dose of politics), there is a reason why architectures like IA-64 (which still intrigue me :)) had competitive problems against archs which trusted runtime decisions a lot more.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 9 Mar 2016, at 12:21, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 09 Mar 2016, at 00:01, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, in the real world, especially when working with technical <br>&gt;&gt;&gt;&gt; and scientific data and for instance in time critical applications <br>&gt;&gt;&gt;&gt; like 3D presentations fast iterations become a necessity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is no reason why collection-based iteration can’t be as fast as a classical C for loop. The compiler should be able to optimise all the overhead away. , even unroll shorter loops. Maybe it doesn’t do it yet. I’d rather see resources invested into improving the compiler to inline/unroll code better where appropriate rather then introducing additional syntax to support a marginal use case. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; — Taras<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>For-loop revisited</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>March  9, 2016 at 02:00:00pm</p></header><div class="content"><p>Hello Taras<br>If I am not mistaken, the compiler cannot optimize: <br></p><p>   for element in collection {}<br></p><p>simply because the contents of the collection are<br>unknown at compile time.<br></p><p>However, it might be able to do so in this cases where<br>the contents of the collection are known at compile time, e.g. : <br></p><p>  1.   for str in [“ape”,”tiger”,”dolphin”,”salmon”] {}<br></p><p>  2.   for n in [1, 12, 34, 65, 78, 3]  {}<br></p><p>or perhaps also for collections declared with ‘let’:<br></p><p>  3.   let words = [“this”,”collection”,”does”,”not”,”change”]<br>        for str in words {} <br></p><p>and also when the compiler can determine the sequence<br> optimize collection usage completely out of the way e.g.: <br>  <br>  4.   for v in stride(from: v1 to v2 by vstep)<br></p><p>like it can do also with:<br> <br>  5.   for i in v1…v2    // etc.<br></p><p>Ergo: In cases where the contents of a collection is unknown at compile<br>time the compiler always needs to include instructions to traverse<br>through a collection. As in my example test, this consumes twice<br>as much time as a plain loop without a collection.<br></p><p>Even when optimized by a smart compiler, or even<br>hand-coded. I’d estimate that the difference at run time <br>wil be also be something  in the order of 2:1, may even 3:1 <br>because the compiled for..in.. it needs the collection processing <br>instructions in all cases where collection contents cannot be<br>determined at compile time.<br></p><p><br>I have sugessted these for variants like so:<br></p><p>   for  x from xmin to xmax by xstep  { }<br></p><p>   for x from xmax to xmin by -xstep  { } <br> <br>because:<br> - no collections are involved/processed in these cases in the first place,<br>   <br>- the compiler can optimize it very easily. <br>   in fact that logic is (still) already present in the<br>   Swift compiler to compile all for ;; variants.<br></p><p>- Semantic: to have a clear distinction that one is not working with collections here.<br></p><p>Certainly not the least:<br></p><p>- For the sake of clearness and readability.<br></p><p><br>Marginal use of for ;; or a new Swift equivalent of it?  <br></p><p>What makes you think so? <br></p><p>That is definitely not the case!. Please read a lot of source code<br>in Fortran, C# Delphi, PL/1 C, C++ , Pascal etc. sources<br>for scientific and technical programming and then try<br>to imagine how you would rewrite these in Swift with<br>for ;; removed?  <br>Currently there is no proper equivalence.<br></p><p>I am a bit worried that there is a tendency to remove<br>statement elements for Swift, as one cannot be sure<br>if these are useful or not for specific interest groups.<br></p><p>Swift is (and hopefully remains to be) a general purpose<br>language, Also, so not especially OOP or FP, both<br>inclinations should be first-class citizens. <br></p><p>TedvG<br></p><p><br>&gt; On 09.03.2016, at 13:21, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 09 Mar 2016, at 00:01, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; However, in the real world, especially when working with technical <br>&gt;&gt; and scientific data and for instance in time critical applications <br>&gt;&gt; like 3D presentations fast iterations become a necessity.<br>&gt; <br>&gt; There is no reason why collection-based iteration can’t be as fast as a classical C for loop. The compiler should be able to optimise all the overhead away. , even unroll shorter loops. Maybe it doesn’t do it yet. I’d rather see resources invested into improving the compiler to inline/unroll code better where appropriate rather then introducing additional syntax to support a marginal use case. <br>&gt; <br>&gt; — Taras<br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>For-loop revisited</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>March  9, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 09 Mar 2016, at 14:52, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hello Taras<br>&gt; If I am not mistaken, the compiler cannot optimize: <br>&gt; <br>&gt;   for element in collection {}<br>&gt; <br>&gt; simply because the contents of the collection are<br>&gt; unknown at compile time.<br></p><p><br>The progression <br></p><p>  for(int i=0; i&lt;=n; i++) {...}<br></p><p>is also unknown at compile time. Compiler needs to generate a series of instructions that increment a loop counter and check whether the exit condition has been reached.<br></p><p>Now, in case of a higher abstraction such as<br></p><p>  for i in stride(0, n, by=1) {...}<br></p><p>there is indeed more code being generated, but the structure of the loop is exactly the same. Specifically, the above loop can essentially be rewritten in C as<br></p><p> for(int i = get_initial_value(), !should_exit_on_counter(i), i = next_value(i)) {...}<br></p><p>There is a piece of code that increments a loop counter and a piece of code that checks the exit condition. In an unoptimised build, the overhead is indeed significant because of all the extra function calls. However, an optimising compiler can easily<br></p><p>a)  detect that the iterator does not escape the loop (and therefore eliminate refcounting for it)<br>b)  inline the methods that implement loop increment and exit condition check<br>c)  infer (e.g. via SSA form transformations) that i and the internal counter used by the iterator variable are always identical and eliminate any unnecessary assignments<br></p><p>All of these optimisations are fairly trivial and have existed for quite some time in modern compilers. At this point the code of the abstract collection-driven loop becomes identical to an optimised for loop. Furthermore, the compiler can use additional heuristics to unroll or otherwise optimise the loop (such as moving the loop counter to a register). <br></p><p>&gt; On 09 Mar 2016, at 14:25, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Sometimes programmers directives and runtime knowledge are essential though and the compilers should be optimised but not held to a practically impossible standards.<br></p><p><br>I do not think that expecting the compiler to optimise away a simple iterator is a practically impossible standard. There are compilers out there that perform much more impressive feats (such as autovectorisation). In fact, I am quite sure that GCC and clang will optimise away the for loop that uses simple functions for  exit condition/increment. <br></p><p>I certainly agree with you that a compiler can’t do everything — but thats what the while loop is for. <br></p><p>&gt; On 09 Mar 2016, at 16:11, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; And yet, developers spend the vast majority of their time running and validating code in non-optimized builds. <br></p><p>This is a good point! But I believe that this can be alleviated somehow by performing partial optimisations on loops even in the debug mode (e.g. refcounting elimination, inlining)<br></p><p>— Taras<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>For-loop revisited</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>March  9, 2016 at 05:00:00pm</p></header><div class="content"><p>BTW, I got curious about this so I actually tested it out. I have written a very rudimentary C program (attached) that implements the same simple loop in three styles:<br></p><p>1. A classical for(int i … ) loop<br>2. A loop using functions for controlling the counter<br>3. A object-oriented iterator protocol (this is essentially what Swift would compile to)<br></p><p>To make sure that the compiler would not optimise the loop away, it produces side effects (console output). <br></p><p>In release mode, I can&#39;t see any substantial difference in the output produced by the compiler. Its not identical, but the actual loop looks very efficient, everything is inlined and all iterator fields are eliminated (they are pushed to registers). So the optimisations in LLVM are there already. If Swift doesn’t do it yet, then its probably the case of few missing heuristics. <br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: main.c<br>Type: application/octet-stream<br>Size: 1137 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/f4d69a5f/attachment.obj&gt;<br>-------------- next part --------------<br></p><p><br></p><p>&gt; On 09 Mar 2016, at 16:45, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 09 Mar 2016, at 14:52, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Taras<br>&gt;&gt; If I am not mistaken, the compiler cannot optimize: <br>&gt;&gt; <br>&gt;&gt;  for element in collection {}<br>&gt;&gt; <br>&gt;&gt; simply because the contents of the collection are<br>&gt;&gt; unknown at compile time.<br>&gt; <br>&gt; <br>&gt; The progression <br>&gt; <br>&gt;  for(int i=0; i&lt;=n; i++) {...}<br>&gt; <br>&gt; is also unknown at compile time. Compiler needs to generate a series of instructions that increment a loop counter and check whether the exit condition has been reached.<br>&gt; <br>&gt; Now, in case of a higher abstraction such as<br>&gt; <br>&gt;  for i in stride(0, n, by=1) {...}<br>&gt; <br>&gt; there is indeed more code being generated, but the structure of the loop is exactly the same. Specifically, the above loop can essentially be rewritten in C as<br>&gt; <br>&gt; for(int i = get_initial_value(), !should_exit_on_counter(i), i = next_value(i)) {...}<br>&gt; <br>&gt; There is a piece of code that increments a loop counter and a piece of code that checks the exit condition. In an unoptimised build, the overhead is indeed significant because of all the extra function calls. However, an optimising compiler can easily<br>&gt; <br>&gt; a)  detect that the iterator does not escape the loop (and therefore eliminate refcounting for it)<br>&gt; b)  inline the methods that implement loop increment and exit condition check<br>&gt; c)  infer (e.g. via SSA form transformations) that i and the internal counter used by the iterator variable are always identical and eliminate any unnecessary assignments<br>&gt; <br>&gt; All of these optimisations are fairly trivial and have existed for quite some time in modern compilers. At this point the code of the abstract collection-driven loop becomes identical to an optimised for loop. Furthermore, the compiler can use additional heuristics to unroll or otherwise optimise the loop (such as moving the loop counter to a register). <br>&gt; <br>&gt;&gt; On 09 Mar 2016, at 14:25, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sometimes programmers directives and runtime knowledge are essential though and the compilers should be optimised but not held to a practically impossible standards.<br>&gt; <br>&gt; <br>&gt; I do not think that expecting the compiler to optimise away a simple iterator is a practically impossible standard. There are compilers out there that perform much more impressive feats (such as autovectorisation). In fact, I am quite sure that GCC and clang will optimise away the for loop that uses simple functions for  exit condition/increment. <br>&gt; <br>&gt; I certainly agree with you that a compiler can’t do everything — but thats what the while loop is for. <br>&gt; <br>&gt;&gt; On 09 Mar 2016, at 16:11, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; And yet, developers spend the vast majority of their time running and validating code in non-optimized builds. <br>&gt; <br>&gt; This is a good point! But I believe that this can be alleviated somehow by performing partial optimisations on loops even in the debug mode (e.g. refcounting elimination, inlining)<br>&gt; <br>&gt; — Taras<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>For-loop revisited</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>March  9, 2016 at 11:00:00am</p></header><div class="content"><p>My concern has never really been with optimized builds of Swift; I think it will get there or fairly close to C++ perf. My concern has always been about non-optimized builds (as that is where I spend 90% of my dev time) and the ability to break out of the abstractions when necessary if extremely important. The corollary for this is the ability to reason about the performance of your code.<br></p><p>Here&#39;s a basic test project that I have: https://github.com/owensd/swift-perf. If anyone spots anything I&#39;m doing wrong, let me know! Hopefully it&#39;s fixes perf to make it usable for me again!<br></p><p>Report for Swift 2.1.1<br></p><p>Language: Swift, Optimization: -Onone, Samples = 10, Iterations = 30      ┃ Avg (ms) ┃ Min (ms) ┃ Max (ms) ┃ StdDev ┃<br>━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━┩<br>RenderGradient ([Pixel])                                                  │ 2832.123 │ 2782.729 │ 2935.282 │ 51.660 │<br>RenderGradient ([UInt32])                                                 │ 356.4907 │ 349.7944 │ 364.8663 │ 4.7476 │<br>RenderGradient (UnsafeMutablePointer)                                     │ 156.4229 │ 151.4939 │ 164.6879 │ 3.9761 │<br>RenderGradient (UnsafeMutablePointer&lt;UInt32&gt;)                             │ 182.3293 │ 179.6009 │ 188.4805 │ 3.3929 │<br>RenderGradient ([Pixel].withUnsafeMutablePointer)                         │ 365.9573 │ 359.1546 │ 371.4564 │ 4.0989 │<br>RenderGradient ([UInt32].withUnsafeMutablePointer)                        │ 377.3043 │ 365.1158 │ 394.5101 │ 7.8776 │<br>RenderGradient ([UInt32].withUnsafeMutablePointer (SIMD))                 │ 305.3486 │ 298.6232 │ 317.0662 │ 6.6205 │<br>RenderGradient ([Pixel].withUnsafeMutablePointer (SIMD))                  │ 407.7086 │ 399.4519 │ 419.2850 │ 6.4855 │<br>──────────────────────────────────────────────────────────────────────────┴──────────┴──────────┴──────────┴────────┘<br></p><p>Language: Swift, Optimization: -O, Samples = 10, Iterations = 30          ┃ Avg (ms) ┃ Min (ms) ┃ Max (ms) ┃ StdDev ┃<br>━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━┩<br>RenderGradient ([Pixel])                                                  │ 19.71537 │ 18.93118 │ 22.85709 │ 1.2512 │<br>RenderGradient ([UInt32])                                                 │ 17.40496 │ 17.10440 │ 17.81726 │ 0.2768 │<br>RenderGradient (UnsafeMutablePointer)                                     │ 20.00288 │ 18.99458 │ 21.66878 │  0.965 │<br>RenderGradient (UnsafeMutablePointer&lt;UInt32&gt;)                             │ 17.96327 │ 17.05896 │ 22.94012 │ 1.7797 │<br>RenderGradient ([Pixel].withUnsafeMutablePointer)                         │ 22.62061 │ 21.44827 │ 26.07391 │ 1.6991 │<br>RenderGradient ([UInt32].withUnsafeMutablePointer)                        │ 19.25109 │ 17.25802 │ 21.41414 │ 1.5964 │<br>RenderGradient ([UInt32].withUnsafeMutablePointer (SIMD))                 │ 14.69814 │ 13.91954 │ 17.96169 │ 1.2282 │<br>RenderGradient ([Pixel].withUnsafeMutablePointer (SIMD))                  │ 24.28080 │  23.1602 │ 27.49104 │ 1.6667 │<br>──────────────────────────────────────────────────────────────────────────┴──────────┴──────────┴──────────┴────────┘<br></p><p>Report for Swift 3.0-March snapshot<br></p><p>Language: Swift, Optimization: -Onone, Samples = 10, Iterations = 30      ┃ Avg (ms) ┃ Min (ms) ┃ Max (ms) ┃ StdDev ┃<br>━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━┩<br>RenderGradient ([Pixel])                                                  │ 3220.543 │ 2898.071 │ 3775.192 │ 325.96 │<br>RenderGradient ([UInt32])                                                 │ 363.5971 │ 357.4558 │ 377.5159 │ 6.4495 │<br>RenderGradient (UnsafeMutablePointer)                                     │ 155.5633 │ 150.4397 │ 166.5735 │ 5.3346 │<br>RenderGradient (UnsafeMutablePointer&lt;UInt32&gt;)                             │ 182.1435 │ 178.1345 │ 194.9554 │ 5.1296 │<br>RenderGradient ([Pixel].withUnsafeMutablePointer)                         │ 340.1474 │ 332.2264 │ 358.1106 │ 7.4227 │<br>RenderGradient ([UInt32].withUnsafeMutablePointer)                        │ 347.6466 │ 341.8327 │ 355.2599 │ 4.1142 │<br>RenderGradient ([UInt32].withUnsafeMutablePointer (SIMD))                 │ 297.6354 │ 289.0012 │ 310.2637 │ 7.3171 │<br>RenderGradient ([Pixel].withUnsafeMutablePointer (SIMD))                  │ 379.2153 │ 374.3724 │ 387.1544 │ 4.6838 │<br>──────────────────────────────────────────────────────────────────────────┴──────────┴──────────┴──────────┴────────┘<br></p><p>Language: Swift, Optimization: -O, Samples = 10, Iterations = 30          ┃ Avg (ms) ┃ Min (ms) ┃ Max (ms) ┃ StdDev ┃<br>━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━┩<br>RenderGradient ([Pixel])                                                  │ 22.51406 │ 21.26175 │ 27.60297 │ 2.1561 │<br>RenderGradient ([UInt32])                                                 │ 18.39304 │ 17.11022 │ 24.14741 │ 2.2164 │<br>RenderGradient (UnsafeMutablePointer)                                     │ 20.67769 │ 19.03668 │ 23.70964 │ 1.8423 │<br>RenderGradient (UnsafeMutablePointer&lt;UInt32&gt;)                             │ 15.29333 │ 13.90142 │ 19.20010 │ 1.6236 │<br>RenderGradient ([Pixel].withUnsafeMutablePointer)                         │ 22.51703 │ 21.28654 │ 27.03154 │ 1.9406 │<br>RenderGradient ([UInt32].withUnsafeMutablePointer)                        │ 19.27868 │ 17.20521 │ 22.53724 │  2.066 │<br>RenderGradient ([UInt32].withUnsafeMutablePointer (SIMD))                 │ 15.63351 │ 13.18523 │ 19.79255 │ 2.0291 │<br>RenderGradient ([Pixel].withUnsafeMutablePointer (SIMD))                  │ 24.48129 │ 23.05487 │ 28.77946 │ 2.0785 │<br>──────────────────────────────────────────────────────────────────────────┴──────────┴──────────┴──────────┴────────┘<br></p><p>Report for Swift 3.0-March snapshot (with changes, like for-loop and ++ removal)<br></p><p>Language: Swift, Optimization: -Onone, Samples = 10, Iterations = 30      ┃ Avg (ms) ┃ Min (ms) ┃ Max (ms) ┃ StdDev ┃<br>━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━┩<br>RenderGradient ([Pixel])                                                  │ 2992.632 │ 2947.714 │ 3041.948 │ 23.913 │<br>RenderGradient ([UInt32])                                                 │ 389.1035 │ 380.1675 │ 404.4974 │ 7.0670 │<br>RenderGradient (UnsafeMutablePointer)                                     │ 200.0568 │ 191.7541 │ 209.4043 │ 5.2761 │<br>RenderGradient (UnsafeMutablePointer&lt;UInt32&gt;)                             │ 212.9935 │ 207.6584 │ 222.6322 │ 4.9337 │<br>RenderGradient ([Pixel].withUnsafeMutablePointer)                         │ 366.9555 │ 360.9891 │ 374.4666 │  4.533 │<br>RenderGradient ([UInt32].withUnsafeMutablePointer)                        │ 367.9753 │ 359.5587 │ 378.8135 │ 7.0686 │<br>RenderGradient ([UInt32].withUnsafeMutablePointer (SIMD))                 │ 512.4176 │ 502.9525 │ 522.4241 │ 5.2631 │<br>RenderGradient ([Pixel].withUnsafeMutablePointer (SIMD))                  │ 601.9091 │ 591.0957 │ 609.4677 │ 5.8693 │<br>──────────────────────────────────────────────────────────────────────────┴──────────┴──────────┴──────────┴────────┘<br></p><p>Language: Swift, Optimization: -O, Samples = 10, Iterations = 30          ┃ Avg (ms) ┃ Min (ms) ┃ Max (ms) ┃ StdDev ┃<br>━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━┩<br>RenderGradient ([Pixel])                                                  │ 19.84214 │ 18.86398 │ 22.93223 │ 1.4087 │<br>RenderGradient ([UInt32])                                                 │ 18.58096 │ 17.13248 │ 21.16593 │ 1.7183 │<br>RenderGradient (UnsafeMutablePointer)                                     │ 19.66112 │ 18.87033 │ 22.60767 │ 1.0966 │<br>RenderGradient (UnsafeMutablePointer&lt;UInt32&gt;)                             │ 15.05691 │ 13.91324 │ 17.63912 │ 1.3198 │<br>RenderGradient ([Pixel].withUnsafeMutablePointer)                         │ 20.23184 │ 18.80135 │ 22.65893 │ 1.5356 │<br>RenderGradient ([UInt32].withUnsafeMutablePointer)                        │ 15.52520 │ 14.72497 │ 19.22203 │ 1.3226 │<br>RenderGradient ([UInt32].withUnsafeMutablePointer (SIMD))                 │ 12.40027 │ 11.74772 │ 15.66219 │  1.209 │<br>RenderGradient ([Pixel].withUnsafeMutablePointer (SIMD))                  │ 24.01914 │ 23.19182 │ 27.04742 │ 1.2454 │<br>──────────────────────────────────────────────────────────────────────────┴──────────┴──────────┴──────────┴────────┘<br></p><p>As you can see, some of these changes do have an impact on performance for the way in which I run code the vast majority of the time. Yes, the optimized performance equivalent, but as a day-to-day language trying to write real-time apps in Swift, there is a lot to be desired on the non-optimized performance of the language. <br></p><p>Here&#39;s the diff of the API changes; I&#39;m not sure there&#39;s a huge readability win (and hopefully I didn&#39;t introduce an error in the conversion!): https://github.com/owensd/swift-perf/pull/2/files<br></p><p>A note about the performance tests: these are a stripped down subset from a rendering path that I was using while developing a game that I&#39;m working on. They represent real problems that I have, and they are not simply arbitrary benchmarks.<br></p><p>As a comparison, here&#39;s what the C performance looks like in non-optimized and optimized builds:<br></p><p>Language: C, Optimization: -O0, Samples = 10, Iterations = 30             ┃ Avg (ms) ┃ Min (ms) ┃ Max (ms) ┃ StdDev ┃<br>━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━┩<br>RenderGradient (Pointer Math)                                             │   38.567 │   36.426 │   41.702 │  1.686 │<br>RenderGradient (SIMD)                                                     │   79.431 │   73.697 │   86.309 │  3.997 │<br>──────────────────────────────────────────────────────────────────────────┴──────────┴──────────┴──────────┴────────┘<br></p><p>Language: C, Optimization: -Os, Samples = 10, Iterations = 30             ┃ Avg (ms) ┃ Min (ms) ┃ Max (ms) ┃ StdDev ┃<br>━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━┩<br>RenderGradient (Pointer Math)                                             │    9.582 │    8.688 │   13.167 │  1.468 │<br>RenderGradient (SIMD)                                                     │    4.608 │    3.640 │    8.792 │  1.568 │<br>──────────────────────────────────────────────────────────────────────────┴──────────┴──────────┴──────────┴────────┘<br></p><p>Language: C, Optimization: -Ofast, Samples = 10, Iterations = 30          ┃ Avg (ms) ┃ Min (ms) ┃ Max (ms) ┃ StdDev ┃<br>━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━┩<br>RenderGradient (Pointer Math)                                             │    3.247 │    2.865 │    4.676 │  0.594 │<br>RenderGradient (SIMD)                                                     │    4.489 │    3.655 │    8.266 │  1.442 │<br>──────────────────────────────────────────────────────────────────────────┴──────────┴──────────┴──────────┴────────┘<br></p><p>In the best case, Swift&#39;s debug performance is still over 4x slower, though that path doesn&#39;t lead to the best optimized times.<br></p><p>-David<br></p><p><br>&gt; On Mar 9, 2016, at 8:37 AM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; BTW, I got curious about this so I actually tested it out. I have written a very rudimentary C program (attached) that implements the same simple loop in three styles:<br>&gt; <br>&gt; 1. A classical for(int i … ) loop<br>&gt; 2. A loop using functions for controlling the counter<br>&gt; 3. A object-oriented iterator protocol (this is essentially what Swift would compile to)<br>&gt; <br>&gt; To make sure that the compiler would not optimise the loop away, it produces side effects (console output). <br>&gt; <br>&gt; In release mode, I can&#39;t see any substantial difference in the output produced by the compiler. Its not identical, but the actual loop looks very efficient, everything is inlined and all iterator fields are eliminated (they are pushed to registers). So the optimisations in LLVM are there already. If Swift doesn’t do it yet, then its probably the case of few missing heuristics. <br>&gt; <br>&gt; &lt;main.c&gt;<br>&gt; <br>&gt; <br>&gt;&gt; On 09 Mar 2016, at 16:45, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 09 Mar 2016, at 14:52, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Taras<br>&gt;&gt;&gt; If I am not mistaken, the compiler cannot optimize: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for element in collection {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; simply because the contents of the collection are<br>&gt;&gt;&gt; unknown at compile time.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The progression <br>&gt;&gt; <br>&gt;&gt; for(int i=0; i&lt;=n; i++) {...}<br>&gt;&gt; <br>&gt;&gt; is also unknown at compile time. Compiler needs to generate a series of instructions that increment a loop counter and check whether the exit condition has been reached.<br>&gt;&gt; <br>&gt;&gt; Now, in case of a higher abstraction such as<br>&gt;&gt; <br>&gt;&gt; for i in stride(0, n, by=1) {...}<br>&gt;&gt; <br>&gt;&gt; there is indeed more code being generated, but the structure of the loop is exactly the same. Specifically, the above loop can essentially be rewritten in C as<br>&gt;&gt; <br>&gt;&gt; for(int i = get_initial_value(), !should_exit_on_counter(i), i = next_value(i)) {...}<br>&gt;&gt; <br>&gt;&gt; There is a piece of code that increments a loop counter and a piece of code that checks the exit condition. In an unoptimised build, the overhead is indeed significant because of all the extra function calls. However, an optimising compiler can easily<br>&gt;&gt; <br>&gt;&gt; a)  detect that the iterator does not escape the loop (and therefore eliminate refcounting for it)<br>&gt;&gt; b)  inline the methods that implement loop increment and exit condition check<br>&gt;&gt; c)  infer (e.g. via SSA form transformations) that i and the internal counter used by the iterator variable are always identical and eliminate any unnecessary assignments<br>&gt;&gt; <br>&gt;&gt; All of these optimisations are fairly trivial and have existed for quite some time in modern compilers. At this point the code of the abstract collection-driven loop becomes identical to an optimised for loop. Furthermore, the compiler can use additional heuristics to unroll or otherwise optimise the loop (such as moving the loop counter to a register). <br>&gt;&gt; <br>&gt;&gt;&gt; On 09 Mar 2016, at 14:25, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sometimes programmers directives and runtime knowledge are essential though and the compilers should be optimised but not held to a practically impossible standards.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I do not think that expecting the compiler to optimise away a simple iterator is a practically impossible standard. There are compilers out there that perform much more impressive feats (such as autovectorisation). In fact, I am quite sure that GCC and clang will optimise away the for loop that uses simple functions for  exit condition/increment. <br>&gt;&gt; <br>&gt;&gt; I certainly agree with you that a compiler can’t do everything — but thats what the while loop is for. <br>&gt;&gt; <br>&gt;&gt;&gt; On 09 Mar 2016, at 16:11, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And yet, developers spend the vast majority of their time running and validating code in non-optimized builds. <br>&gt;&gt; <br>&gt;&gt; This is a good point! But I believe that this can be alleviated somehow by performing partial optimisations on loops even in the debug mode (e.g. refcounting elimination, inlining)<br>&gt;&gt; <br>&gt;&gt; — Taras<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/bfd0c4f8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>For-loop revisited</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>March  9, 2016 at 07:00:00am</p></header><div class="content"><p>And yet, developers spend the vast majority of their time running and validating code in non-optimized builds. <br></p><p>I&#39;d also refer you to the many, many talks about so called zero-cost abstractions in C++ causing significant overhead in real-time apps/games. I&#39;m still amazed that Swift&#39;s only out here is to write a while loop here. <br></p><p>Sent from my iPhone<br></p><p>&gt; On Mar 9, 2016, at 4:21 AM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 09 Mar 2016, at 00:01, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; However, in the real world, especially when working with technical <br>&gt;&gt; and scientific data and for instance in time critical applications <br>&gt;&gt; like 3D presentations fast iterations become a necessity.<br>&gt; <br>&gt; There is no reason why collection-based iteration can’t be as fast as a classical C for loop. The compiler should be able to optimise all the overhead away. , even unroll shorter loops. Maybe it doesn’t do it yet. I’d rather see resources invested into improving the compiler to inline/unroll code better where appropriate rather then introducing additional syntax to support a marginal use case. <br>&gt; <br>&gt; — Taras<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Striding Through Lands of Iteration</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>March  4, 2016 at 01:00:00pm</p></header><div class="content"><p>Goedemorgen David, Chris &amp; Other respected,<br></p><p>      for v from v1 to v2 by v3 { }<br></p><p>Yes, i do see this for variant as an *additional* alternative to ranges/strides.<br></p><p>Regarding performance, I was under the false impression that for a stride<br>a complete collection was generated, but luckily this is not the case, as for each<br>next() a new value is calculated, not a collection element is returned<br></p><p>In the mean time I’ve made a new Strider variant, as described in detail<br>with source code in another post I’ve submitted yesterday:<br></p><p>for v in Strider( from: v1, to: v2, by: v3, tolerance: vtol) { Aragorn(v) }<br></p><p>which is also implemented (as the other stride(s) as a Double extension function.<br>Also able to move backwards. <br></p><p>In essence, I can live with using a strider construct, because it can do everything<br>the classical ‘for ; ;’  loop does.  <br>(although the classical for-loop is way much more efficient)  <br></p><p>And also working with pseudo-collections as Strides are has advantages as well<br></p><p>(still: <br>Laying under my car and trying with one hand to find<br>my for-screwdriver. &quot;Sh..! Hey! Who took my really handy wrench <br>out of my shiny new Swift toolbox !?! Because he/she thought<br>wrongly I didn’t need it anymore? And also without offering a better alternative?” )<br> <br> <br>I still think its an important Swift improvement to also have:<br></p><p>      for v from v1 to v2 by v3 { }<br></p><p>and perhaps add for real numbers, this tolerance parameter like so:<br></p><p>      for v from v1 to v2 by v3 tolerance vtol { }’<br></p><p><br>Not only because it is easier to think and write,<br>especially for those new to Swift,<br></p><p>@Chris:   !<br>but also because the Swift compiler can really boil this<br>down to a very efficient loop structure wit nearly no calls involved.<br>instead of having to get values from a generator all the time.<br></p><p>I’d estimate this would at least save about 10 calls or so,<br>but I am not sure of that, as I have no experience<br>with working on compilers, parsers and the like.<br></p><p>I assume that our compiler is not intelligent enough to<br>optimize this strider logic away, because it simply cannot know<br>in advance what values to expect from the strider sequence.<br></p><p>I do also still think the compiler should treat tolerance requests<br>for the same reason of a significant performance improvement.<br>(As in a previous thread I’ll pick up again) <br></p><p>About reserved words:  (will also post this separate) <br>In short:<br>                 -=  there should be none =-<br>A compiler should have enough intelligence to determine<br>from the statement’s context if a word is used as a keyword<br>or not.   Like e.g. in PL/1 as I posted here before. <br>  ----<br>Lunch break  Going to get some coffee to get over<br>what I saw on BBC/CNN TV… <br>Some things are really hard to believe.<br>So, to my dear American colleagues and friends:<br>for _ in 1..100; { print(“Please! “} <br>don’t vote for someone like that.<br>It is already bad enough that he came that far.<br>https://www.youtube.com/watch?v=FK3TIYG9mqM<br>  ----<br></p><p>kind regards / met vriendelijke groeten<br>TedvG<br></p><p><br>&gt; On 26.02.2016, at 21:52, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 26, 2016, at 9:07 AM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Does .stride(), which in the end uses a descendant of SequenceType, just calculate a new value each time   for..in..   uses .next() on this collection? <br>&gt; <br>&gt; this.<br>&gt; <br>&gt;&gt;    for  x from xmin to xmax by xstep  { }<br>&gt;&gt; <br>&gt;&gt;    for x from xmax to xmin by -xstep  { } <br>&gt;&gt; <br>&gt;&gt;    for apple from 1 to applesInTruck  { }<br>&gt;&gt; <br>&gt;&gt; No need for collections in these cases,<br>&gt; <br>&gt; As the thread for removal of C-style for showed in benchmarks, using a range or stride does not have a performance impact under optimization. Such new syntax would need to stand on its own as a second alternative to using ranges/strides. <br>&gt; <br>&gt; Considering that it would require reserving three new keywords (‘from’, ‘to’, and ‘by’) this will be a hard argument to make.<br>&gt; <br>&gt; -DW<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/f90b7bf4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
