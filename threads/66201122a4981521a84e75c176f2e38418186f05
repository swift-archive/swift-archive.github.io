<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/92adc26e3003cac88ca299a08d35b2b3?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Jo√£o Pinheiro</string> &lt;joao at joaopinheiro.org&gt;<p>June 20, 2016 at 06:00:00pm</p></header><div class="content"><p>Recently there has been a screenshot going around Twitter about C++ allowing zero-width spaces in variable names. Swift also suffers from this problem which can be abused to create ambiguous, misleading, and potentially obfuscate nefarious code.<br></p><p>I would like to propose a change to prohibit the use of invisible characters in identifier names.<br></p><p>I&#39;m including an example of problematic code at the bottom of this email.<br></p><p>Sincerely,<br>Jo√£o Pinheiro<br></p><p><br>/* The output for this code is:<br> A<br> B<br> C<br> 1<br> 2<br> 3<br> */<br></p><p>func test() { print(&quot;A&quot;) }<br>func t‚Äãest() { print(&quot;B&quot;) }<br>func te‚Äãst() { print(&quot;C&quot;) }<br></p><p>let abc = 1<br>let a‚Äãbc = 2<br>let ab‚Äãc = 3<br></p><p>test()<br>t‚Äãest()<br>te‚Äãst()<br></p><p>print(abc)<br>print(a‚Äãbc)<br>print(ab‚Äãc)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 20, 2016 at 01:00:00pm</p></header><div class="content"><p>+1<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jun 20, 2016, at 12:51 PM, Jo√£o Pinheiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Recently there has been a screenshot going around Twitter about C++ allowing zero-width spaces in variable names. Swift also suffers from this problem which can be abused to create ambiguous, misleading, and potentially obfuscate nefarious code.<br>&gt; <br>&gt; I would like to propose a change to prohibit the use of invisible characters in identifier names.<br>&gt; <br>&gt; I&#39;m including an example of problematic code at the bottom of this email.<br>&gt; <br>&gt; Sincerely,<br>&gt; Jo√£o Pinheiro<br>&gt; <br>&gt; <br>&gt; /* The output for this code is:<br>&gt; A<br>&gt; B<br>&gt; C<br>&gt; 1<br>&gt; 2<br>&gt; 3<br>&gt; */<br>&gt; <br>&gt; func test() { print(&quot;A&quot;) }<br>&gt; func t‚Äãest() { print(&quot;B&quot;) }<br>&gt; func te‚Äãst() { print(&quot;C&quot;) }<br>&gt; <br>&gt; let abc = 1<br>&gt; let a‚Äãbc = 2<br>&gt; let ab‚Äãc = 3<br>&gt; <br>&gt; test()<br>&gt; t‚Äãest()<br>&gt; te‚Äãst()<br>&gt; <br>&gt; print(abc)<br>&gt; print(a‚Äãbc)<br>&gt; print(ab‚Äãc)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 20, 2016 at 09:00:00pm</p></header><div class="content"><p>Very interesting.<br></p><p>Btw, IBM Swift Sandbox shows these spaces:<br>https://swiftlang.ng.bluemix.net/<br>But my mail client does not - i.e. I saw exactly the same &quot;test&quot;&amp;&quot;abc&quot;<br></p><p>Also, I read about some issues with left-to-right and right-to-left markers <br>that also somehow change the actual text of source - i.e. you see one text, <br>but when it compiles - it works not as expected. I.e. viewer/editor <br>processes these special codes and show you one text, but compiler treats <br>text in another way.<br></p><p>I believe it is a potential security problem that all unicode chars are <br>allowed for variables/func names in Swift. IMO We definitely should limit <br>allowed charset for identifiers in sources.<br></p><p>On 20.06.2016 20:51, Jo√£o Pinheiro via swift-evolution wrote:<br>&gt; Recently there has been a screenshot going around Twitter about C++ allowing zero-width spaces in variable names. Swift also suffers from this problem which can be abused to create ambiguous, misleading, and potentially obfuscate nefarious code.<br>&gt;<br>&gt; I would like to propose a change to prohibit the use of invisible characters in identifier names.<br>&gt;<br>&gt; I&#39;m including an example of problematic code at the bottom of this email.<br>&gt;<br>&gt; Sincerely,<br>&gt; Jo√£o Pinheiro<br>&gt;<br>&gt;<br>&gt; /* The output for this code is:<br>&gt;  A<br>&gt;  B<br>&gt;  C<br>&gt;  1<br>&gt;  2<br>&gt;  3<br>&gt;  */<br>&gt;<br>&gt; func test() { print(&quot;A&quot;) }<br>&gt; func t‚Äãest() { print(&quot;B&quot;) }<br>&gt; func te‚Äãst() { print(&quot;C&quot;) }<br>&gt;<br>&gt; let abc = 1<br>&gt; let a‚Äãbc = 2<br>&gt; let ab‚Äãc = 3<br>&gt;<br>&gt; test()<br>&gt; t‚Äãest()<br>&gt; te‚Äãst()<br>&gt;<br>&gt; print(abc)<br>&gt; print(a‚Äãbc)<br>&gt; print(ab‚Äãc)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/92adc26e3003cac88ca299a08d35b2b3?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Jo√£o Pinheiro</string> &lt;joao at joaopinheiro.org&gt;<p>June 20, 2016 at 08:00:00pm</p></header><div class="content"><p>Nice feature in the IBM Swift Sandbox. Xcode doesn&#39;t display zero-width spaces either so the identifier names look exactly the same.<br></p><p>The issue with left-to-right and right-to-left markers is interesting and has previously been exploited in email phishing attacks.<br></p><p>It would be possible to highlight invisible characters in Xcode as a stopgap measure, but that doesn&#39;t solve the problem for developers using other editors or in other platforms. I think it would be a better idea to sanitise the set of allowed (or prohibited) characters for identifiers at the language level.<br></p><p>Sincerely,<br>Jo√£o Pinheiro<br></p><p><br>&gt; On 20 Jun 2016, at 19:26, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; Very interesting.<br>&gt; <br>&gt; Btw, IBM Swift Sandbox shows these spaces:<br>&gt; https://swiftlang.ng.bluemix.net/<br>&gt; But my mail client does not - i.e. I saw exactly the same &quot;test&quot;&amp;&quot;abc&quot;<br>&gt; <br>&gt; Also, I read about some issues with left-to-right and right-to-left markers that also somehow change the actual text of source - i.e. you see one text, but when it compiles - it works not as expected. I.e. viewer/editor processes these special codes and show you one text, but compiler treats text in another way.<br>&gt; <br>&gt; I believe it is a potential security problem that all unicode chars are allowed for variables/func names in Swift. IMO We definitely should limit allowed charset for identifiers in sources.<br>&gt; <br>&gt; On 20.06.2016 20:51, Jo√£o Pinheiro via swift-evolution wrote:<br>&gt;&gt; Recently there has been a screenshot going around Twitter about C++ allowing zero-width spaces in variable names. Swift also suffers from this problem which can be abused to create ambiguous, misleading, and potentially obfuscate nefarious code.<br>&gt;&gt; <br>&gt;&gt; I would like to propose a change to prohibit the use of invisible characters in identifier names.<br>&gt;&gt; <br>&gt;&gt; I&#39;m including an example of problematic code at the bottom of this email.<br>&gt;&gt; <br>&gt;&gt; Sincerely,<br>&gt;&gt; Jo√£o Pinheiro<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; /* The output for this code is:<br>&gt;&gt; A<br>&gt;&gt; B<br>&gt;&gt; C<br>&gt;&gt; 1<br>&gt;&gt; 2<br>&gt;&gt; 3<br>&gt;&gt; */<br>&gt;&gt; <br>&gt;&gt; func test() { print(&quot;A&quot;) }<br>&gt;&gt; func t‚Äãest() { print(&quot;B&quot;) }<br>&gt;&gt; func te‚Äãst() { print(&quot;C&quot;) }<br>&gt;&gt; <br>&gt;&gt; let abc = 1<br>&gt;&gt; let a‚Äãbc = 2<br>&gt;&gt; let ab‚Äãc = 3<br>&gt;&gt; <br>&gt;&gt; test()<br>&gt;&gt; t‚Äãest()<br>&gt;&gt; te‚Äãst()<br>&gt;&gt; <br>&gt;&gt; print(abc)<br>&gt;&gt; print(a‚Äãbc)<br>&gt;&gt; print(ab‚Äãc)<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 20, 2016 at 02:00:00pm</p></header><div class="content"><p>On Mon, Jun 20, 2016 at 2:17 PM, Jo√£o Pinheiro &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; Nice feature in the IBM Swift Sandbox. Xcode doesn&#39;t display zero-width<br>&gt; spaces either so the identifier names look exactly the same.<br>&gt;<br>&gt; The issue with left-to-right and right-to-left markers is interesting and<br>&gt; has previously been exploited in email phishing attacks.<br>&gt;<br>&gt; It would be possible to highlight invisible characters in Xcode as a<br>&gt; stopgap measure, but that doesn&#39;t solve the problem for developers using<br>&gt; other editors or in other platforms. I think it would be a better idea to<br>&gt; sanitise the set of allowed (or prohibited) characters for identifiers at<br>&gt; the language level.<br>&gt;<br></p><p>This is a potential security problem, but no need try to invent an ad-hoc<br>solution here, particularly one as drastic as prohibiting characters. The<br>same security considerations are applicable elsewhere and there&#39;s a lot of<br>work about Unicode security. See here: http://www.unicode.org/reports/tr39/<br></p><p>Unicode maintains a list of &quot;confusable&quot; characters. See here:<br>http://www.unicode.org/Public/security/latest/confusables.txt<br></p><p>It should be sufficient to regard confusables as the same glyph for the<br>purpose of identifier names; zero-width and invisible marks would then be<br>regarded as non-existent, so that `test` and `t[invisible glyph]est` would<br>refer to the same variable.<br></p><p><br>&gt; Sincerely,<br>&gt; Jo√£o Pinheiro<br>&gt;<br>&gt;<br>&gt; &gt; On 20 Jun 2016, at 19:26, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Very interesting.<br>&gt; &gt;<br>&gt; &gt; Btw, IBM Swift Sandbox shows these spaces:<br>&gt; &gt; https://swiftlang.ng.bluemix.net/<br>&gt; &gt; But my mail client does not - i.e. I saw exactly the same &quot;test&quot;&amp;&quot;abc&quot;<br>&gt; &gt;<br>&gt; &gt; Also, I read about some issues with left-to-right and right-to-left<br>&gt; markers that also somehow change the actual text of source - i.e. you see<br>&gt; one text, but when it compiles - it works not as expected. I.e.<br>&gt; viewer/editor processes these special codes and show you one text, but<br>&gt; compiler treats text in another way.<br>&gt; &gt;<br>&gt; &gt; I believe it is a potential security problem that all unicode chars are<br>&gt; allowed for variables/func names in Swift. IMO We definitely should limit<br>&gt; allowed charset for identifiers in sources.<br>&gt; &gt;<br>&gt; &gt; On 20.06.2016 20:51, Jo√£o Pinheiro via swift-evolution wrote:<br>&gt; &gt;&gt; Recently there has been a screenshot going around Twitter about C++<br>&gt; allowing zero-width spaces in variable names. Swift also suffers from this<br>&gt; problem which can be abused to create ambiguous, misleading, and<br>&gt; potentially obfuscate nefarious code.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I would like to propose a change to prohibit the use of invisible<br>&gt; characters in identifier names.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;m including an example of problematic code at the bottom of this<br>&gt; email.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Sincerely,<br>&gt; &gt;&gt; Jo√£o Pinheiro<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; /* The output for this code is:<br>&gt; &gt;&gt; A<br>&gt; &gt;&gt; B<br>&gt; &gt;&gt; C<br>&gt; &gt;&gt; 1<br>&gt; &gt;&gt; 2<br>&gt; &gt;&gt; 3<br>&gt; &gt;&gt; */<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func test() { print(&quot;A&quot;) }<br>&gt; &gt;&gt; func t‚Äãest() { print(&quot;B&quot;) }<br>&gt; &gt;&gt; func te‚Äãst() { print(&quot;C&quot;) }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; let abc = 1<br>&gt; &gt;&gt; let a‚Äãbc = 2<br>&gt; &gt;&gt; let ab‚Äãc = 3<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; test()<br>&gt; &gt;&gt; t‚Äãest()<br>&gt; &gt;&gt; te‚Äãst()<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; print(abc)<br>&gt; &gt;&gt; print(a‚Äãbc)<br>&gt; &gt;&gt; print(ab‚Äãc)<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/64336558/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/92adc26e3003cac88ca299a08d35b2b3?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Jo√£o Pinheiro</string> &lt;joao at joaopinheiro.org&gt;<p>June 20, 2016 at 08:00:00pm</p></header><div class="content"><p>I agree that treating zero-width spaces as non-existent would be a possible solution, but I think it would make more sense to consider it as white space and thus not admissible in identifier names. I&#39;m not sure of what the best way to handle left-to-right and right-to-left markers would be. Does it make sense to allow mixed text orientation in identifiers?<br></p><p>Removing ambiguity between unicode confusables is a much more complicated issue which implies defining a canonical unicode representation for identifiers and a way to resolve them. It would also make it impractical to use certain valid mathematical symbols as identifiers.<br></p><p>Jo√£o Pinheiro<br></p><p><br>&gt; On 20 Jun 2016, at 20:23, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, Jun 20, 2016 at 2:17 PM, Jo√£o Pinheiro &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Nice feature in the IBM Swift Sandbox. Xcode doesn&#39;t display zero-width spaces either so the identifier names look exactly the same.<br>&gt; <br>&gt; The issue with left-to-right and right-to-left markers is interesting and has previously been exploited in email phishing attacks.<br>&gt; <br>&gt; It would be possible to highlight invisible characters in Xcode as a stopgap measure, but that doesn&#39;t solve the problem for developers using other editors or in other platforms. I think it would be a better idea to sanitise the set of allowed (or prohibited) characters for identifiers at the language level.<br>&gt; <br>&gt; This is a potential security problem, but no need try to invent an ad-hoc solution here, particularly one as drastic as prohibiting characters. The same security considerations are applicable elsewhere and there&#39;s a lot of work about Unicode security. See here: http://www.unicode.org/reports/tr39/ &lt;http://www.unicode.org/reports/tr39/&gt;<br>&gt; <br>&gt; Unicode maintains a list of &quot;confusable&quot; characters. See here: http://www.unicode.org/Public/security/latest/confusables.txt &lt;http://www.unicode.org/Public/security/latest/confusables.txt&gt;<br>&gt; <br>&gt; It should be sufficient to regard confusables as the same glyph for the purpose of identifier names; zero-width and invisible marks would then be regarded as non-existent, so that `test` and `t[invisible glyph]est` would refer to the same variable.<br>&gt; <br>&gt; <br>&gt; Sincerely,<br>&gt; Jo√£o Pinheiro<br>&gt; <br>&gt; <br>&gt; &gt; On 20 Jun 2016, at 19:26, Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Very interesting.<br>&gt; &gt;<br>&gt; &gt; Btw, IBM Swift Sandbox shows these spaces:<br>&gt; &gt; https://swiftlang.ng.bluemix.net/ &lt;https://swiftlang.ng.bluemix.net/&gt;<br>&gt; &gt; But my mail client does not - i.e. I saw exactly the same &quot;test&quot;&amp;&quot;abc&quot;<br>&gt; &gt;<br>&gt; &gt; Also, I read about some issues with left-to-right and right-to-left markers that also somehow change the actual text of source - i.e. you see one text, but when it compiles - it works not as expected. I.e. viewer/editor processes these special codes and show you one text, but compiler treats text in another way.<br>&gt; &gt;<br>&gt; &gt; I believe it is a potential security problem that all unicode chars are allowed for variables/func names in Swift. IMO We definitely should limit allowed charset for identifiers in sources.<br>&gt; &gt;<br>&gt; &gt; On 20.06.2016 20:51, Jo√£o Pinheiro via swift-evolution wrote:<br>&gt; &gt;&gt; Recently there has been a screenshot going around Twitter about C++ allowing zero-width spaces in variable names. Swift also suffers from this problem which can be abused to create ambiguous, misleading, and potentially obfuscate nefarious code.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I would like to propose a change to prohibit the use of invisible characters in identifier names.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;m including an example of problematic code at the bottom of this email.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Sincerely,<br>&gt; &gt;&gt; Jo√£o Pinheiro<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; /* The output for this code is:<br>&gt; &gt;&gt; A<br>&gt; &gt;&gt; B<br>&gt; &gt;&gt; C<br>&gt; &gt;&gt; 1<br>&gt; &gt;&gt; 2<br>&gt; &gt;&gt; 3<br>&gt; &gt;&gt; */<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func test() { print(&quot;A&quot;) }<br>&gt; &gt;&gt; func t‚Äãest() { print(&quot;B&quot;) }<br>&gt; &gt;&gt; func te‚Äãst() { print(&quot;C&quot;) }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; let abc = 1<br>&gt; &gt;&gt; let a‚Äãbc = 2<br>&gt; &gt;&gt; let ab‚Äãc = 3<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; test()<br>&gt; &gt;&gt; t‚Äãest()<br>&gt; &gt;&gt; te‚Äãst()<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; print(abc)<br>&gt; &gt;&gt; print(a‚Äãbc)<br>&gt; &gt;&gt; print(ab‚Äãc)<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/eb0c8d4d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 20, 2016 at 03:00:00pm</p></header><div class="content"><p>On Mon, Jun 20, 2016 at 2:42 PM, Jo√£o Pinheiro &lt;joao at joaopinheiro.org&gt;<br>wrote:<br></p><p>&gt; I agree that treating zero-width spaces as non-existent would be a<br>&gt; possible solution, but I think it would make more sense to consider it as<br>&gt; white space and thus not admissible in identifier names.<br>&gt;<br></p><p>If you treat it like whitespace, then you get interesting behaviors that I<br>don&#39;t think you would want. For example, something that looks like `if<br>letter...` could be parsed as conditional binding `if let ter...` if I put<br>in a zero-width space in the right place.<br></p><p><br>&gt; I&#39;m not sure of what the best way to handle left-to-right and<br>&gt; right-to-left markers would be. Does it make sense to allow mixed text<br>&gt; orientation in identifiers?<br>&gt;<br></p><p>How do other languages that support Unicode handle these markers in<br>identifiers? I&#39;d be interested to know.<br></p><p><br>&gt; Removing ambiguity between unicode confusables is a much more complicated<br>&gt; issue which implies defining a canonical unicode representation for<br>&gt; identifiers and a way to resolve them. It would also make it impractical to<br>&gt; use certain valid mathematical symbols as identifiers.<br>&gt;<br></p><p>Most interesting mathematical symbols are reserved for operators anyway. As<br>a result, `x` and the multiplication symbol are not readily confusable in<br>most contexts in Swift, and confusable resolution could be built in such a<br>way that identifier characters are not regarded as confusable with operator<br>characters.<br></p><p><br>&gt; Jo√£o Pinheiro<br>&gt;<br>&gt;<br>&gt; On 20 Jun 2016, at 20:23, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Mon, Jun 20, 2016 at 2:17 PM, Jo√£o Pinheiro &lt;swift-evolution at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Nice feature in the IBM Swift Sandbox. Xcode doesn&#39;t display zero-width<br>&gt;&gt; spaces either so the identifier names look exactly the same.<br>&gt;&gt;<br>&gt;&gt; The issue with left-to-right and right-to-left markers is interesting and<br>&gt;&gt; has previously been exploited in email phishing attacks.<br>&gt;&gt;<br>&gt;&gt; It would be possible to highlight invisible characters in Xcode as a<br>&gt;&gt; stopgap measure, but that doesn&#39;t solve the problem for developers using<br>&gt;&gt; other editors or in other platforms. I think it would be a better idea to<br>&gt;&gt; sanitise the set of allowed (or prohibited) characters for identifiers at<br>&gt;&gt; the language level.<br>&gt;&gt;<br>&gt;<br>&gt; This is a potential security problem, but no need try to invent an ad-hoc<br>&gt; solution here, particularly one as drastic as prohibiting characters. The<br>&gt; same security considerations are applicable elsewhere and there&#39;s a lot of<br>&gt; work about Unicode security. See here:<br>&gt; http://www.unicode.org/reports/tr39/<br>&gt;<br>&gt; Unicode maintains a list of &quot;confusable&quot; characters. See here:<br>&gt; http://www.unicode.org/Public/security/latest/confusables.txt<br>&gt;<br>&gt; It should be sufficient to regard confusables as the same glyph for the<br>&gt; purpose of identifier names; zero-width and invisible marks would then be<br>&gt; regarded as non-existent, so that `test` and `t[invisible glyph]est` would<br>&gt; refer to the same variable.<br>&gt;<br>&gt;<br>&gt;&gt; Sincerely,<br>&gt;&gt; Jo√£o Pinheiro<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On 20 Jun 2016, at 19:26, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Very interesting.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Btw, IBM Swift Sandbox shows these spaces:<br>&gt;&gt; &gt; https://swiftlang.ng.bluemix.net/<br>&gt;&gt; &gt; But my mail client does not - i.e. I saw exactly the same &quot;test&quot;&amp;&quot;abc&quot;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Also, I read about some issues with left-to-right and right-to-left<br>&gt;&gt; markers that also somehow change the actual text of source - i.e. you see<br>&gt;&gt; one text, but when it compiles - it works not as expected. I.e.<br>&gt;&gt; viewer/editor processes these special codes and show you one text, but<br>&gt;&gt; compiler treats text in another way.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I believe it is a potential security problem that all unicode chars are<br>&gt;&gt; allowed for variables/func names in Swift. IMO We definitely should limit<br>&gt;&gt; allowed charset for identifiers in sources.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On 20.06.2016 20:51, Jo√£o Pinheiro via swift-evolution wrote:<br>&gt;&gt; &gt;&gt; Recently there has been a screenshot going around Twitter about C++<br>&gt;&gt; allowing zero-width spaces in variable names. Swift also suffers from this<br>&gt;&gt; problem which can be abused to create ambiguous, misleading, and<br>&gt;&gt; potentially obfuscate nefarious code.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I would like to propose a change to prohibit the use of invisible<br>&gt;&gt; characters in identifier names.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I&#39;m including an example of problematic code at the bottom of this<br>&gt;&gt; email.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Sincerely,<br>&gt;&gt; &gt;&gt; Jo√£o Pinheiro<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; /* The output for this code is:<br>&gt;&gt; &gt;&gt; A<br>&gt;&gt; &gt;&gt; B<br>&gt;&gt; &gt;&gt; C<br>&gt;&gt; &gt;&gt; 1<br>&gt;&gt; &gt;&gt; 2<br>&gt;&gt; &gt;&gt; 3<br>&gt;&gt; &gt;&gt; */<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func test() { print(&quot;A&quot;) }<br>&gt;&gt; &gt;&gt; func t‚Äãest() { print(&quot;B&quot;) }<br>&gt;&gt; &gt;&gt; func te‚Äãst() { print(&quot;C&quot;) }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; let abc = 1<br>&gt;&gt; &gt;&gt; let a‚Äãbc = 2<br>&gt;&gt; &gt;&gt; let ab‚Äãc = 3<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; test()<br>&gt;&gt; &gt;&gt; t‚Äãest()<br>&gt;&gt; &gt;&gt; te‚Äãst()<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; print(abc)<br>&gt;&gt; &gt;&gt; print(a‚Äãbc)<br>&gt;&gt; &gt;&gt; print(ab‚Äãc)<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/66ec5302/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/92adc26e3003cac88ca299a08d35b2b3?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Jo√£o Pinheiro</string> &lt;joao at joaopinheiro.org&gt;<p>June 20, 2016 at 10:00:00pm</p></header><div class="content"><p>On 20 Jun 2016, at 21:07, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, Jun 20, 2016 at 2:42 PM, Jo√£o Pinheiro &lt;joao at joaopinheiro.org &lt;mailto:joao at joaopinheiro.org&gt;&gt; wrote:<br>&gt; I agree that treating zero-width spaces as non-existent would be a possible solution, but I think it would make more sense to consider it as white space and thus not admissible in identifier names.<br>&gt; <br>&gt; If you treat it like whitespace, then you get interesting behaviors that I don&#39;t think you would want. For example, something that looks like `if letter...` could be parsed as conditional binding `if let ter...` if I put in a zero-width space in the right place.<br></p><p>I hadn&#39;t thought of that possibility. Ignoring them has the problem of creating multiple valid representations for the same identifier though. Not allowing invisible characters in identifiers sounds like the best solution to me.<br></p><p>&gt; I&#39;m not sure of what the best way to handle left-to-right and right-to-left markers would be. Does it make sense to allow mixed text orientation in identifiers?<br>&gt; <br>&gt; How do other languages that support Unicode handle these markers in identifiers? I&#39;d be interested to know.<br></p><p>Me too.<br></p><p>&gt; Removing ambiguity between unicode confusables is a much more complicated issue which implies defining a canonical unicode representation for identifiers and a way to resolve them. It would also make it impractical to use certain valid mathematical symbols as identifiers.<br>&gt; <br>&gt; Most interesting mathematical symbols are reserved for operators anyway. As a result, `x` and the multiplication symbol are not readily confusable in most contexts in Swift, and confusable resolution could be built in such a way that identifier characters are not regarded as confusable with operator characters.<br></p><p>That would require maintaining a large list of exception characters though. Just like the problem with ignoring invisible characters mentioned above, eliminating confusables has the problem of creating multiple representations for the same identifier, which could become quite confusing and result in additional problems of its own. I think it would probably be best to avoid a situation where it&#39;s necessary to resolve different representations of an identifier.<br></p><p>Sincerely,<br>Jo√£o Pinheiro<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/3514d598/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 21, 2016 at 12:00:00am</p></header><div class="content"><p>Perhaps stupid but: why was Swift designed to accept most Unicode characters in identifier names? Wouldn‚Äôt it be simpler to go back to a model where only standard ascii characters are accepted in identifier names?<br></p><p>&gt; On 20 Jun 2016, at 20:26, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Very interesting.<br>&gt; <br>&gt; Btw, IBM Swift Sandbox shows these spaces:<br>&gt; https://swiftlang.ng.bluemix.net/<br>&gt; But my mail client does not - i.e. I saw exactly the same &quot;test&quot;&amp;&quot;abc&quot;<br>&gt; <br>&gt; Also, I read about some issues with left-to-right and right-to-left markers that also somehow change the actual text of source - i.e. you see one text, but when it compiles - it works not as expected. I.e. viewer/editor processes these special codes and show you one text, but compiler treats text in another way.<br>&gt; <br>&gt; I believe it is a potential security problem that all unicode chars are allowed for variables/func names in Swift. IMO We definitely should limit allowed charset for identifiers in sources.<br>&gt; <br>&gt; On 20.06.2016 20:51, Jo√£o Pinheiro via swift-evolution wrote:<br>&gt;&gt; Recently there has been a screenshot going around Twitter about C++ allowing zero-width spaces in variable names. Swift also suffers from this problem which can be abused to create ambiguous, misleading, and potentially obfuscate nefarious code.<br>&gt;&gt; <br>&gt;&gt; I would like to propose a change to prohibit the use of invisible characters in identifier names.<br>&gt;&gt; <br>&gt;&gt; I&#39;m including an example of problematic code at the bottom of this email.<br>&gt;&gt; <br>&gt;&gt; Sincerely,<br>&gt;&gt; Jo√£o Pinheiro<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; /* The output for this code is:<br>&gt;&gt; A<br>&gt;&gt; B<br>&gt;&gt; C<br>&gt;&gt; 1<br>&gt;&gt; 2<br>&gt;&gt; 3<br>&gt;&gt; */<br>&gt;&gt; <br>&gt;&gt; func test() { print(&quot;A&quot;) }<br>&gt;&gt; func t‚Äãest() { print(&quot;B&quot;) }<br>&gt;&gt; func te‚Äãst() { print(&quot;C&quot;) }<br>&gt;&gt; <br>&gt;&gt; let abc = 1<br>&gt;&gt; let a‚Äãbc = 2<br>&gt;&gt; let ab‚Äãc = 3<br>&gt;&gt; <br>&gt;&gt; test()<br>&gt;&gt; t‚Äãest()<br>&gt;&gt; te‚Äãst()<br>&gt;&gt; <br>&gt;&gt; print(abc)<br>&gt;&gt; print(a‚Äãbc)<br>&gt;&gt; print(ab‚Äãc)<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 20, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Perhaps stupid but: why was Swift designed to accept most Unicode characters in identifier names? Wouldn‚Äôt it be simpler to go back to a model where only standard ascii characters are accepted in identifier names?<br></p><p>I assume it has something to do with the fact that 94.6% of the world&#39;s population speak a first language which is not English. That outweighs the inconvenience for Anglo developers, IMHO.<br></p><p>Honestly, this seems to me like a concern for linters and security auditing tools, not for the compiler. Swift identifiers are case-sensitive; I see no reason they shouldn&#39;t be script-sensitive or zero-width-joiner-sensitive. (Though basic Unicode normalization seems like a good idea, since differently-normalized strings are `==` anyway.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 21, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Jun 21, 2016, at 2:23 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Perhaps stupid but: why was Swift designed to accept most Unicode characters in identifier names? Wouldn‚Äôt it be simpler to go back to a model where only standard ascii characters are accepted in identifier names?<br>&gt; <br>&gt; I assume it has something to do with the fact that 94.6% of the world&#39;s population speak a first language which is not English. That outweighs the inconvenience for Anglo developers, IMHO.<br></p><p>Yes, but the SDKs (frameworks, system libraries) are all in English, including Swift standard library. I remember a few languages attempting localized versions for kids to study better, failing terribly because you learned something that had a very very limited use.<br></p><p>When it comes to maintaining code, using localized identifier names is a bad practice since anyone outside that country coming to the code can&#39;t really use it. I personally can&#39;t imagine coming to maintain Swift code with identifiers in Chinese, Japanese, Arabic, ...<br></p><p>While the feature of non-ASCII characters being allowed as identifiers (which was held up high with Apple giving emoji examples) may seem cool, I can only see this helpful in the future, given a different keyboard layout (as someone has pointed out some time ago here), to introduce one-character operators that would be otherwise impossible. But if someone came to me with a code where a variable would be an emoji of a dog, he&#39;d get fired on the spot.<br></p><p>I&#39;d personally vote to keep the zero-width-joiner characters forbidden within the code outside of string literals (where they may make sense). I agree that this can be easily solved by linters, but: I think this particular set of characters should be restricted by the language itself, since it&#39;s something easily omittable during code review and given the upcoming package manager, this can lead to a hard-to-find malware being distributed among developers who include these packages within their projects - since you usually do not run a linter on a 3rd party code.<br></p><p>As for the confusables - this depends a lot on the rendering and what font you have set. I&#39;ve tried  ùõé ‚Üí v with current Xcode and it looks really different, mostly when you use a fixed-space font which usually doesn&#39;t have non-ASCII characters which are then rendered using a different font, making the distinction easy to spot.<br></p><p>&gt; <br>&gt; Honestly, this seems to me like a concern for linters and security auditing tools, not for the compiler. Swift identifiers are case-sensitive; I see no reason they shouldn&#39;t be script-sensitive or zero-width-joiner-sensitive. (Though basic Unicode normalization seems like a good idea, since differently-normalized strings are `==` anyway.)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 21, 2016 at 05:00:00pm</p></header><div class="content"><p>On 21.06.2016 7:37, Charlie Monroe via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On Jun 21, 2016, at 2:23 AM, Brent Royal-Gordon via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Perhaps stupid but: why was Swift designed to accept most Unicode<br>&gt;&gt;&gt; characters in identifier names? Wouldn‚Äôt it be simpler to go back to<br>&gt;&gt;&gt; a model where only standard ascii characters are accepted in<br>&gt;&gt;&gt; identifier names?<br>&gt;&gt;<br>&gt;&gt; I assume it has something to do with the fact that 94.6% of the<br>&gt;&gt; world&#39;s population speak a first language which is not English. That<br>&gt;&gt; outweighs the inconvenience for Anglo developers, IMHO.<br>&gt;<br>&gt; Yes, but the SDKs (frameworks, system libraries) are all in English,<br>&gt; including Swift standard library. I remember a few languages attempting<br>&gt; localized versions for kids to study better, failing terribly because<br>&gt; you learned something that had a very very limited use.<br></p><p>Support Charlie&#39;s opinion. For me (as non-native English speaker) non-ASCII <br>characters in identifiers had no sense, even when I start to tech the <br>programming when I was a child. Expressions composed from identifiers <br>written in my native language is not near correct sentences.<br></p><p>Even more, we still have all other parts of language in English - <br>for-while-guard-let-var-func etc..<br></p><p>&gt;<br>&gt; When it comes to maintaining code, using localized identifier names is a<br>&gt; bad practice since anyone outside that country coming to the code can&#39;t<br>&gt; really use it. I personally can&#39;t imagine coming to maintain Swift code<br>&gt; with identifiers in Chinese, Japanese, Arabic, ...<br>&gt;<br>&gt; While the feature of non-ASCII characters being allowed as identifiers<br>&gt; (which was held up high with Apple giving emoji examples) may seem cool,<br>&gt; I can only see this helpful in the future, given a different keyboard<br>&gt; layout (as someone has pointed out some time ago here), to introduce<br>&gt; one-character operators that would be otherwise impossible. But if<br>&gt; someone came to me with a code where a variable would be an emoji of a<br>&gt; dog, he&#39;d get fired on the spot.<br></p><p>Yes, but I don&#39;t believe Apple will accept limiting of character set for <br>identifiers to ASCII *after* these presentations with emoji of a dog ;-)<br></p><p>&gt;<br>&gt; I&#39;d personally vote to keep the zero-width-joiner characters forbidden<br>&gt; within the code outside of string literals (where they may make sense).<br>&gt; I agree that this can be easily solved by linters, but: I think this<br>&gt; particular set of characters should be restricted by the language<br>&gt; itself, since it&#39;s something easily omittable during code review and<br>&gt; given the upcoming package manager, this can lead to a hard-to-find<br>&gt; malware being distributed among developers who include these packages<br>&gt; within their projects - since you usually do not run a linter on a 3rd<br>&gt; party code.<br></p><p>I also think the main problem that could be caused by such tricks with <br>zero-width-joiner or right-to-left-markers is injecting some malware code <br>into sources in github, in package manager *or* even just in  code snippet <br>on web page(so you copy-pasted it to your source). Right now I don&#39;t know <br>exact method to implement such malware code, but I believe this <br>vulnerability could be used some day.<br></p><p>Btw, regarding the package manager. Will we have any protection from <br>Typosquatting ? <br>http://incolumitas.com/2016/06/08/typosquatting-package-managers/#typosquatting-package-managers<br></p><p>&gt;<br>&gt; As for the confusables - this depends a lot on the rendering and what<br>&gt; font you have set. I&#39;ve tried  ùõé ‚Üí v with current Xcode and it looks<br>&gt; really different, mostly when you use a fixed-space font which usually<br>&gt; doesn&#39;t have non-ASCII characters which are then rendered using a<br>&gt; different font, making the distinction easy to spot.<br></p><p>In Russian we have these chars :<br>—É –∫ –µ –≥ —Ö –∞ —Ä –æ —Å —å<br>which are similar to english:<br>y k e r x a p o c b<br></p><p>So you most likely can&#39;t differ `—Ä–æ—Å` and `poc` , `—Ö–∞–µ` and `xae` etc<br></p><p>I don&#39;t think compiler should somehow decide if one non-English letter is <br>looks like another English letter. But don&#39;t see any other method to <br>protect myself other than using lints/checking tools for 3rd party code also.<br></p><p>&gt;<br>&gt;&gt;<br>&gt;&gt; Honestly, this seems to me like a concern for linters and security<br>&gt;&gt; auditing tools, not for the compiler. Swift identifiers are<br>&gt;&gt; case-sensitive; I see no reason they shouldn&#39;t be script-sensitive or<br>&gt;&gt; zero-width-joiner-sensitive. (Though basic Unicode normalization seems<br>&gt;&gt; like a good idea, since differently-normalized strings are `==`<br>&gt;&gt; anyway.)<br>&gt;&gt;<br>&gt;&gt; -- Brent Royal-Gordon Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________ swift-evolution mailing<br>&gt; list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/42eca71033ece251f2f194b7e343c2ec?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Magnus Ahltorp</string> &lt;map at kth.se&gt;<p>June 25, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; 21 June 2016 16:48 Vladimir.S via swift-evolution wrote:<br>&gt; <br>&gt; On 21.06.2016 7:37, Charlie Monroe via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 21, 2016, at 2:23 AM, Brent Royal-Gordon via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Perhaps stupid but: why was Swift designed to accept most Unicode<br>&gt;&gt;&gt;&gt; characters in identifier names? Wouldn‚Äôt it be simpler to go back to<br>&gt;&gt;&gt;&gt; a model where only standard ascii characters are accepted in<br>&gt;&gt;&gt;&gt; identifier names?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I assume it has something to do with the fact that 94.6% of the<br>&gt;&gt;&gt; world&#39;s population speak a first language which is not English. That<br>&gt;&gt;&gt; outweighs the inconvenience for Anglo developers, IMHO.<br>&gt;&gt; <br>&gt;&gt; Yes, but the SDKs (frameworks, system libraries) are all in English,<br>&gt;&gt; including Swift standard library. I remember a few languages attempting<br>&gt;&gt; localized versions for kids to study better, failing terribly because<br>&gt;&gt; you learned something that had a very very limited use.<br>&gt; <br>&gt; Support Charlie&#39;s opinion. For me (as non-native English speaker) non-ASCII characters in identifiers had no sense, even when I start to tech the programming when I was a child. Expressions composed from identifiers written in my native language is not near correct sentences.<br>&gt; <br>&gt; Even more, we still have all other parts of language in English - for-while-guard-let-var-func etc..<br></p><p>As far as I can see, forcing the programmer to write identifiers in an only-ASCII language, and requiring that identifier names have to be meaningful to the programmer means that the programmer has to know a language that is written in only ASCII. Most people are not, and requiring that they first learn for example English to be able to write programs is absurd.<br></p><p>Of course, if we relax the rule that identifier names have to be meaningful to the programmer, then it works out, but that is not something that I feel the Swift community should encourage.<br></p><p>The few symbols that are in English can be learned as what they are, symbols, without knowing their English meaning, just like &amp;, |, &lt;, &gt;, *, and so on are symbols. In fact, you all learn these words as symbols that are distinct from their English connotations, since Swift is definitely not English text.<br></p><p>/Magnus<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 25, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Jun 25, 2016, at 12:21 AM, Magnus Ahltorp &lt;map at kth.se&gt; wrote:<br>&gt; <br>&gt;&gt; 21 June 2016 16:48 Vladimir.S via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt; On 21.06.2016 7:37, Charlie Monroe via swift-evolution wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 21, 2016, at 2:23 AM, Brent Royal-Gordon via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Perhaps stupid but: why was Swift designed to accept most Unicode<br>&gt;&gt;&gt;&gt;&gt; characters in identifier names? Wouldn‚Äôt it be simpler to go back to<br>&gt;&gt;&gt;&gt;&gt; a model where only standard ascii characters are accepted in<br>&gt;&gt;&gt;&gt;&gt; identifier names?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I assume it has something to do with the fact that 94.6% of the<br>&gt;&gt;&gt;&gt; world&#39;s population speak a first language which is not English. That<br>&gt;&gt;&gt;&gt; outweighs the inconvenience for Anglo developers, IMHO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, but the SDKs (frameworks, system libraries) are all in English,<br>&gt;&gt;&gt; including Swift standard library. I remember a few languages attempting<br>&gt;&gt;&gt; localized versions for kids to study better, failing terribly because<br>&gt;&gt;&gt; you learned something that had a very very limited use.<br>&gt;&gt; <br>&gt;&gt; Support Charlie&#39;s opinion. For me (as non-native English speaker) non-ASCII characters in identifiers had no sense, even when I start to tech the programming when I was a child. Expressions composed from identifiers written in my native language is not near correct sentences.<br>&gt;&gt; <br>&gt;&gt; Even more, we still have all other parts of language in English - for-while-guard-let-var-func etc..<br>&gt; <br>&gt; As far as I can see, forcing the programmer to write identifiers in an only-ASCII language, and requiring that identifier names have to be meaningful to the programmer means that the programmer has to know a language that is written in only ASCII. Most people are not, and requiring that they first learn for example English to be able to write programs is absurd.<br></p><p>You can always write your identifier using ASCII. For languages that use the latin script, just extended with various accents, can be written without them (this is how I was taught). Any language I&#39;m aware of can be eventually written in the latin script (Chinese, cyrilic, ...). <br></p><p>BTW how far along with programming do you think you&#39;d get without the knowledge of English? All libraries, SDKs use English identifiers. The documentation is in English. For one to lear programming without actually knowing any English would require the language to have localizable identifiers. Can you imagine those? Given how much time is put here to standardize the naming of a few methods in the standard library, how would it look in other languages? <br></p><p>&gt; <br>&gt; Of course, if we relax the rule that identifier names have to be meaningful to the programmer, then it works out, but that is not something that I feel the Swift community should encourage.<br>&gt; <br>&gt; The few symbols that are in English can be learned as what they are, symbols, without knowing their English meaning, just like &amp;, |, &lt;, &gt;, *, and so on are symbols. In fact, you all learn these words as symbols that are distinct from their English connotations, since Swift is definitely not English text.<br>&gt; <br>&gt; /Magnus<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 25, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Jun 24, 2016, at 23:13, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; BTW how far along with programming do you think you&#39;d get without the knowledge of English? All libraries, SDKs use English identifiers. The documentation is in English. For one to lear programming without actually knowing any English would require the language to have localizable identifiers. Can you imagine those? Given how much time is put here to standardize the naming of a few methods in the standard library, how would it look in other languages?<br></p><p>Speaking of which, hypothetically, if we wanted to support translations of Swift itself (and the standard library), would it be better to have the compiler figure out how to make object files work across languages, or would it be better for the on-disk file to always be in the &quot;canonical&quot; language and have the IDE do the translation?<br></p><p>I&#39;m *not* proposing we do this... Just thinking about what would need to be done and how hard it would be.<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 27, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Jun 25, 2016, at 7:12 AM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 24, 2016, at 23:13, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; BTW how far along with programming do you think you&#39;d get without the knowledge of English? All libraries, SDKs use English identifiers. The documentation is in English. For one to lear programming without actually knowing any English would require the language to have localizable identifiers. Can you imagine those? Given how much time is put here to standardize the naming of a few methods in the standard library, how would it look in other languages?<br>&gt; <br>&gt; Speaking of which, hypothetically, if we wanted to support translations of Swift itself (and the standard library), would it be better to have the compiler figure out how to make object files work across languages, or would it be better for the on-disk file to always be in the &quot;canonical&quot; language and have the IDE do the translation?<br></p><p>Historically, these languages were 100% translated and required localized compiler support (we&#39;re talking about BASIC, Pascal) since back then IDE support was quite poor. Nowadays, on-the-fly translation by the IDE would probably work out the best.<br></p><p>&gt; I&#39;m *not* proposing we do this... Just thinking about what would need to be done and how hard it would be.<br>&gt; <br>&gt; - Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>June 27, 2016 at 05:00:00am</p></header><div class="content"><p>The problem with depending on the IDE is that not everyone is using<br>Xcode‚Ä¶or even a modern IDE. There are those that are using basic text<br>editors, which must be considered as well.<br></p><p>On Sun, Jun 26, 2016 at 9:25 PM Charlie Monroe via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jun 25, 2016, at 7:12 AM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jun 24, 2016, at 23:13, Charlie Monroe via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; BTW how far along with programming do you think you&#39;d get without the<br>&gt; knowledge of English? All libraries, SDKs use English identifiers. The<br>&gt; documentation is in English. For one to lear programming without actually<br>&gt; knowing any English would require the language to have localizable<br>&gt; identifiers. Can you imagine those? Given how much time is put here to<br>&gt; standardize the naming of a few methods in the standard library, how would<br>&gt; it look in other languages?<br>&gt; &gt;<br>&gt; &gt; Speaking of which, hypothetically, if we wanted to support translations<br>&gt; of Swift itself (and the standard library), would it be better to have the<br>&gt; compiler figure out how to make object files work across languages, or<br>&gt; would it be better for the on-disk file to always be in the &quot;canonical&quot;<br>&gt; language and have the IDE do the translation?<br>&gt;<br>&gt; Historically, these languages were 100% translated and required localized<br>&gt; compiler support (we&#39;re talking about BASIC, Pascal) since back then IDE<br>&gt; support was quite poor. Nowadays, on-the-fly translation by the IDE would<br>&gt; probably work out the best.<br>&gt;<br>&gt; &gt; I&#39;m *not* proposing we do this... Just thinking about what would need to<br>&gt; be done and how hard it would be.<br>&gt; &gt;<br>&gt; &gt; - Dave Sweeris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/ecf0dfab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 27, 2016 at 08:00:00am</p></header><div class="content"><p>Sure, but if you want to have translated identifiers, there&#39;s really no other (better) option unless you want to create ABI incompatible code (given that Swift 4 has a finalized ABI) that only runs on your localized system.<br></p><p>&gt; On Jun 27, 2016, at 7:59 AM, Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br>&gt; <br>&gt; The problem with depending on the IDE is that not everyone is using Xcode‚Ä¶or even a modern IDE. There are those that are using basic text editors, which must be considered as well.<br>&gt; <br>&gt; On Sun, Jun 26, 2016 at 9:25 PM Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Jun 25, 2016, at 7:12 AM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jun 24, 2016, at 23:13, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; BTW how far along with programming do you think you&#39;d get without the knowledge of English? All libraries, SDKs use English identifiers. The documentation is in English. For one to lear programming without actually knowing any English would require the language to have localizable identifiers. Can you imagine those? Given how much time is put here to standardize the naming of a few methods in the standard library, how would it look in other languages?<br>&gt; &gt;<br>&gt; &gt; Speaking of which, hypothetically, if we wanted to support translations of Swift itself (and the standard library), would it be better to have the compiler figure out how to make object files work across languages, or would it be better for the on-disk file to always be in the &quot;canonical&quot; language and have the IDE do the translation?<br>&gt; <br>&gt; Historically, these languages were 100% translated and required localized compiler support (we&#39;re talking about BASIC, Pascal) since back then IDE support was quite poor. Nowadays, on-the-fly translation by the IDE would probably work out the best.<br>&gt; <br>&gt; &gt; I&#39;m *not* proposing we do this... Just thinking about what would need to be done and how hard it would be.<br>&gt; &gt;<br>&gt; &gt; - Dave Sweeris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -- <br>&gt; -Saagar Jha<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/187d26e5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>June 27, 2016 at 06:00:00am</p></header><div class="content"><p>It‚Äôs leaving a lot of Linux users out to dry; a better option may be a sort<br>of hybrid approach with a ‚Äúmiddleman‚Äù tool that does the translation, which<br>people could simply add as a build step if they needed translation.<br></p><p>On Sun, Jun 26, 2016 at 11:08 PM Charlie Monroe &lt;charlie at charliemonroe.net&gt;<br>wrote:<br></p><p>&gt; Sure, but if you want to have translated identifiers, there&#39;s really no<br>&gt; other (better) option unless you want to create ABI incompatible code<br>&gt; (given that Swift 4 has a finalized ABI) that only runs on your localized<br>&gt; system.<br>&gt;<br>&gt; On Jun 27, 2016, at 7:59 AM, Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br>&gt;<br>&gt; The problem with depending on the IDE is that not everyone is using<br>&gt; Xcode‚Ä¶or even a modern IDE. There are those that are using basic text<br>&gt; editors, which must be considered as well.<br>&gt;<br>&gt; On Sun, Jun 26, 2016 at 9:25 PM Charlie Monroe via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Jun 25, 2016, at 7:12 AM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jun 24, 2016, at 23:13, Charlie Monroe via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; BTW how far along with programming do you think you&#39;d get without the<br>&gt;&gt; knowledge of English? All libraries, SDKs use English identifiers. The<br>&gt;&gt; documentation is in English. For one to lear programming without actually<br>&gt;&gt; knowing any English would require the language to have localizable<br>&gt;&gt; identifiers. Can you imagine those? Given how much time is put here to<br>&gt;&gt; standardize the naming of a few methods in the standard library, how would<br>&gt;&gt; it look in other languages?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Speaking of which, hypothetically, if we wanted to support translations<br>&gt;&gt; of Swift itself (and the standard library), would it be better to have the<br>&gt;&gt; compiler figure out how to make object files work across languages, or<br>&gt;&gt; would it be better for the on-disk file to always be in the &quot;canonical&quot;<br>&gt;&gt; language and have the IDE do the translation?<br>&gt;&gt;<br>&gt;&gt; Historically, these languages were 100% translated and required localized<br>&gt;&gt; compiler support (we&#39;re talking about BASIC, Pascal) since back then IDE<br>&gt;&gt; support was quite poor. Nowadays, on-the-fly translation by the IDE would<br>&gt;&gt; probably work out the best.<br>&gt;&gt;<br>&gt;&gt; &gt; I&#39;m *not* proposing we do this... Just thinking about what would need<br>&gt;&gt; to be done and how hard it would be.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; - Dave Sweeris<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; --<br>&gt; -Saagar Jha<br>&gt;<br>&gt;<br>&gt; --<br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/252d3b05/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/42eca71033ece251f2f194b7e343c2ec?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Magnus Ahltorp</string> &lt;map at kth.se&gt;<p>June 25, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; 25 June 2016 06:13 Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 25, 2016, at 12:21 AM, Magnus Ahltorp &lt;map at kth.se&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As far as I can see, forcing the programmer to write identifiers in an only-ASCII language, and requiring that identifier names have to be meaningful to the programmer means that the programmer has to know a language that is written in only ASCII. Most people are not, and requiring that they first learn for example English to be able to write programs is absurd.<br>&gt; <br>&gt; You can always write your identifier using ASCII. For languages that use the latin script, just extended with various accents, can be written without them (this is how I was taught). Any language I&#39;m aware of can be eventually written in the latin script (Chinese, cyrilic, ...). <br></p><p>Take this small example from the Swift book:<br></p><p>let favoriteSnacks = [<br>    &quot;Alice&quot;: &quot;Chips&quot;,<br>    &quot;Bob&quot;: &quot;Licorice&quot;,<br>    &quot;Eve&quot;: &quot;Pretzels&quot;,<br>]<br></p><p>func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {<br>    let snackName = favoriteSnacks[person] ?? &quot;Candy Bar&quot;<br>    try vendingMachine.vend(itemNamed: snackName)<br>}<br></p><p>Imagine being forced to write all your identifiers in Chinese script, based on the Mandarin transliteration of the English pronunciation:<br></p><p>ÂÅáËÆæ Ë¥πÂºóÂãíÁâπÊñØÁ∫≥ÂÖãÊñØ = [<br>    &quot;Alice&quot;: &quot;Chips&quot;,<br>    &quot;Bob&quot;: &quot;Licorice&quot;,<br>    &quot;Eve&quot;: &quot;Pretzels&quot;,<br>]<br></p><p>ÂáΩÊï∞ ÊãúË¥πÂºóÂãíÁâπÊñØÁ∫≥ÂÖã(ÁèÄÂ∞îÁëüÊÅ©: Â≠óÁ¨¶‰∏≤, Êñá‰∏ÅÈªòÊ¨£: Êñá‰∏ÅÈªòÊ¨£) ‰ºöÊäïÊé∑ {<br>    ÂÅáËÆæ ÊñØÁ∫≥ÂÖãÂÜÖÂßÜ = Ë¥πÂºóÂãíÁâπÊñØÁ∫≥ÂÖãÊñØ[ÁèÄÂ∞îÁëüÊÅ©] ?? &quot;Candy Bar&quot;<br>    Â∞ùËØï Êñá‰∏ÅÈªòÊ¨£.ÊñáÂæ∑(ËâæÂæ∑ÂßÜÂÜÖÂßÜÂæ∑: ÊñØÁ∫≥ÂÖãÂÜÖÂßÜ)<br>}<br></p><p>At least you can write the strings in your familiar script. Since you probably don&#39;t know Chinese, it is best illustrated by converting it to (non-accented) Pinyin.<br></p><p>jiashe feifuletesinakesi = [<br>    &quot;Alice&quot;: &quot;Chips&quot;,<br>    &quot;Bob&quot;: &quot;Licorice&quot;,<br>    &quot;Eve&quot;: &quot;Pretzels&quot;,<br>]<br></p><p>hanshu baifeifuletesinake(poerseen: zifuchuan, wendingmoxin: wendingmoxin) huitouzhi {<br>    jiashe sinakeneimu = feifuletesinakesi[poerseen] ?? &quot;Candy Bar&quot;<br>    changshi wendingmoxin.wende(aidemuneimude: sinakeneimu)<br>}<br></p><p>You would probably quickly learn words like jiashe and hanshu, but every identifier else is actually still in English, just horribly garbled.<br></p><p>Please excuse any errors in the transliterations, but you would probably make some errors if you would have to write your code in Chinese as well.<br></p><p>&gt; BTW how far along with programming do you think you&#39;d get without the knowledge of English? All libraries, SDKs use English identifiers. The documentation is in English. For one to lear programming without actually knowing any English would require the language to have localizable identifiers. Can you imagine those? Given how much time is put here to standardize the naming of a few methods in the standard library, how would it look in other languages? <br></p><p>There are actually programming resources in other languages than English. This is especially true for Chinese.<br></p><p>/Magnus<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>June 28, 2016 at 12:00:00pm</p></header><div class="content"><p>Doesn&#39;t Unicode have a standard for this that specified which characters are look-alikes?<br></p><p>Russ<br></p><p>&gt; On Jun 21, 2016, at 7:48 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 21.06.2016 7:37, Charlie Monroe via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 21, 2016, at 2:23 AM, Brent Royal-Gordon via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Perhaps stupid but: why was Swift designed to accept most Unicode<br>&gt;&gt;&gt;&gt; characters in identifier names? Wouldn‚Äôt it be simpler to go back to<br>&gt;&gt;&gt;&gt; a model where only standard ascii characters are accepted in<br>&gt;&gt;&gt;&gt; identifier names?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I assume it has something to do with the fact that 94.6% of the<br>&gt;&gt;&gt; world&#39;s population speak a first language which is not English. That<br>&gt;&gt;&gt; outweighs the inconvenience for Anglo developers, IMHO.<br>&gt;&gt; <br>&gt;&gt; Yes, but the SDKs (frameworks, system libraries) are all in English,<br>&gt;&gt; including Swift standard library. I remember a few languages attempting<br>&gt;&gt; localized versions for kids to study better, failing terribly because<br>&gt;&gt; you learned something that had a very very limited use.<br>&gt; <br>&gt; Support Charlie&#39;s opinion. For me (as non-native English speaker) non-ASCII characters in identifiers had no sense, even when I start to tech the programming when I was a child. Expressions composed from identifiers written in my native language is not near correct sentences.<br>&gt; <br>&gt; Even more, we still have all other parts of language in English - for-while-guard-let-var-func etc..<br>&gt; <br>&gt;&gt; <br>&gt;&gt; When it comes to maintaining code, using localized identifier names is a<br>&gt;&gt; bad practice since anyone outside that country coming to the code can&#39;t<br>&gt;&gt; really use it. I personally can&#39;t imagine coming to maintain Swift code<br>&gt;&gt; with identifiers in Chinese, Japanese, Arabic, ...<br>&gt;&gt; <br>&gt;&gt; While the feature of non-ASCII characters being allowed as identifiers<br>&gt;&gt; (which was held up high with Apple giving emoji examples) may seem cool,<br>&gt;&gt; I can only see this helpful in the future, given a different keyboard<br>&gt;&gt; layout (as someone has pointed out some time ago here), to introduce<br>&gt;&gt; one-character operators that would be otherwise impossible. But if<br>&gt;&gt; someone came to me with a code where a variable would be an emoji of a<br>&gt;&gt; dog, he&#39;d get fired on the spot.<br>&gt; <br>&gt; Yes, but I don&#39;t believe Apple will accept limiting of character set for identifiers to ASCII *after* these presentations with emoji of a dog ;-)<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;d personally vote to keep the zero-width-joiner characters forbidden<br>&gt;&gt; within the code outside of string literals (where they may make sense).<br>&gt;&gt; I agree that this can be easily solved by linters, but: I think this<br>&gt;&gt; particular set of characters should be restricted by the language<br>&gt;&gt; itself, since it&#39;s something easily omittable during code review and<br>&gt;&gt; given the upcoming package manager, this can lead to a hard-to-find<br>&gt;&gt; malware being distributed among developers who include these packages<br>&gt;&gt; within their projects - since you usually do not run a linter on a 3rd<br>&gt;&gt; party code.<br>&gt; <br>&gt; I also think the main problem that could be caused by such tricks with zero-width-joiner or right-to-left-markers is injecting some malware code into sources in github, in package manager *or* even just in  code snippet on web page(so you copy-pasted it to your source). Right now I don&#39;t know exact method to implement such malware code, but I believe this vulnerability could be used some day.<br>&gt; <br>&gt; Btw, regarding the package manager. Will we have any protection from Typosquatting ? http://incolumitas.com/2016/06/08/typosquatting-package-managers/#typosquatting-package-managers<br>&gt; <br>&gt;&gt; <br>&gt;&gt; As for the confusables - this depends a lot on the rendering and what<br>&gt;&gt; font you have set. I&#39;ve tried  ùõé ‚Üí v with current Xcode and it looks<br>&gt;&gt; really different, mostly when you use a fixed-space font which usually<br>&gt;&gt; doesn&#39;t have non-ASCII characters which are then rendered using a<br>&gt;&gt; different font, making the distinction easy to spot.<br>&gt; <br>&gt; In Russian we have these chars :<br>&gt; —É –∫ –µ –≥ —Ö –∞ —Ä –æ —Å —å<br>&gt; which are similar to english:<br>&gt; y k e r x a p o c b<br>&gt; <br>&gt; So you most likely can&#39;t differ `—Ä–æ—Å` and `poc` , `—Ö–∞–µ` and `xae` etc<br>&gt; <br>&gt; I don&#39;t think compiler should somehow decide if one non-English letter is looks like another English letter. But don&#39;t see any other method to protect myself other than using lints/checking tools for 3rd party code also.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Honestly, this seems to me like a concern for linters and security<br>&gt;&gt;&gt; auditing tools, not for the compiler. Swift identifiers are<br>&gt;&gt;&gt; case-sensitive; I see no reason they shouldn&#39;t be script-sensitive or<br>&gt;&gt;&gt; zero-width-joiner-sensitive. (Though basic Unicode normalization seems<br>&gt;&gt;&gt; like a good idea, since differently-normalized strings are `==`<br>&gt;&gt;&gt; anyway.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- Brent Royal-Gordon Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________ swift-evolution mailing<br>&gt;&gt; list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 28, 2016 at 08:00:00pm</p></header><div class="content"><p>Yes. See earlier in the discussion about the Unicode confusables list. The<br>security issues that arise from confusable URLs aren&#39;t the same as those<br>for identifiers in Swift, and I think the short version of the previous<br>discussion is that prohibiting the use of Greek nu and mathematical bold<br>italic v, for instance, isn&#39;t necessary for security.<br></p><p>Thus, we&#39;re working off of a different Unicode recommendation specifically<br>drawn up for identifier normalization, which does not involve forbidding<br>confusables.<br></p><p>On Tue, Jun 28, 2016 at 14:43 Russ Bishop via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Doesn&#39;t Unicode have a standard for this that specified which characters<br>&gt; are look-alikes?<br>&gt;<br>&gt; Russ<br>&gt;<br>&gt; &gt; On Jun 21, 2016, at 7:48 AM, Vladimir.S via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On 21.06.2016 7:37, Charlie Monroe via swift-evolution wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Jun 21, 2016, at 2:23 AM, Brent Royal-Gordon via swift-evolution<br>&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Perhaps stupid but: why was Swift designed to accept most Unicode<br>&gt; &gt;&gt;&gt;&gt; characters in identifier names? Wouldn‚Äôt it be simpler to go back to<br>&gt; &gt;&gt;&gt;&gt; a model where only standard ascii characters are accepted in<br>&gt; &gt;&gt;&gt;&gt; identifier names?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I assume it has something to do with the fact that 94.6% of the<br>&gt; &gt;&gt;&gt; world&#39;s population speak a first language which is not English. That<br>&gt; &gt;&gt;&gt; outweighs the inconvenience for Anglo developers, IMHO.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Yes, but the SDKs (frameworks, system libraries) are all in English,<br>&gt; &gt;&gt; including Swift standard library. I remember a few languages attempting<br>&gt; &gt;&gt; localized versions for kids to study better, failing terribly because<br>&gt; &gt;&gt; you learned something that had a very very limited use.<br>&gt; &gt;<br>&gt; &gt; Support Charlie&#39;s opinion. For me (as non-native English speaker)<br>&gt; non-ASCII characters in identifiers had no sense, even when I start to tech<br>&gt; the programming when I was a child. Expressions composed from identifiers<br>&gt; written in my native language is not near correct sentences.<br>&gt; &gt;<br>&gt; &gt; Even more, we still have all other parts of language in English -<br>&gt; for-while-guard-let-var-func etc..<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; When it comes to maintaining code, using localized identifier names is a<br>&gt; &gt;&gt; bad practice since anyone outside that country coming to the code can&#39;t<br>&gt; &gt;&gt; really use it. I personally can&#39;t imagine coming to maintain Swift code<br>&gt; &gt;&gt; with identifiers in Chinese, Japanese, Arabic, ...<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; While the feature of non-ASCII characters being allowed as identifiers<br>&gt; &gt;&gt; (which was held up high with Apple giving emoji examples) may seem cool,<br>&gt; &gt;&gt; I can only see this helpful in the future, given a different keyboard<br>&gt; &gt;&gt; layout (as someone has pointed out some time ago here), to introduce<br>&gt; &gt;&gt; one-character operators that would be otherwise impossible. But if<br>&gt; &gt;&gt; someone came to me with a code where a variable would be an emoji of a<br>&gt; &gt;&gt; dog, he&#39;d get fired on the spot.<br>&gt; &gt;<br>&gt; &gt; Yes, but I don&#39;t believe Apple will accept limiting of character set for<br>&gt; identifiers to ASCII *after* these presentations with emoji of a dog ;-)<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;d personally vote to keep the zero-width-joiner characters forbidden<br>&gt; &gt;&gt; within the code outside of string literals (where they may make sense).<br>&gt; &gt;&gt; I agree that this can be easily solved by linters, but: I think this<br>&gt; &gt;&gt; particular set of characters should be restricted by the language<br>&gt; &gt;&gt; itself, since it&#39;s something easily omittable during code review and<br>&gt; &gt;&gt; given the upcoming package manager, this can lead to a hard-to-find<br>&gt; &gt;&gt; malware being distributed among developers who include these packages<br>&gt; &gt;&gt; within their projects - since you usually do not run a linter on a 3rd<br>&gt; &gt;&gt; party code.<br>&gt; &gt;<br>&gt; &gt; I also think the main problem that could be caused by such tricks with<br>&gt; zero-width-joiner or right-to-left-markers is injecting some malware code<br>&gt; into sources in github, in package manager *or* even just in  code snippet<br>&gt; on web page(so you copy-pasted it to your source). Right now I don&#39;t know<br>&gt; exact method to implement such malware code, but I believe this<br>&gt; vulnerability could be used some day.<br>&gt; &gt;<br>&gt; &gt; Btw, regarding the package manager. Will we have any protection from<br>&gt; Typosquatting ?<br>&gt; http://incolumitas.com/2016/06/08/typosquatting-package-managers/#typosquatting-package-managers<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; As for the confusables - this depends a lot on the rendering and what<br>&gt; &gt;&gt; font you have set. I&#39;ve tried  ùõé ‚Üí v with current Xcode and it looks<br>&gt; &gt;&gt; really different, mostly when you use a fixed-space font which usually<br>&gt; &gt;&gt; doesn&#39;t have non-ASCII characters which are then rendered using a<br>&gt; &gt;&gt; different font, making the distinction easy to spot.<br>&gt; &gt;<br>&gt; &gt; In Russian we have these chars :<br>&gt; &gt; —É –∫ –µ –≥ —Ö –∞ —Ä –æ —Å —å<br>&gt; &gt; which are similar to english:<br>&gt; &gt; y k e r x a p o c b<br>&gt; &gt;<br>&gt; &gt; So you most likely can&#39;t differ `—Ä–æ—Å` and `poc` , `—Ö–∞–µ` and `xae` etc<br>&gt; &gt;<br>&gt; &gt; I don&#39;t think compiler should somehow decide if one non-English letter<br>&gt; is looks like another English letter. But don&#39;t see any other method to<br>&gt; protect myself other than using lints/checking tools for 3rd party code<br>&gt; also.<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Honestly, this seems to me like a concern for linters and security<br>&gt; &gt;&gt;&gt; auditing tools, not for the compiler. Swift identifiers are<br>&gt; &gt;&gt;&gt; case-sensitive; I see no reason they shouldn&#39;t be script-sensitive or<br>&gt; &gt;&gt;&gt; zero-width-joiner-sensitive. (Though basic Unicode normalization seems<br>&gt; &gt;&gt;&gt; like a good idea, since differently-normalized strings are `==`<br>&gt; &gt;&gt;&gt; anyway.)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; -- Brent Royal-Gordon Architechies<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt; &gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________ swift-evolution mailing<br>&gt; &gt;&gt; list swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/fb65ada0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 20, 2016 at 05:00:00pm</p></header><div class="content"><p>IIRC, some languages require zero-width joiners (though not zero-width spaces, which are distinct) to properly encode some of their characters. I&#39;d be very leery of having Swift land on a model where identifiers can be used with some languages and not others; that smacks of ethnocentrism.<br></p><p>Jordan<br></p><p><br>&gt; On Jun 20, 2016, at 10:51, Jo√£o Pinheiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Recently there has been a screenshot going around Twitter about C++ allowing zero-width spaces in variable names. Swift also suffers from this problem which can be abused to create ambiguous, misleading, and potentially obfuscate nefarious code.<br>&gt; <br>&gt; I would like to propose a change to prohibit the use of invisible characters in identifier names.<br>&gt; <br>&gt; I&#39;m including an example of problematic code at the bottom of this email.<br>&gt; <br>&gt; Sincerely,<br>&gt; Jo√£o Pinheiro<br>&gt; <br>&gt; <br>&gt; /* The output for this code is:<br>&gt; A<br>&gt; B<br>&gt; C<br>&gt; 1<br>&gt; 2<br>&gt; 3<br>&gt; */<br>&gt; <br>&gt; func test() { print(&quot;A&quot;) }<br>&gt; func t‚Äãest() { print(&quot;B&quot;) }<br>&gt; func te‚Äãst() { print(&quot;C&quot;) }<br>&gt; <br>&gt; let abc = 1<br>&gt; let a‚Äãbc = 2<br>&gt; let ab‚Äãc = 3<br>&gt; <br>&gt; test()<br>&gt; t‚Äãest()<br>&gt; te‚Äãst()<br>&gt; <br>&gt; print(abc)<br>&gt; print(a‚Äãbc)<br>&gt; print(ab‚Äãc)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/376e8c09/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 20, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 20, 2016, at 5:22 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; IIRC, some languages require zero-width joiners (though not zero-width spaces, which are distinct) to properly encode some of their characters. I&#39;d be very leery of having Swift land on a model where identifiers can be used with some languages and not others; that smacks of ethnocentrism.<br></p><p>None of those languages require zero-width characters between two Latin letters, or between a Latin letter and an Arabic numeral, or at the end of a word.  Since standard / system APIs will (barring some radical shift) use those code points exclusively, it&#39;s justifiable to give them some special attention.<br></p><p>John.<br></p><p>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 20, 2016, at 10:51, Jo√£o Pinheiro via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Recently there has been a screenshot going around Twitter about C++ allowing zero-width spaces in variable names. Swift also suffers from this problem which can be abused to create ambiguous, misleading, and potentially obfuscate nefarious code.<br>&gt;&gt; <br>&gt;&gt; I would like to propose a change to prohibit the use of invisible characters in identifier names.<br>&gt;&gt; <br>&gt;&gt; I&#39;m including an example of problematic code at the bottom of this email.<br>&gt;&gt; <br>&gt;&gt; Sincerely,<br>&gt;&gt; Jo√£o Pinheiro<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; /* The output for this code is:<br>&gt;&gt; A<br>&gt;&gt; B<br>&gt;&gt; C<br>&gt;&gt; 1<br>&gt;&gt; 2<br>&gt;&gt; 3<br>&gt;&gt; */<br>&gt;&gt; <br>&gt;&gt; func test() { print(&quot;A&quot;) }<br>&gt;&gt; func t‚Äãest() { print(&quot;B&quot;) }<br>&gt;&gt; func te‚Äãst() { print(&quot;C&quot;) }<br>&gt;&gt; <br>&gt;&gt; let abc = 1<br>&gt;&gt; let a‚Äãbc = 2<br>&gt;&gt; let ab‚Äãc = 3<br>&gt;&gt; <br>&gt;&gt; test()<br>&gt;&gt; t‚Äãest()<br>&gt;&gt; te‚Äãst()<br>&gt;&gt; <br>&gt;&gt; print(abc)<br>&gt;&gt; print(a‚Äãbc)<br>&gt;&gt; print(ab‚Äãc)<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/fcfe88cc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 20, 2016 at 09:00:00pm</p></header><div class="content"><p>On Mon, Jun 20, 2016 at 8:58 PM, John McCall via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Jun 20, 2016, at 5:22 PM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; IIRC, some languages *require* zero-width joiners (though not zero-width<br>&gt; spaces, which are distinct) to properly encode some of their characters.<br>&gt; I&#39;d be very leery of having Swift land on a model where identifiers can be<br>&gt; used with some languages and not others; that smacks of ethnocentrism.<br>&gt;<br>&gt;<br>&gt; None of those languages require zero-width characters between two Latin<br>&gt; letters, or between a Latin letter and an Arabic numeral, or at the end of<br>&gt; a word.  Since standard / system APIs will (barring some radical shift) use<br>&gt; those code points exclusively, it&#39;s justifiable to give them some special<br>&gt; attention.<br>&gt;<br></p><p>Although the practical implementation may need to be more limited in scope,<br>the general principle doesn&#39;t need to privilege Latin letters and Arabic<br>numerals. If, in any context, the presence or absence of a zero-width glyph<br>cannot possibly be distinguished by a human reading the text, then the<br>compiler should also be indifferent to its presence or absence (or,<br>alternatively, its presence should be a compile-time error).<br></p><p><br></p><p>&gt; John.<br>&gt;<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Jun 20, 2016, at 10:51, Jo√£o Pinheiro via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Recently there has been a screenshot going around Twitter about C++<br>&gt; allowing zero-width spaces in variable names. Swift also suffers from this<br>&gt; problem which can be abused to create ambiguous, misleading, and<br>&gt; potentially obfuscate nefarious code.<br>&gt;<br>&gt; I would like to propose a change to prohibit the use of invisible<br>&gt; characters in identifier names.<br>&gt;<br>&gt; I&#39;m including an example of problematic code at the bottom of this email.<br>&gt;<br>&gt; Sincerely,<br>&gt; Jo√£o Pinheiro<br>&gt;<br>&gt;<br>&gt; /* The output for this code is:<br>&gt; A<br>&gt; B<br>&gt; C<br>&gt; 1<br>&gt; 2<br>&gt; 3<br>&gt; */<br>&gt;<br>&gt; func test() { print(&quot;A&quot;) }<br>&gt; func t‚Äãest() { print(&quot;B&quot;) }<br>&gt; func te‚Äãst() { print(&quot;C&quot;) }<br>&gt;<br>&gt; let abc = 1<br>&gt; let a‚Äãbc = 2<br>&gt; let ab‚Äãc = 3<br>&gt;<br>&gt; test()<br>&gt; t‚Äãest()<br>&gt; te‚Äãst()<br>&gt;<br>&gt; print(abc)<br>&gt; print(a‚Äãbc)<br>&gt; print(ab‚Äãc)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/894dbef5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 21, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jun 20, 2016, at 7:07 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; On Mon, Jun 20, 2016 at 8:58 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On Jun 20, 2016, at 5:22 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; IIRC, some languages require zero-width joiners (though not zero-width spaces, which are distinct) to properly encode some of their characters. I&#39;d be very leery of having Swift land on a model where identifiers can be used with some languages and not others; that smacks of ethnocentrism.<br>&gt; <br>&gt; None of those languages require zero-width characters between two Latin letters, or between a Latin letter and an Arabic numeral, or at the end of a word.  Since standard / system APIs will (barring some radical shift) use those code points exclusively, it&#39;s justifiable to give them some special attention.<br>&gt; <br>&gt; Although the practical implementation may need to be more limited in scope, the general principle doesn&#39;t need to privilege Latin letters and Arabic numerals. If, in any context, the presence or absence of a zero-width glyph cannot possibly be distinguished by a human reading the text, then the compiler should also be indifferent to its presence or absence (or, alternatively, its presence should be a compile-time error).<br></p><p>Sure, that&#39;s obvious.  Jordan was observing that the simplest way to enforce that, banning such characters from identifiers completely, would still interfere with some languages, and I was pointing out that just doing enough to protect English would get most of the practical value because it would protect every use of the system and standard library.  A program would then only become attackable in this specific way for its own identifiers using non-Latin characters.<br></p><p>All that said, I&#39;m not convinced that this is worthwhile; the identifier-similarity problem in Unicode is much broader than just invisible characters.  In fact, Swift still doesn&#39;t canonicalize identifiers, so canonically equivalent compositions of the same glyph will actually produce different names.  So unless we&#39;re going to fix that and then ban all sorts of things that are known to generally be represented with a confusable glyph in a typical fixed-width font (like the mathematical alphabets), this is just a problem that will always exist in some form.<br></p><p>John.<br></p><p>&gt; <br>&gt;  <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 20, 2016, at 10:51, Jo√£o Pinheiro via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Recently there has been a screenshot going around Twitter about C++ allowing zero-width spaces in variable names. Swift also suffers from this problem which can be abused to create ambiguous, misleading, and potentially obfuscate nefarious code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would like to propose a change to prohibit the use of invisible characters in identifier names.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m including an example of problematic code at the bottom of this email.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sincerely,<br>&gt;&gt;&gt; Jo√£o Pinheiro<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /* The output for this code is:<br>&gt;&gt;&gt; A<br>&gt;&gt;&gt; B<br>&gt;&gt;&gt; C<br>&gt;&gt;&gt; 1<br>&gt;&gt;&gt; 2<br>&gt;&gt;&gt; 3<br>&gt;&gt;&gt; */<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func test() { print(&quot;A&quot;) }<br>&gt;&gt;&gt; func t‚Äãest() { print(&quot;B&quot;) }<br>&gt;&gt;&gt; func te‚Äãst() { print(&quot;C&quot;) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let abc = 1<br>&gt;&gt;&gt; let a‚Äãbc = 2<br>&gt;&gt;&gt; let ab‚Äãc = 3<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; test()<br>&gt;&gt;&gt; t‚Äãest()<br>&gt;&gt;&gt; te‚Äãst()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(abc)<br>&gt;&gt;&gt; print(a‚Äãbc)<br>&gt;&gt;&gt; print(ab‚Äãc)<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160621/e0e67d6d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>June 21, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 21, 2016, at 8:47 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 20, 2016, at 7:07 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; On Mon, Jun 20, 2016 at 8:58 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Jun 20, 2016, at 5:22 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; IIRC, some languages require zero-width joiners (though not zero-width spaces, which are distinct) to properly encode some of their characters. I&#39;d be very leery of having Swift land on a model where identifiers can be used with some languages and not others; that smacks of ethnocentrism.<br>&gt;&gt; <br>&gt;&gt; None of those languages require zero-width characters between two Latin letters, or between a Latin letter and an Arabic numeral, or at the end of a word.  Since standard / system APIs will (barring some radical shift) use those code points exclusively, it&#39;s justifiable to give them some special attention.<br>&gt;&gt; <br>&gt;&gt; Although the practical implementation may need to be more limited in scope, the general principle doesn&#39;t need to privilege Latin letters and Arabic numerals. If, in any context, the presence or absence of a zero-width glyph cannot possibly be distinguished by a human reading the text, then the compiler should also be indifferent to its presence or absence (or, alternatively, its presence should be a compile-time error).<br>&gt; <br>&gt; Sure, that&#39;s obvious.  Jordan was observing that the simplest way to enforce that, banning such characters from identifiers completely, would still interfere with some languages, and I was pointing out that just doing enough to protect English would get most of the practical value because it would protect every use of the system and standard library.  A program would then only become attackable in this specific way for its own identifiers using non-Latin characters.<br>&gt; <br>&gt; All that said, I&#39;m not convinced that this is worthwhile; the identifier-similarity problem in Unicode is much broader than just invisible characters.  In fact, Swift still doesn&#39;t canonicalize identifiers, so canonically equivalent compositions of the same glyph will actually produce different names.  So unless we&#39;re going to fix that and then ban all sorts of things that are known to generally be represented with a confusable glyph in a typical fixed-width font (like the mathematical alphabets), this is just a problem that will always exist in some form.<br></p><p>Any discussion about this ought to start from UAX #31, the Unicode consortium&#39;s recommendations on identifiers in programming languages:<br></p><p>http://unicode.org/reports/tr31/<br></p><p>Section 2.3 specifically calls out the situations in which ZWJ and ZWNJ need to be allowed. The document also describes a stability policy for handling new Unicode versions, other confusability issues, and many of the other problems with adopting Unicode in a programming language&#39;s syntax.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 21, 2016 at 02:00:00pm</p></header><div class="content"><p>On Tue, Jun 21, 2016 at 1:16 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jun 21, 2016, at 8:47 AM, John McCall via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Jun 20, 2016, at 7:07 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;&gt; On Mon, Jun 20, 2016 at 8:58 PM, John McCall via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt; On Jun 20, 2016, at 5:22 PM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt; IIRC, some languages require zero-width joiners (though not zero-width<br>&gt; spaces, which are distinct) to properly encode some of their characters.<br>&gt; I&#39;d be very leery of having Swift land on a model where identifiers can be<br>&gt; used with some languages and not others; that smacks of ethnocentrism.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; None of those languages require zero-width characters between two Latin<br>&gt; letters, or between a Latin letter and an Arabic numeral, or at the end of<br>&gt; a word.  Since standard / system APIs will (barring some radical shift) use<br>&gt; those code points exclusively, it&#39;s justifiable to give them some special<br>&gt; attention.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Although the practical implementation may need to be more limited in<br>&gt; scope, the general principle doesn&#39;t need to privilege Latin letters and<br>&gt; Arabic numerals. If, in any context, the presence or absence of a<br>&gt; zero-width glyph cannot possibly be distinguished by a human reading the<br>&gt; text, then the compiler should also be indifferent to its presence or<br>&gt; absence (or, alternatively, its presence should be a compile-time error).<br>&gt; &gt;<br>&gt; &gt; Sure, that&#39;s obvious.  Jordan was observing that the simplest way to<br>&gt; enforce that, banning such characters from identifiers completely, would<br>&gt; still interfere with some languages, and I was pointing out that just doing<br>&gt; enough to protect English would get most of the practical value because it<br>&gt; would protect every use of the system and standard library.  A program<br>&gt; would then only become attackable in this specific way for its own<br>&gt; identifiers using non-Latin characters.<br>&gt; &gt;<br>&gt; &gt; All that said, I&#39;m not convinced that this is worthwhile; the<br>&gt; identifier-similarity problem in Unicode is much broader than just<br>&gt; invisible characters.  In fact, Swift still doesn&#39;t canonicalize<br>&gt; identifiers, so canonically equivalent compositions of the same glyph will<br>&gt; actually produce different names.  So unless we&#39;re going to fix that and<br>&gt; then ban all sorts of things that are known to generally be represented<br>&gt; with a confusable glyph in a typical fixed-width font (like the<br>&gt; mathematical alphabets), this is just a problem that will always exist in<br>&gt; some form.<br>&gt;<br>&gt; Any discussion about this ought to start from UAX #31, the Unicode<br>&gt; consortium&#39;s recommendations on identifiers in programming languages:<br>&gt;<br>&gt; http://unicode.org/reports/tr31/<br>&gt;<br>&gt; Section 2.3 specifically calls out the situations in which ZWJ and ZWNJ<br>&gt; need to be allowed. The document also describes a stability policy for<br>&gt; handling new Unicode versions, other confusability issues, and many of the<br>&gt; other problems with adopting Unicode in a programming language&#39;s syntax.<br>&gt;<br></p><p>That&#39;s a fantastic document--a very edifying read. Given Swift&#39;s robust<br>support for Unicode in its core libraries, it&#39;s kind of surprising to me<br>that identifiers aren&#39;t canonicalized at compile time. From a quick first<br>read, faithful adoption of UAX #31 recommendations would address most if<br>not all of the confusability and zero-width security issues raised in this<br>conversation.<br></p><p><br>&gt;<br>&gt; -Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160621/e07d2c39/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 21, 2016 at 09:00:00pm</p></header><div class="content"><p>On Jun 21, 2016, at 12:15 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Any discussion about this ought to start from UAX #31, the Unicode consortium&#39;s recommendations on identifiers in programming languages:<br>&gt; <br>&gt; http://unicode.org/reports/tr31/ &lt;http://unicode.org/reports/tr31/&gt;<br>&gt; <br>&gt; Section 2.3 specifically calls out the situations in which ZWJ and ZWNJ need to be allowed. The document also describes a stability policy for handling new Unicode versions, other confusability issues, and many of the other problems with adopting Unicode in a programming language&#39;s syntax.<br>&gt; <br>&gt; That&#39;s a fantastic document--a very edifying read. Given Swift&#39;s robust support for Unicode in its core libraries, it&#39;s kind of surprising to me that identifiers aren&#39;t canonicalized at compile time. From a quick first read, faithful adoption of UAX #31 recommendations would address most if not all of the confusability and zero-width security issues raised in this conversation.<br>&gt;  <br></p><p>+1<br></p><p>-Chris<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160621/9c75638b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/92adc26e3003cac88ca299a08d35b2b3?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Jo√£o Pinheiro</string> &lt;joao at joaopinheiro.org&gt;<p>June 23, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 21 Jun 2016, at 20:15, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Tue, Jun 21, 2016 at 1:16 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; Any discussion about this ought to start from UAX #31, the Unicode consortium&#39;s recommendations on identifiers in programming languages:<br>&gt; <br>&gt; http://unicode.org/reports/tr31/ &lt;http://unicode.org/reports/tr31/&gt;<br>&gt; <br>&gt; Section 2.3 specifically calls out the situations in which ZWJ and ZWNJ need to be allowed. The document also describes a stability policy for handling new Unicode versions, other confusability issues, and many of the other problems with adopting Unicode in a programming language&#39;s syntax.<br>&gt; <br>&gt; That&#39;s a fantastic document--a very edifying read. Given Swift&#39;s robust support for Unicode in its core libraries, it&#39;s kind of surprising to me that identifiers aren&#39;t canonicalized at compile time. From a quick first read, faithful adoption of UAX #31 recommendations would address most if not all of the confusability and zero-width security issues raised in this conversation.<br></p><p>From what I&#39;ve read of UAX #31 &lt;http://unicode.org/reports/tr31/&gt; it does seem to address all of the invisible character issues raised in the discussion. Given their unicode status of of Default_Ignorable_Code_Points, I believe the best course of action would be to canonicalise identifiers by allowing invisible characters only where appropriate and ignoring them everywhere else.<br></p><p>The alternative to ignoring them would be to not canonicalise identifiers and treat invisible characters as an error instead.<br></p><p>This doesn&#39;t address the issue of unicode confusable characters, but solving that has additional problems of its own and would probably be better addressed in a different proposal entirely.<br></p><p>I&#39;d like to start writing the proposal if there is agreement that this would be the best course of action.<br></p><p>Sincerely,<br>Jo√£o Pinheiro<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/0e315e13/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 23, 2016 at 11:00:00am</p></header><div class="content"><p>I‚Äôm no unicode expert, but this sounds like the way to go to me.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jun 23, 2016, at 11:17 AM, Jo√£o Pinheiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 21 Jun 2016, at 20:15, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Tue, Jun 21, 2016 at 1:16 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; Any discussion about this ought to start from UAX #31, the Unicode consortium&#39;s recommendations on identifiers in programming languages:<br>&gt;&gt; <br>&gt;&gt; http://unicode.org/reports/tr31/<br>&gt;&gt; <br>&gt;&gt; Section 2.3 specifically calls out the situations in which ZWJ and ZWNJ need to be allowed. The document also describes a stability policy for handling new Unicode versions, other confusability issues, and many of the other problems with adopting Unicode in a programming language&#39;s syntax.<br>&gt;&gt; <br>&gt;&gt; That&#39;s a fantastic document--a very edifying read. Given Swift&#39;s robust support for Unicode in its core libraries, it&#39;s kind of surprising to me that identifiers aren&#39;t canonicalized at compile time. From a quick first read, faithful adoption of UAX #31 recommendations would address most if not all of the confusability and zero-width security issues raised in this conversation.<br>&gt; <br>&gt; From what I&#39;ve read of UAX #31 it does seem to address all of the invisible character issues raised in the discussion. Given their unicode status of of Default_Ignorable_Code_Points, I believe the best course of action would be to canonicalise identifiers by allowing invisible characters only where appropriate and ignoring them everywhere else.<br>&gt; <br>&gt; The alternative to ignoring them would be to not canonicalise identifiers and treat invisible characters as an error instead.<br>&gt; <br>&gt; This doesn&#39;t address the issue of unicode confusable characters, but solving that has additional problems of its own and would probably be better addressed in a different proposal entirely.<br>&gt; <br>&gt; I&#39;d like to start writing the proposal if there is agreement that this would be the best course of action.<br>&gt; <br>&gt; Sincerely,<br>&gt; Jo√£o Pinheiro<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 23, 2016 at 04:00:00pm</p></header><div class="content"><p>I think this issue is bigger than that. As UAX #31 suggests, the most<br>appropriate approach is canonicalizing identifiers by NFC, with specific<br>treatment of ZWJ and ZWNJ by allowing them in three contexts, which will<br>require thought as to how to implement.<br></p><p>Given that there is a specifically recommended algorithm on how to handle<br>this issue, I&#39;m also not sure anymore that this requires a proposal;<br>&quot;process Unicode correctly&quot; is really more of a bug fix because, given the<br>strict limits of what&#39;s canonicalized, there shouldn&#39;t be a user-facing<br>effect if we are merely proposing to prohibit glyphs from appearing in<br>certain contexts where they are never in fact encountered in real language.<br></p><p>On Thu, Jun 23, 2016 at 11:19 AM Sean Heber &lt;sean at fifthace.com&gt; wrote:<br></p><p>&gt; I‚Äôm no unicode expert, but this sounds like the way to go to me.<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt; &gt; On Jun 23, 2016, at 11:17 AM, Jo√£o Pinheiro via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On 21 Jun 2016, at 20:15, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Tue, Jun 21, 2016 at 1:16 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;&gt; Any discussion about this ought to start from UAX #31, the Unicode<br>&gt; consortium&#39;s recommendations on identifiers in programming languages:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; http://unicode.org/reports/tr31/<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Section 2.3 specifically calls out the situations in which ZWJ and ZWNJ<br>&gt; need to be allowed. The document also describes a stability policy for<br>&gt; handling new Unicode versions, other confusability issues, and many of the<br>&gt; other problems with adopting Unicode in a programming language&#39;s syntax.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; That&#39;s a fantastic document--a very edifying read. Given Swift&#39;s robust<br>&gt; support for Unicode in its core libraries, it&#39;s kind of surprising to me<br>&gt; that identifiers aren&#39;t canonicalized at compile time. From a quick first<br>&gt; read, faithful adoption of UAX #31 recommendations would address most if<br>&gt; not all of the confusability and zero-width security issues raised in this<br>&gt; conversation.<br>&gt; &gt;<br>&gt; &gt; From what I&#39;ve read of UAX #31 it does seem to address all of the<br>&gt; invisible character issues raised in the discussion. Given their unicode<br>&gt; status of of Default_Ignorable_Code_Points, I believe the best course of<br>&gt; action would be to canonicalise identifiers by allowing invisible<br>&gt; characters only where appropriate and ignoring them everywhere else.<br>&gt; &gt;<br>&gt; &gt; The alternative to ignoring them would be to not canonicalise<br>&gt; identifiers and treat invisible characters as an error instead.<br>&gt; &gt;<br>&gt; &gt; This doesn&#39;t address the issue of unicode confusable characters, but<br>&gt; solving that has additional problems of its own and would probably be<br>&gt; better addressed in a different proposal entirely.<br>&gt; &gt;<br>&gt; &gt; I&#39;d like to start writing the proposal if there is agreement that this<br>&gt; would be the best course of action.<br>&gt; &gt;<br>&gt; &gt; Sincerely,<br>&gt; &gt; Jo√£o Pinheiro<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/400bd8d4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/92adc26e3003cac88ca299a08d35b2b3?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Jo√£o Pinheiro</string> &lt;joao at joaopinheiro.org&gt;<p>June 23, 2016 at 06:00:00pm</p></header><div class="content"><p>There are two different issues here, individual character normalisation and identifier canonicalisation. NFC handles character normalisation and it definitely should be part of the proposal since identifier canonicalisation doesn&#39;t make sense if the individual character representation isn&#39;t normalised first.<br></p><p>Swift currently doesn&#39;t normalise unicode characters, as can be seen in the following code example:<br></p><p>let ‚Ñ´ = &quot;Hello&quot; // Angstrom<br>let √Ö = &quot;Swift&quot; // Latin Capital Letter A With Ring Above<br>let √Ö = &quot;World&quot; // Latin Capital Letter A + Combining Ring Above<br></p><p>print(‚Ñ´)<br>print(√Ö)<br>print(√Ö)<br></p><p>According to the unicode standard, all 3 of these characters should be normalised into the same representation.<br></p><p>Sincerely,<br>Jo√£o Pinheiro<br></p><p><br>&gt; On 23 Jun 2016, at 17:40, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think this issue is bigger than that. As UAX #31 suggests, the most appropriate approach is canonicalizing identifiers by NFC, with specific treatment of ZWJ and ZWNJ by allowing them in three contexts, which will require thought as to how to implement.<br>&gt; <br>&gt; Given that there is a specifically recommended algorithm on how to handle this issue, I&#39;m also not sure anymore that this requires a proposal; &quot;process Unicode correctly&quot; is really more of a bug fix because, given the strict limits of what&#39;s canonicalized, there shouldn&#39;t be a user-facing effect if we are merely proposing to prohibit glyphs from appearing in certain contexts where they are never in fact encountered in real language.<br>&gt; <br>&gt; On Thu, Jun 23, 2016 at 11:19 AM Sean Heber &lt;sean at fifthace.com &lt;mailto:sean at fifthace.com&gt;&gt; wrote:<br>&gt; I‚Äôm no unicode expert, but this sounds like the way to go to me.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt; &gt; On Jun 23, 2016, at 11:17 AM, Jo√£o Pinheiro via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On 21 Jun 2016, at 20:15, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Tue, Jun 21, 2016 at 1:16 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; &gt;&gt; Any discussion about this ought to start from UAX #31, the Unicode consortium&#39;s recommendations on identifiers in programming languages:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; http://unicode.org/reports/tr31/ &lt;http://unicode.org/reports/tr31/&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Section 2.3 specifically calls out the situations in which ZWJ and ZWNJ need to be allowed. The document also describes a stability policy for handling new Unicode versions, other confusability issues, and many of the other problems with adopting Unicode in a programming language&#39;s syntax.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; That&#39;s a fantastic document--a very edifying read. Given Swift&#39;s robust support for Unicode in its core libraries, it&#39;s kind of surprising to me that identifiers aren&#39;t canonicalized at compile time. From a quick first read, faithful adoption of UAX #31 recommendations would address most if not all of the confusability and zero-width security issues raised in this conversation.<br>&gt; &gt;<br>&gt; &gt; From what I&#39;ve read of UAX #31 it does seem to address all of the invisible character issues raised in the discussion. Given their unicode status of of Default_Ignorable_Code_Points, I believe the best course of action would be to canonicalise identifiers by allowing invisible characters only where appropriate and ignoring them everywhere else.<br>&gt; &gt;<br>&gt; &gt; The alternative to ignoring them would be to not canonicalise identifiers and treat invisible characters as an error instead.<br>&gt; &gt;<br>&gt; &gt; This doesn&#39;t address the issue of unicode confusable characters, but solving that has additional problems of its own and would probably be better addressed in a different proposal entirely.<br>&gt; &gt;<br>&gt; &gt; I&#39;d like to start writing the proposal if there is agreement that this would be the best course of action.<br>&gt; &gt;<br>&gt; &gt; Sincerely,<br>&gt; &gt; Jo√£o Pinheiro<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/c285997f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 23, 2016 at 12:00:00pm</p></header><div class="content"><p>On Thu, Jun 23, 2016 at 12:41 PM, Jo√£o Pinheiro &lt;joao at joaopinheiro.org&gt;<br>wrote:<br></p><p>&gt; There are two different issues here, individual character normalisation<br>&gt; and identifier canonicalisation. NFC handles character normalisation and it<br>&gt; definitely should be part of the proposal since identifier canonicalisation<br>&gt; doesn&#39;t make sense if the individual character representation isn&#39;t<br>&gt; normalised first.<br>&gt;<br></p><p>I think we&#39;re using terminology differently here. What you call &quot;character<br>normalization&quot; is what I&#39;m calling canonicalization. NFC is described in<br>UAX #15 as &quot;canonical decomposition followed by canonical composition&quot; and<br>I&#39;m just using the word &quot;canonicalization&quot; because it&#39;s shorter. If Swift<br>represents each identifier in an NFC-transformed form (what I call<br>canonicalized), then I understand the identifier to be canonicalized. What<br>is the distinction you&#39;re drawing here?<br></p><p><br>&gt;<br>&gt; Swift currently doesn&#39;t normalise unicode characters, as can be seen in<br>&gt; the following code example:<br>&gt;<br>&gt; let ‚Ñ´ = &quot;Hello&quot; // Angstrom<br>&gt; let √Ö = &quot;Swift&quot; // Latin Capital Letter A With Ring Above<br>&gt; let √Ö = &quot;World&quot; // Latin Capital Letter A + Combining Ring Above<br>&gt;<br>&gt; print(‚Ñ´)<br>&gt; print(√Ö)<br>&gt; print(√Ö)<br>&gt;<br>&gt; According to the unicode standard, all 3 of these characters should be<br>&gt; normalised into the same representation.<br>&gt;<br>&gt; Sincerely,<br>&gt; Jo√£o Pinheiro<br>&gt;<br>&gt;<br>&gt; On 23 Jun 2016, at 17:40, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; I think this issue is bigger than that. As UAX #31 suggests, the most<br>&gt; appropriate approach is canonicalizing identifiers by NFC, with specific<br>&gt; treatment of ZWJ and ZWNJ by allowing them in three contexts, which will<br>&gt; require thought as to how to implement.<br>&gt;<br>&gt; Given that there is a specifically recommended algorithm on how to handle<br>&gt; this issue, I&#39;m also not sure anymore that this requires a proposal;<br>&gt; &quot;process Unicode correctly&quot; is really more of a bug fix because, given the<br>&gt; strict limits of what&#39;s canonicalized, there shouldn&#39;t be a user-facing<br>&gt; effect if we are merely proposing to prohibit glyphs from appearing in<br>&gt; certain contexts where they are never in fact encountered in real language.<br>&gt;<br>&gt; On Thu, Jun 23, 2016 at 11:19 AM Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;<br>&gt;&gt; I‚Äôm no unicode expert, but this sounds like the way to go to me.<br>&gt;&gt;<br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Jun 23, 2016, at 11:17 AM, Jo√£o Pinheiro via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On 21 Jun 2016, at 20:15, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; On Tue, Jun 21, 2016 at 1:16 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; &gt;&gt; Any discussion about this ought to start from UAX #31, the Unicode<br>&gt;&gt; consortium&#39;s recommendations on identifiers in programming languages:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; http://unicode.org/reports/tr31/<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Section 2.3 specifically calls out the situations in which ZWJ and<br>&gt;&gt; ZWNJ need to be allowed. The document also describes a stability policy for<br>&gt;&gt; handling new Unicode versions, other confusability issues, and many of the<br>&gt;&gt; other problems with adopting Unicode in a programming language&#39;s syntax.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; That&#39;s a fantastic document--a very edifying read. Given Swift&#39;s<br>&gt;&gt; robust support for Unicode in its core libraries, it&#39;s kind of surprising<br>&gt;&gt; to me that identifiers aren&#39;t canonicalized at compile time. From a quick<br>&gt;&gt; first read, faithful adoption of UAX #31 recommendations would address most<br>&gt;&gt; if not all of the confusability and zero-width security issues raised in<br>&gt;&gt; this conversation.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; From what I&#39;ve read of UAX #31 it does seem to address all of the<br>&gt;&gt; invisible character issues raised in the discussion. Given their unicode<br>&gt;&gt; status of of Default_Ignorable_Code_Points, I believe the best course of<br>&gt;&gt; action would be to canonicalise identifiers by allowing invisible<br>&gt;&gt; characters only where appropriate and ignoring them everywhere else.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The alternative to ignoring them would be to not canonicalise<br>&gt;&gt; identifiers and treat invisible characters as an error instead.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This doesn&#39;t address the issue of unicode confusable characters, but<br>&gt;&gt; solving that has additional problems of its own and would probably be<br>&gt;&gt; better addressed in a different proposal entirely.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;d like to start writing the proposal if there is agreement that this<br>&gt;&gt; would be the best course of action.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Sincerely,<br>&gt;&gt; &gt; Jo√£o Pinheiro<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/63e8e575/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 23, 2016 at 01:00:00pm</p></header><div class="content"><p>On Thu, Jun 23, 2016 at 12:56 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; On Thu, Jun 23, 2016 at 12:41 PM, Jo√£o Pinheiro &lt;joao at joaopinheiro.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; There are two different issues here, individual character normalisation<br>&gt;&gt; and identifier canonicalisation. NFC handles character normalisation and it<br>&gt;&gt; definitely should be part of the proposal since identifier canonicalisation<br>&gt;&gt; doesn&#39;t make sense if the individual character representation isn&#39;t<br>&gt;&gt; normalised first.<br>&gt;&gt;<br>&gt;<br>&gt; I think we&#39;re using terminology differently here. What you call &quot;character<br>&gt; normalization&quot; is what I&#39;m calling canonicalization. NFC is described in<br>&gt; UAX #15 as &quot;canonical decomposition followed by canonical composition&quot; and<br>&gt; I&#39;m just using the word &quot;canonicalization&quot; because it&#39;s shorter. If Swift<br>&gt; represents each identifier in an NFC-transformed form (what I call<br>&gt; canonicalized), then I understand the identifier to be canonicalized. What<br>&gt; is the distinction you&#39;re drawing here?<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Swift currently doesn&#39;t normalise unicode characters, as can be seen in<br>&gt;&gt; the following code example:<br>&gt;&gt;<br>&gt;&gt; let ‚Ñ´ = &quot;Hello&quot; // Angstrom<br>&gt;&gt; let √Ö = &quot;Swift&quot; // Latin Capital Letter A With Ring Above<br>&gt;&gt; let √Ö = &quot;World&quot; // Latin Capital Letter A + Combining Ring Above<br>&gt;&gt;<br>&gt;&gt; print(‚Ñ´)<br>&gt;&gt; print(√Ö)<br>&gt;&gt; print(√Ö)<br>&gt;&gt;<br>&gt;&gt; According to the unicode standard, all 3 of these characters should be<br>&gt;&gt; normalised into the same representation.<br>&gt;&gt;<br>&gt;&gt;<br>Just re-read UAX #31. I see two different issues here too--do these match<br>up with what you&#39;re saying above?<br></p><p>* Disallowing certain glyphs in identifiers. To do so, we can implement the<br>recommendation to disallow all glyphs in UAX #31 Table 4, except ZWJ and<br>ZWNJ in the specific scenarios outlined in section 2.3.<br></p><p>* Internally, when comparing two identifiers A and B, compare NFC(A) and<br>NFC(B) without modifying or otherwise restricting the actual user-facing<br>code to contain only NFC-normalized strings. This would be the approach<br>recommended in section 1.3.<br></p><p><br>&gt; Sincerely,<br>&gt;&gt; Jo√£o Pinheiro<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 23 Jun 2016, at 17:40, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I think this issue is bigger than that. As UAX #31 suggests, the most<br>&gt;&gt; appropriate approach is canonicalizing identifiers by NFC, with specific<br>&gt;&gt; treatment of ZWJ and ZWNJ by allowing them in three contexts, which will<br>&gt;&gt; require thought as to how to implement.<br>&gt;&gt;<br>&gt;&gt; Given that there is a specifically recommended algorithm on how to handle<br>&gt;&gt; this issue, I&#39;m also not sure anymore that this requires a proposal;<br>&gt;&gt; &quot;process Unicode correctly&quot; is really more of a bug fix because, given the<br>&gt;&gt; strict limits of what&#39;s canonicalized, there shouldn&#39;t be a user-facing<br>&gt;&gt; effect if we are merely proposing to prohibit glyphs from appearing in<br>&gt;&gt; certain contexts where they are never in fact encountered in real language.<br>&gt;&gt;<br>&gt;&gt; On Thu, Jun 23, 2016 at 11:19 AM Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I‚Äôm no unicode expert, but this sounds like the way to go to me.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; l8r<br>&gt;&gt;&gt; Sean<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Jun 23, 2016, at 11:17 AM, Jo√£o Pinheiro via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; On 21 Jun 2016, at 20:15, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; On Tue, Jun 21, 2016 at 1:16 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt; Any discussion about this ought to start from UAX #31, the Unicode<br>&gt;&gt;&gt; consortium&#39;s recommendations on identifiers in programming languages:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; http://unicode.org/reports/tr31/<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Section 2.3 specifically calls out the situations in which ZWJ and<br>&gt;&gt;&gt; ZWNJ need to be allowed. The document also describes a stability policy for<br>&gt;&gt;&gt; handling new Unicode versions, other confusability issues, and many of the<br>&gt;&gt;&gt; other problems with adopting Unicode in a programming language&#39;s syntax.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; That&#39;s a fantastic document--a very edifying read. Given Swift&#39;s<br>&gt;&gt;&gt; robust support for Unicode in its core libraries, it&#39;s kind of surprising<br>&gt;&gt;&gt; to me that identifiers aren&#39;t canonicalized at compile time. From a quick<br>&gt;&gt;&gt; first read, faithful adoption of UAX #31 recommendations would address most<br>&gt;&gt;&gt; if not all of the confusability and zero-width security issues raised in<br>&gt;&gt;&gt; this conversation.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; From what I&#39;ve read of UAX #31 it does seem to address all of the<br>&gt;&gt;&gt; invisible character issues raised in the discussion. Given their unicode<br>&gt;&gt;&gt; status of of Default_Ignorable_Code_Points, I believe the best course of<br>&gt;&gt;&gt; action would be to canonicalise identifiers by allowing invisible<br>&gt;&gt;&gt; characters only where appropriate and ignoring them everywhere else.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The alternative to ignoring them would be to not canonicalise<br>&gt;&gt;&gt; identifiers and treat invisible characters as an error instead.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; This doesn&#39;t address the issue of unicode confusable characters, but<br>&gt;&gt;&gt; solving that has additional problems of its own and would probably be<br>&gt;&gt;&gt; better addressed in a different proposal entirely.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I&#39;d like to start writing the proposal if there is agreement that this<br>&gt;&gt;&gt; would be the best course of action.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Sincerely,<br>&gt;&gt;&gt; &gt; Jo√£o Pinheiro<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/9975c49c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/92adc26e3003cac88ca299a08d35b2b3?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Jo√£o Pinheiro</string> &lt;joao at joaopinheiro.org&gt;<p>June 23, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; I think we&#39;re using terminology differently here. What you call &quot;character normalization&quot; is what I&#39;m calling canonicalization. NFC is described in UAX #15 as &quot;canonical decomposition followed by canonical composition&quot; and I&#39;m just using the word &quot;canonicalization&quot; because it&#39;s shorter. If Swift represents each identifier in an NFC-transformed form (what I call canonicalized), then I understand the identifier to be canonicalized. What is the distinction you&#39;re drawing here?<br></p><p>There is a small difference between normalisation and canonicalisation, but it&#39;s mostly splitting hairs. They both ensure something is represented properly, but canonicalisation implies establishing a single base representation for something. Web addresses are a good example. Both http://www.apple.com and http://apple.com are valid normalised addresses, but only the former is the canonical address for the Apple website.<br></p><p>&gt; Just re-read UAX #31. I see two different issues here too--do these match up with what you&#39;re saying above?<br>&gt; <br>&gt; * Disallowing certain glyphs in identifiers. To do so, we can implement the recommendation to disallow all glyphs in UAX #31 Table 4, except ZWJ and ZWNJ in the specific scenarios outlined in section 2.3.<br>&gt; <br>&gt; * Internally, when comparing two identifiers A and B, compare NFC(A) and NFC(B) without modifying or otherwise restricting the actual user-facing code to contain only NFC-normalized strings. This would be the approach recommended in section 1.3.<br></p><p>Yes, that&#39;s correct. The proposal would be to normalise the encoding via NFC and then canonicalise the identifiers by ignoring invisible characters except in the scenarios described in UAX #31.<br></p><p>Sincerely,<br>Jo√£o Pinheiro<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 23, 2016 at 02:00:00pm</p></header><div class="content"><p>On Thu, Jun 23, 2016 at 2:29 PM, Jo√£o Pinheiro &lt;joao at joaopinheiro.org&gt;<br>wrote:<br></p><p>&gt; &gt; I think we&#39;re using terminology differently here. What you call<br>&gt; &quot;character normalization&quot; is what I&#39;m calling canonicalization. NFC is<br>&gt; described in UAX #15 as &quot;canonical decomposition followed by canonical<br>&gt; composition&quot; and I&#39;m just using the word &quot;canonicalization&quot; because it&#39;s<br>&gt; shorter. If Swift represents each identifier in an NFC-transformed form<br>&gt; (what I call canonicalized), then I understand the identifier to be<br>&gt; canonicalized. What is the distinction you&#39;re drawing here?<br>&gt;<br>&gt; There is a small difference between normalisation and canonicalisation,<br>&gt; but it&#39;s mostly splitting hairs. They both ensure something is represented<br>&gt; properly, but canonicalisation implies establishing a single base<br>&gt; representation for something. Web addresses are a good example. Both<br>&gt; http://www.apple.com and http://apple.com are valid normalised addresses,<br>&gt; but only the former is the canonical address for the Apple website.<br>&gt;<br>&gt; &gt; Just re-read UAX #31. I see two different issues here too--do these<br>&gt; match up with what you&#39;re saying above?<br>&gt; &gt;<br>&gt; &gt; * Disallowing certain glyphs in identifiers. To do so, we can implement<br>&gt; the recommendation to disallow all glyphs in UAX #31 Table 4, except ZWJ<br>&gt; and ZWNJ in the specific scenarios outlined in section 2.3.<br>&gt; &gt;<br>&gt; &gt; * Internally, when comparing two identifiers A and B, compare NFC(A) and<br>&gt; NFC(B) without modifying or otherwise restricting the actual user-facing<br>&gt; code to contain only NFC-normalized strings. This would be the approach<br>&gt; recommended in section 1.3.<br>&gt;<br>&gt; Yes, that&#39;s correct. The proposal would be to normalise the encoding via<br>&gt; NFC and then canonicalise the identifiers by ignoring invisible characters<br>&gt; except in the scenarios described in UAX #31<br></p><p><br>That&#39;s cool, although my preferred solution would be more closely aligned<br>with UAX #31: overtly disallow the glyphs in Table 4 (instead of ignoring<br>them) except in the specific scenarios for ZWJ and ZWNJ identified in UAX<br>#31, then afterwards internally represent the identifier as its<br>NFC-normalized string.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/28afc03d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/92adc26e3003cac88ca299a08d35b2b3?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Jo√£o Pinheiro</string> &lt;joao at joaopinheiro.org&gt;<p>June 23, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 23 Jun 2016, at 20:43, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; That&#39;s cool, although my preferred solution would be more closely aligned with UAX #31: overtly disallow the glyphs in Table 4 (instead of ignoring them) except in the specific scenarios for ZWJ and ZWNJ identified in UAX #31, then afterwards internally represent the identifier as its NFC-normalized string.<br></p><p>Explicitly disallowing them was my initial idea, but I think it would end up being a confusing error for users to encounter. Ignoring the invisible characters and leaving it up to a linter to remove them is less likely to cause confusion for users.<br></p><p>I&#39;ll be sure to describe the alternative of explicitly prohibiting them in the proposal though.<br></p><p>Sincerely,<br>Jo√£o Pinheiro<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e439b0f8beb3222a8b44f40eecee259a?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Josh Wisenbaker</string> &lt;macshome at mac.com&gt;<p>June 23, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 3:54 PM, Jo√£o Pinheiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On 23 Jun 2016, at 20:43, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; That&#39;s cool, although my preferred solution would be more closely aligned with UAX #31: overtly disallow the glyphs in Table 4 (instead of ignoring them) except in the specific scenarios for ZWJ and ZWNJ identified in UAX #31, then afterwards internally represent the identifier as its NFC-normalized string.<br>&gt; <br>&gt; Explicitly disallowing them was my initial idea, but I think it would end up being a confusing error for users to encounter. Ignoring the invisible characters and leaving it up to a linter to remove them is less likely to cause confusion for users.<br></p><p>Allowing invisibles has already resulted in being able to do things like this which is intensely confusing to say the very least. <br></p><p><br></p><p>Josh<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/3c4d8b0a/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: Messages Image(763472166).png<br>Type: image/png<br>Size: 23442 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/3c4d8b0a/attachment.png&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4103 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/3c4d8b0a/attachment.p7s&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 23, 2016 at 03:00:00pm</p></header><div class="content"><p>On Thu, Jun 23, 2016 at 2:54 PM, Jo√£o Pinheiro &lt;joao at joaopinheiro.org&gt;<br>wrote:<br></p><p>&gt;<br>&gt; &gt; On 23 Jun 2016, at 20:43, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt; That&#39;s cool, although my preferred solution would be more closely<br>&gt; aligned with UAX #31: overtly disallow the glyphs in Table 4 (instead of<br>&gt; ignoring them) except in the specific scenarios for ZWJ and ZWNJ identified<br>&gt; in UAX #31, then afterwards internally represent the identifier as its<br>&gt; NFC-normalized string.<br>&gt;<br>&gt; Explicitly disallowing them was my initial idea, but I think it would end<br>&gt; up being a confusing error for users to encounter. Ignoring the invisible<br>&gt; characters and leaving it up to a linter to remove them is less likely to<br>&gt; cause confusion for users.<br>&gt;<br>&gt; I&#39;ll be sure to describe the alternative of explicitly prohibiting them in<br>&gt; the proposal though.<br>&gt;<br></p><p>I would strongly urge you to propose explicitly prohibiting them just as<br>UAX #31 recommends. Their reasoning is that these characters, which include<br>those that reverse text direction or control joining, can cause one<br>identifier to be maliciously changed to look like another. If you ignore<br>these characters instead of prohibiting them, an identifier that visually<br>appears as one string could in fact be a different one to the compiler.<br></p><p>Moreover, a compiler error can be made helpful by saying that the offending<br>character is potentially invisible and it can come with a fix-it to remove<br>the offending character. I don&#39;t think that would confuse the user at all.<br>It would be more confusing if invisible characters that caused one thing to<br>look identical to another were silently permitted.<br></p><p><br>&gt; Sincerely,<br>&gt; Jo√£o Pinheiro<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/925383c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 23, 2016 at 03:00:00pm</p></header><div class="content"><p>+1<br>I didn&#39;t even know there were any invisible characters until this thread came up.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jun 23, 2016, at 15:13, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Thu, Jun 23, 2016 at 2:54 PM, Jo√£o Pinheiro &lt;joao at joaopinheiro.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On 23 Jun 2016, at 20:43, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; &gt; That&#39;s cool, although my preferred solution would be more closely aligned with UAX #31: overtly disallow the glyphs in Table 4 (instead of ignoring them) except in the specific scenarios for ZWJ and ZWNJ identified in UAX #31, then afterwards internally represent the identifier as its NFC-normalized string.<br>&gt;&gt; <br>&gt;&gt; Explicitly disallowing them was my initial idea, but I think it would end up being a confusing error for users to encounter. Ignoring the invisible characters and leaving it up to a linter to remove them is less likely to cause confusion for users.<br>&gt;&gt; <br>&gt;&gt; I&#39;ll be sure to describe the alternative of explicitly prohibiting them in the proposal though.<br>&gt; <br>&gt; I would strongly urge you to propose explicitly prohibiting them just as UAX #31 recommends. Their reasoning is that these characters, which include those that reverse text direction or control joining, can cause one identifier to be maliciously changed to look like another. If you ignore these characters instead of prohibiting them, an identifier that visually appears as one string could in fact be a different one to the compiler.<br>&gt; <br>&gt; Moreover, a compiler error can be made helpful by saying that the offending character is potentially invisible and it can come with a fix-it to remove the offending character. I don&#39;t think that would confuse the user at all. It would be more confusing if invisible characters that caused one thing to look identical to another were silently permitted.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Sincerely,<br>&gt;&gt; Jo√£o Pinheiro<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/27fc9c45/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/063adc064d3d040fcbfba0265019aecd?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>James Hillhouse</string> &lt;jdhillhouse4 at icloud.com&gt;<p>June 23, 2016 at 03:00:00pm</p></header><div class="content"><p>+1 on this. Josh Wisenbaker‚Äôs example says enough. Yikes!<br></p><p>&gt; On Jun 23, 2016, at 3:18 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt; I didn&#39;t even know there were any invisible characters until this thread came up.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt; On Jun 23, 2016, at 15:13, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Thu, Jun 23, 2016 at 2:54 PM, Jo√£o Pinheiro &lt;joao at joaopinheiro.org &lt;mailto:joao at joaopinheiro.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On 23 Jun 2016, at 20:43, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; &gt; That&#39;s cool, although my preferred solution would be more closely aligned with UAX #31: overtly disallow the glyphs in Table 4 (instead of ignoring them) except in the specific scenarios for ZWJ and ZWNJ identified in UAX #31, then afterwards internally represent the identifier as its NFC-normalized string.<br>&gt;&gt; <br>&gt;&gt; Explicitly disallowing them was my initial idea, but I think it would end up being a confusing error for users to encounter. Ignoring the invisible characters and leaving it up to a linter to remove them is less likely to cause confusion for users.<br>&gt;&gt; <br>&gt;&gt; I&#39;ll be sure to describe the alternative of explicitly prohibiting them in the proposal though.<br>&gt;&gt; <br>&gt;&gt; I would strongly urge you to propose explicitly prohibiting them just as UAX #31 recommends. Their reasoning is that these characters, which include those that reverse text direction or control joining, can cause one identifier to be maliciously changed to look like another. If you ignore these characters instead of prohibiting them, an identifier that visually appears as one string could in fact be a different one to the compiler.<br>&gt;&gt; <br>&gt;&gt; Moreover, a compiler error can be made helpful by saying that the offending character is potentially invisible and it can come with a fix-it to remove the offending character. I don&#39;t think that would confuse the user at all. It would be more confusing if invisible characters that caused one thing to look identical to another were silently permitted.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sincerely,<br>&gt;&gt; Jo√£o Pinheiro<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/0a4c0f4d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 23, 2016 at 08:00:00pm</p></header><div class="content"><p>FWIW, Josh&#39;s example would be fixed whether we prohibit or ignore invisible<br>characters, but there are other potential strings for which prohibition<br>would be more secure.<br></p><p>On Thu, Jun 23, 2016 at 15:27 James Hillhouse &lt;jdhillhouse4 at icloud.com&gt;<br>wrote:<br></p><p>&gt; +1 on this. Josh Wisenbaker‚Äôs example says enough. Yikes!<br>&gt;<br>&gt; On Jun 23, 2016, at 3:18 PM, David Sweeris via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; +1<br>&gt; I didn&#39;t even know there were any invisible characters until this thread<br>&gt; came up.<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>&gt; On Jun 23, 2016, at 15:13, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Thu, Jun 23, 2016 at 2:54 PM, Jo√£o Pinheiro &lt;joao at joaopinheiro.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On 23 Jun 2016, at 20:43, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; &gt; That&#39;s cool, although my preferred solution would be more closely<br>&gt;&gt; aligned with UAX #31: overtly disallow the glyphs in Table 4 (instead of<br>&gt;&gt; ignoring them) except in the specific scenarios for ZWJ and ZWNJ identified<br>&gt;&gt; in UAX #31, then afterwards internally represent the identifier as its<br>&gt;&gt; NFC-normalized string.<br>&gt;&gt;<br>&gt;&gt; Explicitly disallowing them was my initial idea, but I think it would end<br>&gt;&gt; up being a confusing error for users to encounter. Ignoring the invisible<br>&gt;&gt; characters and leaving it up to a linter to remove them is less likely to<br>&gt;&gt; cause confusion for users.<br>&gt;&gt;<br>&gt;&gt; I&#39;ll be sure to describe the alternative of explicitly prohibiting them<br>&gt;&gt; in the proposal though.<br>&gt;&gt;<br>&gt;<br>&gt; I would strongly urge you to propose explicitly prohibiting them just as<br>&gt; UAX #31 recommends. Their reasoning is that these characters, which include<br>&gt; those that reverse text direction or control joining, can cause one<br>&gt; identifier to be maliciously changed to look like another. If you ignore<br>&gt; these characters instead of prohibiting them, an identifier that visually<br>&gt; appears as one string could in fact be a different one to the compiler.<br>&gt;<br>&gt; Moreover, a compiler error can be made helpful by saying that the<br>&gt; offending character is potentially invisible and it can come with a fix-it<br>&gt; to remove the offending character. I don&#39;t think that would confuse the<br>&gt; user at all. It would be more confusing if invisible characters that caused<br>&gt; one thing to look identical to another were silently permitted.<br>&gt;<br>&gt;<br>&gt;&gt; Sincerely,<br>&gt;&gt; Jo√£o Pinheiro<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/8ce53e49/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/063adc064d3d040fcbfba0265019aecd?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>James Hillhouse</string> &lt;jdhillhouse4 at icloud.com&gt;<p>June 23, 2016 at 03:00:00pm</p></header><div class="content"><p>Thanks Xiaodi. That‚Äôs a relief to know.<br></p><p><br>&gt; On Jun 23, 2016, at 3:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; FWIW, Josh&#39;s example would be fixed whether we prohibit or ignore invisible characters, but there are other potential strings for which prohibition would be more secure.<br>&gt; <br>&gt; On Thu, Jun 23, 2016 at 15:27 James Hillhouse &lt;jdhillhouse4 at icloud.com &lt;mailto:jdhillhouse4 at icloud.com&gt;&gt; wrote:<br>&gt; +1 on this. Josh Wisenbaker‚Äôs example says enough. Yikes!<br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 3:18 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1<br>&gt;&gt; I didn&#39;t even know there were any invisible characters until this thread came up.<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt; On Jun 23, 2016, at 15:13, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Thu, Jun 23, 2016 at 2:54 PM, Jo√£o Pinheiro &lt;joao at joaopinheiro.org &lt;mailto:joao at joaopinheiro.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On 23 Jun 2016, at 20:43, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt; That&#39;s cool, although my preferred solution would be more closely aligned with UAX #31: overtly disallow the glyphs in Table 4 (instead of ignoring them) except in the specific scenarios for ZWJ and ZWNJ identified in UAX #31, then afterwards internally represent the identifier as its NFC-normalized string.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Explicitly disallowing them was my initial idea, but I think it would end up being a confusing error for users to encounter. Ignoring the invisible characters and leaving it up to a linter to remove them is less likely to cause confusion for users.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ll be sure to describe the alternative of explicitly prohibiting them in the proposal though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would strongly urge you to propose explicitly prohibiting them just as UAX #31 recommends. Their reasoning is that these characters, which include those that reverse text direction or control joining, can cause one identifier to be maliciously changed to look like another. If you ignore these characters instead of prohibiting them, an identifier that visually appears as one string could in fact be a different one to the compiler.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Moreover, a compiler error can be made helpful by saying that the offending character is potentially invisible and it can come with a fix-it to remove the offending character. I don&#39;t think that would confuse the user at all. It would be more confusing if invisible characters that caused one thing to look identical to another were silently permitted.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sincerely,<br>&gt;&gt;&gt; Jo√£o Pinheiro<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/69e70ce8/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 23, 2016 at 08:00:00pm</p></header><div class="content"><p>Let me correct myself: what I think Josh&#39;s example is should be corrected<br>whether we prohibit or ignore. However, since no one can see the invisible<br>characters he used, I can&#39;t say for sure.<br></p><p>If he found a clever way to reorder or change spacing between letters (e.g.<br>superimpose two characters so that &quot;var11&quot; looks like &quot;var1&quot;), then the<br>problem can only be fixed by prohibition.<br>On Thu, Jun 23, 2016 at 15:36 James Hillhouse &lt;jdhillhouse4 at icloud.com&gt;<br>wrote:<br></p><p>&gt; Thanks Xiaodi. That‚Äôs a relief to know.<br>&gt;<br>&gt;<br>&gt; On Jun 23, 2016, at 3:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; FWIW, Josh&#39;s example would be fixed whether we prohibit or ignore<br>&gt; invisible characters, but there are other potential strings for which<br>&gt; prohibition would be more secure.<br>&gt;<br>&gt; On Thu, Jun 23, 2016 at 15:27 James Hillhouse &lt;jdhillhouse4 at icloud.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; +1 on this. Josh Wisenbaker‚Äôs example says enough. Yikes!<br>&gt;&gt;<br>&gt;&gt; On Jun 23, 2016, at 3:18 PM, David Sweeris via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; +1<br>&gt;&gt; I didn&#39;t even know there were any invisible characters until this thread<br>&gt;&gt; came up.<br>&gt;&gt;<br>&gt;&gt; - Dave Sweeris<br>&gt;&gt;<br>&gt;&gt; On Jun 23, 2016, at 15:13, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Thu, Jun 23, 2016 at 2:54 PM, Jo√£o Pinheiro &lt;joao at joaopinheiro.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On 23 Jun 2016, at 20:43, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; &gt; That&#39;s cool, although my preferred solution would be more closely<br>&gt;&gt;&gt; aligned with UAX #31: overtly disallow the glyphs in Table 4 (instead of<br>&gt;&gt;&gt; ignoring them) except in the specific scenarios for ZWJ and ZWNJ identified<br>&gt;&gt;&gt; in UAX #31, then afterwards internally represent the identifier as its<br>&gt;&gt;&gt; NFC-normalized string.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Explicitly disallowing them was my initial idea, but I think it would<br>&gt;&gt;&gt; end up being a confusing error for users to encounter. Ignoring the<br>&gt;&gt;&gt; invisible characters and leaving it up to a linter to remove them is less<br>&gt;&gt;&gt; likely to cause confusion for users.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;ll be sure to describe the alternative of explicitly prohibiting them<br>&gt;&gt;&gt; in the proposal though.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I would strongly urge you to propose explicitly prohibiting them just as<br>&gt;&gt; UAX #31 recommends. Their reasoning is that these characters, which include<br>&gt;&gt; those that reverse text direction or control joining, can cause one<br>&gt;&gt; identifier to be maliciously changed to look like another. If you ignore<br>&gt;&gt; these characters instead of prohibiting them, an identifier that visually<br>&gt;&gt; appears as one string could in fact be a different one to the compiler.<br>&gt;&gt;<br>&gt;&gt; Moreover, a compiler error can be made helpful by saying that the<br>&gt;&gt; offending character is potentially invisible and it can come with a fix-it<br>&gt;&gt; to remove the offending character. I don&#39;t think that would confuse the<br>&gt;&gt; user at all. It would be more confusing if invisible characters that caused<br>&gt;&gt; one thing to look identical to another were silently permitted.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; Sincerely,<br>&gt;&gt;&gt; Jo√£o Pinheiro<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/ae0bd91c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/92adc26e3003cac88ca299a08d35b2b3?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Jo√£o Pinheiro</string> &lt;joao at joaopinheiro.org&gt;<p>June 23, 2016 at 10:00:00pm</p></header><div class="content"><p>Indeed, the case shown in Josh&#39;s example was the motivation for this thread and will be solved by the proposal.<br></p><p>The current discussion has been around whether it should be solved by ignoring invisible characters or prohibiting them and explicitly highlighting them as an error. I originally proposed prohibiting them and was convinced into thinking that ignoring them would suffice. Upon further reading of the unicode normalisation and security documents, I agree that prohibiting them outside of the situations described in UAX #31 is the best and safest choice.<br></p><p>Sincerely,<br>Jo√£o Pinheiro<br></p><p><br>&gt; On 23 Jun 2016, at 21:45, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Let me correct myself: what I think Josh&#39;s example is should be corrected whether we prohibit or ignore. However, since no one can see the invisible characters he used, I can&#39;t say for sure.<br>&gt; <br>&gt; If he found a clever way to reorder or change spacing between letters (e.g. superimpose two characters so that &quot;var11&quot; looks like &quot;var1&quot;), then the problem can only be fixed by prohibition.<br>&gt; On Thu, Jun 23, 2016 at 15:36 James Hillhouse &lt;jdhillhouse4 at icloud.com &lt;mailto:jdhillhouse4 at icloud.com&gt;&gt; wrote:<br>&gt; Thanks Xiaodi. That‚Äôs a relief to know.<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 3:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; FWIW, Josh&#39;s example would be fixed whether we prohibit or ignore invisible characters, but there are other potential strings for which prohibition would be more secure.<br>&gt;&gt; <br>&gt;&gt; On Thu, Jun 23, 2016 at 15:27 James Hillhouse &lt;jdhillhouse4 at icloud.com &lt;mailto:jdhillhouse4 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; +1 on this. Josh Wisenbaker‚Äôs example says enough. Yikes!<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 23, 2016, at 3:18 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1<br>&gt;&gt;&gt; I didn&#39;t even know there were any invisible characters until this thread came up.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 23, 2016, at 15:13, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, Jun 23, 2016 at 2:54 PM, Jo√£o Pinheiro &lt;joao at joaopinheiro.org &lt;mailto:joao at joaopinheiro.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On 23 Jun 2016, at 20:43, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; That&#39;s cool, although my preferred solution would be more closely aligned with UAX #31: overtly disallow the glyphs in Table 4 (instead of ignoring them) except in the specific scenarios for ZWJ and ZWNJ identified in UAX #31, then afterwards internally represent the identifier as its NFC-normalized string.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Explicitly disallowing them was my initial idea, but I think it would end up being a confusing error for users to encounter. Ignoring the invisible characters and leaving it up to a linter to remove them is less likely to cause confusion for users.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ll be sure to describe the alternative of explicitly prohibiting them in the proposal though.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would strongly urge you to propose explicitly prohibiting them just as UAX #31 recommends. Their reasoning is that these characters, which include those that reverse text direction or control joining, can cause one identifier to be maliciously changed to look like another. If you ignore these characters instead of prohibiting them, an identifier that visually appears as one string could in fact be a different one to the compiler.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Moreover, a compiler error can be made helpful by saying that the offending character is potentially invisible and it can come with a fix-it to remove the offending character. I don&#39;t think that would confuse the user at all. It would be more confusing if invisible characters that caused one thing to look identical to another were silently permitted.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sincerely,<br>&gt;&gt;&gt;&gt; Jo√£o Pinheiro<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/0e5f5caf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 24, 2016 at 04:00:00pm</p></header><div class="content"><p>On 24.06.2016 0:57, Jo√£o Pinheiro via swift-evolution wrote:<br>&gt; Indeed, the case shown in Josh&#39;s example was the motivation for this thread<br>&gt; and will be solved by the proposal.<br>&gt;<br>&gt; The current discussion has been around whether it should be solved by<br>&gt; ignoring invisible characters or prohibiting them and explicitly<br>&gt; highlighting them as an error. I originally proposed prohibiting them and<br>&gt; was convinced into thinking that ignoring them would suffice. Upon further<br>&gt; reading of the unicode normalisation and security documents, I agree that<br>&gt; prohibiting them outside of the situations described in UAX #31 is the best<br>&gt; and safest choice.<br></p><p>I do believe the *safest* variant should be chosen as, actually, do we see <br>lot of sources with unicode identifiers? I believe very small percent in <br>real code. IMO At first we should protect Swift from problems with unicode <br>identifiers, and only after this support as much unicode as we can.<br>(Personally I really don&#39;t understand why we need anything than ASCII codes <br>for identifiers. This could solve all the problems with invisible <br>space/left-to-right-flags/complicated rules/graphemes etc. But someone <br>needs to be able to put dog emoji as identifiers.. well.. OK)<br></p><p>&gt;<br>&gt; Sincerely,<br>&gt; Jo√£o Pinheiro<br>&gt;<br>&gt;<br>&gt;&gt; On 23 Jun 2016, at 21:45, Xiaodi Wu via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Let me correct myself: what I think Josh&#39;s example is should be corrected<br>&gt;&gt; whether we prohibit or ignore. However, since no one can see the<br>&gt;&gt; invisible characters he used, I can&#39;t say for sure.<br>&gt;&gt;<br>&gt;&gt; If he found a clever way to reorder or change spacing between letters<br>&gt;&gt; (e.g. superimpose two characters so that &quot;var11&quot; looks like &quot;var1&quot;), then<br>&gt;&gt; the problem can only be fixed by prohibition.<br>&gt;&gt; On Thu, Jun 23, 2016 at 15:36 James Hillhouse &lt;jdhillhouse4 at icloud.com<br>&gt;&gt; &lt;mailto:jdhillhouse4 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     Thanks Xiaodi. That‚Äôs a relief to know.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;     On Jun 23, 2016, at 3:32 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com<br>&gt;&gt;&gt;     &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     FWIW, Josh&#39;s example would be fixed whether we prohibit or ignore<br>&gt;&gt;&gt;     invisible characters, but there are other potential strings for<br>&gt;&gt;&gt;     which prohibition would be more secure.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     On Thu, Jun 23, 2016 at 15:27 James Hillhouse<br>&gt;&gt;&gt;     &lt;jdhillhouse4 at icloud.com &lt;mailto:jdhillhouse4 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         +1 on this. Josh Wisenbaker‚Äôs example says enough. Yikes!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         On Jun 23, 2016, at 3:18 PM, David Sweeris via swift-evolution<br>&gt;&gt;&gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;         wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         +1<br>&gt;&gt;&gt;&gt;         I didn&#39;t even know there were any invisible characters until<br>&gt;&gt;&gt;&gt;         this thread came up.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         - Dave Sweeris<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         On Jun 23, 2016, at 15:13, Xiaodi Wu via swift-evolution<br>&gt;&gt;&gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;         wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         On Thu, Jun 23, 2016 at 2:54 PM, Jo√£o Pinheiro<br>&gt;&gt;&gt;&gt;&gt;         &lt;joao at joaopinheiro.org &lt;mailto:joao at joaopinheiro.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;             &gt; On 23 Jun 2016, at 20:43, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;             &gt; That&#39;s cool, although my preferred solution would be more closely aligned with UAX #31: overtly disallow the glyphs in Table 4 (instead of ignoring them) except in the specific scenarios for ZWJ and ZWNJ identified in UAX #31, then afterwards internally represent the identifier as its NFC-normalized string.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;             Explicitly disallowing them was my initial idea, but I<br>&gt;&gt;&gt;&gt;&gt;             think it would end up being a confusing error for users to<br>&gt;&gt;&gt;&gt;&gt;             encounter. Ignoring the invisible characters and leaving<br>&gt;&gt;&gt;&gt;&gt;             it up to a linter to remove them is less likely to cause<br>&gt;&gt;&gt;&gt;&gt;             confusion for users.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;             I&#39;ll be sure to describe the alternative of explicitly<br>&gt;&gt;&gt;&gt;&gt;             prohibiting them in the proposal though.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         I would strongly urge you to propose explicitly prohibiting<br>&gt;&gt;&gt;&gt;&gt;         them just as UAX #31 recommends. Their reasoning is that these<br>&gt;&gt;&gt;&gt;&gt;         characters, which include those that reverse text direction or<br>&gt;&gt;&gt;&gt;&gt;         control joining, can cause one identifier to be maliciously<br>&gt;&gt;&gt;&gt;&gt;         changed to look like another. If you ignore these characters<br>&gt;&gt;&gt;&gt;&gt;         instead of prohibiting them, an identifier that visually<br>&gt;&gt;&gt;&gt;&gt;         appears as one string could in fact be a different one to the<br>&gt;&gt;&gt;&gt;&gt;         compiler.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         Moreover, a compiler error can be made helpful by saying that<br>&gt;&gt;&gt;&gt;&gt;         the offending character is potentially invisible and it can<br>&gt;&gt;&gt;&gt;&gt;         come with a fix-it to remove the offending character. I don&#39;t<br>&gt;&gt;&gt;&gt;&gt;         think that would confuse the user at all. It would be more<br>&gt;&gt;&gt;&gt;&gt;         confusing if invisible characters that caused one thing to<br>&gt;&gt;&gt;&gt;&gt;         look identical to another were silently permitted.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;             Sincerely,<br>&gt;&gt;&gt;&gt;&gt;             Jo√£o Pinheiro<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;         swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;         _______________________________________________<br>&gt;&gt;&gt;&gt;         swift-evolution mailing list<br>&gt;&gt;&gt;&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June 24, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jun 24, 2016, at 8:27 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; (Personally I really don&#39;t understand why we need anything than ASCII codes for identifiers. This could solve all the problems with invisible space/left-to-right-flags/complicated rules/graphemes etc. But someone needs to be able to put dog emoji as identifiers.. well.. OK)<br></p><p>Did you even watch the WWDC keynote? This was basically the transcript of it:<br></p><p>&quot;Emoji! Emoji emoji emoji. Emoji emoji. Emoji! Emoji emoji emoji emoji. Emoji Emoji? Emoji. Emoji!‚Äù<br></p><p>(cue a bunch of emoji bouncing around on an iPad screen)<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/e683552e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 25, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Jun 24, 2016, at 08:27, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; (Personally I really don&#39;t understand why we need anything than ASCII codes for identifiers. This could solve all the problems with invisible space/left-to-right-flags/complicated rules/graphemes etc. But someone needs to be able to put dog emoji as identifiers.. well.. OK)<br></p><p>Math symbols make everything better (at least if you&#39;re into math).<br></p><p>- Dave Sweeris<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e439b0f8beb3222a8b44f40eecee259a?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Josh Wisenbaker</string> &lt;macshome at mac.com&gt;<p>June 23, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 4:45 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Let me correct myself: what I think Josh&#39;s example is should be corrected whether we prohibit or ignore. However, since no one can see the invisible characters he used, I can&#39;t say for sure.<br>&gt; <br>&gt; If he found a clever way to reorder or change spacing between letters (e.g. superimpose two characters so that &quot;var11&quot; looks like &quot;var1&quot;), then the problem can only be fixed by prohibition.<br></p><p>I asked my colleague who played the prank on me and got the details:<br></p><p>&quot;Lines 4 and 5 declare variables with embedded Unicode Zero Width Spaces (U+200B) in their names. Line 4 is actually  ‚Äúvar\U+200B1‚Äù, not ‚Äúvar1‚Äù. Isn‚Äôt it nice of Swift to be this flexible üòä‚Äù<br></p><p>Josh<br></p><p><br>Josh Wisenbaker<br>macshome at mac.com<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/ae2a5e9b/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4103 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/ae2a5e9b/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/92adc26e3003cac88ca299a08d35b2b3?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Jo√£o Pinheiro</string> &lt;joao at joaopinheiro.org&gt;<p>June 23, 2016 at 11:00:00pm</p></header><div class="content"><p>This was exactly the motivation for the proposal and a similar example was given on the first email of the thread.<br></p><p>Try this:<br></p><p>func test() { print(&quot;A&quot;) }<br>func t‚Äãest() { print(&quot;B&quot;) }<br>func te‚Äãst() { print(&quot;C&quot;) }<br></p><p>let abc = 1<br>let a‚Äãbc = 2<br>let ab‚Äãc = 3<br></p><p>test()<br>t‚Äãest()<br>te‚Äãst()<br></p><p>print(abc)<br>print(a‚Äãbc)<br>print(ab‚Äãc)<br></p><p>Sincerely,<br>Jo√£o Pinheiro<br></p><p><br>&gt; On 23 Jun 2016, at 22:59, Josh Wisenbaker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 4:45 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Let me correct myself: what I think Josh&#39;s example is should be corrected whether we prohibit or ignore. However, since no one can see the invisible characters he used, I can&#39;t say for sure.<br>&gt;&gt; <br>&gt;&gt; If he found a clever way to reorder or change spacing between letters (e.g. superimpose two characters so that &quot;var11&quot; looks like &quot;var1&quot;), then the problem can only be fixed by prohibition.<br>&gt; <br>&gt; I asked my colleague who played the prank on me and got the details:<br>&gt; <br>&gt; &quot;Lines 4 and 5 declare variables with embedded Unicode Zero Width Spaces (U+200B) in their names. Line 4 is actually  ‚Äúvar\U+200B1‚Äù, not ‚Äúvar1‚Äù. Isn‚Äôt it nice of Swift to be this flexible üòä‚Äù<br>&gt; <br>&gt; Josh<br>&gt; <br>&gt; <br>&gt; Josh Wisenbaker<br>&gt; macshome at mac.com &lt;mailto:macshome at mac.com&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/9957b071/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 23, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 9:17 AM, Jo√£o Pinheiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 21 Jun 2016, at 20:15, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Tue, Jun 21, 2016 at 1:16 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; Any discussion about this ought to start from UAX #31, the Unicode consortium&#39;s recommendations on identifiers in programming languages:<br>&gt;&gt; <br>&gt;&gt; http://unicode.org/reports/tr31/ &lt;http://unicode.org/reports/tr31/&gt;<br>&gt;&gt; <br>&gt;&gt; Section 2.3 specifically calls out the situations in which ZWJ and ZWNJ need to be allowed. The document also describes a stability policy for handling new Unicode versions, other confusability issues, and many of the other problems with adopting Unicode in a programming language&#39;s syntax.<br>&gt;&gt; <br>&gt;&gt; That&#39;s a fantastic document--a very edifying read. Given Swift&#39;s robust support for Unicode in its core libraries, it&#39;s kind of surprising to me that identifiers aren&#39;t canonicalized at compile time. From a quick first read, faithful adoption of UAX #31 recommendations would address most if not all of the confusability and zero-width security issues raised in this conversation.<br>&gt; <br>&gt; From what I&#39;ve read of UAX #31 &lt;http://unicode.org/reports/tr31/&gt; it does seem to address all of the invisible character issues raised in the discussion. Given their unicode status of of Default_Ignorable_Code_Points, I believe the best course of action would be to canonicalise identifiers by allowing invisible characters only where appropriate and ignoring them everywhere else.<br>&gt; <br>&gt; The alternative to ignoring them would be to not canonicalise identifiers and treat invisible characters as an error instead.<br>&gt; <br>&gt; This doesn&#39;t address the issue of unicode confusable characters, but solving that has additional problems of its own and would probably be better addressed in a different proposal entirely.<br>&gt; <br>&gt; I&#39;d like to start writing the proposal if there is agreement that this would be the best course of action.<br></p><p>Sounds great, please do.  Thanks!<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/d3faadfb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/92adc26e3003cac88ca299a08d35b2b3?s=50"></div><header><strong>Prohibit invisible characters in identifier names</strong> from <string>Jo√£o Pinheiro</string> &lt;joao at joaopinheiro.org&gt;<p>July 26, 2016 at 09:00:00pm</p></header><div class="content"><p>I&#39;ve submitted a draft of the proposal on the thread &quot;Normalize Unicode Identifiers &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/25126&gt;&quot;. Please make any comments and recommendations there.<br></p><p>Sincerely,<br>Jo√£o Pinheiro<br></p><p><br>&gt; On 23 Jun 2016, at 18:30, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 9:17 AM, Jo√£o Pinheiro via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 21 Jun 2016, at 20:15, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Jun 21, 2016 at 1:16 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; Any discussion about this ought to start from UAX #31, the Unicode consortium&#39;s recommendations on identifiers in programming languages:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; http://unicode.org/reports/tr31/ &lt;http://unicode.org/reports/tr31/&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Section 2.3 specifically calls out the situations in which ZWJ and ZWNJ need to be allowed. The document also describes a stability policy for handling new Unicode versions, other confusability issues, and many of the other problems with adopting Unicode in a programming language&#39;s syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s a fantastic document--a very edifying read. Given Swift&#39;s robust support for Unicode in its core libraries, it&#39;s kind of surprising to me that identifiers aren&#39;t canonicalized at compile time. From a quick first read, faithful adoption of UAX #31 recommendations would address most if not all of the confusability and zero-width security issues raised in this conversation.<br>&gt;&gt; <br>&gt;&gt; From what I&#39;ve read of UAX #31 &lt;http://unicode.org/reports/tr31/&gt; it does seem to address all of the invisible character issues raised in the discussion. Given their unicode status of of Default_Ignorable_Code_Points, I believe the best course of action would be to canonicalise identifiers by allowing invisible characters only where appropriate and ignoring them everywhere else.<br>&gt;&gt; <br>&gt;&gt; The alternative to ignoring them would be to not canonicalise identifiers and treat invisible characters as an error instead.<br>&gt;&gt; <br>&gt;&gt; This doesn&#39;t address the issue of unicode confusable characters, but solving that has additional problems of its own and would probably be better addressed in a different proposal entirely.<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to start writing the proposal if there is agreement that this would be the best course of action.<br>&gt; <br>&gt; Sounds great, please do.  Thanks!<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/422ef5c4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
