<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>UnsafeMutablePointer&lt;String&gt; vs. UnsafeMutablePointer&lt;Int&gt;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 21, 2016 at 10:00:00am</p></header><div class="content"><p>I played around with UnsafeMutablePointer and realized one behavior:<br></p><p>let pString = UnsafeMutablePointer&lt;String&gt;.alloc(1)<br>pString.initialize(&quot;test&quot;)<br>pString.predecessor().memory // will crash ax expected<br>pString.predecessor() == pString.advancedBy(-1) // true<br>pString.destroy()<br>pString.dealloc(1)<br>where<br></p><p>let iInt = UnsafeMutablePointer&lt;String&gt;.alloc(1)<br>iInt.initialize(&quot;test&quot;)<br>iInt.predecessor().memory // will not crash<br>iInt.predecessor() == iInt.advancedBy(-1) // true<br>iInt.predecessor().memory = 42 // did I just modified some memory I don&#39;t own?<br>iInt.destroy()<br>iInt.dealloc(1)<br>Is this intended? This is really the case where its unsafe.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160521/b82e14ce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>UnsafeMutablePointer&lt;String&gt; vs. UnsafeMutablePointer&lt;Int&gt;</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>May 21, 2016 at 02:00:00am</p></header><div class="content"><p>Hi Adrian,<br></p><p>On Sat, May 21, 2016 at 1:48 AM, Adrian Zubarev via swift-users<br>&lt;swift-users at swift.org&gt; wrote:<br>&gt; I played around with UnsafeMutablePointer and realized one behavior:<br>&gt;<br>&gt; let pString = UnsafeMutablePointer&lt;String&gt;.alloc(1)<br>&gt; pString.initialize(&quot;test&quot;)<br>&gt; pString.predecessor().memory // will crash ax expected<br>&gt; pString.predecessor() == pString.advancedBy(-1) // true<br>&gt; pString.destroy()<br>&gt; pString.dealloc(1)<br>&gt;<br>&gt; where<br>&gt;<br>&gt; let iInt = UnsafeMutablePointer&lt;String&gt;.alloc(1)<br>&gt; iInt.initialize(&quot;test&quot;)<br>&gt; iInt.predecessor().memory // will not crash<br>&gt; iInt.predecessor() == iInt.advancedBy(-1) // true<br>&gt; iInt.predecessor().memory = 42 // did I just modified some memory I don&#39;t<br>&gt; own?<br></p><p>Yes, you did.<br></p><p>In the String case the crash is not guaranteed (it is a segmentation<br>fault, not a controlled trap).  Someone else&#39;s valid String can happen<br>to be located immediately before your memory chunk, and then the code<br>would &quot;just work&quot;, loading that other string.<br></p><p>Dereferencing (reading or writing into) an out-of-bounds pointer is<br>undefined behavior in Swift.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>UnsafeMutablePointer&lt;String&gt; vs. UnsafeMutablePointer&lt;Int&gt;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 21, 2016 at 11:00:00am</p></header><div class="content"><p>So basically if I do something like this I should be on the safe side:<br></p><p>public class Characters {<br>         <br>    private let reference: UnsafeMutablePointer&lt;Character&gt;<br></p><p>    var characters: [Character] {<br>             <br>        var characters = [Character]()<br>             <br>        for index in 0..&lt;self.count {<br>                 <br>            characters.append(self.reference.advancedBy(index).memory)<br>        }<br>        return characters<br>    }<br>         <br>    var combined: String { return String(self.characters) }<br>         <br>    public let count: Int<br>         <br>    public init(value: String) {<br>             <br>        let characters = value.characters<br>             <br>        self.count = characters.count<br>        self.reference = UnsafeMutablePointer&lt;Character&gt;.alloc(self.count)<br>        self.reference.initializeFrom(characters)<br>    }<br>         <br>    deinit {<br>             <br>        self.reference.destroy(self.count)<br>        self.reference.dealloc(self.count)<br>    }<br>}<br>Or do I have to fix something?<br></p><p>Here I don’t walk out of the boundary I allocate.<br></p><p>Does the UnsafeMutablePointer reserves me a safe portion of memory (by safe I mean which isn’t used by anyone at the time I will start using it)?<br></p><p>Sure another pointer could be created and hack into my memory but that wasn’t the question. :)<br></p><p>Thanks.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 21. Mai 2016 bei 11:04:10, Dmitri Gribenko (gribozavr at gmail.com) schrieb:<br></p><p>Hi Adrian,  <br></p><p>On Sat, May 21, 2016 at 1:48 AM, Adrian Zubarev via swift-users  <br>&lt;swift-users at swift.org&gt; wrote:  <br>&gt; I played around with UnsafeMutablePointer and realized one behavior:  <br>&gt;  <br>&gt; let pString = UnsafeMutablePointer&lt;String&gt;.alloc(1)  <br>&gt; pString.initialize(&quot;test&quot;)  <br>&gt; pString.predecessor().memory // will crash ax expected  <br>&gt; pString.predecessor() == pString.advancedBy(-1) // true  <br>&gt; pString.destroy()  <br>&gt; pString.dealloc(1)  <br>&gt;  <br>&gt; where  <br>&gt;  <br>&gt; let iInt = UnsafeMutablePointer&lt;String&gt;.alloc(1)  <br>&gt; iInt.initialize(&quot;test&quot;)  <br>&gt; iInt.predecessor().memory // will not crash  <br>&gt; iInt.predecessor() == iInt.advancedBy(-1) // true  <br>&gt; iInt.predecessor().memory = 42 // did I just modified some memory I don&#39;t  <br>&gt; own?  <br></p><p>Yes, you did.  <br></p><p>In the String case the crash is not guaranteed (it is a segmentation  <br>fault, not a controlled trap). Someone else&#39;s valid String can happen  <br>to be located immediately before your memory chunk, and then the code  <br>would &quot;just work&quot;, loading that other string.  <br></p><p>Dereferencing (reading or writing into) an out-of-bounds pointer is  <br>undefined behavior in Swift.  <br></p><p>Dmitri  <br></p><p>--  <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if  <br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/  <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160521/5883320b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>UnsafeMutablePointer&lt;String&gt; vs. UnsafeMutablePointer&lt;Int&gt;</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>May 21, 2016 at 02:00:00am</p></header><div class="content"><p>On Sat, May 21, 2016 at 2:15 AM, Adrian Zubarev via swift-users<br>&lt;swift-users at swift.org&gt; wrote:<br>&gt; So basically if I do something like this I should be on the safe side:<br></p><p>Yes, this code is safe.  If you just want to store a contiguous buffer<br>of elements of the same type, you should consider using Array.  It has<br>methods that will allow you to operate on the unsafe pointer to the<br>memory if you need that for speed, but it will do the memory<br>management for you.<br></p><p>&gt; Does the UnsafeMutablePointer reserves me a safe portion of memory (by safe<br>&gt; I mean which isn’t used by anyone at the time I will start using it)?<br></p><p>Yes, you will become a unique owner of the newly allocated chunk of<br>memory.  (Same as malloc() in C.)<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>UnsafeMutablePointer&lt;String&gt; vs. UnsafeMutablePointer&lt;Int&gt;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May 23, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 21, 2016, at 01:48, Adrian Zubarev via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I played around with UnsafeMutablePointer and realized one behavior:<br>&gt; <br>&gt; let pString = UnsafeMutablePointer&lt;String&gt;.alloc(1)<br>&gt; pString.initialize(&quot;test&quot;)<br>&gt; pString.predecessor().memory // will crash ax expected<br>&gt; pString.predecessor() == pString.advancedBy(-1) // true<br>&gt; pString.destroy()<br>&gt; pString.dealloc(1)<br>&gt; where<br>&gt; <br>&gt; let iInt = UnsafeMutablePointer&lt;String&gt;.alloc(1)<br>&gt; iInt.initialize(&quot;test&quot;)<br>&gt; iInt.predecessor().memory // will not crash<br>&gt; iInt.predecessor() == iInt.advancedBy(-1) // true<br>&gt; iInt.predecessor().memory = 42 // did I just modified some memory I don&#39;t own?<br>&gt; iInt.destroy()<br>&gt; iInt.dealloc(1)<br>&gt; Is this intended? This is really the case where its unsafe.<br>&gt; <br></p><p>Dmitri’s answers are all better for this specific discussion, but in general, “unsafe” in Swift means “if you don’t follow the rules, this may crash, may silently corrupt memory or do other bad things, may cause other code to be optimized out or miscompiled, may be harmless”. In this particular case, it’d be hard to check for the validity of the pointer while also being fast and binary-compatible with C.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160523/5b19f3fe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>UnsafeMutablePointer&lt;String&gt; vs. UnsafeMutablePointer&lt;Int&gt;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June  1, 2016 at 06:00:00pm</p></header><div class="content"><p>I’ve got one more question that bothers me.<br></p><p>Lets say I’ve got a class that might look something like this:<br></p><p>class Reference {<br>     <br>    var pointer: UnsafeMutablePointer&lt;Int&gt;<br>     <br>    init(integer: Int) {<br>        self.pointer = UnsafeMutablePointer&lt;Int&gt;.alloc(1)<br>        self.pointer.initialize(integer)<br>    }<br>     <br>    deinit {<br>        self.pointer.destroy(1)<br>        self.pointer.dealloc(1)<br>    }<br>}<br>Let talk about ARC here. If I use optionals here and release manually the reference deinit will be called and we’re happy here:<br></p><p>var reference: Reference? = Reference(integer: 123456789)<br>reference = nil<br>If I don’t use optionals because I want my value to exist while the application is running, deinit will never be called but my application terminates just fine (SIGKILL?):<br></p><p>let reference = Reference(integer: 123456789)<br>Doesn’t this create a memory leak?<br></p><p>How do I solve this problem, especially if don’t know whats inside the Reference type (assume I’m a different developer who only has access to the framework but not its implementation)?<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 23. Mai 2016 um 18:31:43, Jordan Rose (jordan_rose at apple.com) schrieb:<br></p><p><br>On May 21, 2016, at 01:48, Adrian Zubarev via swift-users &lt;swift-users at swift.org&gt; wrote:<br></p><p>I played around with UnsafeMutablePointer and realized one behavior:<br></p><p>let pString = UnsafeMutablePointer&lt;String&gt;.alloc(1)<br>pString.initialize(&quot;test&quot;)<br>pString.predecessor().memory // will crash ax expected<br>pString.predecessor() == pString.advancedBy(-1) // true<br>pString.destroy()<br>pString.dealloc(1)<br></p><p>where<br></p><p>let iInt = UnsafeMutablePointer&lt;String&gt;.alloc(1)<br>iInt.initialize(&quot;test&quot;)<br>iInt.predecessor().memory // will not crash<br>iInt.predecessor() == iInt.advancedBy(-1) // true<br>iInt.predecessor().memory = 42 // did I just modified some memory I don&#39;t own?<br>iInt.destroy()<br>iInt.dealloc(1)<br></p><p>Is this intended? This is really the case where its unsafe.<br></p><p><br>Dmitri’s answers are all better for this specific discussion, but in general, “unsafe” in Swift means “if you don’t follow the rules, this may crash, may silently corrupt memory or do other bad things, may cause other code to be optimized out or miscompiled, may be harmless”. In this particular case, it’d be hard to check for the validity of the pointer while also being fast and binary-compatible with C.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160601/66b23a1b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>UnsafeMutablePointer&lt;String&gt; vs. UnsafeMutablePointer&lt;Int&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  1, 2016 at 09:00:00am</p></header><div class="content"><p>This shouldn&#39;t be something you need to worry about. The mechanism the OS uses to handle memory per process is different from the mechanism your process uses to allocate memory, and the OS should reclaim all the memory that your app used (whether it was &#39;leaked&#39; or not).<br></p><p>More info: http://stackoverflow.com/questions/2975831/is-leaked-memory-freed-up-when-the-program-exits &lt;http://stackoverflow.com/questions/2975831/is-leaked-memory-freed-up-when-the-program-exits&gt;<br></p><p>Best,<br>Austin<br></p><p>&gt; On Jun 1, 2016, at 9:13 AM, Adrian Zubarev via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve got one more question that bothers me.<br>&gt; <br>&gt; Lets say I’ve got a class that might look something like this:<br>&gt; <br>&gt; class Reference {<br>&gt;      <br>&gt;     var pointer: UnsafeMutablePointer&lt;Int&gt;<br>&gt;      <br>&gt;     init(integer: Int) {<br>&gt;         self.pointer = UnsafeMutablePointer&lt;Int&gt;.alloc(1)<br>&gt;         self.pointer.initialize(integer)<br>&gt;     }<br>&gt;      <br>&gt;     deinit {<br>&gt;         self.pointer.destroy(1)<br>&gt;         self.pointer.dealloc(1)<br>&gt;     }<br>&gt; }<br>&gt; Let talk about ARC here. If I use optionals here and release manually the reference deinit will be called and we’re happy here:<br>&gt; <br>&gt; var reference: Reference? = Reference(integer: 123456789)<br>&gt; reference = nil<br>&gt; If I don’t use optionals because I want my value to exist while the application is running, deinit will never be called but my application terminates just fine (SIGKILL?):<br>&gt; <br>&gt; let reference = Reference(integer: 123456789)<br>&gt; Doesn’t this create a memory leak?<br>&gt; <br>&gt; How do I solve this problem, especially if don’t know whats inside the Reference type (assume I’m a different developer who only has access to the framework but not its implementation)?<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 23. Mai 2016 um 18:31:43, Jordan Rose (jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 21, 2016, at 01:48, Adrian Zubarev via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I played around with UnsafeMutablePointer and realized one behavior:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let pString = UnsafeMutablePointer&lt;String&gt;.alloc(1)<br>&gt;&gt;&gt; pString.initialize(&quot;test&quot;)<br>&gt;&gt;&gt; pString.predecessor().memory // will crash ax expected<br>&gt;&gt;&gt; pString.predecessor() == pString.advancedBy(-1) // true<br>&gt;&gt;&gt; pString.destroy()<br>&gt;&gt;&gt; pString.dealloc(1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; where<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let iInt = UnsafeMutablePointer&lt;String&gt;.alloc(1)<br>&gt;&gt;&gt; iInt.initialize(&quot;test&quot;)<br>&gt;&gt;&gt; iInt.predecessor().memory // will not crash<br>&gt;&gt;&gt; iInt.predecessor() == iInt.advancedBy(-1) // true<br>&gt;&gt;&gt; iInt.predecessor().memory = 42 // did I just modified some memory I don&#39;t own?<br>&gt;&gt;&gt; iInt.destroy()<br>&gt;&gt;&gt; iInt.dealloc(1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is this intended? This is really the case where its unsafe.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Dmitri’s answers are all better for this specific discussion, but in general, “unsafe” in Swift means “if you don’t follow the rules, this may crash, may silently corrupt memory or do other bad things, may cause other code to be optimized out or miscompiled, may be harmless”. In this particular case, it’d be hard to check for the validity of the pointer while also being fast and binary-compatible with C.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160601/f23e54ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[swift-users] UnsafeMutablePointer&lt;String&gt; vs. UnsafeMutablePointer&lt;Int&gt;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June  1, 2016 at 06:00:00pm</p></header><div class="content"><p>So basically if my application terminates without errors or crashes I can be sure that the OS will free any memory it used.<br></p><p>Now I feel safe using UnsafeMutablePointers in swift :)<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 1. Juni 2016 um 18:19:01, Austin Zheng (austinzheng at gmail.com) schrieb:<br></p><p>This shouldn&#39;t be something you need to worry about. The mechanism the OS uses to handle memory per process is different from the mechanism your process uses to allocate memory, and the OS should reclaim all the memory that your app used (whether it was &#39;leaked&#39; or not).<br></p><p>More info: http://stackoverflow.com/questions/2975831/is-leaked-memory-freed-up-when-the-program-exits<br></p><p>Best,<br>Austin<br></p><p>On Jun 1, 2016, at 9:13 AM, Adrian Zubarev via swift-users &lt;swift-users at swift.org&gt; wrote:<br></p><p>I’ve got one more question that bothers me.<br></p><p>Lets say I’ve got a class that might look something like this:<br></p><p>class Reference {<br>      <br>    var pointer: UnsafeMutablePointer&lt;Int&gt;<br>      <br>    init(integer: Int) {<br>        self.pointer = UnsafeMutablePointer&lt;Int&gt;.alloc(1)<br>        self.pointer.initialize(integer)<br>    }<br>      <br>    deinit {<br>        self.pointer.destroy(1)<br>        self.pointer.dealloc(1)<br>    }<br>}<br>Let talk about ARC here. If I use optionals here and release manually the reference deinit will be called and we’re happy here:<br></p><p>var reference: Reference? = Reference(integer: 123456789)<br>reference = nil<br>If I don’t use optionals because I want my value to exist while the application is running, deinit will never be called but my application terminates just fine (SIGKILL?):<br></p><p>let reference = Reference(integer: 123456789)<br>Doesn’t this create a memory leak?<br></p><p>How do I solve this problem, especially if don’t know whats inside the Reference type (assume I’m a different developer who only has access to the framework but not its implementation)?<br></p><p><br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 23. Mai 2016 um 18:31:43, Jordan Rose (jordan_rose at apple.com) schrieb:<br></p><p><br>On May 21, 2016, at 01:48, Adrian Zubarev via swift-users &lt;swift-users at swift.org&gt; wrote:<br></p><p>I played around with UnsafeMutablePointer and realized one behavior:<br></p><p>let pString = UnsafeMutablePointer&lt;String&gt;.alloc(1)<br>pString.initialize(&quot;test&quot;)<br>pString.predecessor().memory // will crash ax expected<br>pString.predecessor() == pString.advancedBy(-1) // true<br>pString.destroy()<br>pString.dealloc(1)<br></p><p>where<br></p><p>let iInt = UnsafeMutablePointer&lt;String&gt;.alloc(1)<br>iInt.initialize(&quot;test&quot;)<br>iInt.predecessor().memory // will not crash<br>iInt.predecessor() == iInt.advancedBy(-1) // true<br>iInt.predecessor().memory = 42 // did I just modified some memory I don&#39;t own?<br>iInt.destroy()<br>iInt.dealloc(1)<br></p><p>Is this intended? This is really the case where its unsafe.<br></p><p><br>Dmitri’s answers are all better for this specific discussion, but in general, “unsafe” in Swift means “if you don’t follow the rules, this may crash, may silently corrupt memory or do other bad things, may cause other code to be optimized out or miscompiled, may be harmless”. In this particular case, it’d be hard to check for the validity of the pointer while also being fast and binary-compatible with C.<br></p><p>Jordan<br></p><p><br>_______________________________________________<br>swift-users mailing list<br>swift-users at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/e27a243c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
