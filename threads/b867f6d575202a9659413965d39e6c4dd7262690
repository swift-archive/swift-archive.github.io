<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[Review] SE-0050: Decoupling Floating Point	Strides from Generic Implementations</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>May 19, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; * What is your evaluation of the proposal?<br></p><p>+1. It might not be pretty, but it is an improvement.<br></p><p>The Proposed Solution doesn&#39;t compile with development snapshot 05-09<br>(SE-0067 hasn&#39;t landed yet, IIRC). I hacked it to get it to compile, and<br>tested it with two problematic cases:<br></p><p>Test #1:<br>let expected = Array(stride(from: 10, through: 20, by: 1).map { Float($0) *<br>0.1 })<br>// [1.0, 1.10000002, 1.20000005, 1.30000007, 1.39999998, 1.5, 1.60000002,<br>1.70000005, 1.80000007, 1.89999998, 2.0]<br></p><p>let actual = Array(stride(from: Float(1.0), through: 2.0, by: 0.1))<br>// old result: one iteration less than expected<br>// [1.0, 1.10000002, 1.20000005, 1.30000007, 1.4000001, 1.50000012,<br>1.60000014, 1.70000017, 1.80000019, 1.90000021]<br>// new result: correct<br>// [1.0, 1.10000002, 1.20000005, 1.29999995, 1.39999998, 1.5, 1.60000002,<br>1.70000005, 1.79999995, 1.9000001, 2.0]<br></p><p>Test #2:<br>let expected = Array(stride(from: 10, to: 100, by: 9).map { Float($0) * 0.1 })<br>// [1.0, 1.89999998, 2.79999995, 3.70000005, 4.5999999, 5.5, 6.4000001,<br>7.30000019, 8.19999981, 9.10000038]<br></p><p>let actual = Array(stride(from: Float(1.0), to: 10.0, by: 0.9))<br>// old result: one iteration more than expected<br>// [1.0, 1.89999998, 2.79999995, 3.69999981, 4.5999999, 5.5, 6.4000001,<br>7.30000019, 8.19999981, 9.09999943, 9.99999905]<br>// new result: correct<br>// [1.0, 1.89999998, 2.79999995, 3.69999981, 4.5999999, 5.5, 6.39999962,<br>7.29999971, 8.19999981, 9.09999943]<br></p><p>So the proposed solution works as advertised.<br></p><p>I would suggest to include two cases like the above in the test suite.<br></p><p><br>&gt; * Is the problem being addressed significant enough to warrant a change to<br>Swift?<br></p><p>Yes. This is a higher level abstraction, so it&#39;s important that it<br>guarantees the best possible accuracy. The current generic implementation<br>gives unacceptably surprising results.<br></p><p>&gt; * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes. It nicely follows the principle of least astonishment.<br></p><p>&gt; * If you have used other languages or libraries with a similar feature,<br>how do you feel that this proposal compares to those?<br></p><p>I always flat-out avoided floating point loops in other languages, fearing<br>that they would be unreliable. It&#39;s good that with this change it&#39;ll be<br>possible to use them with more confidence.<br></p><p>&gt; * How much effort did you put into your review? A glance, a quick reading,<br>or an in-depth study?<br></p><p>careful reading, tested the proposed solution, and read and contributed to<br>the relevant threads.<br></p><p>--<br>Nicola<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0050: Decoupling Floating Point Strides from Generic Implementations</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 19, 2016 at 05:00:00pm</p></header><div class="content"><p>On Thu, May 19, 2016 at 4:31 AM, Nicola Salmoria via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; * What is your evaluation of the proposal?<br>&gt;<br>&gt; +1. It might not be pretty, but it is an improvement.<br>&gt;<br>&gt; The Proposed Solution doesn&#39;t compile with development snapshot 05-09<br>&gt; (SE-0067 hasn&#39;t landed yet, IIRC).<br></p><p><br>An (almost complete) implementation of SE-0067 floating point protocols<br>have landed in master; there have been a few nips and tucks as compared to<br>SE-0067 itself and I&#39;ve created a version of the code in this proposal to<br>compile accordingly. You can see it here:<br>https://github.com/xwu/swift/tree/SE-0050<br></p><p>There&#39;s is a wrinkle in the proposal worth discussing here during the<br>review period, and you&#39;ll notice a difference related to it if you compare<br>the code above to what&#39;s in this proposal. What should be the type of the<br>internal step counter `_step`? [BigInt types not currently in the stdlib<br>are out of scope.]<br></p><p>As proposed, _step has the same floating point type as the stride size.<br>Originally, Erica proposed an Int step counter, and I too thought that it<br>was plenty good enough. Functionally, 2^64 iterations is effectively an<br>infinite loop on modern machines. Moreover, strides have always been<br>intended to conform to Collection (though they do not in fact do so), and<br>by analogy to arrays and other collection types a maximum of Int elements<br>is quite consistent.<br></p><p>However, Stephen Canon has pointed out that using an Int step counter means<br>that the maximum number of steps on 32-bit systems is dramatically lower.<br>On the other hand, while I can readily accept that there are meaningful<br>loops with 2^32 iterations, I&#39;m unsure whether there are as many use cases<br>for floating point strides with more than 2^32 steps.<br></p><p>More concerning, though, there&#39;s a hit in performing<br>integer-to-floating-point conversion at every iteration. Recently, I tried<br>to compare the performance of floating point stride using an Int step<br>counter or a floating point one. What I had handy at the time was Swift<br>2.2; I backported both solutions and measured performance using XCTest<br>framework (making sure to use the result of the computation at each<br>iteration to prevent the compiler from optimizing away my loop). I found<br>that, at least in the several times that I performed the test, one solution<br>was not consistently faster than the other. I&#39;m not sure whether this can<br>be generalized to 32-bit platforms, and I did not dig to see if one or both<br>solutions was compiled to make use of fused multiply-add.<br></p><p>What one gains from using an Int step counter over a floating point one is<br>a consistent maximum number of steps regardless of the floating point type<br>of the endpoints. Less pertinently, when it comes to implementation detail,<br>some of the computations are a little more elegant (for instance,<br>precondition total number of steps less than Int.max rather than testing<br>whether the ULP of the total number of steps is less than or equal to one).<br></p><p><br>I hacked it to get it to compile, and<br>&gt; tested it with two problematic cases:<br>&gt;<br>&gt; Test #1:<br>&gt; let expected = Array(stride(from: 10, through: 20, by: 1).map { Float($0) *<br>&gt; 0.1 })<br>&gt; // [1.0, 1.10000002, 1.20000005, 1.30000007, 1.39999998, 1.5, 1.60000002,<br>&gt; 1.70000005, 1.80000007, 1.89999998, 2.0]<br>&gt;<br>&gt; let actual = Array(stride(from: Float(1.0), through: 2.0, by: 0.1))<br>&gt; // old result: one iteration less than expected<br>&gt; // [1.0, 1.10000002, 1.20000005, 1.30000007, 1.4000001, 1.50000012,<br>&gt; 1.60000014, 1.70000017, 1.80000019, 1.90000021]<br>&gt; // new result: correct<br>&gt; // [1.0, 1.10000002, 1.20000005, 1.29999995, 1.39999998, 1.5, 1.60000002,<br>&gt; 1.70000005, 1.79999995, 1.9000001, 2.0]<br>&gt;<br>&gt; Test #2:<br>&gt; let expected = Array(stride(from: 10, to: 100, by: 9).map { Float($0) *<br>&gt; 0.1 })<br>&gt; // [1.0, 1.89999998, 2.79999995, 3.70000005, 4.5999999, 5.5, 6.4000001,<br>&gt; 7.30000019, 8.19999981, 9.10000038]<br>&gt;<br>&gt; let actual = Array(stride(from: Float(1.0), to: 10.0, by: 0.9))<br>&gt; // old result: one iteration more than expected<br>&gt; // [1.0, 1.89999998, 2.79999995, 3.69999981, 4.5999999, 5.5, 6.4000001,<br>&gt; 7.30000019, 8.19999981, 9.09999943, 9.99999905]<br>&gt; // new result: correct<br>&gt; // [1.0, 1.89999998, 2.79999995, 3.69999981, 4.5999999, 5.5, 6.39999962,<br>&gt; 7.29999971, 8.19999981, 9.09999943]<br>&gt;<br>&gt; So the proposed solution works as advertised.<br>&gt;<br>&gt; I would suggest to include two cases like the above in the test suite.<br>&gt;<br>&gt;<br>&gt; &gt; * Is the problem being addressed significant enough to warrant a change<br>&gt; to<br>&gt; Swift?<br>&gt;<br>&gt; Yes. This is a higher level abstraction, so it&#39;s important that it<br>&gt; guarantees the best possible accuracy. The current generic implementation<br>&gt; gives unacceptably surprising results.<br>&gt;<br>&gt; &gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; Yes. It nicely follows the principle of least astonishment.<br>&gt;<br>&gt; &gt; * If you have used other languages or libraries with a similar feature,<br>&gt; how do you feel that this proposal compares to those?<br>&gt;<br>&gt; I always flat-out avoided floating point loops in other languages, fearing<br>&gt; that they would be unreliable. It&#39;s good that with this change it&#39;ll be<br>&gt; possible to use them with more confidence.<br>&gt;<br>&gt; &gt; * How much effort did you put into your review? A glance, a quick<br>&gt; reading,<br>&gt; or an in-depth study?<br>&gt;<br>&gt; careful reading, tested the proposed solution, and read and contributed to<br>&gt; the relevant threads.<br>&gt;<br>&gt; --<br>&gt; Nicola<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/18654980/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
