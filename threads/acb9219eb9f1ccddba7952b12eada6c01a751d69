<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Continuation-based versus nested-function-based materializeForSet</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 31, 2016 at 12:00:00pm</p></header><div class="content"><p>We currently abstract over mutable property accesses using what I’ll call a continuation-based model–the materializeForSet accessor is called before an inout access, and returns a continuation callback that must be called when the inout access is completed. I think a nested-function-based model, if designed correctly, has the potential to be more efficient and easier to implement.<br></p><p>As background for anyone intimately familiar with the implementation, Swift’s language model for mutable properties requires a reconciliation step after a mutation occurs. For example, in an inout access like this:<br></p><p>foo(&amp;x.y.z)<br>the y or z property may be computed, requiring a getter call before the call to foo and a setter call afterward, or either property may have willSet or didSet observers that fire after foo finishes. If the base x is a class, protocol, or generic value, the implementation of y can`t be statically known, so we need an abstract interface for mutating the property, projecting out the value at the start of the access and committing the mutated value back at the end. Ideally, the interface should accommodate efficient access to both stored and computed properties, avoiding unnecessary copying of stored properties to avoid inducing CoW copies or, in the near future, violating the constraints of move-only types or the borrow model. There are two broad approaches to doing this:<br></p><p>Continuation-based access<br></p><p>The accessor that begins the formal access can return a continuation closure to call when the access is completed. This is the approach Swift currently uses with its materializeForSet accessor pattern. A property under this model compiles to something like this C code:<br></p><p>struct X {<br>  // getter for Y<br>  Y (*getY)(const X *self);<br>  // setter for Y<br>  void (*setY)(X *self, Y newValue);<br>  // materializeForSet for Y<br>  struct MaterializeForSetReturn {<br>    // The projected field<br>    Y *y;<br>    // The function that finishes the access, or null<br>    void (*finish)(X *self, void *buffer);<br>  }; <br>  struct MaterializeForSetReturn (*materalizeForSettingY)(X *self, void *buffer);<br>};<br></p><p>void callFooOnXDotYDotZ(X *x) {<br>  // To compile:<br>  //   foo(&amp;x.y.z)<br>  // <br>  // - call the materializeForSet accessor to begin the access to y, giving it a buffer<br>  //   to store a computed value or capture state to pass to the end of the access<br>  char alignas(Y) bufferY[sizeof(Y) + 3*sizeof(void*)];<br>  auto materializedY = x-&gt;materializeForSettingY(x, bufferY);<br>  // - call materializeForSet to begin access to z<br>  char alignas(Z) bufferZ[sizeof(Z) + 3*sizeof(void*)];<br>  autom materializedZ = materializedY.y-&gt;materializeForSettingZ(materializedY.y, bufferZ);<br>  // - perform the access<br>  foo(materializedZ.z);<br>  // - finish the accesses, if we were given a finishing callback<br>  if (materializedZ.finish)<br>    materializedZ.finish(materializedY.y, bufferZ);<br>  if (materializedY.finish)<br>    materializedY.finish(x, bufferY);<br>}<br>A stored property can be exposed through this interface by trivially returning the projected address of the subobject, with no continuation:<br></p><p>struct MaterializeForSetReturn<br>materializeForSettingStoredY(X *self, void *buffer) {<br>  return (struct MaterializeForSetReturn){&amp;self-&gt;y, NULL};<br>}<br>whereas a computed property can call the getter, store the computed value into the buffer, and return a continuation function that calls the setter:<br></p><p>struct MaterializeForSetReturn<br>materializeForSettingComputedY(X *self, void *buffer) {<br>  Y oldValue = getY(self);<br>  memcpy(buffer, &amp;oldValue, sizeof(Y));<br>  return (struct MaterializeForSetReturn){(Y *)buffer, finishSettingComputedY};<br>}<br>void finishSettingComputedY(X *self, void *buffer) {<br>  Y newValue;<br>  memcpy(&amp;newValue, buffer, sizeof(Y));<br>  setY(self, newValue);<br>}<br>A benefit of this approach is that it maintains the integrity of the source function in the compiled code. On the other hand, in order for the property implementation to transfer state from the start to the completion of the access, the caller must preallocate some stack space; if it’s too much, the space is wasted, and if it’s not enough, the property implementation must use malloc to get more space for itself. (It’s theoretically possible to avoid this with some clever stack pointer accounting.) There’s also a code size impact on the caller, which needs to bracket the inout access with a call on each side. The underlying CPU has to execute three or five branches per segment of the access path (calling and returning from materializeForSet, testing for null, and potentially calling and returning from the continuation if there is one).<br></p><p>Nested functions<br></p><p>Alternatively, we can implement the formal access pattern as a series of nested functions. A property under this model compiles to something like this C code:<br></p><p>struct X {<br>  // getter for Y<br>  Y (*getY)(const X *self);<br>  // setter for Y<br>  void (*setY)(X *self, Y newValue);<br>  // mutator for Y<br>  void *(*mutateY)(X *self, void *context, void *(*innerMutation)(Y *y, void *context));<br>};<br></p><p>void callFooOnXDotYDotZ(X *x) {<br>  // To compile:<br>  //   foo(&amp;x.y)<br>  // - call the mutate accessor for y, with the inner access as a<br>  //   function whose pointer gets passed in<br>  x-&gt;mutateY(x, NULL, callFooOnXDotY_inner_1);<br>}<br>void callFooOnXDotYDotZ_inner_1(Y *y, void *context) {<br>  // - call the mutate accessor for z<br>  y-&gt;mutateZ(y, context, callFooOnXDotY_inner_2);<br>}<br>void callFooOnXDotYDotZ_inner_2(Z *z, void *context) {<br>  foo(z);<br>}<br>A stored property can implement mutate by projecting the physical address of the subobject, tail-calling the subsequent inner function:<br></p><p>void *mutateStoredY(X *self, void *context, void *(*innerMutation)(Y *y, void *context)) {<br>  /*tail*/ return innerMutation(&amp;self-&gt;y, context);<br>}<br>and a computed property can bracket the inner mutation in getter and setter calls:<br></p><p>void *mutateComputedY(X *self, void *context, void *(*innerMutation)(Y *y, void *context)) {<br>  Y value = getY(self);<br>  void *result = innerMutation(&amp;value, context);<br>  setY(self, value);<br>  return result;<br>}<br>This makes things easier for the property implementation, which can easily save as much state as it needs to on the stack instead of relying on a preallocated buffer handed down from the caller. There’s one fewer branch necessary per segment of the access path compared to the continuation-based model, either three if the accessor has no reconciliation necessary and can tail-call the inner function, or four if it does a normal call. On the other hand, the caller function has to be broken up into many smaller subfunctions, potentially one for every segment of an access path.<br></p><p>Letting nested functions walk the access path<br></p><p>We can reduce the number of nested functions that are needed for a nested access path by designing a convention that allows each mutator to directly call the mutator for the next segment of access. For example, the caller could construct the entire access path as an array of pointers to mutation functions:<br></p><p>typedef void *(*MutatorFunction)(void *base, MutatorFunction *accessPath, void *context);<br>void callFooOnXDotYDotZDotW(X *x) {<br>  // foo(&amp;x.y.z.w)<br>  MutatorFunction accessPath[] = {<br>    (MutatorFunction)mutateZ,<br>    (MutatorFunction)mutateW,<br>    (MutatorFunction)callFooOnXDotYDotZDotW_inner<br>  };<br>  mutateY(x, accessPath, NULL);<br>}<br>Each property accessor function then loads the next step of the access out of the path, and advances the pointer forward for the nested access:<br></p><p>void *mutateY(X *self, MutatorFunction *accessPath, void *context) {<br>  // Project out y<br>  Y *y = self-&gt;y;<br>  // Call the next step of the access path, passing the remainder of the access path<br>  return (*accessPath)(y, accessPath + 1, context);<br>}<br>And the inner function at the end of the access path ignores the access path parameter and performs the access:<br></p><p>void *callFooOnXDotYDotZDotW_inner(W *w, MutatorFunction *_ignored, void *context) {<br>  foo(w);<br>}<br>In this model, only one inner function needs to be broken out of the caller for the innermost inout access, at least for simple property projections. There are only two branches needed per segment, or one for segments that can tail-call the inner access. Parameterized segments such as subscripts can be supported by storing the parameters in the access path buffer as well, and having the subscript accessor advance past the parameters when it consumes them. For example:<br></p><p>void callFooOnXDotYSubIDotZ(X *x, intptr_t i) {<br>  // foo(&amp;x.y[i].z)<br>  uintptr_t accessPath[] = {<br>    (uintptr_t)mutateYSubscript,<br>    (uintptr_t)i,<br>    (uintptr_t)mutateZ,<br>    (uintptr_t)callFooOnXDotYSubIDotZ_inner<br>  };<br>  <br>  mutateY(x, accessPath, NULL);<br>}<br></p><p>void *mutateYSubscript(Y *y, uintptr_t *accessPath, void *context) {<br>  // Get the subscript index out of the access path<br>  intptr_t i = (intptr_t)*accessPath++;<br>  // Get the next step of the access out of the access path<br>  MutatorFunction next = (MutatorFunction)*accessPath++;<br>  <br>  return next(&amp;y-&gt;elements[i], accessPath, context);<br>}<br>On the other hand, this does push the inner access functions and subscript arguments onto the stack, which is a small amount of overhead. Furthermore, the caller function has to push any state it needs to pass from outside the access to inside on the stack as well, if it isn’t able to cram it otherwise into a single context pointer argument.<br></p><p>Machine-level calling convention tricks<br></p><p>To be able to feed a return value from the inner access back to the outer caller, nested mutators would need to preserve all of the return registers potentially used by the inner access on the way out of the access. To minimize the impact on the outer caller, the convention for mutators could also specify that they need to preserve the contents of callee-save registers when they call down to nested accesses. This should allow as much state to be kept in registers between the outer caller and inner access as if they were naturally in the same function, with at most a function call in between.<br></p><p>With these sorts of optimizations, I think the nested function approach has the potential to be competitive with, or even more efficient than, our current continuation-based materializeForSet design.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161031/acb91d69/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Continuation-based versus nested-function-based materializeForSet</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>November  1, 2016 at 11:00:00am</p></header><div class="content"><p>I like the idea; it makes more sense to me than our current model (which feels more like a plain callback than a continuation to me). Some things that occurred to me when reading this:<br></p><p>- This seems like it&#39;ll be much simpler to check for invalid concurrent access to the same location (inout violations) in debug builds. (I don&#39;t think it&#39;s actually any more or less possible, but it is simpler.)<br></p><p>- This will look funny but work fine for multiple inout parameters: foo(&amp;x, &amp;y)<br></p><p>- OTOH, this does break up basic blocks in the caller context, making LLVM analysis less effective. Since the materializeForSet calls were already either inlined or opaque, though, we&#39;re probably fine there.<br></p><p>- Does this help us with the nested dictionary CoW problem? `foo[&quot;bar&quot;][&quot;baz&quot;] += 1`<br></p><p>Jordan<br></p><p><br></p><p>&gt; On Oct 31, 2016, at 12:22, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; We currently abstract over mutable property accesses using what I’ll call a continuation-based model–the materializeForSet accessor is called before an inout access, and returns a continuation callback that must be called when the inout access is completed. I think a nested-function-based model, if designed correctly, has the potential to be more efficient and easier to implement.<br>&gt; <br>&gt; As background for anyone intimately familiar with the implementation, Swift’s language model for mutable properties requires a reconciliation step after a mutation occurs. For example, in an inout access like this:<br>&gt; <br>&gt; foo(&amp;x.y.z)<br>&gt; the y or z property may be computed, requiring a getter call before the call to foo and a setter call afterward, or either property may have willSet or didSet observers that fire after foo finishes. If the base x is a class, protocol, or generic value, the implementation of y can`t be statically known, so we need an abstract interface for mutating the property, projecting out the value at the start of the access and committing the mutated value back at the end. Ideally, the interface should accommodate efficient access to both stored and computed properties, avoiding unnecessary copying of stored properties to avoid inducing CoW copies or, in the near future, violating the constraints of move-only types or the borrow model. There are two broad approaches to doing this:<br>&gt; <br>&gt; Continuation-based access<br>&gt; <br>&gt; The accessor that begins the formal access can return a continuation closure to call when the access is completed. This is the approach Swift currently uses with its materializeForSet accessor pattern. A property under this model compiles to something like this C code:<br>&gt; <br>&gt; struct X {<br>&gt;   // getter for Y<br>&gt;   Y (*getY)(const X *self);<br>&gt;   // setter for Y<br>&gt;   void (*setY)(X *self, Y newValue);<br>&gt;   // materializeForSet for Y<br>&gt;   struct MaterializeForSetReturn {<br>&gt;     // The projected field<br>&gt;     Y *y;<br>&gt;     // The function that finishes the access, or null<br>&gt;     void (*finish)(X *self, void *buffer);<br>&gt;   }; <br>&gt;   struct MaterializeForSetReturn (*materalizeForSettingY)(X *self, void *buffer);<br>&gt; };<br>&gt; <br>&gt; void callFooOnXDotYDotZ(X *x) {<br>&gt;   // To compile:<br>&gt;   //   foo(&amp;x.y.z)<br>&gt;   // <br>&gt;   // - call the materializeForSet accessor to begin the access to y, giving it a buffer<br>&gt;   //   to store a computed value or capture state to pass to the end of the access<br>&gt;   char alignas(Y) bufferY[sizeof(Y) + 3*sizeof(void*)];<br>&gt;   auto materializedY = x-&gt;materializeForSettingY(x, bufferY);<br>&gt;   // - call materializeForSet to begin access to z<br>&gt;   char alignas(Z) bufferZ[sizeof(Z) + 3*sizeof(void*)];<br>&gt;   autom materializedZ = materializedY.y-&gt;materializeForSettingZ(materializedY.y, bufferZ);<br>&gt;   // - perform the access<br>&gt;   foo(materializedZ.z);<br>&gt;   // - finish the accesses, if we were given a finishing callback<br>&gt;   if (materializedZ.finish)<br>&gt;     materializedZ.finish(materializedY.y, bufferZ);<br>&gt;   if (materializedY.finish)<br>&gt;     materializedY.finish(x, bufferY);<br>&gt; }<br>&gt; A stored property can be exposed through this interface by trivially returning the projected address of the subobject, with no continuation:<br>&gt; <br>&gt; struct MaterializeForSetReturn<br>&gt; materializeForSettingStoredY(X *self, void *buffer) {<br>&gt;   return (struct MaterializeForSetReturn){&amp;self-&gt;y, NULL};<br>&gt; }<br>&gt; whereas a computed property can call the getter, store the computed value into the buffer, and return a continuation function that calls the setter:<br>&gt; <br>&gt; struct MaterializeForSetReturn<br>&gt; materializeForSettingComputedY(X *self, void *buffer) {<br>&gt;   Y oldValue = getY(self);<br>&gt;   memcpy(buffer, &amp;oldValue, sizeof(Y));<br>&gt;   return (struct MaterializeForSetReturn){(Y *)buffer, finishSettingComputedY};<br>&gt; }<br>&gt; void finishSettingComputedY(X *self, void *buffer) {<br>&gt;   Y newValue;<br>&gt;   memcpy(&amp;newValue, buffer, sizeof(Y));<br>&gt;   setY(self, newValue);<br>&gt; }<br>&gt; A benefit of this approach is that it maintains the integrity of the source function in the compiled code. On the other hand, in order for the property implementation to transfer state from the start to the completion of the access, the caller must preallocate some stack space; if it’s too much, the space is wasted, and if it’s not enough, the property implementation must use malloc to get more space for itself. (It’s theoretically possible to avoid this with some clever stack pointer accounting.) There’s also a code size impact on the caller, which needs to bracket the inout access with a call on each side. The underlying CPU has to execute three or five branches per segment of the access path (calling and returning from materializeForSet, testing for null, and potentially calling and returning from the continuation if there is one).<br>&gt; <br>&gt; Nested functions<br>&gt; <br>&gt; Alternatively, we can implement the formal access pattern as a series of nested functions. A property under this model compiles to something like this C code:<br>&gt; <br>&gt; struct X {<br>&gt;   // getter for Y<br>&gt;   Y (*getY)(const X *self);<br>&gt;   // setter for Y<br>&gt;   void (*setY)(X *self, Y newValue);<br>&gt;   // mutator for Y<br>&gt;   void *(*mutateY)(X *self, void *context, void *(*innerMutation)(Y *y, void *context));<br>&gt; };<br>&gt; <br>&gt; void callFooOnXDotYDotZ(X *x) {<br>&gt;   // To compile:<br>&gt;   //   foo(&amp;x.y)<br>&gt;   // - call the mutate accessor for y, with the inner access as a<br>&gt;   //   function whose pointer gets passed in<br>&gt;   x-&gt;mutateY(x, NULL, callFooOnXDotY_inner_1);<br>&gt; }<br>&gt; void callFooOnXDotYDotZ_inner_1(Y *y, void *context) {<br>&gt;   // - call the mutate accessor for z<br>&gt;   y-&gt;mutateZ(y, context, callFooOnXDotY_inner_2);<br>&gt; }<br>&gt; void callFooOnXDotYDotZ_inner_2(Z *z, void *context) {<br>&gt;   foo(z);<br>&gt; }<br>&gt; A stored property can implement mutate by projecting the physical address of the subobject, tail-calling the subsequent inner function:<br>&gt; <br>&gt; void *mutateStoredY(X *self, void *context, void *(*innerMutation)(Y *y, void *context)) {<br>&gt;   /*tail*/ return innerMutation(&amp;self-&gt;y, context);<br>&gt; }<br>&gt; and a computed property can bracket the inner mutation in getter and setter calls:<br>&gt; <br>&gt; void *mutateComputedY(X *self, void *context, void *(*innerMutation)(Y *y, void *context)) {<br>&gt;   Y value = getY(self);<br>&gt;   void *result = innerMutation(&amp;value, context);<br>&gt;   setY(self, value);<br>&gt;   return result;<br>&gt; }<br>&gt; This makes things easier for the property implementation, which can easily save as much state as it needs to on the stack instead of relying on a preallocated buffer handed down from the caller. There’s one fewer branch necessary per segment of the access path compared to the continuation-based model, either three if the accessor has no reconciliation necessary and can tail-call the inner function, or four if it does a normal call. On the other hand, the caller function has to be broken up into many smaller subfunctions, potentially one for every segment of an access path.<br>&gt; <br>&gt; Letting nested functions walk the access path<br>&gt; <br>&gt; We can reduce the number of nested functions that are needed for a nested access path by designing a convention that allows each mutator to directly call the mutator for the next segment of access. For example, the caller could construct the entire access path as an array of pointers to mutation functions:<br>&gt; <br>&gt; typedef void *(*MutatorFunction)(void *base, MutatorFunction *accessPath, void *context);<br>&gt; void callFooOnXDotYDotZDotW(X *x) {<br>&gt;   // foo(&amp;x.y.z.w)<br>&gt;   MutatorFunction accessPath[] = {<br>&gt;     (MutatorFunction)mutateZ,<br>&gt;     (MutatorFunction)mutateW,<br>&gt;     (MutatorFunction)callFooOnXDotYDotZDotW_inner<br>&gt;   };<br>&gt;   mutateY(x, accessPath, NULL);<br>&gt; }<br>&gt; Each property accessor function then loads the next step of the access out of the path, and advances the pointer forward for the nested access:<br>&gt; <br>&gt; void *mutateY(X *self, MutatorFunction *accessPath, void *context) {<br>&gt;   // Project out y<br>&gt;   Y *y = self-&gt;y;<br>&gt;   // Call the next step of the access path, passing the remainder of the access path<br>&gt;   return (*accessPath)(y, accessPath + 1, context);<br>&gt; }<br>&gt; And the inner function at the end of the access path ignores the access path parameter and performs the access:<br>&gt; <br>&gt; void *callFooOnXDotYDotZDotW_inner(W *w, MutatorFunction *_ignored, void *context) {<br>&gt;   foo(w);<br>&gt; }<br>&gt; In this model, only one inner function needs to be broken out of the caller for the innermost inout access, at least for simple property projections. There are only two branches needed per segment, or one for segments that can tail-call the inner access. Parameterized segments such as subscripts can be supported by storing the parameters in the access path buffer as well, and having the subscript accessor advance past the parameters when it consumes them. For example:<br>&gt; <br>&gt; void callFooOnXDotYSubIDotZ(X *x, intptr_t i) {<br>&gt;   // foo(&amp;x.y[i].z)<br>&gt;   uintptr_t accessPath[] = {<br>&gt;     (uintptr_t)mutateYSubscript,<br>&gt;     (uintptr_t)i,<br>&gt;     (uintptr_t)mutateZ,<br>&gt;     (uintptr_t)callFooOnXDotYSubIDotZ_inner<br>&gt;   };<br>&gt;   <br>&gt;   mutateY(x, accessPath, NULL);<br>&gt; }<br>&gt; <br>&gt; void *mutateYSubscript(Y *y, uintptr_t *accessPath, void *context) {<br>&gt;   // Get the subscript index out of the access path<br>&gt;   intptr_t i = (intptr_t)*accessPath++;<br>&gt;   // Get the next step of the access out of the access path<br>&gt;   MutatorFunction next = (MutatorFunction)*accessPath++;<br>&gt;   <br>&gt;   return next(&amp;y-&gt;elements[i], accessPath, context);<br>&gt; }<br>&gt; On the other hand, this does push the inner access functions and subscript arguments onto the stack, which is a small amount of overhead. Furthermore, the caller function has to push any state it needs to pass from outside the access to inside on the stack as well, if it isn’t able to cram it otherwise into a single context pointer argument.<br>&gt; <br>&gt; Machine-level calling convention tricks<br>&gt; <br>&gt; To be able to feed a return value from the inner access back to the outer caller, nested mutators would need to preserve all of the return registers potentially used by the inner access on the way out of the access. To minimize the impact on the outer caller, the convention for mutators could also specify that they need to preserve the contents of callee-save registers when they call down to nested accesses. This should allow as much state to be kept in registers between the outer caller and inner access as if they were naturally in the same function, with at most a function call in between.<br>&gt; <br>&gt; With these sorts of optimizations, I think the nested function approach has the potential to be competitive with, or even more efficient than, our current continuation-based materializeForSet design.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161101/ad544b5f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Continuation-based versus nested-function-based materializeForSet</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>November  1, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Nov 1, 2016, at 11:00 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; I like the idea; it makes more sense to me than our current model (which feels more like a plain callback than a continuation to me). Some things that occurred to me when reading this:<br>&gt; <br>&gt; - This seems like it&#39;ll be much simpler to check for invalid concurrent access to the same location (inout violations) in debug builds. (I don&#39;t think it&#39;s actually any more or less possible, but it is simpler.)<br>&gt; <br>&gt; - This will look funny but work fine for multiple inout parameters: foo(&amp;x, &amp;y)<br>&gt; <br>&gt; - OTOH, this does break up basic blocks in the caller context, making LLVM analysis less effective. Since the materializeForSet calls were already either inlined or opaque, though, we&#39;re probably fine there.<br></p><p>True. John mentioned that LLVM has grown some support for subfunction extraction in support of C++1z coroutines; we might be able to leverage that so that the IR still looks materializeForSet-ish even though we lower things differently.<br></p><p>&gt; - Does this help us with the nested dictionary CoW problem? `foo[&quot;bar&quot;][&quot;baz&quot;] += 1`<br></p><p>I think the dictionary problem can be addressed in either implementation model, if we open up the language to express generalized &quot;mutators&quot; instead of just special-cased addressors. With strict enforcement of `inout`, the dictionary implementation would have the worst-case freedom to move an indexed value into a temporary without copying it, and move it back at the end of the access, if we&#39;re unable to otherwise represent it entirely as an in-place operation.<br></p><p>-Joe<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Continuation-based versus nested-function-based materializeForSet</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>November  1, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Nov 1, 2016, at 11:00 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; - Does this help us with the nested dictionary CoW problem? `foo[&quot;bar&quot;][&quot;baz&quot;] += 1`<br></p><p>My understanding is that this problem arises because we don’t have ‘optional addressors’. A dictionary lookup might return nil. If addressors had a way to return an optional wrapping a pointer, and optional evaluation supported this, we could do in-place updates of this kind. For Apple people: I have a radar that I think describes this problem (rdar://17509619).<br></p><p>Slava<br></p><p>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Oct 31, 2016, at 12:22, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We currently abstract over mutable property accesses using what I’ll call a continuation-based model–the materializeForSet accessor is called before an inout access, and returns a continuation callback that must be called when the inout access is completed. I think a nested-function-based model, if designed correctly, has the potential to be more efficient and easier to implement.<br>&gt;&gt; <br>&gt;&gt; As background for anyone intimately familiar with the implementation, Swift’s language model for mutable properties requires a reconciliation step after a mutation occurs. For example, in an inout access like this:<br>&gt;&gt; <br>&gt;&gt; foo(&amp;x.y.z)<br>&gt;&gt; the y or z property may be computed, requiring a getter call before the call to foo and a setter call afterward, or either property may have willSet or didSet observers that fire after foo finishes. If the base x is a class, protocol, or generic value, the implementation of y can`t be statically known, so we need an abstract interface for mutating the property, projecting out the value at the start of the access and committing the mutated value back at the end. Ideally, the interface should accommodate efficient access to both stored and computed properties, avoiding unnecessary copying of stored properties to avoid inducing CoW copies or, in the near future, violating the constraints of move-only types or the borrow model. There are two broad approaches to doing this:<br>&gt;&gt; <br>&gt;&gt; Continuation-based access<br>&gt;&gt; <br>&gt;&gt; The accessor that begins the formal access can return a continuation closure to call when the access is completed. This is the approach Swift currently uses with its materializeForSet accessor pattern. A property under this model compiles to something like this C code:<br>&gt;&gt; <br>&gt;&gt; struct X {<br>&gt;&gt;   // getter for Y<br>&gt;&gt;   Y (*getY)(const X *self);<br>&gt;&gt;   // setter for Y<br>&gt;&gt;   void (*setY)(X *self, Y newValue);<br>&gt;&gt;   // materializeForSet for Y<br>&gt;&gt;   struct MaterializeForSetReturn {<br>&gt;&gt;     // The projected field<br>&gt;&gt;     Y *y;<br>&gt;&gt;     // The function that finishes the access, or null<br>&gt;&gt;     void (*finish)(X *self, void *buffer);<br>&gt;&gt;   }; <br>&gt;&gt;   struct MaterializeForSetReturn (*materalizeForSettingY)(X *self, void *buffer);<br>&gt;&gt; };<br>&gt;&gt; <br>&gt;&gt; void callFooOnXDotYDotZ(X *x) {<br>&gt;&gt;   // To compile:<br>&gt;&gt;   //   foo(&amp;x.y.z)<br>&gt;&gt;   // <br>&gt;&gt;   // - call the materializeForSet accessor to begin the access to y, giving it a buffer<br>&gt;&gt;   //   to store a computed value or capture state to pass to the end of the access<br>&gt;&gt;   char alignas(Y) bufferY[sizeof(Y) + 3*sizeof(void*)];<br>&gt;&gt;   auto materializedY = x-&gt;materializeForSettingY(x, bufferY);<br>&gt;&gt;   // - call materializeForSet to begin access to z<br>&gt;&gt;   char alignas(Z) bufferZ[sizeof(Z) + 3*sizeof(void*)];<br>&gt;&gt;   autom materializedZ = materializedY.y-&gt;materializeForSettingZ(materializedY.y, bufferZ);<br>&gt;&gt;   // - perform the access<br>&gt;&gt;   foo(materializedZ.z);<br>&gt;&gt;   // - finish the accesses, if we were given a finishing callback<br>&gt;&gt;   if (materializedZ.finish)<br>&gt;&gt;     materializedZ.finish(materializedY.y, bufferZ);<br>&gt;&gt;   if (materializedY.finish)<br>&gt;&gt;     materializedY.finish(x, bufferY);<br>&gt;&gt; }<br>&gt;&gt; A stored property can be exposed through this interface by trivially returning the projected address of the subobject, with no continuation:<br>&gt;&gt; <br>&gt;&gt; struct MaterializeForSetReturn<br>&gt;&gt; materializeForSettingStoredY(X *self, void *buffer) {<br>&gt;&gt;   return (struct MaterializeForSetReturn){&amp;self-&gt;y, NULL};<br>&gt;&gt; }<br>&gt;&gt; whereas a computed property can call the getter, store the computed value into the buffer, and return a continuation function that calls the setter:<br>&gt;&gt; <br>&gt;&gt; struct MaterializeForSetReturn<br>&gt;&gt; materializeForSettingComputedY(X *self, void *buffer) {<br>&gt;&gt;   Y oldValue = getY(self);<br>&gt;&gt;   memcpy(buffer, &amp;oldValue, sizeof(Y));<br>&gt;&gt;   return (struct MaterializeForSetReturn){(Y *)buffer, finishSettingComputedY};<br>&gt;&gt; }<br>&gt;&gt; void finishSettingComputedY(X *self, void *buffer) {<br>&gt;&gt;   Y newValue;<br>&gt;&gt;   memcpy(&amp;newValue, buffer, sizeof(Y));<br>&gt;&gt;   setY(self, newValue);<br>&gt;&gt; }<br>&gt;&gt; A benefit of this approach is that it maintains the integrity of the source function in the compiled code. On the other hand, in order for the property implementation to transfer state from the start to the completion of the access, the caller must preallocate some stack space; if it’s too much, the space is wasted, and if it’s not enough, the property implementation must use malloc to get more space for itself. (It’s theoretically possible to avoid this with some clever stack pointer accounting.) There’s also a code size impact on the caller, which needs to bracket the inout access with a call on each side. The underlying CPU has to execute three or five branches per segment of the access path (calling and returning from materializeForSet, testing for null, and potentially calling and returning from the continuation if there is one).<br>&gt;&gt; <br>&gt;&gt; Nested functions<br>&gt;&gt; <br>&gt;&gt; Alternatively, we can implement the formal access pattern as a series of nested functions. A property under this model compiles to something like this C code:<br>&gt;&gt; <br>&gt;&gt; struct X {<br>&gt;&gt;   // getter for Y<br>&gt;&gt;   Y (*getY)(const X *self);<br>&gt;&gt;   // setter for Y<br>&gt;&gt;   void (*setY)(X *self, Y newValue);<br>&gt;&gt;   // mutator for Y<br>&gt;&gt;   void *(*mutateY)(X *self, void *context, void *(*innerMutation)(Y *y, void *context));<br>&gt;&gt; };<br>&gt;&gt; <br>&gt;&gt; void callFooOnXDotYDotZ(X *x) {<br>&gt;&gt;   // To compile:<br>&gt;&gt;   //   foo(&amp;x.y)<br>&gt;&gt;   // - call the mutate accessor for y, with the inner access as a<br>&gt;&gt;   //   function whose pointer gets passed in<br>&gt;&gt;   x-&gt;mutateY(x, NULL, callFooOnXDotY_inner_1);<br>&gt;&gt; }<br>&gt;&gt; void callFooOnXDotYDotZ_inner_1(Y *y, void *context) {<br>&gt;&gt;   // - call the mutate accessor for z<br>&gt;&gt;   y-&gt;mutateZ(y, context, callFooOnXDotY_inner_2);<br>&gt;&gt; }<br>&gt;&gt; void callFooOnXDotYDotZ_inner_2(Z *z, void *context) {<br>&gt;&gt;   foo(z);<br>&gt;&gt; }<br>&gt;&gt; A stored property can implement mutate by projecting the physical address of the subobject, tail-calling the subsequent inner function:<br>&gt;&gt; <br>&gt;&gt; void *mutateStoredY(X *self, void *context, void *(*innerMutation)(Y *y, void *context)) {<br>&gt;&gt;   /*tail*/ return innerMutation(&amp;self-&gt;y, context);<br>&gt;&gt; }<br>&gt;&gt; and a computed property can bracket the inner mutation in getter and setter calls:<br>&gt;&gt; <br>&gt;&gt; void *mutateComputedY(X *self, void *context, void *(*innerMutation)(Y *y, void *context)) {<br>&gt;&gt;   Y value = getY(self);<br>&gt;&gt;   void *result = innerMutation(&amp;value, context);<br>&gt;&gt;   setY(self, value);<br>&gt;&gt;   return result;<br>&gt;&gt; }<br>&gt;&gt; This makes things easier for the property implementation, which can easily save as much state as it needs to on the stack instead of relying on a preallocated buffer handed down from the caller. There’s one fewer branch necessary per segment of the access path compared to the continuation-based model, either three if the accessor has no reconciliation necessary and can tail-call the inner function, or four if it does a normal call. On the other hand, the caller function has to be broken up into many smaller subfunctions, potentially one for every segment of an access path.<br>&gt;&gt; <br>&gt;&gt; Letting nested functions walk the access path<br>&gt;&gt; <br>&gt;&gt; We can reduce the number of nested functions that are needed for a nested access path by designing a convention that allows each mutator to directly call the mutator for the next segment of access. For example, the caller could construct the entire access path as an array of pointers to mutation functions:<br>&gt;&gt; <br>&gt;&gt; typedef void *(*MutatorFunction)(void *base, MutatorFunction *accessPath, void *context);<br>&gt;&gt; void callFooOnXDotYDotZDotW(X *x) {<br>&gt;&gt;   // foo(&amp;x.y.z.w)<br>&gt;&gt;   MutatorFunction accessPath[] = {<br>&gt;&gt;     (MutatorFunction)mutateZ,<br>&gt;&gt;     (MutatorFunction)mutateW,<br>&gt;&gt;     (MutatorFunction)callFooOnXDotYDotZDotW_inner<br>&gt;&gt;   };<br>&gt;&gt;   mutateY(x, accessPath, NULL);<br>&gt;&gt; }<br>&gt;&gt; Each property accessor function then loads the next step of the access out of the path, and advances the pointer forward for the nested access:<br>&gt;&gt; <br>&gt;&gt; void *mutateY(X *self, MutatorFunction *accessPath, void *context) {<br>&gt;&gt;   // Project out y<br>&gt;&gt;   Y *y = self-&gt;y;<br>&gt;&gt;   // Call the next step of the access path, passing the remainder of the access path<br>&gt;&gt;   return (*accessPath)(y, accessPath + 1, context);<br>&gt;&gt; }<br>&gt;&gt; And the inner function at the end of the access path ignores the access path parameter and performs the access:<br>&gt;&gt; <br>&gt;&gt; void *callFooOnXDotYDotZDotW_inner(W *w, MutatorFunction *_ignored, void *context) {<br>&gt;&gt;   foo(w);<br>&gt;&gt; }<br>&gt;&gt; In this model, only one inner function needs to be broken out of the caller for the innermost inout access, at least for simple property projections. There are only two branches needed per segment, or one for segments that can tail-call the inner access. Parameterized segments such as subscripts can be supported by storing the parameters in the access path buffer as well, and having the subscript accessor advance past the parameters when it consumes them. For example:<br>&gt;&gt; <br>&gt;&gt; void callFooOnXDotYSubIDotZ(X *x, intptr_t i) {<br>&gt;&gt;   // foo(&amp;x.y[i].z)<br>&gt;&gt;   uintptr_t accessPath[] = {<br>&gt;&gt;     (uintptr_t)mutateYSubscript,<br>&gt;&gt;     (uintptr_t)i,<br>&gt;&gt;     (uintptr_t)mutateZ,<br>&gt;&gt;     (uintptr_t)callFooOnXDotYSubIDotZ_inner<br>&gt;&gt;   };<br>&gt;&gt;   <br>&gt;&gt;   mutateY(x, accessPath, NULL);<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; void *mutateYSubscript(Y *y, uintptr_t *accessPath, void *context) {<br>&gt;&gt;   // Get the subscript index out of the access path<br>&gt;&gt;   intptr_t i = (intptr_t)*accessPath++;<br>&gt;&gt;   // Get the next step of the access out of the access path<br>&gt;&gt;   MutatorFunction next = (MutatorFunction)*accessPath++;<br>&gt;&gt;   <br>&gt;&gt;   return next(&amp;y-&gt;elements[i], accessPath, context);<br>&gt;&gt; }<br>&gt;&gt; On the other hand, this does push the inner access functions and subscript arguments onto the stack, which is a small amount of overhead. Furthermore, the caller function has to push any state it needs to pass from outside the access to inside on the stack as well, if it isn’t able to cram it otherwise into a single context pointer argument.<br>&gt;&gt; <br>&gt;&gt; Machine-level calling convention tricks<br>&gt;&gt; <br>&gt;&gt; To be able to feed a return value from the inner access back to the outer caller, nested mutators would need to preserve all of the return registers potentially used by the inner access on the way out of the access. To minimize the impact on the outer caller, the convention for mutators could also specify that they need to preserve the contents of callee-save registers when they call down to nested accesses. This should allow as much state to be kept in registers between the outer caller and inner access as if they were naturally in the same function, with at most a function call in between.<br>&gt;&gt; <br>&gt;&gt; With these sorts of optimizations, I think the nested function approach has the potential to be competitive with, or even more efficient than, our current continuation-based materializeForSet design.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161101/cae4d797/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Continuation-based versus nested-function-based materializeForSet</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>November  2, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Nov 1, 2016, at 9:23 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Nov 1, 2016, at 11:00 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; - Does this help us with the nested dictionary CoW problem? `foo[&quot;bar&quot;][&quot;baz&quot;] += 1`<br>&gt; <br>&gt; My understanding is that this problem arises because we don’t have ‘optional addressors’. A dictionary lookup might return nil. If addressors had a way to return an optional wrapping a pointer, and optional evaluation supported this, we could do in-place updates of this kind. For Apple people: I have a radar that I think describes this problem (rdar://17509619).<br></p><p>I think our long-term goal here is to let the property definition fully control the `inout` access with a coroutine-like definition, something like:<br></p><p>var foo: T {<br>  get { return /*value for read-only access*/ }<br>  set { _foo = /*write-only access*/ }<br>  mutate {<br>    var tmp = prepareForMutation()<br>    yield &amp;tmp // continue nested inout access<br>    reconcileMutation(tmp)<br>  }<br>}<br></p><p>This should let the dictionary implementation do whatever it needs to present a moved Optional value to the chained access. If Dictionary can&#39;t store Optionals directly inline in all cases, we ought to still be able to rely on enforced inout uniqueness to get away with moving in and out of a temporary.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Continuation-based versus nested-function-based materializeForSet</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>November  2, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Nov 2, 2016, at 9:05 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; On Nov 1, 2016, at 9:23 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Nov 1, 2016, at 11:00 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Does this help us with the nested dictionary CoW problem? `foo[&quot;bar&quot;][&quot;baz&quot;] += 1`<br>&gt;&gt; <br>&gt;&gt; My understanding is that this problem arises because we don’t have ‘optional addressors’. A dictionary lookup might return nil. If addressors had a way to return an optional wrapping a pointer, and optional evaluation supported this, we could do in-place updates of this kind. For Apple people: I have a radar that I think describes this problem (rdar://17509619).<br>&gt; <br>&gt; I think our long-term goal here is to let the property definition fully control the `inout` access with a coroutine-like definition, something like:<br>&gt; <br>&gt; var foo: T {<br>&gt;  get { return /*value for read-only access*/ }<br>&gt;  set { _foo = /*write-only access*/ }<br>&gt;  mutate {<br>&gt;    var tmp = prepareForMutation()<br>&gt;    yield &amp;tmp // continue nested inout access<br>&gt;    reconcileMutation(tmp)<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; This should let the dictionary implementation do whatever it needs to present a moved Optional value to the chained access. If Dictionary can&#39;t store Optionals directly inline in all cases, we ought to still be able to rely on enforced inout uniqueness to get away with moving in and out of a temporary.<br></p><p>It&#39;s tricky, because if Dictionary is going to support non-movable values, then we also want the non-mutating accessor to be able to return a Borrowed&lt;Optional&lt;V&gt;&gt;, which it can&#39;t do if that representation has to be a pointer to an Optional&lt;V&gt;.  It can returned an Optional&lt;Borrowed&lt;V&gt;&gt; just fine, of course.<br></p><p>This relates to the earlier conversation we had about borrowed tuples.  We may have to make the representation of a Borrowed&lt;T&gt; potentially different from just a T*, and that really stinks.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Continuation-based versus nested-function-based materializeForSet</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>November  2, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Nov 2, 2016, at 11:38 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Nov 2, 2016, at 9:05 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Nov 1, 2016, at 9:23 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Nov 1, 2016, at 11:00 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Does this help us with the nested dictionary CoW problem? `foo[&quot;bar&quot;][&quot;baz&quot;] += 1`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My understanding is that this problem arises because we don’t have ‘optional addressors’. A dictionary lookup might return nil. If addressors had a way to return an optional wrapping a pointer, and optional evaluation supported this, we could do in-place updates of this kind. For Apple people: I have a radar that I think describes this problem (rdar://17509619).<br>&gt;&gt; <br>&gt;&gt; I think our long-term goal here is to let the property definition fully control the `inout` access with a coroutine-like definition, something like:<br>&gt;&gt; <br>&gt;&gt; var foo: T {<br>&gt;&gt; get { return /*value for read-only access*/ }<br>&gt;&gt; set { _foo = /*write-only access*/ }<br>&gt;&gt; mutate {<br>&gt;&gt;   var tmp = prepareForMutation()<br>&gt;&gt;   yield &amp;tmp // continue nested inout access<br>&gt;&gt;   reconcileMutation(tmp)<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This should let the dictionary implementation do whatever it needs to present a moved Optional value to the chained access. If Dictionary can&#39;t store Optionals directly inline in all cases, we ought to still be able to rely on enforced inout uniqueness to get away with moving in and out of a temporary.<br>&gt; <br>&gt; It&#39;s tricky, because if Dictionary is going to support non-movable values,<br></p><p>Sorry, I obviously meant move-only (i.e. non-copyable) values here.  I keep making this mistake.<br></p><p>John.<br></p><p>&gt; then we also want the non-mutating accessor to be able to return a Borrowed&lt;Optional&lt;V&gt;&gt;, which it can&#39;t do if that representation has to be a pointer to an Optional&lt;V&gt;.  It can returned an Optional&lt;Borrowed&lt;V&gt;&gt; just fine, of course.<br>&gt; <br>&gt; This relates to the earlier conversation we had about borrowed tuples.  We may have to make the representation of a Borrowed&lt;T&gt; potentially different from just a T*, and that really stinks.<br>&gt; <br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Continuation-based versus nested-function-based materializeForSet</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>November  2, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Nov 2, 2016, at 11:38 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Nov 2, 2016, at 9:05 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Nov 1, 2016, at 9:23 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Nov 1, 2016, at 11:00 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Does this help us with the nested dictionary CoW problem? `foo[&quot;bar&quot;][&quot;baz&quot;] += 1`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My understanding is that this problem arises because we don’t have ‘optional addressors’. A dictionary lookup might return nil. If addressors had a way to return an optional wrapping a pointer, and optional evaluation supported this, we could do in-place updates of this kind. For Apple people: I have a radar that I think describes this problem (rdar://17509619).<br>&gt;&gt; <br>&gt;&gt; I think our long-term goal here is to let the property definition fully control the `inout` access with a coroutine-like definition, something like:<br>&gt;&gt; <br>&gt;&gt; var foo: T {<br>&gt;&gt; get { return /*value for read-only access*/ }<br>&gt;&gt; set { _foo = /*write-only access*/ }<br>&gt;&gt; mutate {<br>&gt;&gt;   var tmp = prepareForMutation()<br>&gt;&gt;   yield &amp;tmp // continue nested inout access<br>&gt;&gt;   reconcileMutation(tmp)<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This should let the dictionary implementation do whatever it needs to present a moved Optional value to the chained access. If Dictionary can&#39;t store Optionals directly inline in all cases, we ought to still be able to rely on enforced inout uniqueness to get away with moving in and out of a temporary.<br>&gt; <br>&gt; It&#39;s tricky, because if Dictionary is going to support non-movable values, then we also want the non-mutating accessor to be able to return a Borrowed&lt;Optional&lt;V&gt;&gt;, which it can&#39;t do if that representation has to be a pointer to an Optional&lt;V&gt;.  It can returned an Optional&lt;Borrowed&lt;V&gt;&gt; just fine, of course.<br>&gt; <br>&gt; This relates to the earlier conversation we had about borrowed tuples.  We may have to make the representation of a Borrowed&lt;T&gt; potentially different from just a T*, and that really stinks.<br></p><p>Being able to model an access as Optional&lt;borrowed T&gt; or Optional&lt;inout T&gt; might fit better with the move-only types model for dictionaries, and would be useful for other things like optional protocol members and properties found on AnyObject. Dictionaries have the &quot;delete&quot; operation to shoehorn into the `inout Optional&lt;T&gt;` model and give `foo[&quot;bar&quot;] = nil` meaning, but there are other mutation interfaces for which that isn&#39;t true. (Even for dictionaries, I&#39;ve always felt it was a bit of a hack.)<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161102/ccf15040/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Continuation-based versus nested-function-based materializeForSet</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>November  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Oct 31, 2016, at 12:22 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; We currently abstract over mutable property accesses using what I’ll call a continuation-based model–the materializeForSet accessor is called before an inout access, and returns a continuation callback that must be called when the inout access is completed. I think a nested-function-based model, if designed correctly, has the potential to be more efficient and easier to implement.<br></p><p>Well, I&#39;m not totally convinced about either of those two points, but it&#39;s definitely something we need to talk about.<br></p><p>Let me try to break this down.  I think I&#39;m going to repeat you a lot in different words.<br></p><p>We have a coroutine-esque problem:<br>  0. Outer is executing.<br>  1. Outer calls Inner.<br>  2. Inner executes for a while.<br>  3. Inner passes control back to Outer without abandoning its execution context.<br>  4. Outer executes for awhile.<br>  5. Outer passes control back to Inner, potentially having changed its own execution context.<br>  6. Inner executes for awhile.<br>  7. Inner finally abandons its execution context and passes control back to Outer.<br>  8. Outer is executing.<br></p><p>Note that there might be multiple static points for (3) and (5), each requiring a different resumption point (and creating different context changes) at (5) and (7) respectively.<br></p><p>(I&#39;m going to use the terms &quot;standard spilling&quot;, &quot;subfunction spilling&quot;, and &quot;transfer spilling&quot; without defining them.  I&#39;ll come back to this.)<br></p><p>I. Lowerings<br></p><p>Currently, as you say, we do this with a sort of CPS conversion where Inner is split into multiple sub-functions.  The initial function is passed a (necessarily fixed-size, opaque to Outer) buffer; at (3), it saves its context into that buffer and returns a sub-function that Outer will invoke (passing the same buffer) at point (5); at (5), that sub-function restores its context from that buffer; and finally the sub-function returns normally at (7).  This has two advantages: Outer can reason locally about the data flow from (0) to (4) to (8), and Inner can return a null pointer at (3) to indicate that there&#39;s no work to do in (6) and thus save an indirect branch (at the cost of a local conditional branch).  However, if Inner has interesting context to save at (3), that requires extra code to manage that data flow, and the amount of data to save can overflow the buffer and therefore require malloc.  Total branching cost: the original call at (1), the easily-predicted return at (3), the conditional branch at (5), the possible indirect call at (5), and the easily-predicted return at (7).  Total save/restore cost: standard spilling at (1-3) and (5-7), transfer spilling at (3-5), possible malloc.<br></p><p>The simplest alternative proposal is a callback conversion, extracting (4) from Outer as a sub-function which is passed to Inner.  Inner now gets an ordinary stack frame to save its context, so its data flow and control flow are easier for the backend to reason about, and malloc is not required.  However, the data/control flow in Outer is significantly obscured; most importantly, different static points for (5) may need to resume to different instructions at (7) (which the continuation lowering implicitly handles by duplicating the call in (5)), and Outer&#39;s context will be modified at various points from (1-7).  Total branching cost: the original call at (1), the indirect call at (3), the easily-predicted return at (5), the easily-predicted return at (7), the possible switch-out at (7).  Total save/restore cost: subfunction spilling at (1-7), standard spilling at (3-5), only stack allocations.<br></p><p>Note that the call at (5) needs to duplicated for continuation lowering in exactly those cases where we need a switch-out at (7) in callback conversion.<br></p><p>Your observation is that, if Outer needs to perform a nested access with this sequence at (4), a naive callback conversion will have a lot of branches.  Let the outer access be (A), with its steps being (A.0-8), and the inner access be (B), with its steps being (B.0-8), so we have (A.4) := (B.0-8).  If the nesting is simple — i.e. there is no code in B.0 or B.8 — and the initiation sequences are compatible — i.e. you can convince (A.3) to directly make the original call for (B.1) — then it is unnecessary to extract a sub-function for (A.4), and instead (A.1) can just set up the chain of calls.  Total branching cost: the original call at (A.1), the indirect call at (A.3 / B.1), the indirect call at (B.3), the easily-predicted return at (B.5), the easily-predicted return at (B.7 / A.5), the easily-predicted return at (A.7), the possible switch-out at (A.7).  Total save/restore cost: subfunction spilling at (A.1-7), standard spilling at (A.3-5), standard spilling at (B.3-5), only stack allocations.  But it does have some additional set-up overhead, and it expects a lot from the indirect call at (3); in particular, to get this to work well in practice, we really have to change all entrypoints for (1) so that they&#39;re callable in exactly the same way, i.e. taking a context argument, a &quot;next callback&quot; pointer, and an array of extra argument data for the types, indices, whatever.<br></p><p>II. Spilling<br></p><p>&quot;Standard spilling&quot; means ordinary compiler behavior to save values across a call; it includes putting values in callee-save registers.  The compiler has a lot of intelligence about this.<br></p><p>&quot;Subfunction spilling&quot; is like standard spilling except the values must be accessible to a sub-function.  The compiler has some very limited intelligence for this; I&#39;m confident that that intelligence can grow over time, but it&#39;s not much right now.  This precludes using callee-save registers unless, like you suggest, we promise to preserve them when making the callback; and note that &quot;preserve&quot; here really means &quot;expect our caller and our callee to have a private contract about these registers that we shouldn&#39;t disturb&quot; — in particular, our caller might set the register, our callee might expect to see that value *and change it*, and our caller might expect to see that changed value.  This is completely implementable, but it&#39;s not how the backend is really engineered right now.<br></p><p>&quot;Transfer spelling&quot; means saving values across a shift in execution contexts, given only a buffer.  The compiler is not well-engineered for this; we&#39;d probably always be lowering to sub-functions early on, and doing so will block a lot of value optimizations in LLVM.<br></p><p>III. Implementation<br></p><p>I think SIL should clearly work with structured, unified Outer and Inner functions here, freely able to move operations between them without having to worry about what goes where.  That means that we have to do some sort of lowering post-SIL (or at least in some low-level late lowering, rather than in SILGen).  I expect that that alone will greatly improve our current implementation.<br></p><p>In order to do this late lowering, we&#39;ll need some structural restrictions on SIL that should be in line with many of the other restrictions we&#39;re imposing with Semantic SIL.  Given that, I don&#39;t think that it&#39;s particularly harder to extract a continuation vs. extracting an inner sub-function.<br></p><p>IV. Summary<br></p><p>So to sum up:<br></p><p>Our current continuation-style lowering is good when:<br>  - there&#39;s a lot of data flow from 0 to 4 or from 4 to 8,<br>  - there&#39;s complex control flow from 4 to 8, or<br>  - the inner function has no code in 6, which is common for stored/addressed accesses.<br></p><p>A callback-style lowering is good when:<br>  - there&#39;s a lot of data flow from 2 to 6 or<br>  - a zero-allocation implementation is required.<br></p><p>A chained callback-style lowering is good when:<br>  - callback-style lowerings are good and<br>  - simply nested accesses are common enough to pay for the slight additional overhead.<br></p><p>Honestly, I have a hard time seeing the callback trade-offs as being the right ones in general.  Removing the malloc is required for true systems programming, but when that guarantee isn&#39;t needed, I think we can provide a large enough buffer to make allocation basically a non-factor.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Continuation-based versus nested-function-based materializeForSet</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>November  2, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Nov 1, 2016, at 3:32 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 31, 2016, at 12:22 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; We currently abstract over mutable property accesses using what I’ll call a continuation-based model–the materializeForSet accessor is called before an inout access, and returns a continuation callback that must be called when the inout access is completed. I think a nested-function-based model, if designed correctly, has the potential to be more efficient and easier to implement.<br>&gt; <br>&gt; Well, I&#39;m not totally convinced about either of those two points, but it&#39;s definitely something we need to talk about.<br>&gt; <br>&gt; Let me try to break this down.  I think I&#39;m going to repeat you a lot in different words.<br>&gt; <br>&gt; We have a coroutine-esque problem:<br>&gt;  0. Outer is executing.<br>&gt;  1. Outer calls Inner.<br>&gt;  2. Inner executes for a while.<br>&gt;  3. Inner passes control back to Outer without abandoning its execution context.<br>&gt;  4. Outer executes for awhile.<br>&gt;  5. Outer passes control back to Inner, potentially having changed its own execution context.<br>&gt;  6. Inner executes for awhile.<br>&gt;  7. Inner finally abandons its execution context and passes control back to Outer.<br>&gt;  8. Outer is executing.<br>&gt; <br>&gt; Note that there might be multiple static points for (3) and (5), each requiring a different resumption point (and creating different context changes) at (5) and (7) respectively.<br>&gt; <br>&gt; (I&#39;m going to use the terms &quot;standard spilling&quot;, &quot;subfunction spilling&quot;, and &quot;transfer spilling&quot; without defining them.  I&#39;ll come back to this.)<br>&gt; <br>&gt; I. Lowerings<br>&gt; <br>&gt; Currently, as you say, we do this with a sort of CPS conversion where Inner is split into multiple sub-functions.  The initial function is passed a (necessarily fixed-size, opaque to Outer) buffer; at (3), it saves its context into that buffer and returns a sub-function that Outer will invoke (passing the same buffer) at point (5); at (5), that sub-function restores its context from that buffer; and finally the sub-function returns normally at (7).  This has two advantages: Outer can reason locally about the data flow from (0) to (4) to (8), and Inner can return a null pointer at (3) to indicate that there&#39;s no work to do in (6) and thus save an indirect branch (at the cost of a local conditional branch).  However, if Inner has interesting context to save at (3), that requires extra code to manage that data flow, and the amount of data to save can overflow the buffer and therefore require malloc.  Total branching cost: the original call at (1), the easily-predicted return at (3), the conditional branch at (5), the possible indirect call at (5), and the easily-predicted return at (7).  Total save/restore cost: standard spilling at (1-3) and (5-7), transfer spilling at (3-5), possible malloc.<br>&gt; <br>&gt; The simplest alternative proposal is a callback conversion, extracting (4) from Outer as a sub-function which is passed to Inner.  Inner now gets an ordinary stack frame to save its context, so its data flow and control flow are easier for the backend to reason about, and malloc is not required.  However, the data/control flow in Outer is significantly obscured; most importantly, different static points for (5) may need to resume to different instructions at (7) (which the continuation lowering implicitly handles by duplicating the call in (5)), and Outer&#39;s context will be modified at various points from (1-7).  Total branching cost: the original call at (1), the indirect call at (3), the easily-predicted return at (5), the easily-predicted return at (7), the possible switch-out at (7).  Total save/restore cost: subfunction spilling at (1-7), standard spilling at (3-5), only stack allocations.<br>&gt; <br>&gt; Note that the call at (5) needs to duplicated for continuation lowering in exactly those cases where we need a switch-out at (7) in callback conversion.<br>&gt; <br>&gt; Your observation is that, if Outer needs to perform a nested access with this sequence at (4), a naive callback conversion will have a lot of branches.  Let the outer access be (A), with its steps being (A.0-8), and the inner access be (B), with its steps being (B.0-8), so we have (A.4) := (B.0-8).  If the nesting is simple — i.e. there is no code in B.0 or B.8 — and the initiation sequences are compatible — i.e. you can convince (A.3) to directly make the original call for (B.1) — then it is unnecessary to extract a sub-function for (A.4), and instead (A.1) can just set up the chain of calls.  Total branching cost: the original call at (A.1), the indirect call at (A.3 / B.1), the indirect call at (B.3), the easily-predicted return at (B.5), the easily-predicted return at (B.7 / A.5), the easily-predicted return at (A.7), the possible switch-out at (A.7).  Total save/restore cost: subfunction spilling at (A.1-7), standard spilling at (A.3-5), standard spilling at (B.3-5), only stack allocations.  But it does have some additional set-up overhead, and it expects a lot from the indirect call at (3); in particular, to get this to work well in practice, we really have to change all entrypoints for (1) so that they&#39;re callable in exactly the same way, i.e. taking a context argument, a &quot;next callback&quot; pointer, and an array of extra argument data for the types, indices, whatever.<br>&gt; <br>&gt; II. Spilling<br>&gt; <br>&gt; &quot;Standard spilling&quot; means ordinary compiler behavior to save values across a call; it includes putting values in callee-save registers.  The compiler has a lot of intelligence about this.<br>&gt; <br>&gt; &quot;Subfunction spilling&quot; is like standard spilling except the values must be accessible to a sub-function.  The compiler has some very limited intelligence for this; I&#39;m confident that that intelligence can grow over time, but it&#39;s not much right now.  This precludes using callee-save registers unless, like you suggest, we promise to preserve them when making the callback; and note that &quot;preserve&quot; here really means &quot;expect our caller and our callee to have a private contract about these registers that we shouldn&#39;t disturb&quot; — in particular, our caller might set the register, our callee might expect to see that value *and change it*, and our caller might expect to see that changed value.  This is completely implementable, but it&#39;s not how the backend is really engineered right now.<br>&gt; <br>&gt; &quot;Transfer spelling&quot; means saving values across a shift in execution contexts, given only a buffer.  The compiler is not well-engineered for this; we&#39;d probably always be lowering to sub-functions early on, and doing so will block a lot of value optimizations in LLVM.<br>&gt; <br>&gt; III. Implementation<br>&gt; <br>&gt; I think SIL should clearly work with structured, unified Outer and Inner functions here, freely able to move operations between them without having to worry about what goes where.  That means that we have to do some sort of lowering post-SIL (or at least in some low-level late lowering, rather than in SILGen).  I expect that that alone will greatly improve our current implementation.<br>&gt; <br>&gt; In order to do this late lowering, we&#39;ll need some structural restrictions on SIL that should be in line with many of the other restrictions we&#39;re imposing with Semantic SIL.  Given that, I don&#39;t think that it&#39;s particularly harder to extract a continuation vs. extracting an inner sub-function.<br>&gt; <br>&gt; IV. Summary<br>&gt; <br>&gt; So to sum up:<br>&gt; <br>&gt; Our current continuation-style lowering is good when:<br>&gt;  - there&#39;s a lot of data flow from 0 to 4 or from 4 to 8,<br>&gt;  - there&#39;s complex control flow from 4 to 8, or<br>&gt;  - the inner function has no code in 6, which is common for stored/addressed accesses.<br>&gt; <br>&gt; A callback-style lowering is good when:<br>&gt;  - there&#39;s a lot of data flow from 2 to 6 or<br>&gt;  - a zero-allocation implementation is required.<br>&gt; <br>&gt; A chained callback-style lowering is good when:<br>&gt;  - callback-style lowerings are good and<br>&gt;  - simply nested accesses are common enough to pay for the slight additional overhead.<br>&gt; <br>&gt; Honestly, I have a hard time seeing the callback trade-offs as being the right ones in general.  Removing the malloc is required for true systems programming, but when that guarantee isn&#39;t needed, I think we can provide a large enough buffer to make allocation basically a non-factor.<br></p><p>OK, if you&#39;re not convinced that chained callbacks are a win, then it&#39;s kind of a wash. I agree that we&#39;d want to represent the caller and callee as independent coroutines in SIL either way, so the tradeoffs come down to how we lower to readily-available LLVM abstractions. Either implementation approach&#39;s tradeoffs could be mitigated with enough implementation effort: We could avoid mallocing in the continuation-style implementation by manipulating the stack pointer across calls to save space for extra state, and on the other hand, for the callback-style lowering, we could increase the 0-to-4-to-8 bandwidth by saving more registers when switching into the callee&#39;s context. One possibly small advantage I think the callback style still holds is the ability for (3) to be a tail call when the callee has no code in 6 (the stored/addressed case), which saves a test and branch the caller needs to perform if we represent that as a nullable continuation return in the continuation-style model.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
