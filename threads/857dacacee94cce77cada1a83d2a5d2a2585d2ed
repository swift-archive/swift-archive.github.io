<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/706baf09e574d70814e4af2d54a315e0?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Vinicius Vendramini</string> &lt;vinivendra at gmail.com&gt;<p>February 26, 2016 at 01:00:00pm</p></header><div class="content"><p>It seems like having a protocol restricted to instances of ‘AccountAuthorizationController’ (as Brent suggested) would solve your problem, wouldn’t it?<br></p><p>You could just add all method declarations that are supposed to be abstract to that protocol instead, and then make sure your subclasses implement the protocol - which means the compiler forces them to implement the abstract methods.<br></p><p>&gt; Currently I have in a private framework a class named `AccountAuthorizationController` with subclasses like `OAuthAccountAuthorizationController`, `OAuth2AccountAuthorizationController` and `WebFormAccountAuthorizationController` and so on.<br>&gt; <br>&gt; In the root &quot;abstract&quot; class I have methods without implementation where I have to use `fatalError()` to ensure that they will never been called. I cannot prevent the framework user to instantiate the `AccountAuthorizationController`, however.<br>&gt; <br>&gt; Look that this is only one example. I have other cases as well when I&#39;d like to have abstract classes and abstract methods.<br>&gt; <br>&gt; I know that structs and protocols are &quot;elegant, simple and powerful&quot; (as they seem to be all new frameworks and languages that pop up every day on the Internet) and the argumentsin favor of composition rather than inheritance. But I still would like to take advantage of the decades of available knowledge in object orientation in my projects.<br>&gt; <br>&gt; +1 for abstract classes and abstract methods.<br>&gt; <br>&gt; -Van<br>&gt; <br>&gt; On Fri, Feb 26, 2016 at 12:46 PM, Evan Maloney via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt;Well not exactly, if you want the same behaviors in subclasses of UIViewController and UITableViewController :<br>&gt; &gt; &gt;- with protocols + extensions, you write in once and apply it to each of your subclasses<br>&gt; &gt; &gt;- with abstract classes you have to write 2 abstract classes, one for direct UIViewController subclasses, one for UITableViewController subclasses<br>&gt; &gt; <br>&gt; &gt; That&#39;s a problem with class hierarchies in general, not with abstract classes.<br>&gt; &gt; <br>&gt; &gt; You can use the same argument to call for the removal of classes from Swift, which is why I think the fundamental question is, are classes intended to be first-class citizens in Swift?<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/857dd2ed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February 26, 2016 at 04:00:00pm</p></header><div class="content"><p>Thank you. This is a good suggestion, but does not fit the case. The `<br>AccountAuthorizationController` is an &quot;abstract&quot; class but it is not a<br>&quot;dumb&quot; class. It store data, reference to injected class instances and do<br>other important things. If I implement all of this as protocols I have to<br>duplicate code here and there. I know I can use protocol extensions to<br>provide default implementations. Even so, I&#39;ll have duplicate code.<br></p><p>Do not take me wrong, I really like protocols and structs and I understand<br>how to use them, but it seems that many of us believe that the is something<br>wrong with classes and the protocol/struct is the new Holy Grail. I<br>disagree. New possibilites and new way to do things are always welcome,<br>mainly if they are solid and consistent and really solves the<br>problem intended to be solved.<br></p><p>I also understand that the Swift team does not want to introduce any new<br>keywords to the language. To tell the truth I think I need to read again<br>all the information on Swift. I thought the Swift would be one thing, but<br>looks like it will be another. It is likely that the wrong one is me.<br></p><p>Provide ways to create abstract classes and abstract methods is not a<br>&quot;keystroke saver&quot;. It is one of many concepts involved in OOP, IMHO.<br></p><p>-Van<br></p><p><br></p><p>On Fri, Feb 26, 2016 at 3:45 PM, Vinicius Vendramini &lt;vinivendra at gmail.com&gt;<br>wrote:<br></p><p>&gt; It seems like having a protocol restricted to instances of ‘AccountAuthorizationController’<br>&gt; (as Brent suggested) would solve your problem, wouldn’t it?<br>&gt;<br>&gt; You could just add all method declarations that are supposed to be<br>&gt; abstract to that protocol instead, and then make sure your subclasses<br>&gt; implement the protocol - which means the compiler forces them to implement<br>&gt; the abstract methods.<br>&gt;<br>&gt; &gt; Currently I have in a private framework a class named<br>&gt; `AccountAuthorizationController` with subclasses like<br>&gt; `OAuthAccountAuthorizationController`,<br>&gt; `OAuth2AccountAuthorizationController` and<br>&gt; `WebFormAccountAuthorizationController` and so on.<br>&gt; &gt;<br>&gt; &gt; In the root &quot;abstract&quot; class I have methods without implementation where<br>&gt; I have to use `fatalError()` to ensure that they will never been called. I<br>&gt; cannot prevent the framework user to instantiate the<br>&gt; `AccountAuthorizationController`, however.<br>&gt; &gt;<br>&gt; &gt; Look that this is only one example. I have other cases as well when I&#39;d<br>&gt; like to have abstract classes and abstract methods.<br>&gt; &gt;<br>&gt; &gt; I know that structs and protocols are &quot;elegant, simple and powerful&quot; (as<br>&gt; they seem to be all new frameworks and languages that pop up every day on<br>&gt; the Internet) and the argumentsin favor of composition rather than<br>&gt; inheritance. But I still would like to take advantage of the decades of<br>&gt; available knowledge in object orientation in my projects.<br>&gt; &gt;<br>&gt; &gt; +1 for abstract classes and abstract methods.<br>&gt; &gt;<br>&gt; &gt; -Van<br>&gt; &gt;<br>&gt; &gt; On Fri, Feb 26, 2016 at 12:46 PM, Evan Maloney via swift-evolution&lt;<br>&gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org<br>&gt; &lt;swift-evolution at swift.org&gt;)&gt;wrote:<br>&gt; &gt; &gt; &gt;Well not exactly, if you want the same behaviors in subclasses of<br>&gt; UIViewController and UITableViewController :<br>&gt; &gt; &gt; &gt;- with protocols + extensions, you write in once and apply it to each<br>&gt; of your subclasses<br>&gt; &gt; &gt; &gt;- with abstract classes you have to write 2 abstract classes, one for<br>&gt; direct UIViewController subclasses, one for UITableViewController subclasses<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; That&#39;s a problem with class hierarchies in general, not with abstract<br>&gt; classes.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; You can use the same argument to call for the removal of classes from<br>&gt; Swift, which is why I think the fundamental question is, are classes<br>&gt; intended to be first-class citizens in Swift?<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org<br>&gt; &lt;swift-evolution at swift.org&gt;)<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/dd51851c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/706baf09e574d70814e4af2d54a315e0?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Vinicius Vendramini</string> &lt;vinivendra at gmail.com&gt;<p>February 26, 2016 at 04:00:00pm</p></header><div class="content"><p>I see, that seems about right. If we have a bas class that is not dumb, and especially if that base class needs to call abstract methods in its existing methods, I don’t think that solution would be enough.<br></p><p>I would still rather have a solution that extends protocols than one that relies specifically on classes, it seems to me that doing so would make the resulting functionality more generic (for instance, it might be possible to use it with structs as well as classes). However, I’m starting to agree that this is an important language feature indeed, since I can’t think of any better (or even equivalent) way of solving the example you showed.<br></p><p>In any case, I think the current proposal might be a bit too complex. Having to specify which property accessors are abstract (get, set, willSet or didSet), for instance, is going too far IMO. In its current form I do not support it (so -1 for me), but I could get behind the same idea using a simpler design.<br></p><p><br>&gt; On Feb 26, 2016, at 2:20 PM, Vanderlei Martinelli &lt;vmartinelli at alecrim.com&gt; wrote:<br>&gt; <br>&gt; Thank you. This is a good suggestion, but does not fit the case. The `AccountAuthorizationController` is an &quot;abstract&quot; class but it is not a &quot;dumb&quot; class. It store data, reference to injected class instances and do other important things. If I implement all of this as protocols I have to duplicate code here and there. I know I can use protocol extensions to provide default implementations. Even so, I&#39;ll have duplicate code.<br>&gt; <br>&gt; Do not take me wrong, I really like protocols and structs and I understand how to use them, but it seems that many of us believe that the is something wrong with classes and the protocol/struct is the new Holy Grail. I disagree. New possibilites and new way to do things are always welcome, mainly if they are solid and consistent and really solves the problem intended to be solved.<br>&gt; <br>&gt; I also understand that the Swift team does not want to introduce any new keywords to the language. To tell the truth I think I need to read again all the information on Swift. I thought the Swift would be one thing, but looks like it will be another. It is likely that the wrong one is me.<br>&gt; <br>&gt; Provide ways to create abstract classes and abstract methods is not a &quot;keystroke saver&quot;. It is one of many concepts involved in OOP, IMHO.<br>&gt; <br>&gt; -Van<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Fri, Feb 26, 2016 at 3:45 PM, Vinicius Vendramini &lt;vinivendra at gmail.com &lt;mailto:vinivendra at gmail.com&gt;&gt; wrote:<br>&gt; It seems like having a protocol restricted to instances of ‘AccountAuthorizationController’ (as Brent suggested) would solve your problem, wouldn’t it?<br>&gt; <br>&gt; You could just add all method declarations that are supposed to be abstract to that protocol instead, and then make sure your subclasses implement the protocol - which means the compiler forces them to implement the abstract methods.<br>&gt; <br>&gt; &gt; Currently I have in a private framework a class named `AccountAuthorizationController` with subclasses like `OAuthAccountAuthorizationController`, `OAuth2AccountAuthorizationController` and `WebFormAccountAuthorizationController` and so on.<br>&gt; &gt; <br>&gt; &gt; In the root &quot;abstract&quot; class I have methods without implementation where I have to use `fatalError()` to ensure that they will never been called. I cannot prevent the framework user to instantiate the `AccountAuthorizationController`, however.<br>&gt; &gt; <br>&gt; &gt; Look that this is only one example. I have other cases as well when I&#39;d like to have abstract classes and abstract methods.<br>&gt; &gt; <br>&gt; &gt; I know that structs and protocols are &quot;elegant, simple and powerful&quot; (as they seem to be all new frameworks and languages that pop up every day on the Internet) and the argumentsin favor of composition rather than inheritance. But I still would like to take advantage of the decades of available knowledge in object orientation in my projects.<br>&gt; &gt; <br>&gt; &gt; +1 for abstract classes and abstract methods.<br>&gt; &gt; <br>&gt; &gt; -Van<br>&gt; &gt; <br>&gt; &gt; On Fri, Feb 26, 2016 at 12:46 PM, Evan Maloney via swift-evolution&lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;(mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;)&gt;wrote:<br>&gt; &gt; &gt; &gt;Well not exactly, if you want the same behaviors in subclasses of UIViewController and UITableViewController :<br>&gt; &gt; &gt; &gt;- with protocols + extensions, you write in once and apply it to each of your subclasses<br>&gt; &gt; &gt; &gt;- with abstract classes you have to write 2 abstract classes, one for direct UIViewController subclasses, one for UITableViewController subclasses<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; That&#39;s a problem with class hierarchies in general, not with abstract classes.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; You can use the same argument to call for the removal of classes from Swift, which is why I think the fundamental question is, are classes intended to be first-class citizens in Swift?<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;(mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;)<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/10ae8cea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; I would still rather have a solution that extends protocols than one that relies specifically on classes, it seems to me that doing so would make the resulting functionality more generic (for instance, it might be possible to use it with structs as well as classes). However, I’m starting to agree that this is an important language feature indeed, since I can’t think of any better (or even equivalent) way of solving the example you showed.<br></p><p>I&#39;m not sure I understand the desire to make protocols fulfill the role of an abstract class. They&#39;re entirely orthogonal concepts.<br></p><p>Protocols are designed to work just as well with structs, enums or classes. Of those, structs and enums have no concept of an inheritance hierarchy. So, the concept of an abstract class is only relevant in one of the three places where a protocol might be used.<br></p><p>It seems to me it would make sense to limit the &#39;abstract&#39; concept to just classes, and not have the concept leak through to other things where is may not be relevant (i.e. protocols) and where it definitely wouldn&#39;t be relevant (structs and enums).<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>February 29, 2016 at 11:00:00am</p></header><div class="content"><p>You can write class-only protocols in Swift.<br></p><p>~Robert Widmann<br></p><p>2016/02/29 11:27、Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt;&gt; I would still rather have a solution that extends protocols than one that relies specifically on classes, it seems to me that doing so would make the resulting functionality more generic (for instance, it might be possible to use it with structs as well as classes). However, I’m starting to agree that this is an important language feature indeed, since I can’t think of any better (or even equivalent) way of solving the example you showed.<br>&gt; <br>&gt; I&#39;m not sure I understand the desire to make protocols fulfill the role of an abstract class. They&#39;re entirely orthogonal concepts.<br>&gt; <br>&gt; Protocols are designed to work just as well with structs, enums or classes. Of those, structs and enums have no concept of an inheritance hierarchy. So, the concept of an abstract class is only relevant in one of the three places where a protocol might be used.<br>&gt; <br>&gt; It seems to me it would make sense to limit the &#39;abstract&#39; concept to just classes, and not have the concept leak through to other things where is may not be relevant (i.e. protocols) and where it definitely wouldn&#39;t be relevant (structs and enums).<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; You can write class-only protocols in Swift.<br></p><p>I do understand that. I&#39;m just saying that if we&#39;re considering abstract class functionality, it would make sense to host that functionality within classes and not have it housed within protocols which work with non-inheritable types like structs and enums.<br></p><p>The latter would need to needless conceptual leakage.<br></p><p><br>&gt; 2016/02/29 11:27、Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt; <br>&gt;&gt;&gt; I would still rather have a solution that extends protocols than one that relies specifically on classes, it seems to me that doing so would make the resulting functionality more generic (for instance, it might be possible to use it with structs as well as classes). However, I’m starting to agree that this is an important language feature indeed, since I can’t think of any better (or even equivalent) way of solving the example you showed.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure I understand the desire to make protocols fulfill the role of an abstract class. They&#39;re entirely orthogonal concepts.<br>&gt;&gt; <br>&gt;&gt; Protocols are designed to work just as well with structs, enums or classes. Of those, structs and enums have no concept of an inheritance hierarchy. So, the concept of an abstract class is only relevant in one of the three places where a protocol might be used.<br>&gt;&gt; <br>&gt;&gt; It seems to me it would make sense to limit the &#39;abstract&#39; concept to just classes, and not have the concept leak through to other things where is may not be relevant (i.e. protocols) and where it definitely wouldn&#39;t be relevant (structs and enums).<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b9f0c10986385f3c7f50615d6176be3?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Pierre Monod-Broca</string> &lt;pierre at monod-broca.fr&gt;<p>February 29, 2016 at 05:00:00pm</p></header><div class="content"><p>I&#39;m not sure it&#39;s a problem. By the way, protocols can already have &#39;mutating&#39; func, which only apply to structs.<br></p><p><br>&gt; Le 29 févr. 2016 à 17:47, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; You can write class-only protocols in Swift.<br>&gt; <br>&gt; I do understand that. I&#39;m just saying that if we&#39;re considering abstract class functionality, it would make sense to host that functionality within classes and not have it housed within protocols which work with non-inheritable types like structs and enums.<br>&gt; <br>&gt; The latter would need to needless conceptual leakage.<br>&gt; <br>&gt; <br>&gt;&gt; 2016/02/29 11:27、Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I would still rather have a solution that extends protocols than one that relies specifically on classes, it seems to me that doing so would make the resulting functionality more generic (for instance, it might be possible to use it with structs as well as classes). However, I’m starting to agree that this is an important language feature indeed, since I can’t think of any better (or even equivalent) way of solving the example you showed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure I understand the desire to make protocols fulfill the role of an abstract class. They&#39;re entirely orthogonal concepts.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Protocols are designed to work just as well with structs, enums or classes. Of those, structs and enums have no concept of an inheritance hierarchy. So, the concept of an abstract class is only relevant in one of the three places where a protocol might be used.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems to me it would make sense to limit the &#39;abstract&#39; concept to just classes, and not have the concept leak through to other things where is may not be relevant (i.e. protocols) and where it definitely wouldn&#39;t be relevant (structs and enums).<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>February 29, 2016 at 06:00:00pm</p></header><div class="content"><p>Yet mutating methods declared in a protocol can be implemented by classes, and are not reserved to structs.<br></p><p>I think that Evan’s reasoning is the following:<br></p><p>1. Swift has classes, and supports class inheritance. It’s a plain fact.<br>2. The concept of &quot;abstract class&quot; is tied to classes, and only classes, since it requires inheritance in its very definition.<br>3. Hence the concept of &quot;abstract class&quot; belongs to the class realm, and protocols have nothing do to with it.<br></p><p>Gwendal<br></p><p><br>&gt; Le 29 févr. 2016 à 17:55, Pierre Monod-Broca via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I&#39;m not sure it&#39;s a problem. By the way, protocols can already have &#39;mutating&#39; func, which only apply to structs.<br>&gt; <br>&gt; <br>&gt;&gt; Le 29 févr. 2016 à 17:47, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; You can write class-only protocols in Swift.<br>&gt;&gt; <br>&gt;&gt; I do understand that. I&#39;m just saying that if we&#39;re considering abstract class functionality, it would make sense to host that functionality within classes and not have it housed within protocols which work with non-inheritable types like structs and enums.<br>&gt;&gt; <br>&gt;&gt; The latter would need to needless conceptual leakage.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; 2016/02/29 11:27、Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would still rather have a solution that extends protocols than one that relies specifically on classes, it seems to me that doing so would make the resulting functionality more generic (for instance, it might be possible to use it with structs as well as classes). However, I’m starting to agree that this is an important language feature indeed, since I can’t think of any better (or even equivalent) way of solving the example you showed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not sure I understand the desire to make protocols fulfill the role of an abstract class. They&#39;re entirely orthogonal concepts.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Protocols are designed to work just as well with structs, enums or classes. Of those, structs and enums have no concept of an inheritance hierarchy. So, the concept of an abstract class is only relevant in one of the three places where a protocol might be used.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems to me it would make sense to limit the &#39;abstract&#39; concept to just classes, and not have the concept leak through to other things where is may not be relevant (i.e. protocols) and where it definitely wouldn&#39;t be relevant (structs and enums).<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February 29, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 29, 2016, at 12:14 PM, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt; <br>&gt; Yet mutating methods declared in a protocol can be implemented by classes, and are not reserved to structs.<br>&gt; <br>&gt; I think that Evan’s reasoning is the following:<br>&gt; <br>&gt; 1. Swift has classes, and supports class inheritance. It’s a plain fact.<br>&gt; 2. The concept of &quot;abstract class&quot; is tied to classes, and only classes, since it requires inheritance in its very definition.<br>&gt; 3. Hence the concept of &quot;abstract class&quot; belongs to the class realm, and protocols have nothing do to with it.<br></p><p>+1.<br></p><p>Thanks, Gwendal, for presenting my argument more clearly &amp; succinctly than I have. :)<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b9f0c10986385f3c7f50615d6176be3?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Pierre Monod-Broca</string> &lt;pierre at monod-broca.fr&gt;<p>February 29, 2016 at 06:00:00pm</p></header><div class="content"><p>Ok, &#39;mutating&#39; was a bad example.<br></p><p>&gt; Le 29 févr. 2016 à 18:14, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; a écrit :<br>&gt; <br>&gt; Yet mutating methods declared in a protocol can be implemented by classes, and are not reserved to structs.<br>&gt; <br>&gt; I think that Evan’s reasoning is the following:<br>&gt; <br>&gt; 1. Swift has classes, and supports class inheritance. It’s a plain fact.<br>&gt; 2. The concept of &quot;abstract class&quot; is tied to classes, and only classes, since it requires inheritance in its very definition.<br>&gt; 3. Hence the concept of &quot;abstract class&quot; belongs to the class realm, and protocols have nothing do to with it.<br>&gt; <br>&gt; Gwendal<br>&gt; <br>&gt; <br>&gt;&gt; Le 29 févr. 2016 à 17:55, Pierre Monod-Broca via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure it&#39;s a problem. By the way, protocols can already have &#39;mutating&#39; func, which only apply to structs.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 29 févr. 2016 à 17:47, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You can write class-only protocols in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I do understand that. I&#39;m just saying that if we&#39;re considering abstract class functionality, it would make sense to host that functionality within classes and not have it housed within protocols which work with non-inheritable types like structs and enums.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The latter would need to needless conceptual leakage.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/02/29 11:27、Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would still rather have a solution that extends protocols than one that relies specifically on classes, it seems to me that doing so would make the resulting functionality more generic (for instance, it might be possible to use it with structs as well as classes). However, I’m starting to agree that this is an important language feature indeed, since I can’t think of any better (or even equivalent) way of solving the example you showed.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m not sure I understand the desire to make protocols fulfill the role of an abstract class. They&#39;re entirely orthogonal concepts.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Protocols are designed to work just as well with structs, enums or classes. Of those, structs and enums have no concept of an inheritance hierarchy. So, the concept of an abstract class is only relevant in one of the three places where a protocol might be used.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It seems to me it would make sense to limit the &#39;abstract&#39; concept to just classes, and not have the concept leak through to other things where is may not be relevant (i.e. protocols) and where it definitely wouldn&#39;t be relevant (structs and enums).<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>February 29, 2016 at 06:00:00pm</p></header><div class="content"><p>I think that the current approach of wishing protocols could basically do everything might be adding too much responsibility and complexity to the POP pattern, but I think both inheritance and protocol oriented programming should receive equal care at this point. Better access control for properties and methods as well as abstract classes are a way to improve inheritance/OOP that is sorely needed and we should discuss improvements to protocol in their own context... without snide remarks on how improvements there actually negate a feature somewhere else. <br>I think we need to move forward from the OOP vs POP debate, I do think Swift can support and evolve both approaches... <br></p><p>Sent from my iPhone<br></p><p>On 29 Feb 2016, at 16:47, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; You can write class-only protocols in Swift.<br>&gt; <br>&gt; I do understand that. I&#39;m just saying that if we&#39;re considering abstract class functionality, it would make sense to host that functionality within classes and not have it housed within protocols which work with non-inheritable types like structs and enums.<br>&gt; <br>&gt; The latter would need to needless conceptual leakage.<br>&gt; <br>&gt; <br>&gt;&gt; 2016/02/29 11:27、Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I would still rather have a solution that extends protocols than one that relies specifically on classes, it seems to me that doing so would make the resulting functionality more generic (for instance, it might be possible to use it with structs as well as classes). However, I’m starting to agree that this is an important language feature indeed, since I can’t think of any better (or even equivalent) way of solving the example you showed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure I understand the desire to make protocols fulfill the role of an abstract class. They&#39;re entirely orthogonal concepts.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Protocols are designed to work just as well with structs, enums or classes. Of those, structs and enums have no concept of an inheritance hierarchy. So, the concept of an abstract class is only relevant in one of the three places where a protocol might be used.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems to me it would make sense to limit the &#39;abstract&#39; concept to just classes, and not have the concept leak through to other things where is may not be relevant (i.e. protocols) and where it definitely wouldn&#39;t be relevant (structs and enums).<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/706baf09e574d70814e4af2d54a315e0?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Vinicius Vendramini</string> &lt;vinivendra at gmail.com&gt;<p>February 29, 2016 at 01:00:00pm</p></header><div class="content"><p>You do have a point here. For some reason I was thinking that structs also supported inheritance - in which case it made more sense to me to add the feature to protocols, so that structs could use it too.<br></p><p>In that case, I’m sold on implementing this in classes instead of protocols. +1 from me :)<br></p><p>As a side note, being able to constrain protocols to subclasses might be something interesting to pursue later.<br></p><p>&gt; On Feb 29, 2016, at 1:00 PM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think that the current approach of wishing protocols could basically do everything might be adding too much responsibility and complexity to the POP pattern, but I think both inheritance and protocol oriented programming should receive equal care at this point. Better access control for properties and methods as well as abstract classes are a way to improve inheritance/OOP that is sorely needed and we should discuss improvements to protocol in their own context... without snide remarks on how improvements there actually negate a feature somewhere else. <br>&gt; I think we need to move forward from the OOP vs POP debate, I do think Swift can support and evolve both approaches... <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On 29 Feb 2016, at 16:47, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; You can write class-only protocols in Swift.<br>&gt;&gt; <br>&gt;&gt; I do understand that. I&#39;m just saying that if we&#39;re considering abstract class functionality, it would make sense to host that functionality within classes and not have it housed within protocols which work with non-inheritable types like structs and enums.<br>&gt;&gt; <br>&gt;&gt; The latter would need to needless conceptual leakage.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; 2016/02/29 11:27、Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would still rather have a solution that extends protocols than one that relies specifically on classes, it seems to me that doing so would make the resulting functionality more generic (for instance, it might be possible to use it with structs as well as classes). However, I’m starting to agree that this is an important language feature indeed, since I can’t think of any better (or even equivalent) way of solving the example you showed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not sure I understand the desire to make protocols fulfill the role of an abstract class. They&#39;re entirely orthogonal concepts.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Protocols are designed to work just as well with structs, enums or classes. Of those, structs and enums have no concept of an inheritance hierarchy. So, the concept of an abstract class is only relevant in one of the three places where a protocol might be used.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems to me it would make sense to limit the &#39;abstract&#39; concept to just classes, and not have the concept leak through to other things where is may not be relevant (i.e. protocols) and where it definitely wouldn&#39;t be relevant (structs and enums).<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February 29, 2016 at 04:00:00pm</p></header><div class="content"><p>@Goffredo: +1 for all you said. Well said. :-)<br></p><p>-Van<br></p><p>On Mon, Feb 29, 2016 at 3:00 PM, Goffredo Marocchi via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think that the current approach of wishing protocols could basically do<br>&gt; everything might be adding too much responsibility and complexity to the<br>&gt; POP pattern, but I think both inheritance and protocol oriented programming<br>&gt; should receive equal care at this point. Better access control for<br>&gt; properties and methods as well as abstract classes are a way to improve<br>&gt; inheritance/OOP that is sorely needed and we should discuss improvements to<br>&gt; protocol in their own context... without snide remarks on how improvements<br>&gt; there actually negate a feature somewhere else.<br>&gt; I think we need to move forward from the OOP vs POP debate, I do think<br>&gt; Swift can support and evolve both approaches...<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On 29 Feb 2016, at 16:47, Evan Maloney via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; You can write class-only protocols in Swift.<br>&gt; &gt;<br>&gt; &gt; I do understand that. I&#39;m just saying that if we&#39;re considering abstract<br>&gt; class functionality, it would make sense to host that functionality within<br>&gt; classes and not have it housed within protocols which work with<br>&gt; non-inheritable types like structs and enums.<br>&gt; &gt;<br>&gt; &gt; The latter would need to needless conceptual leakage.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; 2016/02/29 11:27、Evan Maloney via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; のメッセージ:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I would still rather have a solution that extends protocols than one<br>&gt; that relies specifically on classes, it seems to me that doing so would<br>&gt; make the resulting functionality more generic (for instance, it might be<br>&gt; possible to use it with structs as well as classes). However, I’m starting<br>&gt; to agree that this is an important language feature indeed, since I can’t<br>&gt; think of any better (or even equivalent) way of solving the example you<br>&gt; showed.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I&#39;m not sure I understand the desire to make protocols fulfill the<br>&gt; role of an abstract class. They&#39;re entirely orthogonal concepts.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Protocols are designed to work just as well with structs, enums or<br>&gt; classes. Of those, structs and enums have no concept of an inheritance<br>&gt; hierarchy. So, the concept of an abstract class is only relevant in one of<br>&gt; the three places where a protocol might be used.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; It seems to me it would make sense to limit the &#39;abstract&#39; concept to<br>&gt; just classes, and not have the concept leak through to other things where<br>&gt; is may not be relevant (i.e. protocols) and where it definitely wouldn&#39;t be<br>&gt; relevant (structs and enums).<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/14166562/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
