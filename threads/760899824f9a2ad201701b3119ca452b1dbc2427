<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e841a2a33b72c728c55ff99200275784?s=50"></div><header><strong>An upcoming proposal for simplifying leak free, safe closures.</strong> from <string>James Froggatt</string> &lt;james.froggatt at me.com&gt;<p>June 26, 2016 at 10:00:00pm</p></header><div class="content"><p>Agreed. Strong capture without an explicit variable binding is unintuitive and generally unsafe. I think it is worth aiming for Swift 3, considering the potential impact.<br></p><p>I have to admit I am quite a heavy user of unowned.<br>If a change somewhere invalidates my assumptions, I&#39;d rather know about it sooner rather the having things silenty fail. However, the weak strong dance really encourages unowned over weak, even when it may not make be entirely safe.<br></p><p>Just to illustrate the gain to be had:<br></p><p>Before:<br></p><p>{<br>    doStuff(with: self) //Oh no! I&#39;ve been silently captured!<br>}<br>{ [unowned self] in<br>    doStuff(with: self) //Probably fine, much more readable.<br>}<br>{ [weak self] in<br>    guard let unwrapped = self else {return}<br>    doStuff(with: unwrapped) //So much boilerplate! The language must be discouraging this.<br>}<br>//unowned seems best<br></p><p>After:<br></p><p>{ [strong self] in<br>    doStuff(with: self) //Strong capture? No thanks!<br>}<br>{ [unowned self] in<br>    doStuff(with: self) //A capture list‽ Look out, you&#39;re doing something unsafe again!<br>}<br>{ guard let unwrapped = self else {return}<br>    doStuff(with: unwrapped) //Oh look, a handy space for a safe unwrap. :)<br>}<br>//weak seems best<br></p><p>------------ Begin Message ------------ <br>Group: gmane.comp.lang.swift.evolution <br>MsgID: &lt;75ADA332-2113-4903-89C3-E1DB1692B7B9 at me.com&gt; <br></p><p>I may be too late for Swift 3, but I am planning to propose changes to the default behavior for closures capturing object references. The introduction of Swift Playgrounds has raised the importance of simplifying the coding of leak-free, crash-free closures. New developers should not have to understand closure memory management to start writing useful and correct code.<br></p><p>The topic of the closure weak/strong dance has been discussed on this list before. This proposal differs from previous proposals in that it will eliminate the dance altogether by default. I am very interested in hearing othersâ opinions as to whether the benefits outweigh the costs of various options.<br></p><p>I have found that Swiftâs capture lists and rules are a bit of a mystery to many experienced developers, even though Swiftâs closure capture rules are very similar to those of Objective-C. Capture lists are probably thought of as opaque incantations by many new Swift developers if they are aware of them at all. Capture lists should, ideally, not be needed for sensible and safe default behavior.<br></p><p>This discussion is iOS / OS X centric and uses terms from those domains, but these issues should be applicable to almost any codebase that uses closures capturing object references.<br></p><p>Capture lists are required by the fact that object references are captured as `strong` by default, often leading to strong reference cycles and memory leaks.<br></p><p>Use of âunownedâ <br>ââââââââ<br>Many examples of using closures capture self as `unowned`. Often, this pattern does not scale well beyond simple examples. iOS and MacOS applications with dynamic UIs, for example, switch between numerous views and view controllers. These objects are dereferenced and reclaimed when they are no longer needed. Closures capturing these objects as `unowned` crash when the references are accessed.<br></p><p>Unfortunately, âunownedâ captures are tempting because they eliminate `guard` and `if let` constructs and avoid littering code with optional unwrapping. They are also slightly more performant, but this difference is probably negligible in most application code.<br></p><p>Capturing escaping object references as `unowned` is only safe when object lifetimes are perfectly understood. In complex systems, it is difficult to predict execution order. Even if object lifetimes are perfectly understood when code is originally written, seemingly innocuous changes to complex systems can negate original assumptions.<br></p><p>For these reasons, I believe that capturing object references as `unowned` should be considered an advanced optimization technique.<br></p><p>I now routinely create closures that capture `self` and other object references as âweakâ even if I think that I feel that `unowned ` would be safe. This may not be the absolutely most performant solution, but it is straightforward and robust.<br></p><p><br>The core proposal:<br>ââââââ<br></p><p>Closures capturing object references should automatically capture all object references as weak.<br></p><p>The closure defined in:<br></p><p>```<br>class ClosureOwner2 {<br>    var aClosure: (() -&gt; Void)?<br>    <br>    func aMethod() {<br>        aClosure = { [weak self] in<br>          self?.someOtherMethod()<br>      }<br>    }<br></p><p>    func someOtherMethod(){}<br>}<br>```<br></p><p>would normally be written as: <br></p><p>```<br>        aClosure = {<br>          self?.someOtherMethod()<br>        }<br>```<br>Closures that can be optimized to safely capture object references as `unowned` can use the current syntax.<br></p><p>Swift 2 closure without explicit capture lists for object references will not compile.<br></p><p>Capturing strong object references can be very useful in certain circumstances and have a straightforward syntax:<br></p><p>```<br>        aClosure = { [strong self] in<br>          self.someOtherMethod()<br>        }<br>```<br></p><p><br>Alternatives / Modifications / Improvements(?):<br>âââââââââââââââââââââ<br></p><p>1) Closures with object references could be simplified further by implicitly including âletâ guards for all object references: <br></p><p>        aClosure = {<br>          // This is included implicitly at the top of the closure:<br>// guard let strongSelf = self else { return }<br></p><p>            /*strongSelf*/ self.someOtherMethod()<br>print( âThis will not appear when self is nil.â )<br></p><p>â¦ other uses of strongSelfâ¦<br></p><p>        }<br></p><p>This would have the effect of making the execution of the closure dependent upon the successful unwrapping of all of its object references. Object references that are not required to unwrap successfully can be captured as `weakâ if desired. <br></p><p><br>2) Some of the magic in #1 could be eliminated by introducing a new capture type:  ârequiredâ to specify âweak guardedâ captures, allowing the example closure to be written:<br></p><p>```<br>        aClosure = { [required self] in<br>          self.someOtherMethod()<br>print( âThis will not appear when self is nil.â )<br>print( âThis is not the default behavior and the reason for this is clearly stated.â ) <br>        }<br>```<br>This reduces the amount of code required, but may increase the cognitive burden over using the current syntax.<br></p><p>`required` is called `guard` in the âSimplified notationâ proposal: https://gist.github.com/emaloney/d34ac9b134ece7c60440 &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440&gt;<br></p><p>This proposal will differ from the âSimplified notationâ proposal in that all object references would be captured as `weak` by default in all closures.<br></p><p>Summary<br>âââââ-<br>Closures with objects references occur frequently in Swift code and the use of closures is probably only going to increase. Current capture list rules are not developer friendly and force developers to deal with subtle asynchronous memory management issues. This increases the cognitive burden particularly for new developers.<br></p><p>Closures should be safe and straightforward by default.<br></p><p>Enhancement #1 without #2 would probably be the easiest option for new developers and result the smallest code size. The question is: is it too âmagicalâ and are the changes in execution behavior going to be significant in practice?<br></p><p>The rules for closure object references with enhancement #1 can be stated succinctly:<br></p><p>By default:<br></p><p>Closures do not affect reference counts of the objects that they reference.<br>All object references used within a closure must unwrap successfully for the closure to execute.<br></p><p>I believe that these are safe, sensible and understandable rules that will eliminate the need for capture lists for many closures. What do you think?<br></p><p><br></p><p><br></p><p>------------- End Message ------------- <br></p><p><br></p><p>From James F<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
