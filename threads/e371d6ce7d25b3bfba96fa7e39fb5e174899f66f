<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 26, 2016 at 04:00:00pm</p></header><div class="content"><p>on Tue Jan 26 2016, Trent Nadeau &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I should clarify. I mean that they&#39;re like types in that they have a<br>&gt; unique scoped name with fields. <br></p><p>struct X {<br>  static var y: Int = 3<br>}<br></p><p>X.y has a unique scoped name.  What&#39;s all this about fields?  I don&#39;t<br>understand that part.<br></p><p>&gt; A union with cases with associated values is a sum types of product<br>&gt; types. Obviously, they can&#39;t be used like &quot;real&quot; types as formal<br>&gt; parameters, etc.<br>&gt;<br>&gt; I don&#39;t see them as values or initializers but very constrained types. For<br>&gt; instance, in C you could have something like:<br>&gt;<br>&gt; struct Foo {<br>&gt;<br>&gt;     int tag;<br>&gt;<br>&gt;     union {<br>&gt;<br>&gt;         struct Bar {<br>&gt;<br>&gt;            int x;<br>&gt;<br>&gt;            int y;<br>&gt;<br>&gt;         } bar;<br>&gt;<br>&gt;         struct Baz {<br>&gt;<br>&gt;           double a;<br>&gt;<br>&gt;           double b;<br>&gt;<br>&gt;         } baz;<br>&gt;<br>&gt;     } data;<br>&gt;<br>&gt; };<br>&gt;<br>&gt; which would be equivalent to Swift&#39;s:<br>&gt;<br>&gt; enum Foo {<br>&gt;     case Bar(x: Int, y: Int)<br>&gt;     case Baz(a: Double, b: Double)<br>&gt; }<br>&gt;<br>&gt; Bar and Baz in the C code above are actual types just unusable outside of<br>&gt; the sum type (tagged union). <br></p><p>The fact that an anonymous union in C hides the types declared within is<br>just a quirk of that language.  You didn&#39;t even need to name Bar and Baz<br>in the `C&#39; code.  The Bar and Baz in your swift code are more similar to<br>bar and baz (lowercase) as they are required in order to access members<br>of the sum.<br></p><p>FWIW, there&#39;s a strong proposal out there (which I support) to give<br>enums optional properties, e.g.<br></p><p>      if let (x,y) = someFoo.Bar { ... }<br>      else if let (a,b) = someFoo.Baz { ... }<br></p><p><br></p><p>&gt; If that&#39;s not similar to Swift, please correct me.<br></p><p>&gt;<br>&gt; On Tue, Jan 26, 2016 at 2:02 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Sun Jan 24 2016, Thorsten Seitz<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; Yes, I think they are a lot like sum (or union) types. In Ceylon enums<br>&gt;&gt; &gt; actually are modeled as union types (there is no specific enum<br>&gt;&gt; &gt; syntax).<br>&gt;&gt;<br>&gt;&gt; Enums in Swift are exactly that; Ceylon chose the name &quot;union;&quot; we chose<br>&gt;&gt; &quot;enum.&quot;  But Trent is saying that enum *cases* are like types.<br>&gt;&gt;<br>&gt;&gt; &gt; -Thorsten<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Am 23.01.2016 um 19:57 schrieb Trent Nadeau via swift-evolution<br>&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; While enum cases may not be types from a compiler perspective, I think<br>&gt;&gt; they are from a user&#39;s level.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Consider:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; enum MyError: ErrorType {<br>&gt;&gt; &gt;&gt;     case FileError(fileName: String)<br>&gt;&gt; &gt;&gt;     case SocketError(ipAddr: String, port: Int16)<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; From a compiler perspective, it&#39;s a tagged union (one type), but for<br>&gt;&gt; &gt;&gt; a user this is a set of disjoint types that happen to share the same<br>&gt;&gt; &gt;&gt; space and have exhaustiveness checking, etc. It&#39;s a much more<br>&gt;&gt; &gt;&gt; efficient and convenient version of multiple structs or tuples.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; On Sat, Jan 23, 2016 at 1:49 PM, Joe Groff<br>&gt;&gt; &gt;&gt; &lt;jgroff at apple.com<br>&gt;&gt; &gt;&gt; &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt; On Jan 23, 2016, at 10:24 AM, Trent Nadeau<br>&gt;&gt; &gt;&gt; &gt; &lt;tanadeau at gmail.com<br>&gt;&gt; &gt;&gt; &gt; &lt;mailto:tanadeau at gmail.com&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; I think it makes sense for enum cases to be UpperCamelCase as they<br>&gt;&gt; &gt;&gt; &gt; can be thought of as scoped types (singleton types in the case of<br>&gt;&gt; &gt;&gt; &gt; cases with no associated types).<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; They aren&#39;t, though. I don&#39;t see much value in setting false<br>&gt;&gt; expectations.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; -Joe<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; Trent Nadeau<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 26, 2016 at 09:00:00pm</p></header><div class="content"><p>I think I understand where you&#39;re coming from now in that you can think of:<br></p><p>enum Foo {<br>    case Bar(x: Int, y: Int)<br>    case Baz(a: Double, b: Double)<br>}<br></p><p>as:<br></p><p>struct Foo {<br>    let Bar: (x: Int, y: Int)<br>    let Baz: (a: Double, b: Double)<br>}<br></p><p>with special handling for storage and pattern matching.<br></p><p>I was thinking of it more in terms of mapping to:<br></p><p>struct Foo {<br>    typealias Bar = (x: Int, y: Int)<br>    typealias Baz = (a: Double, b: Double)<br></p><p>    let storage: MagicStorageOfMaxSize<br>}<br></p><p>with special handling for type use and pattern matching.<br></p><p>The former is probably closer to the implementation and is easier to<br>explain. If that&#39;s the case, I&#39;m +1 on changing the case naming convention.<br>The initial capital letter probably put &quot;type&quot; in my head in the first<br>place along with ways of using enums from other languages like Ceylon:<br></p><p>abstract class Node() of Leaf | Branch {}<br>class Leaf(shared Object element)<br>        extends Node() {}<br>class Branch(shared Node left, shared Node right)<br>        extends Node() {}<br></p><p><br>On Tue, Jan 26, 2016 at 7:49 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Tue Jan 26 2016, Trent Nadeau &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; I should clarify. I mean that they&#39;re like types in that they have a<br>&gt; &gt; unique scoped name with fields.<br>&gt;<br>&gt; struct X {<br>&gt;   static var y: Int = 3<br>&gt; }<br>&gt;<br>&gt; X.y has a unique scoped name.  What&#39;s all this about fields?  I don&#39;t<br>&gt; understand that part.<br>&gt;<br>&gt; &gt; A union with cases with associated values is a sum types of product<br>&gt; &gt; types. Obviously, they can&#39;t be used like &quot;real&quot; types as formal<br>&gt; &gt; parameters, etc.<br>&gt; &gt;<br>&gt; &gt; I don&#39;t see them as values or initializers but very constrained types.<br>&gt; For<br>&gt; &gt; instance, in C you could have something like:<br>&gt; &gt;<br>&gt; &gt; struct Foo {<br>&gt; &gt;<br>&gt; &gt;     int tag;<br>&gt; &gt;<br>&gt; &gt;     union {<br>&gt; &gt;<br>&gt; &gt;         struct Bar {<br>&gt; &gt;<br>&gt; &gt;            int x;<br>&gt; &gt;<br>&gt; &gt;            int y;<br>&gt; &gt;<br>&gt; &gt;         } bar;<br>&gt; &gt;<br>&gt; &gt;         struct Baz {<br>&gt; &gt;<br>&gt; &gt;           double a;<br>&gt; &gt;<br>&gt; &gt;           double b;<br>&gt; &gt;<br>&gt; &gt;         } baz;<br>&gt; &gt;<br>&gt; &gt;     } data;<br>&gt; &gt;<br>&gt; &gt; };<br>&gt; &gt;<br>&gt; &gt; which would be equivalent to Swift&#39;s:<br>&gt; &gt;<br>&gt; &gt; enum Foo {<br>&gt; &gt;     case Bar(x: Int, y: Int)<br>&gt; &gt;     case Baz(a: Double, b: Double)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Bar and Baz in the C code above are actual types just unusable outside of<br>&gt; &gt; the sum type (tagged union).<br>&gt;<br>&gt; The fact that an anonymous union in C hides the types declared within is<br>&gt; just a quirk of that language.  You didn&#39;t even need to name Bar and Baz<br>&gt; in the `C&#39; code.  The Bar and Baz in your swift code are more similar to<br>&gt; bar and baz (lowercase) as they are required in order to access members<br>&gt; of the sum.<br>&gt;<br>&gt; FWIW, there&#39;s a strong proposal out there (which I support) to give<br>&gt; enums optional properties, e.g.<br>&gt;<br>&gt;       if let (x,y) = someFoo.Bar { ... }<br>&gt;       else if let (a,b) = someFoo.Baz { ... }<br>&gt;<br>&gt;<br>&gt;<br>&gt; &gt; If that&#39;s not similar to Swift, please correct me.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; On Tue, Jan 26, 2016 at 2:02 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; &gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Sun Jan 24 2016, Thorsten Seitz<br>&gt; &gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; Yes, I think they are a lot like sum (or union) types. In Ceylon enums<br>&gt; &gt;&gt; &gt; actually are modeled as union types (there is no specific enum<br>&gt; &gt;&gt; &gt; syntax).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Enums in Swift are exactly that; Ceylon chose the name &quot;union;&quot; we chose<br>&gt; &gt;&gt; &quot;enum.&quot;  But Trent is saying that enum *cases* are like types.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; -Thorsten<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt; Am 23.01.2016 um 19:57 schrieb Trent Nadeau via swift-evolution<br>&gt; &gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; While enum cases may not be types from a compiler perspective, I<br>&gt; think<br>&gt; &gt;&gt; they are from a user&#39;s level.<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; Consider:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; enum MyError: ErrorType {<br>&gt; &gt;&gt; &gt;&gt;     case FileError(fileName: String)<br>&gt; &gt;&gt; &gt;&gt;     case SocketError(ipAddr: String, port: Int16)<br>&gt; &gt;&gt; &gt;&gt; }<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; From a compiler perspective, it&#39;s a tagged union (one type), but for<br>&gt; &gt;&gt; &gt;&gt; a user this is a set of disjoint types that happen to share the same<br>&gt; &gt;&gt; &gt;&gt; space and have exhaustiveness checking, etc. It&#39;s a much more<br>&gt; &gt;&gt; &gt;&gt; efficient and convenient version of multiple structs or tuples.<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; On Sat, Jan 23, 2016 at 1:49 PM, Joe Groff<br>&gt; &gt;&gt; &gt;&gt; &lt;jgroff at apple.com<br>&gt; &gt;&gt; &gt;&gt; &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; &gt; On Jan 23, 2016, at 10:24 AM, Trent Nadeau<br>&gt; &gt;&gt; &gt;&gt; &gt; &lt;tanadeau at gmail.com<br>&gt; &gt;&gt; &gt;&gt; &gt; &lt;mailto:tanadeau at gmail.com&gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt; &gt; I think it makes sense for enum cases to be UpperCamelCase as they<br>&gt; &gt;&gt; &gt;&gt; &gt; can be thought of as scoped types (singleton types in the case of<br>&gt; &gt;&gt; &gt;&gt; &gt; cases with no associated types).<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; They aren&#39;t, though. I don&#39;t see much value in setting false<br>&gt; &gt;&gt; expectations.<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; -Joe<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; --<br>&gt; &gt;&gt; &gt;&gt; Trent Nadeau<br>&gt; &gt;&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; _______________________________________________<br>&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt; &gt;&gt; &gt; swift-evolution at swift.org<br>&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; -Dave<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/e44a669b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 27, 2016 at 07:00:00am</p></header><div class="content"><p>That Ceylon example is exactly what I&#39;ve been thinking of, too.<br></p><p>I understand that Swift&#39;s enums work differently, though. But I do like Ceylon&#39;s union types (them being able to represent enums being just a minor part).<br></p><p>-Thorsten <br></p><p>&gt; Am 27.01.2016 um 03:09 schrieb Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I think I understand where you&#39;re coming from now in that you can think of:<br>&gt; <br>&gt; enum Foo {<br>&gt;     case Bar(x: Int, y: Int)<br>&gt;     case Baz(a: Double, b: Double)<br>&gt; }<br>&gt; <br>&gt; as:<br>&gt; <br>&gt; struct Foo {<br>&gt;     let Bar: (x: Int, y: Int)<br>&gt;     let Baz: (a: Double, b: Double)<br>&gt; }<br>&gt; <br>&gt; with special handling for storage and pattern matching.<br>&gt; <br>&gt; I was thinking of it more in terms of mapping to:<br>&gt; <br>&gt; struct Foo {<br>&gt;     typealias Bar = (x: Int, y: Int)<br>&gt;     typealias Baz = (a: Double, b: Double)<br>&gt; <br>&gt;     let storage: MagicStorageOfMaxSize<br>&gt; }<br>&gt; <br>&gt; with special handling for type use and pattern matching.<br>&gt; <br>&gt; The former is probably closer to the implementation and is easier to explain. If that&#39;s the case, I&#39;m +1 on changing the case naming convention. The initial capital letter probably put &quot;type&quot; in my head in the first place along with ways of using enums from other languages like Ceylon:<br>&gt; <br>&gt; abstract class Node() of Leaf | Branch {}<br>&gt; <br>&gt; class Leaf(shared Object element) <br>&gt;         extends Node() {}<br>&gt; <br>&gt; class Branch(shared Node left, shared Node right) <br>&gt;         extends Node() {}<br>&gt; <br>&gt;&gt; On Tue, Jan 26, 2016 at 7:49 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; on Tue Jan 26 2016, Trent Nadeau &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; I should clarify. I mean that they&#39;re like types in that they have a<br>&gt;&gt; &gt; unique scoped name with fields.<br>&gt;&gt; <br>&gt;&gt; struct X {<br>&gt;&gt;   static var y: Int = 3<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; X.y has a unique scoped name.  What&#39;s all this about fields?  I don&#39;t<br>&gt;&gt; understand that part.<br>&gt;&gt; <br>&gt;&gt; &gt; A union with cases with associated values is a sum types of product<br>&gt;&gt; &gt; types. Obviously, they can&#39;t be used like &quot;real&quot; types as formal<br>&gt;&gt; &gt; parameters, etc.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I don&#39;t see them as values or initializers but very constrained types. For<br>&gt;&gt; &gt; instance, in C you could have something like:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; struct Foo {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     int tag;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     union {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;         struct Bar {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;            int x;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;            int y;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;         } bar;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;         struct Baz {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;           double a;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;           double b;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;         } baz;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     } data;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; };<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; which would be equivalent to Swift&#39;s:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; enum Foo {<br>&gt;&gt; &gt;     case Bar(x: Int, y: Int)<br>&gt;&gt; &gt;     case Baz(a: Double, b: Double)<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Bar and Baz in the C code above are actual types just unusable outside of<br>&gt;&gt; &gt; the sum type (tagged union).<br>&gt;&gt; <br>&gt;&gt; The fact that an anonymous union in C hides the types declared within is<br>&gt;&gt; just a quirk of that language.  You didn&#39;t even need to name Bar and Baz<br>&gt;&gt; in the `C&#39; code.  The Bar and Baz in your swift code are more similar to<br>&gt;&gt; bar and baz (lowercase) as they are required in order to access members<br>&gt;&gt; of the sum.<br>&gt;&gt; <br>&gt;&gt; FWIW, there&#39;s a strong proposal out there (which I support) to give<br>&gt;&gt; enums optional properties, e.g.<br>&gt;&gt; <br>&gt;&gt;       if let (x,y) = someFoo.Bar { ... }<br>&gt;&gt;       else if let (a,b) = someFoo.Baz { ... }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; If that&#39;s not similar to Swift, please correct me.<br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Tue, Jan 26, 2016 at 2:02 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; &gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; on Sun Jan 24 2016, Thorsten Seitz<br>&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt; Yes, I think they are a lot like sum (or union) types. In Ceylon enums<br>&gt;&gt; &gt;&gt; &gt; actually are modeled as union types (there is no specific enum<br>&gt;&gt; &gt;&gt; &gt; syntax).<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Enums in Swift are exactly that; Ceylon chose the name &quot;union;&quot; we chose<br>&gt;&gt; &gt;&gt; &quot;enum.&quot;  But Trent is saying that enum *cases* are like types.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt; -Thorsten<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Am 23.01.2016 um 19:57 schrieb Trent Nadeau via swift-evolution<br>&gt;&gt; &gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; While enum cases may not be types from a compiler perspective, I think<br>&gt;&gt; &gt;&gt; they are from a user&#39;s level.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Consider:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; enum MyError: ErrorType {<br>&gt;&gt; &gt;&gt; &gt;&gt;     case FileError(fileName: String)<br>&gt;&gt; &gt;&gt; &gt;&gt;     case SocketError(ipAddr: String, port: Int16)<br>&gt;&gt; &gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; From a compiler perspective, it&#39;s a tagged union (one type), but for<br>&gt;&gt; &gt;&gt; &gt;&gt; a user this is a set of disjoint types that happen to share the same<br>&gt;&gt; &gt;&gt; &gt;&gt; space and have exhaustiveness checking, etc. It&#39;s a much more<br>&gt;&gt; &gt;&gt; &gt;&gt; efficient and convenient version of multiple structs or tuples.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; On Sat, Jan 23, 2016 at 1:49 PM, Joe Groff<br>&gt;&gt; &gt;&gt; &gt;&gt; &lt;jgroff at apple.com<br>&gt;&gt; &gt;&gt; &gt;&gt; &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; &gt; On Jan 23, 2016, at 10:24 AM, Trent Nadeau<br>&gt;&gt; &gt;&gt; &gt;&gt; &gt; &lt;tanadeau at gmail.com<br>&gt;&gt; &gt;&gt; &gt;&gt; &gt; &lt;mailto:tanadeau at gmail.com&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; &gt; I think it makes sense for enum cases to be UpperCamelCase as they<br>&gt;&gt; &gt;&gt; &gt;&gt; &gt; can be thought of as scoped types (singleton types in the case of<br>&gt;&gt; &gt;&gt; &gt;&gt; &gt; cases with no associated types).<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; They aren&#39;t, though. I don&#39;t see much value in setting false<br>&gt;&gt; &gt;&gt; expectations.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; -Joe<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; &gt;&gt; Trent Nadeau<br>&gt;&gt; &gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; -Dave<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/3724798b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
