<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/04a3fc14ec0008acf8d406c93e23c3ae?s=50"></div><header><strong>Warning when &quot;overriding&quot; an extension method that&#39;s not in the protocol</strong> from <string>Jesse Rusak</string> &lt;me at jesserusak.com&gt;<p>December 31, 2015 at 06:00:00pm</p></header><div class="content"><p>Hi Doug,<br></p><p>I’ve been playing around with an implementation of the warning you referenced here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001584.html<br></p><p>Would it be helpful for me to take this on? If so, is there any detail in the radar assigned to you about what exactly should trigger such a warning? For example, I have it currently triggering whenever there’s a method with a matching name, ignoring parameter/return types; it’s not obvious to me how closely they should have to match, if at all, to trigger the warning.<br></p><p>Thanks!<br>Jesse<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Warning when &quot;overriding&quot; an extension method that&#39;s not in the protocol</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January  2, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 3:15 PM, Jesse Rusak &lt;me at jesserusak.com&gt; wrote:<br>&gt; <br>&gt; Hi Doug,<br>&gt; <br>&gt; I’ve been playing around with an implementation of the warning you referenced here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001584.html<br>&gt; <br>&gt; Would it be helpful for me to take this on?<br></p><p>Yes, absolutely!<br></p><p>&gt; If so, is there any detail in the radar assigned to you about what exactly should trigger such a warning?<br>&gt; For example, I have it currently triggering whenever there’s a method with a matching name, ignoring parameter/return types; it’s not obvious to me how closely they should have to match, if at all, to trigger the warning.<br></p><p>I just realized that I wrote up a big discussion of a related-but-not-identical warning. In either case, there is some kind of radar, and neither gives a lot of detail. <br></p><p>In general: just matching on name alone feels like it might produce too many false positives, but exactly matching parameter/return types feels like it might miss cases where this warning would be important, so… I think it’s going to come down to coming up with cases where you do/don’t want to see the warning and tuning the warning to do the right thing. It might be that you want to do some simplistic matching (perhaps akin to what lib/Sema/TypeCheckProtocol.cpp does when inferring type witnesses) that ignores uses of associated types that might have been deduced differently from what the user expected.<br></p><p>That leads to my #1 example I’d love to get a warning for, which is when you intended to provide something to satisfy a protocol requirement, but you ended up getting a default implementation:<br></p><p>struct MyGenerator {<br>  mutating func next() -&gt; Int? { return nil }<br>}<br></p><p>struct MyCollection : CollectionType {<br>  typealias Index = Int<br></p><p>  var startIndex: Int { return 0 }<br>  var endIndex: Int { return 10 }<br></p><p>  subscript (index: Int) -&gt; Int {<br>    return index<br>  }<br></p><p>  func generate() -&gt; MyGenerator {<br>    print(&quot;using MyGenerator&quot;)<br>    return MyGenerator()<br>  }<br>}<br></p><p>func foo&lt;C: CollectionType&gt;(c: C) {<br>  c.generate()<br>}<br></p><p>foo(MyCollection())<br></p><p>Note that there is no output from this program, although one would expect to see “using MyGenerator”.<br></p><p>The root of the problem is annoying simple (I “forgot” to state that MyGenerator conforms to GeneratorType). The result is that the implied SequenceType conformance gets a default implementation of “generate” from a protocol extension in the standard library (that produces default generator for any SequenceType that is also a CollectionType). Our place to warn about this is at the point where we decide to use a “generate” from a protocol extension rather than the “generate” in the same “struct” that declares conformance to CollectionType. Obviously, lots of bonus points if we could say why the generate() in the struct wasn’t picked :)<br></p><p>That brings up another point about warnings: it’s useful to have a way to suppress them. Let’s say we got a warning for my example above (huzzah!) but I wanted to silence it. A fairly natural way to do so would be to move the “generate” function I defined into a separate extension, so it’s away from where we state conformance to CollectionType:<br></p><p><br>struct MyGenerator {<br>  mutating func next() -&gt; Int? { return nil }<br>}<br></p><p>struct MyCollection : CollectionType {<br>  typealias Index = Int<br></p><p>  var startIndex: Int { return 0 }<br>  var endIndex: Int { return 10 }<br></p><p>  subscript (index: Int) -&gt; Int {<br>    return index<br>  }<br>}<br></p><p>extension MyCollection {<br>  func generate() -&gt; MyGenerator { // no warning<br>    print(&quot;using MyGenerator&quot;)<br>    return MyGenerator()<br>  }<br>}<br></p><p>Effectively, we’re using the declaration of conformance to a protocol as indicating user intent that the contents of this particular definition/extension involve that conformance.<br></p><p>The actual warning you are talking about is very, very similar, and would likely use most of the same logic. The part that differs is the trigger: whenever one declares something within a type, perform a lookup in that type to determine whether there are any similar members of extensions of one of the protocols that type conforms to. You&#39;ll want to think about how to suppress the warning when the user wants to. <br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160102/527fa224/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Warning when &quot;overriding&quot; an extension method that&#39;s not in the protocol</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  2, 2016 at 06:00:00pm</p></header><div class="content"><p>On Sat, Jan 2, 2016, at 11:39 AM, Douglas Gregor via swift-dev wrote:<br>&gt;<br>&gt;<br>&gt;&gt; On Dec 31, 2015, at 3:15 PM, Jesse Rusak &lt;me at jesserusak.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi Doug,<br>&gt;&gt;<br>&gt;&gt; I’ve been playing around with an implementation of the warning you<br>&gt;&gt; referenced here:<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001584.html<br>&gt;&gt;<br>&gt;&gt; Would it be helpful for me to take this on?<br>&gt;<br>&gt; Yes, absolutely!<br>&gt;<br>&gt;&gt; If so, is there any detail in the radar assigned to you about what<br>&gt;&gt; exactly should trigger such a warning? For example, I have it<br>&gt;&gt; currently triggering whenever there’s a method with a matching name,<br>&gt;&gt; ignoring parameter/return types; it’s not obvious to me how closely<br>&gt;&gt; they should have to match, if at all, to trigger the warning.<br>&gt; I just realized that I wrote up a big discussion of a related-but-not-<br>&gt; identical warning. In either case, there is some kind of radar, and<br>&gt; neither gives a lot of detail.<br>&gt;<br>&gt; In general: just matching on name alone feels like it might produce<br>&gt; too many false positives, but exactly matching parameter/return types<br>&gt; feels like it might miss cases where this warning would be important,<br>&gt; so… I think it’s going to come down to coming up with cases where you<br>&gt; do/don’t want to see the warning and tuning the warning to do the<br>&gt; right thing. It might be that you want to do some simplistic matching<br>&gt; (perhaps akin to what lib/Sema/TypeCheckProtocol.cpp does when<br>&gt; inferring type witnesses) that ignores uses of associated types that<br>&gt; might have been deduced differently from what the user expected.<br>&gt;<br>&gt; That leads to my #1 example I’d love to get a warning for, which is<br>&gt; when you intended to provide something to satisfy a protocol<br>&gt; requirement, but you ended up getting a default implementation:<br>&gt;<br>&gt;&gt; struct MyGenerator {  mutating func next() -&gt; Int? { return nil } }<br>&gt;&gt;<br>&gt;&gt; struct MyCollection : CollectionType {  typealias Index = Int<br>&gt;&gt;<br>&gt;&gt; var startIndex: Int { return 0 }  var endIndex: Int { return 10 }<br>&gt;&gt;<br>&gt;&gt; subscript (index: Int) -&gt; Int {    return index  }<br>&gt;&gt;<br>&gt;&gt; func generate() -&gt; MyGenerator {    print(&quot;using MyGenerator&quot;)<br>&gt;&gt; return MyGenerator()  } }<br>&gt;&gt;<br>&gt;&gt; func foo&lt;C: CollectionType&gt;(c: C) {  c.generate() }<br>&gt;&gt;<br>&gt;&gt; foo(MyCollection())<br>&gt;<br>&gt; Note that there is no output from this program, although one would<br>&gt; expect to see “using MyGenerator”.<br>&gt;<br>&gt; The root of the problem is annoying simple (I “forgot” to state that<br>&gt; MyGenerator conforms to GeneratorType). The result is that the implied<br>&gt; SequenceType conformance gets a default implementation of “generate”<br>&gt; from a protocol extension in the standard library (that produces<br>&gt; default generator for any SequenceType that is also a CollectionType).<br>&gt; Our place to warn about this is at the point where we decide to use a<br>&gt; “generate” from a protocol extension rather than the “generate” in the<br>&gt; same “struct” that declares conformance to CollectionType. Obviously,<br>&gt; lots of bonus points if we could say why the generate() in the struct<br>&gt; wasn’t picked :)<br>&gt;<br>&gt; That brings up another point about warnings: it’s useful to have a way<br>&gt; to suppress them. Let’s say we got a warning for my example above<br>&gt; (huzzah!) but I wanted to silence it. A fairly natural way to do so<br>&gt; would be to move the “generate” function I defined into a separate<br>&gt; extension, so it’s away from where we state conformance to<br>&gt; CollectionType:<br>&gt;<br>&gt;<br>&gt;&gt; struct MyGenerator {  mutating func next() -&gt; Int? { return nil } }<br>&gt;&gt;<br>&gt;&gt; struct MyCollection : CollectionType {  typealias Index = Int<br>&gt;&gt;<br>&gt;&gt; var startIndex: Int { return 0 }  var endIndex: Int { return 10 }<br>&gt;&gt;<br>&gt;&gt; subscript (index: Int) -&gt; Int {    return index  } }<br>&gt;&gt;<br>&gt;&gt; extension MyCollection {  func generate() -&gt; MyGenerator { // no<br>&gt;&gt; warning    print(&quot;using MyGenerator&quot;)    return MyGenerator()  } }<br>&gt;&gt;<br>&gt; Effectively, we’re using the declaration of conformance to a protocol<br>&gt; as indicating user intent that the contents of this particular<br>&gt; definition/extension involve that conformance.<br></p><p>This isn&#39;t going to work well for cases where the protocol declares a<br>property (with a default computed property impl) and a conforming type<br>attempts to use a stored property. Stored properties must be declared in<br>the initial type declaration, not in extensions. The only way to<br>suppress it then would be to suppress the warning in general for members<br>provided in the initial type declaration when the protocol conformance<br>is part of an extension (sort of the opposite of the suggested way of<br>suppressing warnings), and maybe that&#39;s fine, but it does mean that<br>there&#39;s no way to suppress the warning for a single stored property<br>without suppressing it for all stored properties.<br></p><p>&gt; The actual warning you are talking about is very, very similar, and<br>&gt; would likely use most of the same logic. The part that differs is the<br>&gt; trigger: whenever one declares something within a type, perform a<br>&gt; lookup in that type to determine whether there are any similar<br>&gt; members of extensions of one of the protocols that type conforms to.<br>&gt; You&#39;ll want to think about how to suppress the warning when the user<br>&gt; wants to.<br></p><p>The warning you documented in most of this email seems perfectly<br>reasonable; if I declare a function that looks like it&#39;s meant to<br>match a protocol method, there&#39;s a good chance I expected it to<br>actually do so (and, as you suggested, there&#39;s a reasonable way to<br>suppress it for methods).<br></p><p>But the warning that Jesse was talking about, the one that was discussed<br>in the older threads, I think is completely different. If I declare a<br>method on my type that matches a protocol extension method, it is *not*<br>safe to assume I was trying to override the (non-overridable) method.<br>It&#39;s very likely that I&#39;m simply providing a specialization of the<br>method that will be called by anyone who&#39;s working with my type directly<br>(with the acknowledgement that working with the type generically won&#39;t<br>call my type&#39;s version). Not only that, but it&#39;s not even possible by<br>looking at the definition of the protocol to determine if any given<br>method I add to my type will even trigger a warning! The warning will be<br>triggered by the existence of any visible extension to the protocol,<br>even one the programmer isn&#39;t aware of.<br></p><p>I think a much better approach to handling this is simply to update the<br>documentation to make it much more obvious which methods/properties are<br>&quot;part of&quot; the protocol and which are extensions. The current stdlib docs<br>(in the iOS Developer Library) adds the text &quot;Default implementation&quot;<br>next to any default method, but it doesn&#39;t actually separate out the<br>default implementations from the required ones. This also means that<br>when Xcode shows the method list in the documentation viewer there&#39;s no<br>indication as to which ones are default and which are not.<br>http://swiftdoc.org provides a *much* better display where &quot;Instance<br>methods&quot; are in a separate section from &quot;Default Implementations&quot; (see<br>http://swiftdoc.org/v2.1/protocol/SequenceType/ for an example).<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160102/b06828cc/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
