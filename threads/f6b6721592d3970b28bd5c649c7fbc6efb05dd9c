<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>The Legend of the Toll-Free Swift -&gt; ObjC Collection Bridge</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>October  7, 2016 at 03:00:00pm</p></header><div class="content"><p>on Fri Oct 07 2016, Alexis &lt;swift-dev-AT-swift.org&gt; wrote:<br></p><p>&gt; I’ve been looking a lot into how Swift and Objective C collections<br>&gt; inter-convert because a bunch of necessary cleanup for ABI stability<br>&gt; interacts with it. Unfortunately I’ve run into some conflicting<br>&gt; information with respect to how stuff should work, and how it seems to<br>&gt; actually work. Hoping y&#39;all could help me clear this up.<br>&gt;<br>&gt; Here’s the literal state of the Swift codebase, as I currently understand it:<br>&gt;<br>&gt; * String, Array, Dictionary, and Set are all effectively tagged unions of &quot;Native || Objc”. <br>&gt; * The ObjC case is the result of lazy bridging, and is basically just storing an NSWhatever pointer.<br>&gt; * If any of these collections are in the ObjC state, then bridging to ObjC is obvious and<br>&gt; trivial. (yay!)<br>&gt; * If any of these collections are in the Native state:<br>&gt;<br>&gt; Array: If the storage is verbatim bridgeable to ObjC (~it’s a class or<br>&gt; objc existential), just return the buffer (toll free). Otherwise, wrap<br>&gt; the storage in a _SwiftDeferredNSArray (not toll free). The first time<br>&gt; someone tries to access the contents of the _SwiftDeferredNSArray, a<br>&gt; CAS-loop race occurs to create a new buffer containing all the bridged<br>&gt; values. <br></p><p>Correct, except to be clear it&#39;s not a data race because of the atomics.<br></p><p>&gt; The only alternative to this would be bridging each element as<br>&gt; it’s requested, but that’s ultimately just a trade-off (and has issues<br>&gt; if people are relying on pointer equality). There has to be some toll<br>&gt; here.<br>&gt;<br>&gt; However the construction of the _SwiftDeferredNSArray is<br>&gt; hypothetically unnecessary, as alluded to in the comments on<br>&gt; _SDNSArray. The class and its CAS pointer could be embedded in the<br>&gt; native array buffer. <br></p><p>That doesn&#39;t make creating it unneccessary; it only makes the separate<br>allocation unnecessary.  Whether or not it&#39;s actually needed is a<br>separate question.  When we first tested Swift without it there were<br>some bugs reported due to object identity of things bridged from value<br>types not being preserved.  We could try again to discover who&#39;s relying<br>on it and see whether we&#39;ve reached the point where that code can be<br>changed not to rely on it.<br></p><p>&gt; This would presumably incur some bloat on all native Arrays, but it<br>&gt; might not be too bad (and platforms which don’t support _runtime(ObjC)<br>&gt; presumably can omit it)? That said, I’m not 100% clear if we have the<br>&gt; machinery to accomplish this yet or not. If anyone knows this, it<br>&gt; would help a lot!<br></p><p>We do.<br></p><p>&gt; (there’s also some special case singleton for empty arrays, that all seems fine)<br>&gt;<br>&gt; See: <br>&gt; 	ContiguousArrayBuffer.swift: _asCocoaArray<br>&gt; 	ContiguousArrayBuffer.swift: _getNonVerbatimBridgedHeapBuffer<br>&gt; 	SwiftNativeNSArray: _SwiftDeferredNSArray (the class that wraps the storage)<br>&gt;<br>&gt; Dictionary/Set: Looks to be pretty much the same thing as Array,<br>&gt; except that the old indexing model led to a double-indirection being<br>&gt; baked into the design, so a wrapper class doesn’t need to be<br>&gt; constructed in the non-verbatim case.<br>&gt; (_NativeDictionaryStorageOwner contains the CAS-pointer). (toll free<br>&gt; as can be!)<br></p><p>I didn&#39;t know that, but it sounds plausible.<br></p><p>&gt; But this means that cleaning up all the gunk from the old indexing<br>&gt; model and removing this indirection will lead to a regression in<br>&gt; bridging performance *unless* Dictionary/Set gets the kind of<br>&gt; optimizations discussed for Array. <br></p><p>I wouldn&#39;t worry about this particular cost.  Bridging values into<br>Objective-C is already very expensive unless none of the values are<br>actually used, which is rare to say the least.<br></p><p>&gt; The class inlining optimization also seem more acceptable for<br>&gt; Dictionary, since it’s necessarily a more bloated allocation than<br>&gt; Array (less overhead by %).<br></p><p>Yes.  And given the scale of expense occurred the first time an element<br>is requested from ObjC, it probably doesn&#39;t make sense for Dictionary<br>either.  Embedding the NS class in the Swift data structure&#39;s buffer<br>can also keep some memory alive longer than necessary.  I don&#39;t think we<br>should do this optimization.<br></p><p>&gt;<br>&gt;<br>&gt; See: <br>&gt; 	HashedCollections.swift.gyb: _bridgeToObjectiveCImpl<br>&gt; 	HashedCollections.swift.gyb: _Native${Self}StorageOwner (the “outer” class)<br>&gt;<br>&gt; String: Unconditionally construct a class that wraps the String’s storage. (not toll free)<br>&gt;<br>&gt; This just seems bad, and as far as I can tell isn’t expected. <br></p><p>As I told you, it isn&#39;t.<br></p><p>&gt; It seems to be the result of _StringBuffer (the lowest-level type in<br>&gt; the String abstraction stack that still actually knows it’s a string)<br>&gt; being a struct, and not a class that inherits from _HeapBuffer <br></p><p>? _HeapBuffer is a struct; you can&#39;t inherit from it.  You must mean<br>_HeapBufferStorage.  But there&#39;s an underlying _HeapBufferStorage in<br>_StringBuffer, and this class can be made a subclass of NSString.<br></p><p>&gt; due to some problems with deriving from generic classes. I’m not 100%<br>&gt; sure what the “fix” for this is supposed to be.<br>&gt;<br>&gt; I think any fix will necessarily lead to String becoming<br>&gt; pointer-sized, which appears to be a desirable ABI feature anyway.<br></p><p>No, you don&#39;t have to do that, but yes, we do want that feature.  <br></p><p>The only Strings that can bridge “toll-free” are the ones currently<br>backed by NSString and the ones that occupy *all* of their backing<br>native buffer (rather than being sliced from that buffer).<br></p><p>&gt; However this has tricky consequences for Strings which are actually<br>&gt; sub-slices of other Strings. At the limit, this will definitely<br>&gt; require some slices which don’t allocate (because they just create a<br>&gt; new String pointing at the old buffer with different start/length<br>&gt; values) to start requiring an allocation (because those fields will be<br>&gt; in a class, and not a struct). <br></p><p>Yes, that&#39;s expected.<br></p><p>&gt; Maybe stack promotion and careful pointer-tagging can eliminate most<br>&gt; allocations in practice.<br>&gt;<br>&gt; See: <br>&gt; 	StringBridge.swift: _stdlib_binary_bridgeToObjectiveCImpl<br>&gt; 	StringBridge.swift: _NSContiguousString (the class that wraps the storage)<br>&gt; 	StringBuffer.swift: _StringBuffer (the type that wants to subclass _HeapBuffer)<br>&gt;<br>&gt; So that’s the situation as I understand it. Did I get anything wrong? Are there any details I’m<br>&gt; missing?<br></p><p>You can give me a call to discuss details if you like :-)<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
