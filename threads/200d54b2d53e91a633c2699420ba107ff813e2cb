<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Draft] Obejctive-C Keypaths</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March  4, 2016 at 06:00:00pm</p></header><div class="content"><p>Hello Swift-friends,<br></p><p>After more thinking, here is a new proposal, based on my original proposal for #selector for properties but better targeted at the intended use: referencing key-paths. Please let me know what you think:<br></p><p>Referencing Objective-C key-paths<br></p><p>Proposal: SE-XXXX &lt;https://github.com/apple/swift-evolution/blob/master/proposals/XXXX-objc-keypaths.md&gt;<br>Author(s): David Hart &lt;https://github.com/hartbit&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://github.com/hartbit/swift-evolution/tree/objc-keypaths#introduction&gt;Introduction<br></p><p>In Objective-C and Swift, key-paths used by KVC and KVO are represented as string literals (e.g., &quot;friend.address.streetName&quot;). This proposal seeks to improve the safety and resilience to modification of code using key-paths by introducing a compiler-checked expression.<br></p><p> &lt;https://github.com/hartbit/swift-evolution/tree/objc-keypaths#motivation&gt;Motivation<br></p><p>The use of string literals for key paths is extremely error-prone: there is no checking that the string corresponds to a valid key-path. In a similar manner to the proposal for the Objective-C selector expression SE-0022 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0022-objc-selectors.md&gt;, this proposal introduces a syntax for referencing compiler-checked key-paths. When the referenced properties and methods are renamed or deleted, the programmer will be notified by a compiler error.<br></p><p> &lt;https://github.com/hartbit/swift-evolution/tree/objc-keypaths#proposed-solution&gt;Proposed solution<br></p><p>Introduce a new expression #keypath that allows one to build a String from a key-path:<br></p><p>class Person: NSObject {<br>    dynamic var firstName: String = &quot;&quot;<br>    dynamic var lastName: String = &quot;&quot;<br>    dynamic var friends: [Person] = []<br>    dynamic var bestFriend: Person?<br></p><p>    init(firstName: String, lastName: String) {<br>        self.firstName = firstName<br>        self.lastName = lastName<br>    }<br>}<br></p><p>let chris = Person(firstName: &quot;Chris&quot;, lastName: &quot;Lattner&quot;)<br>let joe = Person(firstName: &quot;Joe&quot;, lastName: &quot;Groff&quot;)<br>let douglas = Person(firstName: &quot;Douglas&quot;, lastName: &quot;Gregor&quot;)<br>chris.friends = [joe, douglas]<br>chris.bestFriend = joe<br></p><p><br>#keypath(Person.firstName) // =&gt; &quot;firstName&quot;<br>chris.valueForKey(#keypath(Person.firstName)) // =&gt; Chris<br>#keypath(Person.bestFriend.lastName) // =&gt; &quot;bestFriend.lastName&quot;<br>chris.valueForKeyPath(#keypath(Person.bestFriend.lastName)) // =&gt; Groff<br>#keypath(Person.friends.firstName) // =&gt; &quot;friends.firstName&quot;<br>chris.valueForKeyPath(#keypath(Person.friends.firstName)) // =&gt; [&quot;Joe&quot;, &quot;Douglas&quot;]<br>By having the #keypath expression do the work to form the Objective-C key-path string, we free the developer from having to do the manual typing and get static checking that the key-path exists and is exposed to Objective-C.<br></p><p> &lt;https://github.com/hartbit/swift-evolution/tree/objc-keypaths#impact-on-existing-code&gt;Impact on existing code<br></p><p>The introduction of the #keypath expression has no impact on existing code as it returns a String. It is simply a modification-safe alternative to using literal strings for referencing key-paths.<br></p><p> &lt;https://github.com/hartbit/swift-evolution/tree/objc-keypaths#alternatives-considered&gt;Alternatives considered<br></p><p>One aspect of the design which seems potentially complicated is the reference to key-paths which include an collection in the middle of the path.<br></p><p>chris.valueForKeyPath(#keypath(Person.friends.firstName))<br>The above example is potentially harder to implement because the argument of #keypath is not a valid Swift expression, compared to the other two examples. An alternative would be to remove the ability to reference those key-paths, making the proposal less useful, but easier to implement.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/200de2cb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Draft] Obejctive-C Keypaths</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>March  4, 2016 at 12:00:00pm</p></header><div class="content"><p>I think that using something like #keypath would be safer and more refactor-friendly than bare strings, but is KVC going to be an important part of Swift&#39;s future?<br></p><p>Félix<br></p><p>&gt; Le 4 mars 2016 à 12:05:05, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Hello Swift-friends,<br>&gt; <br>&gt; After more thinking, here is a new proposal, based on my original proposal for #selector for properties but better targeted at the intended use: referencing key-paths. Please let me know what you think:<br>&gt; <br>&gt; Referencing Objective-C key-paths<br>&gt; <br>&gt; Proposal: SE-XXXX &lt;https://github.com/apple/swift-evolution/blob/master/proposals/XXXX-objc-keypaths.md&gt;<br>&gt; Author(s): David Hart &lt;https://github.com/hartbit&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/hartbit/swift-evolution/tree/objc-keypaths#introduction&gt;Introduction<br>&gt; <br>&gt; In Objective-C and Swift, key-paths used by KVC and KVO are represented as string literals (e.g., &quot;friend.address.streetName&quot;). This proposal seeks to improve the safety and resilience to modification of code using key-paths by introducing a compiler-checked expression.<br>&gt; <br>&gt;  &lt;https://github.com/hartbit/swift-evolution/tree/objc-keypaths#motivation&gt;Motivation<br>&gt; <br>&gt; The use of string literals for key paths is extremely error-prone: there is no checking that the string corresponds to a valid key-path. In a similar manner to the proposal for the Objective-C selector expression SE-0022 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0022-objc-selectors.md&gt;, this proposal introduces a syntax for referencing compiler-checked key-paths. When the referenced properties and methods are renamed or deleted, the programmer will be notified by a compiler error.<br>&gt; <br>&gt;  &lt;https://github.com/hartbit/swift-evolution/tree/objc-keypaths#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; Introduce a new expression #keypath that allows one to build a String from a key-path:<br>&gt; <br>&gt; class Person: NSObject {<br>&gt;     dynamic var firstName: String = &quot;&quot;<br>&gt;     dynamic var lastName: String = &quot;&quot;<br>&gt;     dynamic var friends: [Person] = []<br>&gt;     dynamic var bestFriend: Person?<br>&gt; <br>&gt;     init(firstName: String, lastName: String) {<br>&gt;         self.firstName = firstName<br>&gt;         self.lastName = lastName<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let chris = Person(firstName: &quot;Chris&quot;, lastName: &quot;Lattner&quot;)<br>&gt; let joe = Person(firstName: &quot;Joe&quot;, lastName: &quot;Groff&quot;)<br>&gt; let douglas = Person(firstName: &quot;Douglas&quot;, lastName: &quot;Gregor&quot;)<br>&gt; chris.friends = [joe, douglas]<br>&gt; chris.bestFriend = joe<br>&gt; <br>&gt; <br>&gt; #keypath(Person.firstName) // =&gt; &quot;firstName&quot;<br>&gt; chris.valueForKey(#keypath(Person.firstName)) // =&gt; Chris<br>&gt; #keypath(Person.bestFriend.lastName) // =&gt; &quot;bestFriend.lastName&quot;<br>&gt; chris.valueForKeyPath(#keypath(Person.bestFriend.lastName)) // =&gt; Groff<br>&gt; #keypath(Person.friends.firstName) // =&gt; &quot;friends.firstName&quot;<br>&gt; chris.valueForKeyPath(#keypath(Person.friends.firstName)) // =&gt; [&quot;Joe&quot;, &quot;Douglas&quot;]<br>&gt; By having the #keypath expression do the work to form the Objective-C key-path string, we free the developer from having to do the manual typing and get static checking that the key-path exists and is exposed to Objective-C.<br>&gt; <br>&gt;  &lt;https://github.com/hartbit/swift-evolution/tree/objc-keypaths#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; The introduction of the #keypath expression has no impact on existing code as it returns a String. It is simply a modification-safe alternative to using literal strings for referencing key-paths.<br>&gt; <br>&gt;  &lt;https://github.com/hartbit/swift-evolution/tree/objc-keypaths#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; One aspect of the design which seems potentially complicated is the reference to key-paths which include an collection in the middle of the path.<br>&gt; <br>&gt; chris.valueForKeyPath(#keypath(Person.friends.firstName))<br>&gt; The above example is potentially harder to implement because the argument of #keypath is not a valid Swift expression, compared to the other two examples. An alternative would be to remove the ability to reference those key-paths, making the proposal less useful, but easier to implement.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/0199f20f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Draft] Obejctive-C Keypaths</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March  4, 2016 at 08:00:00pm</p></header><div class="content"><p>I think KVC is going to continue being useful:<br>* Foundation is becoming part of the Swift portability story<br>* We are still at least a year and a half (Swift 4) from the kind of features which will reduce the usefulness of KVO and KVC.<br></p><p>It is also evident that smoothing out working with Objective-C is still greatly sought out as the #selector proposal shows.<br></p><p>&gt; On 04 Mar 2016, at 18:55, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; I think that using something like #keypath would be safer and more refactor-friendly than bare strings, but is KVC going to be an important part of Swift&#39;s future?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 4 mars 2016 à 12:05:05, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Hello Swift-friends,<br>&gt;&gt; <br>&gt;&gt; After more thinking, here is a new proposal, based on my original proposal for #selector for properties but better targeted at the intended use: referencing key-paths. Please let me know what you think:<br>&gt;&gt; <br>&gt;&gt; Referencing Objective-C key-paths<br>&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt; Author(s): David Hart<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; In Objective-C and Swift, key-paths used by KVC and KVO are represented as string literals (e.g., &quot;friend.address.streetName&quot;). This proposal seeks to improve the safety and resilience to modification of code using key-paths by introducing a compiler-checked expression.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; The use of string literals for key paths is extremely error-prone: there is no checking that the string corresponds to a valid key-path. In a similar manner to the proposal for the Objective-C selector expression SE-0022, this proposal introduces a syntax for referencing compiler-checked key-paths. When the referenced properties and methods are renamed or deleted, the programmer will be notified by a compiler error.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; Introduce a new expression #keypath that allows one to build a String from a key-path:<br>&gt;&gt; <br>&gt;&gt; class Person: NSObject {<br>&gt;&gt;     dynamic var firstName: String = &quot;&quot;<br>&gt;&gt;     dynamic var lastName: String = &quot;&quot;<br>&gt;&gt;     dynamic var friends: [Person] = []<br>&gt;&gt;     dynamic var bestFriend: Person?<br>&gt;&gt; <br>&gt;&gt;     init(firstName: String, lastName: String) {<br>&gt;&gt;         self.firstName = firstName<br>&gt;&gt;         self.lastName = lastName<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let chris = Person(firstName: &quot;Chris&quot;, lastName: &quot;Lattner&quot;)<br>&gt;&gt; let joe = Person(firstName: &quot;Joe&quot;, lastName: &quot;Groff&quot;)<br>&gt;&gt; let douglas = Person(firstName: &quot;Douglas&quot;, lastName: &quot;Gregor&quot;)<br>&gt;&gt; chris.friends = [joe, douglas]<br>&gt;&gt; chris.bestFriend = joe<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; #keypath(Person.firstName) // =&gt; &quot;firstName&quot;<br>&gt;&gt; chris.valueForKey(#keypath(Person.firstName)) // =&gt; Chris<br>&gt;&gt; #keypath(Person.bestFriend.lastName) // =&gt; &quot;bestFriend.lastName&quot;<br>&gt;&gt; chris.valueForKeyPath(#keypath(Person.bestFriend.lastName)) // =&gt; Groff<br>&gt;&gt; #keypath(Person.friends.firstName) // =&gt; &quot;friends.firstName&quot;<br>&gt;&gt; chris.valueForKeyPath(#keypath(Person.friends.firstName)) // =&gt; [&quot;Joe&quot;, &quot;Douglas&quot;]<br>&gt;&gt; By having the #keypath expression do the work to form the Objective-C key-path string, we free the developer from having to do the manual typing and get static checking that the key-path exists and is exposed to Objective-C.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; The introduction of the #keypath expression has no impact on existing code as it returns a String. It is simply a modification-safe alternative to using literal strings for referencing key-paths.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; One aspect of the design which seems potentially complicated is the reference to key-paths which include an collection in the middle of the path.<br>&gt;&gt; <br>&gt;&gt; chris.valueForKeyPath(#keypath(Person.friends.firstName))<br>&gt;&gt; The above example is potentially harder to implement because the argument of #keypath is not a valid Swift expression, compared to the other two examples. An alternative would be to remove the ability to reference those key-paths, making the proposal less useful, but easier to implement.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/aae798aa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Obejctive-C Keypaths</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  4, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; * Foundation is becoming part of the Swift portability story<br></p><p>Foundation is, but KVC is not—Corelibs Foundation does not appear to support it (or even have the stubs for it).<br></p><p>Nevertheless, I do actually think this is a useful feature even without KVC. It is often the case that, in serializing an instance, you need to create fields with names matching the instance&#39;s properties. This is true whether you&#39;re using NSCoding, RawRepresentable with a dictionary raw value, or something completely custom.<br></p><p>The simplest way to do this is to type a string literal in each place. But that means each name is now duplicated in three places: the property declaration, the writing code, and the reading code. You can reduce that to two by creating constants for the property names, but that has a few issues:<br></p><p>1. There are still two sources of truth (the constants and the properties).<br>2. It requires a fair bit of discipline and foresight; it&#39;s something you have to learn is a good idea, usually through experience.<br>3. It&#39;s kind of a pain.<br></p><p>Supporting something like #keypath() even in environments without Objective-C would allow you to write this kind of code using one source of truth: the property declarations.<br></p><p>(If we did this, the use of `.` for multi-component key paths would be an arbitrary choice on non-Objective-C platforms. But it&#39;s as good as any choice. Certain types, like Optional and Array, would have to be marked as &quot;transparent&quot; to the feature; they would be considered equivalent to their generic type.)<br></p><p>If we went this route, I would suggest changing a few things here.<br></p><p>1. #keypath should be equivalent to a string literal, not necessarily a `Swift.String`. That would allow you to store it into StaticString or other StringLiteralConvertible types. (If you had an enum corresponding to the available properties, you might even be able to conform it to StringLiteralConvertible and use this feature with it.)<br></p><p>2. We *may* want to consider calling it something that&#39;s slightly less tied to Cocoa terminology, like #name or #property. (#key might be a good compromise between the two.) I don&#39;t think this is *necessary*, but we might want to consider it.<br></p><p>3. It would be nice if you could easily get a name for a property on `self`, and it might even make sense to allow you to easily get a name for a property on any variable. Maybe the syntax (assuming that this code is inside a `Person`) would be more like:<br></p><p>	print(#key(Person.bestFriend.firstName))		// =&gt; bestFriend.firstName<br>	print(#key(chris.bestFriend.firstName))			// =&gt; bestFriend.firstName<br>	print(#key(bestFriend.firstName)				// =&gt; bestFriend.firstName<br></p><p>Note that that last form has a slightly tricky rule: because the only visible `bestFriend` is a property, `#name(bestFriend.firstName)` is actually `#name(self.bestFriend.firstName)`, so the `self` is what&#39;s stripped off. A small redesign would disambiguate:<br></p><p>	print(Person.#key(bestFriend.firstName))		// =&gt; bestFriend.firstName<br>	print(chris.#key(bestFriend.firstName))			// =&gt; bestFriend.firstName<br>	print(#key(bestFriend.firstName)				// =&gt; bestFriend.firstName<br></p><p>For this receiver-based form, we might want to repurpose leading dot to refer to the type of the receiver of the method it&#39;s being passed to, if it is being passed to a method. In other words, you could write this:<br></p><p>	chris.valueForKeyPath(.#key(firstName))<br></p><p>And it would know to look in `Person` because `chris` is a `Person`. This doesn&#39;t really match the conventional meaning of leading dot, but I don&#39;t see a way to apply leading dot&#39;s usual meaning to this construct anyway.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Draft] Obejctive-C Keypaths</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March  8, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; If we went this route, I would suggest changing a few things here.<br>&gt; <br>&gt; 1. #keypath should be equivalent to a string literal, not necessarily a `Swift.String`. That would allow you to store it into StaticString or other StringLiteralConvertible types. (If you had an enum corresponding to the available properties, you might even be able to conform it to StringLiteralConvertible and use this feature with it.)<br></p><p>Sounds good to me!<br></p><p>&gt; 2. We *may* want to consider calling it something that&#39;s slightly less tied to Cocoa terminology, like #name or #property. (#key might be a good compromise between the two.) I don&#39;t think this is *necessary*, but we might want to consider it.<br></p><p>I don’t think this is a good idea because:<br>- #name, #property, #key all hide the ability to chain properties for a “key path”.<br>- #keypath already has prior meaning to so many developers.<br></p><p>Even if #keypath exists without the Objective-C runtime, I think that the name is strong enough meaning to keep it’s weight. What do you think?<br></p><p>&gt; 3. It would be nice if you could easily get a name for a property on `self`, and it might even make sense to allow you to easily get a name for a property on any variable. Maybe the syntax (assuming that this code is inside a `Person`) would be more like:<br>&gt; <br>&gt; 	print(#key(Person.bestFriend.firstName))		// =&gt; bestFriend.firstName<br>&gt; 	print(#key(chris.bestFriend.firstName))			// =&gt; bestFriend.firstName<br>&gt; 	print(#key(bestFriend.firstName)				// =&gt; bestFriend.firstName<br>&gt; <br>&gt; Note that that last form has a slightly tricky rule: because the only visible `bestFriend` is a property, `#name(bestFriend.firstName)` is actually `#name(self.bestFriend.firstName)`, so the `self` is what&#39;s stripped off. A small redesign would disambiguate:<br>&gt; <br>&gt; 	print(Person.#key(bestFriend.firstName))		// =&gt; bestFriend.firstName<br>&gt; 	print(chris.#key(bestFriend.firstName))			// =&gt; bestFriend.firstName<br>&gt; 	print(#key(bestFriend.firstName)				// =&gt; bestFriend.firstName<br></p><p>I understand the reasoning behind this modification, I would also like to be able to reference properties from variables (instead of by type), but I find both propositions confusing. I agree that with the first version, it is very tricky on first sight to understand what is being “keypathed”. But I find the second variation syntactically very surprising for Swift and I think many people in the mailing list would have problems with it.<br></p><p>Here’s a potential solution: force explicit self. inside #keypath expressions:<br></p><p>print(#keypath(Person.bestFriend.firstName))	// =&gt; bestFriend.firstName<br>print(#keypath(chris.bestFriend.firstName))	// =&gt; bestFriend.firstName<br>print(#keypath(self.bestFriend.firstName)	// =&gt; bestFriend.firstName<br></p><p>Better?<br></p><p>David.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/b9a96cfe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Draft] Obejctive-C Keypaths</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March 10, 2016 at 08:00:00am</p></header><div class="content"><p>I updated my proposal to mention value-expressions, but I since saw that my self. proposition was a bit stupid.<br></p><p>https://github.com/hartbit/swift-evolution/blob/objc-keypaths/proposals/XXXX-objc-keypaths.md<br></p><p>&gt; On 08 Mar 2016, at 08:21, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; If we went this route, I would suggest changing a few things here.<br>&gt;&gt; <br>&gt;&gt; 1. #keypath should be equivalent to a string literal, not necessarily a `Swift.String`. That would allow you to store it into StaticString or other StringLiteralConvertible types. (If you had an enum corresponding to the available properties, you might even be able to conform it to StringLiteralConvertible and use this feature with it.)<br>&gt; <br>&gt; Sounds good to me!<br>&gt; <br>&gt;&gt; 2. We *may* want to consider calling it something that&#39;s slightly less tied to Cocoa terminology, like #name or #property. (#key might be a good compromise between the two.) I don&#39;t think this is *necessary*, but we might want to consider it.<br>&gt; <br>&gt; I don’t think this is a good idea because:<br>&gt; - #name, #property, #key all hide the ability to chain properties for a “key path”.<br>&gt; - #keypath already has prior meaning to so many developers.<br>&gt; <br>&gt; Even if #keypath exists without the Objective-C runtime, I think that the name is strong enough meaning to keep it’s weight. What do you think?<br>&gt; <br>&gt;&gt; 3. It would be nice if you could easily get a name for a property on `self`, and it might even make sense to allow you to easily get a name for a property on any variable. Maybe the syntax (assuming that this code is inside a `Person`) would be more like:<br>&gt;&gt; <br>&gt;&gt; 	print(#key(Person.bestFriend.firstName))		// =&gt; bestFriend.firstName<br>&gt;&gt; 	print(#key(chris.bestFriend.firstName))			// =&gt; bestFriend.firstName<br>&gt;&gt; 	print(#key(bestFriend.firstName)				// =&gt; bestFriend.firstName<br>&gt;&gt; <br>&gt;&gt; Note that that last form has a slightly tricky rule: because the only visible `bestFriend` is a property, `#name(bestFriend.firstName)` is actually `#name(self.bestFriend.firstName)`, so the `self` is what&#39;s stripped off. A small redesign would disambiguate:<br>&gt;&gt; <br>&gt;&gt; 	print(Person.#key(bestFriend.firstName))		// =&gt; bestFriend.firstName<br>&gt;&gt; 	print(chris.#key(bestFriend.firstName))			// =&gt; bestFriend.firstName<br>&gt;&gt; 	print(#key(bestFriend.firstName)				// =&gt; bestFriend.firstName<br>&gt; <br>&gt; I understand the reasoning behind this modification, I would also like to be able to reference properties from variables (instead of by type), but I find both propositions confusing. I agree that with the first version, it is very tricky on first sight to understand what is being “keypathed”. But I find the second variation syntactically very surprising for Swift and I think many people in the mailing list would have problems with it.<br>&gt; <br>&gt; Here’s a potential solution: force explicit self. inside #keypath expressions:<br>&gt; <br>&gt; print(#keypath(Person.bestFriend.firstName))	// =&gt; bestFriend.firstName<br>&gt; print(#keypath(chris.bestFriend.firstName))	// =&gt; bestFriend.firstName<br>&gt; print(#keypath(self.bestFriend.firstName)	// =&gt; bestFriend.firstName<br>&gt; <br>&gt; Better?<br>&gt; <br>&gt; David.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/6d1dcb12/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec21faaf010581d3b9d6ef507644e622?s=50"></div><header><strong>[Draft] Obejctive-C Keypaths</strong> from <string>Jack Lawrence</string> &lt;jackl at apple.com&gt;<p>March 10, 2016 at 12:00:00am</p></header><div class="content"><p>You may also want to consider how this works with collection operators such as @sum and @unionOfObjects: https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/CollectionOperators.html<br></p><p>Jack<br>&gt; On Mar 9, 2016, at 11:52 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I updated my proposal to mention value-expressions, but I since saw that my self. proposition was a bit stupid.<br>&gt; <br>&gt; https://github.com/hartbit/swift-evolution/blob/objc-keypaths/proposals/XXXX-objc-keypaths.md &lt;https://github.com/hartbit/swift-evolution/blob/objc-keypaths/proposals/XXXX-objc-keypaths.md&gt;<br>&gt; <br>&gt;&gt; On 08 Mar 2016, at 08:21, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; If we went this route, I would suggest changing a few things here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. #keypath should be equivalent to a string literal, not necessarily a `Swift.String`. That would allow you to store it into StaticString or other StringLiteralConvertible types. (If you had an enum corresponding to the available properties, you might even be able to conform it to StringLiteralConvertible and use this feature with it.)<br>&gt;&gt; <br>&gt;&gt; Sounds good to me!<br>&gt;&gt; <br>&gt;&gt;&gt; 2. We *may* want to consider calling it something that&#39;s slightly less tied to Cocoa terminology, like #name or #property. (#key might be a good compromise between the two.) I don&#39;t think this is *necessary*, but we might want to consider it.<br>&gt;&gt; <br>&gt;&gt; I don’t think this is a good idea because:<br>&gt;&gt; - #name, #property, #key all hide the ability to chain properties for a “key path”.<br>&gt;&gt; - #keypath already has prior meaning to so many developers.<br>&gt;&gt; <br>&gt;&gt; Even if #keypath exists without the Objective-C runtime, I think that the name is strong enough meaning to keep it’s weight. What do you think?<br>&gt;&gt; <br>&gt;&gt;&gt; 3. It would be nice if you could easily get a name for a property on `self`, and it might even make sense to allow you to easily get a name for a property on any variable. Maybe the syntax (assuming that this code is inside a `Person`) would be more like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	print(#key(Person.bestFriend.firstName))		// =&gt; bestFriend.firstName<br>&gt;&gt;&gt; 	print(#key(chris.bestFriend.firstName))			// =&gt; bestFriend.firstName<br>&gt;&gt;&gt; 	print(#key(bestFriend.firstName)				// =&gt; bestFriend.firstName<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that that last form has a slightly tricky rule: because the only visible `bestFriend` is a property, `#name(bestFriend.firstName)` is actually `#name(self.bestFriend.firstName)`, so the `self` is what&#39;s stripped off. A small redesign would disambiguate:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	print(Person.#key(bestFriend.firstName))		// =&gt; bestFriend.firstName<br>&gt;&gt;&gt; 	print(chris.#key(bestFriend.firstName))			// =&gt; bestFriend.firstName<br>&gt;&gt;&gt; 	print(#key(bestFriend.firstName)				// =&gt; bestFriend.firstName<br>&gt;&gt; <br>&gt;&gt; I understand the reasoning behind this modification, I would also like to be able to reference properties from variables (instead of by type), but I find both propositions confusing. I agree that with the first version, it is very tricky on first sight to understand what is being “keypathed”. But I find the second variation syntactically very surprising for Swift and I think many people in the mailing list would have problems with it.<br>&gt;&gt; <br>&gt;&gt; Here’s a potential solution: force explicit self. inside #keypath expressions:<br>&gt;&gt; <br>&gt;&gt; print(#keypath(Person.bestFriend.firstName))	// =&gt; bestFriend.firstName<br>&gt;&gt; print(#keypath(chris.bestFriend.firstName))	// =&gt; bestFriend.firstName<br>&gt;&gt; print(#keypath(self.bestFriend.firstName)	// =&gt; bestFriend.firstName<br>&gt;&gt; <br>&gt;&gt; Better?<br>&gt;&gt; <br>&gt;&gt; David.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/92fbe3a6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Draft] Obejctive-C Keypaths</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March 10, 2016 at 04:00:00pm</p></header><div class="content"><p>I purposely left it out because it&#39;s either material for a future proposal, or not useful enough to implement in Swift.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 10 Mar 2016, at 09:29, Jack Lawrence &lt;jackl at apple.com&gt; wrote:<br>&gt; <br>&gt; You may also want to consider how this works with collection operators such as @sum and @unionOfObjects: https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/CollectionOperators.html<br>&gt; <br>&gt; Jack<br>&gt;&gt; On Mar 9, 2016, at 11:52 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I updated my proposal to mention value-expressions, but I since saw that my self. proposition was a bit stupid.<br>&gt;&gt; <br>&gt;&gt; https://github.com/hartbit/swift-evolution/blob/objc-keypaths/proposals/XXXX-objc-keypaths.md<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On 08 Mar 2016, at 08:21, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we went this route, I would suggest changing a few things here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. #keypath should be equivalent to a string literal, not necessarily a `Swift.String`. That would allow you to store it into StaticString or other StringLiteralConvertible types. (If you had an enum corresponding to the available properties, you might even be able to conform it to StringLiteralConvertible and use this feature with it.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sounds good to me!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. We *may* want to consider calling it something that&#39;s slightly less tied to Cocoa terminology, like #name or #property. (#key might be a good compromise between the two.) I don&#39;t think this is *necessary*, but we might want to consider it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think this is a good idea because:<br>&gt;&gt;&gt; - #name, #property, #key all hide the ability to chain properties for a “key path”.<br>&gt;&gt;&gt; - #keypath already has prior meaning to so many developers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even if #keypath exists without the Objective-C runtime, I think that the name is strong enough meaning to keep it’s weight. What do you think?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. It would be nice if you could easily get a name for a property on `self`, and it might even make sense to allow you to easily get a name for a property on any variable. Maybe the syntax (assuming that this code is inside a `Person`) would be more like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	print(#key(Person.bestFriend.firstName))		// =&gt; bestFriend.firstName<br>&gt;&gt;&gt;&gt; 	print(#key(chris.bestFriend.firstName))			// =&gt; bestFriend.firstName<br>&gt;&gt;&gt;&gt; 	print(#key(bestFriend.firstName)				// =&gt; bestFriend.firstName<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that that last form has a slightly tricky rule: because the only visible `bestFriend` is a property, `#name(bestFriend.firstName)` is actually `#name(self.bestFriend.firstName)`, so the `self` is what&#39;s stripped off. A small redesign would disambiguate:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	print(Person.#key(bestFriend.firstName))		// =&gt; bestFriend.firstName<br>&gt;&gt;&gt;&gt; 	print(chris.#key(bestFriend.firstName))			// =&gt; bestFriend.firstName<br>&gt;&gt;&gt;&gt; 	print(#key(bestFriend.firstName)				// =&gt; bestFriend.firstName<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I understand the reasoning behind this modification, I would also like to be able to reference properties from variables (instead of by type), but I find both propositions confusing. I agree that with the first version, it is very tricky on first sight to understand what is being “keypathed”. But I find the second variation syntactically very surprising for Swift and I think many people in the mailing list would have problems with it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s a potential solution: force explicit self. inside #keypath expressions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(#keypath(Person.bestFriend.firstName))	// =&gt; bestFriend.firstName<br>&gt;&gt;&gt; print(#keypath(chris.bestFriend.firstName))	// =&gt; bestFriend.firstName<br>&gt;&gt;&gt; print(#keypath(self.bestFriend.firstName)	// =&gt; bestFriend.firstName<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Better?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; David.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/3a88cfe6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
