<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d84ca98458a664bba5656c95d11762a?s=50"></div><header><strong>SE-0066 Reaction</strong> from <string>Mishal Awadah</string> &lt;a.mamish at gmail.com&gt;<p>April 26, 2016 at 10:00:00am</p></header><div class="content"><p>Hi,<br></p><p>I missed the original thread, but here are my thoughts on SE-0066 right<br>after Chris&#39;s email ends with &quot;thoughts?&quot;.<br></p><p><br>Concern 1:<br></p><p>I feel like we&#39;re forgetting about the functional programming syntax of<br>declaring function types like this:<br></p><p>A -&gt; B -&gt; C<br></p><p>for a function foo(a: A, b: B) -&gt; C<br></p><p>This eliminates the ambiguity of what the parameter types are, and is more<br>legible (less paren hell) than adding parens like this:<br></p><p>(A,B) -&gt; C<br></p><p>which for a function<br></p><p>foo(a: (A, B)) -&gt; C<br></p><p>would look like this after the implementation of SE-0066:<br></p><p>((A,B)) -&gt; C<br></p><p>instead of<br></p><p>(A,B) -&gt; C<br></p><p><br>Concern 2:<br></p><p>There&#39;s also the potential to transform a function like this<br></p><p>A -&gt; B -&gt; C<br></p><p>into this<br></p><p>B -&gt; C<br></p><p>after partial application, something which might not be totally irrelevant<br>to Swift in its future.<br></p><p><br>Here are a few contrived examples of function types showing the paren<br>version (order 66), the parens on the return type too, and the generic<br>functional programming version (right). I want to preface this with,<br>&quot;Remember that Swift is an enjoyable experience because reading Swift is<br>pleasant.&quot;<br></p><p><br>| 66                 | 66 return type       | generic functional style |<br>|--------------------+----------------------+--------------------------|<br>| (A) -&gt; B           | (A) -&gt; (B)           | A -&gt; B                   |<br></p><p>| (A, B) -&gt; C        | (A, B) -&gt; (C)        | A -&gt; B -&gt; C              |<br></p><p>| ((A, B)) -&gt; C      | ((A, B)) -&gt; (C)      | (A, B) -&gt; C              |<br></p><p>| ([A]) -&gt; B         | ([A]) -&gt; (B)         | [A] -&gt; B                 |<br></p><p>| ([A], (B, C)) -&gt; D | ([A], (B, C)) -&gt; (D) | [A] -&gt; (B, C) -&gt; D       |<br></p><p>| ([A], [B]) -&gt; [C]  | ([A], [B]) -&gt; ([C])  | [A] -&gt; [B] -&gt; [C]        |<br></p><p>| (([A], [B])) -&gt; C  | (([A], [B])) -&gt; (C)  | ([A], [B]) -&gt; C          |<br></p><p><br></p><p>- Mish<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/124afe0b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>SE-0066 Reaction</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 26, 2016 at 11:00:00am</p></header><div class="content"><p>On Apr 26, 2016, at 10:52 AM, Mishal Awadah via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Concern 1:<br>&gt; I feel like we&#39;re forgetting about the functional programming syntax of declaring function types like this: <br>&gt; <br>&gt; A -&gt; B -&gt; C <br>&gt; <br>&gt; for a function foo(a: A, b: B) -&gt; C<br></p><p>This analogy doesn’t exist in Swift, languages like Haskell have auto-currying behavior like this, but Swift does not.<br></p><p>&gt; <br>&gt; This eliminates the ambiguity of what the parameter types are, and is more legible (less paren hell) than adding parens like this: <br>&gt; <br>&gt; (A,B) -&gt; C<br>&gt; <br>&gt; which for a function <br>&gt; <br>&gt; foo(a: (A, B)) -&gt; C<br>&gt; <br>&gt; would look like this after the implementation of SE-0066: <br>&gt; <br>&gt; ((A,B)) -&gt; C<br>&gt; <br>&gt; instead of <br>&gt; <br>&gt; (A,B) -&gt; C<br></p><p>I’m not sure what the actual concern you’re pointing out here.  However, you are forgetting the argument labels.  Your foo example will have type:<br></p><p>(a: (A,B)) -&gt; C<br></p><p>More to the point thought, this example is *exactly* why SE-0066 is the right thing to do.  You cannot currently write the type of “foo” as &quot;(A,B) -&gt; C”.  (with or without labels), because of the grammar ambiguities that SE-0066 fixes.<br></p><p>That said, it is likely that I’m totally missing your point here, can you please restate your concern?<br></p><p><br>&gt; Concern 2:<br>&gt; <br>&gt; There&#39;s also the potential to transform a function like this<br>&gt; <br>&gt; A -&gt; B -&gt; C<br>&gt; <br>&gt; into this<br>&gt; <br>&gt; B -&gt; C<br>&gt; <br>&gt; after partial application, something which might not be totally irrelevant to Swift in its future. <br></p><p>This isn’t affected by SE-0066 - what is your concern?  With SE-0066, the transformation is:<br></p><p>(A) -&gt; (B) -&gt; C<br>into:<br>(B) -&gt; C<br></p><p>Please keep in mind that SE-0066 doesn’t change the type system, it just adds parens in a very narrow case.<br></p><p>&gt; <br>&gt; <br>&gt; Here are a few contrived examples of function types showing the paren version (order 66), the parens on the return type too, and the generic functional programming version (right). I want to preface this with, &quot;Remember that Swift is an enjoyable experience because reading Swift is pleasant.”<br></p><p>0066 does not affect the return type of a function.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d84ca98458a664bba5656c95d11762a?s=50"></div><header><strong>SE-0066 Reaction</strong> from <string>Mishal Awadah</string> &lt;a.mamish at gmail.com&gt;<p>April 26, 2016 at 03:00:00pm</p></header><div class="content"><p>On Tue, Apr 26, 2016 at 11:23 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt; On Apr 26, 2016, at 10:52 AM, Mishal Awadah via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Concern 1:<br>&gt; &gt; I feel like we&#39;re forgetting about the functional programming syntax of<br>&gt; declaring function types like this:<br>&gt; &gt;<br>&gt; &gt; A -&gt; B -&gt; C<br>&gt; &gt;<br>&gt; &gt; for a function foo(a: A, b: B) -&gt; C<br>&gt;<br>&gt; This analogy doesn’t exist in Swift, languages like Haskell have<br>&gt; auto-currying behavior like this, but Swift does not.<br>&gt;<br></p><p>Indeed, my point is that this proposal drives the distance further from<br>this analogy, which is a nice one, because function application is still<br>relevant in Swift, and may be more so in the future. That is to say, this<br>is closing a functional programming door. I am contrasting this proposal to<br>Haskell&#39;s type system, not the existing Swift one, to increase the<br>awareness of the direction this is going.<br></p><p>In summary: I am concerned that by doing this we will never do the<br>Haskell-style type annotations, which feel more at home in Swift.<br></p><p>Obviously, if the Haskell-style annotations are a given &quot;we are never going<br>to adopt this in Swift&quot;, then I cannot argue with the increased clarity<br>that 0066 provides, despite the unpleasant parenthesis proliferation it<br>will cause.<br></p><p><br>&gt;<br>&gt; &gt;<br>&gt; &gt; This eliminates the ambiguity of what the parameter types are, and is<br>&gt; more legible (less paren hell) than adding parens like this:<br>&gt; &gt;<br>&gt; &gt; (A,B) -&gt; C<br>&gt; &gt;<br>&gt; &gt; which for a function<br>&gt; &gt;<br>&gt; &gt; foo(a: (A, B)) -&gt; C<br>&gt; &gt;<br>&gt; &gt; would look like this after the implementation of SE-0066:<br>&gt; &gt;<br>&gt; &gt; ((A,B)) -&gt; C<br>&gt; &gt;<br>&gt; &gt; instead of<br>&gt; &gt;<br>&gt; &gt; (A,B) -&gt; C<br>&gt;<br>&gt; I’m not sure what the actual concern you’re pointing out here.  However,<br>&gt; you are forgetting the argument labels.  Your foo example will have type:<br>&gt;<br>&gt; (a: (A,B)) -&gt; C<br>&gt;<br>&gt; More to the point thought, this example is *exactly* why SE-0066 is the<br>&gt; right thing to do.  You cannot currently write the type of “foo” as &quot;(A,B)<br>&gt; -&gt; C”.  (with or without labels), because of the grammar ambiguities that<br>&gt; SE-0066 fixes.<br>&gt;<br>&gt; That said, it is likely that I’m totally missing your point here, can you<br>&gt; please restate your concern?<br>&gt;<br>&gt;<br>I&#39;m confused, I created this function and got the type without argument<br>label annotation.<br></p><p>func happy(a: (Int, Int)) -&gt; String {<br></p><p>    return &quot;Happy&quot;<br></p><p>}<br></p><p><br>print(happy.dynamicType)<br></p><p>// prints: (Int, Int) -&gt; String<br></p><p><br>The concern is that rather than move towards a more Haskell-like syntax<br>(which removes ambiguity of tuple params over multiple params as well) this<br>is adding more parens and making it look less pleasant to read. Contrast<br>the types of these functions in the Haskell-Style, and the proposed 0066<br>style:<br></p><p>Haskell Style: (Int, Int) -&gt; String<br>0066 Style: ((Int, Int)) -&gt; String<br></p><p>The Haskell Style would remove the ambiguity against a function like this:<br></p><p>func unhappy(a: Int, b: Int) -&gt; String {<br></p><p>    return &quot;Unhappy&quot;<br></p><p>}<br></p><p><br>print(unhappy.dynamicType)<br></p><p>//prints:(Int, Int) -&gt; String<br></p><p>Haskell Style: Int -&gt; Int -&gt; String<br>0066 Style: (Int, Int) -&gt; String<br></p><p>Now compare these two functions in their respective styles, which one is<br>clearer to parse at glance?<br></p><p>// haskell style<br></p><p>// happy: (Int, Int) -&gt; String<br></p><p>// unhappy: Int -&gt; Int -&gt; String<br></p><p><br>// 0066 style<br></p><p>// happy: ((Int, Int)) -&gt; String<br></p><p>// unhappy: (Int, Int) -&gt; String<br></p><p>Perhaps I am jaded from spending time in a functional programming world<br>(although really not that much), but it is definitely going to take me a<br>while to see that unhappy is accepting 2 separate params, rather than a<br>single tuple params. I think this is more because of how we represent tuple<br>types (like array types) as (Int, Int) or [Int] everywhere else.<br></p><p>In the wild, a tuple type looks like this:<br></p><p>foo: (Int, Int)<br></p><p>but for functions we&#39;ll use<br></p><p>fooFunc: ((Int, Int)) -&gt; ()<br></p><p><br></p><p>&gt; &gt; Concern 2:<br>&gt; &gt;<br>&gt; &gt; There&#39;s also the potential to transform a function like this<br>&gt; &gt;<br>&gt; &gt; A -&gt; B -&gt; C<br>&gt; &gt;<br>&gt; &gt; into this<br>&gt; &gt;<br>&gt; &gt; B -&gt; C<br>&gt; &gt;<br>&gt; &gt; after partial application, something which might not be totally<br>&gt; irrelevant to Swift in its future.<br>&gt;<br>&gt; This isn’t affected by SE-0066 - what is your concern?  With SE-0066, the<br>&gt; transformation is:<br>&gt;<br>&gt; (A) -&gt; (B) -&gt; C<br>&gt; into:<br>&gt; (B) -&gt; C<br>&gt;<br>&gt; Please keep in mind that SE-0066 doesn’t change the type system, it just<br>&gt; adds parens in a very narrow case.<br>&gt;<br></p><p>I was thinking about partial function application in the context of<br>ordinary functions (i.e. not those that explicitly return functions as<br>well), should that ever be an interesting direction for Swift to head into.<br></p><p>Otherwise, if we look at functions that explicitly return functions, you<br>could still get a nice function type in the Haskell way if you paren the<br>return type:<br></p><p>A -&gt; (B -&gt; C)<br></p><p>which reads more simply to me.<br></p><p>(A) -&gt; (B) -&gt; C isn&#39;t as clear to parse in this way, but with practice it<br>doesn&#39;t seem like it would be hard to get used to. Perhaps some confusing<br>instances would be:<br></p><p>(A) -&gt; (B) -&gt; (C) where (C) is a single tuple of type C.<br></p><p><br>- Mish<br></p><p><br>&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Here are a few contrived examples of function types showing the paren<br>&gt; version (order 66), the parens on the return type too, and the generic<br>&gt; functional programming version (right). I want to preface this with,<br>&gt; &quot;Remember that Swift is an enjoyable experience because reading Swift is<br>&gt; pleasant.”<br>&gt;<br>&gt; 0066 does not affect the return type of a function.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/163bf032/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>SE-0066 Reaction</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 26, 2016 at 10:00:00pm</p></header><div class="content"><p>On Apr 26, 2016, at 3:37 PM, Mishal Awadah &lt;a.mamish at gmail.com&gt; wrote:<br>&gt; This analogy doesn’t exist in Swift, languages like Haskell have auto-currying behavior like this, but Swift does not.<br>&gt; <br>&gt; Indeed, my point is that this proposal drives the distance further from this analogy, which is a nice one, because function application is still relevant in Swift, and may be more so in the future. That is to say, this is closing a functional programming door. I am contrasting this proposal to Haskell&#39;s type system, not the existing Swift one, to increase the awareness of the direction this is going. <br></p><p>Hi Mish,<br></p><p>I’m also fond of Haskell and the MLs, and I appreciate many of the choices that they made in the context of their languages.  However, there are a large number of deep differences between the type system in Swift and the type system in Haskell that motivate the current behavior we have in Swift.<br></p><p>SE-0066 is a very narrow proposal - it only affects syntax, not semantics.  The type system semantics that you seem interested in are unlikely to happen regardless of the syntax changes SE-0066 imply, and SE-0066 doesn’t have anything to do with that.<br></p><p>-Chris<br></p><p><br></p><p>&gt; <br>&gt; In summary: I am concerned that by doing this we will never do the Haskell-style type annotations, which feel more at home in Swift. <br>&gt; <br>&gt; Obviously, if the Haskell-style annotations are a given &quot;we are never going to adopt this in Swift&quot;, then I cannot argue with the increased clarity that 0066 provides, despite the unpleasant parenthesis proliferation it will cause.<br>&gt;  <br>&gt; <br>&gt; &gt;<br>&gt; &gt; This eliminates the ambiguity of what the parameter types are, and is more legible (less paren hell) than adding parens like this:<br>&gt; &gt;<br>&gt; &gt; (A,B) -&gt; C<br>&gt; &gt;<br>&gt; &gt; which for a function<br>&gt; &gt;<br>&gt; &gt; foo(a: (A, B)) -&gt; C<br>&gt; &gt;<br>&gt; &gt; would look like this after the implementation of SE-0066:<br>&gt; &gt;<br>&gt; &gt; ((A,B)) -&gt; C<br>&gt; &gt;<br>&gt; &gt; instead of<br>&gt; &gt;<br>&gt; &gt; (A,B) -&gt; C<br>&gt; <br>&gt; I’m not sure what the actual concern you’re pointing out here.  However, you are forgetting the argument labels.  Your foo example will have type:<br>&gt; <br>&gt; (a: (A,B)) -&gt; C<br>&gt; <br>&gt; More to the point thought, this example is *exactly* why SE-0066 is the right thing to do.  You cannot currently write the type of “foo” as &quot;(A,B) -&gt; C”.  (with or without labels), because of the grammar ambiguities that SE-0066 fixes.<br>&gt; <br>&gt; That said, it is likely that I’m totally missing your point here, can you please restate your concern?<br>&gt; <br>&gt; <br>&gt; I&#39;m confused, I created this function and got the type without argument label annotation. <br>&gt; <br>&gt; func happy(a: (Int, Int)) -&gt; String {<br>&gt;     return &quot;Happy&quot;<br>&gt; }<br>&gt; <br>&gt; print(happy.dynamicType)<br>&gt; // prints: (Int, Int) -&gt; String<br>&gt;  <br>&gt; <br>&gt; The concern is that rather than move towards a more Haskell-like syntax (which removes ambiguity of tuple params over multiple params as well) this is adding more parens and making it look less pleasant to read. Contrast the types of these functions in the Haskell-Style, and the proposed 0066 style: <br>&gt; <br>&gt; Haskell Style: (Int, Int) -&gt; String<br>&gt; 0066 Style: ((Int, Int)) -&gt; String<br>&gt; <br>&gt; The Haskell Style would remove the ambiguity against a function like this: <br>&gt; <br>&gt; func unhappy(a: Int, b: Int) -&gt; String {<br>&gt;     return &quot;Unhappy&quot;<br>&gt; }<br>&gt; <br>&gt; print(unhappy.dynamicType)<br>&gt; //prints:(Int, Int) -&gt; String<br>&gt; <br>&gt; Haskell Style: Int -&gt; Int -&gt; String<br>&gt; 0066 Style: (Int, Int) -&gt; String<br>&gt; <br>&gt; Now compare these two functions in their respective styles, which one is clearer to parse at glance?<br>&gt; <br>&gt; // haskell style<br>&gt; // happy: (Int, Int) -&gt; String<br>&gt; // unhappy: Int -&gt; Int -&gt; String<br>&gt; <br>&gt; // 0066 style<br>&gt; // happy: ((Int, Int)) -&gt; String<br>&gt; // unhappy: (Int, Int) -&gt; String<br>&gt; <br>&gt; Perhaps I am jaded from spending time in a functional programming world (although really not that much), but it is definitely going to take me a while to see that unhappy is accepting 2 separate params, rather than a single tuple params. I think this is more because of how we represent tuple types (like array types) as (Int, Int) or [Int] everywhere else. <br>&gt; <br>&gt; In the wild, a tuple type looks like this:<br>&gt; <br>&gt; foo: (Int, Int) <br>&gt; <br>&gt; but for functions we&#39;ll use <br>&gt; <br>&gt; fooFunc: ((Int, Int)) -&gt; ()<br>&gt; <br>&gt; <br>&gt; <br>&gt; &gt; Concern 2:<br>&gt; &gt;<br>&gt; &gt; There&#39;s also the potential to transform a function like this<br>&gt; &gt;<br>&gt; &gt; A -&gt; B -&gt; C<br>&gt; &gt;<br>&gt; &gt; into this<br>&gt; &gt;<br>&gt; &gt; B -&gt; C<br>&gt; &gt;<br>&gt; &gt; after partial application, something which might not be totally irrelevant to Swift in its future.<br>&gt; <br>&gt; This isn’t affected by SE-0066 - what is your concern?  With SE-0066, the transformation is:<br>&gt; <br>&gt; (A) -&gt; (B) -&gt; C<br>&gt; into:<br>&gt; (B) -&gt; C<br>&gt; <br>&gt; Please keep in mind that SE-0066 doesn’t change the type system, it just adds parens in a very narrow case.<br>&gt; <br>&gt; I was thinking about partial function application in the context of ordinary functions (i.e. not those that explicitly return functions as well), should that ever be an interesting direction for Swift to head into. <br>&gt; <br>&gt; Otherwise, if we look at functions that explicitly return functions, you could still get a nice function type in the Haskell way if you paren the return type:<br>&gt; <br>&gt; A -&gt; (B -&gt; C)<br>&gt; <br>&gt; which reads more simply to me.<br>&gt; <br>&gt; (A) -&gt; (B) -&gt; C isn&#39;t as clear to parse in this way, but with practice it doesn&#39;t seem like it would be hard to get used to. Perhaps some confusing instances would be: <br>&gt; <br>&gt; (A) -&gt; (B) -&gt; (C) where (C) is a single tuple of type C. <br>&gt; <br>&gt; <br>&gt; - Mish<br>&gt;  <br>&gt; <br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Here are a few contrived examples of function types showing the paren version (order 66), the parens on the return type too, and the generic functional programming version (right). I want to preface this with, &quot;Remember that Swift is an enjoyable experience because reading Swift is pleasant.”<br>&gt; <br>&gt; 0066 does not affect the return type of a function.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/4f047ae0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>SE-0066 Reaction</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>April 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; SE-0066 is a very narrow proposal - it only affects syntax, not<br>&gt; semantics.  The type system semantics that you seem interested in are<br>&gt; unlikely to happen regardless of the syntax changes SE-0066 imply, and<br>&gt; SE-0066 doesn’t have anything to do with that.<br> <br>It is most disappointing to read these sorts of statements.<br> <br>One of the things that I have noticed over the last year or so of<br>working with Swift is a trend in the community of libriaries being<br>written for Swift towards some of these &quot;system semantics&quot; (i.e.,<br>functional paradigms) like applicatives and such.<br> <br>Granted I may have a selection bias towards these sorts of libraries.<br>That is, I tried one library that did some of this stuff so then I<br>tried more. Eventually stumbling into an enclave of functional<br>practioners of Swift. I&#39;m willing to admit that I have not conducted a<br>scientific survey.<br> <br>But from my vantage we have a minority of Swift users participating in<br>these evolution discussions. Albeit, judging from the e-mail volume,<br>an extremely _vocal_ minority. I worry that these things become an<br>echo chamber and those not involved will look at some of the &quot;writing<br>on the wall&quot; and think differently about Swift going forward. Indeed<br>for those people they may look at Swift 3 and say &quot;I did not leave<br>Swift; Swift left me.&quot;<br> <br>What is more is that those not participating in these discussions now<br>may leave them with no recourse to be heard. Because apparently Swift 3<br>is a do-or-die release (or as the author of this evolution put it: &quot;It<br>is now or never.&quot;). I wonder what portion of Swift developers, the ones<br>who want to see Swift be their go-to language for the forseable future,<br>understand the implications or justifications for a Swift 3 release.<br> <br>All that having been said, I get it, decisions are made by those who<br>show up. Roger that. I also understand and agree with the desire to make<br>Swift its own language. To show restraint at the urge to turn the<br>language into a hodge podge of the &quot;greatest hits&quot; of language<br>paradigms. I sincerely appreciate the difficulty of the task for the<br>Swift core team.<br> <br>I realized at the end that I do not really have a point. Apparently I&#39;m<br>feeling philosphical this Wednesday morning.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/541097e7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>SE-0066 Reaction</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April 28, 2016 at 12:00:00am</p></header><div class="content"><p>I initially had similar concerns to Mishal, but I worked my way through it<br>and found I was wrong.<br></p><p>In current Swift you can have a function:<br>A -&gt; B -&gt; C<br></p><p>Adding brackets for clarity, that is equivalent to this (current Swift):<br>A -&gt; (B -&gt; C)<br></p><p>After this proposal this will become:<br>(A) -&gt; ((B) -&gt; C)<br></p><p>Which can also be expressed (with proposal):<br>(A) -&gt; (B) -&gt; C<br></p><p>I don&#39;t think this is making it harder to do what you want. I think that&#39;s<br>what Chris meant. Please correct me if I&#39;m wrong Chris :)<br></p><p>By my interpretation it is just removing the syntactic ambiguity between:<br> * a single argument that is a tuple of type: (A, B, C)<br> * multiple arguments: A, B, C<br></p><p> This is a small change with a big win.<br></p><p>On Wednesday, 27 April 2016, Ryan Lovelett via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; SE-0066 is a very narrow proposal - it only affects syntax, not<br>&gt; semantics.  The type system semantics that you seem interested in are<br>&gt; unlikely to happen regardless of the syntax changes SE-0066 imply, and<br>&gt; SE-0066 doesn’t have anything to do with that.<br>&gt;<br>&gt;<br>&gt; It is most disappointing to read these sorts of statements.<br>&gt;<br>&gt; One of the things that I have noticed over the last year or so of working<br>&gt; with Swift is a trend in the community of libriaries being written for<br>&gt; Swift towards some of these &quot;system semantics&quot; (i.e., functional paradigms)<br>&gt; like applicatives and such.<br>&gt;<br>&gt; Granted I may have a selection bias towards these sorts of libraries. That<br>&gt; is, I tried one library that did some of this stuff so then I tried more.<br>&gt; Eventually stumbling into an enclave of functional practioners of Swift.<br>&gt; I&#39;m willing to admit that I have not conducted a scientific survey.<br>&gt;<br>&gt; But from my vantage we have a minority of Swift users participating in<br>&gt; these evolution discussions. Albeit, judging from the e-mail volume, an<br>&gt; extremely _vocal_ minority. I worry that these things become an echo<br>&gt; chamber and those not involved will look at some of the &quot;writing on the<br>&gt; wall&quot; and think differently about Swift going forward. Indeed for those<br>&gt; people they may look at Swift 3 and say &quot;I did not leave Swift; Swift left<br>&gt; me.&quot;<br>&gt;<br>&gt; What is more is that those not participating in these discussions now may<br>&gt; leave them with no recourse to be heard. Because apparently Swift 3 is a<br>&gt; do-or-die release (or as the author of this evolution put it: &quot;It is now or<br>&gt; never.&quot;). I wonder what portion of Swift developers, the ones who want to<br>&gt; see Swift be their go-to language for the forseable future, understand the<br>&gt; implications or justifications for a Swift 3 release.<br>&gt;<br>&gt; All that having been said, I get it, decisions are made by those who show<br>&gt; up. Roger that. I also understand and agree with the desire to make Swift<br>&gt; its own language. To show restraint at the urge to turn the language into a<br>&gt; hodge podge of the &quot;greatest hits&quot; of language paradigms. I sincerely<br>&gt; appreciate the difficulty of the task for the Swift core team.<br>&gt;<br>&gt; I realized at the end that I do not really have a point. Apparently I&#39;m<br>&gt; feeling philosphical this Wednesday morning.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/f08a0614/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d84ca98458a664bba5656c95d11762a?s=50"></div><header><strong>SE-0066 Reaction</strong> from <string>Mishal Awadah</string> &lt;a.mamish at gmail.com&gt;<p>April 27, 2016 at 09:00:00am</p></header><div class="content"><p>Thanks for the feedback Chris! I am happy with this proposal given the<br>discussion here.<br></p><p>- Mish<br></p><p>On Wed, Apr 27, 2016 at 7:01 AM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br></p><p>&gt; I initially had similar concerns to Mishal, but I worked my way through it<br>&gt; and found I was wrong.<br>&gt;<br>&gt; In current Swift you can have a function:<br>&gt; A -&gt; B -&gt; C<br>&gt;<br>&gt; Adding brackets for clarity, that is equivalent to this (current Swift):<br>&gt; A -&gt; (B -&gt; C)<br>&gt;<br>&gt; After this proposal this will become:<br>&gt; (A) -&gt; ((B) -&gt; C)<br>&gt;<br>&gt; Which can also be expressed (with proposal):<br>&gt; (A) -&gt; (B) -&gt; C<br>&gt;<br>&gt; I don&#39;t think this is making it harder to do what you want. I think that&#39;s<br>&gt; what Chris meant. Please correct me if I&#39;m wrong Chris :)<br>&gt;<br>&gt; By my interpretation it is just removing the syntactic ambiguity between:<br>&gt;  * a single argument that is a tuple of type: (A, B, C)<br>&gt;  * multiple arguments: A, B, C<br>&gt;<br>&gt;  This is a small change with a big win.<br>&gt;<br>&gt; On Wednesday, 27 April 2016, Ryan Lovelett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; SE-0066 is a very narrow proposal - it only affects syntax, not<br>&gt;&gt; semantics.  The type system semantics that you seem interested in are<br>&gt;&gt; unlikely to happen regardless of the syntax changes SE-0066 imply, and<br>&gt;&gt; SE-0066 doesn’t have anything to do with that.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It is most disappointing to read these sorts of statements.<br>&gt;&gt;<br>&gt;&gt; One of the things that I have noticed over the last year or so of working<br>&gt;&gt; with Swift is a trend in the community of libriaries being written for<br>&gt;&gt; Swift towards some of these &quot;system semantics&quot; (i.e., functional paradigms)<br>&gt;&gt; like applicatives and such.<br>&gt;&gt;<br>&gt;&gt; Granted I may have a selection bias towards these sorts of libraries.<br>&gt;&gt; That is, I tried one library that did some of this stuff so then I tried<br>&gt;&gt; more. Eventually stumbling into an enclave of functional practioners of<br>&gt;&gt; Swift. I&#39;m willing to admit that I have not conducted a scientific survey.<br>&gt;&gt;<br>&gt;&gt; But from my vantage we have a minority of Swift users participating in<br>&gt;&gt; these evolution discussions. Albeit, judging from the e-mail volume, an<br>&gt;&gt; extremely _vocal_ minority. I worry that these things become an echo<br>&gt;&gt; chamber and those not involved will look at some of the &quot;writing on the<br>&gt;&gt; wall&quot; and think differently about Swift going forward. Indeed for those<br>&gt;&gt; people they may look at Swift 3 and say &quot;I did not leave Swift; Swift left<br>&gt;&gt; me.&quot;<br>&gt;&gt;<br>&gt;&gt; What is more is that those not participating in these discussions now may<br>&gt;&gt; leave them with no recourse to be heard. Because apparently Swift 3 is a<br>&gt;&gt; do-or-die release (or as the author of this evolution put it: &quot;It is now or<br>&gt;&gt; never.&quot;). I wonder what portion of Swift developers, the ones who want to<br>&gt;&gt; see Swift be their go-to language for the forseable future, understand the<br>&gt;&gt; implications or justifications for a Swift 3 release.<br>&gt;&gt;<br>&gt;&gt; All that having been said, I get it, decisions are made by those who show<br>&gt;&gt; up. Roger that. I also understand and agree with the desire to make Swift<br>&gt;&gt; its own language. To show restraint at the urge to turn the language into a<br>&gt;&gt; hodge podge of the &quot;greatest hits&quot; of language paradigms. I sincerely<br>&gt;&gt; appreciate the difficulty of the task for the Swift core team.<br>&gt;&gt;<br>&gt;&gt; I realized at the end that I do not really have a point. Apparently I&#39;m<br>&gt;&gt; feeling philosphical this Wednesday morning.<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/81793a21/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>SE-0066 Reaction</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 27, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 27, 2016, at 6:05 AM, Ryan Lovelett &lt;swift-dev at ryan.lovelett.me&gt; wrote:<br>&gt; <br>&gt;&gt; SE-0066 is a very narrow proposal - it only affects syntax, not semantics.  The type system semantics that you seem interested in are unlikely to happen regardless of the syntax changes SE-0066 imply, and SE-0066 doesn’t have anything to do with that.<br>&gt;  <br>&gt; It is most disappointing to read these sorts of statements.<br>&gt;  <br>&gt; One of the things that I have noticed over the last year or so of working with Swift is a trend in the community of libriaries being written for Swift towards some of these &quot;system semantics&quot; (i.e., functional paradigms) like applicatives and such.<br></p><p>I hope I’m coming across clearly here.  What I’m trying to say is that there are a lot of reasons that the Swift type system works the way it does (e.g. inout has very specific behavior that doesn’t work when partially applied, we have specific promotion rules that apply only in argument lists etc).  These reasons and features are certainly debatable, but have nothing to do with SE-0066, therefore they seem out of scope for a discussion of SE-0066 to go into.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>SE-0066 Reaction</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>April 28, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt;  What I’m trying to say is that there are a lot of reasons that the Swift type system works the way it does (e.g. inout has very specific behavior that doesn’t work when partially applied, we have specific promotion rules that apply only in argument lists etc).  These reasons and features are certainly debatable, but have nothing to do with SE-0066, therefore they seem out of scope for a discussion of SE-0066 to go into.<br></p><p>I agree, but although the model of small changes with immediate benefit has advantages, I think &quot;the big picture&quot; is to important to be ignored.<br>I don&#39;t think this is the case, but those of us whose only source of information is this list have a viewpoint that is narrow compared to a member of the core team (that&#39;s just natural — publishing every conversation isn&#39;t practical).<br></p><p>Coming back to the topic, there must have been a reason to start with a model where all functions take a single parameter (which might be a tuple), and there must be a good reason to dissociate from that principle.<br>I think actually knowing those motivations would be beneficial for the evolution process:<br>Although it&#39;s discouraged to discuss proposals with ground shaking consequences here on the list, sharing more of the long-term vision for Swift could help focusing on topics that fit into that vision.<br></p><p>(of course, I might just be missing an important post here or in the Swift blog, so please be patient with me if this is the case)<br></p><p>Best regards,<br>Tino<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>SE-0066 Reaction</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>April 28, 2016 at 07:00:00pm</p></header><div class="content"><p>Hey, <br></p><p>I&#39;m inserting these opinions into almost every FP discussion, for which I&#39;m sorry, but I believe it&#39;s important to remind everyone that there&#39;s the rest of us who will run away from Swift if it becomes too FP-y.<br></p><p>&gt; One of the things that I have noticed over the last year or so of working with Swift is a trend in the community of libriaries being written for Swift towards some of these &quot;system semantics&quot; (i.e., functional paradigms) like applicatives and such.<br></p><p>Just as an example of a different selection bias, I saw a couple of those, digged in for a little bit and then ran far, far away. I haven&#39;t seen any FP-related Swift libraries after that.<br></p><p>I absolutely don&#39;t have an impression that Swift has any affinity towards being functional. To me, it embraces mutability and higher-level object design aspects (like protocols) while taking only the bits of FP that are actually useful (e.g. collection methods).<br></p><p>I don&#39;t have any data, but I can bet that most software developers on iOS and Mac platforms welcome that, and don&#39;t really want the move towards FP.<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>SE-0066 Reaction</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>April 28, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Hey, <br>&gt; <br>&gt; I&#39;m inserting these opinions into almost every FP discussion, for which I&#39;m sorry, but I believe it&#39;s important to remind everyone that there&#39;s the rest of us who will run away from Swift if it becomes too FP-y.<br>&gt; <br>&gt;&gt; One of the things that I have noticed over the last year or so of working with Swift is a trend in the community of libriaries being written for Swift towards some of these &quot;system semantics&quot; (i.e., functional paradigms) like applicatives and such.<br>&gt; <br>&gt; Just as an example of a different selection bias, I saw a couple of those, digged in for a little bit and then ran far, far away. I haven&#39;t seen any FP-related Swift libraries after that.<br>&gt; <br>&gt; I absolutely don&#39;t have an impression that Swift has any affinity towards being functional. To me, it embraces mutability and higher-level object design aspects (like protocols) while taking only the bits of FP that are actually useful (e.g. collection methods).<br>&gt; <br>&gt; I don&#39;t have any data, but I can bet that most software developers on iOS and Mac platforms welcome that, and don&#39;t really want the move towards FP.<br>&gt; <br>&gt; A.<br></p><p>What do you think of this message by Chris Lattner: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/015774.html?<br></p><p>Gwendal<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>SE-0066 Reaction</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 28, 2016 at 05:00:00pm</p></header><div class="content"><p>Support your opinion on 100%. IMO Swift is language that has *elements* of <br>FP that help us to build our software, but it was not born to be Pure FP <br>language like Haskel https://en.wikipedia.org/wiki/Purely_functional<br>And I believe will never be, as then we should implement Haskell&#39;s I/O <br>system in Swift and other &#39;features&#39;.<br></p><p>Do we need Haskel instead of Swift? I don&#39;t believe so.<br></p><p>On 28.04.2016 16:48, Andrey Tarantsov via swift-evolution wrote:<br>&gt; Hey,<br>&gt;<br>&gt; I&#39;m inserting these opinions into almost every FP discussion, for which<br>&gt; I&#39;m sorry, but I believe it&#39;s important to remind everyone that there&#39;s<br>&gt; the rest of us who will run away from Swift if it becomes too FP-y.<br>&gt;<br>&gt;&gt; One of the things that I have noticed over the last year or so of<br>&gt;&gt; working with Swift is a trend in the community of libriaries being<br>&gt;&gt; written for Swift towards some of these &quot;system semantics&quot; (i.e.,<br>&gt;&gt; functional paradigms) like applicatives and such.<br>&gt;<br>&gt; Just as an example of a different selection bias, I saw a couple of<br>&gt; those, digged in for a little bit and then ran far, far away. I haven&#39;t<br>&gt; seen any FP-related Swift libraries after that.<br>&gt;<br>&gt; I absolutely don&#39;t have an impression that Swift has any affinity<br>&gt; towards being functional. To me, it embraces mutability and higher-level<br>&gt; object design aspects (like protocols) while taking only the bits of FP<br>&gt; that are actually useful (e.g. collection methods).<br>&gt;<br>&gt; I don&#39;t have any data, but I can bet that most software developers on<br>&gt; iOS and Mac platforms welcome that, and don&#39;t really want the move<br>&gt; towards FP.<br>&gt;<br>&gt; A.<br>&gt;<br>&gt; _______________________________________________ swift-evolution mailing<br>&gt; list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
