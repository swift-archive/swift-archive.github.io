<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>March  8, 2016 at 04:00:00pm</p></header><div class="content"><p>On 2016-03-04 00:48:39 +0000, Dmitri Gribenko via swift-evolution said:<br></p><p>&gt; Hi Károly,<br>&gt; <br>&gt; Sorry for a delayed reply!<br></p><p>Ditto on my part! :-)<br></p><p>&gt; On Tue, Mar 1, 2016 at 10:39 PM, Károly Lőrentey &lt;karoly at lorentey.hu&gt; wrote:<br>&gt;&gt; - My B-trees are persistent data structures, thus my nodes cannot have<br>&gt;&gt; parent or sibling links. Index lookup and navigation is still O(1)<br>&gt;&gt; though, as my indices contain pointers to every node on the path to<br>&gt;&gt; the current element.<br>&gt; <br>&gt; Are these pointers unsafe pointers or ARC references?  If they are ARC<br>&gt; references, then we get extra retain/releases.  If they are unsafe<br>&gt; pointers, we need a safety check -- and I am interested to know what<br>&gt; was your approach to this.<br></p><p>They are strong ARC references in iterators (and cursors), and weak<br>references in indices.<br></p><p>It seems to me I could replace all references on the path with<br>unowned(unsafe), except for a single strong (or weak) reference to the<br>root node. Keeping a reference to the root node will keep the rest<br>of the nodes in its subtree alive anyway.<br></p><p>The path rarely changes during iteration (there can be hundreds of<br>elements under each node), so I expect eliminating retain/release<br>would have a minimal effect there; but path creation and some<br>random-access navigation patterns could benefit from it.<br></p><p>&gt;&gt; - I found that the most straightforward place to implement tree<br>&gt;&gt; navigation methods like `next(:)` and `advance(:by:)` is on the path<br>&gt;&gt; struct that contains the actual node references. There is no reason<br>&gt;&gt; I couldn&#39;t have the new collection methods simply call through to<br>&gt;&gt; these path methods, though -- I am currently doing the same thing in<br>&gt;&gt; the BTreeIndex type anyway.<br>&gt;&gt; <br>&gt;&gt; - I&#39;m using weak references inside the index, with a (seriously<br>&gt;&gt; underdeveloped) index invalidation method that happens to be closer<br>&gt;&gt; to #2b than #2a. I&#39;m not happy about using weak references, but this<br>&gt;&gt; seemed the most sensible thing to do. I&#39;d love to replace them with<br>&gt;&gt; `unowned(unsafe)`, and the mutation counter seems like a great idea.<br>&gt;&gt; The ARC issue mentioned at the end of the proposal is rather scary,<br>&gt;&gt; though -- I don&#39;t know how I would protect against that.<br>&gt; <br>&gt; Does your tree have in-place mutation?  (E.g., if a tree is uniquely<br>&gt; referenced, and there&#39;s only one live index, does tree[i] = 42<br>&gt; reallocate any nodes?)<br></p><p>Yes, BTree does in-place mutation for uniquely referenced nodes.<br>The half-baked index invalidation algorithm I currently have in place<br>does not always detect that this happened; I&#39;d rather prefer to<br>invalidate all indices on most mutations. A per-node mutation counter<br>seems like a good way to ensure this.<br></p><p>&gt; I think the reasoning about unowned(safe) applies to weak references.<br>&gt; (The ARC issue.)<br>&gt; <br>&gt; Fundamentally, the problem is that if you want an entity to be an<br>&gt; independent value, it has to hold strong references to all its<br>&gt; critical parts.  For example, an index can hold a weak reference to<br>&gt; something, but only if it does not care and continues to be fully<br>&gt; functional if that reference suddenly becomes nil.  But if a valid<br>&gt; index can&#39;t operate without a reference to collection&#39;s storage, it<br>&gt; has to be a strong reference.<br></p><p>Yes, but #2a-style strict invalidation means that an index whose node(s)<br>have been deallocated is guaranteed to be invalid, either because of a<br>tree mutation, or because the tree that produced the index is not around<br>anymore (which is a kind of tree mutation).<br></p><p>&gt; You can replace a strong reference with an unsafe(unowned) reference,<br>&gt; but as an optimization, when it is possible to guarantee memory safety<br>&gt; by other means that are cheaper than ARC.  You should see no<br>&gt; functional difference between using a strong reference and<br>&gt; unsafe(unowned) + necessary safety checks.<br>&gt; <br>&gt;&gt; Generators/iterators look to be safe from this issue,<br>&gt;&gt; so I’ll probably optimize their path representation first.<br>&gt; <br>&gt; Generators/iterators are separate values.  So they should be<br>&gt; traversing a snapshot of the collection value.  Iterators shouldn&#39;t be<br>&gt; auto-updating with concurrent collection mutations.  For example, for<br>&gt; any collection implementation, this code terminates and appends<br>&gt; collection&#39;s elements to itself:<br>&gt; <br>&gt; var c = getCollection()<br>&gt; for item in c {<br>&gt;   c.append(item)<br>&gt; }<br>&gt; <br>&gt; Thus, iterators should be holding a strong reference to the<br>&gt; collection&#39;s storage, and make it non-uniquely referenced.<br></p><p>Understood.<br></p><p>&gt;&gt; - The `Indices` associated type is intriguing. I assume it is brand new?<br>&gt;&gt; It seems strange that it is allowed to hold a strong reference, but<br>&gt;&gt; I’ll have to look through the prototype code to grok it.<br>&gt; <br>&gt; No, it is not new.  It is a special type for `var indices`, which is<br>&gt; the collection of indices.  This variable used to be typed as<br>&gt; `Range&lt;Index&gt;` -- basically wrapping a pair of indices.<br>&gt; `Range&lt;Index&gt;` won&#39;t be able to conform to Collection in this<br>&gt; proposal, since you can&#39;t increment all indices in isolation.<br>&gt; Therefore, in the general case, `var indices` has to capture<br>&gt; startIndex, endIndex and the collection itself.  In some cases (for<br>&gt; example, Array) it can be Range&lt;Index&gt;.  To allow using the cheapest<br>&gt; possible implementation, we are making the type of `var indices` an<br>&gt; associated type.<br>&gt; <br>&gt; The reason why it needs to hold a strong reference is the same as why<br>&gt; generators need to hold a strong reference.  This index collection is<br>&gt; a separate value.  The value should be usable regardless of what<br>&gt; happens to other values.<br></p><p>Ah, interesting.<br></p><p>&gt; Consider this example:<br>&gt; <br>&gt; var c = getCollection()<br>&gt; for i in c.indices {<br>&gt;   print(i)<br>&gt;   c.append(c[i])<br>&gt; }<br>&gt; <br>&gt; Imagine that `c` is uniquely referenced, and `c.indices` holds an<br>&gt; unowned reference to `c` that does not increase the reference count.<br>&gt; Then, when a new element is appended, the collection might need to<br>&gt; reallocate the storage.  The old storage will be deallocated.  When<br>&gt; `c.indices` needs to increment the index, it will try to access an<br>&gt; unowned reference that was deallocated, and the program will trap.<br></p><p>My problem is that this example assumes that mutating `c` at a certain<br>index won&#39;t invalidate earlier indices. And even if that is true for<br>`c`, whenever `c.indices` holds a strong reference, an idiom like<br></p><p>  for i in c.indices {<br>    c.mutate(i)<br>  }<br></p><p>will certainly lead to COW copying that isn&#39;t happening today with<br></p><p>  var i = c.startIndex<br>  while i != c.endIndex {<br>    c.mutate(i)<br>    i = i.successor()<br>  }<br></p><p>How would I emulate the exact semantics of today&#39;s code with `c.indices`?<br></p><p>-- <br>Károly<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
