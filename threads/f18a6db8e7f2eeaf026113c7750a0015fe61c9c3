<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft Proposal] Require `final` on protocol extension members</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 29, 2015 at 03:00:00am</p></header><div class="content"><p>I&#39;ve been working on this on-and-off for a few weeks, and I&#39;ve finished drafting a formal proposal. Comments welcome.<br></p><p>&lt;https://github.com/brentdax/swift-evolution/blob/final-protocol-methods/proposals/0000-require-final-on-protocol-extension-methods.md&gt;<br></p><p><br></p><p># Require `final` on protocol extension members<br></p><p>## Introduction<br></p><p>Protocol extension members which aren&#39;t listed in the protocol itself have an unusual behavior: a conforming type can implement an identically named member, but instances with the protocol&#39;s type are always statically dispatched to the protocol&#39;s implementation. This can lead to the same instance displaying different behavior when it&#39;s cast to a  protocol it conforms to. In effect, the conforming type&#39;s member shadows the protocol&#39;s, rather than overriding it. This behavior is very surprising to some users.<br></p><p>The lack of a warning on this is [currently considered a bug](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001861.html), but I think we should go further and cause it to be an error. However, we should also provide an escape hatch which permits conflicts in cases where they&#39;re necessary.<br></p><p>## Motivation<br></p><p>Suppose you write a protocol and extension like this:<br></p><p>	protocol Turnable {<br>	    func turning() -&gt; Self<br>	    mutating func turn()<br>	}<br>	extension Turnable {<br>	    mutating func turn() {<br>	        self = turning()<br>	    }<br>	<br>	    func turningRepeatedly(additionalTurns: Int) -&gt; Self {<br>	        var turnedSelf = self<br>	        for _ in 1...additionalTurns {<br>	            turnedSelf.turn()<br>	        }<br>	        return turnedSelf<br>	    }<br>	}<br></p><p>Now you want to write a conforming type, `SpimsterWicket`. There are three different rules about whether your type has to, or can, implement its own versions of these methods.<br></p><p>1. `turning()` is a “protocol method”: it is listed in the protocol but is not included in the extension. You *must* implement `turning()` to conform to `Turnable`.<br>2. `turn()` is a “defaulted protocol method”: it is listed in the protocol but there is also an implementation of it in the extension. You *may* implement `turn()`; if you don’t, the protocol extension’s implementation will be used.<br>3. `turningRepeatedly(_: Int)` is a “protocol extension method”: it is *not* listed in the protocol, but only in the protocol extension. This is the case we are trying to address.<br></p><p>Currently, in case 3, Swift permits you to implement your own `turningRepeatedly(_: Int)`. However, your implementation may not be called in every circumstance that you expect. If you call `turningRepeatedly` on a variable of type `SpimsterWicket`, you’ll get `SpimsterWicket`’s implementation of the method; however, if you call `turningRepeatedly` on a variable of type `Turnable`, you’ll get `Turnable`’s implementation of the method.<br></p><p>	var wicket: SpimsterWicket = SpimsterWicket()<br>	var turnable: Turnable = wicket<br>	<br>	wicket.turn()					// Calls SpimsterWicket.turn()<br>	turnable.turn()					// Also calls SpimsterWicket.turn()<br>	<br>	wicket.turningRepeatedly(5)		// Calls SpimsterWicket.turningRepeatedly(_:)<br>	turnable.turningRepeatedly(5)	// Calls Turnable.turningRepeatedly(_:)<br></p><p>In most parts of Swift, casting an instance or assigning it to a variable of a different type doesn’t change which implementation will be called when you put it on the left-hand side of a dot. (I’m leaving aside Objective-C bridging, like `Int` to `NSNumber`, which is really a different operation being performed with the same syntax.) If you put a `UIControl` into a variable of type `UIView`, and then call `touchesBegan()` on that variable, Swift will still call `UIControl.touchesBegan()`. The same is true of defaulted protocol methods—if you call `turn()` on `turnable`, you’ll get `SpimsterWicket.turn()`.<br></p><p>But this is not true of protocol extension methods. There, the static type of the variable—the type known at compile time, the type that the variable is labeled with—is used. Thus, calling `turningRepeatedly(_:)` on `wicket` gets you `SpimsterWicket`’s implementation, but calling it on `turnable`—even though it&#39;s merely the same instance casted to a different type—gets you `Turnable`’s implementation.<br></p><p>This creates what I call an “incoherent” dispatch, and it occurs nowhere else in Swift. In most places in Swift, method dispatch is either based on the runtime type (reference types, normal protocol members), or the design of the language ensures there’s no difference between dispatching on the compile-time type and the runtime type (value types, `final` members). But in protocol extension members, dispatch is based on the compile-time type even though the runtime type might produce different behavior.<br></p><p>## Proposed solution<br></p><p>I propose that we:<br></p><p>1. Cause Swift to emit an error when it detects this sort of conflict.<br>2. Add a mandatory `final` keyword to statically-dispatched protocol extension members, to give a textual indication that these errors will occur.<br>3. For those circumstances in which this conflict is a necessary evil, provide an attribute which can be applied to indicate that conflicts are allowed when caused by a particular conformance.<br></p><p>Specifics follow, though not in the order given above. In the examples below, `T` and `U` are conforming types, `P` and `Q` are protocols, and `f` is a member which, in some cases, may be a final protocol extension member.<br></p><p>### Mark protocol extension members with the `final` keyword<br></p><p>If we are going to emit an error for these conflicts, it would be helpful to mark which members are prone to them.<br></p><p>I therefore propose that all protocol extension members (that is, the ones that aren&#39;t providing a default implementation for a protocol requirement) be marked with the `final` keyword. Failing to mark such a member with `final` would cause an error.<br></p><p>Currently, the `final` keyword is only used on classes. When applied to a class&#39;s member, it indicates that subclasses cannot override that member. I see this new use of the `final` keyword as analogously indicating that conforming types cannot customize the member. In fact, you can capture both meanings of `final` in a single statement:<br></p><p>&gt; `final` declares that subtypes of this type must use this specific implementation of the member, and cannot substitute their own specialized implementation. Attempting to do so causes an error.<br></p><p>### Make conflicting with a `final` protocol extension method an error<br></p><p>We can now define an incoherent type as one in which a `final` protocol extension member is shadowed by a member of a conforming type, as seen from any source file. (Note that methods and subscripts are only shadowed by a member with a matching signature.)<br></p><p>Because incoherence is caused by the interaction of two separate declarations, there are many different circumstances in which incoherence may be caused. Here are the ones I&#39;ve been able to think of:<br></p><p>1. Type `T` is conformed to protocol `P` in a file where member `f` is visible on both `T` and `P`.<br>2. Type `T` is conformed to protocols `P` and `Q`, which both have a final member `f`. (Note that diamond conformance patterns, where `P` and `Q` both get the same final member `f` from protocol `R`, should be permitted.)<br>3. Type `T` is extended to add a member `f` in a file where `T`&#39;s conformance to `P` is imported from another module, and `P` has a final member `f`.<br>4. Protocol `P` is extended to add final member `f` in a file where `T`&#39;s conformance to `P`, and the declaration of `T.f`, are both imported from other modules.<br>5. A source file imports module A, which extends protocol `P` to include final member `f`, and module B, which conforms type `T` with member `f` to conform to `P`.<br></p><p>It should be noted that these conflicts are tied to *visibility*. There is no conflict if the two definitions of `f` are not both visible in  the same place. For instance:<br></p><p>- If file A.swift extends `T` with a private member `f`, and file B.swift extends `P` with a private final member `f`, there is no conflict.<br>- If module A extends `T` with an internal member `f`, and module B extends `P` with an internal final member `f`, there is no conflict.<br>- If module A extends `T` with a *public* member `f`, and module B extends `P` with a public final member `f`, there is only a conflict if A and B are imported in the same file. Even if A and B are imported in different files in the same module, there is no conflict.<br></p><p>### Permit conflicts with an explicit acknowledgement through an `@incoherent` attribute<br></p><p>In some circumstances, it may be desirable to permit a conflict, even though it causes surprising behavior. For instance, you may want to conform an existing type to a protocol where the names conflict through sheer happenstance, and you know the protocol extension method will only ever be needed in code that treats that uses the protocol&#39;s type. In those cases, you can disable the conflict error and restore the current incoherent dispatch behavior using an `@incoherent` attribute.<br></p><p>The `@incoherent` attribute is always tied to a particular type and protocol. It says, in essence, &quot;I know type T conflicts with protocol P, and I want to ignore all of those conflicts and accept incoherent dispatch.&quot; Depending on where it&#39;s attached, you may have to specify more or less information in the attribute&#39;s parameters. For instance:<br></p><p>	// Mark the conformance.<br>	extension T: @incoherent P {...}<br>	<br>	// Mark the extension.<br>	@incoherent(T) extension P {...}<br>	@incoherent(P) extension T {...}<br>	<br>	// Mark the import statement<br>	@incoherent(T: P) import B<br></p><p>## Detailed design<br></p><p>### Errors for improper use of the `final` keyword<br></p><p>Failing to put a `final` keyword on a protocol extension member which requires it should emit an error message along these lines:<br></p><p>&gt; f must be final because it is not a requirement of P.<br></p><p>This error should include a fix-it which adds the `final` keyword.<br></p><p>Putting a `final` keyword on a defaulted protocol member is nonsensical—it essentially gives the member the semantics of a protocol extension member. We should emit an error message along these lines:<br></p><p>&gt; f cannot be final because it is a requirement of P.<br></p><p>This error should include a fix-it which removes the `final` keyword.<br></p><p>### Errors for conflicting members<br></p><p>As mentioned above, there are many ways to cause a conflict, and each of them needs a slightly different wording. Here&#39;s what I propose:<br></p><p>1. **Type `T` is conformed to protocol `P` in a file where member `f` is visible on both `T` and `P`.** The declaration of the conformance (that is, the declaration with the `: P` clause) should be marked with an error like:<br></p><p>   &gt; T cannot conform to P because T.f conflicts with final member P.f.<br>	<br>2. **Type `T` is conformed to protocols `P` and `Q`, which both have a final member `f`.** The declaration of one of the conformances should be marked with an error like:<br></p><p>   &gt; T cannot conform to both P and Q because final member P.f conflicts with final member Q.f.<br></p><p>3. **Type `T` is extended to add a member `f` in a file where `T`&#39;s conformance to `P` is imported from another module, and `P` has a final member `f`.** The declaration of the concrete type extension should be marked with an error like:<br></p><p>   &gt; T cannot be extended to add member f because it conflicts with final member P.f.<br></p><p>4. **Protocol `P` is extended to add final member `f` in a file where `T`&#39;s conformance to `P`, and the declaration of `T.f`, are both imported from other modules.** The declaration of the protocol extension should be marked with an error like:<br></p><p>   &gt; P cannot be extended to add final member f because it conflicts with member T.f of a conforming type.<br>	<br>5. **A source file imports module A, which extends protocol `P` to include final member `f`, and module B, which conforms type `T` with member `f` to conform to `P`.** The later of the two imports should be marked with an error like:<br></p><p>   &gt; B cannot be imported because final member P.f conflicts with A&#39;s T.f.<br></p><p>The preferred means of resolving a conflict include:<br></p><p>- Renaming one of the conflicting members.<br>- Deleting one of the conflicting members.<br>- Deleting an `import` statement which causes the conflict.<br>- Adding the conflicting member to the protocol, and removing the `final` keyword, so that it becomes a defaulted protocol member.<br></p><p>If it is feasible to provide a fix-it suggesting one of these solutions, that should be done.<br></p><p>Fix-its should *not* suggest adding an `@incoherent` attribute. It is sometimes necessary to permit incoherence, but it&#39;s never desirable, because incoherence is confusing. A fix-it would encourage users to enable incoherence without actually understanding what it means, which will cause confusion.<br></p><p>### Marking multiple `@incoherent` types<br></p><p>In places where one parameter to the `@incoherent` attribute is permitted, you can instead provide a comma-separated list to permit several different incoherences caused by the same declaration:<br></p><p>	@incoherent(T, U) extension P {...}<br>	@incoherent(P, Q) extension T {...}<br>	<br>	@incoherent(T: P, U: Q) import B<br></p><p>## Impact on existing code<br></p><p>The requirement that `final` be applied to many protocol extension methods will cause many—perhaps most—protocol extensions to stop compiling without changes. However, the changes needed—adding a keyword to the declarations of relevant members—are fairly mechanical and are fix-it guided. The migrator should add them automatically.<br></p><p>The conflict errors will cause a smaller number of conformance declarations, protocol extensions, or `import` statements to fail to compile. I believe that many of these cases will be bugs, and users will want to rename members to avoid them. When users do not want to rename, they can preserve the existing semantics with an `@incoherent` attribute.<br></p><p>Because this is primarily a safety feature, does not change runtime semantics, and, in most codebases, all changes will be purely mechanical, I believe this feature should be added to the next minor version of Swift, rather than waiting for 3.0.<br></p><p>## Alternatives considered<br></p><p>### Dynamically dispatch calls to protocol extension members<br></p><p>This would fix the underlying problem—the confusing behavior—by making protocol extension members not behave confusingly.<br></p><p>This would likely take a redesign of protocol witnesses to include extension methods not listed in the original protocol. It&#39;s probably not impossible—class extensions behave this way—but it&#39;s a much bigger change than what I propose, which keeps the current runtime semantics and only adds compile-time errors and keywords.<br></p><p>Dynamically dispatching to protocol extension members would also change the performance characteristics of these calls. Even if this change were made, we might want to allow users to apply `final` to extension methods which they want to be dispatched statically.<br></p><p>### Don&#39;t provide an `@incoherent` attribute<br></p><p>This would improve safety by making this confusing construct completely impossible to write. However, it would also make it completely impossible to conform certain types to certain protocols or import certain combinations of modules into the same file. This seems especially unwise because previous versions of Swift have actually permitted this shadowing; code that previously compiled without even a warning could be difficult to port.<br></p><p>### Mark default members instead of statically dispatched members<br></p><p>This would invert the keywording in a protocol extension: instead of marking the statically-dispatched members with `final`, you would mark the overridable members with `default`.<br></p><p>I prefer `final` because it marks the more unusual case. Users are not surprised that they can override default methods; they are surprised that they *can&#39;t* reliably override protocol extension methods. Also, as mentioned in the previous section, I could see `final` being retained even if protocol extension methods gained dynamic dispatch.<br></p><p>However, my preference is not terribly strong, and using `default` on the overridable methods is not a bad option.<br></p><p>### Require a `final` keyword, but don&#39;t prevent conflicts with an error<br></p><p>The problem with this approach is that the conflict is the surprising part. It doesn&#39;t matter all that much whether protocol extension members are dispatched statically or dynamically *except* if there&#39;s a conflict; *then* you&#39;re getting into potential bug territory. The `@incoherent` keyword is what makes this mistake impossible to make accidentally; without it, this is merely a proposal to force people to annotate their protocol extensions more clearly.<br></p><p>### Don&#39;t require a `final` keyword, but prevent conflicts with an error<br></p><p>Without the `final` keyword (or the `default` alternative mentioned above) on the extension members themselves, it&#39;s impossible to tell at a glance which members are overridable and which ones aren&#39;t. This makes predicting incoherent conformance errors an exercise in trial-and-error, or at least in visual-diffing two separate parts of the code to figure out what&#39;s going on. Without the `final` keyword, in other words, avoiding conflicts when you write your code instead of discovering them when you compile it is much more difficult.<br></p><p>### Mark specific conflicting members<br></p><p>Rather than marking an entire conformance as permitted to allow conflicts, we could force users to mark specific conflicting members. For instance, in the `Turnable`/`SpimsterWicket` example used above, `turningRepeatedly(_:)` itself would have to be marked in some way.<br></p><p>The main issue I see is that, in many cases, a conformance is added in a different file or even module than the conflicting declaration, so there&#39;s no convenient place to put the attribute. This is basically the same reason there&#39;s no equivalent of `override` for implementations of protocol methods.<br></p><p>This would also require more declarations, but I don&#39;t necessarily think that would be a bad thing.<br></p><p><br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Draft Proposal] Require `final` on protocol extension members</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  4, 2016 at 03:00:00pm</p></header><div class="content"><p>Didn&#39;t we already have a very long discussion about all of this?<br></p><p>In any case, I very strongly disagree with this. It&#39;s confusing, it&#39;s overloading the term `final` in a way that doesn&#39;t seem to make sense (`final` means you can&#39;t subclass or override, but there&#39;s nothing in this proposal that affects either subclassing _or_ method overriding), and it means protocol extensions that you aren&#39;t even aware of from other modules can cause your otherwise-legal type to start throwing errors.<br></p><p>Making this kind of change only makes any sense at all if you assume that, every single time someone implements a method that happens to look the same as a method provided by a protocol extension, they&#39;re trying to override that protocol extension method. But since protocol extension methods cannot be overridden (merely shadowed), that assumption doesn&#39;t make a lot of sense. But even if I accepted that assumption, I would still say this is an abuse of the term `final`, and I think forcing people to brand their legitimate functions with a negative-sounding term &quot;incoherent&quot; is also basically subtly punishing people. I mean, who wants to write code that is publicly branded as being &quot;incoherent&quot; code?<br></p><p>Also, even after reading this proposal, it&#39;s still not obvious to me how the @incoherent attribute works. The rest is a little confusing, but this attribute is very confusing all by itself.<br></p><p>-Kevin Ballard<br></p><p>On Tue, Dec 29, 2015, at 03:04 AM, Brent Royal-Gordon via swift-evolution wrote:<br>&gt; I&#39;ve been working on this on-and-off for a few weeks, and I&#39;ve finished drafting a formal proposal. Comments welcome.<br>&gt; <br>&gt; &lt;https://github.com/brentdax/swift-evolution/blob/final-protocol-methods/proposals/0000-require-final-on-protocol-extension-methods.md&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; # Require `final` on protocol extension members<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; Protocol extension members which aren&#39;t listed in the protocol itself have an unusual behavior: a conforming type can implement an identically named member, but instances with the protocol&#39;s type are always statically dispatched to the protocol&#39;s implementation. This can lead to the same instance displaying different behavior when it&#39;s cast to a  protocol it conforms to. In effect, the conforming type&#39;s member shadows the protocol&#39;s, rather than overriding it. This behavior is very surprising to some users.<br>&gt; <br>&gt; The lack of a warning on this is [currently considered a bug](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001861.html), but I think we should go further and cause it to be an error. However, we should also provide an escape hatch which permits conflicts in cases where they&#39;re necessary.<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; Suppose you write a protocol and extension like this:<br>&gt; <br>&gt; 	protocol Turnable {<br>&gt; 	    func turning() -&gt; Self<br>&gt; 	    mutating func turn()<br>&gt; 	}<br>&gt; 	extension Turnable {<br>&gt; 	    mutating func turn() {<br>&gt; 	        self = turning()<br>&gt; 	    }<br>&gt; 	<br>&gt; 	    func turningRepeatedly(additionalTurns: Int) -&gt; Self {<br>&gt; 	        var turnedSelf = self<br>&gt; 	        for _ in 1...additionalTurns {<br>&gt; 	            turnedSelf.turn()<br>&gt; 	        }<br>&gt; 	        return turnedSelf<br>&gt; 	    }<br>&gt; 	}<br>&gt; <br>&gt; Now you want to write a conforming type, `SpimsterWicket`. There are three different rules about whether your type has to, or can, implement its own versions of these methods.<br>&gt; <br>&gt; 1. `turning()` is a “protocol method”: it is listed in the protocol but is not included in the extension. You *must* implement `turning()` to conform to `Turnable`.<br>&gt; 2. `turn()` is a “defaulted protocol method”: it is listed in the protocol but there is also an implementation of it in the extension. You *may* implement `turn()`; if you don’t, the protocol extension’s implementation will be used.<br>&gt; 3. `turningRepeatedly(_: Int)` is a “protocol extension method”: it is *not* listed in the protocol, but only in the protocol extension. This is the case we are trying to address.<br>&gt; <br>&gt; Currently, in case 3, Swift permits you to implement your own `turningRepeatedly(_: Int)`. However, your implementation may not be called in every circumstance that you expect. If you call `turningRepeatedly` on a variable of type `SpimsterWicket`, you’ll get `SpimsterWicket`’s implementation of the method; however, if you call `turningRepeatedly` on a variable of type `Turnable`, you’ll get `Turnable`’s implementation of the method.<br>&gt; <br>&gt; 	var wicket: SpimsterWicket = SpimsterWicket()<br>&gt; 	var turnable: Turnable = wicket<br>&gt; 	<br>&gt; 	wicket.turn()					// Calls SpimsterWicket.turn()<br>&gt; 	turnable.turn()					// Also calls SpimsterWicket.turn()<br>&gt; 	<br>&gt; 	wicket.turningRepeatedly(5)		// Calls SpimsterWicket.turningRepeatedly(_:)<br>&gt; 	turnable.turningRepeatedly(5)	// Calls Turnable.turningRepeatedly(_:)<br>&gt; <br>&gt; In most parts of Swift, casting an instance or assigning it to a variable of a different type doesn’t change which implementation will be called when you put it on the left-hand side of a dot. (I’m leaving aside Objective-C bridging, like `Int` to `NSNumber`, which is really a different operation being performed with the same syntax.) If you put a `UIControl` into a variable of type `UIView`, and then call `touchesBegan()` on that variable, Swift will still call `UIControl.touchesBegan()`. The same is true of defaulted protocol methods—if you call `turn()` on `turnable`, you’ll get `SpimsterWicket.turn()`.<br>&gt; <br>&gt; But this is not true of protocol extension methods. There, the static type of the variable—the type known at compile time, the type that the variable is labeled with—is used. Thus, calling `turningRepeatedly(_:)` on `wicket` gets you `SpimsterWicket`’s implementation, but calling it on `turnable`—even though it&#39;s merely the same instance casted to a different type—gets you `Turnable`’s implementation.<br>&gt; <br>&gt; This creates what I call an “incoherent” dispatch, and it occurs nowhere else in Swift. In most places in Swift, method dispatch is either based on the runtime type (reference types, normal protocol members), or the design of the language ensures there’s no difference between dispatching on the compile-time type and the runtime type (value types, `final` members). But in protocol extension members, dispatch is based on the compile-time type even though the runtime type might produce different behavior.<br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; I propose that we:<br>&gt; <br>&gt; 1. Cause Swift to emit an error when it detects this sort of conflict.<br>&gt; 2. Add a mandatory `final` keyword to statically-dispatched protocol extension members, to give a textual indication that these errors will occur.<br>&gt; 3. For those circumstances in which this conflict is a necessary evil, provide an attribute which can be applied to indicate that conflicts are allowed when caused by a particular conformance.<br>&gt; <br>&gt; Specifics follow, though not in the order given above. In the examples below, `T` and `U` are conforming types, `P` and `Q` are protocols, and `f` is a member which, in some cases, may be a final protocol extension member.<br>&gt; <br>&gt; ### Mark protocol extension members with the `final` keyword<br>&gt; <br>&gt; If we are going to emit an error for these conflicts, it would be helpful to mark which members are prone to them.<br>&gt; <br>&gt; I therefore propose that all protocol extension members (that is, the ones that aren&#39;t providing a default implementation for a protocol requirement) be marked with the `final` keyword. Failing to mark such a member with `final` would cause an error.<br>&gt; <br>&gt; Currently, the `final` keyword is only used on classes. When applied to a class&#39;s member, it indicates that subclasses cannot override that member. I see this new use of the `final` keyword as analogously indicating that conforming types cannot customize the member. In fact, you can capture both meanings of `final` in a single statement:<br>&gt; <br>&gt; &gt; `final` declares that subtypes of this type must use this specific implementation of the member, and cannot substitute their own specialized implementation. Attempting to do so causes an error.<br>&gt; <br>&gt; ### Make conflicting with a `final` protocol extension method an error<br>&gt; <br>&gt; We can now define an incoherent type as one in which a `final` protocol extension member is shadowed by a member of a conforming type, as seen from any source file. (Note that methods and subscripts are only shadowed by a member with a matching signature.)<br>&gt; <br>&gt; Because incoherence is caused by the interaction of two separate declarations, there are many different circumstances in which incoherence may be caused. Here are the ones I&#39;ve been able to think of:<br>&gt; <br>&gt; 1. Type `T` is conformed to protocol `P` in a file where member `f` is visible on both `T` and `P`.<br>&gt; 2. Type `T` is conformed to protocols `P` and `Q`, which both have a final member `f`. (Note that diamond conformance patterns, where `P` and `Q` both get the same final member `f` from protocol `R`, should be permitted.)<br>&gt; 3. Type `T` is extended to add a member `f` in a file where `T`&#39;s conformance to `P` is imported from another module, and `P` has a final member `f`.<br>&gt; 4. Protocol `P` is extended to add final member `f` in a file where `T`&#39;s conformance to `P`, and the declaration of `T.f`, are both imported from other modules.<br>&gt; 5. A source file imports module A, which extends protocol `P` to include final member `f`, and module B, which conforms type `T` with member `f` to conform to `P`.<br>&gt; <br>&gt; It should be noted that these conflicts are tied to *visibility*. There is no conflict if the two definitions of `f` are not both visible in  the same place. For instance:<br>&gt; <br>&gt; - If file A.swift extends `T` with a private member `f`, and file B.swift extends `P` with a private final member `f`, there is no conflict.<br>&gt; - If module A extends `T` with an internal member `f`, and module B extends `P` with an internal final member `f`, there is no conflict.<br>&gt; - If module A extends `T` with a *public* member `f`, and module B extends `P` with a public final member `f`, there is only a conflict if A and B are imported in the same file. Even if A and B are imported in different files in the same module, there is no conflict.<br>&gt; <br>&gt; ### Permit conflicts with an explicit acknowledgement through an `@incoherent` attribute<br>&gt; <br>&gt; In some circumstances, it may be desirable to permit a conflict, even though it causes surprising behavior. For instance, you may want to conform an existing type to a protocol where the names conflict through sheer happenstance, and you know the protocol extension method will only ever be needed in code that treats that uses the protocol&#39;s type. In those cases, you can disable the conflict error and restore the current incoherent dispatch behavior using an `@incoherent` attribute.<br>&gt; <br>&gt; The `@incoherent` attribute is always tied to a particular type and protocol. It says, in essence, &quot;I know type T conflicts with protocol P, and I want to ignore all of those conflicts and accept incoherent dispatch.&quot; Depending on where it&#39;s attached, you may have to specify more or less information in the attribute&#39;s parameters. For instance:<br>&gt; <br>&gt; 	// Mark the conformance.<br>&gt; 	extension T: @incoherent P {...}<br>&gt; 	<br>&gt; 	// Mark the extension.<br>&gt; 	@incoherent(T) extension P {...}<br>&gt; 	@incoherent(P) extension T {...}<br>&gt; 	<br>&gt; 	// Mark the import statement<br>&gt; 	@incoherent(T: P) import B<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; ### Errors for improper use of the `final` keyword<br>&gt; <br>&gt; Failing to put a `final` keyword on a protocol extension member which requires it should emit an error message along these lines:<br>&gt; <br>&gt; &gt; f must be final because it is not a requirement of P.<br>&gt; <br>&gt; This error should include a fix-it which adds the `final` keyword.<br>&gt; <br>&gt; Putting a `final` keyword on a defaulted protocol member is nonsensical—it essentially gives the member the semantics of a protocol extension member. We should emit an error message along these lines:<br>&gt; <br>&gt; &gt; f cannot be final because it is a requirement of P.<br>&gt; <br>&gt; This error should include a fix-it which removes the `final` keyword.<br>&gt; <br>&gt; ### Errors for conflicting members<br>&gt; <br>&gt; As mentioned above, there are many ways to cause a conflict, and each of them needs a slightly different wording. Here&#39;s what I propose:<br>&gt; <br>&gt; 1. **Type `T` is conformed to protocol `P` in a file where member `f` is visible on both `T` and `P`.** The declaration of the conformance (that is, the declaration with the `: P` clause) should be marked with an error like:<br>&gt; <br>&gt;    &gt; T cannot conform to P because T.f conflicts with final member P.f.<br>&gt; 	<br>&gt; 2. **Type `T` is conformed to protocols `P` and `Q`, which both have a final member `f`.** The declaration of one of the conformances should be marked with an error like:<br>&gt; <br>&gt;    &gt; T cannot conform to both P and Q because final member P.f conflicts with final member Q.f.<br>&gt; <br>&gt; 3. **Type `T` is extended to add a member `f` in a file where `T`&#39;s conformance to `P` is imported from another module, and `P` has a final member `f`.** The declaration of the concrete type extension should be marked with an error like:<br>&gt; <br>&gt;    &gt; T cannot be extended to add member f because it conflicts with final member P.f.<br>&gt; <br>&gt; 4. **Protocol `P` is extended to add final member `f` in a file where `T`&#39;s conformance to `P`, and the declaration of `T.f`, are both imported from other modules.** The declaration of the protocol extension should be marked with an error like:<br>&gt; <br>&gt;    &gt; P cannot be extended to add final member f because it conflicts with member T.f of a conforming type.<br>&gt; 	<br>&gt; 5. **A source file imports module A, which extends protocol `P` to include final member `f`, and module B, which conforms type `T` with member `f` to conform to `P`.** The later of the two imports should be marked with an error like:<br>&gt; <br>&gt;    &gt; B cannot be imported because final member P.f conflicts with A&#39;s T.f.<br>&gt; <br>&gt; The preferred means of resolving a conflict include:<br>&gt; <br>&gt; - Renaming one of the conflicting members.<br>&gt; - Deleting one of the conflicting members.<br>&gt; - Deleting an `import` statement which causes the conflict.<br>&gt; - Adding the conflicting member to the protocol, and removing the `final` keyword, so that it becomes a defaulted protocol member.<br>&gt; <br>&gt; If it is feasible to provide a fix-it suggesting one of these solutions, that should be done.<br>&gt; <br>&gt; Fix-its should *not* suggest adding an `@incoherent` attribute. It is sometimes necessary to permit incoherence, but it&#39;s never desirable, because incoherence is confusing. A fix-it would encourage users to enable incoherence without actually understanding what it means, which will cause confusion.<br>&gt; <br>&gt; ### Marking multiple `@incoherent` types<br>&gt; <br>&gt; In places where one parameter to the `@incoherent` attribute is permitted, you can instead provide a comma-separated list to permit several different incoherences caused by the same declaration:<br>&gt; <br>&gt; 	@incoherent(T, U) extension P {...}<br>&gt; 	@incoherent(P, Q) extension T {...}<br>&gt; 	<br>&gt; 	@incoherent(T: P, U: Q) import B<br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; The requirement that `final` be applied to many protocol extension methods will cause many—perhaps most—protocol extensions to stop compiling without changes. However, the changes needed—adding a keyword to the declarations of relevant members—are fairly mechanical and are fix-it guided. The migrator should add them automatically.<br>&gt; <br>&gt; The conflict errors will cause a smaller number of conformance declarations, protocol extensions, or `import` statements to fail to compile. I believe that many of these cases will be bugs, and users will want to rename members to avoid them. When users do not want to rename, they can preserve the existing semantics with an `@incoherent` attribute.<br>&gt; <br>&gt; Because this is primarily a safety feature, does not change runtime semantics, and, in most codebases, all changes will be purely mechanical, I believe this feature should be added to the next minor version of Swift, rather than waiting for 3.0.<br>&gt; <br>&gt; ## Alternatives considered<br>&gt; <br>&gt; ### Dynamically dispatch calls to protocol extension members<br>&gt; <br>&gt; This would fix the underlying problem—the confusing behavior—by making protocol extension members not behave confusingly.<br>&gt; <br>&gt; This would likely take a redesign of protocol witnesses to include extension methods not listed in the original protocol. It&#39;s probably not impossible—class extensions behave this way—but it&#39;s a much bigger change than what I propose, which keeps the current runtime semantics and only adds compile-time errors and keywords.<br>&gt; <br>&gt; Dynamically dispatching to protocol extension members would also change the performance characteristics of these calls. Even if this change were made, we might want to allow users to apply `final` to extension methods which they want to be dispatched statically.<br>&gt; <br>&gt; ### Don&#39;t provide an `@incoherent` attribute<br>&gt; <br>&gt; This would improve safety by making this confusing construct completely impossible to write. However, it would also make it completely impossible to conform certain types to certain protocols or import certain combinations of modules into the same file. This seems especially unwise because previous versions of Swift have actually permitted this shadowing; code that previously compiled without even a warning could be difficult to port.<br>&gt; <br>&gt; ### Mark default members instead of statically dispatched members<br>&gt; <br>&gt; This would invert the keywording in a protocol extension: instead of marking the statically-dispatched members with `final`, you would mark the overridable members with `default`.<br>&gt; <br>&gt; I prefer `final` because it marks the more unusual case. Users are not surprised that they can override default methods; they are surprised that they *can&#39;t* reliably override protocol extension methods. Also, as mentioned in the previous section, I could see `final` being retained even if protocol extension methods gained dynamic dispatch.<br>&gt; <br>&gt; However, my preference is not terribly strong, and using `default` on the overridable methods is not a bad option.<br>&gt; <br>&gt; ### Require a `final` keyword, but don&#39;t prevent conflicts with an error<br>&gt; <br>&gt; The problem with this approach is that the conflict is the surprising part. It doesn&#39;t matter all that much whether protocol extension members are dispatched statically or dynamically *except* if there&#39;s a conflict; *then* you&#39;re getting into potential bug territory. The `@incoherent` keyword is what makes this mistake impossible to make accidentally; without it, this is merely a proposal to force people to annotate their protocol extensions more clearly.<br>&gt; <br>&gt; ### Don&#39;t require a `final` keyword, but prevent conflicts with an error<br>&gt; <br>&gt; Without the `final` keyword (or the `default` alternative mentioned above) on the extension members themselves, it&#39;s impossible to tell at a glance which members are overridable and which ones aren&#39;t. This makes predicting incoherent conformance errors an exercise in trial-and-error, or at least in visual-diffing two separate parts of the code to figure out what&#39;s going on. Without the `final` keyword, in other words, avoiding conflicts when you write your code instead of discovering them when you compile it is much more difficult.<br>&gt; <br>&gt; ### Mark specific conflicting members<br>&gt; <br>&gt; Rather than marking an entire conformance as permitted to allow conflicts, we could force users to mark specific conflicting members. For instance, in the `Turnable`/`SpimsterWicket` example used above, `turningRepeatedly(_:)` itself would have to be marked in some way.<br>&gt; <br>&gt; The main issue I see is that, in many cases, a conformance is added in a different file or even module than the conflicting declaration, so there&#39;s no convenient place to put the attribute. This is basically the same reason there&#39;s no equivalent of `override` for implementations of protocol methods.<br>&gt; <br>&gt; This would also require more declarations, but I don&#39;t necessarily think that would be a bad thing.<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft Proposal] Require `final` on protocol extension members</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  4, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Didn&#39;t we already have a very long discussion about all of this?<br></p><p>We did, which ended with you and I clearly in fundamental disagreement, while others appeared to think it was a good idea. I&#39;m now putting forth a more specific version of that proposal, one that I think is almost ready for review.<br></p><p>&gt; It&#39;s confusing, it&#39;s overloading the term `final` in a way that doesn&#39;t seem to make sense (`final` means you can&#39;t subclass or override, but there&#39;s nothing in this proposal that affects either subclassing _or_ method overriding)<br></p><p>`final` is currently restricted to the context of a class, yes. But I think it&#39;s a clean extension of the concept to use it to mark protocol extension methods that can&#39;t be overridden. Hence why I provide this re-definition of the meaning of `final`:<br></p><p>	`final` declares that subtypes of this type must use this specific implementation of the member, and cannot substitute their own specialized implementation. Attempting to do so causes an error.<br></p><p>(Technically it&#39;s true that no protocol extension member can be overridden. But the distinction between defaulted protocol members and protocol extension members is very subtle—they are both written in protocol extensions and look identical unless you go back to the protocol definition to check what&#39;s there—and I think it needs to be called out in the text of the code.)<br></p><p>&gt; and it means protocol extensions that you aren&#39;t even aware of from other modules can cause your otherwise-legal type to start throwing errors.<br></p><p><br>You can only get a conflict from something that&#39;s visible to your code. For instance, an `internal` protocol extension in another module can&#39;t cause a conflict—only public APIs can cause conflicts through imports. And it&#39;s important that they do, because it&#39;s hard to know that you didn&#39;t think the conflicting member was a defaulted protocol requirement you could override.<br></p><p>&gt; Making this kind of change only makes any sense at all if you assume that, every single time someone implements a method that happens to look the same as a method provided by a protocol extension, they&#39;re trying to override that protocol extension method. But since protocol extension methods cannot be overridden (merely shadowed), that assumption doesn&#39;t make a lot of sense.<br></p><p>I realize that this doesn&#39;t confuse you, but it seems to confuse everyone else. The core team seems to think so too, because they consider the lack of a warning about it to be a bug that can be fixed without going through the evolution process. (And I believe there&#39;s a thread currently in swift-dev where someone is working on that warning.)<br></p><p>&gt; and I think forcing people to brand their legitimate functions with a negative-sounding term &quot;incoherent&quot; is also basically subtly punishing people. I mean, who wants to write code that is publicly branded as being &quot;incoherent&quot; code?<br></p><p><br>&quot;Incoherent&quot; is a very opinionated keyword. But I think it&#39;s also a descriptive one, which captures in a single word why you may not want to use it. I&#39;m open to alternatives, including less judgmental alternatives.<br></p><p>&gt; Also, even after reading this proposal, it&#39;s still not obvious to me how the @incoherent attribute works. The rest is a little confusing, but this attribute is very confusing all by itself.<br></p><p>`@incoherent` basically says &quot;I know what I&#39;m doing, so don&#39;t emit errors about conflicts between these two types; just give me the Swift 2.1 behavior&quot;. I&#39;m not sure why you think the current behavior is not confusing, but `@incoherent`&#39;s behavior is very confusing.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Draft Proposal] Require `final` on protocol extension members</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January  5, 2016 at 11:00:00am</p></header><div class="content"><p>Since we’re moving this to a new thread, I’ll copy forward the design guidance that Chris Lattner gave us.<br></p><p>Chris wrote a wealth of far-ranging thoughts on Swift’s design philosophy. I wrote:<br></p><p>&gt; I’ll copy and paste what Chris wrote into a “Swift philosophy” checklist for Brent’s proposal, and for any others working toward these goals. Chris, please correct me if I’m putting words in your mouth!<br>&gt; Provide a programmer model that:<br>&gt; is high level<br>&gt; is expressive and clean<br>&gt; is dynamic by default<br>&gt; doesn’t require a programmer to think about the fact that a static compiler is able to transparently provide great performance<br>&gt; Provide a performance model that:<br>&gt; is predictable<br>&gt; makes the dynamic parts of the language optimizable by a static compiler in many common cases<br>&gt; does not requiring profiling or other dynamic information<br>&gt; does not require JIT compilation<br></p><p>And Chris wrote:<br></p><p>&gt; Yes, this is a good summary.<br></p><p>I think that guidance from Chris could help focus this discussion.<br></p><p>I’d also like to hear more thoughts on Kevin’s proposal from a broader range of people.<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br>&gt; On Jan 4, 2016, at 6:38 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Didn&#39;t we already have a very long discussion about all of this?<br>&gt; <br>&gt; We did, which ended with you and I clearly in fundamental disagreement, while others appeared to think it was a good idea. I&#39;m now putting forth a more specific version of that proposal, one that I think is almost ready for review.<br>&gt; <br>&gt;&gt; It&#39;s confusing, it&#39;s overloading the term `final` in a way that doesn&#39;t seem to make sense (`final` means you can&#39;t subclass or override, but there&#39;s nothing in this proposal that affects either subclassing _or_ method overriding)<br>&gt; <br>&gt; `final` is currently restricted to the context of a class, yes. But I think it&#39;s a clean extension of the concept to use it to mark protocol extension methods that can&#39;t be overridden. Hence why I provide this re-definition of the meaning of `final`:<br>&gt; <br>&gt; 	`final` declares that subtypes of this type must use this specific implementation of the member, and cannot substitute their own specialized implementation. Attempting to do so causes an error.<br>&gt; <br>&gt; (Technically it&#39;s true that no protocol extension member can be overridden. But the distinction between defaulted protocol members and protocol extension members is very subtle—they are both written in protocol extensions and look identical unless you go back to the protocol definition to check what&#39;s there—and I think it needs to be called out in the text of the code.)<br>&gt; <br>&gt;&gt; and it means protocol extensions that you aren&#39;t even aware of from other modules can cause your otherwise-legal type to start throwing errors.<br>&gt; <br>&gt; <br>&gt; You can only get a conflict from something that&#39;s visible to your code. For instance, an `internal` protocol extension in another module can&#39;t cause a conflict—only public APIs can cause conflicts through imports. And it&#39;s important that they do, because it&#39;s hard to know that you didn&#39;t think the conflicting member was a defaulted protocol requirement you could override.<br>&gt; <br>&gt;&gt; Making this kind of change only makes any sense at all if you assume that, every single time someone implements a method that happens to look the same as a method provided by a protocol extension, they&#39;re trying to override that protocol extension method. But since protocol extension methods cannot be overridden (merely shadowed), that assumption doesn&#39;t make a lot of sense.<br>&gt; <br>&gt; I realize that this doesn&#39;t confuse you, but it seems to confuse everyone else. The core team seems to think so too, because they consider the lack of a warning about it to be a bug that can be fixed without going through the evolution process. (And I believe there&#39;s a thread currently in swift-dev where someone is working on that warning.)<br>&gt; <br>&gt;&gt; and I think forcing people to brand their legitimate functions with a negative-sounding term &quot;incoherent&quot; is also basically subtly punishing people. I mean, who wants to write code that is publicly branded as being &quot;incoherent&quot; code?<br>&gt; <br>&gt; <br>&gt; &quot;Incoherent&quot; is a very opinionated keyword. But I think it&#39;s also a descriptive one, which captures in a single word why you may not want to use it. I&#39;m open to alternatives, including less judgmental alternatives.<br>&gt; <br>&gt;&gt; Also, even after reading this proposal, it&#39;s still not obvious to me how the @incoherent attribute works. The rest is a little confusing, but this attribute is very confusing all by itself.<br>&gt; <br>&gt; `@incoherent` basically says &quot;I know what I&#39;m doing, so don&#39;t emit errors about conflicts between these two types; just give me the Swift 2.1 behavior&quot;. I&#39;m not sure why you think the current behavior is not confusing, but `@incoherent`&#39;s behavior is very confusing.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/91bb00d6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fb5a6986048ff63d65b0f34fd1ecd1a9?s=50"></div><header><strong>[Draft Proposal] Require `final` on protocol extension members</strong> from <string>Paul Cantrell</string> &lt;paul at innig.net&gt;<p>January  5, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; I’d also like to hear more thoughts on Kevin’s proposal from a broader range of people.<br></p><p>Derp, I mean Brent’s proposal.<br></p><p>My brain is utterly unable to keep people’s names straight. Is there a clinical name for it? Because whatever it is, I’ve got it baaad.<br></p><p>Brent and Kevin, apologies!<br></p><p>P<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Draft Proposal] Require `final` on protocol extension members</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>January  5, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; doesn’t require a programmer to think about the fact that a static compiler is able to transparently provide great performance<br></p><p>Should not this be a guidance to either make sure you cannot override default methods in protocol extensions or that you should use dynamic dispatching unless the protocol extension default implementation has surely not been overridden?<br></p><p>Sent from my iPhone<br></p><p>&gt; On 5 Jan 2016, at 17:15, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Since we’re moving this to a new thread, I’ll copy forward the design guidance that Chris Lattner gave us.<br>&gt; <br>&gt; Chris wrote a wealth of far-ranging thoughts on Swift’s design philosophy. I wrote:<br>&gt; <br>&gt;&gt; I’ll copy and paste what Chris wrote into a “Swift philosophy” checklist for Brent’s proposal, and for any others working toward these goals. Chris, please correct me if I’m putting words in your mouth!<br>&gt;&gt; Provide a programmer model that:<br>&gt;&gt; is high level<br>&gt;&gt; is expressive and clean<br>&gt;&gt; is dynamic by default<br>&gt;&gt; doesn’t require a programmer to think about the fact that a static compiler is able to transparently provide great performance<br>&gt;&gt; Provide a performance model that:<br>&gt;&gt; is predictable<br>&gt;&gt; makes the dynamic parts of the language optimizable by a static compiler in many common cases<br>&gt;&gt; does not requiring profiling or other dynamic information<br>&gt;&gt; does not require JIT compilation<br>&gt; <br>&gt; And Chris wrote:<br>&gt; <br>&gt;&gt; Yes, this is a good summary.<br>&gt; <br>&gt; I think that guidance from Chris could help focus this discussion.<br>&gt; <br>&gt; I’d also like to hear more thoughts on Kevin’s proposal from a broader range of people.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jan 4, 2016, at 6:38 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Didn&#39;t we already have a very long discussion about all of this?<br>&gt;&gt; <br>&gt;&gt; We did, which ended with you and I clearly in fundamental disagreement, while others appeared to think it was a good idea. I&#39;m now putting forth a more specific version of that proposal, one that I think is almost ready for review.<br>&gt;&gt; <br>&gt;&gt;&gt; It&#39;s confusing, it&#39;s overloading the term `final` in a way that doesn&#39;t seem to make sense (`final` means you can&#39;t subclass or override, but there&#39;s nothing in this proposal that affects either subclassing _or_ method overriding)<br>&gt;&gt; <br>&gt;&gt; `final` is currently restricted to the context of a class, yes. But I think it&#39;s a clean extension of the concept to use it to mark protocol extension methods that can&#39;t be overridden. Hence why I provide this re-definition of the meaning of `final`:<br>&gt;&gt; <br>&gt;&gt; 	`final` declares that subtypes of this type must use this specific implementation of the member, and cannot substitute their own specialized implementation. Attempting to do so causes an error.<br>&gt;&gt; <br>&gt;&gt; (Technically it&#39;s true that no protocol extension member can be overridden. But the distinction between defaulted protocol members and protocol extension members is very subtle—they are both written in protocol extensions and look identical unless you go back to the protocol definition to check what&#39;s there—and I think it needs to be called out in the text of the code.)<br>&gt;&gt; <br>&gt;&gt;&gt; and it means protocol extensions that you aren&#39;t even aware of from other modules can cause your otherwise-legal type to start throwing errors.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; You can only get a conflict from something that&#39;s visible to your code. For instance, an `internal` protocol extension in another module can&#39;t cause a conflict—only public APIs can cause conflicts through imports. And it&#39;s important that they do, because it&#39;s hard to know that you didn&#39;t think the conflicting member was a defaulted protocol requirement you could override.<br>&gt;&gt; <br>&gt;&gt;&gt; Making this kind of change only makes any sense at all if you assume that, every single time someone implements a method that happens to look the same as a method provided by a protocol extension, they&#39;re trying to override that protocol extension method. But since protocol extension methods cannot be overridden (merely shadowed), that assumption doesn&#39;t make a lot of sense.<br>&gt;&gt; <br>&gt;&gt; I realize that this doesn&#39;t confuse you, but it seems to confuse everyone else. The core team seems to think so too, because they consider the lack of a warning about it to be a bug that can be fixed without going through the evolution process. (And I believe there&#39;s a thread currently in swift-dev where someone is working on that warning.)<br>&gt;&gt; <br>&gt;&gt;&gt; and I think forcing people to brand their legitimate functions with a negative-sounding term &quot;incoherent&quot; is also basically subtly punishing people. I mean, who wants to write code that is publicly branded as being &quot;incoherent&quot; code?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &quot;Incoherent&quot; is a very opinionated keyword. But I think it&#39;s also a descriptive one, which captures in a single word why you may not want to use it. I&#39;m open to alternatives, including less judgmental alternatives.<br>&gt;&gt; <br>&gt;&gt;&gt; Also, even after reading this proposal, it&#39;s still not obvious to me how the @incoherent attribute works. The rest is a little confusing, but this attribute is very confusing all by itself.<br>&gt;&gt; <br>&gt;&gt; `@incoherent` basically says &quot;I know what I&#39;m doing, so don&#39;t emit errors about conflicts between these two types; just give me the Swift 2.1 behavior&quot;. I&#39;m not sure why you think the current behavior is not confusing, but `@incoherent`&#39;s behavior is very confusing.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/f8d75512/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
