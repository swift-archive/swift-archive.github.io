<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  3, 2016 at 08:00:00am</p></header><div class="content"><p>on Tue Mar 01 2016, Károly Lőrentey &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This looks interesting! As the author of a number of custom collection<br>&gt; implementations, including a rather elaborate B-tree package<br>&gt; (https://github.com/lorentey/BTree), <br></p><p>FWIW, I am impressed by (even jealous of) this work, so your feedback in<br>this area is much appreciated.<br></p><p>&gt; it always felt strange to me that indices are expected to be able to<br>&gt; move around the collection on their own, while element access has to<br>&gt; go through by the collection. It is a great idea to fix this<br>&gt; asymmetry.<br>&gt;<br>&gt; I’ll have to carefully read through it a couple more times and look at<br>&gt; the prototype branch to form a real opinion, but at first glance I<br>&gt; like the proposal. Here are a couple of quick thoughts, with more to<br>&gt; come once I had time to think about the implications in detail:<br>&gt;<br>&gt; - I’m not at a great fan of the `*IndexType` protocols in Swift 2. I<br>&gt;   do not believe they work hard enough compared to how hard it is to<br>&gt;   implement them, and I welcome any change that makes them even a <br>&gt;   little bit simpler for the collection writer.<br>&gt;<br>&gt; - Having to call a collection method to increment an index looks<br>&gt;   unnatural at first glance, but I can see myself getting used to it<br>&gt;   in a few hours.<br></p><p>One thing that hasn&#39;t been mentioned so far is that when the algorithms<br>using indices are extensions on the collection protocol (or members of a<br>specific collection) these APIs can be used without qualification, which<br>makes them read like free functions, which ends up looking quite natural<br>to my eye.<br></p><p>&gt; - I know that it isn&#39;t a new requirement, but I do dislike that<br>&gt;   `Indexable` specifies the complexity of index operations; this puts<br>&gt;   a hard constraint on custom collection design. I do understand the<br>&gt;   desire for concrete complexity promises on operations using<br>&gt;   indexes, but can&#39;t we express these instead e.g. in terms of number<br>&gt;   of index accesses?<br></p><p>The problem is that eventually it becomes really difficult to simply<br>describe the efficiency of any given algorithm.  We don&#39;t want people to<br>have to do complex algebra to understand how algorithms compose with<br>data structures.<br></p><p>Yes, it&#39;s a trade-off, and loosening the upper bound on the cost of<br>indexing was one of the things we considered.  We tried to carefully<br>think through different possible collection designs (trees in<br>particular!) to understand what the implications of keeping the O(1)<br>upper bound were.  We&#39;d be happy to discuss specific tradeoffs with you.<br></p><p>&gt; - I love that there is a section with detailed guidance on designing <br>&gt;   tree-based collections. It’s interesting and informative.<br>&gt;<br>&gt; - My B-trees are persistent data structures, thus my nodes cannot have<br>&gt;   parent or sibling links. Index lookup and navigation is still O(1)<br>&gt;   though, as my indices contain pointers to every node on the path to<br>&gt;   the current element. Since I have to keep looking up these nodes<br>&gt;   anyway to retrieve elements and to navigate around in the tree, I<br>&gt;   simply decided to keep them directly in the index. B-trees are super<br>&gt;   shallow, so there are only a handful of nodes on any path.<br></p><p>Yeah, one other way to get O(1) here is to consider that log N is<br>bounded by a small constant, for practical purposes.<br></p><p>&gt; - I found that the most straightforward place to implement tree<br>&gt;   navigation methods like `next(:)` and `advance(:by:)` is on the path<br>&gt;   struct that contains the actual node references. There is no reason<br>&gt;   I couldn&#39;t have the new collection methods simply call through to<br>&gt;   these path methods, though -- I am currently doing the same thing in<br>&gt;   the BTreeIndex type anyway.<br>&gt;<br>&gt; - I&#39;m using weak references inside the index, with a (seriously<br>&gt;   underdeveloped) index invalidation method that happens to be closer<br>&gt;   to #2b than #2a. I&#39;m not happy about using weak references, but this<br>&gt;   seemed the most sensible thing to do. I&#39;d love to replace them with<br>&gt;   `unowned(unsafe)`, and the mutation counter seems like a great idea.<br>&gt;   The ARC issue mentioned at the end of the proposal is rather scary,<br>&gt;   though -- I don&#39;t know how I would protect against that.<br></p><p>Hmm, Dmitri, I thought we decided that using unowned(unsafe) to manage<br>the &quot;indices&quot; collection was simply untenable.  Remember the<br>thread-safety issue, iterating indices on one thread while mutating the<br>collection on another?<br></p><p>&gt;   Generators/iterators look to be safe from this issue,<br>&gt;   so I’ll probably optimize their path representation first. <br>&gt;<br>&gt; - For mutation, I think custom APIs often make much more sense<br>&gt;   than general-purpose solutions. I try to discourage use of the normal<br>&gt;   B-tree index for doing complex tree mutations, and I instead provide <br>&gt;   a cursor construct that was designed especially for performing <br>&gt;   a batch of mutations in a batch:<br>&gt;<br>&gt;   https://github.com/lorentey/BTree/blob/master/Sources/BTreeCursor.swift#L295-L707 <br>&gt;<br>&gt;   The cursor is like an index on steroids. It has an identity with<br>&gt;   mutable state on its own, and it takes unique ownership of the tree<br>&gt;   while it is active. This frees the cursor to disable some costly<br>&gt;   invariants (such as maintaining up-to-date descendant counts in each<br>&gt;   node). This in turn allows for convenient batch editing of elements<br>&gt;   in the tree, with amortized O(1) insertion and removal operations.<br>&gt;<br>&gt;   The cursor&#39;s approach goes the exact opposite way of this proposal:<br>&gt;   not only is the collection not necessary to use the cursor, but the<br>&gt;   collection&#39;s value isn&#39;t even available while there is an active<br>&gt;   cursor on it. (This is like how<br>&gt;   `Array.withUnsafeMutableBufferPointer()` works.)<br>&gt;<br>&gt; - I&#39;m almost positive this has been discussed before, but what is the<br>&gt;   rationale behind allowing non-Int `IndexDistance`s? <br></p><p>One could imagine indexing a file-backed thing on a 32-bit platform,<br>which could require 64-bit distances.<br></p><p>&gt;   The distance is getting cast to Int in a lot of places anyway (IIRC,<br>&gt;   even the stdlib uses numericCasts to cut a way through it.)<br></p><p>We&#39;ve tried to be careful enough in balancing ease-of-use (Int<br>almost everywhere) with flexibility, but we might have made mistakes,<br>for sure.<br></p><p>&gt;     associatedtype IndexDistance : SignedIntegerType = Int<br></p><p>&gt; - The `Indices` associated type is intriguing. I assume it is brand new?<br>&gt;   It seems strange that it is allowed to hold a strong reference, but<br>&gt;   I’ll have to look through the prototype code to grok it.<br>&gt;<br>&gt;   Superficial comment: I’m not too happy with the name. The irregular<br>&gt;   plural is hard on non-native English speakers, plus it seems weird<br>&gt;   to have both an `Index` and an `Indices` type. The `indices` property<br>&gt;   calls it `IndexRange` (I assume by accident); I think I like that <br>&gt;   name better.<br>&gt;<br>&gt; - In this declaration:<br>&gt;<br>&gt;     subscript(position: Index) -&gt; Generator.Element { get }<br>&gt;<br>&gt;   I find the argument name rather unfortunate, because I&#39;ve been using<br>&gt;   the term &quot;position&quot; to consistently refer to the (numerical)<br>&gt;   position of an element in an ordered collection, <br></p><p>“Offset” would be a better name for that, IMO.<br></p><p>&gt;   which is typically not the same as the element&#39;s index. Could we<br>&gt;   just quietly rename this to `index` or `i`? :-)<br>&gt;<br>&gt;<br>&gt;&gt; On 2016-03-02, at 03:04, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; We would like to propose a major change to how collection indices<br>&gt;&gt; work.  The standard library team has discussed this idea internally<br>&gt;&gt; and we wrote a prototype.  Now we think it is a viable direction to<br>&gt;&gt; consider, and we are bringing it for wider public discussion.<br>&gt;&gt; <br>&gt;&gt; I&#39;m pasting the first section of the proposal below to give you a<br>&gt;&gt; general idea about this change, but please read the proposal to<br>&gt;&gt; understand the full details.<br>&gt;&gt; <br>&gt;&gt; You can find the most up to date version of the proposal at<br>&gt;&gt; https://github.com/gribozavr/swift-evolution/blob/new-collections/proposals/NNNN-collections-move-indices.md<br>&gt;&gt; <br>&gt;&gt; Permalink:<br>&gt;&gt; https://github.com/gribozavr/swift-evolution/blob/87df19a9a9d73e64a2a966b807440216a608b8ad/proposals/NNNN-collections-move-indices.md<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; We are proposing a new model for collections, where indices can only be<br>&gt;&gt; advanced forward or backward by the corresponding collection instance.<br>&gt;&gt; Indices become opaque tokens representing collection positions, that can<br>&gt;&gt; be produced and consumed by collection APIs.  This allows us to reduce<br>&gt;&gt; the amount of data stored in indices to the bare minimum.<br>&gt;&gt; <br>&gt;&gt; Compared to the current state, the new scheme simplifies implementation<br>&gt;&gt; of non-trivial indices, and fixes concurrency issues in `Set` and<br>&gt;&gt; `Dictionary` indices.  It also allows us to eliminate reference-counted<br>&gt;&gt; stored properties from most indices, including non-trivial ones, like<br>&gt;&gt; `Set.Index` and `Dictionary.Index`, creating more optimizable code.<br>&gt;&gt; <br>&gt;&gt; Out of scope for this proposal:<br>&gt;&gt; <br>&gt;&gt; * Expanding the set of concrete collections provided by the standard<br>&gt;&gt;  library.<br>&gt;&gt; <br>&gt;&gt; * Expanding the set of collection protocols to provide functionality<br>&gt;&gt;  beyond what is already provided (for example, protocols for sorted<br>&gt;&gt;  collections, queues etc.)  Discussing how other concrete collections<br>&gt;&gt;  fit into the current protocol hierarchy is in scope, though.<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
