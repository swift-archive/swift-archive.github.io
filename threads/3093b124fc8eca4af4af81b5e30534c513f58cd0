<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Swift4][Pitch] Control struct layout with @layout, @offset, @order</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>August 17, 2016 at 11:00:00am</p></header><div class="content"><p>I wanted to gauge the interest in supporting explicit struct layout and alignment.<br></p><p>The general idea would be to support attributes to create packed structs and set alignment. It will be critical for certain kinds of interop and systems programming in pure Swift. I don’t know about you but I want to write a kernel module in Swift someday :) I’m bringing it up because it probably affects ABI stability and resilience and so meets the requirements for Swift 4 phase 1.<br></p><p>Hopefully this could be a jumping-off point for further discussion. If the core team doesn’t think this affects ABI stability then we can postpone discussing it until Swift 4 phase 1 wraps up.<br></p><p><br>@layout(style: auto, alignment: natural)<br></p><p>enum LayoutStyle {<br>    /// Compiler is free to order the fields as it likes<br>    case automatic<br>    /// Places a struct&#39;s members in source order<br>    case sequential<br>    /// Requires each member to have an @order attribute<br>    case ordered<br>    /// Requires each member to have an @offset attribute<br>    case explicit<br>}<br></p><p>Only structs with certain @layout attributes would be exportable to non-Swift languages (assuming such support is added at some point). A struct defined with ordered or explicit layout and as resilient could possibly avoid indirect access to members since the ABI contract guarantees the location of each member.<br></p><p><br>enum Alignment {<br>    /// Compiler decides<br>    case natural<br>    /// Align as if the natural alignment were specified bytes<br>    case bytes(Int)<br>}<br></p><p><br></p><p>@order(&lt;int&gt;)<br></p><p>Specifies the order of the member in memory. Order must start at zero and increase monotonically without gaps. This makes accidental changes to the ordering errors.<br></p><p><br></p><p>@offset(&lt;int&gt;)<br></p><p>Specifies the offset from the start of the struct where this member should be placed. The size of the struct becomes the highest offset plus the size of the member with that offset.<br></p><p>It is an open question whether overlapping alignment should be allowed. If it is allowed I’d propose that for any set of members overlapping all of the members must be entirely contained within the largest overlapping member (I’m thinking of C-style unions when the struct format is imposed by something outside your control).<br></p><p><br></p><p>Thoughts?<br></p><p>Russ<br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/30938cd0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e26a5e7b70e927186f7e556d59c50ad5?s=50"></div><header><strong>[Swift4][Pitch] Control struct layout with @layout, @offset, @order</strong> from <string>Mark Lacey</string> &lt;mark_lacey at apple.com&gt;<p>August 17, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Aug 17, 2016, at 11:28 AM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I wanted to gauge the interest in supporting explicit struct layout and alignment.<br>&gt; <br>&gt; The general idea would be to support attributes to create packed structs and set alignment. It will be critical for certain kinds of interop and systems programming in pure Swift. I don’t know about you but I want to write a kernel module in Swift someday :) I’m bringing it up because it probably affects ABI stability and resilience and so meets the requirements for Swift 4 phase 1.<br></p><p>Explicit layout matters for the ABI once the feature exists, but it seems purely additive, i.e. out of scope for Swift 4 phase 1. You can ship without any explicit layout support and add it later without impacting code that ships before the feature exists.<br></p><p>Mark<br></p><p>&gt; <br>&gt; Hopefully this could be a jumping-off point for further discussion. If the core team doesn’t think this affects ABI stability then we can postpone discussing it until Swift 4 phase 1 wraps up.<br>&gt; <br>&gt; <br>&gt; @layout(style: auto, alignment: natural)<br>&gt; <br>&gt; enum LayoutStyle {<br>&gt;     /// Compiler is free to order the fields as it likes<br>&gt;     case automatic<br>&gt;     /// Places a struct&#39;s members in source order<br>&gt;     case sequential<br>&gt;     /// Requires each member to have an @order attribute<br>&gt;     case ordered<br>&gt;     /// Requires each member to have an @offset attribute<br>&gt;     case explicit<br>&gt; }<br>&gt; <br>&gt; Only structs with certain @layout attributes would be exportable to non-Swift languages (assuming such support is added at some point). A struct defined with ordered or explicit layout and as resilient could possibly avoid indirect access to members since the ABI contract guarantees the location of each member.<br>&gt; <br>&gt; <br>&gt; enum Alignment {<br>&gt;     /// Compiler decides<br>&gt;     case natural<br>&gt;     /// Align as if the natural alignment were specified bytes<br>&gt;     case bytes(Int)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; @order(&lt;int&gt;)<br>&gt; <br>&gt; Specifies the order of the member in memory. Order must start at zero and increase monotonically without gaps. This makes accidental changes to the ordering errors.<br>&gt; <br>&gt; <br>&gt; <br>&gt; @offset(&lt;int&gt;)<br>&gt; <br>&gt; Specifies the offset from the start of the struct where this member should be placed. The size of the struct becomes the highest offset plus the size of the member with that offset.<br>&gt; <br>&gt; It is an open question whether overlapping alignment should be allowed. If it is allowed I’d propose that for any set of members overlapping all of the members must be entirely contained within the largest overlapping member (I’m thinking of C-style unions when the struct format is imposed by something outside your control).<br>&gt; <br>&gt; <br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; Russ<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/82afc6a8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Swift4][Pitch] Control struct layout with @layout, @offset, @order</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>August 17, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Aug 17, 2016, at 11:37 AM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 17, 2016, at 11:28 AM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I wanted to gauge the interest in supporting explicit struct layout and alignment.<br>&gt;&gt; <br>&gt;&gt; The general idea would be to support attributes to create packed structs and set alignment. It will be critical for certain kinds of interop and systems programming in pure Swift. I don’t know about you but I want to write a kernel module in Swift someday :) I’m bringing it up because it probably affects ABI stability and resilience and so meets the requirements for Swift 4 phase 1.<br>&gt; <br>&gt; Explicit layout matters for the ABI once the feature exists, but it seems purely additive, i.e. out of scope for Swift 4 phase 1. You can ship without any explicit layout support and add it later without impacting code that ships before the feature exists.<br></p><p>Agreed.  This is something that we’d like Swift to support someday, but it isn’t on the critical path, and it would be a distraction to dive deep on it right now.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/08f88851/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Swift4][Pitch] Control struct layout with @layout, @offset, @order</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 17, 2016 at 01:00:00pm</p></header><div class="content"><p>Hi Russ,<br></p><p>Keep in mind you can control layout of structs by defining them in C (using __attribute__((packed)) and so on), and using them as imported types in Swift.<br></p><p>As Mark mentioned, we can add this later if we need it, so it’s probably out of scope for now.<br></p><p>Slava<br></p><p>&gt; On Aug 17, 2016, at 11:28 AM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I wanted to gauge the interest in supporting explicit struct layout and alignment.<br>&gt; <br>&gt; The general idea would be to support attributes to create packed structs and set alignment. It will be critical for certain kinds of interop and systems programming in pure Swift. I don’t know about you but I want to write a kernel module in Swift someday :) I’m bringing it up because it probably affects ABI stability and resilience and so meets the requirements for Swift 4 phase 1.<br>&gt; <br>&gt; Hopefully this could be a jumping-off point for further discussion. If the core team doesn’t think this affects ABI stability then we can postpone discussing it until Swift 4 phase 1 wraps up.<br>&gt; <br>&gt; <br>&gt; @layout(style: auto, alignment: natural)<br>&gt; <br>&gt; enum LayoutStyle {<br>&gt;     /// Compiler is free to order the fields as it likes<br>&gt;     case automatic<br>&gt;     /// Places a struct&#39;s members in source order<br>&gt;     case sequential<br>&gt;     /// Requires each member to have an @order attribute<br>&gt;     case ordered<br>&gt;     /// Requires each member to have an @offset attribute<br>&gt;     case explicit<br>&gt; }<br>&gt; <br>&gt; Only structs with certain @layout attributes would be exportable to non-Swift languages (assuming such support is added at some point). A struct defined with ordered or explicit layout and as resilient could possibly avoid indirect access to members since the ABI contract guarantees the location of each member.<br>&gt; <br>&gt; <br>&gt; enum Alignment {<br>&gt;     /// Compiler decides<br>&gt;     case natural<br>&gt;     /// Align as if the natural alignment were specified bytes<br>&gt;     case bytes(Int)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; @order(&lt;int&gt;)<br>&gt; <br>&gt; Specifies the order of the member in memory. Order must start at zero and increase monotonically without gaps. This makes accidental changes to the ordering errors.<br>&gt; <br>&gt; <br>&gt; <br>&gt; @offset(&lt;int&gt;)<br>&gt; <br>&gt; Specifies the offset from the start of the struct where this member should be placed. The size of the struct becomes the highest offset plus the size of the member with that offset.<br>&gt; <br>&gt; It is an open question whether overlapping alignment should be allowed. If it is allowed I’d propose that for any set of members overlapping all of the members must be entirely contained within the largest overlapping member (I’m thinking of C-style unions when the struct format is imposed by something outside your control).<br>&gt; <br>&gt; <br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; Russ<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/627b3692/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Swift4][Pitch] Control struct layout with @layout, @offset, @order</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>August 19, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Aug 17, 2016, at 11:28 AM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I wanted to gauge the interest in supporting explicit struct layout and alignment.<br>&gt; <br>&gt; The general idea would be to support attributes to create packed structs and set alignment. It will be critical for certain kinds of interop and systems programming in pure Swift. I don’t know about you but I want to write a kernel module in Swift someday :) I’m bringing it up because it probably affects ABI stability and resilience and so meets the requirements for Swift 4 phase 1.<br>&gt; <br>&gt; Hopefully this could be a jumping-off point for further discussion. If the core team doesn’t think this affects ABI stability then we can postpone discussing it until Swift 4 phase 1 wraps up.<br>&gt; <br>&gt; <br>&gt; @layout(style: auto, alignment: natural)<br>&gt; <br>&gt; enum LayoutStyle {<br>&gt;     /// Compiler is free to order the fields as it likes<br>&gt;     case automatic<br>&gt;     /// Places a struct&#39;s members in source order<br>&gt;     case sequential<br>&gt;     /// Requires each member to have an @order attribute<br>&gt;     case ordered<br>&gt;     /// Requires each member to have an @offset attribute<br>&gt;     case explicit<br>&gt; }<br>&gt; <br>&gt; Only structs with certain @layout attributes would be exportable to non-Swift languages (assuming such support is added at some point). A struct defined with ordered or explicit layout and as resilient could possibly avoid indirect access to members since the ABI contract guarantees the location of each member.<br>&gt; <br>&gt; <br>&gt; enum Alignment {<br>&gt;     /// Compiler decides<br>&gt;     case natural<br>&gt;     /// Align as if the natural alignment were specified bytes<br>&gt;     case bytes(Int)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; @order(&lt;int&gt;)<br>&gt; <br>&gt; Specifies the order of the member in memory. Order must start at zero and increase monotonically without gaps. This makes accidental changes to the ordering errors.<br>&gt; <br>&gt; <br>&gt; <br>&gt; @offset(&lt;int&gt;)<br>&gt; <br>&gt; Specifies the offset from the start of the struct where this member should be placed. The size of the struct becomes the highest offset plus the size of the member with that offset.<br>&gt; <br>&gt; It is an open question whether overlapping alignment should be allowed. If it is allowed I’d propose that for any set of members overlapping all of the members must be entirely contained within the largest overlapping member (I’m thinking of C-style unions when the struct format is imposed by something outside your control).<br>&gt; <br>&gt; <br>&gt; <br>&gt; Thoughts?<br></p><p>Property behaviors could conceivably get you at least some of the way here. You could do something like this:<br></p><p>protocol ManualLayout {<br>  associatedtype Storage<br>  var storage: Storage<br>}<br></p><p>struct Foo: ManualLayout {<br>  var storage: [4 x Int32] // give me 16 bytes of 32-bit-aligned storage<br></p><p>  var [offset(0)] foo: Int32<br>  var [offset(5)] bar: Int32<br>  var [offset(10)] bas: Int32<br>}<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Swift4][Pitch] Control struct layout with @layout, @offset, @order</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>August 22, 2016 at 12:00:00pm</p></header><div class="content"><p>No problem, I&#39;ll put it on the back burner for the time being. <br></p><p>Russ<br></p><p>&gt; On Aug 19, 2016, at 12:50 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 17, 2016, at 11:28 AM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I wanted to gauge the interest in supporting explicit struct layout and alignment.<br>&gt;&gt; <br>&gt;&gt; The general idea would be to support attributes to create packed structs and set alignment. It will be critical for certain kinds of interop and systems programming in pure Swift. I don’t know about you but I want to write a kernel module in Swift someday :) I’m bringing it up because it probably affects ABI stability and resilience and so meets the requirements for Swift 4 phase 1.<br>&gt;&gt; <br>&gt;&gt; Hopefully this could be a jumping-off point for further discussion. If the core team doesn’t think this affects ABI stability then we can postpone discussing it until Swift 4 phase 1 wraps up.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; @layout(style: auto, alignment: natural)<br>&gt;&gt; <br>&gt;&gt; enum LayoutStyle {<br>&gt;&gt;    /// Compiler is free to order the fields as it likes<br>&gt;&gt;    case automatic<br>&gt;&gt;    /// Places a struct&#39;s members in source order<br>&gt;&gt;    case sequential<br>&gt;&gt;    /// Requires each member to have an @order attribute<br>&gt;&gt;    case ordered<br>&gt;&gt;    /// Requires each member to have an @offset attribute<br>&gt;&gt;    case explicit<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Only structs with certain @layout attributes would be exportable to non-Swift languages (assuming such support is added at some point). A struct defined with ordered or explicit layout and as resilient could possibly avoid indirect access to members since the ABI contract guarantees the location of each member.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; enum Alignment {<br>&gt;&gt;    /// Compiler decides<br>&gt;&gt;    case natural<br>&gt;&gt;    /// Align as if the natural alignment were specified bytes<br>&gt;&gt;    case bytes(Int)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; @order(&lt;int&gt;)<br>&gt;&gt; <br>&gt;&gt; Specifies the order of the member in memory. Order must start at zero and increase monotonically without gaps. This makes accidental changes to the ordering errors.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; @offset(&lt;int&gt;)<br>&gt;&gt; <br>&gt;&gt; Specifies the offset from the start of the struct where this member should be placed. The size of the struct becomes the highest offset plus the size of the member with that offset.<br>&gt;&gt; <br>&gt;&gt; It is an open question whether overlapping alignment should be allowed. If it is allowed I’d propose that for any set of members overlapping all of the members must be entirely contained within the largest overlapping member (I’m thinking of C-style unions when the struct format is imposed by something outside your control).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt; <br>&gt; Property behaviors could conceivably get you at least some of the way here. You could do something like this:<br>&gt; <br>&gt; protocol ManualLayout {<br>&gt;  associatedtype Storage<br>&gt;  var storage: Storage<br>&gt; }<br>&gt; <br>&gt; struct Foo: ManualLayout {<br>&gt;  var storage: [4 x Int32] // give me 16 bytes of 32-bit-aligned storage<br>&gt; <br>&gt;  var [offset(0)] foo: Int32<br>&gt;  var [offset(5)] bar: Int32<br>&gt;  var [offset(10)] bas: Int32<br>&gt; }<br>&gt; <br>&gt; -Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160822/654488ce/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
