<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>Relative Pointers and Windows ARM</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>May 18, 2016 at 01:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>It seems that there are assumptions about the ability to create relative<br>address across sections which doesn&#39;t seem possible on Windows ARM.<br></p><p>Consider the following swift code:<br></p><p>final class _ContiguousArrayStorage&lt;Element&gt; { }<br></p><p>When compiled for Windows x86 (via swiftc -c -target i686-windows<br>-parse-as-library -parse-stdlib -module-name Swift -o Swift.obj<br>reduced.swift) it will generate the metadata pattern as:<br></p><p>    __TMPCs23_ContiguousArrayStorage:<br>      ...<br>      .long<br>__TMnCs23_ContiguousArrayStorage-(__MPCs23_ContiguousArrayStorage+128)<br>      ...<br></p><p>This generates a IMAGE_REL_I386_REL32 relocation which is the 32-bit<br>relative displacement of the target.<br></p><p>On Windows ARM (swiftc -c -target i686-windows -parse-pas-library<br>-parse-stdlib -module-name Swift -o Swift.obj reduced.swift) it will<br>generate similar assembly:<br></p><p>    _TMPCs23_ContiguousArrayStorage:<br>      ...<br>      .long<br>_TMnCs23_ContiguousArrayStorage-(_MPCs23_ContiguousArrayStorage+128)<br>      ...<br></p><p>However, this generates an IMAGE_REL_ARM_ADDR32 relocation which is the<br>32-bit VA of the target.  If the symbol are in the same section, it is<br>possible to get a relative value.  However, I don&#39;t really see a way to<br>generate a relative offset across sections.  There is no relocation in the<br>COFF ARM specification which provides the 32-bit relative displacement of<br>the target.  There are 20, 23, and 24 bit relative displacements designed<br>specifically for branch instructions, but none that would operate on<br>generic data.<br></p><p>Is there a good way to address this ABI issue?  Or perhaps do we need<br>something more invasive to support such targets?  Now, I might be<br>completely overlooking something simple that I didn&#39;t consider, so pointing<br>that out would be greatly appreciated as well.<br></p><p>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160518/8c209ca2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Relative Pointers and Windows ARM</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 1:51 PM, Saleem Abdulrasool via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; It seems that there are assumptions about the ability to create relative address across sections which doesn&#39;t seem possible on Windows ARM.<br>&gt; <br>&gt; Consider the following swift code:<br>&gt; <br>&gt; final class _ContiguousArrayStorage&lt;Element&gt; { }<br>&gt; <br>&gt; When compiled for Windows x86 (via swiftc -c -target i686-windows -parse-as-library -parse-stdlib -module-name Swift -o Swift.obj reduced.swift) it will generate the metadata pattern as:<br>&gt; <br>&gt;     __TMPCs23_ContiguousArrayStorage:<br>&gt;       ...<br>&gt;       .long __TMnCs23_ContiguousArrayStorage-(__MPCs23_ContiguousArrayStorage+128)<br>&gt;       ...<br>&gt; <br>&gt; This generates a IMAGE_REL_I386_REL32 relocation which is the 32-bit relative displacement of the target.<br>&gt; <br>&gt; On Windows ARM (swiftc -c -target i686-windows -parse-pas-library -parse-stdlib -module-name Swift -o Swift.obj reduced.swift) it will generate similar assembly:<br>&gt; <br>&gt;     _TMPCs23_ContiguousArrayStorage:<br>&gt;       ...<br>&gt;       .long _TMnCs23_ContiguousArrayStorage-(_MPCs23_ContiguousArrayStorage+128)<br>&gt;       ...<br>&gt; <br>&gt; However, this generates an IMAGE_REL_ARM_ADDR32 relocation which is the 32-bit VA of the target.  If the symbol are in the same section, it is possible to get a relative value.  However, I don&#39;t really see a way to generate a relative offset across sections.  There is no relocation in the COFF ARM specification which provides the 32-bit relative displacement of the target.  There are 20, 23, and 24 bit relative displacements designed specifically for branch instructions, but none that would operate on generic data.<br>&gt; <br>&gt; Is there a good way to address this ABI issue?  Or perhaps do we need something more invasive to support such targets?  Now, I might be completely overlooking something simple that I didn&#39;t consider, so pointing that out would be greatly appreciated as well.<br></p><p>That&#39;s unfortunate. One possibly-crazy solution would be to use a different object format that does support the necessary relocations, such as LLVM&#39;s win32-macho target. That would forgo interoperability with non-LLVM toolchains, of course. <br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>Relative Pointers and Windows ARM</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>May 18, 2016 at 06:00:00pm</p></header><div class="content"><p>On Wednesday, May 18, 2016, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On May 18, 2016, at 1:51 PM, Saleem Abdulrasool via swift-dev &lt;<br>&gt; swift-dev at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; It seems that there are assumptions about the ability to create relative<br>&gt; address across sections which doesn&#39;t seem possible on Windows ARM.<br>&gt; &gt;<br>&gt; &gt; Consider the following swift code:<br>&gt; &gt;<br>&gt; &gt; final class _ContiguousArrayStorage&lt;Element&gt; { }<br>&gt; &gt;<br>&gt; &gt; When compiled for Windows x86 (via swiftc -c -target i686-windows<br>&gt; -parse-as-library -parse-stdlib -module-name Swift -o Swift.obj<br>&gt; reduced.swift) it will generate the metadata pattern as:<br>&gt; &gt;<br>&gt; &gt;     __TMPCs23_ContiguousArrayStorage:<br>&gt; &gt;       ...<br>&gt; &gt;       .long<br>&gt; __TMnCs23_ContiguousArrayStorage-(__MPCs23_ContiguousArrayStorage+128)<br>&gt; &gt;       ...<br>&gt; &gt;<br>&gt; &gt; This generates a IMAGE_REL_I386_REL32 relocation which is the 32-bit<br>&gt; relative displacement of the target.<br>&gt; &gt;<br>&gt; &gt; On Windows ARM (swiftc -c -target i686-windows -parse-pas-library<br>&gt; -parse-stdlib -module-name Swift -o Swift.obj reduced.swift) it will<br>&gt; generate similar assembly:<br>&gt; &gt;<br>&gt; &gt;     _TMPCs23_ContiguousArrayStorage:<br>&gt; &gt;       ...<br>&gt; &gt;       .long<br>&gt; _TMnCs23_ContiguousArrayStorage-(_MPCs23_ContiguousArrayStorage+128)<br>&gt; &gt;       ...<br>&gt; &gt;<br>&gt; &gt; However, this generates an IMAGE_REL_ARM_ADDR32 relocation which is the<br>&gt; 32-bit VA of the target.  If the symbol are in the same section, it is<br>&gt; possible to get a relative value.  However, I don&#39;t really see a way to<br>&gt; generate a relative offset across sections.  There is no relocation in the<br>&gt; COFF ARM specification which provides the 32-bit relative displacement of<br>&gt; the target.  There are 20, 23, and 24 bit relative displacements designed<br>&gt; specifically for branch instructions, but none that would operate on<br>&gt; generic data.<br>&gt; &gt;<br>&gt; &gt; Is there a good way to address this ABI issue?  Or perhaps do we need<br>&gt; something more invasive to support such targets?  Now, I might be<br>&gt; completely overlooking something simple that I didn&#39;t consider, so pointing<br>&gt; that out would be greatly appreciated as well.<br>&gt;<br>&gt; That&#39;s unfortunate. One possibly-crazy solution would be to use a<br>&gt; different object format that does support the necessary relocations, such<br>&gt; as LLVM&#39;s win32-macho target. That would forgo interoperability with<br>&gt; non-LLVM toolchains, of course<br></p><p><br>Yeah, it would make interoperability harder.  But, is there a loader for<br>macho on Windows?<br></p><p>-Joe<br></p><p><br></p><p>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160518/234bad8a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Relative Pointers and Windows ARM</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 19, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 18, 2016, at 6:01 PM, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt; wrote:<br>&gt; <br>&gt; On Wednesday, May 18, 2016, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; &gt; On May 18, 2016, at 1:51 PM, Saleem Abdulrasool via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; It seems that there are assumptions about the ability to create relative address across sections which doesn&#39;t seem possible on Windows ARM.<br>&gt; &gt;<br>&gt; &gt; Consider the following swift code:<br>&gt; &gt;<br>&gt; &gt; final class _ContiguousArrayStorage&lt;Element&gt; { }<br>&gt; &gt;<br>&gt; &gt; When compiled for Windows x86 (via swiftc -c -target i686-windows -parse-as-library -parse-stdlib -module-name Swift -o Swift.obj reduced.swift) it will generate the metadata pattern as:<br>&gt; &gt;<br>&gt; &gt;     __TMPCs23_ContiguousArrayStorage:<br>&gt; &gt;       ...<br>&gt; &gt;       .long __TMnCs23_ContiguousArrayStorage-(__MPCs23_ContiguousArrayStorage+128)<br>&gt; &gt;       ...<br>&gt; &gt;<br>&gt; &gt; This generates a IMAGE_REL_I386_REL32 relocation which is the 32-bit relative displacement of the target.<br>&gt; &gt;<br>&gt; &gt; On Windows ARM (swiftc -c -target i686-windows -parse-pas-library -parse-stdlib -module-name Swift -o Swift.obj reduced.swift) it will generate similar assembly:<br>&gt; &gt;<br>&gt; &gt;     _TMPCs23_ContiguousArrayStorage:<br>&gt; &gt;       ...<br>&gt; &gt;       .long _TMnCs23_ContiguousArrayStorage-(_MPCs23_ContiguousArrayStorage+128)<br>&gt; &gt;       ...<br>&gt; &gt;<br>&gt; &gt; However, this generates an IMAGE_REL_ARM_ADDR32 relocation which is the 32-bit VA of the target.  If the symbol are in the same section, it is possible to get a relative value.  However, I don&#39;t really see a way to generate a relative offset across sections.  There is no relocation in the COFF ARM specification which provides the 32-bit relative displacement of the target.  There are 20, 23, and 24 bit relative displacements designed specifically for branch instructions, but none that would operate on generic data.<br>&gt; &gt;<br>&gt; &gt; Is there a good way to address this ABI issue?  Or perhaps do we need something more invasive to support such targets?  Now, I might be completely overlooking something simple that I didn&#39;t consider, so pointing that out would be greatly appreciated as well.<br>&gt; <br>&gt; That&#39;s unfortunate. One possibly-crazy solution would be to use a different object format that does support the necessary relocations, such as LLVM&#39;s win32-macho target. That would forgo interoperability with non-LLVM toolchains, of course<br>&gt; <br>&gt; Yeah, it would make interoperability harder.  But, is there a loader for macho on Windows?<br></p><p>Sorry, if it wasn&#39;t clear, I meant that you could use mach-o (or ELF, or any object format really) for .o and .a files. You&#39;d still link them into PE executables and DLLs.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7f82643a80c536e1ddf188d21826fc08?s=50"></div><header><strong>Relative Pointers and Windows ARM</strong> from <string>Tom Birch</string> &lt;froody at gmail.com&gt;<p>May 19, 2016 at 07:00:00pm</p></header><div class="content"><p>Would it be acceptable to make relative pointers optional, so we can pay<br>the extra load-time cost on platforms where it&#39;s hard/undesirable to<br>implement them?<br></p><p>cheers,<br>Tom<br></p><p>On Thu, May 19, 2016 at 9:51 AM Joe Groff via swift-dev &lt;swift-dev at swift.org&gt;<br>wrote:<br></p><p>&gt;<br>&gt; &gt; On May 18, 2016, at 6:01 PM, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On Wednesday, May 18, 2016, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; &gt; On May 18, 2016, at 1:51 PM, Saleem Abdulrasool via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Hi,<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; It seems that there are assumptions about the ability to create<br>&gt; relative address across sections which doesn&#39;t seem possible on Windows ARM.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Consider the following swift code:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; final class _ContiguousArrayStorage&lt;Element&gt; { }<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; When compiled for Windows x86 (via swiftc -c -target i686-windows<br>&gt; -parse-as-library -parse-stdlib -module-name Swift -o Swift.obj<br>&gt; reduced.swift) it will generate the metadata pattern as:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;     __TMPCs23_ContiguousArrayStorage:<br>&gt; &gt; &gt;       ...<br>&gt; &gt; &gt;       .long<br>&gt; __TMnCs23_ContiguousArrayStorage-(__MPCs23_ContiguousArrayStorage+128)<br>&gt; &gt; &gt;       ...<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; This generates a IMAGE_REL_I386_REL32 relocation which is the 32-bit<br>&gt; relative displacement of the target.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; On Windows ARM (swiftc -c -target i686-windows -parse-pas-library<br>&gt; -parse-stdlib -module-name Swift -o Swift.obj reduced.swift) it will<br>&gt; generate similar assembly:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;     _TMPCs23_ContiguousArrayStorage:<br>&gt; &gt; &gt;       ...<br>&gt; &gt; &gt;       .long<br>&gt; _TMnCs23_ContiguousArrayStorage-(_MPCs23_ContiguousArrayStorage+128)<br>&gt; &gt; &gt;       ...<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; However, this generates an IMAGE_REL_ARM_ADDR32 relocation which is<br>&gt; the 32-bit VA of the target.  If the symbol are in the same section, it is<br>&gt; possible to get a relative value.  However, I don&#39;t really see a way to<br>&gt; generate a relative offset across sections.  There is no relocation in the<br>&gt; COFF ARM specification which provides the 32-bit relative displacement of<br>&gt; the target.  There are 20, 23, and 24 bit relative displacements designed<br>&gt; specifically for branch instructions, but none that would operate on<br>&gt; generic data.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Is there a good way to address this ABI issue?  Or perhaps do we need<br>&gt; something more invasive to support such targets?  Now, I might be<br>&gt; completely overlooking something simple that I didn&#39;t consider, so pointing<br>&gt; that out would be greatly appreciated as well.<br>&gt; &gt;<br>&gt; &gt; That&#39;s unfortunate. One possibly-crazy solution would be to use a<br>&gt; different object format that does support the necessary relocations, such<br>&gt; as LLVM&#39;s win32-macho target. That would forgo interoperability with<br>&gt; non-LLVM toolchains, of course<br>&gt; &gt;<br>&gt; &gt; Yeah, it would make interoperability harder.  But, is there a loader for<br>&gt; macho on Windows?<br>&gt;<br>&gt; Sorry, if it wasn&#39;t clear, I meant that you could use mach-o (or ELF, or<br>&gt; any object format really) for .o and .a files. You&#39;d still link them into<br>&gt; PE executables and DLLs.<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160519/f140a632/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Relative Pointers and Windows ARM</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 19, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 19, 2016, at 12:22 PM, Tom Birch &lt;froody at gmail.com&gt; wrote:<br>&gt; <br>&gt; Would it be acceptable to make relative pointers optional, so we can pay the extra load-time cost on platforms where it&#39;s hard/undesirable to implement them?<br></p><p>That&#39;s also a reasonable answer, since sliding DLLs is already fairly costly. We&#39;d need a bunch of extra tests to ensure both the relative and absolute forms work, though maybe with David Farler&#39;s work to abstract relative addresses it&#39;s already straightforward to have the RelativePointer&lt;..&gt; templates in the runtime work in a platform-independent way.<br></p><p>-Joe<br></p><p>&gt; cheers,<br>&gt; Tom<br>&gt; <br>&gt; On Thu, May 19, 2016 at 9:51 AM Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; &gt; On May 18, 2016, at 6:01 PM, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On Wednesday, May 18, 2016, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; &gt; On May 18, 2016, at 1:51 PM, Saleem Abdulrasool via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Hi,<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; It seems that there are assumptions about the ability to create relative address across sections which doesn&#39;t seem possible on Windows ARM.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Consider the following swift code:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; final class _ContiguousArrayStorage&lt;Element&gt; { }<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; When compiled for Windows x86 (via swiftc -c -target i686-windows -parse-as-library -parse-stdlib -module-name Swift -o Swift.obj reduced.swift) it will generate the metadata pattern as:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;     __TMPCs23_ContiguousArrayStorage:<br>&gt; &gt; &gt;       ...<br>&gt; &gt; &gt;       .long __TMnCs23_ContiguousArrayStorage-(__MPCs23_ContiguousArrayStorage+128)<br>&gt; &gt; &gt;       ...<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; This generates a IMAGE_REL_I386_REL32 relocation which is the 32-bit relative displacement of the target.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; On Windows ARM (swiftc -c -target i686-windows -parse-pas-library -parse-stdlib -module-name Swift -o Swift.obj reduced.swift) it will generate similar assembly:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;     _TMPCs23_ContiguousArrayStorage:<br>&gt; &gt; &gt;       ...<br>&gt; &gt; &gt;       .long _TMnCs23_ContiguousArrayStorage-(_MPCs23_ContiguousArrayStorage+128)<br>&gt; &gt; &gt;       ...<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; However, this generates an IMAGE_REL_ARM_ADDR32 relocation which is the 32-bit VA of the target.  If the symbol are in the same section, it is possible to get a relative value.  However, I don&#39;t really see a way to generate a relative offset across sections.  There is no relocation in the COFF ARM specification which provides the 32-bit relative displacement of the target.  There are 20, 23, and 24 bit relative displacements designed specifically for branch instructions, but none that would operate on generic data.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Is there a good way to address this ABI issue?  Or perhaps do we need something more invasive to support such targets?  Now, I might be completely overlooking something simple that I didn&#39;t consider, so pointing that out would be greatly appreciated as well.<br>&gt; &gt;<br>&gt; &gt; That&#39;s unfortunate. One possibly-crazy solution would be to use a different object format that does support the necessary relocations, such as LLVM&#39;s win32-macho target. That would forgo interoperability with non-LLVM toolchains, of course<br>&gt; &gt;<br>&gt; &gt; Yeah, it would make interoperability harder.  But, is there a loader for macho on Windows?<br>&gt; <br>&gt; Sorry, if it wasn&#39;t clear, I meant that you could use mach-o (or ELF, or any object format really) for .o and .a files. You&#39;d still link them into PE executables and DLLs.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>Relative Pointers and Windows ARM</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>May 21, 2016 at 01:00:00pm</p></header><div class="content"><p>On Thu, May 19, 2016 at 12:29 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On May 19, 2016, at 12:22 PM, Tom Birch &lt;froody at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Would it be acceptable to make relative pointers optional, so we can pay<br>&gt; the extra load-time cost on platforms where it&#39;s hard/undesirable to<br>&gt; implement them?<br>&gt;<br>&gt; That&#39;s also a reasonable answer, since sliding DLLs is already fairly<br>&gt; costly. We&#39;d need a bunch of extra tests to ensure both the relative and<br>&gt; absolute forms work, though maybe with David Farler&#39;s work to abstract<br>&gt; relative addresses it&#39;s already straightforward to have the<br>&gt; RelativePointer&lt;..&gt; templates in the runtime work in a platform-independent<br>&gt; way.<br></p><p><br>Would be interesting to at least see if this is possible.  Any hints on<br>where to get started with testing/prototyping such an approach?<br></p><p><br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; &gt; cheers,<br>&gt; &gt; Tom<br>&gt; &gt;<br>&gt; &gt; On Thu, May 19, 2016 at 9:51 AM Joe Groff via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; &gt; On May 18, 2016, at 6:01 PM, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt;<br>&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; On Wednesday, May 18, 2016, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; On May 18, 2016, at 1:51 PM, Saleem Abdulrasool via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; Hi,<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; It seems that there are assumptions about the ability to create<br>&gt; relative address across sections which doesn&#39;t seem possible on Windows ARM.<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; Consider the following swift code:<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; final class _ContiguousArrayStorage&lt;Element&gt; { }<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; When compiled for Windows x86 (via swiftc -c -target i686-windows<br>&gt; -parse-as-library -parse-stdlib -module-name Swift -o Swift.obj<br>&gt; reduced.swift) it will generate the metadata pattern as:<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;     __TMPCs23_ContiguousArrayStorage:<br>&gt; &gt; &gt; &gt;       ...<br>&gt; &gt; &gt; &gt;       .long<br>&gt; __TMnCs23_ContiguousArrayStorage-(__MPCs23_ContiguousArrayStorage+128)<br>&gt; &gt; &gt; &gt;       ...<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; This generates a IMAGE_REL_I386_REL32 relocation which is the 32-bit<br>&gt; relative displacement of the target.<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; On Windows ARM (swiftc -c -target i686-windows -parse-pas-library<br>&gt; -parse-stdlib -module-name Swift -o Swift.obj reduced.swift) it will<br>&gt; generate similar assembly:<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;     _TMPCs23_ContiguousArrayStorage:<br>&gt; &gt; &gt; &gt;       ...<br>&gt; &gt; &gt; &gt;       .long<br>&gt; _TMnCs23_ContiguousArrayStorage-(_MPCs23_ContiguousArrayStorage+128)<br>&gt; &gt; &gt; &gt;       ...<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; However, this generates an IMAGE_REL_ARM_ADDR32 relocation which is<br>&gt; the 32-bit VA of the target.  If the symbol are in the same section, it is<br>&gt; possible to get a relative value.  However, I don&#39;t really see a way to<br>&gt; generate a relative offset across sections.  There is no relocation in the<br>&gt; COFF ARM specification which provides the 32-bit relative displacement of<br>&gt; the target.  There are 20, 23, and 24 bit relative displacements designed<br>&gt; specifically for branch instructions, but none that would operate on<br>&gt; generic data.<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; Is there a good way to address this ABI issue?  Or perhaps do we<br>&gt; need something more invasive to support such targets?  Now, I might be<br>&gt; completely overlooking something simple that I didn&#39;t consider, so pointing<br>&gt; that out would be greatly appreciated as well.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; That&#39;s unfortunate. One possibly-crazy solution would be to use a<br>&gt; different object format that does support the necessary relocations, such<br>&gt; as LLVM&#39;s win32-macho target. That would forgo interoperability with<br>&gt; non-LLVM toolchains, of course<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Yeah, it would make interoperability harder.  But, is there a loader<br>&gt; for macho on Windows?<br>&gt; &gt;<br>&gt; &gt; Sorry, if it wasn&#39;t clear, I meant that you could use mach-o (or ELF, or<br>&gt; any object format really) for .o and .a files. You&#39;d still link them into<br>&gt; PE executables and DLLs.<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-dev mailing list<br>&gt; &gt; swift-dev at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt;<br></p><p><br>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160521/f454aeb0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Relative Pointers and Windows ARM</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>May 22, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 21, 2016, at 1:01 PM, Saleem Abdulrasool via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; On Thu, May 19, 2016 at 12:29 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On May 19, 2016, at 12:22 PM, Tom Birch &lt;froody at gmail.com &lt;mailto:froody at gmail.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Would it be acceptable to make relative pointers optional, so we can pay the extra load-time cost on platforms where it&#39;s hard/undesirable to implement them?<br>&gt; <br>&gt; That&#39;s also a reasonable answer, since sliding DLLs is already fairly costly. We&#39;d need a bunch of extra tests to ensure both the relative and absolute forms work, though maybe with David Farler&#39;s work to abstract relative addresses it&#39;s already straightforward to have the RelativePointer&lt;..&gt; templates in the runtime work in a platform-independent way.<br>&gt; <br>&gt; Would be interesting to at least see if this is possible.  Any hints on where to get started with testing/prototyping such an approach?<br></p><p>Well, there are four places you need to worry about:<br>  - The parts of IRGen that emit constant relative references; these should all be using ConstantBuilder, so it should be easy to update them.<br>  - The parts of IRGen that emit code to dereference relative references; I&#39;m not sure any of these actually exist right now.<br>  - The runtime, where like Joe says, it should be easy to abstract a template class on the runtime-traits class that&#39;s either a relative or absolute reference.<br>  - MetadataReader, which will need to do the right thing based on the runtime-traits class.<br></p><p>I think the hardest part of this is probably coming up with a pithy name. :)  It&#39;s important that callers not call something called addRelativeReference and have it just randomly add an absolute reference depending on target platform; the fact that it&#39;s sometimes relative and sometimes absolute is something that people adding new metadata features should be actively conscious of (among other things, because absolute references always have to be pointer-sized, not just 32 bits, and so the layout of the object may change).  So we should call it something that doesn&#39;t directly connote absolute vs. relative: maybe NearReference or LocalReference?<br></p><p>John.<br></p><p>&gt;  <br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; &gt; cheers,<br>&gt; &gt; Tom<br>&gt; &gt;<br>&gt; &gt; On Thu, May 19, 2016 at 9:51 AM Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; &gt; On May 18, 2016, at 6:01 PM, Saleem Abdulrasool &lt;compnerd at compnerd.org &lt;mailto:compnerd at compnerd.org&gt;&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; On Wednesday, May 18, 2016, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; On May 18, 2016, at 1:51 PM, Saleem Abdulrasool via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; Hi,<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; It seems that there are assumptions about the ability to create relative address across sections which doesn&#39;t seem possible on Windows ARM.<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; Consider the following swift code:<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; final class _ContiguousArrayStorage&lt;Element&gt; { }<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; When compiled for Windows x86 (via swiftc -c -target i686-windows -parse-as-library -parse-stdlib -module-name Swift -o Swift.obj reduced.swift) it will generate the metadata pattern as:<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;     __TMPCs23_ContiguousArrayStorage:<br>&gt; &gt; &gt; &gt;       ...<br>&gt; &gt; &gt; &gt;       .long __TMnCs23_ContiguousArrayStorage-(__MPCs23_ContiguousArrayStorage+128)<br>&gt; &gt; &gt; &gt;       ...<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; This generates a IMAGE_REL_I386_REL32 relocation which is the 32-bit relative displacement of the target.<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; On Windows ARM (swiftc -c -target i686-windows -parse-pas-library -parse-stdlib -module-name Swift -o Swift.obj reduced.swift) it will generate similar assembly:<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;     _TMPCs23_ContiguousArrayStorage:<br>&gt; &gt; &gt; &gt;       ...<br>&gt; &gt; &gt; &gt;       .long _TMnCs23_ContiguousArrayStorage-(_MPCs23_ContiguousArrayStorage+128)<br>&gt; &gt; &gt; &gt;       ...<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; However, this generates an IMAGE_REL_ARM_ADDR32 relocation which is the 32-bit VA of the target.  If the symbol are in the same section, it is possible to get a relative value.  However, I don&#39;t really see a way to generate a relative offset across sections.  There is no relocation in the COFF ARM specification which provides the 32-bit relative displacement of the target.  There are 20, 23, and 24 bit relative displacements designed specifically for branch instructions, but none that would operate on generic data.<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; Is there a good way to address this ABI issue?  Or perhaps do we need something more invasive to support such targets?  Now, I might be completely overlooking something simple that I didn&#39;t consider, so pointing that out would be greatly appreciated as well.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; That&#39;s unfortunate. One possibly-crazy solution would be to use a different object format that does support the necessary relocations, such as LLVM&#39;s win32-macho target. That would forgo interoperability with non-LLVM toolchains, of course<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Yeah, it would make interoperability harder.  But, is there a loader for macho on Windows?<br>&gt; &gt;<br>&gt; &gt; Sorry, if it wasn&#39;t clear, I meant that you could use mach-o (or ELF, or any object format really) for .o and .a files. You&#39;d still link them into PE executables and DLLs.<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-dev mailing list<br>&gt; &gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Saleem Abdulrasool<br>&gt; compnerd (at) compnerd (dot) org<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160522/7775e290/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Relative Pointers and Windows ARM</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>May 19, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 18, 2016, at 1:51 PM, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt; wrote:<br>&gt; Hi,<br>&gt; <br>&gt; It seems that there are assumptions about the ability to create relative address across sections which doesn&#39;t seem possible on Windows ARM.<br>&gt; <br>&gt; Consider the following swift code:<br>&gt; <br>&gt; final class _ContiguousArrayStorage&lt;Element&gt; { }<br>&gt; <br>&gt; When compiled for Windows x86 (via swiftc -c -target i686-windows -parse-as-library -parse-stdlib -module-name Swift -o Swift.obj reduced.swift) it will generate the metadata pattern as:<br>&gt; <br>&gt;     __TMPCs23_ContiguousArrayStorage:<br>&gt;       ...<br>&gt;       .long __TMnCs23_ContiguousArrayStorage-(__MPCs23_ContiguousArrayStorage+128)<br>&gt;       ...<br>&gt; <br>&gt; This generates a IMAGE_REL_I386_REL32 relocation which is the 32-bit relative displacement of the target.<br>&gt; <br>&gt; On Windows ARM (swiftc -c -target i686-windows -parse-pas-library -parse-stdlib -module-name Swift -o Swift.obj reduced.swift) it will generate similar assembly:<br>&gt; <br>&gt;     _TMPCs23_ContiguousArrayStorage:<br>&gt;       ...<br>&gt;       .long _TMnCs23_ContiguousArrayStorage-(_MPCs23_ContiguousArrayStorage+128)<br>&gt;       ...<br>&gt; <br>&gt; However, this generates an IMAGE_REL_ARM_ADDR32 relocation which is the 32-bit VA of the target.  If the symbol are in the same section, it is possible to get a relative value.  However, I don&#39;t really see a way to generate a relative offset across sections.  There is no relocation in the COFF ARM specification which provides the 32-bit relative displacement of the target.  There are 20, 23, and 24 bit relative displacements designed specifically for branch instructions, but none that would operate on generic data.<br>&gt; <br>&gt; Is there a good way to address this ABI issue?  Or perhaps do we need something more invasive to support such targets?  Now, I might be completely overlooking something simple that I didn&#39;t consider, so pointing that out would be greatly appreciated as well.<br></p><p>You can build PIC on Windows ARM, right?  How does Microsoft compile this:<br></p><p>  static int x;<br>  int *get_x_addr() { return &amp;x; }<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Relative Pointers and Windows ARM</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 19, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 19, 2016, at 9:07 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On May 18, 2016, at 1:51 PM, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt; wrote:<br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; It seems that there are assumptions about the ability to create relative address across sections which doesn&#39;t seem possible on Windows ARM.<br>&gt;&gt; <br>&gt;&gt; Consider the following swift code:<br>&gt;&gt; <br>&gt;&gt; final class _ContiguousArrayStorage&lt;Element&gt; { }<br>&gt;&gt; <br>&gt;&gt; When compiled for Windows x86 (via swiftc -c -target i686-windows -parse-as-library -parse-stdlib -module-name Swift -o Swift.obj reduced.swift) it will generate the metadata pattern as:<br>&gt;&gt; <br>&gt;&gt;    __TMPCs23_ContiguousArrayStorage:<br>&gt;&gt;      ...<br>&gt;&gt;      .long __TMnCs23_ContiguousArrayStorage-(__MPCs23_ContiguousArrayStorage+128)<br>&gt;&gt;      ...<br>&gt;&gt; <br>&gt;&gt; This generates a IMAGE_REL_I386_REL32 relocation which is the 32-bit relative displacement of the target.<br>&gt;&gt; <br>&gt;&gt; On Windows ARM (swiftc -c -target i686-windows -parse-pas-library -parse-stdlib -module-name Swift -o Swift.obj reduced.swift) it will generate similar assembly:<br>&gt;&gt; <br>&gt;&gt;    _TMPCs23_ContiguousArrayStorage:<br>&gt;&gt;      ...<br>&gt;&gt;      .long _TMnCs23_ContiguousArrayStorage-(_MPCs23_ContiguousArrayStorage+128)<br>&gt;&gt;      ...<br>&gt;&gt; <br>&gt;&gt; However, this generates an IMAGE_REL_ARM_ADDR32 relocation which is the 32-bit VA of the target.  If the symbol are in the same section, it is possible to get a relative value.  However, I don&#39;t really see a way to generate a relative offset across sections. There is no relocation in the COFF ARM specification which provides the 32-bit relative displacement of the target.  There are 20, 23, and 24 bit relative displacements designed specifically for branch instructions, but none that would operate on generic data.<br>&gt;&gt; <br>&gt;&gt; Is there a good way to address this ABI issue?  Or perhaps do we need something more invasive to support such targets?  Now, I might be completely overlooking something simple that I didn&#39;t consider, so pointing that out would be greatly appreciated as well.<br>&gt; <br>&gt; You can build PIC on Windows ARM, right?  How does Microsoft compile this:<br>&gt; <br>&gt;  static int x;<br>&gt;  int *get_x_addr() { return &amp;x; }<br></p><p>I&#39;m not familiar with Windows ARM, but if image loading works like Windows on Intel, then PIC isn&#39;t a thing—everything is compiled for a fixed address, and the kernel brute-force slides all the addresses at load time if it can&#39;t map an exe or dll at its preferred address.<br></p><p>-Joe<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>Relative Pointers and Windows ARM</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>May 19, 2016 at 05:00:00pm</p></header><div class="content"><p>On Thu, May 19, 2016 at 9:07 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br></p><p>&gt; &gt; On May 18, 2016, at 1:51 PM, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt;<br>&gt; wrote:<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; It seems that there are assumptions about the ability to create relative<br>&gt; address across sections which doesn&#39;t seem possible on Windows ARM.<br>&gt; &gt;<br>&gt; &gt; Consider the following swift code:<br>&gt; &gt;<br>&gt; &gt; final class _ContiguousArrayStorage&lt;Element&gt; { }<br>&gt; &gt;<br>&gt; &gt; When compiled for Windows x86 (via swiftc -c -target i686-windows<br>&gt; -parse-as-library -parse-stdlib -module-name Swift -o Swift.obj<br>&gt; reduced.swift) it will generate the metadata pattern as:<br>&gt; &gt;<br>&gt; &gt;     __TMPCs23_ContiguousArrayStorage:<br>&gt; &gt;       ...<br>&gt; &gt;       .long<br>&gt; __TMnCs23_ContiguousArrayStorage-(__MPCs23_ContiguousArrayStorage+128)<br>&gt; &gt;       ...<br>&gt; &gt;<br>&gt; &gt; This generates a IMAGE_REL_I386_REL32 relocation which is the 32-bit<br>&gt; relative displacement of the target.<br>&gt; &gt;<br>&gt; &gt; On Windows ARM (swiftc -c -target i686-windows -parse-pas-library<br>&gt; -parse-stdlib -module-name Swift -o Swift.obj reduced.swift) it will<br>&gt; generate similar assembly:<br>&gt; &gt;<br>&gt; &gt;     _TMPCs23_ContiguousArrayStorage:<br>&gt; &gt;       ...<br>&gt; &gt;       .long<br>&gt; _TMnCs23_ContiguousArrayStorage-(_MPCs23_ContiguousArrayStorage+128)<br>&gt; &gt;       ...<br>&gt; &gt;<br>&gt; &gt; However, this generates an IMAGE_REL_ARM_ADDR32 relocation which is the<br>&gt; 32-bit VA of the target.  If the symbol are in the same section, it is<br>&gt; possible to get a relative value.  However, I don&#39;t really see a way to<br>&gt; generate a relative offset across sections.  There is no relocation in the<br>&gt; COFF ARM specification which provides the 32-bit relative displacement of<br>&gt; the target.  There are 20, 23, and 24 bit relative displacements designed<br>&gt; specifically for branch instructions, but none that would operate on<br>&gt; generic data.<br>&gt; &gt;<br>&gt; &gt; Is there a good way to address this ABI issue?  Or perhaps do we need<br>&gt; something more invasive to support such targets?  Now, I might be<br>&gt; completely overlooking something simple that I didn&#39;t consider, so pointing<br>&gt; that out would be greatly appreciated as well.<br>&gt;<br>&gt; You can build PIC on Windows ARM, right?  How does Microsoft compile this:<br>&gt;<br>&gt;   static int x;<br>&gt;   int *get_x_addr() { return &amp;x; }<br></p><p><br>It will generate what they call a based relocation, relying on the DLL<br>sliding to adjust for the load at an address other than the preferred base<br>address.<br></p><p><br>&gt;<br>&gt; John.<br></p><p><br>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160519/86ac5bad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Relative Pointers and Windows ARM</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>May 19, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 19, 2016, at 5:39 PM, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt; wrote:<br>&gt; On Thu, May 19, 2016 at 9:07 AM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt; &gt; On May 18, 2016, at 1:51 PM, Saleem Abdulrasool &lt;compnerd at compnerd.org &lt;mailto:compnerd at compnerd.org&gt;&gt; wrote:<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; It seems that there are assumptions about the ability to create relative address across sections which doesn&#39;t seem possible on Windows ARM.<br>&gt; &gt;<br>&gt; &gt; Consider the following swift code:<br>&gt; &gt;<br>&gt; &gt; final class _ContiguousArrayStorage&lt;Element&gt; { }<br>&gt; &gt;<br>&gt; &gt; When compiled for Windows x86 (via swiftc -c -target i686-windows -parse-as-library -parse-stdlib -module-name Swift -o Swift.obj reduced.swift) it will generate the metadata pattern as:<br>&gt; &gt;<br>&gt; &gt;     __TMPCs23_ContiguousArrayStorage:<br>&gt; &gt;       ...<br>&gt; &gt;       .long __TMnCs23_ContiguousArrayStorage-(__MPCs23_ContiguousArrayStorage+128)<br>&gt; &gt;       ...<br>&gt; &gt;<br>&gt; &gt; This generates a IMAGE_REL_I386_REL32 relocation which is the 32-bit relative displacement of the target.<br>&gt; &gt;<br>&gt; &gt; On Windows ARM (swiftc -c -target i686-windows -parse-pas-library -parse-stdlib -module-name Swift -o Swift.obj reduced.swift) it will generate similar assembly:<br>&gt; &gt;<br>&gt; &gt;     _TMPCs23_ContiguousArrayStorage:<br>&gt; &gt;       ...<br>&gt; &gt;       .long _TMnCs23_ContiguousArrayStorage-(_MPCs23_ContiguousArrayStorage+128)<br>&gt; &gt;       ...<br>&gt; &gt;<br>&gt; &gt; However, this generates an IMAGE_REL_ARM_ADDR32 relocation which is the 32-bit VA of the target.  If the symbol are in the same section, it is possible to get a relative value.  However, I don&#39;t really see a way to generate a relative offset across sections.  There is no relocation in the COFF ARM specification which provides the 32-bit relative displacement of the target.  There are 20, 23, and 24 bit relative displacements designed specifically for branch instructions, but none that would operate on generic data.<br>&gt; &gt;<br>&gt; &gt; Is there a good way to address this ABI issue?  Or perhaps do we need something more invasive to support such targets?  Now, I might be completely overlooking something simple that I didn&#39;t consider, so pointing that out would be greatly appreciated as well.<br>&gt; <br>&gt; You can build PIC on Windows ARM, right?  How does Microsoft compile this:<br>&gt; <br>&gt;   static int x;<br>&gt;   int *get_x_addr() { return &amp;x; }<br>&gt; <br>&gt; It will generate what they call a based relocation, relying on the DLL sliding to adjust for the load at an address other than the preferred base address.<br></p><p>Okay, so an absolute address and metadata to do a fix-up, i.e. not PIC.  Score one for Joe.<br></p><p>I guess it&#39;s probably not reasonable to assume that IMAGE_REL_ARM_BRANCH24 will just work. :)  16M is not really a reasonable max image size anyway.<br></p><p>Well, if we wanted to be adventurous, we could ask Microsoft to add an IMAGE_REL_ARM_REL32 relocation in a future toolchain.  What we&#39;re asking of the ELF and Mach-O linkers isn&#39;t all that much less ridiculous... In the meantime, yeah, we should probably just switch to absolute addressing; it should be easy enough to generalize that in the metadata scheme.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160519/2d9e1346/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
