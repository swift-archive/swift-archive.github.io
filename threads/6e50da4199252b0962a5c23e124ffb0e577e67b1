<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Inquiry: Improved Composability of stdlib Collections?</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December  5, 2015 at 01:00:00pm</p></header><div class="content"><p>Swift’s standard library&#39;s core collections&#39; value-like, copy-on-write behavior is handy in the small, but they compose rather poorly with each other: if you have e.g. [K:Set&lt;V&gt;], and plan to mutate the “inner&quot; sets, it seems at present as if there is no way to avoid an unnecessary transient copy of each set for each mutation you perform upon it.<br></p><p>Various workarounds/solutions exist but all are full of unfortunate tradeoffs and/or limited further composability; in concrete cases you can do alright, but it’s hard to craft a generic solution that doesn’t inadvertently reintroduce the problem you started-out trying to solve.<br></p><p>Is anything currently on the roadmap to address this specifically — whether optimizer improvements, extended APIs, implementation adjustments, a `borrow` construct, or some other approach?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Inquiry: Improved Composability of stdlib Collections?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  5, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 5, 2015, at 11:34 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift’s standard library&#39;s core collections&#39; value-like, copy-on-write behavior is handy in the small, but they compose rather poorly with each other: if you have e.g. [K:Set&lt;V&gt;], and plan to mutate the “inner&quot; sets, it seems at present as if there is no way to avoid an unnecessary transient copy of each set for each mutation you perform upon it.<br>&gt; <br>&gt; Various workarounds/solutions exist but all are full of unfortunate tradeoffs and/or limited further composability; in concrete cases you can do alright, but it’s hard to craft a generic solution that doesn’t inadvertently reintroduce the problem you started-out trying to solve.<br>&gt; <br>&gt; Is anything currently on the roadmap to address this specifically — whether optimizer improvements, extended APIs, implementation adjustments, a `borrow` construct, or some other approach?<br>&gt; <br></p><p>Do you have specific examples of problems you&#39;re trying to solve?<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/0a319485/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Inquiry: Improved Composability of stdlib Collections?</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December  6, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 5, 2015, at 8:10 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 5, 2015, at 11:34 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Swift’s standard library&#39;s core collections&#39; value-like, copy-on-write behavior is handy in the small, but they compose rather poorly with each other: if you have e.g. [K:Set&lt;V&gt;], and plan to mutate the “inner&quot; sets, it seems at present as if there is no way to avoid an unnecessary transient copy of each set for each mutation you perform upon it.<br>&gt;&gt; <br>&gt;&gt; Various workarounds/solutions exist but all are full of unfortunate tradeoffs and/or limited further composability; in concrete cases you can do alright, but it’s hard to craft a generic solution that doesn’t inadvertently reintroduce the problem you started-out trying to solve.<br>&gt;&gt; <br>&gt;&gt; Is anything currently on the roadmap to address this specifically — whether optimizer improvements, extended APIs, implementation adjustments, a `borrow` construct, or some other approach?<br>&gt;&gt; <br>&gt; <br>&gt; Do you have specific examples of problems you&#39;re trying to solve?<br></p><p>I&#39;m not entirely sure if you&#39;re asking:<br></p><p>1. what are some specific problems with the standard library collections&#39; composability?<br>2. what are some specific problems with available solutions to the problems in (1)?<br>3. what are some specific problems for which *performant* nested collections would be useful?<br></p><p>...so I&#39;ll answer (1) and (2) quickly, then provide some context for (3).<br></p><p>Before I&#39;ll begin, I&#39;ll preface this by re-stating what I wanted to know:<br></p><p>- whether or not the problems I see for (1) and (2) are seen as such<br>- whether or not anything is already on the roadmap to address (1) and (2)<br></p><p>...and in case, thanks for your time and consideration.<br></p><p>For (1), the problem is simply that when you nest Swift&#39;s collections -- at least within a `Dictionary`, e.g. `[K:Set&lt;V&gt;]` -- there&#39;s currently no direct way to do efficient, in-place mutations of the inner `Set&lt;V&gt;` values; performance here is essentially quadratic (see Appendix A).<br>  <br>That you get ~quadratic performance in this context isn&#39;t surprising, given the collections&#39; design; the aspect I see as problematic is the lack of any straightforward way to do any better.<br></p><p>For (2), if you want e.g. all of the following:<br></p><p>- a collection `DictionaryOfSets` behaving ~ [K:Set&lt;V&gt;]<br>- re-using the basic collection types<br>- with value-like semantics (e.g. to fit in with the rest of the language)<br>- with better-than-quadratic performance on updates<br></p><p>...then the following outline seems to be the minimal amount of work to achieve all of the above:<br></p><p>- a class like `class Box&lt;T&gt; { var storage: T }` (etc.)<br>- a struct like `struct _DictionaryOfSets&lt;K,V&gt; { var storage: [K:Box&lt;Set&lt;V&gt;&gt;] }`<br>  - best if this implements all-or-most of the public API on `DictionaryOfSets`<br>  - knows how to perform a deep copy of `storage`<br>- a struct like `struct DictionaryOfSets&lt;K,V&gt; { var buffer: ManagedBuffer&lt;_DictionaryOfSets&lt;K,V&gt;,Void&gt; }`  <br>  - takes care of checking `isUniquelyReferenced` and making deep-copies when needed<br>  - with ownership now assured, forwards all calls to the buffer&#39;s `_DictionaryOfSets` <br>  <br>...which is certainly tractable, but also feels rather disproportionate: to make it work we&#39;ve now added 2 additional levels of indirection -- one due to the outer `ManagedBuffer`, and one more due to `Box` -- which we only need because we have no other way to manipulate the essentially-equivalent ownership-and-copying-(...etc.) behavior of `Dictionary` and `Set`.<br></p><p>This all feels like it could -- and should! -- be unnecessary, with e.g. some way of indicating an intent to do an in-place update if possible.<br></p><p>As for (3), a surprising amount of application-infrastructure code amounts to babysitting a nested collection of some kind.<br></p><p>As one example, if you want a generic solution to the &quot;pool-and-reuse a bunch of expensive-to-create elements&quot; (consider e.g. `UITableView` or `UICollectionView`), a `[Key:Set&lt;V&gt;]`-like collection is extremely handy:<br></p><p>    protocol ReusableComponentType: Equatable, Hashable {<br>      func prepareForPooling()<br>      func prepareForReuse()<br>      var reuseIdentifier: String { get }<br>    }<br>    <br>    protocol ComponentFactoryType {<br>      typealias Component: ReusableComponentType<br>      func instantiateComponent(reuseIdentifier: String) -&gt; Component<br>    }<br>    <br>    class ReusableComponentPool&lt;Component:ReusableComponentType&gt; {<br>      private var factories: [String:AnyComponentFactory&lt;Component&gt;]<br>      private var poolSizeLimits: [String:Int]<br>      private var reusePool: DictionaryOfSets&lt;String,Component&gt;<br>      // ^ NESTED COLLECTION HERE, ~ [String:Set&lt;Component&gt;]<br>      <br>      func dequeueComponentForReuseIdentifier(identifier: String) -&gt; Component {<br>        if let existing = self.reusePool.popFirstElementForKey(identifier) {<br>          existing.prepareForReuse()<br>        } else if let created = self.factories[identifier]?.instantiateComponent(reuseIdentifier: identifier) {<br>          return created<br>        } else {<br>          fatalError(&quot;No registered factory for identifier &#39;\(identifier)&#39;!&quot;)<br>        }<br>      }<br>      <br>      func poolComponentForPotentialReuse(component: Component) {<br>        self.reusePool.insertElement(<br>          component,<br>          forKey: component.identifier<br>        )<br>      }<br>      <br>      func drainOverfullPoolsIfNecessary() {<br>        for (identifier,sizeLimit) in self.poolSizeLimits {<br>          self.reusePool.shrinkSetForKey(<br>            identifier,<br>            ifAboveCount: sizeLimit<br>          )<br>        }<br>      }<br>      <br>    }<br></p><p>...but it&#39;s also a handy thing in other places (tracking active-transfers-by-host as ~`[String:Set&lt;NSURL&gt;]`, tracking discovered characteristics-of-services in `CoreBluetooth` as ~`[CBUUID:Set&lt;CBUUID&gt;]`, tracking invalidated layout attributes by supplementary-element-kind as ~`[String:Set&lt;NSIndexPath&gt;]`, organizing equivalence-classes for certain types of unit tests, and so on).<br></p><p>Note that it&#39;s not just `[K:Set&lt;V&gt;]`, either; sometimes `[K:[V]]` is handy, sometimes `[K:[Q:V]]` is handy (and ~ `[(K,Q):V]` isn&#39;t right); if Swift&#39;s stdlib gets an `OrderedSet` or `OrderedDictionary` there would be uses for those, as well.<br></p><p>Note that although in any specific use-case, you are arguably better off with a specific solution, e.g.:<br></p><p>    private class SingleComponentPool&lt;Component:ReusableComponentType&gt; {<br>      let factory: AnyComponentFactory&lt;Component&gt;<br>      let sizeLimit: Int?<br>      var pool: Set&lt;Component&gt;<br>    }<br>    <br>    class ReusableComponentPool&lt;Component:ReusableComponentType&gt; {<br>      private var pools: [String:SingleComponentPool&lt;Component&gt;]<br>    }<br></p><p>...instead of the earlier above, there&#39;s still arguably a utility to having a fancy collection that can be used in various contexts, with a rich supporting API.<br></p><p>In closing, thanks again for taking the time to read and thanks in advance for any consideration or response.<br></p><p>## Appendix: Concrete Benchmarks<br></p><p>To make the sure the performance implications are clear:<br></p><p>    func test10BareInserts() {<br>      self.measureBlock() {<br>        var target = Set&lt;Int&gt;()<br>        for index in 0..&lt;10 {<br>          target.insert(index)<br>        }<br>      }<br>    }<br>    <br>    func test10NestedInserts() {<br>      self.measureBlock() {<br>        var target = [Int:Set&lt;Int&gt;]()<br>        var target[0] = Set&lt;Int&gt;()<br>        for index in 0..&lt;10 {<br>          target[0]?.insert(index)<br>        }<br>      }<br>    }<br></p><p>...and so on, for e.g. `test100*`, `test1000*`, ...etc. Here&#39;s how this performs:<br></p><p>- 10 inserts: <br>  - bare:   *0.000003<br>  - nested: *0.000008<br>- 100 inserts:<br>  - bare:   *0.000012<br>  - nested: *0.000073<br>- 1000 inserts:<br>  - bare:  *0.000081<br>  - nested: 0.003<br>- 10000 inserts:<br>  - bare:   0.001<br>  - nested: 0.431<br>- 100000 inserts:<br>  - bare:   0.009<br>  - nested: 41.937<br>- 1000000 inserts:<br>  - bare:   0.112<br>  - nested: ????? (didn&#39;t run, but &gt; 1 hr if trend continues...)<br>  <br>...(where the un-marked values are average times, and those marked `*` are eyeballed modes over the runs, since XCTest seemingly rounds averages &lt; 0.001 to 0.000). Tested under a Release build, FWIW.<br></p><p>As always whether this matters depends on problem-size and context.<br></p><p>&gt; -Joe<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/52b25439/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
