<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 11, 2016 at 12:00:00pm</p></header><div class="content"><p>Thanks for your comments, Brent!<br></p><p>on Sun Apr 10 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md<br>&gt;<br>&gt; Some questions and comments:<br>&gt;<br>&gt;&gt; 		• Two for ranges that additionally conform to<br>&gt;&gt; RandomAccessCollection (requiring bounds that are Strideablewith<br>&gt;&gt; Stride conforming to Integer): CountableRange&lt;T&gt; and<br>&gt;&gt; CountableClosedRange&lt;T&gt;. These types can be folded into Range and<br>&gt;&gt; ClosedRange when Swift acquires conditional conformance capability.<br>&gt;<br>&gt; Does this mean that once we have conditional conformances,<br>&gt; HalfOpenRangeProtocol and ClosedRangeProtocol will most likely go<br>&gt; away?<br></p><p>I&#39;m not sure, honestly.<br></p><p>&gt;&gt; We also introduce three new protocols:<br>&gt;&gt; <br>&gt;&gt; 	• RangeProtocol<br>&gt;&gt; 	• HalfOpenRangeProtocol<br>&gt;&gt; 	• ClosedRangeProtocol<br>&gt;&gt; <br>&gt;&gt; These protocols mostly exist facilitate implementation-sharing among<br>&gt;&gt; the range types, and would seldom need to be implemented outside the<br>&gt;&gt; standard library.<br>&gt;<br>&gt; If these types are for implementation sharing, should they be<br>&gt; underscored to discourage their use? Or is the position they occupy in<br>&gt; the type hierarchy important because Range and ClosedRange will<br>&gt; eventually occupy them?<br></p><p>Underscoring hides names from users completely, and IMO that would not<br>be appropriate here.  If we underscored them, it would be mysterious<br>where an implementation of various methods came from.<br></p><p>&gt; It seems to me that RangeProtocol is unlike the other two in that it&#39;s<br>&gt; a sensible thing to constrain a parameter to. Does the<br>&gt; &quot;implementation-sharing&quot; comment not really apply to it? <br></p><p>That could be argued either way, I think.  One can&#39;t know for sure<br>without doing a redesign using a hypothetical more-capable Swift<br>language, which we don&#39;t have today.<br></p><p>&gt; On the other hand, it&#39;s not like the SubSequence subscript now takes a<br>&gt; RangeProtocol. Should it?<br></p><p>No; subscript can&#39;t be generic (language limitation).<br></p><p>&gt; (Has any thought been given to allowing you to close protocols to<br>&gt; outside conformances the way that resilience seems to suggest we&#39;ll<br>&gt; eventually allow you to close classes?)<br></p><p>I don&#39;t know who else might have thought about it, but personally I<br>don&#39;t think we want to do that.<br></p><p>&gt;&gt; • Two for general ranges (whose bounds are Comparable): Range&lt;T&gt; and<br>&gt;&gt; ClosedRange&lt;T&gt;. Having a separate ClosedRange type allows us to<br>&gt;&gt; address the vexing inability of the old Range to represent a range<br>&gt;&gt; containing the maximal value of its bound.<br>&gt;<br>&gt; I notice that ClosedRange uses a ClosedRangeIndex to, essentially, add<br>&gt; one extra value for &quot;larger than all values of this type&quot;. Could this<br>&gt; solution be applied to Range to allow us to unify Range and<br>&gt; ClosedRange, or are there other obstacles to that?<br></p><p>Performance is one such obstacle.  Half-open ranges should be your go-to<br>range, and can be implemented more simply.  There&#39;s also the problem of<br>how to decide whether the upper bound is part of the range.  I&#39;d rather<br>not have a dynamic check to select the comparison.<br></p><p>&gt; (There likely are. I just wanted to make sure the idea wasn&#39;t left unexplored.)<br>&gt;<br>&gt;&gt; func successor(of i: Index) -&gt; Index<br>&gt;<br>&gt; Two things:<br>&gt;<br>&gt; 1. I would really like a version of this which returns Optional and is<br>&gt; guaranteed to go `nil` once it hits `endIndex`. <br></p><p>The primary question to answer when exploring this idea is, IMO, “what<br>does that do to the code in algorithms?”  I can&#39;t imagine writing binary<br>search, partition, or rotate if I had to check for nil every time I<br>moved an index.<br></p><p>&gt; There can be a non-optional version too, or it might even be a feature<br>&gt; of the `index` family of methods instead of `successor` itself, but I<br>&gt; think it would be valuable to let the collection worry about the<br>&gt; bounds check.<br></p><p>Why would that be valuable?<br></p><p>&gt; It seems silly to check the index before calling `successor(of:)` when<br>&gt; `successor(of:)` is going to immediately perform the same check again<br>&gt; as a precondition.<br></p><p>Preconditions are not necessarily checked.  We don&#39;t promise to trap<br>every precondition violation.  We promise memory and type safety in the<br>absence of data races, and some precondition failures will trap in order<br>to ensure that.  Others will trap, where we think it is affordable, just<br>to provide a better programmer experience.<br></p><p>&gt; (Actually, in general, I&#39;m a little bit dismayed that the collection<br>&gt; API does so little to help you include bounds checks in your<br>&gt; code. Especially when iterating through a collection, bounds checks<br>&gt; are absolutely mandatory, and the collection API&#39;s solution to the<br>&gt; problem is &quot;eh, just use `&lt;`, it&#39;s not like you might mess something<br>&gt; like that up&quot;.)<br></p><p>What do you mean?  Could you show an example of what you think should be<br>better supported?<br></p><p>&gt; 2. There is a very strong parallel between this method and a<br>&gt; generator&#39;s `next()` method—the generator&#39;s `next()` calls<br>&gt; `successor(of:)` to get the index it should use—which makes me wonder<br>&gt; if this method should also be called `next(_:)` instead of<br>&gt; `successor(of:)`. <br></p><p>We had that in the code for a while. Certain people disliked it a lot.<br>Personally I think successor(of:) is still better, considering that<br>these methods end up getting thrown into the mix with all the other<br>methods on collections (e.g. sort()).<br></p><p>&gt; On the other hand, I have no good suggestion for a<br>&gt;<br>&gt;&gt; func index(n: IndexDistance, stepsFrom i: Index) -&gt; Index<br>&gt;<br>&gt; Oof, I am really not a fan of this name. `steps` is sort-of a label on<br>&gt; the `n` parameter, but it&#39;s attached to `i`. <br></p><p>Yes, it&#39;s an awkward thing to name.  Better suggestions most welcome.<br></p><p>&gt; Other collection APIs use `distance`, not `steps` (although &quot;steps&quot;<br>&gt; does appear in the documentation of the `Distance` associated<br>&gt; type). `index` puts it in a method family with `index(predicate:)` and<br>&gt; `index(of:)`, but those two are user-facing while this one is part of<br>&gt; the collection API. Even the word `index` itself is redundant with the<br>&gt; method return type.<br>&gt;<br>&gt; I do understand how this is kind of parallel to `index(of:)` and<br>&gt; `index(predicate:)`, in that they all return an index calculated from<br>&gt; the parameters, but I think these methods are more different than they<br>&gt; are similar.<br>&gt;<br>&gt; Compared to this:<br>&gt;<br>&gt; 	collection.index(5, stepsFrom: i)<br>&gt;<br>&gt; I would prefer any of these (ordered from least favorite to most):<br>&gt;<br>&gt; 	collection.index(distance: 5, from: i)<br></p><p>I&#39;m OK with this one, but am not sure it&#39;s an improvement over the<br>proposal.  I&#39;d like to hear other peoples&#39; arguments on this.<br></p><p>&gt; 	collection.index(5, from: i)<br></p><p>I don&#39;t think this one reads clearly enough.<br></p><p>&gt; 	collection.traveling(5, from: i)<br>&gt; 	collection.striding(5, from: i)<br>&gt; 	collection.advancing(i, by: 5)<br></p><p>None of the “ing” names work, IMO because that suffix suggests you&#39;re<br>returning a modified version of the receiver.<br></p><p>&gt; A word on `striding(_:from:)` appearing in that list: Although<br>&gt; redesigning Strideable is not directly in scope for this proposal,<br>&gt; I&#39;ve noticed that our discussions on modernizing Strideable seem to be<br>&gt; trending towards the idea that it operates on collections (or rather,<br>&gt; on an as-yet-unnamed supertype of `BidirectionalCollection` or<br>&gt; `RandomAccessCollection`) and strides by repeatedly calling a method<br>&gt; with the same semantics as this one. Thus, there seems to be an<br>&gt; intimate connection between this operation and Strideable. I think we<br>&gt; ought to choose a method name which suits that, and I don&#39;t think<br>&gt; `index` is it.<br>&gt;<br>&gt;&gt; func index(n: IndexDistance, stepsFrom i: Index, limitedBy limit: Index) -&gt; Index<br>&gt;<br>&gt; I have a few issues with this API.<br>&gt;<br>&gt; 1. As aforementioned, I&#39;m not a big fan of using `index` as the base method name.<br>&gt;<br>&gt; 2. This method can move the index either forwards or backwards, but<br>&gt; only one limit is specified. Would we be better off having the `limit`<br>&gt; be a range?<br></p><p>That would add a cost for checking that one doesn&#39;t want to pay in<br>algorithms that need this method.<br></p><p>&gt; 3. What is the use case for returning the `limit` instead of returning<br>&gt; the fact that we crossed it? I have a hard time thinking of a case<br>&gt; where I would want to just bump up against the limit and use it rather<br>&gt; than *detect* that I&#39;ve hit the limit (which would probably call for a<br>&gt; return type of `Index?`). Are there common needs that I&#39;m just not<br>&gt; thinking of? <br></p><p>Sure, for example<br></p><p>  x[i..&lt;x.index(n, stepsFrom: i, limitedBy: x.endIndex)].sort()<br></p><p><br>&gt; Should we offer both?<br></p><p>Definitely not, IMO!  They are utterly redundant, are they not?<br></p><p>&gt;<br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;<br>&gt; Despite my criticisms, this is fundamentally a very good design. It<br>&gt; will not only improve the language, it will also open the door to<br>&gt; further improvements.<br>&gt;<br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;<br>&gt; Yes. I believe this change is complicating in the short run but<br>&gt; actually simplifying in the long run, eliminating concepts like the<br>&gt; Index protocols which represented several overlapping semantics.<br>&gt;<br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; Yes.<br>&gt;<br>&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;<br>&gt; Nothing with a collection design as rich as Swift&#39;s.<br>&gt;<br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;<br>&gt; Somewhere between the latter two. I wouldn&#39;t call it in-depth when<br>&gt; it&#39;s such a big change, but I feel like I have too much background to<br>&gt; say it&#39;s a quick reading, either.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>April 11, 2016 at 08:00:00pm</p></header><div class="content"><p>On Mon, Apr 11, 2016 at 1:01 PM Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; Compared to this:<br>&gt; &gt;<br>&gt; &gt;       collection.index(5, stepsFrom: i)<br>&gt; &gt;<br>&gt; &gt; I would prefer any of these (ordered from least favorite to most):<br>&gt; &gt;<br>&gt; &gt;       collection.index(distance: 5, from: i)<br>&gt;<br>&gt; I&#39;m OK with this one, but am not sure it&#39;s an improvement over the<br>&gt; proposal.  I&#39;d like to hear other peoples&#39; arguments on this.<br>&gt;<br></p><p>Just to throwing out some additional ideas...<br></p><p>&quot;index moved x steps from i&quot;<br>index = collection.index(moved: 5, stepsFrom: i)<br>index = collection.index(moved: -10, stepsFrom: i)<br></p><p>&quot;index offset x from i&quot;<br>index = collection.index(offset: 5, from: i)<br>index = collection.index(offset: -10, from: i)<br></p><p>&quot;index advanced x from i&quot;<br>index = collection.index(advanced: 5, from: i)<br>index = collection.index(advanced: -10, from: i)<br></p><p>...of course also start to wonder why not the following...<br></p><p>&quot;index after/before i&quot;<br>index = collection.index(after:i)<br>index = collection.index(before:i)<br></p><p>...instead of the separately name styled successor / predecessor functions.<br></p><p>I am still hesitant about the use of &quot;form&quot; for in the in place variants,<br>throwing out more ideas, of course these break from the &quot;index&quot; style<br>naming above but on could argue the above naming is attempting to imply you<br>get a new index back while the following are attempting to avoid that.<br></p><p>&quot;move index i by x&quot;<br>collection.move(index: i, by: 5)<br>collection.offest(index: i, by: -3)<br></p><p>&quot;offset index i by x&quot;<br>collection.offest(index: i, by: 5)<br>collection.offest(index: i, by: -3)<br></p><p>&quot;advance index i by x&quot;<br>collection.advance(index: i, by: 5)<br>collection.advance(index: i, by: -3)<br></p><p>I think I like the ones using advance the best and if the &quot;index(&quot; ones are<br>the path forward I would lobby for index(after:)/index(before:) instead of<br>successor and predecessor.<br></p><p>-Shawn<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/5134c1e6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>April 11, 2016 at 09:00:00pm</p></header><div class="content"><p>Proposal link: https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md<br></p><p>&gt; On Apr 11, 2016, at 2:59 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for your comments, Brent!<br>&gt; <br>&gt; on Sun Apr 10 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>The shift described in this proposal is extremely valuable and makes implementing collections far more intuitive, as all the collection&#39;s logic lives &quot;inside&quot; the collection itself. My only hesitation is with the naming of the method that Brent also called out:<br></p><p>... snip ...<br></p><p>&gt;&gt;&gt; func index(n: IndexDistance, stepsFrom i: Index) -&gt; Index<br>&gt;&gt; <br>&gt;&gt; Oof, I am really not a fan of this name. `steps` is sort-of a label on<br>&gt;&gt; the `n` parameter, but it&#39;s attached to `i`. <br></p><p>Oof indeed! This is a very unusual method in the standard library, since we&#39;re calling on one instance to perform an action on another. My problems with the naming are twofold: <br></p><p>(1) Collision with the index(of:) and index(where:) APIs<br>The existing methods are used for searching a collection, possibly finding a matching index, possibly not. The new ones deterministically find an new index at a prescribed distance, with important and slightly complicated preconditions. These differences make the use and &quot;flavor&quot; of the two sets of methods distinct enough that I think they should have different names.<br></p><p>(2) Arguments are reversed<br>I think the ideal API for this would be index.advanced(by: 5, in: c), but I prefer keeping the index-moving implementation in the collection, not the index. I would favor any naming for this method that puts the index before the distance, keeping the overall shape of the advanced(by:) method. c.advance(i, by: 4) would be my pick.<br></p><p>....and finally I&#39;ll just go ahead and say again that I prefer -InPlace over form-. That&#39;s all, I&#39;m done!<br></p><p>Nate<br></p><p>ps. Seriously, collections make so much more sense with this change. +1000<br></p><p><br>&gt; Yes, it&#39;s an awkward thing to name.  Better suggestions most welcome.<br>&gt; <br>&gt;&gt; Other collection APIs use `distance`, not `steps` (although &quot;steps&quot;<br>&gt;&gt; does appear in the documentation of the `Distance` associated<br>&gt;&gt; type). `index` puts it in a method family with `index(predicate:)` and<br>&gt;&gt; `index(of:)`, but those two are user-facing while this one is part of<br>&gt;&gt; the collection API. Even the word `index` itself is redundant with the<br>&gt;&gt; method return type.<br>&gt;&gt; <br>&gt;&gt; I do understand how this is kind of parallel to `index(of:)` and<br>&gt;&gt; `index(predicate:)`, in that they all return an index calculated from<br>&gt;&gt; the parameters, but I think these methods are more different than they<br>&gt;&gt; are similar.<br>&gt;&gt; <br>&gt;&gt; Compared to this:<br>&gt;&gt; <br>&gt;&gt; 	collection.index(5, stepsFrom: i)<br>&gt;&gt; <br>&gt;&gt; I would prefer any of these (ordered from least favorite to most):<br>&gt;&gt; <br>&gt;&gt; 	collection.index(distance: 5, from: i)<br>&gt; <br>&gt; I&#39;m OK with this one, but am not sure it&#39;s an improvement over the<br>&gt; proposal.  I&#39;d like to hear other peoples&#39; arguments on this.<br>&gt; <br>&gt;&gt; 	collection.index(5, from: i)<br>&gt; <br>&gt; I don&#39;t think this one reads clearly enough.<br>&gt; <br>&gt;&gt; 	collection.traveling(5, from: i)<br>&gt;&gt; 	collection.striding(5, from: i)<br>&gt;&gt; 	collection.advancing(i, by: 5)<br>&gt; <br>&gt; None of the “ing” names work, IMO because that suffix suggests you&#39;re<br>&gt; returning a modified version of the receiver.<br>&gt; <br>&gt;&gt; A word on `striding(_:from:)` appearing in that list: Although<br>&gt;&gt; redesigning Strideable is not directly in scope for this proposal,<br>&gt;&gt; I&#39;ve noticed that our discussions on modernizing Strideable seem to be<br>&gt;&gt; trending towards the idea that it operates on collections (or rather,<br>&gt;&gt; on an as-yet-unnamed supertype of `BidirectionalCollection` or<br>&gt;&gt; `RandomAccessCollection`) and strides by repeatedly calling a method<br>&gt;&gt; with the same semantics as this one. Thus, there seems to be an<br>&gt;&gt; intimate connection between this operation and Strideable. I think we<br>&gt;&gt; ought to choose a method name which suits that, and I don&#39;t think<br>&gt;&gt; `index` is it.<br>&gt;&gt; <br>&gt;&gt;&gt; func index(n: IndexDistance, stepsFrom i: Index, limitedBy limit: Index) -&gt; Index<br>&gt;&gt; <br>&gt;&gt; I have a few issues with this API.<br>&gt;&gt; <br>&gt;&gt; 1. As aforementioned, I&#39;m not a big fan of using `index` as the base method name.<br>&gt;&gt; <br>&gt;&gt; 2. This method can move the index either forwards or backwards, but<br>&gt;&gt; only one limit is specified. Would we be better off having the `limit`<br>&gt;&gt; be a range?<br>&gt; <br>&gt; That would add a cost for checking that one doesn&#39;t want to pay in<br>&gt; algorithms that need this method.<br>&gt; <br>&gt;&gt; 3. What is the use case for returning the `limit` instead of returning<br>&gt;&gt; the fact that we crossed it? I have a hard time thinking of a case<br>&gt;&gt; where I would want to just bump up against the limit and use it rather<br>&gt;&gt; than *detect* that I&#39;ve hit the limit (which would probably call for a<br>&gt;&gt; return type of `Index?`). Are there common needs that I&#39;m just not<br>&gt;&gt; thinking of? <br>&gt; <br>&gt; Sure, for example<br>&gt; <br>&gt;  x[i..&lt;x.index(n, stepsFrom: i, limitedBy: x.endIndex)].sort()<br>&gt; <br>&gt; <br>&gt;&gt; Should we offer both?<br>&gt; <br>&gt; Definitely not, IMO!  They are utterly redundant, are they not?<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; Despite my criticisms, this is fundamentally a very good design. It<br>&gt;&gt; will not only improve the language, it will also open the door to<br>&gt;&gt; further improvements.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; Yes. I believe this change is complicating in the short run but<br>&gt;&gt; actually simplifying in the long run, eliminating concepts like the<br>&gt;&gt; Index protocols which represented several overlapping semantics.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; Yes.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; <br>&gt;&gt; Nothing with a collection design as rich as Swift&#39;s.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; Somewhere between the latter two. I wouldn&#39;t call it in-depth when<br>&gt;&gt; it&#39;s such a big change, but I feel like I have too much background to<br>&gt;&gt; say it&#39;s a quick reading, either.<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/7f9b9584/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 12, 2016 at 02:00:00pm</p></header><div class="content"><p>on Mon Apr 11 2016, Nate Cook &lt;natecook-AT-gmail.com&gt; wrote:<br></p><p>&gt; Proposal link:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md<br>&gt;<br>&gt;     On Apr 11, 2016, at 2:59 PM, Dave Abrahams via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     Thanks for your comments, Brent!<br>&gt;<br>&gt;     on Sun Apr 10 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The shift described in this proposal is extremely valuable and makes<br>&gt; implementing collections far more intuitive, as all the collection&#39;s logic lives<br>&gt; &quot;inside&quot; the collection itself. My only hesitation is with the naming of the<br>&gt; method that Brent also called out:<br>&gt;<br>&gt; ... snip ...<br>&gt;<br>&gt;                 func index(n: IndexDistance, stepsFrom i: Index) -&gt; Index<br>&gt;<br>&gt;         Oof, I am really not a fan of this name. `steps` is sort-of a label on<br>&gt;         the `n` parameter, but it&#39;s attached to `i`. <br>&gt;<br>&gt; Oof indeed! This is a very unusual method in the standard library, since we&#39;re<br>&gt; calling on one instance to perform an action on another. My problems with the<br>&gt; naming are twofold: <br>&gt;<br>&gt; (1) Collision with the index(of:) and index(where:) APIs<br>&gt; The existing methods are used for searching a collection, possibly finding a<br>&gt; matching index, possibly not. The new ones deterministically find an new index<br>&gt; at a prescribed distance, with important and slightly complicated preconditions.<br>&gt; These differences make the use and &quot;flavor&quot; of the two sets of methods distinct<br>&gt; enough that I think they should have different names.<br></p><p>Yup, I think that&#39;s a strong argument.<br></p><p>&gt;<br>&gt;<br>&gt; (2) Arguments are reversed<br>&gt; I think the ideal API for this would be index.advanced(by: 5, in: c), but I<br>&gt; prefer keeping the index-moving implementation in the collection, not the index.<br>&gt; I would favor any naming for this method that puts the index before the<br>&gt; distance, keeping the overall shape of the advanced(by:) method. c.advance(i,<br>&gt; by: 4) would be my pick.<br></p><p>Right, that would be great, except that it&#39;s a non-side-effectful method<br>and if we “noun the verb” (e.g. c.advanced(...)) it is now a method that<br>should return a modified version of the receiver, which it does not.  In<br>other words, there&#39;s no path to a non-mutating variant of the method.<br>One other possible approach: make the only method mutating, so instead<br>of <br></p><p>    let j = c.index(5, stepsFrom: i)<br></p><p>you get:<br></p><p>    var j = i<br>    c.advance(&amp;j, by: 5)<br>    // ...use j...<br></p><p>I think being forced to accept making j mutable would be a sad tradeoff<br>to make just because the name of the method makes us uncomfortable, but<br>it&#39;s an option.<br></p><p>&gt; ....and finally I&#39;ll just go ahead and say again that I prefer -InPlace over<br>&gt; form-. <br></p><p>Yer preachin&#39; to the choir, brother.<br></p><p>&gt; That&#39;s all, I&#39;m done!<br>&gt;<br>&gt; Nate<br>&gt;<br>&gt; ps. Seriously, collections make so much more sense with this change. +1000<br>&gt;<br>&gt;     Yes, it&#39;s an awkward thing to name. Better suggestions most welcome.<br>&gt;<br>&gt;         Other collection APIs use `distance`, not `steps` (although &quot;steps&quot;<br>&gt;         does appear in the documentation of the `Distance` associated<br>&gt;         type). `index` puts it in a method family with `index(predicate:)` and<br>&gt;         `index(of:)`, but those two are user-facing while this one is part of<br>&gt;         the collection API. Even the word `index` itself is redundant with the<br>&gt;         method return type.<br>&gt;<br>&gt;         I do understand how this is kind of parallel to `index(of:)` and<br>&gt;         `index(predicate:)`, in that they all return an index calculated from<br>&gt;         the parameters, but I think these methods are more different than they<br>&gt;         are similar.<br>&gt;<br>&gt;         Compared to this:<br>&gt;<br>&gt;         collection.index(5, stepsFrom: i)<br>&gt;<br>&gt;         I would prefer any of these (ordered from least favorite to most):<br>&gt;<br>&gt;         collection.index(distance: 5, from: i)<br>&gt;<br>&gt;     I&#39;m OK with this one, but am not sure it&#39;s an improvement over the<br>&gt;     proposal. I&#39;d like to hear other peoples&#39; arguments on this.<br>&gt;<br>&gt;         collection.index(5, from: i)<br>&gt;<br>&gt;     I don&#39;t think this one reads clearly enough.<br>&gt;<br>&gt;         collection.traveling(5, from: i)<br>&gt;         collection.striding(5, from: i)<br>&gt;         collection.advancing(i, by: 5)<br>&gt;<br>&gt;     None of the “ing” names work, IMO because that suffix suggests you&#39;re<br>&gt;     returning a modified version of the receiver.<br>&gt;<br>&gt;         A word on `striding(_:from:)` appearing in that list: Although<br>&gt;         redesigning Strideable is not directly in scope for this proposal,<br>&gt;         I&#39;ve noticed that our discussions on modernizing Strideable seem to be<br>&gt;         trending towards the idea that it operates on collections (or rather,<br>&gt;         on an as-yet-unnamed supertype of `BidirectionalCollection` or<br>&gt;         `RandomAccessCollection`) and strides by repeatedly calling a method<br>&gt;         with the same semantics as this one. Thus, there seems to be an<br>&gt;         intimate connection between this operation and Strideable. I think we<br>&gt;         ought to choose a method name which suits that, and I don&#39;t think<br>&gt;         `index` is it.<br>&gt;<br>&gt;                 func index(n: IndexDistance, stepsFrom i: Index, limitedBy<br>&gt;             limit: Index) -&gt; Index<br>&gt;<br>&gt;         I have a few issues with this API.<br>&gt;<br>&gt;         1. As aforementioned, I&#39;m not a big fan of using `index` as the base<br>&gt;         method name.<br>&gt;<br>&gt;         2. This method can move the index either forwards or backwards, but<br>&gt;         only one limit is specified. Would we be better off having the `limit`<br>&gt;         be a range?<br>&gt;<br>&gt;     That would add a cost for checking that one doesn&#39;t want to pay in<br>&gt;     algorithms that need this method.<br>&gt;<br>&gt;         3. What is the use case for returning the `limit` instead of returning<br>&gt;         the fact that we crossed it? I have a hard time thinking of a case<br>&gt;         where I would want to just bump up against the limit and use it rather<br>&gt;         than *detect* that I&#39;ve hit the limit (which would probably call for a<br>&gt;         return type of `Index?`). Are there common needs that I&#39;m just not<br>&gt;         thinking of? <br>&gt;<br>&gt;     Sure, for example<br>&gt;<br>&gt;     x[i..&lt;x.index(n, stepsFrom: i, limitedBy: x.endIndex)].sort()<br>&gt;<br>&gt;         Should we offer both?<br>&gt;<br>&gt;     Definitely not, IMO! They are utterly redundant, are they not?<br>&gt;<br>&gt;                 * What is your evaluation of the proposal?<br>&gt;<br>&gt;         Despite my criticisms, this is fundamentally a very good design. It<br>&gt;         will not only improve the language, it will also open the door to<br>&gt;         further improvements.<br>&gt;<br>&gt;                 * Is the problem being addressed significant enough to warrant a<br>&gt;             change to Swift?<br>&gt;<br>&gt;         Yes. I believe this change is complicating in the short run but<br>&gt;         actually simplifying in the long run, eliminating concepts like the<br>&gt;         Index protocols which represented several overlapping semantics.<br>&gt;<br>&gt;                 * Does this proposal fit well with the feel and direction of<br>&gt;             Swift?<br>&gt;<br>&gt;         Yes.<br>&gt;<br>&gt;                 * If you have you used other languages or libraries with a<br>&gt;             similar feature, how do you feel that this proposal compares to<br>&gt;             those?<br>&gt;<br>&gt;         Nothing with a collection design as rich as Swift&#39;s.<br>&gt;<br>&gt;                 * How much effort did you put into your review? A glance, a<br>&gt;             quick reading, or an in-depth study?<br>&gt;<br>&gt;         Somewhere between the latter two. I wouldn&#39;t call it in-depth when<br>&gt;         it&#39;s such a big change, but I feel like I have too much background to<br>&gt;         say it&#39;s a quick reading, either.<br>&gt;<br>&gt;     -- <br>&gt;     Dave<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 11, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt;&gt; If these types are for implementation sharing, should they be<br>&gt;&gt; underscored to discourage their use? Or is the position they occupy in<br>&gt;&gt; the type hierarchy important because Range and ClosedRange will<br>&gt;&gt; eventually occupy them?<br>&gt; <br>&gt; Underscoring hides names from users completely, and IMO that would not<br>&gt; be appropriate here.  If we underscored them, it would be mysterious<br>&gt; where an implementation of various methods came from.<br></p><p>If the concrete types show these members, does it matter that they actually came from a protocol?<br></p><p>&gt;&gt; On the other hand, it&#39;s not like the SubSequence subscript now takes a<br>&gt;&gt; RangeProtocol. Should it?<br>&gt; <br>&gt; No; subscript can&#39;t be generic (language limitation).<br></p><p>Right, and RangeProtocol isn&#39;t existential. Ouch.<br></p><p>&gt;&gt;&gt; func successor(of i: Index) -&gt; Index<br>&gt;&gt; <br>&gt;&gt; Two things:<br>&gt;&gt; <br>&gt;&gt; 1. I would really like a version of this which returns Optional and is<br>&gt;&gt; guaranteed to go `nil` once it hits `endIndex`. <br>&gt; <br>&gt; The primary question to answer when exploring this idea is, IMO, “what<br>&gt; does that do to the code in algorithms?”  I can&#39;t imagine writing binary<br>&gt; search, partition, or rotate if I had to check for nil every time I<br>&gt; moved an index.<br></p><p>If you&#39;re confident you&#39;re remaining in bounds, you should force-unwrap it.<br></p><p>&gt;&gt; There can be a non-optional version too, or it might even be a feature<br>&gt;&gt; of the `index` family of methods instead of `successor` itself, but I<br>&gt;&gt; think it would be valuable to let the collection worry about the<br>&gt;&gt; bounds check.<br>&gt; <br>&gt; Why would that be valuable?<br>&gt; <br>&gt;&gt; It seems silly to check the index before calling `successor(of:)` when<br>&gt;&gt; `successor(of:)` is going to immediately perform the same check again<br>&gt;&gt; as a precondition.<br>&gt; <br>&gt; Preconditions are not necessarily checked.  We don&#39;t promise to trap<br>&gt; every precondition violation.  We promise memory and type safety in the<br>&gt; absence of data races, and some precondition failures will trap in order<br>&gt; to ensure that.  Others will trap, where we think it is affordable, just<br>&gt; to provide a better programmer experience.<br></p><p>I understand that, but many—perhaps most—clients of APIs like `successor(of:)` will need to perform a bounds check. I think we would be better off if the check were implicit in the call. That would force all clients, or at least all clients which used the bounds-checking variants (which would be encouraged), to explicitly handle out-of-bounds conditions, in much the same way that `index(of:)` forces its clients to explicitly handle the possibility that a matching element might not exist, rather than returning `endIndex` (which would be easier).<br></p><p>&gt;&gt; (Actually, in general, I&#39;m a little bit dismayed that the collection<br>&gt;&gt; API does so little to help you include bounds checks in your<br>&gt;&gt; code. Especially when iterating through a collection, bounds checks<br>&gt;&gt; are absolutely mandatory, and the collection API&#39;s solution to the<br>&gt;&gt; problem is &quot;eh, just use `&lt;`, it&#39;s not like you might mess something<br>&gt;&gt; like that up&quot;.)<br>&gt; <br>&gt; What do you mean?  Could you show an example of what you think should be<br>&gt; better supported?<br></p><p>The simplest thing would simply be to have calls like these in Collection:<br></p><p>	func validate(i: Index) -&gt; Bool<br>	func validateIncreasing(i: Index) -&gt; Bool<br>	func validateDecreasing(i: Index) -&gt; Bool<br></p><p>Usage:<br></p><p>	while collection.validateIncreasing(i) {<br>		collection[i] = repeatedValue<br>		i = collection.successor(of: i)<br>	}<br></p><p>These methods would be one-liners, sure, but they would make your code say what was *meant*, not what happened to be true.<br></p><p>However, we could go further than this and perhaps reduce the amount of bounds-checking we do, even across optimization barriers.<br></p><p>To explain what I mean, let&#39;s take a look at `IndexingIterator`. With various less-interesting bits stripped out, the pull request defines it like this:<br></p><p>	public struct IndexingIterator&lt;Elements: IndexableBase&gt;: IteratorProtocol, Sequence {<br>	  init(_elements: Elements) {<br>	    self._elements = _elements<br>	    self._position = _elements.startIndex<br>	  }<br></p><p>	  mutating func next() -&gt; Elements._Element? {<br>	    if _position == _elements.endIndex { return nil }<br>	    let element = _elements[_position]<br>	    _elements.formSuccessor(&amp;_position)<br>	    return element<br>	  }<br></p><p>	  internal let _elements: Elements<br>	  internal var _position: Elements.Index<br>	}<br></p><p>Let&#39;s annotate the `next()` method with its bounds-checking behavior.<br></p><p>	  mutating func next() -&gt; Elements._Element? {<br>	    if _position == _elements.endIndex { return nil }		// Explicit bounds check performed here<br>	    let element = _elements[_position]				// Usually precondition()s a bounds check to preserve memory safety<br>	    _elements.formSuccessor(&amp;_position)			// May perform a bounds check on the incremented value<br>	    return element<br>	  }<br></p><p>Depending on the implementation, at least two, and possibly all three, of these lines will involve a bounds check. Now, perhaps the optimizer is good at eliding redundant checks involving an IndexingIterator because stdlib is transparent, but similar user code wouldn&#39;t get that benefit.<br></p><p>So, imagine that we have a type like this in the standard library:<br></p><p>	/// Represents a pre-validated index. A pre-validated index received from a given collection is <br>	/// guaranteed to refer to a valid element in that collection, as long as the collection is not mutated.<br>	/// <br>	/// -Warning:	Operations which accept a Valid&lt;Index&gt; assume it is in bounds and do not perform <br>	///			bounds checks. Using a Valid&lt;Index&gt; on a collection other than the one which created <br>	/// 			it, or on a collection which has been mutated since it was created, may be unsafe.<br>	struct Valid&lt;Index: Comparable&gt; {<br>		init(unsafeIndex index: Index) { self.index = index }<br>		private(set) var index: Index<br>	}<br></p><p>And a few members like these in the Collection protocols (there would be others; I&#39;m just defining the ones we&#39;re using here:<br></p><p>	/// Validates an index, returning `nil` if it is invalid, or a Valid&lt;Index&gt; for that index otherwise.<br>	func validate(i: Index) -&gt; Valid&lt;Index&gt;?<br>	<br>	/// Transforms `i` to represent the next valid index after itself, or `nil` if that index would be out of bounds.<br>	func formValidSuccessor(i: inout Valid&lt;Index&gt;?)<br>	<br>	/// Accesses the element corresponding to the prevalidated index<br>	subscript (i: Valid&lt;Index&gt;) -&gt; Element { get }<br></p><p>With those in hand, you can rewrite IndexingIterator like so:<br></p><p>	public struct IndexingIterator&lt;Elements: IndexableBase&gt;: IteratorProtocol, Sequence {<br>	  init(_elements: Elements) {<br>	    self._elements = _elements<br>	    self._position = _elements.validate(_elements.startIndex)<br>	  }<br></p><p>	  mutating func next() -&gt; Elements._Element? {<br>	    if _position == nil { return nil }				// This merely checks the result of the previous bounds check<br>	    let element = _elements[_position!]			// No bounds check needed<br>	    _elements.formValidSuccessor(&amp;_position!)	// This is the only bounds check in the loop<br>	    return element<br>	  }<br></p><p>	  internal let _elements: Elements<br>	  internal var _position: Valid&lt;Elements.Index&gt;?<br>	}<br></p><p>This version only tests the bounds once per element, inside `formValidSuccessor(_:)` (or in `validate` for the start index), rather than several times.<br></p><p>(Incidentally, `Valid&lt;Int&gt;?` could theoretically be expressed in the size of a normal `Int`, since `endIndex &lt;= Int.max`, and `endIndex` is not valid. I don&#39;t see a good way to tell Swift about this, though.)<br></p><p>&gt;&gt; 	collection.index(5, from: i)<br>&gt; <br>&gt; I don&#39;t think this one reads clearly enough.<br></p><p>&quot;The index 5 from i&quot; reads fine to me, but I guess that&#39;s a matter of opinion.<br></p><p>&gt;&gt; 	collection.traveling(5, from: i)<br>&gt;&gt; 	collection.striding(5, from: i)<br>&gt;&gt; 	collection.advancing(i, by: 5)<br>&gt; <br>&gt; None of the “ing” names work, IMO because that suffix suggests you&#39;re<br>&gt; returning a modified version of the receiver.<br></p><p>Huh, that clarifies something. How about the non-`ing` variants?<br></p><p>	collection.travel(5, from: i)<br>	collection.stride(5, from: i)<br>	collection.advance(i, by: 5)<br></p><p>I&#39;d say `stride` might be an attractive nuisance in this form (although if Strideable&#39;s public face becomes `Self.striding(by:)`, only to Swift 2 users) but the others look fine to me.<br></p><p>&gt;&gt;&gt; func index(n: IndexDistance, stepsFrom i: Index, limitedBy limit: Index) -&gt; Index<br>&gt;&gt; <br>&gt;&gt; 2. This method can move the index either forwards or backwards, but<br>&gt;&gt; only one limit is specified. Would we be better off having the `limit`<br>&gt;&gt; be a range?<br>&gt; <br>&gt; That would add a cost for checking that one doesn&#39;t want to pay in<br>&gt; algorithms that need this method.<br></p><p>I&#39;m a little uncomfortable with the way `limit`&#39;s interpretation changes based on the sign of `n` here; a stray arithmetic error could turn a maximum into a minimum, with potentially bizarre results. In the code, it looks like we end up branching to accommodate that interpretation, too, which isn&#39;t ideal.<br></p><p>I might feel a little better with a variant for each limit semantic:<br></p><p>	func index(n: IndexDistance, stepsFrom: Index, belowLimit: Index) -&gt; Index				// for when you expect to move up<br>	func index(n: IndexDistance, stepsFrom: Index, aboveLimit: Index) -&gt; Index			// for when you expect to move down<br>	func index(n: IndexDistance, stepsFrom: Index, withinLimits: Range&lt;Index&gt;) -&gt; Index	// for when you don&#39;t know which direction you&#39;re going<br></p><p>&gt;&gt; 3. What is the use case for returning the `limit` instead of returning<br>&gt;&gt; the fact that we crossed it? I have a hard time thinking of a case<br>&gt;&gt; where I would want to just bump up against the limit and use it rather<br>&gt;&gt; than *detect* that I&#39;ve hit the limit (which would probably call for a<br>&gt;&gt; return type of `Index?`). Are there common needs that I&#39;m just not<br>&gt;&gt; thinking of? <br>&gt; <br>&gt; Sure, for example<br>&gt; <br>&gt;  x[i..&lt;x.index(n, stepsFrom: i, limitedBy: x.endIndex)].sort()<br></p><p>Let me restate that. Given that Swift doesn&#39;t usually seem to truncate ranges that are too long (though there are exceptions), are we more frequently going to want to stop at the limit, or to detect that the limit has been hit?<br></p><p>&gt;&gt; Should we offer both?<br>&gt; <br>&gt; Definitely not, IMO!  They are utterly redundant, are they not?<br></p><p>Well, an Optional-returning `index(_:stepsFrom:limitedBy:)` can be treated as a truncating version pretty easily. For instance, `prefix(_:)` can do this:<br></p><p>	let end = index(numericCast(maxLength), stepsFrom: startIndex, limitedBy: endIndex) ?? endIndex<br>	return self[startIndex..&lt;end]<br></p><p>This is a bit of a hassle, and might be less efficient (an optional return, an extra test), but I don&#39;t think you can reliably go in the other direction.<br></p><p>(On the other hand, it might be that I&#39;m conceiving of the purpose of `limitedBy` differently from you—I think of it as a safety measure, but you may be thinking of it specifically as an automatic truncation mechanism.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>April 12, 2016 at 02:00:00am</p></header><div class="content"><p>On Mon, Apr 11, 2016 at 9:56 PM, Brent Royal-Gordon via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; So, imagine that we have a type like this in the standard library:<br>&gt;<br>&gt;         /// Represents a pre-validated index. A pre-validated index received from a given collection is<br>&gt;         /// guaranteed to refer to a valid element in that collection, as long as the collection is not mutated.<br>&gt;         ///<br>&gt;         /// -Warning:   Operations which accept a Valid&lt;Index&gt; assume it is in bounds and do not perform<br>&gt;         ///                     bounds checks. Using a Valid&lt;Index&gt; on a collection other than the one which created<br>&gt;         ///                     it, or on a collection which has been mutated since it was created, may be unsafe.<br>&gt;         struct Valid&lt;Index: Comparable&gt; {<br>&gt;                 init(unsafeIndex index: Index) { self.index = index }<br>&gt;                 private(set) var index: Index<br>&gt;         }<br></p><p>Hi Brent,<br></p><p>Index invalidation rules are much more complex than what this model<br>can express.  For example, Array&#39;s indices can become invalid after<br>you remove elements from it.  Even if you have validated indices<br>around, that validation is now invalidated.  Not even to mention that<br>indices are valid only in context of a particular collection instance,<br>so in this model you could validate an index against one collection<br>and use it with another one.  Please read<br>https://github.com/apple/swift/blob/master/docs/IndexInvalidation.rst<br>for a more detailed description of the rules.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/909469b64d49eaf2c4e82fbba166d55c?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Stephan Tolksdorf</string> &lt;st at quanttec.com&gt;<p>April 15, 2016 at 10:00:00pm</p></header><div class="content"><p>On 2016-04-12 Dmitri Gribenko via swift-evolution wrote:<br>&gt; Not even to mention that<br>&gt; indices are valid only in context of a particular collection instance,<br>&gt; so in this model you could validate an index against one collection<br>&gt; and use it with another one.<br></p><p>The proposal requires Index values to be Comparable. Does that mean that <br>indices from different collection instances should be comparable i.e. <br>have a strict total order?<br></p><p>And somewhat related: Is it safe in Swift (in contrast to C) to compare <br>NativePointers into unrelated memory blocks?<br></p><p>- Stephan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>April 15, 2016 at 02:00:00pm</p></header><div class="content"><p>On Fri, Apr 15, 2016 at 1:30 PM, Stephan Tolksdorf &lt;st at quanttec.com&gt; wrote:<br>&gt; On 2016-04-12 Dmitri Gribenko via swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt; Not even to mention that<br>&gt;&gt; indices are valid only in context of a particular collection instance,<br>&gt;&gt; so in this model you could validate an index against one collection<br>&gt;&gt; and use it with another one.<br>&gt;<br>&gt;<br>&gt; The proposal requires Index values to be Comparable. Does that mean that<br>&gt; indices from different collection instances should be comparable i.e. have a<br>&gt; strict total order?<br></p><p>No, comparing indices from unrelated instances produces unspecified<br>results (incl. traps).<br></p><p>&gt; And somewhat related: Is it safe in Swift (in contrast to C) to compare<br>&gt; NativePointers into unrelated memory blocks?<br></p><p>Unfortunately, I don&#39;t know, but I&#39;d like to know the answer, too :)<br>I don&#39;t think this is documented anywhere though, so it is technically<br>unspecified.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/909469b64d49eaf2c4e82fbba166d55c?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Stephan Tolksdorf</string> &lt;st at quanttec.com&gt;<p>April 16, 2016 at 01:00:00am</p></header><div class="content"><p>On 2016-04-15 Dmitri Gribenko wrote:<br>&gt;&gt; On Fri, Apr 15, 2016 at 1:30 PM, Stephan Tolksdorf &lt;st at quanttec.com&gt; wrote:<br>&gt;&gt; The proposal requires Index values to be Comparable. Does that mean that<br>&gt;&gt; indices from different collection instances should be comparable i.e. have a<br>&gt;&gt; strict total order?<br>&gt;<br>&gt; No, comparing indices from unrelated instances produces unspecified<br>&gt; results (incl. traps).<br></p><p>&gt;&gt; And somewhat related: Is it safe in Swift (in contrast to C) to compare<br>&gt;&gt; NativePointers into unrelated memory blocks?<br>&gt;<br>&gt; Unfortunately, I don&#39;t know, but I&#39;d like to know the answer, too :)<br>&gt; I don&#39;t think this is documented anywhere though, so it is technically<br>&gt; unspecified.<br></p><p>Thanks for your reply!<br></p><p>These kind of type-specific special preconditions for the Comparable <br>protocol probably should be documented more prominently. A similar case <br>is the behaviour of the Comparable implementation for floats when NaNs <br>are involved.<br></p><p>- Stephan<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 16, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Am 15.04.2016 um 23:19 schrieb Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; On Fri, Apr 15, 2016 at 1:30 PM, Stephan Tolksdorf &lt;st at quanttec.com&gt; wrote:<br>&gt;&gt; On 2016-04-12 Dmitri Gribenko via swift-evolution wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not even to mention that<br>&gt;&gt;&gt; indices are valid only in context of a particular collection instance,<br>&gt;&gt;&gt; so in this model you could validate an index against one collection<br>&gt;&gt;&gt; and use it with another one.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The proposal requires Index values to be Comparable. Does that mean that<br>&gt;&gt; indices from different collection instances should be comparable i.e. have a<br>&gt;&gt; strict total order?<br>&gt; <br>&gt; No, comparing indices from unrelated instances produces unspecified<br>&gt; results (incl. traps).<br></p><p>Path dependent types as used in Scala would allow making this distinction type safe (see http://docs.scala-lang.org/tutorials/tour/inner-classes or http://danielwestheide.com/blog/2013/02/13/the-neophytes-guide-to-scala-part-13-path-dependent-types.html) by allowing the index type to be rooted at the instance.<br></p><p>Are there any plans to adding path dependent types to Swift?<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 17, 2016 at 08:00:00am</p></header><div class="content"><p>+1 for Scala&#39;s path dependent types.<br></p><p>On Saturday, 16 April 2016, Thorsten Seitz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; Am 15.04.2016 um 23:19 schrieb Dmitri Gribenko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt;:<br>&gt; &gt;<br>&gt; &gt; On Fri, Apr 15, 2016 at 1:30 PM, Stephan Tolksdorf &lt;st at quanttec.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt; On 2016-04-12 Dmitri Gribenko via swift-evolution wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Not even to mention that<br>&gt; &gt;&gt;&gt; indices are valid only in context of a particular collection instance,<br>&gt; &gt;&gt;&gt; so in this model you could validate an index against one collection<br>&gt; &gt;&gt;&gt; and use it with another one.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The proposal requires Index values to be Comparable. Does that mean that<br>&gt; &gt;&gt; indices from different collection instances should be comparable i.e.<br>&gt; have a<br>&gt; &gt;&gt; strict total order?<br>&gt; &gt;<br>&gt; &gt; No, comparing indices from unrelated instances produces unspecified<br>&gt; &gt; results (incl. traps).<br>&gt;<br>&gt; Path dependent types as used in Scala would allow making this distinction<br>&gt; type safe (see http://docs.scala-lang.org/tutorials/tour/inner-classes or<br>&gt; http://danielwestheide.com/blog/2013/02/13/the-neophytes-guide-to-scala-part-13-path-dependent-types.html)<br>&gt; by allowing the index type to be rooted at the instance.<br>&gt;<br>&gt; Are there any plans to adding path dependent types to Swift?<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160417/fff1461a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>April 12, 2016 at 02:00:00am</p></header><div class="content"><p>On Mon, Apr 11, 2016 at 9:56 PM, Brent Royal-Gordon via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; (On the other hand, it might be that I&#39;m conceiving of the purpose of `limitedBy` differently from you—I think of it as a safety measure, but you may be thinking of it specifically as an automatic truncation mechanism.)<br></p><p>Hi Brent,<br></p><p>Could you explain what kind of safety do you have in mind?  Swift will<br>guarantee memory safety even if you attempt to advance an index past<br>endIndex using the non-limiting overload.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 12, 2016 at 04:00:00am</p></header><div class="content"><p>&gt;&gt; (On the other hand, it might be that I&#39;m conceiving of the purpose of `limitedBy` differently from you—I think of it as a safety measure, but you may be thinking of it specifically as an automatic truncation mechanism.)<br>&gt; <br>&gt; Hi Brent,<br>&gt; <br>&gt; Could you explain what kind of safety do you have in mind?  Swift will<br>&gt; guarantee memory safety even if you attempt to advance an index past<br>&gt; endIndex using the non-limiting overload.<br></p><p>By &quot;safety&quot; here, I mean what I will call &quot;index safety&quot;: not accidentally using an index which would violate the preconditions of the methods or properties you are planning to use it with. I think it&#39;s too easy to accidentally overrun the permitted range of indices, and the API should help you avoid doing that.<br></p><p>For instance, suppose I&#39;m porting XCTest to Swift, and I decide to rewrite its `demangleSimpleClass` function, which extracts the identifiers from a mangled Swift symbol name. Specifically, I&#39;m implementing `scanIdentifier`, which reads one particular identifier out of the middle of a string. (For those unfamiliar: an identifier in a mangled symbol name consists of one or more digits to represent a length, followed by that many characters.) I will assume that the mangled symbol name is in a Swift.String.<br></p><p>Here&#39;s a direct port:<br></p><p>	func scanIdentifier(partialMangled: String) -&gt; (identifier: String, remainder: String) {<br>		let chars = partialMangled.characters<br>		var lengthRange = chars.startIndex ..&lt; chars.startIndex<br>	<br>		while chars[lengthRange.endIndex].isDigit {<br>			lengthRange.endIndex = chars.successor(of: lengthRange.endDigit)<br>		}<br>	<br>		let lengthString = String(chars[lengthRange])<br>		let length = Int(lengthString)!<br>	<br>		let identifierRange = lengthRange.endIndex ..&lt; chars.index(length, stepsFrom: lengthRange.endIndex)<br>		let remainderRange = chars.suffix(from: identifierRange.endIndex)<br>	<br>		return (String(chars[identifierRange]), String(chars[identifierRange]))<br>	}<br></p><p>This works (note: probably, I haven&#39;t actually tested it), but it fails a precondition if the mangled symbol is invalid. Suppose we want to detect this condition so that our parent function can throw a nice error instead:<br></p><p>	func scanIdentifier(partialMangled: String) -&gt; (identifier: String, remainder: String)? {<br>		let chars = partialMangled.characters<br>		var lengthRange = chars.startIndex ..&lt; chars.startIndex<br>	<br>		while chars[lengthRange.endIndex].isDigit {<br>			lengthRange.endIndex = chars.successor(of: lengthRange.endDigit)<br>			if lengthRange.endIndex == chars.endIndex {<br>				return nil<br>			}<br>		}<br>	<br>		let lengthString = String(chars[lengthRange])<br>		guard let length = Int(lengthString) else {<br>			return nil<br>		}<br>	<br>		let identifierRange = lengthRange.endIndex ..&lt; chars.index(length, stepsFrom: lengthRange.endIndex)<br>		if identifierRange.endIndex &gt; chars.endIndex {<br>			return nil<br>		}<br>	<br>		let remainderRange = chars.suffix(from: identifierRange.endIndex)<br>	<br>		return (String(chars[identifierRange]), String(chars[identifierRange]))<br>	}<br></p><p>That&#39;s really not the greatest. To tell the truth, I&#39;ve actually guessed what bounds-checking is needed here; I&#39;m not 100% sure I caught all the cases. And, um, I&#39;m not really sure that `index(length, stepsFrom: lengthRange.endIndex)` is guaranteed to return anything valid if `length` is too large. Even `limitedBy:` wouldn&#39;t help me here—I would end up silently accepting and truncating an invalid string instead of detecting the error.<br></p><p>Now, imagine if `successor(of:)` and `index(_:stepsFrom:)` instead had variants which performed range checks on their results and returned `nil` if they failed:<br></p><p>	func scanIdentifier(partialMangled: String) -&gt; (identifier: String, remainder: String)? {<br>		let chars = partialMangled.characters<br>		var lengthRange = chars.startIndex ..&lt; chars.startIndex<br>	<br>		while chars[lengthRange.endIndex].isDigit {<br>			guard let nextIndex = chars.successor(of: lengthRange.endDigit, permittingEnd: false) else {<br>				return nil<br>			}<br>			lengthRange.endIndex = nextIndex<br>		}<br>	<br>		let lengthString = String(chars[lengthRange])<br>		guard let length = Int(lengthString) else {<br>			return nil<br>		}<br>	<br>		guard let identifierEndIndex = chars.index(length, stepsFrom: lengthRange.endIndex, permittingEnd: true) else {<br>			return nil<br>		}<br>	<br>		let identifierRange = lengthRange.endIndex ..&lt; identifierEndIndex<br>		let remainderRange = chars.suffix(from: identifierRange.endIndex)<br>	<br>		return (String(chars[identifierRange]), String(chars[identifierRange]))<br>	}<br></p><p>By using these variants of the index-manipulation operations, the Collection API itself tells me where I need to handle bounds-check violations. Just like the failable `Int(_: String)` initializer, if I forget to check bounds after manipulating an index, the code will not type-check. That&#39;s a nice victory for correct semantics.<br></p><p>* * *<br></p><p>Incidentally, rather than having Valid&lt;Index&gt;, an alternative would be to have Unchecked&lt;Index&gt;. This would mark an index which had *not* been checked. You could use its `uncheckedIndex` property to access the index directly, or you could pass it to `Collection.check(_: Unchecked&lt;Index&gt;) -&gt; Index?` to perform the check.<br></p><p>This would not serve to eliminate redundant checks; it would merely get the type system to help you catch index-checking mistakes. You could, of course, perform the check and then invalidate the index with a mutation, but that&#39;s just as true today. I believe that, with aggressive enough optimization, this could be costless at runtime. *And* it would offer a way to provide the so-called &quot;safe indexing&quot; many people ask for: you could offer a subscript which took an Unchecked&lt;Index&gt; and returned an Optional&lt;Element&gt;.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>April 12, 2016 at 06:00:00pm</p></header><div class="content"><p>On Tue, Apr 12, 2016 at 4:27 AM, Brent Royal-Gordon<br>&lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; (On the other hand, it might be that I&#39;m conceiving of the purpose of `limitedBy` differently from you—I think of it as a safety measure, but you may be thinking of it specifically as an automatic truncation mechanism.)<br>&gt;&gt;<br>&gt;&gt; Hi Brent,<br>&gt;&gt;<br>&gt;&gt; Could you explain what kind of safety do you have in mind?  Swift will<br>&gt;&gt; guarantee memory safety even if you attempt to advance an index past<br>&gt;&gt; endIndex using the non-limiting overload.<br>&gt;<br>&gt; By &quot;safety&quot; here, I mean what I will call &quot;index safety&quot;: not accidentally using an index which would violate the preconditions of the methods or properties you are planning to use it with. I think it&#39;s too easy to accidentally overrun the permitted range of indices, and the API should help you avoid doing that.<br></p><p>Hi Brent,<br></p><p>Thank you for the explanation.  Assuming that I am interpreting you<br>correctly, I can&#39;t agree with your conclusions though.<br></p><p>I want to make a point that avoiding precondition violations by<br>removing preconditions is not the solution.  When you design an API,<br>it frequently has some constraints on the arguments or on the<br>execution environment, which, when violated, prevent the API from<br>performing the operation correctly.  As an API designer, you document<br>these constraints, but for the implementation you have two choices:<br></p><p>1.  You rigorously check the constraints, and return back some<br>indicator of the failure back to the caller (a nil return, a thrown<br>error etc.)  This decision makes the checks guaranteed, permanent,<br>documented part of your API behavior.  Users can now rely on these<br>checks for their normal logic.  In this case, the constraints are not<br>preconditions that the user is required to satisfy.<br></p><p>2.  You perform the operation anyway, relying on the caller to satisfy<br>the constraints.  The constraints become preconditions.  The<br>implementation can still check some of the constraints for either QoI<br>reasons or memory safety reasons.  Apart from preventing memory safety<br>violations, the implementation is not required to check the<br>constraints.<br></p><p>Now the question becomes, given a certain API design problem, how do<br>you make a choice between (1) and (2)?  In some cases, the answer is<br>clear:<br></p><p>- You can be forced to make your constraints into checks in API<br>behavior.  Example: a network i/o operation can fail.  This is a<br>completely normal thing that networks do sometimes, and the caller of<br>networking code should be expected to deal with networking failures,<br>or such code can&#39;t work on a real network.<br></p><p>- Some preconditions just can&#39;t be checked at all, or can&#39;t be checked<br>in time that is acceptable for the intended API purpose.  A trivial<br>example is UnsafePointer.pointee (we can&#39;t know whether the pointer<br>actually points to an instance of a correct type).  Another example is<br>sort predicates -- we can&#39;t check that the order defined by the<br>predicate is indeed a strict weak ordering for all values of the type.<br>We can check that the predicate defines a strict weak order for all<br>values in a particular dataset, but that requires O(n^2) time while<br>sort() complexity is O(n log n).<br></p><p>What about those cases when both (1) and (2) are implementable?  There<br>exists a trade-off between making the API &quot;resilient&quot; to programming<br>mistakes and hiding bugs by not stopping the application when an issue<br>happens.  We are very conservative in Swift about hiding errors.<br></p><p>If your APIs document that they check preconditions and trap if they<br>are not satisfied, then developers can rely on it, and you are not<br>allowed to weaken remove the checks in future.  If the app can recover<br>from a precondition failure, the recovery path just becomes a part of<br>the API behavior.  You can end up with a system where every API can<br>signal failure back to the calling code.  Now users have to handle<br>these failures.  There are two ways to handle them:<br></p><p>- force-unwrap, or &#39;try!&#39;.<br></p><p>- follow the advice of people who advocate never using force-unwrap<br>and &#39;try!&#39;.  The code that does so will likely have a lot of untested,<br>untestable, and dead branches that try to deal defensively with<br>situations that can&#39;t happen, but the API forces them to do so anyway.<br></p><p>I don&#39;t think either option leads to good code.  Thus, it is only<br>reasonable that we design the API based on a purpose that we intend<br>for this API.<br></p><p>Let&#39;s talk about how this applies to Collection.<br></p><p>For example, Collection APIs in question that work with indices are<br>primitive APIs that the rest of Collection APIs build upon.  One of<br>these APIs, basically the reason why indices exist, is<br>Collection.subscript(Index).  Today the behavior is unspecified if the<br>index is not valid.  If we follow the principle that you outlined:<br></p><p>&gt; not accidentally using an index which would violate the preconditions of the methods or properties you are planning to use it with.<br></p><p>Collection.subscript(Index) should return an optional.  Does this<br>match your expectations?  If so, how do you imagine even trivial<br>algorithms written?<br></p><p>for i in data.indices {<br>  data[i]! = data[i]! * 2   // assume that &#39;data[i]!&#39; can be made settable.<br>}<br></p><p>This code has two force-unwraps in it, despite being completely safe.<br>If you follow the &quot;never force-unwrap&quot; school of thought, then you end<br>up with two branches, and an error return from this function, that are<br>dead, untestable code.<br></p><p>If every API can fail, then you can&#39;t write useful code.  You need to<br>have some fundamental basis that you can rely on, and trust to operate<br>correctly.<br></p><p>The primitive Collection APIs are the basis of the Collection API.  If<br>they would be burdened with required range checks, then, just as you<br>are saying, the code would be full of redundant range checks.  For<br>example, UnsafeBufferPointer would also be burdened with them.<br></p><p>&gt; I think it&#39;s too easy to accidentally overrun the permitted range of indices, and the API should help you avoid doing that.<br></p><p>I wholeheartedly agree that APIs should help you to avoid making<br>mistakes.  There are multiple ways in which they can do so:<br></p><p>1.  (best) Make wrong code not compile.  Swift has a strong type<br>system that allows us to express complex constraints between types,<br>preventing some mistakes from being compiled.<br></p><p>2.  Check preconditions where it is possible (implementable), and when<br>the performance hit is reasonable, and deterministically trap as soon<br>as the violation was detected.<br></p><p>Unfortunately, validity of indices is a complex dynamic property of<br>the index-collection instance pair.  We can&#39;t encode it in the static<br>type system.  Consider the following example:<br></p><p>---<br>var a = [1, 2, 3]<br>let i: Int = a.check(a.startIndex)<br>a.removeAll()<br>a[i] // trap<br>---<br></p><p>Ok, mutation can invalidate indices.  Can immutability help?<br></p><p>---<br>let a = [1, 2, 3]<br>let b: [Int] = []<br>let i = a.check(a.startIndex)<br>b[i] // trap<br>---<br></p><p>Since it is not possible to encode the validity relationship in the<br>type system, we want to encourage these operations to trap if they<br>detect violations.<br></p><p>Now let&#39;s go back to the demangling algorithm.  We know that we have<br>weaknesses in the String parsing, and it is important for us to know<br>how well we are covering these use cases, and how we need to improve.<br>I think this is a great problem.<br></p><p>I implemented it using three different approaches:<br>https://gist.github.com/gribozavr/ed95f71b762d25bee2991dd9c0191b34<br></p><p>A high-level point that I&#39;d like to make is that when using<br>collections, you need to make use of algorithms to the biggest extent<br>possible.  This allows to express the semantics of your operation in<br>your domain using a high-level vocabulary.<br></p><p>I would like to draw attention to the following part:<br></p><p>// Approach #3: change Collection.index(_:stepsFrom:limitedBy:) to return an<br>// optional index.<br>//<br>// This method has to perform the range check to stop advancing the index when<br>// it reaches the limit. Currently it just discards the information about<br>// whether it reached the limit or not. Instead, it can cheaply return it to<br>// the caller.<br>//<br>// Note that the same logic does not apply to other<br>// Collection.index(_:stepsFrom:) overloads.<br></p><p>We will change the index(_:stepsFrom:limitedBy:) overload to return an<br>optional, and we will see what other implications it has, and how it<br>fits into the rest of the system.<br></p><p>Thanks again, Brent.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 12, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; I want to make a point that avoiding precondition violations by<br>&gt; removing preconditions is not the solution.  When you design an API,<br>&gt; it frequently has some constraints on the arguments or on the<br>&gt; execution environment, which, when violated, prevent the API from<br>&gt; performing the operation correctly.<br></p><p>I totally agree with this section, and I&#39;ve made similar arguments in the past on this list. For instance, I&#39;ve been critical in the past of suggestions that failable initializers should be removed, or that all subscripts should be Optional.<br></p><p>&gt; Let&#39;s talk about how this applies to Collection.<br>&gt; <br>&gt; For example, Collection APIs in question that work with indices are<br>&gt; primitive APIs that the rest of Collection APIs build upon.  One of<br>&gt; these APIs, basically the reason why indices exist, is<br>&gt; Collection.subscript(Index).  Today the behavior is unspecified if the<br>&gt; index is not valid.  If we follow the principle that you outlined:<br>&gt; <br>&gt;&gt; not accidentally using an index which would violate the preconditions of the methods or properties you are planning to use it with.<br>&gt; <br>&gt; Collection.subscript(Index) should return an optional.  Does this<br>&gt; match your expectations?  If so, how do you imagine even trivial<br>&gt; algorithms written?<br>&gt; <br>&gt; for i in data.indices {<br>&gt;  data[i]! = data[i]! * 2   // assume that &#39;data[i]!&#39; can be made settable.<br>&gt; }<br></p><p>Yes, I totally agree that `Collection.subscript(_: Index)` should not be Optional.<br></p><p>But I think that index-manipulation methods like `successor(of:)` are a different story. It is normal and expected that, when you alter an index, you will occasionally hit the boundaries of the collection. There certainly are cases where you know a particular index manipulation is safe, but most index manipulations need to be guarded by something like:<br></p><p>	while index &lt; collection.endIndex {<br>		let nextIndex = collection.successor(of: index)<br>		…<br>		index = nextIndex<br>	}<br></p><p>In these cases, it would be better if the `successor(of:)` method was designed in a way that acknowledged and encapsulated the bounds check that is usually required when it is used:<br></p><p>	while let nextIndex = collection.successor(of: index) {<br>		…<br>		index = nextIndex<br>	}<br></p><p>Given the difficulties of statically detecting index invalidation, I totally agree that (as you discussed in a section I&#39;ve snipped) we can&#39;t statically prove indexes are safe. But we can, at the point where we generate an index, easily check if that index is *currently* valid. And it&#39;s something that most callers will have to do anyway if we don&#39;t do it ourselves.<br></p><p>However…<br></p><p>&gt; I would like to draw attention to the following part:<br>&gt; <br>&gt; // Approach #3: change Collection.index(_:stepsFrom:limitedBy:) to return an<br>&gt; // optional index.<br>&gt; //<br>&gt; // This method has to perform the range check to stop advancing the index when<br>&gt; // it reaches the limit. Currently it just discards the information about<br>&gt; // whether it reached the limit or not. Instead, it can cheaply return it to<br>&gt; // the caller.<br>&gt; //<br>&gt; // Note that the same logic does not apply to other<br>&gt; // Collection.index(_:stepsFrom:) overloads.<br>&gt; <br>&gt; We will change the index(_:stepsFrom:limitedBy:) overload to return an<br>&gt; optional, and we will see what other implications it has, and how it<br>&gt; fits into the rest of the system.<br></p><p>I&#39;m glad to hear you&#39;ll evaluate this option, and I think it can give us both what we want from this API.<br></p><p>I think having the most high-level operations incorporate bounds checks, while the lower-level ones don&#39;t, is a good compromise. If we encourage people to use `index(_:stepsFrom:limitedBy:)` unless they know what they&#39;re doing, naïve clients will get an implicit bounds check, while sophisticated, speed-sensitive clients can use methods like `successor(of:)` which require them to check bounds manually.<br></p><p>(There might even be a case for offering bounds-checked `successor(of:limitedBy:)` and `predecessor(of:limitedBy:)` methods to give people bounds-checked alternatives to all three.)<br></p><p>&gt; Thanks again, Brent.<br></p><p>Thank you!<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 18, 2016 at 08:00:00am</p></header><div class="content"><p>Preventing indices of one collection being used by another collection can be done by using path dependent types like in Scala.<br></p><p>Then &#39;i&#39; would have type a.Index (where &#39;a&#39; is the instance!) and therefore b[i] would not typecheck as it would require an index of type b.Index<br></p><p>-Thorsten <br></p><p>&gt; Am 13.04.2016 um 03:39 schrieb Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Ok, mutation can invalidate indices.  Can immutability help?<br>&gt; <br>&gt; ---<br>&gt; let a = [1, 2, 3]<br>&gt; let b: [Int] = []<br>&gt; let i = a.check(a.startIndex)<br>&gt; b[i] // trap<br>&gt; ---<br>&gt; <br>&gt; Since it is not possible to encode the validity relationship in the<br>&gt; type system, we want to encourage these operations to trap if they<br>&gt; detect violations.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>April 17, 2016 at 11:00:00pm</p></header><div class="content"><p>On Sun, Apr 17, 2016 at 11:14 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; Preventing indices of one collection being used by another collection can be done by using path dependent types like in Scala.<br>&gt;<br>&gt; Then &#39;i&#39; would have type a.Index (where &#39;a&#39; is the instance!) and therefore b[i] would not typecheck as it would require an index of type b.Index<br></p><p>This is an interesting concept!  Would this work with slices?  You<br>should be able to use indices from slices with the base collection,<br>and vice-versa (when indices are in range).<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 18, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Am 18.04.2016 um 08:16 schrieb Dmitri Gribenko &lt;gribozavr at gmail.com&gt;:<br>&gt; <br>&gt;&gt; On Sun, Apr 17, 2016 at 11:14 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; Preventing indices of one collection being used by another collection can be done by using path dependent types like in Scala.<br>&gt;&gt; <br>&gt;&gt; Then &#39;i&#39; would have type a.Index (where &#39;a&#39; is the instance!) and therefore b[i] would not typecheck as it would require an index of type b.Index<br>&gt; <br>&gt; This is an interesting concept!  Would this work with slices?  You<br>&gt; should be able to use indices from slices with the base collection,<br>&gt; and vice-versa (when indices are in range).<br></p><p>Good point!<br></p><p>I just tried the following on scastie.org:<br></p><p>class Coll(val elements: List[Int]) {<br> <br>  case class Index(val value: Int)<br> <br>  def firstIndex: Index = Index(0)<br> <br>  def get(index: Index) = elements(index.value)<br> <br>  def slice(start: Index) = new Slice(start.value)<br> <br>  class Slice(val start: Int) {<br>    def firstIndex: Index = Index(start)<br>    def get(index: Index) = elements(index.value)<br>  }<br> <br>}<br> <br>object Main extends App {<br> <br>  val a = new Coll(List(1, 2, 3))<br>  val b = new Coll(List(1, 2, 3))<br> <br>  val i = a.firstIndex<br> <br>  a.get(i)<br>  // b.get(i) // type error<br> <br>  val s = a.slice(a.firstIndex)<br>  s.get(a.firstIndex) // allowed!<br> <br>  val s2 = b.slice(b.firstIndex)<br>  s2.get(b.firstIndex)<br>  // s2.get(a.firstIndex) // type error<br>}<br></p><p>So it seems that having Slice as nested class (which has an implicit reference to the collection instance) results in a slice to have the same index type as its parent collection, so that it indeed works as intended.<br></p><p>Now the question is whether this would fit the design of slices in Swift and whether/how path dependent types would fit nicely into the design of Swift.<br></p><p>-Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160418/0ca479b0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 19, 2016 at 08:00:00am</p></header><div class="content"><p>A Scala like new-Iterator pattern, using path-dependent typing, might be:<br></p><p>struct Range&lt;T: Comparable&gt; { ... }<br>func ..&lt; &lt;T: Comparable&gt;(lowest: T, highest: T) { ... }<br></p><p>struct Array&lt;T&gt;: Collection {<br></p><p>static struct Iterator { ... } // Note static<br></p><p>...<br></p><p>func next(iterator: inout Iterator) -&gt; Element? { ... }<br></p><p>subscript(range: Range&lt;Int&gt;) -&gt; [E] { ... }<br></p><p>}<br></p><p><br>With new iterators, Scala style, the following is legal:<br></p><p>let a = [Int]()<br>let b = [Int]()<br>let i = a.Iterator() // Create an instance of an inner type, type<br>associated with an instance of its outer type<br>let aE = a.next(&amp;i)<br>let r = 1 ..&lt; 2<br>let aS = a[r]<br>let bS = b[r] // OK since `r` is not associated with `a` because `Range` is<br>not nested within `Array`<br></p><p><br>but not<br></p><p>let bE = b.next(&amp;i) // Type error because `i` is associated with `a` not `b`<br></p><p><br>The type `Iterator` is static because it does not capture the enclosing<br>type instance, the enclosing type instance, `a` in the example, is solely<br>used for typing. Non-static inner types capture an instance of their outer<br>type.<br></p><p>The other interesting pattern using inner types is old-style<br>iterators, conventional external iterators:<br></p><p><br>struct Array&lt;T&gt;: Collection {<br></p><p>struct Iterator { ... } // Note *not* static, therefore captures outer<br>instance when created<br></p><p>...<br></p><p>}<br></p><p><br>With external iterators, Scala style, the following is legal:<br></p><p>let a = [Int]()<br>let i = a.Iterator() // Create an instance of an inner type, *capturing*<br>and type associating with an instance of its outer type<br>let aE = i.next()<br></p><p>Whilst this pattern in use is very similar to what Swift currently does it<br>is a lot easier to optimise because an escape analysis can tell if the<br>capture of `a` by `i` needs to increment the reference counting or not. The<br>compiler knows that `i` has captured `a` which allows this optimisation. I<br>*think* that Java&#39;s JVM&#39;s escape analysis does this optimisation.<br></p><p>Assuming that Swift could optimise inner types then this would allow<br>retention of traditional external iterators.<br></p><p>On Monday, 18 April 2016, Dmitri Gribenko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Sun, Apr 17, 2016 at 11:14 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt;<br>&gt; wrote:<br>&gt; &gt; Preventing indices of one collection being used by another collection<br>&gt; can be done by using path dependent types like in Scala.<br>&gt; &gt;<br>&gt; &gt; Then &#39;i&#39; would have type a.Index (where &#39;a&#39; is the instance!) and<br>&gt; therefore b[i] would not typecheck as it would require an index of type<br>&gt; b.Index<br>&gt;<br>&gt; This is an interesting concept!  Would this work with slices?  You<br>&gt; should be able to use indices from slices with the base collection,<br>&gt; and vice-versa (when indices are in range).<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160419/e99ceb5b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>April 12, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 12, 2016, at 4:15 AM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Mon, Apr 11, 2016 at 9:56 PM, Brent Royal-Gordon via<br>&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; (On the other hand, it might be that I&#39;m conceiving of the purpose of `limitedBy` differently from you—I think of it as a safety measure, but you may be thinking of it specifically as an automatic truncation mechanism.)<br>&gt; <br>&gt; Hi Brent,<br>&gt; <br>&gt; Could you explain what kind of safety do you have in mind?  Swift will<br>&gt; guarantee memory safety even if you attempt to advance an index past<br>&gt; endIndex using the non-limiting overload.<br></p><p>One challenge that I&#39;ve run into is that the `limitedBy` methods throw away one bit of information—namely, did I move as far as I requested or not? Example:<br></p><p>let j = c.index(10, stepsFrom: i, limitedBy: c.endIndex)<br></p><p>There&#39;s no way to interpolate the answer to that question efficiently in a non-random-access collection. If `j` is equal to `c.endIndex`, that could be because `c.endIndex` is ten steps after `i` *or* because the limit kicked in, and without checking `c.distance(from: i, to: j)` there&#39;s no way to know for sure.<br></p><p>If the `limitedBy` methods returned an optional index, we&#39;d get all the information that the index-moving algorithm finds (let&#39;s hear it for the Law of Useful Return!). With that API, we could decide whether to use the returned index or not:<br></p><p>// Use the resulting index no matter what:<br>let i = c.index(10, stepsFrom: c.startIndex, limitedBy: c.endIndex) ?? c.endIndex<br>let prefix = c.prefix(upTo: i)<br></p><p>// Only use the result if it wasn&#39;t limited:<br>if let j = c.index(10, stepsFrom: i, limitedBy: c.endIndex) {<br>    let sub = c[i..&lt;j]      // sub.count == 10<br>} else {<br>    // not enough elements...<br>}<br></p><p>// &quot;Safe&quot; successor:<br>if let j = c.index(1, stepsFrom: i, limitedBy: c.endIndex) {<br>    // ...<br>}<br></p><p>Nate<br></p><p><br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160412/0a683559/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 12, 2016 at 02:00:00pm</p></header><div class="content"><p>on Mon Apr 11 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br></p><p>&gt;&gt;&gt; If these types are for implementation sharing, should they be<br>&gt;&gt;&gt; underscored to discourage their use? Or is the position they occupy in<br>&gt;&gt;&gt; the type hierarchy important because Range and ClosedRange will<br>&gt;&gt;&gt; eventually occupy them?<br>&gt;&gt; <br>&gt;&gt; Underscoring hides names from users completely, and IMO that would not<br>&gt;&gt; be appropriate here.  If we underscored them, it would be mysterious<br>&gt;&gt; where an implementation of various methods came from.<br>&gt;<br>&gt; If the concrete types show these members, does it matter that they<br>&gt; actually came from a protocol?<br></p><p>I don&#39;t know; would the concrete types show these members?<br></p><p>&gt;&gt;&gt; On the other hand, it&#39;s not like the SubSequence subscript now takes a<br>&gt;&gt;&gt; RangeProtocol. Should it?<br>&gt;&gt; <br>&gt;&gt; No; subscript can&#39;t be generic (language limitation).<br>&gt;<br>&gt; Right, and RangeProtocol isn&#39;t existential. Ouch.<br>&gt;<br>&gt;&gt;&gt;&gt; func successor(of i: Index) -&gt; Index<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Two things:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. I would really like a version of this which returns Optional and is<br>&gt;&gt;&gt; guaranteed to go `nil` once it hits `endIndex`. <br>&gt;&gt; <br>&gt;&gt; The primary question to answer when exploring this idea is, IMO, “what<br>&gt;&gt; does that do to the code in algorithms?”  I can&#39;t imagine writing binary<br>&gt;&gt; search, partition, or rotate if I had to check for nil every time I<br>&gt;&gt; moved an index.<br>&gt;<br>&gt; If you&#39;re confident you&#39;re remaining in bounds, you should<br>&gt; force-unwrap it.<br></p><p>s/check for nil/force unwrap/<br></p><p>&gt;&gt;&gt; There can be a non-optional version too, or it might even be a feature<br>&gt;&gt;&gt; of the `index` family of methods instead of `successor` itself, but I<br>&gt;&gt;&gt; think it would be valuable to let the collection worry about the<br>&gt;&gt;&gt; bounds check.<br>&gt;&gt; <br>&gt;&gt; Why would that be valuable?<br>&gt;&gt; <br>&gt;&gt;&gt; It seems silly to check the index before calling `successor(of:)` when<br>&gt;&gt;&gt; `successor(of:)` is going to immediately perform the same check again<br>&gt;&gt;&gt; as a precondition.<br>&gt;&gt; <br>&gt;&gt; Preconditions are not necessarily checked.  We don&#39;t promise to trap<br>&gt;&gt; every precondition violation.  We promise memory and type safety in the<br>&gt;&gt; absence of data races, and some precondition failures will trap in order<br>&gt;&gt; to ensure that.  Others will trap, where we think it is affordable, just<br>&gt;&gt; to provide a better programmer experience.<br>&gt;<br>&gt; I understand that, but many—perhaps most—clients of APIs like<br>&gt; `successor(of:)` will need to perform a bounds check. <br></p><p>Why do you say so?<br></p><p>&gt; I think we would be better off if the check were implicit in the<br>&gt; call. That would force all clients, or at least all clients which used<br>&gt; the bounds-checking variants (which would be encouraged), to<br>&gt; explicitly handle out-of-bounds conditions, in much the same way that<br>&gt; `index(of:)` forces its clients to explicitly handle the possibility<br>&gt; that a matching element might not exist, rather than returning<br>&gt; `endIndex` (which would be easier).<br></p><p>I think we agree that the proposed index method that takes a limit<br>should return optional.  Dmitri&#39;s going to explain more in his response.<br></p><p>&gt;&gt;&gt; 	collection.index(5, from: i)<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think this one reads clearly enough.<br>&gt;<br>&gt; &quot;The index 5 from i&quot; reads fine to me, but I guess that&#39;s a matter of opinion.<br>&gt;<br>&gt;&gt;&gt; 	collection.traveling(5, from: i)<br>&gt;&gt;&gt; 	collection.striding(5, from: i)<br>&gt;&gt;&gt; 	collection.advancing(i, by: 5)<br>&gt;&gt; <br>&gt;&gt; None of the “ing” names work, IMO because that suffix suggests you&#39;re<br>&gt;&gt; returning a modified version of the receiver.<br>&gt;<br>&gt; Huh, that clarifies something. How about the non-`ing` variants?<br>&gt;<br>&gt; 	collection.travel(5, from: i)<br>&gt; 	collection.stride(5, from: i)<br>&gt; 	collection.advance(i, by: 5)<br></p><p>Active verb phrases are reserved for methods with side-effects according<br>to the API guidelines.<br></p><p>&gt; I&#39;d say `stride` might be an attractive nuisance in this form<br>&gt; (although if Strideable&#39;s public face becomes `Self.striding(by:)`,<br>&gt; only to Swift 2 users) but the others look fine to me.<br></p><p>I&#39;m going to leave the rest of this for Dmitri, at least for the time<br>being.<br>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 12, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt;&gt; Huh, that clarifies something. How about the non-`ing` variants?<br>&gt;&gt; <br>&gt;&gt; 	collection.travel(5, from: i)<br>&gt;&gt; 	collection.stride(5, from: i)<br>&gt;&gt; 	collection.advance(i, by: 5)<br>&gt; <br>&gt; Active verb phrases are reserved for methods with side-effects according<br>&gt; to the API guidelines.<br></p><p>Is there *any* way of using a verb to indicate an argument is being modified? If not, I think that&#39;s a serious omission in the API guidelines.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 12, 2016 at 05:00:00pm</p></header><div class="content"><p>on Tue Apr 12 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br></p><p>&gt;&gt;&gt; Huh, that clarifies something. How about the non-`ing` variants?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	collection.travel(5, from: i)<br>&gt;&gt;&gt; 	collection.stride(5, from: i)<br>&gt;&gt;&gt; 	collection.advance(i, by: 5)<br>&gt;&gt; <br>&gt;&gt; Active verb phrases are reserved for methods with side-effects according<br>&gt;&gt; to the API guidelines.<br>&gt;<br>&gt; Is there *any* way of using a verb to indicate an argument is being<br>&gt; modified? If not, I think that&#39;s a serious omission in the API<br>&gt; guidelines.<br></p><p><br>  x.modify(&amp;y)<br></p><p>seems to work just fine.<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
