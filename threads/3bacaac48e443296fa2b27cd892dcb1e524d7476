<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/97f4283ae7fdeaa490e80e6118ed5e68?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Michael Savich</string> &lt;savichmichael at icloud.com&gt;<p>August 14, 2016 at 06:00:00pm</p></header><div class="content"><p>Back in Swift 1.0, subscripting a String was easy, you could just use subscripting in a very Python like way. But now, things are a bit more complicated. I recognize why we need syntax like str.startIndex.advancedBy(x) but it has its downsides. Namely, it makes things hard on beginners. If one of Swift&#39;s goals is to make it a great first language, this syntax fights that. Imagine having to explain Unicode and character size to an 8 year old. This is doubly problematic because String manipulation is one of the first things new coders might want to do. <br></p><p>What about having an InternalString subclass that only supports one encoding, allowing it to be subscripted with Ints? The idea is that an InternalString is for Strings that are more or less hard coded into the app. Dictionary keys, enum raw values, that kind of stuff. This also has the added benefit of forcing the programmer to think about what the String is being used for. Is it user facing? Or is it just for internal use? And of course, it makes code dealing with String manipulation much more concise and readable.<br></p><p>It follows that something like this would need to be entered as a literal to make it as easy as using String. One way would be to make all String literals InternalStrings, but that sounds far too drastic. Maybe appending an exclamation point like &quot;this&quot;! Or even just wrapping the whole thing in exclamation marks like !&quot;this&quot;! Of course, we could go old school and write it like @&quot;this&quot; …That last one is a joke.<br></p><p>I&#39;ll be the first to admit I&#39;m way in over my head here, so I&#39;m very open to suggestions and criticism. Thanks!<br></p><p>Sent from my iPad<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160814/3bac7476/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 15, 2016 at 12:00:00pm</p></header><div class="content"><p>On Sun, Aug 14, 2016 at 5:41 PM, Michael Savich via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Back in Swift 1.0, subscripting a String was easy, you could just use<br>&gt; subscripting in a very Python like way. But now, things are a bit more<br>&gt; complicated. I recognize why we need syntax like<br>&gt; str.startIndex.advancedBy(x) but it has its downsides. Namely, it makes<br>&gt; things hard on beginners. If one of Swift&#39;s goals is to make it a great<br>&gt; first language, this syntax fights that. Imagine having to explain Unicode<br>&gt; and character size to an 8 year old. This is doubly problematic because<br>&gt; String manipulation is one of the first things new coders might want to do.<br>&gt;<br>&gt; What about having an InternalString subclass that only supports one<br>&gt; encoding, allowing it to be subscripted with Ints? The idea is that an<br>&gt; InternalString is for Strings that are more or less hard coded into the<br>&gt; app. Dictionary keys, enum raw values, that kind of stuff. This also has<br>&gt; the added benefit of forcing the programmer to think about what the String<br>&gt; is being used for. Is it user facing? Or is it just for internal use? And<br>&gt; of course, it makes code dealing with String manipulation much more concise<br>&gt; and readable.<br>&gt;<br>&gt; It follows that something like this would need to be entered as a literal<br>&gt; to make it as easy as using String. One way would be to make all String<br>&gt; literals InternalStrings, but that sounds far too drastic. Maybe appending<br>&gt; an exclamation point like &quot;this&quot;! Or even just wrapping the whole thing in<br>&gt; exclamation marks like !&quot;this&quot;! Of course, we could go old school and write<br>&gt; it like @&quot;this&quot; …That last one is a joke.<br>&gt;<br>&gt; I&#39;ll be the first to admit I&#39;m way in over my head here, so I&#39;m very open<br>&gt; to suggestions and criticism. Thanks!<br>&gt;<br></p><p>I can sympathize, but this is tricky.<br></p><p>Fundamentally, if it&#39;s going to be a learning and teaching issue, then this<br>&quot;easy&quot; string should be the default. That is to say, if I write `var a =<br>&quot;Hello, world!&quot;`, then `a` should be inferred to be of type InternalString<br>or EasyString, whatever you want to call it.<br></p><p>But, we also want Swift to support Unicode by default, and we want that<br>support to do things The Right Way(TM) by default. In other words, a user<br>should not have to reach for a special type in order to handle arbitrary<br>strings correctly, and I should be able to reassign `a = &quot;你好&quot;` and have<br>things work as expected. So, we also can&#39;t have the &quot;easy&quot; string type be<br>the default...<br></p><p>I can&#39;t think of a way to square that circle.<br></p><p><br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160815/9f1ba158/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>August 15, 2016 at 10:00:00am</p></header><div class="content"><p>I agree with both points of view. I think we need to bring back subscripting on strings which does the thing people would most commonly expect.<br></p><p>I would say that the subscripts indexes should correspond to a visual glyph. This seems reasonable to me for most character sets like Roman, Cyrillic, Chinese. There is some doubt in my mind for things like subscripted Japanese or connected (ligatured?) languages like Arabic, Hindi or Thai.<br></p><p>-Kenny<br></p><p><br>&gt; On Aug 15, 2016, at 10:42 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Sun, Aug 14, 2016 at 5:41 PM, Michael Savich via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Back in Swift 1.0, subscripting a String was easy, you could just use subscripting in a very Python like way. But now, things are a bit more complicated. I recognize why we need syntax like str.startIndex.advancedBy(x) but it has its downsides. Namely, it makes things hard on beginners. If one of Swift&#39;s goals is to make it a great first language, this syntax fights that. Imagine having to explain Unicode and character size to an 8 year old. This is doubly problematic because String manipulation is one of the first things new coders might want to do. <br>&gt; <br>&gt; What about having an InternalString subclass that only supports one encoding, allowing it to be subscripted with Ints? The idea is that an InternalString is for Strings that are more or less hard coded into the app. Dictionary keys, enum raw values, that kind of stuff. This also has the added benefit of forcing the programmer to think about what the String is being used for. Is it user facing? Or is it just for internal use? And of course, it makes code dealing with String manipulation much more concise and readable.<br>&gt; <br>&gt; It follows that something like this would need to be entered as a literal to make it as easy as using String. One way would be to make all String literals InternalStrings, but that sounds far too drastic. Maybe appending an exclamation point like &quot;this&quot;! Or even just wrapping the whole thing in exclamation marks like !&quot;this&quot;! Of course, we could go old school and write it like @&quot;this&quot; …That last one is a joke.<br>&gt; <br>&gt; I&#39;ll be the first to admit I&#39;m way in over my head here, so I&#39;m very open to suggestions and criticism. Thanks!<br>&gt; <br>&gt; I can sympathize, but this is tricky.<br>&gt; <br>&gt; Fundamentally, if it&#39;s going to be a learning and teaching issue, then this &quot;easy&quot; string should be the default. That is to say, if I write `var a = &quot;Hello, world!&quot;`, then `a` should be inferred to be of type InternalString or EasyString, whatever you want to call it.<br>&gt; <br>&gt; But, we also want Swift to support Unicode by default, and we want that support to do things The Right Way(TM) by default. In other words, a user should not have to reach for a special type in order to handle arbitrary strings correctly, and I should be able to reassign `a = &quot;你好&quot;` and have things work as expected. So, we also can&#39;t have the &quot;easy&quot; string type be the default...<br>&gt; <br>&gt; I can&#39;t think of a way to square that circle.<br>&gt;  <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>August 15, 2016 at 09:00:00pm</p></header><div class="content"><p>The major problem with this approach is that visual glyphs themselves have one level of variable-length encoding, and they sit on top of another variable-length encoding used to represent the Unicode characters (Swift-native Strings are currently encoded as UTF-8). For instance, the visual glyph 🇺🇸 is the the result of putting side-by-side the Unicode characters 🇺 and  🇸(&quot;REGIONAL INDICATOR SYMBOL LETTER U&quot; and &quot;REGIONAL INDICATOR SYMBOL LETTER S&quot;), which are themselves encoded as UTF-8 using 4 bytes each. A design in which you can &quot;just write&quot; string[4544] hides the fact that indexing is a linear-time operation that needs to recompose UTF-8 characters and then recompose visual glyphs on top of that.<br></p><p>Generally speaking, I *think* that I agree that human-geared &quot;long string&quot; on which you probably won&#39;t need random access, and machine-geared smaller strings that encode a command, could benefit from not being considered the same fundamental thing. However, I&#39;m also afraid that this will end with more applications and websites that think that first names only contain 7-bit-clean characters in the A-Z range. (I live in the US and I can attest that this is still very common.)<br></p><p>You could make a point too that better facilities to parse strings would probably address this issue.<br></p><p>Félix<br></p><p>&gt; Le 15 août 2016 à 10:52:02, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I agree with both points of view. I think we need to bring back subscripting on strings which does the thing people would most commonly expect.<br>&gt; <br>&gt; I would say that the subscripts indexes should correspond to a visual glyph. This seems reasonable to me for most character sets like Roman, Cyrillic, Chinese. There is some doubt in my mind for things like subscripted Japanese or connected (ligatured?) languages like Arabic, Hindi or Thai.<br>&gt; <br>&gt; -Kenny<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 15, 2016, at 10:42 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Sun, Aug 14, 2016 at 5:41 PM, Michael Savich via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Back in Swift 1.0, subscripting a String was easy, you could just use subscripting in a very Python like way. But now, things are a bit more complicated. I recognize why we need syntax like str.startIndex.advancedBy(x) but it has its downsides. Namely, it makes things hard on beginners. If one of Swift&#39;s goals is to make it a great first language, this syntax fights that. Imagine having to explain Unicode and character size to an 8 year old. This is doubly problematic because String manipulation is one of the first things new coders might want to do. <br>&gt;&gt; <br>&gt;&gt; What about having an InternalString subclass that only supports one encoding, allowing it to be subscripted with Ints? The idea is that an InternalString is for Strings that are more or less hard coded into the app. Dictionary keys, enum raw values, that kind of stuff. This also has the added benefit of forcing the programmer to think about what the String is being used for. Is it user facing? Or is it just for internal use? And of course, it makes code dealing with String manipulation much more concise and readable.<br>&gt;&gt; <br>&gt;&gt; It follows that something like this would need to be entered as a literal to make it as easy as using String. One way would be to make all String literals InternalStrings, but that sounds far too drastic. Maybe appending an exclamation point like &quot;this&quot;! Or even just wrapping the whole thing in exclamation marks like !&quot;this&quot;! Of course, we could go old school and write it like @&quot;this&quot; …That last one is a joke.<br>&gt;&gt; <br>&gt;&gt; I&#39;ll be the first to admit I&#39;m way in over my head here, so I&#39;m very open to suggestions and criticism. Thanks!<br>&gt;&gt; <br>&gt;&gt; I can sympathize, but this is tricky.<br>&gt;&gt; <br>&gt;&gt; Fundamentally, if it&#39;s going to be a learning and teaching issue, then this &quot;easy&quot; string should be the default. That is to say, if I write `var a = &quot;Hello, world!&quot;`, then `a` should be inferred to be of type InternalString or EasyString, whatever you want to call it.<br>&gt;&gt; <br>&gt;&gt; But, we also want Swift to support Unicode by default, and we want that support to do things The Right Way(TM) by default. In other words, a user should not have to reach for a special type in order to handle arbitrary strings correctly, and I should be able to reassign `a = &quot;你好&quot;` and have things work as expected. So, we also can&#39;t have the &quot;easy&quot; string type be the default...<br>&gt;&gt; <br>&gt;&gt; I can&#39;t think of a way to square that circle.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160815/4caf0a46/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>August 17, 2016 at 09:00:00am</p></header><div class="content"><p>I understand that the most friendly approach may not be the most efficient, but that’s not what I’m pushing for. I’m pushing for &quot;does the thing people would most commonly expect”. Take a first-time programmer who reads any (human) language, and that is what they would expect.<br></p><p>Why couldn’t String’s internal storage format be glyph-based? If I were, say, writing a text editor, it would certainly be the easiest and most efficient format to work in.<br></p><p>-Kenny<br></p><p><br>&gt; On Aug 15, 2016, at 9:20 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; The major problem with this approach is that visual glyphs themselves have one level of variable-length encoding, and they sit on top of another variable-length encoding used to represent the Unicode characters (Swift-native Strings are currently encoded as UTF-8). For instance, the visual glyph 🇺🇸 is the the result of putting side-by-side the Unicode characters 🇺 and  🇸(&quot;REGIONAL INDICATOR SYMBOL LETTER U&quot; and &quot;REGIONAL INDICATOR SYMBOL LETTER S&quot;), which are themselves encoded as UTF-8 using 4 bytes each. A design in which you can &quot;just write&quot; string[4544] hides the fact that indexing is a linear-time operation that needs to recompose UTF-8 characters and then recompose visual glyphs on top of that.<br>&gt; <br>&gt; Generally speaking, I *think* that I agree that human-geared &quot;long string&quot; on which you probably won&#39;t need random access, and machine-geared smaller strings that encode a command, could benefit from not being considered the same fundamental thing. However, I&#39;m also afraid that this will end with more applications and websites that think that first names only contain 7-bit-clean characters in the A-Z range. (I live in the US and I can attest that this is still very common.)<br>&gt; <br>&gt; You could make a point too that better facilities to parse strings would probably address this issue.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 15 août 2016 à 10:52:02, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I agree with both points of view. I think we need to bring back subscripting on strings which does the thing people would most commonly expect.<br>&gt;&gt; <br>&gt;&gt; I would say that the subscripts indexes should correspond to a visual glyph. This seems reasonable to me for most character sets like Roman, Cyrillic, Chinese. There is some doubt in my mind for things like subscripted Japanese or connected (ligatured?) languages like Arabic, Hindi or Thai.<br>&gt;&gt; <br>&gt;&gt; -Kenny<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 15, 2016, at 10:42 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sun, Aug 14, 2016 at 5:41 PM, Michael Savich via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Back in Swift 1.0, subscripting a String was easy, you could just use subscripting in a very Python like way. But now, things are a bit more complicated. I recognize why we need syntax like str.startIndex.advancedBy(x) but it has its downsides. Namely, it makes things hard on beginners. If one of Swift&#39;s goals is to make it a great first language, this syntax fights that. Imagine having to explain Unicode and character size to an 8 year old. This is doubly problematic because String manipulation is one of the first things new coders might want to do. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What about having an InternalString subclass that only supports one encoding, allowing it to be subscripted with Ints? The idea is that an InternalString is for Strings that are more or less hard coded into the app. Dictionary keys, enum raw values, that kind of stuff. This also has the added benefit of forcing the programmer to think about what the String is being used for. Is it user facing? Or is it just for internal use? And of course, it makes code dealing with String manipulation much more concise and readable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It follows that something like this would need to be entered as a literal to make it as easy as using String. One way would be to make all String literals InternalStrings, but that sounds far too drastic. Maybe appending an exclamation point like &quot;this&quot;! Or even just wrapping the whole thing in exclamation marks like !&quot;this&quot;! Of course, we could go old school and write it like @&quot;this&quot; …That last one is a joke.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ll be the first to admit I&#39;m way in over my head here, so I&#39;m very open to suggestions and criticism. Thanks!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can sympathize, but this is tricky.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fundamentally, if it&#39;s going to be a learning and teaching issue, then this &quot;easy&quot; string should be the default. That is to say, if I write `var a = &quot;Hello, world!&quot;`, then `a` should be inferred to be of type InternalString or EasyString, whatever you want to call it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But, we also want Swift to support Unicode by default, and we want that support to do things The Right Way(TM) by default. In other words, a user should not have to reach for a special type in order to handle arbitrary strings correctly, and I should be able to reassign `a = &quot;你好&quot;` and have things work as expected. So, we also can&#39;t have the &quot;easy&quot; string type be the default...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can&#39;t think of a way to square that circle.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>August 17, 2016 at 11:00:00am</p></header><div class="content"><p>It&#39;s 2016, &quot;the thing people would most commonly expect&quot;<br>impossible-to-screw-up Unicode support that&#39;s performance. Optimizing<br>developer experience for beginning developers is just going to lead to<br>software that screws up in situations the developer doesn&#39;t anticipate,<br>as F+¬lix notes above.<br></p><p>Zachary<br></p><p>On Wed, Aug 17, 2016, at 09:40 AM, Kenny Leung via swift-evolution<br>wrote:<br>&gt; I understand that the most friendly approach may not be the most<br>&gt; efficient, but that’s not what I’m pushing for. I’m pushing for &quot;does the<br>&gt; thing people would most commonly expect”. Take a first-time programmer<br>&gt; who reads any (human) language, and that is what they would expect.<br>&gt; <br>&gt; Why couldn’t String’s internal storage format be glyph-based? If I were,<br>&gt; say, writing a text editor, it would certainly be the easiest and most<br>&gt; efficient format to work in.<br>&gt; <br>&gt; -Kenny<br>&gt; <br>&gt; <br>&gt; &gt; On Aug 15, 2016, at 9:20 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; The major problem with this approach is that visual glyphs themselves have one level of variable-length encoding, and they sit on top of another variable-length encoding used to represent the Unicode characters (Swift-native Strings are currently encoded as UTF-8). For instance, the visual glyph 🇺🇸 is the the result of putting side-by-side the Unicode characters 🇺 and  🇸(&quot;REGIONAL INDICATOR SYMBOL LETTER U&quot; and &quot;REGIONAL INDICATOR SYMBOL LETTER S&quot;), which are themselves encoded as UTF-8 using 4 bytes each. A design in which you can &quot;just write&quot; string[4544] hides the fact that indexing is a linear-time operation that needs to recompose UTF-8 characters and then recompose visual glyphs on top of that.<br>&gt; &gt; <br>&gt; &gt; Generally speaking, I *think* that I agree that human-geared &quot;long string&quot; on which you probably won&#39;t need random access, and machine-geared smaller strings that encode a command, could benefit from not being considered the same fundamental thing. However, I&#39;m also afraid that this will end with more applications and websites that think that first names only contain 7-bit-clean characters in the A-Z range. (I live in the US and I can attest that this is still very common.)<br>&gt; &gt; <br>&gt; &gt; You could make a point too that better facilities to parse strings would probably address this issue.<br>&gt; &gt; <br>&gt; &gt; Félix<br>&gt; &gt; <br>&gt; &gt;&gt; Le 15 août 2016 à 10:52:02, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I agree with both points of view. I think we need to bring back subscripting on strings which does the thing people would most commonly expect.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I would say that the subscripts indexes should correspond to a visual glyph. This seems reasonable to me for most character sets like Roman, Cyrillic, Chinese. There is some doubt in my mind for things like subscripted Japanese or connected (ligatured?) languages like Arabic, Hindi or Thai.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; -Kenny<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt;&gt; On Aug 15, 2016, at 10:42 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; On Sun, Aug 14, 2016 at 5:41 PM, Michael Savich via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt; Back in Swift 1.0, subscripting a String was easy, you could just use subscripting in a very Python like way. But now, things are a bit more complicated. I recognize why we need syntax like str.startIndex.advancedBy(x) but it has its downsides. Namely, it makes things hard on beginners. If one of Swift&#39;s goals is to make it a great first language, this syntax fights that. Imagine having to explain Unicode and character size to an 8 year old. This is doubly problematic because String manipulation is one of the first things new coders might want to do. <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; What about having an InternalString subclass that only supports one encoding, allowing it to be subscripted with Ints? The idea is that an InternalString is for Strings that are more or less hard coded into the app. Dictionary keys, enum raw values, that kind of stuff. This also has the added benefit of forcing the programmer to think about what the String is being used for. Is it user facing? Or is it just for internal use? And of course, it makes code dealing with String manipulation much more concise and readable.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; It follows that something like this would need to be entered as a literal to make it as easy as using String. One way would be to make all String literals InternalStrings, but that sounds far too drastic. Maybe appending an exclamation point like &quot;this&quot;! Or even just wrapping the whole thing in exclamation marks like !&quot;this&quot;! Of course, we could go old school and write it like @&quot;this&quot; …That last one is a joke.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; I&#39;ll be the first to admit I&#39;m way in over my head here, so I&#39;m very open to suggestions and criticism. Thanks!<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; I can sympathize, but this is tricky.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Fundamentally, if it&#39;s going to be a learning and teaching issue, then this &quot;easy&quot; string should be the default. That is to say, if I write `var a = &quot;Hello, world!&quot;`, then `a` should be inferred to be of type InternalString or EasyString, whatever you want to call it.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; But, we also want Swift to support Unicode by default, and we want that support to do things The Right Way(TM) by default. In other words, a user should not have to reach for a special type in order to handle arbitrary strings correctly, and I should be able to reassign `a = &quot;你好&quot;` and have things work as expected. So, we also can&#39;t have the &quot;easy&quot; string type be the default...<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; I can&#39;t think of a way to square that circle.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Sent from my iPad<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>August 17, 2016 at 12:00:00pm</p></header><div class="content"><p>It seems to me that UTF-8 is the best choice to encode strings in English and English-like character sets for storage, but it’s not clear that it is the most useful or performant internal representation for working with strings. In my opinion, conflating the preferred storage format and the best internal representation is not the proper thing to do. Picking the right internal storage format should be evaluated based on its own criteria. Even as an experienced programmer, I assert that the most useful indexing system is glyph based.<br></p><p>In Félix’s case, I would expect to have to ask for a mail-friendly representation of his name, just like you have to ask for a filesystem-friendly representation of a filename regardless of what the internal representation is. Just because you are using UTF-8 as the internal format, it does not mean that universal support is guaranteed.<br></p><p>In response to this statement: “Optimizing developer experience for beginning developers is just going to lead to software that screws…”, the current system trips up not only beginning developers, but is different from pretty much every programming language in my experience.<br></p><p>-Kenny<br></p><p><br>&gt; On Aug 17, 2016, at 11:48 AM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It&#39;s 2016, &quot;the thing people would most commonly expect&quot;<br>&gt; impossible-to-screw-up Unicode support that&#39;s performance. Optimizing<br>&gt; developer experience for beginning developers is just going to lead to<br>&gt; software that screws up in situations the developer doesn&#39;t anticipate,<br>&gt; as F+¬lix notes above.<br>&gt; <br>&gt; Zachary<br>&gt; <br>&gt; On Wed, Aug 17, 2016, at 09:40 AM, Kenny Leung via swift-evolution<br>&gt; wrote:<br>&gt;&gt; I understand that the most friendly approach may not be the most<br>&gt;&gt; efficient, but that’s not what I’m pushing for. I’m pushing for &quot;does the<br>&gt;&gt; thing people would most commonly expect”. Take a first-time programmer<br>&gt;&gt; who reads any (human) language, and that is what they would expect.<br>&gt;&gt; <br>&gt;&gt; Why couldn’t String’s internal storage format be glyph-based? If I were,<br>&gt;&gt; say, writing a text editor, it would certainly be the easiest and most<br>&gt;&gt; efficient format to work in.<br>&gt;&gt; <br>&gt;&gt; -Kenny<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 15, 2016, at 9:20 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The major problem with this approach is that visual glyphs themselves have one level of variable-length encoding, and they sit on top of another variable-length encoding used to represent the Unicode characters (Swift-native Strings are currently encoded as UTF-8). For instance, the visual glyph 🇺🇸 is the the result of putting side-by-side the Unicode characters 🇺 and  🇸(&quot;REGIONAL INDICATOR SYMBOL LETTER U&quot; and &quot;REGIONAL INDICATOR SYMBOL LETTER S&quot;), which are themselves encoded as UTF-8 using 4 bytes each. A design in which you can &quot;just write&quot; string[4544] hides the fact that indexing is a linear-time operation that needs to recompose UTF-8 characters and then recompose visual glyphs on top of that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generally speaking, I *think* that I agree that human-geared &quot;long string&quot; on which you probably won&#39;t need random access, and machine-geared smaller strings that encode a command, could benefit from not being considered the same fundamental thing. However, I&#39;m also afraid that this will end with more applications and websites that think that first names only contain 7-bit-clean characters in the A-Z range. (I live in the US and I can attest that this is still very common.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You could make a point too that better facilities to parse strings would probably address this issue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 15 août 2016 à 10:52:02, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with both points of view. I think we need to bring back subscripting on strings which does the thing people would most commonly expect.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would say that the subscripts indexes should correspond to a visual glyph. This seems reasonable to me for most character sets like Roman, Cyrillic, Chinese. There is some doubt in my mind for things like subscripted Japanese or connected (ligatured?) languages like Arabic, Hindi or Thai.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Kenny<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 15, 2016, at 10:42 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sun, Aug 14, 2016 at 5:41 PM, Michael Savich via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Back in Swift 1.0, subscripting a String was easy, you could just use subscripting in a very Python like way. But now, things are a bit more complicated. I recognize why we need syntax like str.startIndex.advancedBy(x) but it has its downsides. Namely, it makes things hard on beginners. If one of Swift&#39;s goals is to make it a great first language, this syntax fights that. Imagine having to explain Unicode and character size to an 8 year old. This is doubly problematic because String manipulation is one of the first things new coders might want to do. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What about having an InternalString subclass that only supports one encoding, allowing it to be subscripted with Ints? The idea is that an InternalString is for Strings that are more or less hard coded into the app. Dictionary keys, enum raw values, that kind of stuff. This also has the added benefit of forcing the programmer to think about what the String is being used for. Is it user facing? Or is it just for internal use? And of course, it makes code dealing with String manipulation much more concise and readable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It follows that something like this would need to be entered as a literal to make it as easy as using String. One way would be to make all String literals InternalStrings, but that sounds far too drastic. Maybe appending an exclamation point like &quot;this&quot;! Or even just wrapping the whole thing in exclamation marks like !&quot;this&quot;! Of course, we could go old school and write it like @&quot;this&quot; …That last one is a joke.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;ll be the first to admit I&#39;m way in over my head here, so I&#39;m very open to suggestions and criticism. Thanks!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I can sympathize, but this is tricky.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Fundamentally, if it&#39;s going to be a learning and teaching issue, then this &quot;easy&quot; string should be the default. That is to say, if I write `var a = &quot;Hello, world!&quot;`, then `a` should be inferred to be of type InternalString or EasyString, whatever you want to call it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But, we also want Swift to support Unicode by default, and we want that support to do things The Right Way(TM) by default. In other words, a user should not have to reach for a special type in order to handle arbitrary strings correctly, and I should be able to reassign `a = &quot;你好&quot;` and have things work as expected. So, we also can&#39;t have the &quot;easy&quot; string type be the default...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I can&#39;t think of a way to square that circle.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>August 17, 2016 at 07:00:00pm</p></header><div class="content"><p>As stated earlier it is 2016, I think the baseline should be robust Unicode<br>support and what we have in Swift is actually a fairly good way of dealing<br>with it IMHO. I think new to development folks should have this as their<br>baseline as well... not that we shouldn&#39;t make it as easy to work with as<br>possible.<br></p><p>-Shawn<br></p><p>On Wed, Aug 17, 2016 at 12:15 PM Kenny Leung via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; It seems to me that UTF-8 is the best choice to encode strings in English<br>&gt; and English-like character sets for storage, but it’s not clear that it is<br>&gt; the most useful or performant internal representation for working with<br>&gt; strings. In my opinion, conflating the preferred storage format and the<br>&gt; best internal representation is not the proper thing to do. Picking the<br>&gt; right internal storage format should be evaluated based on its own<br>&gt; criteria. Even as an experienced programmer, I assert that the most useful<br>&gt; indexing system is glyph based.<br>&gt;<br>&gt; In Félix’s case, I would expect to have to ask for a mail-friendly<br>&gt; representation of his name, just like you have to ask for a<br>&gt; filesystem-friendly representation of a filename regardless of what the<br>&gt; internal representation is. Just because you are using UTF-8 as the<br>&gt; internal format, it does not mean that universal support is guaranteed.<br>&gt;<br>&gt; In response to this statement: “Optimizing developer experience for<br>&gt; beginning developers is just going to lead to software that screws…”, the<br>&gt; current system trips up not only beginning developers, but is different<br>&gt; from pretty much every programming language in my experience.<br>&gt;<br>&gt; -Kenny<br>&gt;<br>&gt;<br>&gt; &gt; On Aug 17, 2016, at 11:48 AM, Zach Waldowski via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; It&#39;s 2016, &quot;the thing people would most commonly expect&quot;<br>&gt; &gt; impossible-to-screw-up Unicode support that&#39;s performance. Optimizing<br>&gt; &gt; developer experience for beginning developers is just going to lead to<br>&gt; &gt; software that screws up in situations the developer doesn&#39;t anticipate,<br>&gt; &gt; as F+¬lix notes above.<br>&gt; &gt;<br>&gt; &gt; Zachary<br>&gt; &gt;<br>&gt; &gt; On Wed, Aug 17, 2016, at 09:40 AM, Kenny Leung via swift-evolution<br>&gt; &gt; wrote:<br>&gt; &gt;&gt; I understand that the most friendly approach may not be the most<br>&gt; &gt;&gt; efficient, but that’s not what I’m pushing for. I’m pushing for &quot;does<br>&gt; the<br>&gt; &gt;&gt; thing people would most commonly expect”. Take a first-time programmer<br>&gt; &gt;&gt; who reads any (human) language, and that is what they would expect.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Why couldn’t String’s internal storage format be glyph-based? If I were,<br>&gt; &gt;&gt; say, writing a text editor, it would certainly be the easiest and most<br>&gt; &gt;&gt; efficient format to work in.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Kenny<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Aug 15, 2016, at 9:20 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The major problem with this approach is that visual glyphs themselves<br>&gt; have one level of variable-length encoding, and they sit on top of another<br>&gt; variable-length encoding used to represent the Unicode characters<br>&gt; (Swift-native Strings are currently encoded as UTF-8). For instance, the<br>&gt; visual glyph 🇺🇸 is the the result of putting side-by-side the Unicode<br>&gt; characters 🇺 and  🇸(&quot;REGIONAL INDICATOR SYMBOL LETTER U&quot; and &quot;REGIONAL<br>&gt; INDICATOR SYMBOL LETTER S&quot;), which are themselves encoded as UTF-8 using 4<br>&gt; bytes each. A design in which you can &quot;just write&quot; string[4544] hides the<br>&gt; fact that indexing is a linear-time operation that needs to recompose UTF-8<br>&gt; characters and then recompose visual glyphs on top of that.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Generally speaking, I *think* that I agree that human-geared &quot;long<br>&gt; string&quot; on which you probably won&#39;t need random access, and machine-geared<br>&gt; smaller strings that encode a command, could benefit from not being<br>&gt; considered the same fundamental thing. However, I&#39;m also afraid that this<br>&gt; will end with more applications and websites that think that first names<br>&gt; only contain 7-bit-clean characters in the A-Z range. (I live in the US and<br>&gt; I can attest that this is still very common.)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; You could make a point too that better facilities to parse strings<br>&gt; would probably address this issue.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Félix<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Le 15 août 2016 à 10:52:02, Kenny Leung via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I agree with both points of view. I think we need to bring back<br>&gt; subscripting on strings which does the thing people would most commonly<br>&gt; expect.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I would say that the subscripts indexes should correspond to a visual<br>&gt; glyph. This seems reasonable to me for most character sets like Roman,<br>&gt; Cyrillic, Chinese. There is some doubt in my mind for things like<br>&gt; subscripted Japanese or connected (ligatured?) languages like Arabic, Hindi<br>&gt; or Thai.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; -Kenny<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Aug 15, 2016, at 10:42 AM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Sun, Aug 14, 2016 at 5:41 PM, Michael Savich via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt; Back in Swift 1.0, subscripting a String was easy, you could just<br>&gt; use subscripting in a very Python like way. But now, things are a bit more<br>&gt; complicated. I recognize why we need syntax like<br>&gt; str.startIndex.advancedBy(x) but it has its downsides. Namely, it makes<br>&gt; things hard on beginners. If one of Swift&#39;s goals is to make it a great<br>&gt; first language, this syntax fights that. Imagine having to explain Unicode<br>&gt; and character size to an 8 year old. This is doubly problematic because<br>&gt; String manipulation is one of the first things new coders might want to do.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; What about having an InternalString subclass that only supports one<br>&gt; encoding, allowing it to be subscripted with Ints? The idea is that an<br>&gt; InternalString is for Strings that are more or less hard coded into the<br>&gt; app. Dictionary keys, enum raw values, that kind of stuff. This also has<br>&gt; the added benefit of forcing the programmer to think about what the String<br>&gt; is being used for. Is it user facing? Or is it just for internal use? And<br>&gt; of course, it makes code dealing with String manipulation much more concise<br>&gt; and readable.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; It follows that something like this would need to be entered as a<br>&gt; literal to make it as easy as using String. One way would be to make all<br>&gt; String literals InternalStrings, but that sounds far too drastic. Maybe<br>&gt; appending an exclamation point like &quot;this&quot;! Or even just wrapping the whole<br>&gt; thing in exclamation marks like !&quot;this&quot;! Of course, we could go old school<br>&gt; and write it like @&quot;this&quot; …That last one is a joke.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I&#39;ll be the first to admit I&#39;m way in over my head here, so I&#39;m very<br>&gt; open to suggestions and criticism. Thanks!<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I can sympathize, but this is tricky.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Fundamentally, if it&#39;s going to be a learning and teaching issue,<br>&gt; then this &quot;easy&quot; string should be the default. That is to say, if I write<br>&gt; `var a = &quot;Hello, world!&quot;`, then `a` should be inferred to be of type<br>&gt; InternalString or EasyString, whatever you want to call it.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; But, we also want Swift to support Unicode by default, and we want<br>&gt; that support to do things The Right Way(TM) by default. In other words, a<br>&gt; user should not have to reach for a special type in order to handle<br>&gt; arbitrary strings correctly, and I should be able to reassign `a = &quot;你好&quot;`<br>&gt; and have things work as expected. So, we also can&#39;t have the &quot;easy&quot; string<br>&gt; type be the default...<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I can&#39;t think of a way to square that circle.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/bf7d2c39/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>August 17, 2016 at 02:00:00pm</p></header><div class="content"><p>I’m not sure what the current year of the Gregorian calendar has to do with strings. :P<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Aug 17, 2016, at 2:20 PM, Shawn Erickson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As stated earlier it is 2016, I think the baseline should be robust Unicode support and what we have in Swift is actually a fairly good way of dealing with it IMHO. I think new to development folks should have this as their baseline as well... not that we shouldn&#39;t make it as easy to work with as possible.<br>&gt; <br>&gt; -Shawn<br>&gt; <br>&gt; On Wed, Aug 17, 2016 at 12:15 PM Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; It seems to me that UTF-8 is the best choice to encode strings in English and English-like character sets for storage, but it’s not clear that it is the most useful or performant internal representation for working with strings. In my opinion, conflating the preferred storage format and the best internal representation is not the proper thing to do. Picking the right internal storage format should be evaluated based on its own criteria. Even as an experienced programmer, I assert that the most useful indexing system is glyph based.<br>&gt; <br>&gt; In Félix’s case, I would expect to have to ask for a mail-friendly representation of his name, just like you have to ask for a filesystem-friendly representation of a filename regardless of what the internal representation is. Just because you are using UTF-8 as the internal format, it does not mean that universal support is guaranteed.<br>&gt; <br>&gt; In response to this statement: “Optimizing developer experience for beginning developers is just going to lead to software that screws…”, the current system trips up not only beginning developers, but is different from pretty much every programming language in my experience.<br>&gt; <br>&gt; -Kenny<br>&gt; <br>&gt; <br>&gt; &gt; On Aug 17, 2016, at 11:48 AM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; It&#39;s 2016, &quot;the thing people would most commonly expect&quot;<br>&gt; &gt; impossible-to-screw-up Unicode support that&#39;s performance. Optimizing<br>&gt; &gt; developer experience for beginning developers is just going to lead to<br>&gt; &gt; software that screws up in situations the developer doesn&#39;t anticipate,<br>&gt; &gt; as F+¬lix notes above.<br>&gt; &gt;<br>&gt; &gt; Zachary<br>&gt; &gt;<br>&gt; &gt; On Wed, Aug 17, 2016, at 09:40 AM, Kenny Leung via swift-evolution<br>&gt; &gt; wrote:<br>&gt; &gt;&gt; I understand that the most friendly approach may not be the most<br>&gt; &gt;&gt; efficient, but that’s not what I’m pushing for. I’m pushing for &quot;does the<br>&gt; &gt;&gt; thing people would most commonly expect”. Take a first-time programmer<br>&gt; &gt;&gt; who reads any (human) language, and that is what they would expect.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Why couldn’t String’s internal storage format be glyph-based? If I were,<br>&gt; &gt;&gt; say, writing a text editor, it would certainly be the easiest and most<br>&gt; &gt;&gt; efficient format to work in.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Kenny<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Aug 15, 2016, at 9:20 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The major problem with this approach is that visual glyphs themselves have one level of variable-length encoding, and they sit on top of another variable-length encoding used to represent the Unicode characters (Swift-native Strings are currently encoded as UTF-8). For instance, the visual glyph 🇺🇸 is the the result of putting side-by-side the Unicode characters 🇺 and  🇸(&quot;REGIONAL INDICATOR SYMBOL LETTER U&quot; and &quot;REGIONAL INDICATOR SYMBOL LETTER S&quot;), which are themselves encoded as UTF-8 using 4 bytes each. A design in which you can &quot;just write&quot; string[4544] hides the fact that indexing is a linear-time operation that needs to recompose UTF-8 characters and then recompose visual glyphs on top of that.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Generally speaking, I *think* that I agree that human-geared &quot;long string&quot; on which you probably won&#39;t need random access, and machine-geared smaller strings that encode a command, could benefit from not being considered the same fundamental thing. However, I&#39;m also afraid that this will end with more applications and websites that think that first names only contain 7-bit-clean characters in the A-Z range. (I live in the US and I can attest that this is still very common.)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; You could make a point too that better facilities to parse strings would probably address this issue.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Félix<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Le 15 août 2016 à 10:52:02, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I agree with both points of view. I think we need to bring back subscripting on strings which does the thing people would most commonly expect.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I would say that the subscripts indexes should correspond to a visual glyph. This seems reasonable to me for most character sets like Roman, Cyrillic, Chinese. There is some doubt in my mind for things like subscripted Japanese or connected (ligatured?) languages like Arabic, Hindi or Thai.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; -Kenny<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Aug 15, 2016, at 10:42 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Sun, Aug 14, 2016 at 5:41 PM, Michael Savich via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt; Back in Swift 1.0, subscripting a String was easy, you could just use subscripting in a very Python like way. But now, things are a bit more complicated. I recognize why we need syntax like str.startIndex.advancedBy(x) but it has its downsides. Namely, it makes things hard on beginners. If one of Swift&#39;s goals is to make it a great first language, this syntax fights that. Imagine having to explain Unicode and character size to an 8 year old. This is doubly problematic because String manipulation is one of the first things new coders might want to do.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; What about having an InternalString subclass that only supports one encoding, allowing it to be subscripted with Ints? The idea is that an InternalString is for Strings that are more or less hard coded into the app. Dictionary keys, enum raw values, that kind of stuff. This also has the added benefit of forcing the programmer to think about what the String is being used for. Is it user facing? Or is it just for internal use? And of course, it makes code dealing with String manipulation much more concise and readable.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; It follows that something like this would need to be entered as a literal to make it as easy as using String. One way would be to make all String literals InternalStrings, but that sounds far too drastic. Maybe appending an exclamation point like &quot;this&quot;! Or even just wrapping the whole thing in exclamation marks like !&quot;this&quot;! Of course, we could go old school and write it like @&quot;this&quot; …That last one is a joke.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I&#39;ll be the first to admit I&#39;m way in over my head here, so I&#39;m very open to suggestions and criticism. Thanks!<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I can sympathize, but this is tricky.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Fundamentally, if it&#39;s going to be a learning and teaching issue, then this &quot;easy&quot; string should be the default. That is to say, if I write `var a = &quot;Hello, world!&quot;`, then `a` should be inferred to be of type InternalString or EasyString, whatever you want to call it.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; But, we also want Swift to support Unicode by default, and we want that support to do things The Right Way(TM) by default. In other words, a user should not have to reach for a special type in order to handle arbitrary strings correctly, and I should be able to reassign `a = &quot;你好&quot;` and have things work as expected. So, we also can&#39;t have the &quot;easy&quot; string type be the default...<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I can&#39;t think of a way to square that circle.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>August 17, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; On Aug 17, 2016, at 12:20 PM, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt; <br>&gt; As stated earlier it is 2016<br></p><p>I don’t like the tone attached to this statement.<br></p><p>&gt; I think the baseline should be robust Unicode support<br></p><p>I don’t understand how anything I have pushed for would compromise robust Unicode support.<br></p><p>&gt; and what we have in Swift is actually a fairly good way of dealing with it IMHO. I think new to development folks should have this as their baseline as well…<br></p><p>&gt; not that we shouldn&#39;t make it as easy to work with as possible.<br></p><p>Regardless of internal representation, wouldn’t this be a glyph-based indexing system?<br></p><p>-Kenny<br></p><p><br>&gt; <br>&gt; -Shawn<br>&gt; <br>&gt; On Wed, Aug 17, 2016 at 12:15 PM Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; It seems to me that UTF-8 is the best choice to encode strings in English and English-like character sets for storage, but it’s not clear that it is the most useful or performant internal representation for working with strings. In my opinion, conflating the preferred storage format and the best internal representation is not the proper thing to do. Picking the right internal storage format should be evaluated based on its own criteria. Even as an experienced programmer, I assert that the most useful indexing system is glyph based.<br>&gt; <br>&gt; In Félix’s case, I would expect to have to ask for a mail-friendly representation of his name, just like you have to ask for a filesystem-friendly representation of a filename regardless of what the internal representation is. Just because you are using UTF-8 as the internal format, it does not mean that universal support is guaranteed.<br>&gt; <br>&gt; In response to this statement: “Optimizing developer experience for beginning developers is just going to lead to software that screws…”, the current system trips up not only beginning developers, but is different from pretty much every programming language in my experience.<br>&gt; <br>&gt; -Kenny<br>&gt; <br>&gt; <br>&gt; &gt; On Aug 17, 2016, at 11:48 AM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; It&#39;s 2016, &quot;the thing people would most commonly expect&quot;<br>&gt; &gt; impossible-to-screw-up Unicode support that&#39;s performance. Optimizing<br>&gt; &gt; developer experience for beginning developers is just going to lead to<br>&gt; &gt; software that screws up in situations the developer doesn&#39;t anticipate,<br>&gt; &gt; as F+¬lix notes above.<br>&gt; &gt;<br>&gt; &gt; Zachary<br>&gt; &gt;<br>&gt; &gt; On Wed, Aug 17, 2016, at 09:40 AM, Kenny Leung via swift-evolution<br>&gt; &gt; wrote:<br>&gt; &gt;&gt; I understand that the most friendly approach may not be the most<br>&gt; &gt;&gt; efficient, but that’s not what I’m pushing for. I’m pushing for &quot;does the<br>&gt; &gt;&gt; thing people would most commonly expect”. Take a first-time programmer<br>&gt; &gt;&gt; who reads any (human) language, and that is what they would expect.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Why couldn’t String’s internal storage format be glyph-based? If I were,<br>&gt; &gt;&gt; say, writing a text editor, it would certainly be the easiest and most<br>&gt; &gt;&gt; efficient format to work in.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Kenny<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Aug 15, 2016, at 9:20 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The major problem with this approach is that visual glyphs themselves have one level of variable-length encoding, and they sit on top of another variable-length encoding used to represent the Unicode characters (Swift-native Strings are currently encoded as UTF-8). For instance, the visual glyph 🇺🇸 is the the result of putting side-by-side the Unicode characters 🇺 and  🇸(&quot;REGIONAL INDICATOR SYMBOL LETTER U&quot; and &quot;REGIONAL INDICATOR SYMBOL LETTER S&quot;), which are themselves encoded as UTF-8 using 4 bytes each. A design in which you can &quot;just write&quot; string[4544] hides the fact that indexing is a linear-time operation that needs to recompose UTF-8 characters and then recompose visual glyphs on top of that.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Generally speaking, I *think* that I agree that human-geared &quot;long string&quot; on which you probably won&#39;t need random access, and machine-geared smaller strings that encode a command, could benefit from not being considered the same fundamental thing. However, I&#39;m also afraid that this will end with more applications and websites that think that first names only contain 7-bit-clean characters in the A-Z range. (I live in the US and I can attest that this is still very common.)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; You could make a point too that better facilities to parse strings would probably address this issue.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Félix<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Le 15 août 2016 à 10:52:02, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I agree with both points of view. I think we need to bring back subscripting on strings which does the thing people would most commonly expect.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I would say that the subscripts indexes should correspond to a visual glyph. This seems reasonable to me for most character sets like Roman, Cyrillic, Chinese. There is some doubt in my mind for things like subscripted Japanese or connected (ligatured?) languages like Arabic, Hindi or Thai.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; -Kenny<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Aug 15, 2016, at 10:42 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Sun, Aug 14, 2016 at 5:41 PM, Michael Savich via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt; Back in Swift 1.0, subscripting a String was easy, you could just use subscripting in a very Python like way. But now, things are a bit more complicated. I recognize why we need syntax like str.startIndex.advancedBy(x) but it has its downsides. Namely, it makes things hard on beginners. If one of Swift&#39;s goals is to make it a great first language, this syntax fights that. Imagine having to explain Unicode and character size to an 8 year old. This is doubly problematic because String manipulation is one of the first things new coders might want to do.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; What about having an InternalString subclass that only supports one encoding, allowing it to be subscripted with Ints? The idea is that an InternalString is for Strings that are more or less hard coded into the app. Dictionary keys, enum raw values, that kind of stuff. This also has the added benefit of forcing the programmer to think about what the String is being used for. Is it user facing? Or is it just for internal use? And of course, it makes code dealing with String manipulation much more concise and readable.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; It follows that something like this would need to be entered as a literal to make it as easy as using String. One way would be to make all String literals InternalStrings, but that sounds far too drastic. Maybe appending an exclamation point like &quot;this&quot;! Or even just wrapping the whole thing in exclamation marks like !&quot;this&quot;! Of course, we could go old school and write it like @&quot;this&quot; …That last one is a joke.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I&#39;ll be the first to admit I&#39;m way in over my head here, so I&#39;m very open to suggestions and criticism. Thanks!<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I can sympathize, but this is tricky.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Fundamentally, if it&#39;s going to be a learning and teaching issue, then this &quot;easy&quot; string should be the default. That is to say, if I write `var a = &quot;Hello, world!&quot;`, then `a` should be inferred to be of type InternalString or EasyString, whatever you want to call it.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; But, we also want Swift to support Unicode by default, and we want that support to do things The Right Way(TM) by default. In other words, a user should not have to reach for a special type in order to handle arbitrary strings correctly, and I should be able to reassign `a = &quot;你好&quot;` and have things work as expected. So, we also can&#39;t have the &quot;easy&quot; string type be the default...<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I can&#39;t think of a way to square that circle.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>August 17, 2016 at 07:00:00pm</p></header><div class="content"><p>I like a &quot;view&quot; based system when looking at a Unicode string. It lets you<br>pick the view of string - defining how it is indexed - based on your needs.<br>A view could be indexed by a human facing glyph, a particular Unicode<br>encoding style, a decompose style, etc.<br></p><p>I think that is powerful, useful, and exposes the real complexity in a<br>manageable and functional way.<br></p><p>In many domains you would never need to care about indexing across a view<br>or even using a view to work with a string.<br>On Wed, Aug 17, 2016 at 12:27 PM Kenny Leung via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt;<br>&gt; &gt; On Aug 17, 2016, at 12:20 PM, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; As stated earlier it is 2016<br>&gt;<br>&gt; I don’t like the tone attached to this statement.<br>&gt;<br>&gt; &gt; I think the baseline should be robust Unicode support<br>&gt;<br>&gt; I don’t understand how anything I have pushed for would compromise robust<br>&gt; Unicode support.<br>&gt;<br>&gt; &gt; and what we have in Swift is actually a fairly good way of dealing with<br>&gt; it IMHO. I think new to development folks should have this as their<br>&gt; baseline as well…<br>&gt;<br>&gt; &gt; not that we shouldn&#39;t make it as easy to work with as possible.<br>&gt;<br>&gt; Regardless of internal representation, wouldn’t this be a glyph-based<br>&gt; indexing system?<br>&gt;<br>&gt; -Kenny<br>&gt;<br>&gt;<br>&gt; &gt;<br>&gt; &gt; -Shawn<br>&gt; &gt;<br>&gt; &gt; On Wed, Aug 17, 2016 at 12:15 PM Kenny Leung via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; It seems to me that UTF-8 is the best choice to encode strings in<br>&gt; English and English-like character sets for storage, but it’s not clear<br>&gt; that it is the most useful or performant internal representation for<br>&gt; working with strings. In my opinion, conflating the preferred storage<br>&gt; format and the best internal representation is not the proper thing to do.<br>&gt; Picking the right internal storage format should be evaluated based on its<br>&gt; own criteria. Even as an experienced programmer, I assert that the most<br>&gt; useful indexing system is glyph based.<br>&gt; &gt;<br>&gt; &gt; In Félix’s case, I would expect to have to ask for a mail-friendly<br>&gt; representation of his name, just like you have to ask for a<br>&gt; filesystem-friendly representation of a filename regardless of what the<br>&gt; internal representation is. Just because you are using UTF-8 as the<br>&gt; internal format, it does not mean that universal support is guaranteed.<br>&gt; &gt;<br>&gt; &gt; In response to this statement: “Optimizing developer experience for<br>&gt; beginning developers is just going to lead to software that screws…”, the<br>&gt; current system trips up not only beginning developers, but is different<br>&gt; from pretty much every programming language in my experience.<br>&gt; &gt;<br>&gt; &gt; -Kenny<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; &gt; On Aug 17, 2016, at 11:48 AM, Zach Waldowski via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; It&#39;s 2016, &quot;the thing people would most commonly expect&quot;<br>&gt; &gt; &gt; impossible-to-screw-up Unicode support that&#39;s performance. Optimizing<br>&gt; &gt; &gt; developer experience for beginning developers is just going to lead to<br>&gt; &gt; &gt; software that screws up in situations the developer doesn&#39;t anticipate,<br>&gt; &gt; &gt; as F+¬lix notes above.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Zachary<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; On Wed, Aug 17, 2016, at 09:40 AM, Kenny Leung via swift-evolution<br>&gt; &gt; &gt; wrote:<br>&gt; &gt; &gt;&gt; I understand that the most friendly approach may not be the most<br>&gt; &gt; &gt;&gt; efficient, but that’s not what I’m pushing for. I’m pushing for &quot;does<br>&gt; the<br>&gt; &gt; &gt;&gt; thing people would most commonly expect”. Take a first-time programmer<br>&gt; &gt; &gt;&gt; who reads any (human) language, and that is what they would expect.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; Why couldn’t String’s internal storage format be glyph-based? If I<br>&gt; were,<br>&gt; &gt; &gt;&gt; say, writing a text editor, it would certainly be the easiest and most<br>&gt; &gt; &gt;&gt; efficient format to work in.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; -Kenny<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; On Aug 15, 2016, at 9:20 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt;<br>&gt; wrote:<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; The major problem with this approach is that visual glyphs<br>&gt; themselves have one level of variable-length encoding, and they sit on top<br>&gt; of another variable-length encoding used to represent the Unicode<br>&gt; characters (Swift-native Strings are currently encoded as UTF-8). For<br>&gt; instance, the visual glyph 🇺🇸 is the the result of putting side-by-side<br>&gt; the Unicode characters 🇺 and  🇸(&quot;REGIONAL INDICATOR SYMBOL LETTER U&quot; and<br>&gt; &quot;REGIONAL INDICATOR SYMBOL LETTER S&quot;), which are themselves encoded as<br>&gt; UTF-8 using 4 bytes each. A design in which you can &quot;just write&quot;<br>&gt; string[4544] hides the fact that indexing is a linear-time operation that<br>&gt; needs to recompose UTF-8 characters and then recompose visual glyphs on top<br>&gt; of that.<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; Generally speaking, I *think* that I agree that human-geared &quot;long<br>&gt; string&quot; on which you probably won&#39;t need random access, and machine-geared<br>&gt; smaller strings that encode a command, could benefit from not being<br>&gt; considered the same fundamental thing. However, I&#39;m also afraid that this<br>&gt; will end with more applications and websites that think that first names<br>&gt; only contain 7-bit-clean characters in the A-Z range. (I live in the US and<br>&gt; I can attest that this is still very common.)<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; You could make a point too that better facilities to parse strings<br>&gt; would probably address this issue.<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; Félix<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt; Le 15 août 2016 à 10:52:02, Kenny Leung via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt; I agree with both points of view. I think we need to bring back<br>&gt; subscripting on strings which does the thing people would most commonly<br>&gt; expect.<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt; I would say that the subscripts indexes should correspond to a<br>&gt; visual glyph. This seems reasonable to me for most character sets like<br>&gt; Roman, Cyrillic, Chinese. There is some doubt in my mind for things like<br>&gt; subscripted Japanese or connected (ligatured?) languages like Arabic, Hindi<br>&gt; or Thai.<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt; -Kenny<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt; On Aug 15, 2016, at 10:42 AM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt; On Sun, Aug 14, 2016 at 5:41 PM, Michael Savich via<br>&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt; Back in Swift 1.0, subscripting a String was easy, you could just<br>&gt; use subscripting in a very Python like way. But now, things are a bit more<br>&gt; complicated. I recognize why we need syntax like<br>&gt; str.startIndex.advancedBy(x) but it has its downsides. Namely, it makes<br>&gt; things hard on beginners. If one of Swift&#39;s goals is to make it a great<br>&gt; first language, this syntax fights that. Imagine having to explain Unicode<br>&gt; and character size to an 8 year old. This is doubly problematic because<br>&gt; String manipulation is one of the first things new coders might want to do.<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt; What about having an InternalString subclass that only supports<br>&gt; one encoding, allowing it to be subscripted with Ints? The idea is that an<br>&gt; InternalString is for Strings that are more or less hard coded into the<br>&gt; app. Dictionary keys, enum raw values, that kind of stuff. This also has<br>&gt; the added benefit of forcing the programmer to think about what the String<br>&gt; is being used for. Is it user facing? Or is it just for internal use? And<br>&gt; of course, it makes code dealing with String manipulation much more concise<br>&gt; and readable.<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt; It follows that something like this would need to be entered as a<br>&gt; literal to make it as easy as using String. One way would be to make all<br>&gt; String literals InternalStrings, but that sounds far too drastic. Maybe<br>&gt; appending an exclamation point like &quot;this&quot;! Or even just wrapping the whole<br>&gt; thing in exclamation marks like !&quot;this&quot;! Of course, we could go old school<br>&gt; and write it like @&quot;this&quot; …That last one is a joke.<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt; I&#39;ll be the first to admit I&#39;m way in over my head here, so I&#39;m<br>&gt; very open to suggestions and criticism. Thanks!<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt; I can sympathize, but this is tricky.<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt; Fundamentally, if it&#39;s going to be a learning and teaching issue,<br>&gt; then this &quot;easy&quot; string should be the default. That is to say, if I write<br>&gt; `var a = &quot;Hello, world!&quot;`, then `a` should be inferred to be of type<br>&gt; InternalString or EasyString, whatever you want to call it.<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt; But, we also want Swift to support Unicode by default, and we want<br>&gt; that support to do things The Right Way(TM) by default. In other words, a<br>&gt; user should not have to reach for a special type in order to handle<br>&gt; arbitrary strings correctly, and I should be able to reassign `a = &quot;你好&quot;`<br>&gt; and have things work as expected. So, we also can&#39;t have the &quot;easy&quot; string<br>&gt; type be the default...<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt; I can&#39;t think of a way to square that circle.<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; _______________________________________________<br>&gt; &gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/660e7ed6/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>August 17, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; In Félix’s case, I would expect to have to ask for a mail-friendly representation of his name, just like you have to ask for a filesystem-friendly representation of a filename regardless of what the internal representation is. Just because you are using UTF-8 as the internal format, it does not mean that universal support is guaranteed.<br></p><p>Would you imagine if &quot;n&quot; turned out to be poorly supported by systems throughout the world and dead-serious people argued that it&#39;s too hard for beginners?<br></p><p>&quot;Filesystem-friendly&quot; and &quot;email-friendly&quot; names are not backed by modern standards. You can have essentially any character that you like in a file name save for the directory separator on almost every platform out there (except on Windows, but the constraints are implemented in a layer above NTFS), and addresses like félix at ... are RFC-legal. Restrictions are merely wished into existence by programmers who don&#39;t want to complicate their mental model of text processing, to everyone else&#39;s detriment.<br></p><p>Félix<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>August 18, 2016 at 09:00:00am</p></header><div class="content"><p>&gt;&gt; Just because you are using UTF-8 as the internal format, it does not mean that universal support is guaranteed.<br></p><p>All I meant was this, and nothing more. If the internal format was UTF-8, and you were using a filesystem whose filenames were UTF-16, you would have the same problems.<br></p><p>-Kenny<br></p><p><br>&gt; On Aug 17, 2016, at 10:40 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt;&gt; In Félix’s case, I would expect to have to ask for a mail-friendly representation of his name, just like you have to ask for a filesystem-friendly representation of a filename regardless of what the internal representation is. Just because you are using UTF-8 as the internal format, it does not mean that universal support is guaranteed.<br>&gt; <br>&gt; Would you imagine if &quot;n&quot; turned out to be poorly supported by systems throughout the world and dead-serious people argued that it&#39;s too hard for beginners?<br>&gt; <br>&gt; &quot;Filesystem-friendly&quot; and &quot;email-friendly&quot; names are not backed by modern standards. You can have essentially any character that you like in a file name save for the directory separator on almost every platform out there (except on Windows, but the constraints are implemented in a layer above NTFS), and addresses like félix at ... are RFC-legal. Restrictions are merely wished into existence by programmers who don&#39;t want to complicate their mental model of text processing, to everyone else&#39;s detriment.<br>&gt; <br>&gt; Félix<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>August 18, 2016 at 06:00:00pm</p></header><div class="content"><p>I&#39;m not sure I understand your comment. UTF-8 and UTF-16 are just two different ways to represent Unicode data, and they can both encode the whole range of Unicode. Of course you&#39;ll have problems if you try to interpret UTF-8 as UTF-16 and vice-versa, but that&#39;ll do you regardless of whether you use international characters or not.Félix <br></p><p>    On Thursday, August 18, 2016 9:33 AM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br> <br></p><p> &gt;&gt; Just because you are using UTF-8 as the internal format, it does not mean that universal support is guaranteed.<br></p><p>All I meant was this, and nothing more. If the internal format was UTF-8, and you were using a filesystem whose filenames were UTF-16, you would have the same problems.<br></p><p>-Kenny<br></p><p><br>&gt; On Aug 17, 2016, at 10:40 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt;&gt; In Félix’s case, I would expect to have to ask for a mail-friendly representation of his name, just like you have to ask for a filesystem-friendly representation of a filename regardless of what the internal representation is. Just because you are using UTF-8 as the internal format, it does not mean that universal support is guaranteed.<br>&gt; <br>&gt; Would you imagine if &quot;n&quot; turned out to be poorly supported by systems throughout the world and dead-serious people argued that it&#39;s too hard for beginners?<br>&gt; <br>&gt; &quot;Filesystem-friendly&quot; and &quot;email-friendly&quot; names are not backed by modern standards. You can have essentially any character that you like in a file name save for the directory separator on almost every platform out there (except on Windows, but the constraints are implemented in a layer above NTFS), and addresses like félix at ... are RFC-legal. Restrictions are merely wished into existence by programmers who don&#39;t want to complicate their mental model of text processing, to everyone else&#39;s detriment.<br>&gt; <br>&gt; Félix<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>  <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/e325f32a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>August 18, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Aug 18, 2016, at 11:51 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;  Of course you&#39;ll have problems if you try to interpret UTF-8 as UTF-16 and vice-versa, but that&#39;ll do you regardless of whether you use international characters or not.<br></p><p>This is exactly my point. Even if the internal representation is UTF-8 (or UTF-16), you are not free from having to do conversions. You still need to convert to the encoding format that is understood by the receiver. I make a distinction between Unicode and Unicode encodings.<br></p><p>-Kenny<br></p><p><br>&gt; On Thursday, August 18, 2016 9:33 AM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; &gt;&gt; Just because you are using UTF-8 as the internal format, it does not mean that universal support is guaranteed.<br>&gt; <br>&gt; All I meant was this, and nothing more. If the internal format was UTF-8, and you were using a filesystem whose filenames were UTF-16, you would have the same problems.<br>&gt; <br>&gt; -Kenny<br>&gt; <br>&gt; <br>&gt; &gt; On Aug 17, 2016, at 10:40 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; &gt; <br>&gt; &gt;&gt; In Félix’s case, I would expect to have to ask for a mail-friendly representation of his name, just like you have to ask for a filesystem-friendly representation of a filename regardless of what the internal representation is. Just because you are using UTF-8 as the internal format, it does not mean that universal support is guaranteed.<br>&gt; &gt; <br>&gt; &gt; Would you imagine if &quot;n&quot; turned out to be poorly supported by systems throughout the world and dead-serious people argued that it&#39;s too hard for beginners?<br>&gt; &gt; <br>&gt; &gt; &quot;Filesystem-friendly&quot; and &quot;email-friendly&quot; names are not backed by modern standards. You can have essentially any character that you like in a file name save for the directory separator on almost every platform out there (except on Windows, but the constraints are implemented in a layer above NTFS), and addresses like félix at ... are RFC-legal. Restrictions are merely wished into existence by programmers who don&#39;t want to complicate their mental model of text processing, to everyone else&#39;s detriment.<br>&gt; &gt; <br>&gt; &gt; Félix<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 18, 2016 at 02:00:00pm</p></header><div class="content"><p>Actually, if I&#39;m not mistaken, String (or at least, CFStringRef, to which<br>String is toll-free bridged) does not re-encode anything eagerly. If you<br>initialize with UTF8 bytes, it&#39;s stored internally as UTF8 bytes; if you<br>initialize with UTF16 code units, it&#39;s stored internally as UTF16 code<br>units. Re-encoding happens only when necessary--i.e. when you ask for UTF8<br>bytes from a UTF16-encoded string.<br></p><p><br>On Thu, Aug 18, 2016 at 2:34 PM, Kenny Leung via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Aug 18, 2016, at 11:51 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; &gt;  Of course you&#39;ll have problems if you try to interpret UTF-8 as UTF-16<br>&gt; and vice-versa, but that&#39;ll do you regardless of whether you use<br>&gt; international characters or not.<br>&gt;<br>&gt; This is exactly my point. Even if the internal representation is UTF-8 (or<br>&gt; UTF-16), you are not free from having to do conversions. You still need to<br>&gt; convert to the encoding format that is understood by the receiver. I make a<br>&gt; distinction between Unicode and Unicode encodings.<br>&gt;<br>&gt; -Kenny<br>&gt;<br>&gt;<br>&gt; &gt; On Thursday, August 18, 2016 9:33 AM, Kenny Leung via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; &gt;&gt; Just because you are using UTF-8 as the internal format, it does not<br>&gt; mean that universal support is guaranteed.<br>&gt; &gt;<br>&gt; &gt; All I meant was this, and nothing more. If the internal format was<br>&gt; UTF-8, and you were using a filesystem whose filenames were UTF-16, you<br>&gt; would have the same problems.<br>&gt; &gt;<br>&gt; &gt; -Kenny<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; &gt; On Aug 17, 2016, at 10:40 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt;<br>&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;&gt; In Félix’s case, I would expect to have to ask for a mail-friendly<br>&gt; representation of his name, just like you have to ask for a<br>&gt; filesystem-friendly representation of a filename regardless of what the<br>&gt; internal representation is. Just because you are using UTF-8 as the<br>&gt; internal format, it does not mean that universal support is guaranteed.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Would you imagine if &quot;n&quot; turned out to be poorly supported by systems<br>&gt; throughout the world and dead-serious people argued that it&#39;s too hard for<br>&gt; beginners?<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; &quot;Filesystem-friendly&quot; and &quot;email-friendly&quot; names are not backed by<br>&gt; modern standards. You can have essentially any character that you like in a<br>&gt; file name save for the directory separator on almost every platform out<br>&gt; there (except on Windows, but the constraints are implemented in a layer<br>&gt; above NTFS), and addresses like félix at ... are RFC-legal. Restrictions are<br>&gt; merely wished into existence by programmers who don&#39;t want to complicate<br>&gt; their mental model of text processing, to everyone else&#39;s detriment.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Félix<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/73bcccfa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>August 18, 2016 at 03:00:00pm</p></header><div class="content"><p>When I say &amp;quot;reinterpret&amp;quot;, I mean taking the UTF-8 bytes and pretend that they&amp;#39;re UTF-16. This is an extremely clear bug whenever it happens. The correct conversion between UTF-8 and UTF-16 is lossless.<br></p><p>The vast majority of systems, including file systems and email addresses, support Unicode. I&amp;#39;m struggling to come up with an example where a restriction isn&amp;#39;t the result of lazy assumptions. It&amp;#39;s not like we have to pause and check that every link on the network path is 8-bit clean anymore. <br></p><p>Félix<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/456e129a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/42eca71033ece251f2f194b7e343c2ec?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Magnus Ahltorp</string> &lt;map at kth.se&gt;<p>August 23, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; 18 Aug. 2016 07:40 Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; In Félix’s case, I would expect to have to ask for a mail-friendly representation of his name, just like you have to ask for a filesystem-friendly representation of a filename regardless of what the internal representation is. Just because you are using UTF-8 as the internal format, it does not mean that universal support is guaranteed.<br>&gt; <br>&gt; Would you imagine if &quot;n&quot; turned out to be poorly supported by systems throughout the world and dead-serious people argued that it&#39;s too hard for beginners?<br>&gt; <br>&gt; &quot;Filesystem-friendly&quot; and &quot;email-friendly&quot; names are not backed by modern standards. You can have essentially any character that you like in a file name save for the directory separator on almost every platform out there (except on Windows, but the constraints are implemented in a layer above NTFS), and addresses like félix at ... are RFC-legal. Restrictions are merely wished into existence by programmers who don&#39;t want to complicate their mental model of text processing, to everyone else&#39;s detriment.<br></p><p>Also, until quite recently &quot;filesystem-friendly&quot; meant &quot;only uppercase characters&quot; and that only 8 (or on some systems only 6) characters could be used. Maybe these ASCII proponents want us to write everything in uppercase as well? And limit our identifiers to 6 characters. Now there&#39;s a proposal I can get behind!<br></p><p>FUNC HLOWRL(S: STRING) -&gt; STRING {<br>    RETURN &quot;HELLO, WORLD: \(S)&quot; <br>}<br></p><p>Or, to take your example with &quot;n&quot; not being supported (&quot;m&quot; is pretty close both phonetically and graphically):<br></p><p>FUMC HLOWRL(S: STRIMG) -&gt; STRIMG {<br>    RETURM &quot;HELLO, WORLD: \(S)&quot; <br>}<br></p><p>Still readable, right? And very easy for beginners.<br></p><p>/Magnus<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b0a8a8751387599c6d98c36808e8916c?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>William Sumner</string> &lt;prestonsumner at me.com&gt;<p>August 17, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Aug 17, 2016, at 10:40 AM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I understand that the most friendly approach may not be the most efficient, but that’s not what I’m pushing for. I’m pushing for &quot;does the thing people would most commonly expect”. Take a first-time programmer who reads any (human) language, and that is what they would expect.<br>&gt; <br>&gt; Why couldn’t String’s internal storage format be glyph-based? If I were, say, writing a text editor, it would certainly be the easiest and most efficient format to work in.<br>&gt; <br>&gt; -Kenny<br></p><p>Can you be more specific about the improvements you’d like to see? Based on an earlier message, you want to be able to use subscripting on strings to retrieve visual glyphs, but you can do this now via the .characters property, which presents a view of the string’s contents as a collection of extended grapheme clusters.<br></p><p>Preston<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>August 17, 2016 at 07:00:00pm</p></header><div class="content"><p>I would also like to understand the perceived problem for first time<br>programmers. To me first time programmers would be working with string<br>literals (&quot;hello world&quot;), string literals with values in them (&quot;Hello<br>/(name)&quot;), doing basic string concat, using higher level API of string to<br>do and find things in a string, etc..<br></p><p>I think indexing into a string is actually a complex programming task and<br>usually is the last thing you want to be doing outside specific problem<br>domains.<br></p><p>On Wed, Aug 17, 2016 at 12:38 PM William Sumner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Aug 17, 2016, at 10:40 AM, Kenny Leung via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I understand that the most friendly approach may not be the most<br>&gt; efficient, but that’s not what I’m pushing for. I’m pushing for &quot;does the<br>&gt; thing people would most commonly expect”. Take a first-time programmer who<br>&gt; reads any (human) language, and that is what they would expect.<br>&gt; &gt;<br>&gt; &gt; Why couldn’t String’s internal storage format be glyph-based? If I were,<br>&gt; say, writing a text editor, it would certainly be the easiest and most<br>&gt; efficient format to work in.<br>&gt; &gt;<br>&gt; &gt; -Kenny<br>&gt;<br>&gt; Can you be more specific about the improvements you’d like to see? Based<br>&gt; on an earlier message, you want to be able to use subscripting on strings<br>&gt; to retrieve visual glyphs, but you can do this now via the .characters<br>&gt; property, which presents a view of the string’s contents as a collection of<br>&gt; extended grapheme clusters.<br>&gt;<br>&gt; Preston<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/20b0ae2e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>August 17, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; William Sumner says:<br>&gt; Can you be more specific about the improvements you’d like to see? Based on an earlier message, you want to be able to use subscripting on strings to retrieve visual glyphs, but you can do this now via the .characters property, which presents a view of the string’s contents as a collection of extended grapheme clusters.<br></p><p>I did not know about .characters. I would say this addresses the glyph portion of my issues.<br></p><p>I still have a problem with not being able to index using simple integers to create subscripts or ranges. I wrote my own “split&quot; function, and found it extremely frustrating to have to work with .Index types instead of being able to use integers for subscripts and ranges. Compared to other languages, this almost obviates the usefulness of subscripts altogether. I understand that there are performance implications with translating integer subscripts into actual indexes in the string, but I guess this is a case where even generating another view on the string doesn’t do enough (internally) to make it worthwhile. Perhaps if it did… Again, this is very beginner unfriendly. I guess I will amend my definition of beginner to not only include people new to programming, but people already experienced in languages besides Swift. Now that I think about it, NSString is as powerful as Swift.String when ti comes to Unicode, and it still allows integer based indexing.<br></p><p>Another issue I have is that a String itself is not subscriptable, but that you have to get a view of it. I think String should have some default subscriptability that “does the right thing”, whatever that is decided to be.<br></p><p>&lt;heart-to-heart on&gt;<br>Now that we’re getting to the heart of the problem (thanks for the prompting me to think more deeply about it), Swift may be more frustrating to learn for experienced programmers coming from C, Objective-C, Java, Ruby, etc. You try to do the simplest think like index into a string, and then find out you can’t - you think to yourself, “I’ve been programming in Objective-C for 20 years. Why can’t I do this? Am I stupid? Is the Swift team purposely trying to make this hard for me?”<br></p><p>I’ve been reading swift-evolution for a long time now, and a reason often given for design decisions is “term of art”. I believe that integer-based subscriptablilty is a term of art that should be supported.<br>&lt;heart-to-heart off&gt;<br></p><p><br>&gt; On Aug 17, 2016, at 12:51 PM, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt; <br>&gt; I would also like to understand the perceived problem for first time programmers. To me first time programmers would be working with string literals (&quot;hello world&quot;), string literals with values in them (&quot;Hello /(name)&quot;), doing basic string concat, using higher level API of string to do and find things in a string, etc..<br></p><p>I guess it’s a matter of opinion what features beginner programmers will dip their toes into, but I think string manipulation is not that far up the totem pole. Would you consider splitting a comma-separated string an advanced task?<br></p><p>Also, see my revised definition of beginner programmer above.<br></p><p>-Kenny<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b0a8a8751387599c6d98c36808e8916c?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>William Sumner</string> &lt;prestonsumner at me.com&gt;<p>August 17, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Aug 17, 2016, at 2:34 PM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; William Sumner says:<br>&gt;&gt; Can you be more specific about the improvements you’d like to see? Based on an earlier message, you want to be able to use subscripting on strings to retrieve visual glyphs, but you can do this now via the .characters property, which presents a view of the string’s contents as a collection of extended grapheme clusters.<br>&gt; <br>&gt; I did not know about .characters. I would say this addresses the glyph portion of my issues.<br>&gt; <br>&gt; I still have a problem with not being able to index using simple integers to create subscripts or ranges. I wrote my own “split&quot; function, and found it extremely frustrating to have to work with .Index types instead of being able to use integers for subscripts and ranges. Compared to other languages, this almost obviates the usefulness of subscripts altogether. I understand that there are performance implications with translating integer subscripts into actual indexes in the string, but I guess this is a case where even generating another view on the string doesn’t do enough (internally) to make it worthwhile. Perhaps if it did… Again, this is very beginner unfriendly. I guess I will amend my definition of beginner to not only include people new to programming, but people already experienced in languages besides Swift. Now that I think about it, NSString is as powerful as Swift.String when ti comes to Unicode, and it still allows integer based indexing.<br>&gt; <br>&gt; Another issue I have is that a String itself is not subscriptable, but that you have to get a view of it. I think String should have some default subscriptability that “does the right thing”, whatever that is decided to be.<br>&gt; <br>&gt; &lt;heart-to-heart on&gt;<br>&gt; Now that we’re getting to the heart of the problem (thanks for the prompting me to think more deeply about it), Swift may be more frustrating to learn for experienced programmers coming from C, Objective-C, Java, Ruby, etc. You try to do the simplest think like index into a string, and then find out you can’t - you think to yourself, “I’ve been programming in Objective-C for 20 years. Why can’t I do this? Am I stupid? Is the Swift team purposely trying to make this hard for me?”<br>&gt; <br>&gt; I’ve been reading swift-evolution for a long time now, and a reason often given for design decisions is “term of art”. I believe that integer-based subscriptablilty is a term of art that should be supported.<br>&gt; &lt;heart-to-heart off&gt;<br></p><p>Note that working with individual characters of a NSString can be unsafe because a visual glyph may be represented by multiple characters. NSString provides methods like rangeOfComposedCharacterSequencesForRange: to enable you to align your character retrievals along grapheme cluster boundaries.<br></p><p>You may be interested in this article by Mike Ash, which gives a rationale for the String API, including why indexes aren&#39;t simple integers: https://www.mikeash.com/pyblog/friday-qa-2015-11-06-why-is-swifts-string-api-so-hard.html<br></p><p>In short, these are not simple accesses but potentially expensive operations, and integer subscripting could give users the assumption that they’re accessing arrays with no performance overhead.<br></p><p>Preston<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>August 17, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Aug 17, 2016, at 1:57 PM, William Sumner &lt;prestonsumner at me.com&gt; wrote:<br></p><p>&gt; You may be interested in this article by Mike Ash, which gives a rationale for the String API, including why indexes aren&#39;t simple integers: https://www.mikeash.com/pyblog/friday-qa-2015-11-06-why-is-swifts-string-api-so-hard.html<br></p><p>Thanks for the pointer.<br></p><p>I guess being told *why* the String API is so hard doesn’t make me feel much better about the fact that it *is* hard.<br></p><p>It opens:<br></p><p>“One of the biggest complaints I see from people using Swift is the String API. It&#39;s difficult and obtuse, and people often wish it were more like string APIs in other languages.”<br></p><p>It’s been said on the list that they are thinking about rewriting the String at some point. I’m hoping that the API can be made simpler.<br></p><p>-Kenny<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 17, 2016 at 05:00:00pm</p></header><div class="content"><p>On Wed, Aug 17, 2016 at 5:03 PM, Kenny Leung via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Aug 17, 2016, at 1:57 PM, William Sumner &lt;prestonsumner at me.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; &gt; You may be interested in this article by Mike Ash, which gives a<br>&gt; rationale for the String API, including why indexes aren&#39;t simple integers:<br>&gt; https://www.mikeash.com/pyblog/friday-qa-2015-11-06-<br>&gt; why-is-swifts-string-api-so-hard.html<br>&gt;<br>&gt; Thanks for the pointer.<br>&gt;<br>&gt; I guess being told *why* the String API is so hard doesn’t make me feel<br>&gt; much better about the fact that it *is* hard.<br>&gt;<br>&gt; It opens:<br>&gt;<br>&gt; “One of the biggest complaints I see from people using Swift is the String<br>&gt; API. It&#39;s difficult and obtuse, and people often wish it were more like<br>&gt; string APIs in other languages.”<br>&gt;<br>&gt; It’s been said on the list that they are thinking about rewriting the<br>&gt; String at some point. I’m hoping that the API can be made simpler.<br>&gt;<br></p><p>I too am excited to see what improvements may come.<br></p><p>That said, the Swift String APIs are far and away *the best* string APIs<br>I&#39;ve ever worked with, precisely because they promote _correct_ code in so<br>many ways that alternative &quot;simpler&quot; APIs don&#39;t. It&#39;s exactly this learning<br>process, where you learn that index-based slicing of NSString is unsafe and<br>that traversing Strings character-by-character is computationally<br>expensive, and then you find that you don&#39;t need to use either the unsafe<br>or the expensive methods after all, that reveals the power of the design.<br>As a result, you now have a Unicode-ready *and* performant slice algorithm.<br>The fact that you&#39;ve been guided to this end result by the API design is<br>precisely what makes me appreciate it so much!<br></p><p><br>&gt; -Kenny<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/7f2a8acf/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>August 17, 2016 at 02:00:00pm</p></header><div class="content"><p>Looking at the String reference again, I see that Swift.String is subscriptable. Also, I was able to write my “split” function without using subscripting at all:<br></p><p>public extension String {<br>    public func split(_ pattern :String) -&gt; [String] {<br>        var results = [String]()<br>        var remaining = self.startIndex..&lt;self.endIndex;<br>        while let matchRange = self.range(of:pattern, options: .regularExpressionSearch, range: remaining, locale: nil) {<br>            results.append(self.substring(with: remaining.lowerBound..&lt;matchRange.lowerBound))<br>            remaining = matchRange.upperBound..&lt;self.endIndex<br>        }<br>        results.append(self.substring(with:remaining))<br>        return results<br>    }    <br>}<br></p><p>So it seems I’ve painted myself into a corner...<br></p><p>-Kenny<br></p><p><br>&gt; On Aug 17, 2016, at 1:34 PM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; William Sumner says:<br>&gt;&gt; Can you be more specific about the improvements you’d like to see? Based on an earlier message, you want to be able to use subscripting on strings to retrieve visual glyphs, but you can do this now via the .characters property, which presents a view of the string’s contents as a collection of extended grapheme clusters.<br>&gt; <br>&gt; I did not know about .characters. I would say this addresses the glyph portion of my issues.<br>&gt; <br>&gt; I still have a problem with not being able to index using simple integers to create subscripts or ranges. I wrote my own “split&quot; function, and found it extremely frustrating to have to work with .Index types instead of being able to use integers for subscripts and ranges. Compared to other languages, this almost obviates the usefulness of subscripts altogether. I understand that there are performance implications with translating integer subscripts into actual indexes in the string, but I guess this is a case where even generating another view on the string doesn’t do enough (internally) to make it worthwhile. Perhaps if it did… Again, this is very beginner unfriendly. I guess I will amend my definition of beginner to not only include people new to programming, but people already experienced in languages besides Swift. Now that I think about it, NSString is as powerful as Swift.String when ti comes to Unicode, and it still allows integer based indexing.<br>&gt; <br>&gt; Another issue I have is that a String itself is not subscriptable, but that you have to get a view of it. I think String should have some default subscriptability that “does the right thing”, whatever that is decided to be.<br>&gt; <br>&gt; &lt;heart-to-heart on&gt;<br>&gt; Now that we’re getting to the heart of the problem (thanks for the prompting me to think more deeply about it), Swift may be more frustrating to learn for experienced programmers coming from C, Objective-C, Java, Ruby, etc. You try to do the simplest think like index into a string, and then find out you can’t - you think to yourself, “I’ve been programming in Objective-C for 20 years. Why can’t I do this? Am I stupid? Is the Swift team purposely trying to make this hard for me?”<br>&gt; <br>&gt; I’ve been reading swift-evolution for a long time now, and a reason often given for design decisions is “term of art”. I believe that integer-based subscriptablilty is a term of art that should be supported.<br>&gt; &lt;heart-to-heart off&gt;<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 17, 2016, at 12:51 PM, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I would also like to understand the perceived problem for first time programmers. To me first time programmers would be working with string literals (&quot;hello world&quot;), string literals with values in them (&quot;Hello /(name)&quot;), doing basic string concat, using higher level API of string to do and find things in a string, etc..<br>&gt; <br>&gt; I guess it’s a matter of opinion what features beginner programmers will dip their toes into, but I think string manipulation is not that far up the totem pole. Would you consider splitting a comma-separated string an advanced task?<br>&gt; <br>&gt; Also, see my revised definition of beginner programmer above.<br>&gt; <br>&gt; -Kenny<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b0a8a8751387599c6d98c36808e8916c?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>William Sumner</string> &lt;prestonsumner at me.com&gt;<p>August 15, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Aug 14, 2016, at 4:41 PM, Michael Savich via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Back in Swift 1.0, subscripting a String was easy, you could just use subscripting in a very Python like way. But now, things are a bit more complicated. I recognize why we need syntax like str.startIndex.advancedBy(x) but it has its downsides. Namely, it makes things hard on beginners. If one of Swift&#39;s goals is to make it a great first language, this syntax fights that. Imagine having to explain Unicode and character size to an 8 year old. This is doubly problematic because String manipulation is one of the first things new coders might want to do. <br>&gt; <br>&gt; What about having an InternalString subclass that only supports one encoding, allowing it to be subscripted with Ints? The idea is that an InternalString is for Strings that are more or less hard coded into the app. Dictionary keys, enum raw values, that kind of stuff. This also has the added benefit of forcing the programmer to think about what the String is being used for. Is it user facing? Or is it just for internal use? And of course, it makes code dealing with String manipulation much more concise and readable.<br>&gt; <br>&gt; It follows that something like this would need to be entered as a literal to make it as easy as using String. One way would be to make all String literals InternalStrings, but that sounds far too drastic. Maybe appending an exclamation point like &quot;this&quot;! Or even just wrapping the whole thing in exclamation marks like !&quot;this&quot;! Of course, we could go old school and write it like @&quot;this&quot; …That last one is a joke.<br>&gt; <br>&gt; I&#39;ll be the first to admit I&#39;m way in over my head here, so I&#39;m very open to suggestions and criticism. Thanks!<br></p><p>If desired for educational purposes, subscripting can be added to String as an extension. On the other hand, the current APIs convey the performance costs of traversing strings. In my opinion, that is the correct approach to learn in a Unicode-aware world.<br></p><p>Preston<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160815/db5da471/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 16, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Aug 14, 2016, at 3:41 PM, Michael Savich via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What about having an InternalString subclass that only supports one encoding, allowing it to be subscripted with Ints? The idea is that an InternalString is for Strings that are more or less hard coded into the app. Dictionary keys, enum raw values, that kind of stuff. This also has the added benefit of forcing the programmer to think about what the String is being used for. Is it user facing? Or is it just for internal use? And of course, it makes code dealing with String manipulation much more concise and readable.<br></p><p>If you actually just want an ASCII string, you can just use an Array&lt;UInt8&gt; and avoid all the complexity of Unicode altogether. You won’t get the string literal syntax, but if you’re really adventurous you can wrap it in a new struct type, and define an ExpressibleByStringLiteral conformance.<br></p><p>Slava<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>August 16, 2016 at 09:00:00pm</p></header><div class="content"><p>Here&#39;s a little prior discussion about ASCIIString:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002138.html<br></p><p>Jacob<br></p><p>On Sun, Aug 14, 2016 at 3:41 PM, Michael Savich via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Back in Swift 1.0, subscripting a String was easy, you could just use<br>&gt; subscripting in a very Python like way. But now, things are a bit more<br>&gt; complicated. I recognize why we need syntax like<br>&gt; str.startIndex.advancedBy(x) but it has its downsides. Namely, it makes<br>&gt; things hard on beginners. If one of Swift&#39;s goals is to make it a great<br>&gt; first language, this syntax fights that. Imagine having to explain Unicode<br>&gt; and character size to an 8 year old. This is doubly problematic because<br>&gt; String manipulation is one of the first things new coders might want to do.<br>&gt;<br>&gt; What about having an InternalString subclass that only supports one<br>&gt; encoding, allowing it to be subscripted with Ints? The idea is that an<br>&gt; InternalString is for Strings that are more or less hard coded into the<br>&gt; app. Dictionary keys, enum raw values, that kind of stuff. This also has<br>&gt; the added benefit of forcing the programmer to think about what the String<br>&gt; is being used for. Is it user facing? Or is it just for internal use? And<br>&gt; of course, it makes code dealing with String manipulation much more concise<br>&gt; and readable.<br>&gt;<br>&gt; It follows that something like this would need to be entered as a literal<br>&gt; to make it as easy as using String. One way would be to make all String<br>&gt; literals InternalStrings, but that sounds far too drastic. Maybe appending<br>&gt; an exclamation point like &quot;this&quot;! Or even just wrapping the whole thing in<br>&gt; exclamation marks like !&quot;this&quot;! Of course, we could go old school and write<br>&gt; it like @&quot;this&quot; …That last one is a joke.<br>&gt;<br>&gt; I&#39;ll be the first to admit I&#39;m way in over my head here, so I&#39;m very open<br>&gt; to suggestions and criticism. Thanks!<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/9dcb9859/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 16, 2016 at 11:00:00pm</p></header><div class="content"><p>Nice, thanks :)<br>FWIW, there are at least some ASCII-specific optimizations internally in<br>String (this was a question asked and not answered in the prior thread).<br></p><p>On Tue, Aug 16, 2016 at 11:21 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Here&#39;s a little prior discussion about ASCIIString: https://lists.<br>&gt; swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002138.html<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; On Sun, Aug 14, 2016 at 3:41 PM, Michael Savich via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Back in Swift 1.0, subscripting a String was easy, you could just use<br>&gt;&gt; subscripting in a very Python like way. But now, things are a bit more<br>&gt;&gt; complicated. I recognize why we need syntax like<br>&gt;&gt; str.startIndex.advancedBy(x) but it has its downsides. Namely, it makes<br>&gt;&gt; things hard on beginners. If one of Swift&#39;s goals is to make it a great<br>&gt;&gt; first language, this syntax fights that. Imagine having to explain Unicode<br>&gt;&gt; and character size to an 8 year old. This is doubly problematic because<br>&gt;&gt; String manipulation is one of the first things new coders might want to do.<br>&gt;&gt;<br>&gt;&gt; What about having an InternalString subclass that only supports one<br>&gt;&gt; encoding, allowing it to be subscripted with Ints? The idea is that an<br>&gt;&gt; InternalString is for Strings that are more or less hard coded into the<br>&gt;&gt; app. Dictionary keys, enum raw values, that kind of stuff. This also has<br>&gt;&gt; the added benefit of forcing the programmer to think about what the String<br>&gt;&gt; is being used for. Is it user facing? Or is it just for internal use? And<br>&gt;&gt; of course, it makes code dealing with String manipulation much more concise<br>&gt;&gt; and readable.<br>&gt;&gt;<br>&gt;&gt; It follows that something like this would need to be entered as a literal<br>&gt;&gt; to make it as easy as using String. One way would be to make all String<br>&gt;&gt; literals InternalStrings, but that sounds far too drastic. Maybe appending<br>&gt;&gt; an exclamation point like &quot;this&quot;! Or even just wrapping the whole thing in<br>&gt;&gt; exclamation marks like !&quot;this&quot;! Of course, we could go old school and write<br>&gt;&gt; it like @&quot;this&quot; …That last one is a joke.<br>&gt;&gt;<br>&gt;&gt; I&#39;ll be the first to admit I&#39;m way in over my head here, so I&#39;m very open<br>&gt;&gt; to suggestions and criticism. Thanks!<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/0e7ea490/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>InternalString class for easy String manipulation</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>August 17, 2016 at 09:00:00am</p></header><div class="content"><p>I&#39;d just like to leave it here that Microsoft called me &quot;F+¬lix&quot; in corporate communications this morning. I&#39;ve never seen that variation before. If Microsoft used Swift, I would like this to be borderline impossible for them to screw up. :)<br></p><p>Félix<br></p><p>&gt; Le 16 août 2016 à 21:27:54, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Nice, thanks :)<br>&gt; FWIW, there are at least some ASCII-specific optimizations internally in String (this was a question asked and not answered in the prior thread).<br>&gt; <br>&gt; On Tue, Aug 16, 2016 at 11:21 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Here&#39;s a little prior discussion about ASCIIString: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002138.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/002138.html&gt;<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Sun, Aug 14, 2016 at 3:41 PM, Michael Savich via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Back in Swift 1.0, subscripting a String was easy, you could just use subscripting in a very Python like way. But now, things are a bit more complicated. I recognize why we need syntax like str.startIndex.advancedBy(x) but it has its downsides. Namely, it makes things hard on beginners. If one of Swift&#39;s goals is to make it a great first language, this syntax fights that. Imagine having to explain Unicode and character size to an 8 year old. This is doubly problematic because String manipulation is one of the first things new coders might want to do. <br>&gt; <br>&gt; What about having an InternalString subclass that only supports one encoding, allowing it to be subscripted with Ints? The idea is that an InternalString is for Strings that are more or less hard coded into the app. Dictionary keys, enum raw values, that kind of stuff. This also has the added benefit of forcing the programmer to think about what the String is being used for. Is it user facing? Or is it just for internal use? And of course, it makes code dealing with String manipulation much more concise and readable.<br>&gt; <br>&gt; It follows that something like this would need to be entered as a literal to make it as easy as using String. One way would be to make all String literals InternalStrings, but that sounds far too drastic. Maybe appending an exclamation point like &quot;this&quot;! Or even just wrapping the whole thing in exclamation marks like !&quot;this&quot;! Of course, we could go old school and write it like @&quot;this&quot; …That last one is a joke.<br>&gt; <br>&gt; I&#39;ll be the first to admit I&#39;m way in over my head here, so I&#39;m very open to suggestions and criticism. Thanks!<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/5b951707/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
