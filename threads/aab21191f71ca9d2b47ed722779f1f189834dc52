<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 27, 2016 at 10:00:00am</p></header><div class="content"><p>on Wed Jan 27 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Doug,<br>&gt;<br>&gt; I think this change looks great!  I don’t have time to look through<br>&gt; the full patch but did look through quite a bit.  It adds clarity in<br>&gt; the vast majority of cases I looked at.<br>&gt;<br>&gt; It seems like with-as-separator is a good heuristic for determining<br>&gt; when the first parameter is not essential to a good name for the<br>&gt; fundamental operation.  I agree with the comments earlier on that in<br>&gt; these cases a label for the first parameter is the best approach.<br>&gt;<br>&gt; I also really like that this groups methods with the same fundamental<br>&gt; operation into overload families where they previously had independent<br>&gt; names.  This is a big win IMO.<br>&gt;<br>&gt; There is a first-parameter-is-an-ID pattern I noticed after this<br>&gt; change.  I show a few examples here, but there are a lot more:<br>&gt;<br>&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt;<br>&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>&gt;<br>&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt;<br>&gt; - func discoverUserInfoWithUserRecordID(userRecordID: CKRecordID,<br>&gt; completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt;<br>&gt; + func discoverUserInfo(userRecordID userRecordID: CKRecordID,<br>&gt; completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt;<br>&gt; The first argument label `trackID` seems like it repeats type<br>&gt; information without adding clarity.  I think it would be better to<br>&gt; just use `id` here.  It seems like a candidate for heuristics as well.<br>&gt; For example, if the type name ends in ID and the label is a suffix of<br>&gt; the type name we could just use `id`.  This is a somewhat specific<br>&gt; pattern, but IDs are common enough that it might make sense.<br></p><p>Actually I&#39;ve been saying for a while that arguments called ID,<br>identifier, and name should not be labelled at all in many cases.  Think<br>about it.<br></p><p>&gt; Interestingly, in at least one case the `WithID` was the original name<br>&gt; of the method so we did receive a simple `id` label:<br>&gt;<br>&gt; - func parameterWithID(paramID: AudioUnitParameterID, scope:<br>&gt; AudioUnitScope, element: AudioUnitElement) -&gt; AUParameter?<br>&gt; + func parameter(id paramID: AudioUnitParameterID, scope:<br>&gt; AudioUnitScope, element: AudioUnitElement) -&gt; AUParameter?<br>&gt;<br>&gt; In another case, the method has a naked `With` at the end.  Somehow<br>&gt; `id` was used in that scenario despite the parameter name being<br>&gt; `objectID` and the type being `NSManagedObjectID`, which aligns with<br>&gt; my suggested naming:<br>&gt;<br>&gt; - func newValuesForObjectWith(objectID: NSManagedObjectID, withContext<br>&gt; context: NSManagedObjectContext) throws -&gt; NSIncrementalStoreNode<br>&gt; + func newValuesForObject(id objectID: NSManagedObjectID, withContext<br>&gt; context: NSManagedObjectContext) throws -&gt; NSIncrementalStoreNode<br>&gt;<br>&gt; A case related to that used `iDs` for array arguments:  <br>&gt;<br>&gt; -  func managedObjectContextDidRegisterObjectsWithIDs(objectIDs: [NSManagedObjectID])<br>&gt; -  func managedObjectContextDidUnregisterObjectsWithIDs(objectIDs: [NSManagedObjectID])<br>&gt; +  func managedObjectContextDidRegisterObjects(iDs objectIDs: [NSManagedObjectID])<br>&gt; +  func managedObjectContextDidUnregisterObjects(iDs objectIDs: [NSManagedObjectID])<br>&gt;<br>&gt; I would prefer `ids` here.  This seems like a pattern that would be a<br>&gt; problem for any all-caps plural acronym or initialism so it might be<br>&gt; good to add a heuristic for this as well.<br>&gt;<br>&gt; Here’s another interesting change:<br>&gt;<br>&gt; -  func unionWith(s2: CIFilterShape) -&gt; CIFilterShape<br>&gt; -  func unionWith(r: CGRect) -&gt; CIFilterShape<br>&gt; -  func intersectWith(s2: CIFilterShape) -&gt; CIFilterShape<br>&gt; -  func intersectWith(r: CGRect) -&gt; CIFilterShape<br>&gt; +  func union(with s2: CIFilterShape) -&gt; CIFilterShape<br>&gt; +  func union(rect r: CGRect) -&gt; CIFilterShape<br>&gt; +  func intersect(with s2: CIFilterShape) -&gt; CIFilterShape<br>&gt; +  func intersect(rect r: CGRect) -&gt; CIFilterShape<br>&gt;<br>&gt; Why do the CGRect arguments receive a type-derived label but the<br>&gt; CIFilterShape arguments just receive `with`?  Shouldn’t these follow<br>&gt; the same pattern?<br>&gt;<br>&gt; -Matthew<br>&gt;<br>&gt;&gt; On Jan 27, 2016, at 1:50 AM, Douglas Gregor via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 25, 2016, at 6:55 AM, Radosław Pietruszewski<br>&gt;&gt;&gt; &lt;radexpl at gmail.com<br>&gt;&gt;&gt; &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m overwhelmingly *for* this proposal. I think removing needless<br>&gt;&gt;&gt; verbosity and keeping the signal-to-noise ratio high is one of the<br>&gt;&gt;&gt; most immediately appealing aspects of Swift, as well as a great<br>&gt;&gt;&gt; general improvement to the programming experience.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And so unswiftified (yes, it’s a word now) APIs from Objective-C<br>&gt;&gt;&gt; stick out like a sore thumb. Not only are they harder to read and<br>&gt;&gt;&gt; write, they visually overwhelm the less verbose, information-dense<br>&gt;&gt;&gt; Swift-first code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just like previous 1.0—2.0 attempts at bridging the gap (with<br>&gt;&gt;&gt; NSError params being translated to Swift errors, factory methods<br>&gt;&gt;&gt; translated to initializers, etc.), automating this will be an<br>&gt;&gt;&gt; error-prone process, and almost bound to be a bit annoying at<br>&gt;&gt;&gt; first, before all the glitches and poor translations are smoothed<br>&gt;&gt;&gt; out. And yet I feel like just like the previous automated<br>&gt;&gt;&gt; translations were overwhelmingly a great thing, so will the result<br>&gt;&gt;&gt; of this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * * *<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    Add First Argument Labels<br>&gt;&gt;&gt;&gt;    <br>&gt;&gt;&gt;&gt;    - func enumerateObjectsWith(_: NSEnumerationOptions = [],<br>&gt;&gt;&gt;&gt; using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt;    + func enumerateObjects(options _: NSEnumerationOptions = [],<br>&gt;&gt;&gt;&gt; using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Good! The Guidelines recommend an explicit first parameter label<br>&gt;&gt;&gt; for arguments with a default value, but this is a good change also<br>&gt;&gt;&gt; for another reason, a use case not included in the Guidelines (I<br>&gt;&gt;&gt; have more to say about this in the SE-0023 thread):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; “Options” is the description of the parameter, not the method<br>&gt;&gt;&gt; itself. Even if (for whatever reason!) `options` didn’t have a<br>&gt;&gt;&gt; default value and the word “Options” wasn’t omitted in the<br>&gt;&gt;&gt; translation,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    enumerateObjects(options: …)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; would be clearer than<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    enumerateObjectsWithOptions(…)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s not even about the extra word, about the four useless<br>&gt;&gt;&gt; characters, it’s simply that “WithOptions” doesn’t describe the<br>&gt;&gt;&gt; operation at all. It’s a word that conveys no information (“with”),<br>&gt;&gt;&gt; and “options”, which describes the first parameter. In Objective-C,<br>&gt;&gt;&gt; there’s no such thing as parameter labels, it’s all one name, so<br>&gt;&gt;&gt; “With” is used as a separator. But in Swift, making the first<br>&gt;&gt;&gt; parameter’s label explicit just makes more sense.<br>&gt;&gt; <br>&gt;&gt; That’s an interesting thought! If “with” is truly used as a<br>&gt;&gt; convention for separating the description of the operation from the<br>&gt;&gt; description of the first parameter, that’s something that can be<br>&gt;&gt; codified in the Clang importer. I was curious, so I hacked it<br>&gt;&gt; up. Here’s a diff of the Cocoa APIs that shows what things would<br>&gt;&gt; look like if we treated “with” as a separator:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5/files<br>&gt;&gt; &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5/files&gt;<br>&gt;&gt; <br>&gt;&gt; It’s a diff against SE-0005, and it introduces a significant number<br>&gt;&gt; of first argument labels. Indeed, you’ll need to grab the patch to<br>&gt;&gt; see them all:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch<br>&gt;&gt; &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch&gt;<br>&gt;&gt; <br>&gt;&gt; A brief survey shows that some cases seem to be lining up with the<br>&gt;&gt; guideline proposals that have been under discussion. For example,<br>&gt;&gt; the patch includes:<br>&gt;&gt; <br>&gt;&gt; -  func fillWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt; -  func strokeWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt; +  func fill(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt; +  func stroke(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt; <br>&gt;&gt; -  func encodeWith(aCoder: Coder)<br>&gt;&gt; +  func encode(coder aCoder: Coder)<br>&gt;&gt; <br>&gt;&gt; which you might recognize, because it’s the example you used:<br>&gt;&gt; <br>&gt;&gt;&gt; And with that in mind, I object to these translations:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    func fillWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;    func strokeWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;    func encodeWith(_: Coder)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even though these don’t have default values, I believe this version<br>&gt;&gt;&gt; to be clearer and make more sense, even if slightly more verbose:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;    func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;    func encode(coder: Coder)<br>&gt;&gt; <br>&gt;&gt; Another random interesting example I encountered:<br>&gt;&gt; <br>&gt;&gt; -  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt; +  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt; <br>&gt;&gt; which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br>&gt;&gt; <br>&gt;&gt; There’s also this:<br>&gt;&gt; <br>&gt;&gt; -  func tracksWithMediaType(mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt; +  func tracks(mediaType mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt; <br>&gt;&gt; -  func tracksWithMediaCharacteristic(mediaCharacteristic: String) -&gt;<br>&gt;&gt; +  func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt; [AVMovieTrack]<br>&gt;&gt; <br>&gt;&gt; which feels reminiscent of Paul’s “resource” example:<br>&gt;&gt; <br>&gt;&gt;     service.resource(&quot;/foo&quot;)<br>&gt;&gt;     service.resource(absoluteURL: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;)<br>&gt;&gt;     service.resource(absoluteURL: NSURL(string: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;))<br>&gt;&gt; <br>&gt;&gt; where (I think) the argument is that the various methods should all have the same base name because they’re all returning “tracks” or a “resource”, respectively.<br>&gt;&gt; <br>&gt;&gt; There is a ton of data in that patch. I’d be interested to hear whether the resulting Cocoa APIs feel better in Swift—are they following the evolving set of guidelines for first argument labels that are under discussion, and are the resulting APIs clearer/more Swifty? What specific APIs work well and where does this “with-as-separator” heuristic break down?<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 27, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 12:03 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Jan 27 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Doug,<br>&gt;&gt; <br>&gt;&gt; I think this change looks great!  I don’t have time to look through<br>&gt;&gt; the full patch but did look through quite a bit.  It adds clarity in<br>&gt;&gt; the vast majority of cases I looked at.<br>&gt;&gt; <br>&gt;&gt; It seems like with-as-separator is a good heuristic for determining<br>&gt;&gt; when the first parameter is not essential to a good name for the<br>&gt;&gt; fundamental operation.  I agree with the comments earlier on that in<br>&gt;&gt; these cases a label for the first parameter is the best approach.<br>&gt;&gt; <br>&gt;&gt; I also really like that this groups methods with the same fundamental<br>&gt;&gt; operation into overload families where they previously had independent<br>&gt;&gt; names.  This is a big win IMO.<br>&gt;&gt; <br>&gt;&gt; There is a first-parameter-is-an-ID pattern I noticed after this<br>&gt;&gt; change.  I show a few examples here, but there are a lot more:<br>&gt;&gt; <br>&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt;&gt; <br>&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>&gt;&gt; <br>&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt;&gt; <br>&gt;&gt; - func discoverUserInfoWithUserRecordID(userRecordID: CKRecordID,<br>&gt;&gt; completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt;&gt; <br>&gt;&gt; + func discoverUserInfo(userRecordID userRecordID: CKRecordID,<br>&gt;&gt; completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt;&gt; <br>&gt;&gt; The first argument label `trackID` seems like it repeats type<br>&gt;&gt; information without adding clarity.  I think it would be better to<br>&gt;&gt; just use `id` here.  It seems like a candidate for heuristics as well.<br>&gt;&gt; For example, if the type name ends in ID and the label is a suffix of<br>&gt;&gt; the type name we could just use `id`.  This is a somewhat specific<br>&gt;&gt; pattern, but IDs are common enough that it might make sense.<br>&gt; <br>&gt; Actually I&#39;ve been saying for a while that arguments called ID,<br>&gt; identifier, and name should not be labelled at all in many cases.  Think<br>&gt; about it.<br></p><p>Looking at this closer, I agree in the single argument case.  However, in cases where there are other closely related arguments I think it feels odd to not label the id parameter.  Regardless, I think the ID case deserves special consideration if we go with Doug’s strategy of using `With` as a separator.<br></p><p>&gt; <br>&gt;&gt; Interestingly, in at least one case the `WithID` was the original name<br>&gt;&gt; of the method so we did receive a simple `id` label:<br>&gt;&gt; <br>&gt;&gt; - func parameterWithID(paramID: AudioUnitParameterID, scope:<br>&gt;&gt; AudioUnitScope, element: AudioUnitElement) -&gt; AUParameter?<br>&gt;&gt; + func parameter(id paramID: AudioUnitParameterID, scope:<br>&gt;&gt; AudioUnitScope, element: AudioUnitElement) -&gt; AUParameter?<br>&gt;&gt; <br>&gt;&gt; In another case, the method has a naked `With` at the end.  Somehow<br>&gt;&gt; `id` was used in that scenario despite the parameter name being<br>&gt;&gt; `objectID` and the type being `NSManagedObjectID`, which aligns with<br>&gt;&gt; my suggested naming:<br>&gt;&gt; <br>&gt;&gt; - func newValuesForObjectWith(objectID: NSManagedObjectID, withContext<br>&gt;&gt; context: NSManagedObjectContext) throws -&gt; NSIncrementalStoreNode<br>&gt;&gt; + func newValuesForObject(id objectID: NSManagedObjectID, withContext<br>&gt;&gt; context: NSManagedObjectContext) throws -&gt; NSIncrementalStoreNode<br>&gt;&gt; <br>&gt;&gt; A case related to that used `iDs` for array arguments:  <br>&gt;&gt; <br>&gt;&gt; -  func managedObjectContextDidRegisterObjectsWithIDs(objectIDs: [NSManagedObjectID])<br>&gt;&gt; -  func managedObjectContextDidUnregisterObjectsWithIDs(objectIDs: [NSManagedObjectID])<br>&gt;&gt; +  func managedObjectContextDidRegisterObjects(iDs objectIDs: [NSManagedObjectID])<br>&gt;&gt; +  func managedObjectContextDidUnregisterObjects(iDs objectIDs: [NSManagedObjectID])<br>&gt;&gt; <br>&gt;&gt; I would prefer `ids` here.  This seems like a pattern that would be a<br>&gt;&gt; problem for any all-caps plural acronym or initialism so it might be<br>&gt;&gt; good to add a heuristic for this as well.<br>&gt;&gt; <br>&gt;&gt; Here’s another interesting change:<br>&gt;&gt; <br>&gt;&gt; -  func unionWith(s2: CIFilterShape) -&gt; CIFilterShape<br>&gt;&gt; -  func unionWith(r: CGRect) -&gt; CIFilterShape<br>&gt;&gt; -  func intersectWith(s2: CIFilterShape) -&gt; CIFilterShape<br>&gt;&gt; -  func intersectWith(r: CGRect) -&gt; CIFilterShape<br>&gt;&gt; +  func union(with s2: CIFilterShape) -&gt; CIFilterShape<br>&gt;&gt; +  func union(rect r: CGRect) -&gt; CIFilterShape<br>&gt;&gt; +  func intersect(with s2: CIFilterShape) -&gt; CIFilterShape<br>&gt;&gt; +  func intersect(rect r: CGRect) -&gt; CIFilterShape<br>&gt;&gt; <br>&gt;&gt; Why do the CGRect arguments receive a type-derived label but the<br>&gt;&gt; CIFilterShape arguments just receive `with`?  Shouldn’t these follow<br>&gt;&gt; the same pattern?<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 27, 2016, at 1:50 AM, Douglas Gregor via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 25, 2016, at 6:55 AM, Radosław Pietruszewski<br>&gt;&gt;&gt;&gt; &lt;radexpl at gmail.com<br>&gt;&gt;&gt;&gt; &lt;mailto:radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m overwhelmingly *for* this proposal. I think removing needless<br>&gt;&gt;&gt;&gt; verbosity and keeping the signal-to-noise ratio high is one of the<br>&gt;&gt;&gt;&gt; most immediately appealing aspects of Swift, as well as a great<br>&gt;&gt;&gt;&gt; general improvement to the programming experience.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And so unswiftified (yes, it’s a word now) APIs from Objective-C<br>&gt;&gt;&gt;&gt; stick out like a sore thumb. Not only are they harder to read and<br>&gt;&gt;&gt;&gt; write, they visually overwhelm the less verbose, information-dense<br>&gt;&gt;&gt;&gt; Swift-first code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just like previous 1.0—2.0 attempts at bridging the gap (with<br>&gt;&gt;&gt;&gt; NSError params being translated to Swift errors, factory methods<br>&gt;&gt;&gt;&gt; translated to initializers, etc.), automating this will be an<br>&gt;&gt;&gt;&gt; error-prone process, and almost bound to be a bit annoying at<br>&gt;&gt;&gt;&gt; first, before all the glitches and poor translations are smoothed<br>&gt;&gt;&gt;&gt; out. And yet I feel like just like the previous automated<br>&gt;&gt;&gt;&gt; translations were overwhelmingly a great thing, so will the result<br>&gt;&gt;&gt;&gt; of this proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * * *<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   Add First Argument Labels<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   - func enumerateObjectsWith(_: NSEnumerationOptions = [],<br>&gt;&gt;&gt;&gt;&gt; using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt;   + func enumerateObjects(options _: NSEnumerationOptions = [],<br>&gt;&gt;&gt;&gt;&gt; using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Good! The Guidelines recommend an explicit first parameter label<br>&gt;&gt;&gt;&gt; for arguments with a default value, but this is a good change also<br>&gt;&gt;&gt;&gt; for another reason, a use case not included in the Guidelines (I<br>&gt;&gt;&gt;&gt; have more to say about this in the SE-0023 thread):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; “Options” is the description of the parameter, not the method<br>&gt;&gt;&gt;&gt; itself. Even if (for whatever reason!) `options` didn’t have a<br>&gt;&gt;&gt;&gt; default value and the word “Options” wasn’t omitted in the<br>&gt;&gt;&gt;&gt; translation,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   enumerateObjects(options: …)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; would be clearer than<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   enumerateObjectsWithOptions(…)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s not even about the extra word, about the four useless<br>&gt;&gt;&gt;&gt; characters, it’s simply that “WithOptions” doesn’t describe the<br>&gt;&gt;&gt;&gt; operation at all. It’s a word that conveys no information (“with”),<br>&gt;&gt;&gt;&gt; and “options”, which describes the first parameter. In Objective-C,<br>&gt;&gt;&gt;&gt; there’s no such thing as parameter labels, it’s all one name, so<br>&gt;&gt;&gt;&gt; “With” is used as a separator. But in Swift, making the first<br>&gt;&gt;&gt;&gt; parameter’s label explicit just makes more sense.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s an interesting thought! If “with” is truly used as a<br>&gt;&gt;&gt; convention for separating the description of the operation from the<br>&gt;&gt;&gt; description of the first parameter, that’s something that can be<br>&gt;&gt;&gt; codified in the Clang importer. I was curious, so I hacked it<br>&gt;&gt;&gt; up. Here’s a diff of the Cocoa APIs that shows what things would<br>&gt;&gt;&gt; look like if we treated “with” as a separator:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5/files &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5/files&gt;<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5/files &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5/files&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s a diff against SE-0005, and it introduces a significant number<br>&gt;&gt;&gt; of first argument labels. Indeed, you’ll need to grab the patch to<br>&gt;&gt;&gt; see them all:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch&gt;<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A brief survey shows that some cases seem to be lining up with the<br>&gt;&gt;&gt; guideline proposals that have been under discussion. For example,<br>&gt;&gt;&gt; the patch includes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func fillWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt; -  func strokeWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt; +  func fill(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt; +  func stroke(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func encodeWith(aCoder: Coder)<br>&gt;&gt;&gt; +  func encode(coder aCoder: Coder)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which you might recognize, because it’s the example you used:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And with that in mind, I object to these translations:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   func fillWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;   func strokeWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;   func encodeWith(_: Coder)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even though these don’t have default values, I believe this version<br>&gt;&gt;&gt;&gt; to be clearer and make more sense, even if slightly more verbose:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;   func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;   func encode(coder: Coder)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another random interesting example I encountered:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt;&gt; +  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There’s also this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func tracksWithMediaType(mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt; +  func tracks(mediaType mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func tracksWithMediaCharacteristic(mediaCharacteristic: String) -&gt;<br>&gt;&gt;&gt; +  func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which feels reminiscent of Paul’s “resource” example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    service.resource(&quot;/foo&quot;)<br>&gt;&gt;&gt;    service.resource(absoluteURL: &quot;http://bar.com &lt;http://bar.com/&gt; &lt;http://bar.com/ &lt;http://bar.com/&gt;&gt;&quot;)<br>&gt;&gt;&gt;    service.resource(absoluteURL: NSURL(string: &quot;http://bar.com &lt;http://bar.com/&gt; &lt;http://bar.com/ &lt;http://bar.com/&gt;&gt;&quot;))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; where (I think) the argument is that the various methods should all have the same base name because they’re all returning “tracks” or a “resource”, respectively.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is a ton of data in that patch. I’d be interested to hear whether the resulting Cocoa APIs feel better in Swift—are they following the evolving set of guidelines for first argument labels that are under discussion, and are the resulting APIs clearer/more Swifty? What specific APIs work well and where does this “with-as-separator” heuristic break down?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/2971cad0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 27, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 10:03 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Jan 27 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Doug,<br>&gt;&gt; <br>&gt;&gt; I think this change looks great!  I don’t have time to look through<br>&gt;&gt; the full patch but did look through quite a bit.  It adds clarity in<br>&gt;&gt; the vast majority of cases I looked at.<br>&gt;&gt; <br>&gt;&gt; It seems like with-as-separator is a good heuristic for determining<br>&gt;&gt; when the first parameter is not essential to a good name for the<br>&gt;&gt; fundamental operation.  I agree with the comments earlier on that in<br>&gt;&gt; these cases a label for the first parameter is the best approach.<br>&gt;&gt; <br>&gt;&gt; I also really like that this groups methods with the same fundamental<br>&gt;&gt; operation into overload families where they previously had independent<br>&gt;&gt; names.  This is a big win IMO.<br>&gt;&gt; <br>&gt;&gt; There is a first-parameter-is-an-ID pattern I noticed after this<br>&gt;&gt; change.  I show a few examples here, but there are a lot more:<br>&gt;&gt; <br>&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt;&gt; <br>&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>&gt;&gt; <br>&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt;&gt; <br>&gt;&gt; - func discoverUserInfoWithUserRecordID(userRecordID: CKRecordID,<br>&gt;&gt; completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt;&gt; <br>&gt;&gt; + func discoverUserInfo(userRecordID userRecordID: CKRecordID,<br>&gt;&gt; completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt;&gt; <br>&gt;&gt; The first argument label `trackID` seems like it repeats type<br>&gt;&gt; information without adding clarity.  I think it would be better to<br>&gt;&gt; just use `id` here.  It seems like a candidate for heuristics as well.<br>&gt;&gt; For example, if the type name ends in ID and the label is a suffix of<br>&gt;&gt; the type name we could just use `id`.  This is a somewhat specific<br>&gt;&gt; pattern, but IDs are common enough that it might make sense.<br>&gt; <br>&gt; Actually I&#39;ve been saying for a while that arguments called ID,<br>&gt; identifier, and name should not be labelled at all in many cases.  Think<br>&gt; about it.<br></p><p><br>Patch where the words “ID”, “Identifier”, and “Name” in a name are considered to match the type “String”:<br></p><p><br></p><p>… and then extending the rule to zap first argument labels named “identifier”, “id”, or “name”:<br></p><p><br></p><p><br>(I’m not sure which one of these you meant, or something different):<br></p><p><br>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/d1a6afc5/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: id-identifier-name-match-string.patch<br>Type: application/octet-stream<br>Size: 99138 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/d1a6afc5/attachment.obj&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/d1a6afc5/attachment-0001.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: id-identifier-name-no-first-arg-label.patch<br>Type: application/octet-stream<br>Size: 103120 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/d1a6afc5/attachment-0001.obj&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/d1a6afc5/attachment-0002.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>January 28, 2016 at 09:00:00am</p></header><div class="content"><p>Loss of &#39;with&#39; sounds weird in certain cases:<br></p><p>- func account(identifier identifier: String!) -&gt; ACAccount!<br>+ func account(identifier: String!) -&gt; ACAccount!<br></p><p>Sent from my iPhone<br></p><p>&gt; On 28 Jan 2016, at 00:31, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 10:03 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Jan 27 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Doug,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this change looks great!  I don’t have time to look through<br>&gt;&gt;&gt; the full patch but did look through quite a bit.  It adds clarity in<br>&gt;&gt;&gt; the vast majority of cases I looked at.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems like with-as-separator is a good heuristic for determining<br>&gt;&gt;&gt; when the first parameter is not essential to a good name for the<br>&gt;&gt;&gt; fundamental operation.  I agree with the comments earlier on that in<br>&gt;&gt;&gt; these cases a label for the first parameter is the best approach.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I also really like that this groups methods with the same fundamental<br>&gt;&gt;&gt; operation into overload families where they previously had independent<br>&gt;&gt;&gt; names.  This is a big win IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is a first-parameter-is-an-ID pattern I noticed after this<br>&gt;&gt;&gt; change.  I show a few examples here, but there are a lot more:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt;&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>&gt;&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt;&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - func discoverUserInfoWithUserRecordID(userRecordID: CKRecordID,<br>&gt;&gt;&gt; completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; + func discoverUserInfo(userRecordID userRecordID: CKRecordID,<br>&gt;&gt;&gt; completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The first argument label `trackID` seems like it repeats type<br>&gt;&gt;&gt; information without adding clarity.  I think it would be better to<br>&gt;&gt;&gt; just use `id` here.  It seems like a candidate for heuristics as well.<br>&gt;&gt;&gt; For example, if the type name ends in ID and the label is a suffix of<br>&gt;&gt;&gt; the type name we could just use `id`.  This is a somewhat specific<br>&gt;&gt;&gt; pattern, but IDs are common enough that it might make sense.<br>&gt;&gt; <br>&gt;&gt; Actually I&#39;ve been saying for a while that arguments called ID,<br>&gt;&gt; identifier, and name should not be labelled at all in many cases.  Think<br>&gt;&gt; about it.<br>&gt; <br>&gt; <br>&gt; Patch where the words “ID”, “Identifier”, and “Name” in a name are considered to match the type “String”:<br>&gt; <br>&gt; &lt;id-identifier-name-match-string.patch&gt;<br>&gt; <br>&gt; … and then extending the rule to zap first argument labels named “identifier”, “id”, or “name”:<br>&gt; <br>&gt; &lt;id-identifier-name-no-first-arg-label.patch&gt;<br>&gt; <br>&gt; <br>&gt; (I’m not sure which one of these you meant, or something different):<br>&gt; <br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/58f5e9b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 28, 2016 at 12:00:00pm</p></header><div class="content"><p>Y&#39;know, I was going to complain about this too, and wrote up an example, complete with call site…<br></p><p>accountStore.account(currentID)<br></p><p>…and then realized that it didn&#39;t bother me as much as I thought. &quot;account&quot; is a noun, so this is either getting or creating an account for me (as if it were a property), and it&#39;s going to use &quot;currentID&quot; to do it.<br></p><p>I&#39;m very used to &quot;fooWithBar: baz&quot; meaning either &quot;get me the foo that has a bar matching baz&quot; or &quot;create me a foo with its bar set to baz&quot;. But I&#39;m not sure this new convention is any worse, now that the base name isn&#39;t assumed to include the first argument.<br></p><p>Jordan<br></p><p><br></p><p>&gt; On Jan 28, 2016, at 0:51, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Loss of &#39;with&#39; sounds weird in certain cases:<br>&gt; <br>&gt; - func account(identifier identifier: String!) -&gt; ACAccount!<br>&gt; + func account(identifier: String!) -&gt; ACAccount!<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On 28 Jan 2016, at 00:31, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 27, 2016, at 10:03 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Wed Jan 27 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Doug,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think this change looks great!  I don’t have time to look through<br>&gt;&gt;&gt;&gt; the full patch but did look through quite a bit.  It adds clarity in<br>&gt;&gt;&gt;&gt; the vast majority of cases I looked at.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems like with-as-separator is a good heuristic for determining<br>&gt;&gt;&gt;&gt; when the first parameter is not essential to a good name for the<br>&gt;&gt;&gt;&gt; fundamental operation.  I agree with the comments earlier on that in<br>&gt;&gt;&gt;&gt; these cases a label for the first parameter is the best approach.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I also really like that this groups methods with the same fundamental<br>&gt;&gt;&gt;&gt; operation into overload families where they previously had independent<br>&gt;&gt;&gt;&gt; names.  This is a big win IMO.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is a first-parameter-is-an-ID pattern I noticed after this<br>&gt;&gt;&gt;&gt; change.  I show a few examples here, but there are a lot more:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt;&gt;&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>&gt;&gt;&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt;&gt;&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - func discoverUserInfoWithUserRecordID(userRecordID: CKRecordID,<br>&gt;&gt;&gt;&gt; completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; + func discoverUserInfo(userRecordID userRecordID: CKRecordID,<br>&gt;&gt;&gt;&gt; completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The first argument label `trackID` seems like it repeats type<br>&gt;&gt;&gt;&gt; information without adding clarity.  I think it would be better to<br>&gt;&gt;&gt;&gt; just use `id` here.  It seems like a candidate for heuristics as well.<br>&gt;&gt;&gt;&gt; For example, if the type name ends in ID and the label is a suffix of<br>&gt;&gt;&gt;&gt; the type name we could just use `id`.  This is a somewhat specific<br>&gt;&gt;&gt;&gt; pattern, but IDs are common enough that it might make sense.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Actually I&#39;ve been saying for a while that arguments called ID,<br>&gt;&gt;&gt; identifier, and name should not be labelled at all in many cases.  Think<br>&gt;&gt;&gt; about it.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Patch where the words “ID”, “Identifier”, and “Name” in a name are considered to match the type “String”:<br>&gt;&gt; <br>&gt;&gt; &lt;id-identifier-name-match-string.patch&gt;<br>&gt;&gt; <br>&gt;&gt; … and then extending the rule to zap first argument labels named “identifier”, “id”, or “name”:<br>&gt;&gt; <br>&gt;&gt; &lt;id-identifier-name-no-first-arg-label.patch&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; (I’m not sure which one of these you meant, or something different):<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/fe4ef9f9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 28, 2016 at 01:00:00pm</p></header><div class="content"><p>&quot;account&quot; is also a verb. It&#39;s not easy to confuse in this situation, but I<br>fear other verb/noun ambiguities might be more confusing; the preposition<br>helps.<br></p><p>Jacob<br></p><p>On Thu, Jan 28, 2016 at 12:03 PM, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Y&#39;know, I was going to complain about this too, and wrote up an example,<br>&gt; complete with call site…<br>&gt;<br>&gt; accountStore.account(currentID)<br>&gt;<br>&gt;<br>&gt; …and then realized that it didn&#39;t bother me as much as I thought.<br>&gt; &quot;account&quot; is a noun, so this is either getting or creating an account for<br>&gt; me (as if it were a property), and it&#39;s going to use &quot;currentID&quot; to do it.<br>&gt;<br>&gt; I&#39;m very used to &quot;fooWithBar: baz&quot; meaning either &quot;get me the foo that has<br>&gt; a bar matching baz&quot; or &quot;create me a foo with its bar set to baz&quot;. But I&#39;m<br>&gt; not sure this new convention is any *worse*, now that the base name isn&#39;t<br>&gt; assumed to include the first argument.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Jan 28, 2016, at 0:51, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Loss of &#39;with&#39; sounds weird in certain cases:<br>&gt;<br>&gt; -  func account(identifier identifier: String!) -&gt; ACAccount!<br>&gt;<br>&gt; +  func account(identifier: String!) -&gt; ACAccount!<br>&gt;<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On 28 Jan 2016, at 00:31, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 27, 2016, at 10:03 AM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Wed Jan 27 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Doug,<br>&gt;<br>&gt; I think this change looks great!  I don’t have time to look through<br>&gt; the full patch but did look through quite a bit.  It adds clarity in<br>&gt; the vast majority of cases I looked at.<br>&gt;<br>&gt; It seems like with-as-separator is a good heuristic for determining<br>&gt; when the first parameter is not essential to a good name for the<br>&gt; fundamental operation.  I agree with the comments earlier on that in<br>&gt; these cases a label for the first parameter is the best approach.<br>&gt;<br>&gt; I also really like that this groups methods with the same fundamental<br>&gt; operation into overload families where they previously had independent<br>&gt; names.  This is a big win IMO.<br>&gt;<br>&gt; There is a first-parameter-is-an-ID pattern I noticed after this<br>&gt; change.  I show a few examples here, but there are a lot more:<br>&gt;<br>&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt;<br>&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt;<br>&gt; AVFragmentedAssetTrack?<br>&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt;<br>&gt; AVFragmentedAssetTrack?<br>&gt;<br>&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt;<br>&gt; AVCompositionTrack?<br>&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt;<br>&gt; - func discoverUserInfoWithUserRecordID(userRecordID: CKRecordID,<br>&gt; completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt;<br>&gt; + func discoverUserInfo(userRecordID userRecordID: CKRecordID,<br>&gt; completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt;<br>&gt; The first argument label `trackID` seems like it repeats type<br>&gt; information without adding clarity.  I think it would be better to<br>&gt; just use `id` here.  It seems like a candidate for heuristics as well.<br>&gt; For example, if the type name ends in ID and the label is a suffix of<br>&gt; the type name we could just use `id`.  This is a somewhat specific<br>&gt; pattern, but IDs are common enough that it might make sense.<br>&gt;<br>&gt;<br>&gt; Actually I&#39;ve been saying for a while that arguments called ID,<br>&gt; identifier, and name should not be labelled at all in many cases.  Think<br>&gt; about it.<br>&gt;<br>&gt;<br>&gt; Patch where the words “ID”, “Identifier”, and “Name” in a name are<br>&gt; considered to match the type “String”:<br>&gt;<br>&gt; &lt;id-identifier-name-match-string.patch&gt;<br>&gt;<br>&gt;<br>&gt; … and then extending the rule to zap first argument labels named<br>&gt; “identifier”, “id”, or “name”:<br>&gt;<br>&gt; &lt;id-identifier-name-no-first-arg-label.patch&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; (I’m not sure which one of these you meant, or something different):<br>&gt;<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/5694e197/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>January 28, 2016 at 10:00:00pm</p></header><div class="content"><p>FWIW, the way I would design this API would be:<br></p><p>   accountStore.findAccount(“abcdef”)<br></p><p>Having the method start with a verb definitely helps clarify what it actually does, and avoids any potential noun/verb confusion, or confusion between finding or creating a record. But that’s a (potential) issue in the API itself, not the translation. `accountWithIdentifier(_:)`, `account(identifier:)` and `account(_:)` share this, and I don’t see how the first one would be any clearer just because it has “WithIdentifier” in the name.<br></p><p>— Radek<br></p><p>&gt; On 28 Jan 2016, at 22:09, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &quot;account&quot; is also a verb. It&#39;s not easy to confuse in this situation, but I fear other verb/noun ambiguities might be more confusing; the preposition helps.<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Thu, Jan 28, 2016 at 12:03 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Y&#39;know, I was going to complain about this too, and wrote up an example, complete with call site…<br>&gt; <br>&gt; accountStore.account(currentID)<br>&gt; <br>&gt; …and then realized that it didn&#39;t bother me as much as I thought. &quot;account&quot; is a noun, so this is either getting or creating an account for me (as if it were a property), and it&#39;s going to use &quot;currentID&quot; to do it.<br>&gt; <br>&gt; I&#39;m very used to &quot;fooWithBar: baz&quot; meaning either &quot;get me the foo that has a bar matching baz&quot; or &quot;create me a foo with its bar set to baz&quot;. But I&#39;m not sure this new convention is any worse, now that the base name isn&#39;t assumed to include the first argument.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 0:51, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Loss of &#39;with&#39; sounds weird in certain cases:<br>&gt;&gt; <br>&gt;&gt; - func account(identifier identifier: String!) -&gt; ACAccount!<br>&gt;&gt; + func account(identifier: String!) -&gt; ACAccount!<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On 28 Jan 2016, at 00:31, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 27, 2016, at 10:03 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Wed Jan 27 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Doug,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think this change looks great!  I don’t have time to look through<br>&gt;&gt;&gt;&gt;&gt; the full patch but did look through quite a bit.  It adds clarity in<br>&gt;&gt;&gt;&gt;&gt; the vast majority of cases I looked at.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It seems like with-as-separator is a good heuristic for determining<br>&gt;&gt;&gt;&gt;&gt; when the first parameter is not essential to a good name for the<br>&gt;&gt;&gt;&gt;&gt; fundamental operation.  I agree with the comments earlier on that in<br>&gt;&gt;&gt;&gt;&gt; these cases a label for the first parameter is the best approach.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I also really like that this groups methods with the same fundamental<br>&gt;&gt;&gt;&gt;&gt; operation into overload families where they previously had independent<br>&gt;&gt;&gt;&gt;&gt; names.  This is a big win IMO.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There is a first-parameter-is-an-ID pattern I noticed after this<br>&gt;&gt;&gt;&gt;&gt; change.  I show a few examples here, but there are a lot more:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt;&gt;&gt;&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>&gt;&gt;&gt;&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt;&gt;&gt;&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - func discoverUserInfoWithUserRecordID(userRecordID: CKRecordID,<br>&gt;&gt;&gt;&gt;&gt; completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; + func discoverUserInfo(userRecordID userRecordID: CKRecordID,<br>&gt;&gt;&gt;&gt;&gt; completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The first argument label `trackID` seems like it repeats type<br>&gt;&gt;&gt;&gt;&gt; information without adding clarity.  I think it would be better to<br>&gt;&gt;&gt;&gt;&gt; just use `id` here.  It seems like a candidate for heuristics as well.<br>&gt;&gt;&gt;&gt;&gt; For example, if the type name ends in ID and the label is a suffix of<br>&gt;&gt;&gt;&gt;&gt; the type name we could just use `id`.  This is a somewhat specific<br>&gt;&gt;&gt;&gt;&gt; pattern, but IDs are common enough that it might make sense.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Actually I&#39;ve been saying for a while that arguments called ID,<br>&gt;&gt;&gt;&gt; identifier, and name should not be labelled at all in many cases.  Think<br>&gt;&gt;&gt;&gt; about it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Patch where the words “ID”, “Identifier”, and “Name” in a name are considered to match the type “String”:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;id-identifier-name-match-string.patch&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; … and then extending the rule to zap first argument labels named “identifier”, “id”, or “name”:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;id-identifier-name-no-first-arg-label.patch&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (I’m not sure which one of these you meant, or something different):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/fcbfb04a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c65faa002b79348ac10e1fb9c1a9ad83?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Colin Cornaby</string> &lt;colin.cornaby at mac.com&gt;<p>February  1, 2016 at 12:00:00am</p></header><div class="content"><p>(Just catching up on this thread)<br></p><p>I’m actually still a little uncomfortable with this new translation of the Obj-C API, although maybe like you I just need to let my brain chew on it for a while. :)<br></p><p>Part of the issue I think is the original function name. As a query function, if I was rewriting this in Swift, I feel like I’d write it as something like “fetchAccount”. accountWith isn’t ideal, but it implies there is some sort of lookup mechanism that is going to happen, and it implies some sort of expense. Just “account” by itself becomes fuzzier than I’d like.<br></p><p>I think there are definitely cases where the with is unnecessary. Looking through Metal under Swift 3 tonight I found…<br>func newTextureWith(descriptor: MTLTextureDescriptor, offset: Int, bytesPerRow: Int) -&gt; MTLTexture<br></p><p>Totally unnecessary here. I have all the context with “newTexture” that I need. I have a reasonable idea of what the function is doing.<br></p><p>If I was doing lookup, similarly I don’t know if I’d like this function name:<br>func texture(descriptor: MTLTextureDescriptor) -&gt; MTLTexture<br></p><p>Especially in this context (in a scenario where maybe newTexture didn’t exist or someone is lost with the API), without more context, it sounds like this function might be used for texture creation. Although I admit “textureWith” wouldn’t be a huge improvement in that respect, but it does seem like a small improvement. Or maybe I just need to think about that one for a bit.<br></p><p>&gt; On Jan 28, 2016, at 12:03 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Y&#39;know, I was going to complain about this too, and wrote up an example, complete with call site…<br>&gt; <br>&gt; accountStore.account(currentID)<br>&gt; <br>&gt; …and then realized that it didn&#39;t bother me as much as I thought. &quot;account&quot; is a noun, so this is either getting or creating an account for me (as if it were a property), and it&#39;s going to use &quot;currentID&quot; to do it.<br>&gt; <br>&gt; I&#39;m very used to &quot;fooWithBar: baz&quot; meaning either &quot;get me the foo that has a bar matching baz&quot; or &quot;create me a foo with its bar set to baz&quot;. But I&#39;m not sure this new convention is any worse, now that the base name isn&#39;t assumed to include the first argument.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 0:51, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Loss of &#39;with&#39; sounds weird in certain cases:<br>&gt;&gt; <br>&gt;&gt; - func account(identifier identifier: String!) -&gt; ACAccount!<br>&gt;&gt; + func account(identifier: String!) -&gt; ACAccount!<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On 28 Jan 2016, at 00:31, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 27, 2016, at 10:03 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Wed Jan 27 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Doug,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think this change looks great!  I don’t have time to look through<br>&gt;&gt;&gt;&gt;&gt; the full patch but did look through quite a bit.  It adds clarity in<br>&gt;&gt;&gt;&gt;&gt; the vast majority of cases I looked at.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It seems like with-as-separator is a good heuristic for determining<br>&gt;&gt;&gt;&gt;&gt; when the first parameter is not essential to a good name for the<br>&gt;&gt;&gt;&gt;&gt; fundamental operation.  I agree with the comments earlier on that in<br>&gt;&gt;&gt;&gt;&gt; these cases a label for the first parameter is the best approach.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I also really like that this groups methods with the same fundamental<br>&gt;&gt;&gt;&gt;&gt; operation into overload families where they previously had independent<br>&gt;&gt;&gt;&gt;&gt; names.  This is a big win IMO.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There is a first-parameter-is-an-ID pattern I noticed after this<br>&gt;&gt;&gt;&gt;&gt; change.  I show a few examples here, but there are a lot more:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt;&gt;&gt;&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>&gt;&gt;&gt;&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVFragmentedAssetTrack?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func trackWithTrackID(trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt;&gt;&gt;&gt;&gt; +  func track(trackID trackID: CMPersistentTrackID) -&gt; AVCompositionTrack?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - func discoverUserInfoWithUserRecordID(userRecordID: CKRecordID,<br>&gt;&gt;&gt;&gt;&gt; completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; + func discoverUserInfo(userRecordID userRecordID: CKRecordID,<br>&gt;&gt;&gt;&gt;&gt; completionHandler: (CKDiscoveredUserInfo?, Error?) -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The first argument label `trackID` seems like it repeats type<br>&gt;&gt;&gt;&gt;&gt; information without adding clarity.  I think it would be better to<br>&gt;&gt;&gt;&gt;&gt; just use `id` here.  It seems like a candidate for heuristics as well.<br>&gt;&gt;&gt;&gt;&gt; For example, if the type name ends in ID and the label is a suffix of<br>&gt;&gt;&gt;&gt;&gt; the type name we could just use `id`.  This is a somewhat specific<br>&gt;&gt;&gt;&gt;&gt; pattern, but IDs are common enough that it might make sense.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Actually I&#39;ve been saying for a while that arguments called ID,<br>&gt;&gt;&gt;&gt; identifier, and name should not be labelled at all in many cases.  Think<br>&gt;&gt;&gt;&gt; about it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Patch where the words “ID”, “Identifier”, and “Name” in a name are considered to match the type “String”:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;id-identifier-name-match-string.patch&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; … and then extending the rule to zap first argument labels named “identifier”, “id”, or “name”:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;id-identifier-name-no-first-arg-label.patch&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (I’m not sure which one of these you meant, or something different):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/4ee10e3a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
