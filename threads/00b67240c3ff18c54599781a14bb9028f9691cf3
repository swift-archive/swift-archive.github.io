<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 21, 2016 at 09:00:00am</p></header><div class="content"><p>Ok, this is something that&#39;s bugged me since Swift was released. It was almost fixed it back in the 1.x days (I think that was when it changed to be a bit more consistent between top-level funcs and members funcs).<br></p><p>The question is this, why do we still implicitly have unnamed first parameters for non-init functions, and in some cases, suggest putting the name of the first parameter in the name of the function? <br></p><p>    func say(message: String, times: Int) { ... } // or<br>    func sayMessage(message: String, times: Int) { ... }<br></p><p>    say(&quot;hello world&quot;, times: 5) // or<br>    sayMessage(&quot;hello world&quot;, times: 5)<br></p><p>    // vs.<br></p><p>    say(message: &quot;hello world&quot;, times: 5)<br></p><p>Let me be clear, I completely understand why the _ is supported, and I understand that it&#39;s not feasible to implicitly convert all the ObjC interfaces to move the parameter name into the first position (though they could be annotated to do this...).<br></p><p>However, why are we continuing that tradition with _new_ Swift APIs? There seems to be a perfectly good spot for the first parameter name of a function: the first parameter slot.<br></p><p>The seemingly poor choice of this shows up in other places too, like Doug Gregor&#39;s Naming Functions with Arguments Labels proposal. The default for that is to always have the _ in the first name slot.<br></p><p>    say(_:times:)<br>    sayMessage(_:times:)<br></p><p>    // vs.<br></p><p>    say(message:times:)<br></p><p>The other unfortunate thing about this, is that this is another instance where &quot;init&quot; behaves differently then the rest of Swift. I think it would be great to unify this.<br></p><p>Am I just missing the really compelling rationale for this?<br></p><p>Thanks,<br>David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/00b61cf3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0acf75deb034e62d9e8c18c2d3680b54?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>Michael Wells</string> &lt;michael at michaelwells.com&gt;<p>January 21, 2016 at 10:00:00am</p></header><div class="content"><p>I’m in 100% agreement here. In this case, the Swift API Design Guideline seems to be aligned more with Objective C and it doesn’t feel  at all Swift-y. <br></p><p>-mw<br></p><p>&gt; On Jan 21, 2016, at 9:23 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ok, this is something that&#39;s bugged me since Swift was released. It was almost fixed it back in the 1.x days (I think that was when it changed to be a bit more consistent between top-level funcs and members funcs).<br>&gt; <br>&gt; The question is this, why do we still implicitly have unnamed first parameters for non-init functions, and in some cases, suggest putting the name of the first parameter in the name of the function? <br>&gt; <br>&gt;     func say(message: String, times: Int) { ... } // or<br>&gt;     func sayMessage(message: String, times: Int) { ... }<br>&gt; <br>&gt;     say(&quot;hello world&quot;, times: 5) // or<br>&gt;     sayMessage(&quot;hello world&quot;, times: 5)<br>&gt; <br>&gt;     // vs.<br>&gt; <br>&gt;     say(message: &quot;hello world&quot;, times: 5)<br>&gt; <br>&gt; Let me be clear, I completely understand why the _ is supported, and I understand that it&#39;s not feasible to implicitly convert all the ObjC interfaces to move the parameter name into the first position (though they could be annotated to do this...).<br>&gt; <br>&gt; However, why are we continuing that tradition with _new_ Swift APIs? There seems to be a perfectly good spot for the first parameter name of a function: the first parameter slot.<br>&gt; <br>&gt; The seemingly poor choice of this shows up in other places too, like Doug Gregor&#39;s Naming Functions with Arguments Labels proposal. The default for that is to always have the _ in the first name slot.<br>&gt; <br>&gt;     say(_:times:)<br>&gt;     sayMessage(_:times:)<br>&gt; <br>&gt;     // vs.<br>&gt; <br>&gt;     say(message:times:)<br>&gt; <br>&gt; The other unfortunate thing about this, is that this is another instance where &quot;init&quot; behaves differently then the rest of Swift. I think it would be great to unify this.<br>&gt; <br>&gt; Am I just missing the really compelling rationale for this?<br>&gt; <br>&gt; Thanks,<br>&gt; David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/63e10911/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>January 21, 2016 at 01:00:00pm</p></header><div class="content"><p>I’m of two minds about this. I initially really disliked this convention and thought it would be more Swifty to get rid of the implicitly unnamed first parameter and do things as David suggests, but lately I have found the naming convention useful for forcing me to keep functions simpler and smaller because the addition of a second parameter that must be named feels so out of place at the call site by comparison and I’d rather not have it there if I can avoid it. Of course there is no reason such discipline could not be applied without this convention, it’s just that, at the moment, I’ve come to embrace the design as a tool for producing better code. I don’t know if that was the original intent behind it or not, though.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jan 21, 2016, at 12:11 PM, Michael Wells via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m in 100% agreement here. In this case, the Swift API Design Guideline seems to be aligned more with Objective C and it doesn’t feel  at all Swift-y. <br>&gt; <br>&gt; -mw<br>&gt; <br>&gt;&gt; On Jan 21, 2016, at 9:23 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Ok, this is something that&#39;s bugged me since Swift was released. It was almost fixed it back in the 1.x days (I think that was when it changed to be a bit more consistent between top-level funcs and members funcs).<br>&gt;&gt; <br>&gt;&gt; The question is this, why do we still implicitly have unnamed first parameters for non-init functions, and in some cases, suggest putting the name of the first parameter in the name of the function? <br>&gt;&gt; <br>&gt;&gt;     func say(message: String, times: Int) { ... } // or<br>&gt;&gt;     func sayMessage(message: String, times: Int) { ... }<br>&gt;&gt; <br>&gt;&gt;     say(&quot;hello world&quot;, times: 5) // or<br>&gt;&gt;     sayMessage(&quot;hello world&quot;, times: 5)<br>&gt;&gt; <br>&gt;&gt;     // vs.<br>&gt;&gt; <br>&gt;&gt;     say(message: &quot;hello world&quot;, times: 5)<br>&gt;&gt; <br>&gt;&gt; Let me be clear, I completely understand why the _ is supported, and I understand that it&#39;s not feasible to implicitly convert all the ObjC interfaces to move the parameter name into the first position (though they could be annotated to do this...).<br>&gt;&gt; <br>&gt;&gt; However, why are we continuing that tradition with _new_ Swift APIs? There seems to be a perfectly good spot for the first parameter name of a function: the first parameter slot.<br>&gt;&gt; <br>&gt;&gt; The seemingly poor choice of this shows up in other places too, like Doug Gregor&#39;s Naming Functions with Arguments Labels proposal. The default for that is to always have the _ in the first name slot.<br>&gt;&gt; <br>&gt;&gt;     say(_:times:)<br>&gt;&gt;     sayMessage(_:times:)<br>&gt;&gt; <br>&gt;&gt;     // vs.<br>&gt;&gt; <br>&gt;&gt;     say(message:times:)<br>&gt;&gt; <br>&gt;&gt; The other unfortunate thing about this, is that this is another instance where &quot;init&quot; behaves differently then the rest of Swift. I think it would be great to unify this.<br>&gt;&gt; <br>&gt;&gt; Am I just missing the really compelling rationale for this?<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; David<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>January 21, 2016 at 08:00:00pm</p></header><div class="content"><p>See below<br></p><p>&gt; Am 21.01.2016 um 19:11 schrieb Michael Wells via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I’m in 100% agreement here. In this case, the Swift API Design Guideline seems to be aligned more with Objective C and it doesn’t feel  at all Swift-y. <br>&gt; <br>&gt; -mw<br>&gt; <br>&gt;&gt; On Jan 21, 2016, at 9:23 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Ok, this is something that&#39;s bugged me since Swift was released. It was almost fixed it back in the 1.x days (I think that was when it changed to be a bit more consistent between top-level funcs and members funcs).<br>&gt;&gt; <br>&gt;&gt; The question is this, why do we still implicitly have unnamed first parameters for non-init functions, and in some cases, suggest putting the name of the first parameter in the name of the function? <br>&gt;&gt; <br></p><p>As you said in some cases. So in most cases you want to have an implicit unnamed first parameter.<br></p><p>- Maximilian<br></p><p>&gt;&gt;     func say(message: String, times: Int) { ... } // or<br>&gt;&gt;     func sayMessage(message: String, times: Int) { ... }<br>&gt;&gt; <br>&gt;&gt;     say(&quot;hello world&quot;, times: 5) // or<br>&gt;&gt;     sayMessage(&quot;hello world&quot;, times: 5)<br>&gt;&gt; <br>&gt;&gt;     // vs.<br>&gt;&gt; <br>&gt;&gt;     say(message: &quot;hello world&quot;, times: 5)<br>&gt;&gt; <br>&gt;&gt; Let me be clear, I completely understand why the _ is supported, and I understand that it&#39;s not feasible to implicitly convert all the ObjC interfaces to move the parameter name into the first position (though they could be annotated to do this...).<br>&gt;&gt; <br>&gt;&gt; However, why are we continuing that tradition with _new_ Swift APIs? There seems to be a perfectly good spot for the first parameter name of a function: the first parameter slot.<br>&gt;&gt; <br>&gt;&gt; The seemingly poor choice of this shows up in other places too, like Doug Gregor&#39;s Naming Functions with Arguments Labels proposal. The default for that is to always have the _ in the first name slot.<br>&gt;&gt; <br>&gt;&gt;     say(_:times:)<br>&gt;&gt;     sayMessage(_:times:)<br>&gt;&gt; <br>&gt;&gt;     // vs.<br>&gt;&gt; <br>&gt;&gt;     say(message:times:)<br>&gt;&gt; <br>&gt;&gt; The other unfortunate thing about this, is that this is another instance where &quot;init&quot; behaves differently then the rest of Swift. I think it would be great to unify this.<br>&gt;&gt; <br>&gt;&gt; Am I just missing the really compelling rationale for this?<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; David<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/9f98749e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>January 21, 2016 at 11:00:00am</p></header><div class="content"><p>Hi David,<br></p><p>This is obviously a topic which gets a lot of discussion, and I doubt I’ll be able to thoroughly convince anyone with an email or two on the topic… but I would like to share one of the reasons behind the decision to avoid labeling the first argument.<br></p><p>We surveyed the entire surface area of the iOS and OS X SDKs, looking to see how many arguments typical methods had. We found that the vast majority of methods actually have just one argument. If we went with a rule that first arguments should be named, then methods like:<br></p><p>sayMessage(“hello”)<br></p><p>would be this instead:<br></p><p>say(message: “hello”)<br></p><p>which isn’t really much of an improvement, in my mind.<br></p><p>Furthermore, when methods have more than one argument, we found that the additional arguments are most often modifiers or minor adjustments to the first argument. Or, put another way: when there are multiple arguments, the first argument is almost always far more important to the meaning of the method. Your example below follows this pattern as well: the primary purpose of the function is to say a message. The number of times it is said is a secondary modifier to the central purpose.<br></p><p>These factors led us to the conclusion that the label of the first argument is (in the vast majority of cases) really part of the method and not equal in importance to the remaining labels.<br></p><p>- Tony<br></p><p><br>&gt; On Jan 21, 2016, at 9:23 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ok, this is something that&#39;s bugged me since Swift was released. It was almost fixed it back in the 1.x days (I think that was when it changed to be a bit more consistent between top-level funcs and members funcs).<br>&gt; <br>&gt; The question is this, why do we still implicitly have unnamed first parameters for non-init functions, and in some cases, suggest putting the name of the first parameter in the name of the function? <br>&gt; <br>&gt;     func say(message: String, times: Int) { ... } // or<br>&gt;     func sayMessage(message: String, times: Int) { ... }<br>&gt; <br>&gt;     say(&quot;hello world&quot;, times: 5) // or<br>&gt;     sayMessage(&quot;hello world&quot;, times: 5)<br>&gt; <br>&gt;     // vs.<br>&gt; <br>&gt;     say(message: &quot;hello world&quot;, times: 5)<br>&gt; <br>&gt; Let me be clear, I completely understand why the _ is supported, and I understand that it&#39;s not feasible to implicitly convert all the ObjC interfaces to move the parameter name into the first position (though they could be annotated to do this...).<br>&gt; <br>&gt; However, why are we continuing that tradition with _new_ Swift APIs? There seems to be a perfectly good spot for the first parameter name of a function: the first parameter slot.<br>&gt; <br>&gt; The seemingly poor choice of this shows up in other places too, like Doug Gregor&#39;s Naming Functions with Arguments Labels proposal. The default for that is to always have the _ in the first name slot.<br>&gt; <br>&gt;     say(_:times:)<br>&gt;     sayMessage(_:times:)<br>&gt; <br>&gt;     // vs.<br>&gt; <br>&gt;     say(message:times:)<br>&gt; <br>&gt; The other unfortunate thing about this, is that this is another instance where &quot;init&quot; behaves differently then the rest of Swift. I think it would be great to unify this.<br>&gt; <br>&gt; Am I just missing the really compelling rationale for this?<br>&gt; <br>&gt; Thanks,<br>&gt; David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/24394f7c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 21, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 21, 2016, at 11:25 AM, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi David,<br>&gt; <br>&gt; This is obviously a topic which gets a lot of discussion, and I doubt I’ll be able to thoroughly convince anyone with an email or two on the topic… but I would like to share one of the reasons behind the decision to avoid labeling the first argument.<br>&gt; <br>&gt; We surveyed the entire surface area of the iOS and OS X SDKs, looking to see how many arguments typical methods had. We found that the vast majority of methods actually have just one argument. If we went with a rule that first arguments should be named, then methods like:<br>&gt; <br>&gt; sayMessage(“hello”)<br>&gt; <br>&gt; would be this instead:<br>&gt; <br>&gt; say(message: “hello”)<br>&gt; <br>&gt; which isn’t really much of an improvement, in my mind.<br></p><p>Interesting. I would have drawn the opposite conclusion. The vast majority of ObjC APIs have the name of the first parameter in the first section of the selector name. This implies, to me, that the name of the first parameter is very important, and because of the syntactical limitation, the name of the action and the name of the first parameter needed to be joined together.<br></p><p>This leads to APIs like this (from UITableView):<br></p><p>func registerNib(_ nib: UINib?, forHeaderFooterViewReuseIdentifier identifier: String)<br>func registerClass(_ aClass: AnyClass?, forHeaderFooterViewReuseIdentifier identifier: String)<br></p><p>Instead of APIs like:<br></p><p>func register(nib: UINib?, forHeaderFooterViewReuseIdentifier identifier: String)<br>func register(aClass: AnyClass?, forHeaderFooterViewReuseIdentifier identifier: String)<br></p><p>I don’t think I’m being overly selective in my example, but it seems like overloads make this even more desirable to move the name within the parameter list.<br></p><p><br>&gt; Furthermore, when methods have more than one argument, we found that the additional arguments are most often modifiers or minor adjustments to the first argument. Or, put another way: when there are multiple arguments, the first argument is almost always far more important to the meaning of the method. Your example below follows this pattern as well: the primary purpose of the function is to say a message. The number of times it is said is a secondary modifier to the central purpose.<br></p><p>I get what you’re saying, we just disagree on the importance of the first parameter’s significance to the function’s purpose. =) I think the primary purpose is “say” and there there is the data for that purpose. Currently, the only data for say is “message:times”, but it’s not hard to see other use cases. I guess my argument is that I think overloads serve that grouping better than different function names that have the same purpose and act on different data. Swift makes it annoying to do that today, so I end up doing neither and just rely on the type system to handle the first parameter difference, which is less than ideal, but it’s the lazy solution.<br></p><p>Thanks for chiming in,<br>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/95cf106f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 21, 2016 at 09:00:00pm</p></header><div class="content"><p>On Jan 21, 2016, at 12:07 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; which isn’t really much of an improvement, in my mind.<br>&gt; <br>&gt; Interesting. I would have drawn the opposite conclusion. The vast majority of ObjC APIs have the name of the first parameter in the first section of the selector name. This implies, to me, that the name of the first parameter is very important, and because of the syntactical limitation, the name of the action and the name of the first parameter needed to be joined together.<br>&gt; <br>&gt; This leads to APIs like this (from UITableView):<br>&gt; <br>&gt; func registerNib(_ nib: UINib?, forHeaderFooterViewReuseIdentifier identifier: String)<br>&gt; func registerClass(_ aClass: AnyClass?, forHeaderFooterViewReuseIdentifier identifier: String)<br>&gt; <br>&gt; Instead of APIs like:<br>&gt; <br>&gt; func register(nib: UINib?, forHeaderFooterViewReuseIdentifier identifier: String)<br>&gt; func register(aClass: AnyClass?, forHeaderFooterViewReuseIdentifier identifier: String)<br>&gt; <br>&gt; I don’t think I’m being overly selective in my example, but it seems like overloads make this even more desirable to move the name within the parameter list.<br></p><p>The others’ are right, this is best discussed holistically as part of the forthcoming renamification threads.<br></p><p>That said, the example you picked is exactly illustrative of why the current default works well.  One of the principles of the naming guidelines is “omit needless words”: https://swift.org/documentation/api-design-guidelines.html &lt;https://swift.org/documentation/api-design-guidelines.html&gt; and it is a specific anti-goal of the new naming approach to “simply repeat type information” in an argument name.<br></p><p>This approach will lead to these APIs actually being imported as:<br></p><p>	func register(nib: UINib?, ...<br>	func register(aClass: AnyClass?, …<br></p><p>These are much better at point of use, and dovetails perfectly with our current keyword argument behavior.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/6c4d578b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 21, 2016 at 10:00:00pm</p></header><div class="content"><p>Thanks for all the initial comments. I have some specific comments about some of the sections in that guideline but I&#39;ll hold those until the review. Looking forward to the review!<br></p><p>-David<br></p><p>&gt; On Jan 21, 2016, at 9:56 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Jan 21, 2016, at 12:07 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; which isn’t really much of an improvement, in my mind.<br>&gt;&gt; <br>&gt;&gt; Interesting. I would have drawn the opposite conclusion. The vast majority of ObjC APIs have the name of the first parameter in the first section of the selector name. This implies, to me, that the name of the first parameter is very important, and because of the syntactical limitation, the name of the action and the name of the first parameter needed to be joined together.<br>&gt;&gt; <br>&gt;&gt; This leads to APIs like this (from UITableView):<br>&gt;&gt; <br>&gt;&gt; func registerNib(_ nib: UINib?, forHeaderFooterViewReuseIdentifier identifier: String)<br>&gt;&gt; func registerClass(_ aClass: AnyClass?, forHeaderFooterViewReuseIdentifier identifier: String)<br>&gt;&gt; <br>&gt;&gt; Instead of APIs like:<br>&gt;&gt; <br>&gt;&gt; func register(nib: UINib?, forHeaderFooterViewReuseIdentifier identifier: String)<br>&gt;&gt; func register(aClass: AnyClass?, forHeaderFooterViewReuseIdentifier identifier: String)<br>&gt;&gt; <br>&gt;&gt; I don’t think I’m being overly selective in my example, but it seems like overloads make this even more desirable to move the name within the parameter list.<br>&gt; <br>&gt; The others’ are right, this is best discussed holistically as part of the forthcoming renamification threads.<br>&gt; <br>&gt; That said, the example you picked is exactly illustrative of why the current default works well.  One of the principles of the naming guidelines is “omit needless words”: https://swift.org/documentation/api-design-guidelines.html &lt;https://swift.org/documentation/api-design-guidelines.html&gt; and it is a specific anti-goal of the new naming approach to “simply repeat type information” in an argument name.<br>&gt; <br>&gt; This approach will lead to these APIs actually being imported as:<br>&gt; <br>&gt; 	func register(nib: UINib?, ...<br>&gt; 	func register(aClass: AnyClass?, …<br>&gt; <br>&gt; These are much better at point of use, and dovetails perfectly with our current keyword argument behavior.<br>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/edb7a0fd/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>January 21, 2016 at 12:00:00pm</p></header><div class="content"><p>+1 (assuming the OP means making naming consistent)<br></p><p>This is one of the ugliest aspects of Swift. There has to be some other way<br>to ensure compatibility with Obj-C. This is particularly cruel to<br>beginners, who won&#39;t understand why they can&#39;t write arguments the same way<br>everywhere. It&#39;s also additional complexity for anyone reading a function.<br></p><p>My personal preference is that **all** arguments, not just regardless of<br>position, but also regardless of their being in an init/method, have<br>explicit labels by default. If one wants to override that with &quot;_&quot;, one can<br>do so, but it ought to work the same way everywhere.<br></p><p><br></p><p>On Thu, Jan 21, 2016 at 11:25 AM, Tony Parker via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi David,<br>&gt;<br>&gt; This is obviously a topic which gets a lot of discussion, and I doubt I’ll<br>&gt; be able to thoroughly convince anyone with an email or two on the topic…<br>&gt; but I would like to share one of the reasons behind the decision to avoid<br>&gt; labeling the first argument.<br>&gt;<br>&gt; We surveyed the entire surface area of the iOS and OS X SDKs, looking to<br>&gt; see how many arguments typical methods had. We found that the vast majority<br>&gt; of methods actually have just one argument. If we went with a rule that<br>&gt; first arguments should be named, then methods like:<br>&gt;<br>&gt; sayMessage(“hello”)<br>&gt;<br>&gt; would be this instead:<br>&gt;<br>&gt; say(message: “hello”)<br>&gt;<br>&gt; which isn’t really much of an improvement, in my mind.<br>&gt;<br>&gt; Furthermore, when methods have more than one argument, we found that the<br>&gt; additional arguments are most often modifiers or minor adjustments to the<br>&gt; first argument. Or, put another way: when there are multiple arguments, the<br>&gt; first argument is almost always far more important to the meaning of the<br>&gt; method. Your example below follows this pattern as well: the primary<br>&gt; purpose of the function is to say a message. The number of times it is said<br>&gt; is a secondary modifier to the central purpose.<br>&gt;<br>&gt; These factors led us to the conclusion that the label of the first<br>&gt; argument is (in the vast majority of cases) really *part of* the method<br>&gt; and not equal in importance to the remaining labels.<br>&gt;<br>&gt; - Tony<br>&gt;<br>&gt;<br>&gt; On Jan 21, 2016, at 9:23 AM, David Owens II via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Ok, this is something that&#39;s bugged me since Swift was released. It was<br>&gt; *almost* fixed it back in the 1.x days (I think that was when it changed<br>&gt; to be a bit more consistent between top-level funcs and members funcs).<br>&gt;<br>&gt; The question is this, why do we still implicitly have unnamed first<br>&gt; parameters for non-init functions, and in some cases, suggest putting the<br>&gt; name of the first parameter in the name of the function?<br>&gt;<br>&gt;     func say(message: String, times: Int) { ... } // or<br>&gt;     func sayMessage(message: String, times: Int) { ... }<br>&gt;<br>&gt;     say(&quot;hello world&quot;, times: 5) // or<br>&gt;     sayMessage(&quot;hello world&quot;, times: 5)<br>&gt;<br>&gt;     // vs.<br>&gt;<br>&gt;     say(message: &quot;hello world&quot;, times: 5)<br>&gt;<br>&gt; Let me be clear, I completely understand why the _ is supported, and I<br>&gt; understand that it&#39;s not feasible to implicitly convert all the ObjC<br>&gt; interfaces to move the parameter name into the first position (though they<br>&gt; could be annotated to do this...).<br>&gt;<br>&gt; However, why are we continuing that tradition with _new_ Swift APIs? There<br>&gt; seems to be a perfectly good spot for the first parameter name of a<br>&gt; function: the first parameter slot.<br>&gt;<br>&gt; The seemingly poor choice of this shows up in other places too, like Doug<br>&gt; Gregor&#39;s *Naming Functions with Arguments Labels* proposal. The default<br>&gt; for that is to always have the _ in the first name slot.<br>&gt;<br>&gt;     say(_:times:)<br>&gt;     sayMessage(_:times:)<br>&gt;<br>&gt;     // vs.<br>&gt;<br>&gt;     say(message:times:)<br>&gt;<br>&gt; The other unfortunate thing about this, is that this is another instance<br>&gt; where &quot;init&quot; behaves differently then the rest of Swift. I think it would<br>&gt; be great to unify this.<br>&gt;<br>&gt; Am I just missing the really compelling rationale for this?<br>&gt;<br>&gt; Thanks,<br>&gt; David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/33c2065d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 23, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Jan 21, 2016, at 1:25 PM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We surveyed the entire surface area of the iOS and OS X SDKs, looking to see how many arguments typical methods had. We found that the vast majority of methods actually have just one argument. If we went with a rule that first arguments should be named, then methods like:<br>&gt; <br>&gt; sayMessage(“hello”)<br>&gt; <br>&gt; would be this instead:<br>&gt; <br>&gt; say(message: “hello”)<br>&gt; <br>&gt; which isn’t really much of an improvement, in my mind.<br></p><p>How about making it so that methods with just one argument have no label on the argument by default, but methods with two or more arguments have labels on all arguments? This would prevent what you describe above, while eliminating the ugliness of one parameter being treated differently from all the rest in the same method.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/c3d18ed5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>January 23, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; How about making it so that methods with just one argument have no label<br>on the argument by default, but methods with two or more arguments have<br>labels on all arguments?<br></p><p>Or have an Xcode &quot;fix it&quot; that offers to insert an &quot;_&quot; on the first<br>argument. That would have the benefit of letting the user disable that<br>warning, if they want to name their args on a case by case basis.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/8a3118b8/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9f3e3f9871fd088e42df4509aa724367?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>Adriano Ferreira</string> &lt;adriano.ferreira at me.com&gt;<p>January 21, 2016 at 07:00:00pm</p></header><div class="content"><p>I totally understand that beautiful &amp; elegant code might be very subjective. However, having a different way of treating the first parameter is rather confusing. Feels weird, inconsistent, and introduces complexity.<br></p><p>I’d rather have all arguments with explicit labels by default. Simple and clean. And, as mentioned already, if one wants to override that behaviour, just use `_`.<br></p><p>Best,<br></p><p>— A<br></p><p>&gt; On Jan 21, 2016, at 12:23 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ok, this is something that&#39;s bugged me since Swift was released. It was almost fixed it back in the 1.x days (I think that was when it changed to be a bit more consistent between top-level funcs and members funcs).<br>&gt; <br>&gt; The question is this, why do we still implicitly have unnamed first parameters for non-init functions, and in some cases, suggest putting the name of the first parameter in the name of the function? <br>&gt; <br>&gt;     func say(message: String, times: Int) { ... } // or<br>&gt;     func sayMessage(message: String, times: Int) { ... }<br>&gt; <br>&gt;     say(&quot;hello world&quot;, times: 5) // or<br>&gt;     sayMessage(&quot;hello world&quot;, times: 5)<br>&gt; <br>&gt;     // vs.<br>&gt; <br>&gt;     say(message: &quot;hello world&quot;, times: 5)<br>&gt; <br>&gt; Let me be clear, I completely understand why the _ is supported, and I understand that it&#39;s not feasible to implicitly convert all the ObjC interfaces to move the parameter name into the first position (though they could be annotated to do this...).<br>&gt; <br>&gt; However, why are we continuing that tradition with _new_ Swift APIs? There seems to be a perfectly good spot for the first parameter name of a function: the first parameter slot.<br>&gt; <br>&gt; The seemingly poor choice of this shows up in other places too, like Doug Gregor&#39;s Naming Functions with Arguments Labels proposal. The default for that is to always have the _ in the first name slot.<br>&gt; <br>&gt;     say(_:times:)<br>&gt;     sayMessage(_:times:)<br>&gt; <br>&gt;     // vs.<br>&gt; <br>&gt;     say(message:times:)<br>&gt; <br>&gt; The other unfortunate thing about this, is that this is another instance where &quot;init&quot; behaves differently then the rest of Swift. I think it would be great to unify this.<br>&gt; <br>&gt; Am I just missing the really compelling rationale for this?<br>&gt; <br>&gt; Thanks,<br>&gt; David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/51c7c656/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 22, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; The other unfortunate thing about this, is that this is another instance where &quot;init&quot; behaves differently then the rest of Swift. I think it would be great to unify this.<br>It&#39;s definitely confusing that labels receive special treatment in init, and I&#39;m quite sure method declarations would look different without the &quot;Objective-C-legacy&quot;.<br></p><p>Imho named arguments with default values are a great feature, which I loved since I&#39;ve seen it the first time R (which would be very hard to use without default values…).<br>R, as my reference, is quite flexible with parameters:<br>You can leave out all labels, and only rely on the order of the values, you can assign values in whatever order you like — and, up to a certain degree, you can mix:<br>myFunc(firstParameterWithoutLabel, secondParameterWithoutLabel, fourthLabel = 8, thirdLabel = 0.5)<br></p><p>I don&#39;t think Swift needs that much flexibility, but imho the compiler could be less strict and leave it to the user weather parameters are identified via label or position.<br></p><p>say(&quot;message&quot;, times: 4)<br>is a good default and should be offered by autocompletion, but<br></p><p>say(message: &quot;Hello&quot;, times: 4)<br></p><p>and even<br></p><p>say(&quot;Hello&quot;, 4)<br></p><p>could be allowed as well (as long as there is no clash with a second say-function).<br></p><p>Labels are &quot;just&quot; an aid for programmers, but for the program itself, they have not much more meaning than a comment:<br>Higher-order functions already ignore labels completely and rely on positions only.<br></p><p>So, instead of complicated rules enforced by the compiler, I would prefer a simple system backed by conventions that discourage programmers to fall back to C-style calls where you have to count parameters to decipher their meaning.<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/bec10284/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>January 22, 2016 at 09:00:00am</p></header><div class="content"><p>On Fri, Jan 22, 2016 at 8:26 AM, Tino Heth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Labels are &quot;just&quot; an aid for programmers, but for the program itself, they<br>&gt; have not much more meaning than a comment:<br>&gt;<br></p><p>UIView.insertSubview(_:,belowSubview:) and<br>UIView.insertSubview(_:,aboveSubview:) beg to differ. As do<br>UIView.convertPoint(_:,toView:) and UIView.convertPoint(_:,fromView:). Need<br>more examples? Take a look at UITableViewDelegate.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/d03397a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>named parameters</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 22, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 7:49, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Fri, Jan 22, 2016 at 8:26 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Labels are &quot;just&quot; an aid for programmers, but for the program itself, they have not much more meaning than a comment:<br>&gt; <br>&gt; UIView.insertSubview(_:,belowSubview:) and UIView.insertSubview(_:,aboveSubview:) beg to differ. As do UIView.convertPoint(_:,toView:) and UIView.convertPoint(_:,fromView:). Need more examples? Take a look at UITableViewDelegate.<br></p><p>Agreed. I&#39;m quite happy that Swift labels are effectively part of the method name and therefore consistently applied. Long parameter lists are easy to get lost in.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/f12a78c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>named parameters</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 22, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt;&gt; UIView.insertSubview(_:,belowSubview:) and UIView.insertSubview(_:,aboveSubview:) beg to differ. As do UIView.convertPoint(_:,toView:) and UIView.convertPoint(_:,fromView:). Need more examples? Take a look at UITableViewDelegate.<br>&gt; <br>&gt; Agreed. I&#39;m quite happy that Swift labels are effectively part of the method name and therefore consistently applied. Long parameter lists are easy to get lost in.<br></p><p>That&#39;s exactly my opinion: Labels help us — the computer doesn&#39;t care weather a function has a meaningful name or is called as &quot;f231(4, true)&quot;<br>Especially because of the benefit of labels, it&#39;s imho not necessary that the compiler enforces their use… but I think it&#39;s actually annoying to be forced to skip labels:<br></p><p>func printPowWithBase(base: Double, exponent: Double) {<br>	print(pow(base, exponent))<br>}<br>printPowWithBase(2, exponent: 3)<br></p><p>Easy to understand, works as expected — but would it hurt if<br></p><p>printPowWithBase(base: 2, exponent: 3)<br></p><p>would be accepted as well? Sure, &quot;base:&quot; is redundant, but who cares? And, as others already mentioned: For init, the first label is required…<br></p><p>Additionally, there is a hidden(?) feature in Swift that&#39;s imho quite cool:<br>The ability to call a function with a tuple containing the arguments<br>let args = (4.0, exponent: 4.0)<br>printPowWithBase(args)<br></p><p>In this case, you end up with a first parameter without any indication of its role.<br></p><p>Tino<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/af3d3c70/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>named parameters</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 22, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 14:32, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; UIView.insertSubview(_:,belowSubview:) and UIView.insertSubview(_:,aboveSubview:) beg to differ. As do UIView.convertPoint(_:,toView:) and UIView.convertPoint(_:,fromView:). Need more examples? Take a look at UITableViewDelegate.<br>&gt;&gt; <br>&gt;&gt; Agreed. I&#39;m quite happy that Swift labels are effectively part of the method name and therefore consistently applied. Long parameter lists are easy to get lost in.<br>&gt; <br>&gt; That&#39;s exactly my opinion: Labels help us — the computer doesn&#39;t care weather a function has a meaningful name or is called as &quot;f231(4, true)&quot;<br>&gt; Especially because of the benefit of labels, it&#39;s imho not necessary that the compiler enforces their use… but I think it&#39;s actually annoying to be forced to skip labels:<br>&gt; <br>&gt; func printPowWithBase(base: Double, exponent: Double) {<br>&gt; 	print(pow(base, exponent))<br>&gt; }<br>&gt; printPowWithBase(2, exponent: 3)<br>&gt; <br>&gt; Easy to understand, works as expected — but would it hurt if<br>&gt; <br>&gt; printPowWithBase(base: 2, exponent: 3)<br>&gt; <br>&gt; would be accepted as well? Sure, &quot;base:&quot; is redundant, but who cares? And, as others already mentioned: For init, the first label is required…<br></p><p>If the library author decides to change the internal name, it&#39;s now a source-breaking change for clients. (Alternately, all the existing internal names are now external names, without any thought given to them, which would be just as bad.)<br></p><p><br>&gt; Additionally, there is a hidden(?) feature in Swift that&#39;s imho quite cool:<br>&gt; The ability to call a function with a tuple containing the arguments<br>&gt; let args = (4.0, exponent: 4.0)<br>&gt; printPowWithBase(args)<br>&gt; <br>&gt; In this case, you end up with a first parameter without any indication of its role.<br></p><p>This feature is likely to get redesigned soon. (It has other problems.)<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/f76ce0d2/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>named parameters</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 22, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; If the library author decides to change the internal name, it&#39;s now a source-breaking change for clients. (Alternately, all the existing internal names are now external names, without any thought given to them, which would be just as bad.)<br>Imho this is no good argument — you can extend it to ban all labels.<br></p><p>&gt;&gt; Additionally, there is a hidden(?) feature in Swift that&#39;s imho quite cool:<br>&gt;&gt; The ability to call a function with a tuple containing the arguments<br>&gt;&gt; let args = (4.0, exponent: 4.0)<br>&gt;&gt; printPowWithBase(args)<br>&gt;&gt; <br>&gt;&gt; In this case, you end up with a first parameter without any indication of its role.<br>&gt; <br>&gt; This feature is likely to get redesigned soon. (It has other problems.)<br>Can you elaborate? I did not encounter many usecases yet, but I think it could be handy to configure a bunch of similar objects — and if it would be possible to capture the parameter tuple inside the called function, this could be forwarded to a function with the same signature easily… (especially, but not only the implementation of super)<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/377e8c7e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>named parameters</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 22, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 14:59, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; If the library author decides to change the internal name, it&#39;s now a source-breaking change for clients. (Alternately, all the existing internal names are now external names, without any thought given to them, which would be just as bad.)<br>&gt; Imho this is no good argument — you can extend it to ban all labels.<br></p><p>No, that&#39;s not the case. External names are part of the method name and signature and are part of the source and binary interface for a library. Internal names are local variables with a little bit of documentation. Every parameter has both internal and external names; it&#39;s just that the logic for what happens when you only specify one that&#39;s different.<br></p><p><br>&gt; <br>&gt;&gt;&gt; Additionally, there is a hidden(?) feature in Swift that&#39;s imho quite cool:<br>&gt;&gt;&gt; The ability to call a function with a tuple containing the arguments<br>&gt;&gt;&gt; let args = (4.0, exponent: 4.0)<br>&gt;&gt;&gt; printPowWithBase(args)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this case, you end up with a first parameter without any indication of its role.<br>&gt;&gt; <br>&gt;&gt; This feature is likely to get redesigned soon. (It has other problems.)<br>&gt; Can you elaborate? I did not encounter many usecases yet, but I think it could be handy to configure a bunch of similar objects — and if it would be possible to capture the parameter tuple inside the called function, this could be forwarded to a function with the same signature easily… (especially, but not only the implementation of super)<br></p><p>In some contexts it&#39;s hard to distinguish between &quot;the first parameter&quot; and &quot;the tuple of all parameters&quot;, and we have some weird inconsistencies where &quot;foo(x)&quot; and &quot;foo((x))&quot; do the same thing sometimes and different things other times.<br></p><p>There&#39;s more complexity here but I don&#39;t have it paged in; it&#39;s not so relevant to this discussion<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/e391bc40/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>named parameters</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 22, 2016 at 04:00:00pm</p></header><div class="content"><p>On Jan 22, 2016, at 3:10 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Additionally, there is a hidden(?) feature in Swift that&#39;s imho quite cool:<br>&gt;&gt;&gt;&gt; The ability to call a function with a tuple containing the arguments<br>&gt;&gt;&gt;&gt; let args = (4.0, exponent: 4.0)<br>&gt;&gt;&gt;&gt; printPowWithBase(args)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this case, you end up with a first parameter without any indication of its role.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This feature is likely to get redesigned soon. (It has other problems.)<br>&gt;&gt; Can you elaborate? I did not encounter many usecases yet, but I think it could be handy to configure a bunch of similar objects — and if it would be possible to capture the parameter tuple inside the called function, this could be forwarded to a function with the same signature easily… (especially, but not only the implementation of super)<br>&gt; <br>&gt; In some contexts it&#39;s hard to distinguish between &quot;the first parameter&quot; and &quot;the tuple of all parameters&quot;, and we have some weird inconsistencies where &quot;foo(x)&quot; and &quot;foo((x))&quot; do the same thing sometimes and different things other times.<br></p><p>Here’s a simple example to show the ambiguity:<br></p><p>func foo(a : Any…) {}<br>let x = (1,2,3)<br>foo(x)   // 1 parameter or 3?<br></p><p><br>&gt; There&#39;s more complexity here but I don&#39;t have it paged in; it&#39;s not so relevant to this discussion<br></p><p>Incidentally, IMO the likely solution is for this to just make this explicit somehow.  * isn’t really right right sigil for this, but you could imagine something like this:<br></p><p>printPowWithBase(*args)<br></p><p>Where the * (or whatever symbol actually makes sense) is a “flatten” or “expand inline” operation for the tuple argument.  This makes it unambiguous whether splatting is happening or not.<br></p><p>func foo(a : Any…) {}<br>let x = (1,2,3)<br>foo(x)   // 1 parameter<br>foo(*x)  // 3 parameters<br></p><p><br>Alternatively, the argument could be made that we should just remove this splatting behavior.  I haven’t heard of any super-compelling use-cases for it.  Adding a sigil for this operation would expose the complexity that the behavior underlines.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/e8b1a50e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>named parameters</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 22, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 5:27 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Jan 22, 2016, at 3:10 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Additionally, there is a hidden(?) feature in Swift that&#39;s imho quite cool:<br>&gt;&gt;&gt;&gt;&gt; The ability to call a function with a tuple containing the arguments<br>&gt;&gt;&gt;&gt;&gt; let args = (4.0, exponent: 4.0)<br>&gt;&gt;&gt;&gt;&gt; printPowWithBase(args)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In this case, you end up with a first parameter without any indication of its role.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This feature is likely to get redesigned soon. (It has other problems.)<br>&gt;&gt;&gt; Can you elaborate? I did not encounter many usecases yet, but I think it could be handy to configure a bunch of similar objects — and if it would be possible to capture the parameter tuple inside the called function, this could be forwarded to a function with the same signature easily… (especially, but not only the implementation of super)<br>&gt;&gt; <br>&gt;&gt; In some contexts it&#39;s hard to distinguish between &quot;the first parameter&quot; and &quot;the tuple of all parameters&quot;, and we have some weird inconsistencies where &quot;foo(x)&quot; and &quot;foo((x))&quot; do the same thing sometimes and different things other times.<br>&gt; <br>&gt; Here’s a simple example to show the ambiguity:<br>&gt; <br>&gt; func foo(a : Any…) {}<br>&gt; let x = (1,2,3)<br>&gt; foo(x)   // 1 parameter or 3?<br>&gt; <br>&gt; <br>&gt;&gt; There&#39;s more complexity here but I don&#39;t have it paged in; it&#39;s not so relevant to this discussion<br>&gt; <br>&gt; Incidentally, IMO the likely solution is for this to just make this explicit somehow.  * isn’t really right right sigil for this, but you could imagine something like this:<br>&gt; <br>&gt; printPowWithBase(*args)<br>&gt; <br>&gt; Where the * (or whatever symbol actually makes sense) is a “flatten” or “expand inline” operation for the tuple argument.  This makes it unambiguous whether splatting is happening or not.<br>&gt; <br>&gt; func foo(a : Any…) {}<br>&gt; let x = (1,2,3)<br>&gt; foo(x)   // 1 parameter<br>&gt; foo(*x)  // 3 parameters<br>&gt; <br>&gt; <br>&gt; Alternatively, the argument could be made that we should just remove this splatting behavior.  I haven’t heard of any super-compelling use-cases for it.  Adding a sigil for this operation would expose the complexity that the behavior underlines.<br>&gt; <br></p><p>Use case:<br></p><p>Zipping streams of arguments into tuples and then applying them through a function, and for the sake of argument, there&#39;s a big scary monster of necessity preventing you from consuming them at the same time using f($0, $1, $2, etc), so the lazy zipped tuple stream occurs at a different time/place as the consumption, which is not expecting a tuple input but n separate arguments.<br></p><p>-- E<br></p><p><br></p><p>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/df1041c2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>named parameters</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 22, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 4:31 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Alternatively, the argument could be made that we should just remove this splatting behavior.  I haven’t heard of any super-compelling use-cases for it.  Adding a sigil for this operation would expose the complexity that the behavior underlines.<br>&gt;&gt; <br>&gt; <br>&gt; Use case:<br>&gt; <br>&gt; Zipping streams of arguments into tuples and then applying them through a function, and for the sake of argument, there&#39;s a big scary monster of necessity preventing you from consuming them at the same time using f($0, $1, $2, etc), so the lazy zipped tuple stream occurs at a different time/place as the consumption, which is not expecting a tuple input but n separate arguments.<br></p><p>AFAICT, the difference is between:<br></p><p>	f(*$0)<br></p><p>and:<br></p><p>	f($0.0, $0.1)<br></p><p>I could argue very easily that the later is much more clear than the former.  High arity tuples are also very uncommon.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/96936c4c/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>named parameters</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 23, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt;&gt;&gt; If the library author decides to change the internal name, it&#39;s now a source-breaking change for clients. (Alternately, all the existing internal names are now external names, without any thought given to them, which would be just as bad.)<br>&gt;&gt; Imho this is no good argument — you can extend it to ban all labels.<br>&gt; <br>&gt; No, that&#39;s not the case. External names are part of the method name and signature and are part of the source and binary interface for a library. Internal names are local variables with a little bit of documentation. Every parameter has both internal and external names; it&#39;s just that the logic for what happens when you only specify one that&#39;s different.<br>I&#39;m not sure if I understand this completely:<br>When each parameter has an external and an internal name, changing the latter should never be an issue for users of that method… where&#39;s the fault in my logic?<br>The &quot;only&quot;* breaking change I see happens when the behavior for all parameters is unified, and suddenly parameters without external name (or &quot;empty external name&quot;...) would receive one.<br></p><p>&gt;&gt;&gt;&gt; The ability to call a function with a tuple containing the arguments<br>&gt; <br>&gt; In some contexts it&#39;s hard to distinguish between &quot;the first parameter&quot; and &quot;the tuple of all parameters&quot;, and we have some weird inconsistencies where &quot;foo(x)&quot; and &quot;foo((x))&quot; do the same thing sometimes and different things other times.<br>&gt; <br>&gt; There&#39;s more complexity here but I don&#39;t have it paged in; it&#39;s not so relevant to this discussion<br>Don&#39;t mind — I&#39;m in the lucky position that I don&#39;t have to care about the hardships tied to implementation details ;-), so I was just curious if there&#39;s danger that the feature will be removed.<br></p><p>Tino<br></p><p>* I guess it would be a huge one...<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/0302a796/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>named parameters</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 25, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 6:02, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; If the library author decides to change the internal name, it&#39;s now a source-breaking change for clients. (Alternately, all the existing internal names are now external names, without any thought given to them, which would be just as bad.)<br>&gt;&gt;&gt; Imho this is no good argument — you can extend it to ban all labels.<br>&gt;&gt; <br>&gt;&gt; No, that&#39;s not the case. External names are part of the method name and signature and are part of the source and binary interface for a library. Internal names are local variables with a little bit of documentation. Every parameter has both internal and external names; it&#39;s just that the logic for what happens when you only specify one that&#39;s different.<br>&gt; I&#39;m not sure if I understand this completely:<br>&gt; When each parameter has an external and an internal name, changing the latter should never be an issue for users of that method… where&#39;s the fault in my logic?<br>&gt; The &quot;only&quot;* breaking change I see happens when the behavior for all parameters is unified, and suddenly parameters without external name (or &quot;empty external name&quot;...) would receive one.<br></p><p>Sorry, I thought you were suggesting that if an external name were not specified, the internal name would be optionally allowed at the call site. I see now that you were proposing to first make all parameters have external names by default, and then to make the label optional.<br></p><p>I still disagree with this, but it doesn&#39;t break anything. :-)<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/837921a1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>named parameters</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 23, 2016 at 04:00:00pm</p></header><div class="content"><p>Yes, I think Swifts external parameter labels are a really well done part of the language and a great advantage over languages without labeled parameters and over those who do have labeled parameters but where the labels are simply the parameter names which does not allow the same expressiveness in a method call as I’m used to from Smalltalk (or Objective-C). I’m really glad Swift has these.<br></p><p>-Thorsten<br></p><p><br>&gt; Am 22.01.2016 um 20:46 schrieb Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 7:49, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Fri, Jan 22, 2016 at 8:26 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Labels are &quot;just&quot; an aid for programmers, but for the program itself, they have not much more meaning than a comment:<br>&gt;&gt; <br>&gt;&gt; UIView.insertSubview(_:,belowSubview:) and UIView.insertSubview(_:,aboveSubview:) beg to differ. As do UIView.convertPoint(_:,toView:) and UIView.convertPoint(_:,fromView:). Need more examples? Take a look at UITableViewDelegate.<br>&gt; <br>&gt; Agreed. I&#39;m quite happy that Swift labels are effectively part of the method name and therefore consistently applied. Long parameter lists are easy to get lost in.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/d631b78f/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 22, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 6:26 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; The other unfortunate thing about this, is that this is another instance where &quot;init&quot; behaves differently then the rest of Swift. I think it would be great to unify this.<br>&gt; It&#39;s definitely confusing that labels receive special treatment in init, and I&#39;m quite sure method declarations would look different without the &quot;Objective-C-legacy”.<br></p><p>We believe fairly strongly that Swift’s design here reflects the appropriate defaults for clear, expressive APIs and code. The API Design Guidelines line up with the default behavior of Swift for a reason. Repeating the “Objective-C legacy” trope strongly implies that you’re not considering the rationale behind Swift’s design, and weakens your arguments considerably.<br></p><p>&gt; Imho named arguments with default values are a great feature, which I loved since I&#39;ve seen it the first time R (which would be very hard to use without default values…).<br>&gt; R, as my reference, is quite flexible with parameters:<br>&gt; You can leave out all labels, and only rely on the order of the values, you can assign values in whatever order you like — and, up to a certain degree, you can mix:<br>&gt; myFunc(firstParameterWithoutLabel, secondParameterWithoutLabel, fourthLabel = 8, thirdLabel = 0.5)<br>&gt; <br>&gt; I don&#39;t think Swift needs that much flexibility, but imho the compiler could be less strict and leave it to the user weather parameters are identified via label or position.<br>&gt; <br>&gt; say(&quot;message&quot;, times: 4)<br>&gt; is a good default and should be offered by autocompletion, but<br>&gt; <br>&gt; say(message: &quot;Hello&quot;, times: 4)<br></p><p>The message is the direct object of the verb “say”, so the first argument being the message is implied. Clarity is not improved by having the “message:” argument label.<br></p><p>&gt; and even<br>&gt; <br>&gt; say(&quot;Hello&quot;, 4)<br>&gt; <br>&gt; could be allowed as well (as long as there is no clash with a second say-function).<br></p><p>This is less clear than your initial example. There is absolutely nothing to indicate, at the call site, that “4” is a repeat count.<br></p><p>&gt; Labels are &quot;just&quot; an aid for programmers, but for the program itself, they have not much more meaning than a comment:<br></p><p>That is incorrect. The argument labels are a fundamental part of the name of a Swift function (or initializer, or subscript).<br></p><p>&gt; Higher-order functions already ignore labels completely and rely on positions only.<br></p><p>That’s mostly correct; our model around argument labels with function types is fuzzy and needs work.<br></p><p>&gt; So, instead of complicated rules enforced by the compiler, I would prefer a simple system backed by conventions that discourage programmers to fall back to C-style calls where you have to count parameters to decipher their meaning.<br></p><p>So… you want a plethora of conventions that differ from one project to the next, rather than a set of default language rules backed by the API Design Guidelines? I admit that one will often do a double-take when first encountering the rules for which arguments have labels by default, but I’d rather learn that once than have widely differing approaches to when argument labels are provided vs. dropped.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/6200d226/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 23, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; We believe fairly strongly that Swift’s design here reflects the appropriate defaults for clear, expressive APIs and code. The API Design Guidelines line up with the default behavior of Swift for a reason. Repeating the “Objective-C legacy” trope strongly implies that you’re not considering the rationale behind Swift’s design, and weakens your arguments considerably.<br>I&#39;m not saying the influence of Objective-C is bad (therefore, I used the quotation marks), but imho it&#39;s pointless to deny that it exists.<br></p><p>&gt;&gt; say(message: &quot;Hello&quot;, times: 4)<br>&gt; <br>&gt; The message is the direct object of the verb “say”, so the first argument being the message is implied. Clarity is not improved by having the “message:” argument label.<br>I wouldn&#39;t force anyone to use that label — and I think this topic was not started because of a lack of clarity, but an excess of different rules.<br></p><p>&gt;&gt; say(&quot;Hello&quot;, 4)<br>&gt; <br>&gt; This is less clear than your initial example. There is absolutely nothing to indicate, at the call site, that “4” is a repeat count.<br>Here as well: The use of a label should not be discouraged — but you can&#39;t fight against users who (for whatever reason) want to use calls that are hard to understand.<br></p><p>&gt;&gt; Labels are &quot;just&quot; an aid for programmers, but for the program itself, they have not much more meaning than a comment:<br>&gt; <br>&gt; That is incorrect. The argument labels are a fundamental part of the name of a Swift function (or initializer, or subscript).<br>I guess that sentence failed in expressing my thoughts:<br>Of course, labels have influence on method/selector resolution — but their raison d&#39;être is to help programmers to write calls that are easy to understand: Many languages have no labels for parameters, and afair, there has been at least one bridge (Cocoa for Java?) that had to get rid of them. <br></p><p>&gt;&gt; Higher-order functions already ignore labels completely and rely on positions only.<br>&gt; <br>&gt; That’s mostly correct; our model around argument labels with function types is fuzzy and needs work.<br></p><p>Taking a statement from another thread:<br>&gt; Right now, you&#39;ll still need to use labels in the call. However, this is an area where we&#39;d like to revisit things a bit: having labels in function types seems to cause more trouble than it provides benefits, and I&#39;d like to see up address that directly.<br>So you say that there are situations where labels are bad, right? So it would be necessary to define rules on how to get rid of them as well...<br></p><p>&gt;&gt; So, instead of complicated rules enforced by the compiler, I would prefer a simple system backed by conventions that discourage programmers to fall back to C-style calls where you have to count parameters to decipher their meaning.<br>&gt; <br>&gt; So… you want a plethora of conventions that differ from one project to the next,<br>No. I don&#39;t think there would be an urge to establish a different set of conventions for each project/team.<br></p><p>&gt; rather than a set of default language rules backed by the API Design Guidelines? I admit that one will often do a double-take when first encountering the rules for which arguments have labels by default, but I’d rather learn that once than have widely differing approaches to when argument labels are provided vs. dropped.<br>I think you are underestimating the importance of conventions — in the area of code comprehensibility, they are far more powerful than anything that can be enforced by a compiler.<br></p><p>There has been another discussion about something that&#39;s optional and should become mandatory (self). I&#39;m glad that proposal was rejected, as I think it&#39;s not that hard to define a set of guidelines when to use &quot;self.&quot; and when to skip it, but it shouldn&#39;t be the job of the compiler to enforce rules whose only justification is to make source more accessible to human readers.<br>Imho labels are very similar in this aspect, with the difference that right now, there is a quite complicated scheme embedded in the compiler. Moving that responsibility to the party that actually is affected by the choice (we as developers) would make the language simpler and more elegant.<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/3c3cfa7e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
