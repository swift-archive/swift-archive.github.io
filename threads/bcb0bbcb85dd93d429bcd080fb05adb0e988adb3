<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  5, 2016 at 05:00:00pm</p></header><div class="content"><p>on Thu Jun 02 2016, John McCall &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The official way to build a literal of a specific type is to write the<br>&gt; literal in an explicitly-typed context, like so:<br>&gt;     let x: UInt16 = 7<br>&gt; or<br>&gt;     let x = 7 as UInt16<br>&gt;<br>&gt; Nonetheless, programmers often try the following:<br>&gt;     UInt16(7)<br>&gt;<br>&gt; Unfortunately, this does not attempt to construct the value using the<br>&gt; appropriate literal protocol; it instead performs overload resolution<br>&gt; using the standard rules, i.e. considering only single-argument<br>&gt; unlabelled initializers of a type which conforms to<br>&gt; IntegerLiteralConvertible.  Often this leads to static ambiguities or,<br>&gt; worse, causes the literal to be built using a default type (such as<br>&gt; Int); this may have semantically very different results which are only<br>&gt; caught at runtime.<br>&gt;<br>&gt; In my opinion, using this initializer-call syntax to build an<br>&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s<br>&gt; clear that programmers are going to continue to independently try to<br>&gt; use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;<br>&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;<br>&gt;   Given a function call expression of the form A(B) (that is, an<br>&gt; expr-call with a single, unlabelled argument) where B is an<br>&gt; expr-literal or expr-collection, if A has type T.Type for some type T<br>&gt; and there is a declared conformance of T to an appropriate literal<br>&gt; protocol for B, then the expression is always resolves as a literal<br>&gt; construction of type T (as if the expression were written &quot;B as A&quot;)<br>&gt; rather than as a general initializer call.<br>&gt;<br>&gt; Formally, this would be a special form of the argument conversion<br>&gt; constraint, since the type of the expression A may not be immediately<br>&gt; known.<br></p><p>I realize this is somewhat tangential, but... IMO this may not be entirely<br>about literals.<br></p><p>We have a standard that full-width type conversions are written as a<br>label-free initializer<br>&lt;https://swift.org/documentation/api-design-guidelines/#type-conversion&gt;.<br>I believe that is partly responsible for setting up the expectation that<br>Int(42) works as one would expect.  It gets ultra-weird when you can<br>convert from type A to type B using B(someA) but you can&#39;t write<br>B(someB).  We should automatically generate a label-free “copy<br>initializer” for value types, to complete implementation of the expected<br>mental model.<br></p><p>&gt; Note that, as specified, it is possible to suppress this typing rule<br>&gt; by wrapping the literal in parentheses.  This might seem distasteful;<br>&gt; it would be easy enough to allow the form of B to include extra<br>&gt; parentheses.  It&#39;s potentially useful to have a way to suppress this<br>&gt; rule and get a normal construction, but there are several other ways<br>&gt; of getting that effect, such as explicitly typing the literal argument<br>&gt; (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;<br>&gt; A conditional conformance counts as a declared conformance even if the<br>&gt; generic arguments are known to not satisfy the conditional<br>&gt; conformance.  This permits the applicability of the rule to be decided<br>&gt; without having to first decide the type arguments, which greatly<br>&gt; simplifies the type-checking problem (and may be necessary for<br>&gt; soundness; I didn&#39;t explore this in depth, but it certainly feels like<br>&gt; a very nasty sort of dependence).  We could potentially weaken this<br>&gt; for cases where A is a direct type reference with bound parameters,<br>&gt; e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but I think there&#39;s<br>&gt; some benefit from having a simpler specification, both for the<br>&gt; implementation and for the explicability of the model.<br>&gt;<br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  7, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 5, 2016, at 5:18 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; on Thu Jun 02 2016, John McCall &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; The official way to build a literal of a specific type is to write the<br>&gt;&gt; literal in an explicitly-typed context, like so:<br>&gt;&gt;    let x: UInt16 = 7<br>&gt;&gt; or<br>&gt;&gt;    let x = 7 as UInt16<br>&gt;&gt; <br>&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;    UInt16(7)<br>&gt;&gt; <br>&gt;&gt; Unfortunately, this does not attempt to construct the value using the<br>&gt;&gt; appropriate literal protocol; it instead performs overload resolution<br>&gt;&gt; using the standard rules, i.e. considering only single-argument<br>&gt;&gt; unlabelled initializers of a type which conforms to<br>&gt;&gt; IntegerLiteralConvertible.  Often this leads to static ambiguities or,<br>&gt;&gt; worse, causes the literal to be built using a default type (such as<br>&gt;&gt; Int); this may have semantically very different results which are only<br>&gt;&gt; caught at runtime.<br>&gt;&gt; <br>&gt;&gt; In my opinion, using this initializer-call syntax to build an<br>&gt;&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt;&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s<br>&gt;&gt; clear that programmers are going to continue to independently try to<br>&gt;&gt; use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt; <br>&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt; <br>&gt;&gt;  Given a function call expression of the form A(B) (that is, an<br>&gt;&gt; expr-call with a single, unlabelled argument) where B is an<br>&gt;&gt; expr-literal or expr-collection, if A has type T.Type for some type T<br>&gt;&gt; and there is a declared conformance of T to an appropriate literal<br>&gt;&gt; protocol for B, then the expression is always resolves as a literal<br>&gt;&gt; construction of type T (as if the expression were written &quot;B as A&quot;)<br>&gt;&gt; rather than as a general initializer call.<br>&gt;&gt; <br>&gt;&gt; Formally, this would be a special form of the argument conversion<br>&gt;&gt; constraint, since the type of the expression A may not be immediately<br>&gt;&gt; known.<br>&gt; <br>&gt; I realize this is somewhat tangential, but... IMO this may not be entirely<br>&gt; about literals.<br>&gt; <br>&gt; We have a standard that full-width type conversions are written as a<br>&gt; label-free initializer<br>&gt; &lt;https://swift.org/documentation/api-design-guidelines/#type-conversion &lt;https://swift.org/documentation/api-design-guidelines/#type-conversion&gt;&gt;.<br>&gt; I believe that is partly responsible for setting up the expectation that<br>&gt; Int(42) works as one would expect.  It gets ultra-weird when you can<br>&gt; convert from type A to type B using B(someA) but you can&#39;t write<br>&gt; B(someB).  We should automatically generate a label-free “copy<br>&gt; initializer” for value types, to complete implementation of the expected<br>&gt; mental model.<br></p><p>That may also be a good idea, but it won&#39;t magically be preferred for literal<br>construction if the type has any other constructors of literal-convertible type.<br></p><p>John.<br></p><p>&gt; <br>&gt;&gt; Note that, as specified, it is possible to suppress this typing rule<br>&gt;&gt; by wrapping the literal in parentheses.  This might seem distasteful;<br>&gt;&gt; it would be easy enough to allow the form of B to include extra<br>&gt;&gt; parentheses.  It&#39;s potentially useful to have a way to suppress this<br>&gt;&gt; rule and get a normal construction, but there are several other ways<br>&gt;&gt; of getting that effect, such as explicitly typing the literal argument<br>&gt;&gt; (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;&gt; <br>&gt;&gt; A conditional conformance counts as a declared conformance even if the<br>&gt;&gt; generic arguments are known to not satisfy the conditional<br>&gt;&gt; conformance.  This permits the applicability of the rule to be decided<br>&gt;&gt; without having to first decide the type arguments, which greatly<br>&gt;&gt; simplifies the type-checking problem (and may be necessary for<br>&gt;&gt; soundness; I didn&#39;t explore this in depth, but it certainly feels like<br>&gt;&gt; a very nasty sort of dependence).  We could potentially weaken this<br>&gt;&gt; for cases where A is a direct type reference with bound parameters,<br>&gt;&gt; e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but I think there&#39;s<br>&gt;&gt; some benefit from having a simpler specification, both for the<br>&gt;&gt; implementation and for the explicability of the model.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/a4693cbd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  7, 2016 at 04:00:00pm</p></header><div class="content"><p>on Tue Jun 07 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 5, 2016, at 5:18 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; on Thu Jun 02 2016, John McCall &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; The official way to build a literal of a specific type is to write the<br>&gt;&gt;&gt; literal in an explicitly-typed context, like so:<br>&gt;<br>&gt;&gt;&gt;    let x: UInt16 = 7<br>&gt;&gt;&gt; or<br>&gt;&gt;&gt;    let x = 7 as UInt16<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;&gt;    UInt16(7)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately, this does not attempt to construct the value using the<br>&gt;&gt;&gt; appropriate literal protocol; it instead performs overload resolution<br>&gt;&gt;&gt; using the standard rules, i.e. considering only single-argument<br>&gt;&gt;&gt; unlabelled initializers of a type which conforms to<br>&gt;&gt;&gt; IntegerLiteralConvertible.  Often this leads to static ambiguities or,<br>&gt;&gt;&gt; worse, causes the literal to be built using a default type (such as<br>&gt;&gt;&gt; Int); this may have semantically very different results which are only<br>&gt;&gt;&gt; caught at runtime.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my opinion, using this initializer-call syntax to build an<br>&gt;&gt;&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt;&gt;&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s<br>&gt;&gt;&gt; clear that programmers are going to continue to independently try to<br>&gt;&gt;&gt; use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Given a function call expression of the form A(B) (that is, an<br>&gt;&gt;&gt; expr-call with a single, unlabelled argument) where B is an<br>&gt;&gt;&gt; expr-literal or expr-collection, if A has type T.Type for some type T<br>&gt;&gt;&gt; and there is a declared conformance of T to an appropriate literal<br>&gt;&gt;&gt; protocol for B, then the expression is always resolves as a literal<br>&gt;&gt;&gt; construction of type T (as if the expression were written &quot;B as A&quot;)<br>&gt;&gt;&gt; rather than as a general initializer call.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Formally, this would be a special form of the argument conversion<br>&gt;&gt;&gt; constraint, since the type of the expression A may not be immediately<br>&gt;&gt;&gt; known.<br>&gt;&gt; <br>&gt;&gt; I realize this is somewhat tangential, but... IMO this may not be entirely<br>&gt;&gt; about literals.<br>&gt;&gt; <br>&gt;&gt; We have a standard that full-width type conversions are written as a<br>&gt;&gt; label-free initializer<br>&gt;&gt; &lt;https://swift.org/documentation/api-design-guidelines/#type-conversion &lt;https://swift.org/documentation/api-design-guidelines/#type-conversion&gt;&gt;.<br>&gt;&gt; I believe that is partly responsible for setting up the expectation that<br>&gt;&gt; Int(42) works as one would expect.  It gets ultra-weird when you can<br>&gt;&gt; convert from type A to type B using B(someA) but you can&#39;t write<br>&gt;&gt; B(someB).  We should automatically generate a label-free “copy<br>&gt;&gt; initializer” for value types, to complete implementation of the expected<br>&gt;&gt; mental model.<br>&gt;<br>&gt; That may also be a good idea, but it won&#39;t magically be preferred for<br>&gt; literal construction if the type has any other constructors of<br>&gt; literal-convertible type.<br></p><p><br>I know.  I&#39;m saying, fixing this for literals without giving value types<br>copy initializers leaves us with only a partial realization of a larger<br>mental model to which I believe people are programming.<br></p><p>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; Note that, as specified, it is possible to suppress this typing rule<br>&gt;&gt;&gt; by wrapping the literal in parentheses.  This might seem distasteful;<br>&gt;&gt;&gt; it would be easy enough to allow the form of B to include extra<br>&gt;&gt;&gt; parentheses.  It&#39;s potentially useful to have a way to suppress this<br>&gt;&gt;&gt; rule and get a normal construction, but there are several other ways<br>&gt;&gt;&gt; of getting that effect, such as explicitly typing the literal argument<br>&gt;&gt;&gt; (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A conditional conformance counts as a declared conformance even if the<br>&gt;&gt;&gt; generic arguments are known to not satisfy the conditional<br>&gt;&gt;&gt; conformance.  This permits the applicability of the rule to be decided<br>&gt;&gt;&gt; without having to first decide the type arguments, which greatly<br>&gt;&gt;&gt; simplifies the type-checking problem (and may be necessary for<br>&gt;&gt;&gt; soundness; I didn&#39;t explore this in depth, but it certainly feels like<br>&gt;&gt;&gt; a very nasty sort of dependence).  We could potentially weaken this<br>&gt;&gt;&gt; for cases where A is a direct type reference with bound parameters,<br>&gt;&gt;&gt; e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but I think there&#39;s<br>&gt;&gt;&gt; some benefit from having a simpler specification, both for the<br>&gt;&gt;&gt; implementation and for the explicability of the model.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 4:25 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; on Tue Jun 07 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 5, 2016, at 5:18 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; on Thu Jun 02 2016, John McCall &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The official way to build a literal of a specific type is to write the<br>&gt;&gt;&gt;&gt; literal in an explicitly-typed context, like so:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;   let x: UInt16 = 7<br>&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt;   let x = 7 as UInt16<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;&gt;&gt;   UInt16(7)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unfortunately, this does not attempt to construct the value using the<br>&gt;&gt;&gt;&gt; appropriate literal protocol; it instead performs overload resolution<br>&gt;&gt;&gt;&gt; using the standard rules, i.e. considering only single-argument<br>&gt;&gt;&gt;&gt; unlabelled initializers of a type which conforms to<br>&gt;&gt;&gt;&gt; IntegerLiteralConvertible.  Often this leads to static ambiguities or,<br>&gt;&gt;&gt;&gt; worse, causes the literal to be built using a default type (such as<br>&gt;&gt;&gt;&gt; Int); this may have semantically very different results which are only<br>&gt;&gt;&gt;&gt; caught at runtime.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my opinion, using this initializer-call syntax to build an<br>&gt;&gt;&gt;&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt;&gt;&gt;&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s<br>&gt;&gt;&gt;&gt; clear that programmers are going to continue to independently try to<br>&gt;&gt;&gt;&gt; use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Given a function call expression of the form A(B) (that is, an<br>&gt;&gt;&gt;&gt; expr-call with a single, unlabelled argument) where B is an<br>&gt;&gt;&gt;&gt; expr-literal or expr-collection, if A has type T.Type for some type T<br>&gt;&gt;&gt;&gt; and there is a declared conformance of T to an appropriate literal<br>&gt;&gt;&gt;&gt; protocol for B, then the expression is always resolves as a literal<br>&gt;&gt;&gt;&gt; construction of type T (as if the expression were written &quot;B as A&quot;)<br>&gt;&gt;&gt;&gt; rather than as a general initializer call.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Formally, this would be a special form of the argument conversion<br>&gt;&gt;&gt;&gt; constraint, since the type of the expression A may not be immediately<br>&gt;&gt;&gt;&gt; known.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I realize this is somewhat tangential, but... IMO this may not be entirely<br>&gt;&gt;&gt; about literals.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have a standard that full-width type conversions are written as a<br>&gt;&gt;&gt; label-free initializer<br>&gt;&gt;&gt; &lt;https://swift.org/documentation/api-design-guidelines/#type-conversion &lt;https://swift.org/documentation/api-design-guidelines/#type-conversion&gt;&gt;.<br>&gt;&gt;&gt; I believe that is partly responsible for setting up the expectation that<br>&gt;&gt;&gt; Int(42) works as one would expect.  It gets ultra-weird when you can<br>&gt;&gt;&gt; convert from type A to type B using B(someA) but you can&#39;t write<br>&gt;&gt;&gt; B(someB).  We should automatically generate a label-free “copy<br>&gt;&gt;&gt; initializer” for value types, to complete implementation of the expected<br>&gt;&gt;&gt; mental model.<br>&gt;&gt; <br>&gt;&gt; That may also be a good idea, but it won&#39;t magically be preferred for<br>&gt;&gt; literal construction if the type has any other constructors of<br>&gt;&gt; literal-convertible type.<br>&gt; <br>&gt; <br>&gt; I know.  I&#39;m saying, fixing this for literals without giving value types<br>&gt; copy initializers leaves us with only a partial realization of a larger<br>&gt; mental model to which I believe people are programming.<br></p><p>That&#39;s fair.  Would you like me to incorporate that into my proposal, then?  I see the relation, but it&#39;s a pretty significant jump in scope.<br></p><p>John.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that, as specified, it is possible to suppress this typing rule<br>&gt;&gt;&gt;&gt; by wrapping the literal in parentheses.  This might seem distasteful;<br>&gt;&gt;&gt;&gt; it would be easy enough to allow the form of B to include extra<br>&gt;&gt;&gt;&gt; parentheses.  It&#39;s potentially useful to have a way to suppress this<br>&gt;&gt;&gt;&gt; rule and get a normal construction, but there are several other ways<br>&gt;&gt;&gt;&gt; of getting that effect, such as explicitly typing the literal argument<br>&gt;&gt;&gt;&gt; (e.g. writing &quot;A(Int(B))&quot;).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A conditional conformance counts as a declared conformance even if the<br>&gt;&gt;&gt;&gt; generic arguments are known to not satisfy the conditional<br>&gt;&gt;&gt;&gt; conformance.  This permits the applicability of the rule to be decided<br>&gt;&gt;&gt;&gt; without having to first decide the type arguments, which greatly<br>&gt;&gt;&gt;&gt; simplifies the type-checking problem (and may be necessary for<br>&gt;&gt;&gt;&gt; soundness; I didn&#39;t explore this in depth, but it certainly feels like<br>&gt;&gt;&gt;&gt; a very nasty sort of dependence).  We could potentially weaken this<br>&gt;&gt;&gt;&gt; for cases where A is a direct type reference with bound parameters,<br>&gt;&gt;&gt;&gt; e.g. Foo&lt;Int&gt;([]) or the same with a typealias, but I think there&#39;s<br>&gt;&gt;&gt;&gt; some benefit from having a simpler specification, both for the<br>&gt;&gt;&gt;&gt; implementation and for the explicability of the model.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -- <br>&gt; Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  8, 2016 at 11:00:00am</p></header><div class="content"><p>on Wed Jun 08 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 7, 2016, at 4:25 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; on Tue Jun 07 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 5, 2016, at 5:18 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; on Thu Jun 02 2016, John McCall &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The official way to build a literal of a specific type is to write the<br>&gt;&gt;&gt;&gt;&gt; literal in an explicitly-typed context, like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   let x: UInt16 = 7<br>&gt;&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt;&gt;   let x = 7 as UInt16<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;&gt;&gt;&gt;   UInt16(7)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Unfortunately, this does not attempt to construct the value using the<br>&gt;&gt;&gt;&gt;&gt; appropriate literal protocol; it instead performs overload resolution<br>&gt;&gt;&gt;&gt;&gt; using the standard rules, i.e. considering only single-argument<br>&gt;&gt;&gt;&gt;&gt; unlabelled initializers of a type which conforms to<br>&gt;&gt;&gt;&gt;&gt; IntegerLiteralConvertible.  Often this leads to static ambiguities or,<br>&gt;&gt;&gt;&gt;&gt; worse, causes the literal to be built using a default type (such as<br>&gt;&gt;&gt;&gt;&gt; Int); this may have semantically very different results which are only<br>&gt;&gt;&gt;&gt;&gt; caught at runtime.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In my opinion, using this initializer-call syntax to build an<br>&gt;&gt;&gt;&gt;&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt;&gt;&gt;&gt;&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s<br>&gt;&gt;&gt;&gt;&gt; clear that programmers are going to continue to independently try to<br>&gt;&gt;&gt;&gt;&gt; use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Given a function call expression of the form A(B) (that is, an<br>&gt;&gt;&gt;&gt;&gt; expr-call with a single, unlabelled argument) where B is an<br>&gt;&gt;&gt;&gt;&gt; expr-literal or expr-collection, if A has type T.Type for some type T<br>&gt;&gt;&gt;&gt;&gt; and there is a declared conformance of T to an appropriate literal<br>&gt;&gt;&gt;&gt;&gt; protocol for B, then the expression is always resolves as a literal<br>&gt;&gt;&gt;&gt;&gt; construction of type T (as if the expression were written &quot;B as A&quot;)<br>&gt;&gt;&gt;&gt;&gt; rather than as a general initializer call.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Formally, this would be a special form of the argument conversion<br>&gt;&gt;&gt;&gt;&gt; constraint, since the type of the expression A may not be immediately<br>&gt;&gt;&gt;&gt;&gt; known.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I realize this is somewhat tangential, but... IMO this may not be entirely<br>&gt;&gt;&gt;&gt; about literals.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We have a standard that full-width type conversions are written as a<br>&gt;&gt;&gt;&gt; label-free initializer<br>&gt;&gt;&gt;&gt; &lt;https://swift.org/documentation/api-design-guidelines/#type-conversion<br>&gt;&gt;&gt;&gt; &lt;https://swift.org/documentation/api-design-guidelines/#type-conversion&gt;&gt;.<br>&gt;&gt;&gt;&gt; I believe that is partly responsible for setting up the expectation that<br>&gt;&gt;&gt;&gt; Int(42) works as one would expect.  It gets ultra-weird when you can<br>&gt;&gt;&gt;&gt; convert from type A to type B using B(someA) but you can&#39;t write<br>&gt;&gt;&gt;&gt; B(someB).  We should automatically generate a label-free “copy<br>&gt;&gt;&gt;&gt; initializer” for value types, to complete implementation of the expected<br>&gt;&gt;&gt;&gt; mental model.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That may also be a good idea, but it won&#39;t magically be preferred for<br>&gt;&gt;&gt; literal construction if the type has any other constructors of<br>&gt;&gt;&gt; literal-convertible type.<br>&gt;&gt; <br>&gt;&gt; I know.  I&#39;m saying, fixing this for literals without giving value types<br>&gt;&gt; copy initializers leaves us with only a partial realization of a larger<br>&gt;&gt; mental model to which I believe people are programming.<br>&gt;<br>&gt; That&#39;s fair.  Would you like me to incorporate that into my proposal,<br>&gt; then?  I see the relation, but it&#39;s a pretty significant jump in<br>&gt; scope.<br></p><p>I&#39;m not sure it should be in the same proposal; I just want it to be a<br>part of the discussion.  We should be able to make incremental progress,<br>but let&#39;s make sure we understand how our changes fit into the big picture.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: &#39;T(literal)&#39; should construct T using the appropriate literal protocol if possible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  8, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 11:15 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; on Wed Jun 08 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 7, 2016, at 4:25 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; on Tue Jun 07 2016, John McCall &lt;rjmccall-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 5:18 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; on Thu Jun 02 2016, John McCall &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The official way to build a literal of a specific type is to write the<br>&gt;&gt;&gt;&gt;&gt;&gt; literal in an explicitly-typed context, like so:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  let x: UInt16 = 7<br>&gt;&gt;&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt;&gt;&gt;  let x = 7 as UInt16<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Nonetheless, programmers often try the following:<br>&gt;&gt;&gt;&gt;&gt;&gt;  UInt16(7)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Unfortunately, this does not attempt to construct the value using the<br>&gt;&gt;&gt;&gt;&gt;&gt; appropriate literal protocol; it instead performs overload resolution<br>&gt;&gt;&gt;&gt;&gt;&gt; using the standard rules, i.e. considering only single-argument<br>&gt;&gt;&gt;&gt;&gt;&gt; unlabelled initializers of a type which conforms to<br>&gt;&gt;&gt;&gt;&gt;&gt; IntegerLiteralConvertible.  Often this leads to static ambiguities or,<br>&gt;&gt;&gt;&gt;&gt;&gt; worse, causes the literal to be built using a default type (such as<br>&gt;&gt;&gt;&gt;&gt;&gt; Int); this may have semantically very different results which are only<br>&gt;&gt;&gt;&gt;&gt;&gt; caught at runtime.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, using this initializer-call syntax to build an<br>&gt;&gt;&gt;&gt;&gt;&gt; explicitly-typed literal is an obvious and natural choice with several<br>&gt;&gt;&gt;&gt;&gt;&gt; advantages over the &quot;as&quot; syntax.  However, even if you disagree, it&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt; clear that programmers are going to continue to independently try to<br>&gt;&gt;&gt;&gt;&gt;&gt; use it, so it&#39;s really unfortunate for it to be subtly wrong.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Therefore, I propose that we adopt the following typing rule:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Given a function call expression of the form A(B) (that is, an<br>&gt;&gt;&gt;&gt;&gt;&gt; expr-call with a single, unlabelled argument) where B is an<br>&gt;&gt;&gt;&gt;&gt;&gt; expr-literal or expr-collection, if A has type T.Type for some type T<br>&gt;&gt;&gt;&gt;&gt;&gt; and there is a declared conformance of T to an appropriate literal<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol for B, then the expression is always resolves as a literal<br>&gt;&gt;&gt;&gt;&gt;&gt; construction of type T (as if the expression were written &quot;B as A&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt; rather than as a general initializer call.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Formally, this would be a special form of the argument conversion<br>&gt;&gt;&gt;&gt;&gt;&gt; constraint, since the type of the expression A may not be immediately<br>&gt;&gt;&gt;&gt;&gt;&gt; known.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I realize this is somewhat tangential, but... IMO this may not be entirely<br>&gt;&gt;&gt;&gt;&gt; about literals.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We have a standard that full-width type conversions are written as a<br>&gt;&gt;&gt;&gt;&gt; label-free initializer<br>&gt;&gt;&gt;&gt;&gt; &lt;https://swift.org/documentation/api-design-guidelines/#type-conversion<br>&gt;&gt;&gt;&gt;&gt; &lt;https://swift.org/documentation/api-design-guidelines/#type-conversion&gt;&gt;.<br>&gt;&gt;&gt;&gt;&gt; I believe that is partly responsible for setting up the expectation that<br>&gt;&gt;&gt;&gt;&gt; Int(42) works as one would expect.  It gets ultra-weird when you can<br>&gt;&gt;&gt;&gt;&gt; convert from type A to type B using B(someA) but you can&#39;t write<br>&gt;&gt;&gt;&gt;&gt; B(someB).  We should automatically generate a label-free “copy<br>&gt;&gt;&gt;&gt;&gt; initializer” for value types, to complete implementation of the expected<br>&gt;&gt;&gt;&gt;&gt; mental model.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That may also be a good idea, but it won&#39;t magically be preferred for<br>&gt;&gt;&gt;&gt; literal construction if the type has any other constructors of<br>&gt;&gt;&gt;&gt; literal-convertible type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know.  I&#39;m saying, fixing this for literals without giving value types<br>&gt;&gt;&gt; copy initializers leaves us with only a partial realization of a larger<br>&gt;&gt;&gt; mental model to which I believe people are programming.<br>&gt;&gt; <br>&gt;&gt; That&#39;s fair.  Would you like me to incorporate that into my proposal,<br>&gt;&gt; then?  I see the relation, but it&#39;s a pretty significant jump in<br>&gt;&gt; scope.<br>&gt; <br>&gt; I&#39;m not sure it should be in the same proposal; I just want it to be a<br>&gt; part of the discussion.  We should be able to make incremental progress,<br>&gt; but let&#39;s make sure we understand how our changes fit into the big picture.<br></p><p>Sure thing.  I agree that that is an interesting way of conceptualizing how<br>this proposal works, at least for value types where the initializer is synthesized:<br>you could think of it as saying that there&#39;s a rule to prefer the &quot;copy initializer&quot;<br>when the argument is a literal and the type is literally constructible.<br></p><p>The flip side is that that argument wouldn&#39;t apply to class types or (presumably)<br>generic type parameters, but we&#39;d still want e.g. T(1) to work if T: IntegerLiteralConvertible.<br></p><p>John.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
