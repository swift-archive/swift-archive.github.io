<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Can we `override var hashValue`?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>September  3, 2016 at 06:00:00am</p></header><div class="content"><p>In Objective-C, it says<br></p><p>If two objects are equal, they must have the same hash value. This last<br>&gt; point is particularly important if you define isEqual: in a subclass and<br>&gt; intend to put instances of that subclass into a collection. Make sure you<br>&gt; also define hash in your subclass.<br></p><p>https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/index.html#//apple_ref/occ/intfm/NSObject/isEqual:<br>&gt;<br></p><p><br>​So the conclusion is that hash can be override.<br></p><p>However, in Swift, things go a little odd. Below code works in both Swift<br>2.2(Xcode 7.3.1) and Swift 3.0(Xcode 8 beta 6).<br></p><p>func ==(lhs: Fruit, rhs: Fruit) -&gt; Bool {<br></p><p>    print(lhs.hashValue)<br></p><p>    print(rhs.hashValue)<br></p><p><br></p><p>    return lhs.name == rhs.name<br></p><p>}<br></p><p><br>func ==(lhs: Apple, rhs: Apple) -&gt; Bool {<br></p><p>    return lhs.name == rhs.name &amp;&amp; lhs.shape == rhs.shape<br></p><p>}<br></p><p><br>func ==(lhs: Banana, rhs: Banana) -&gt; Bool {<br></p><p>    return lhs.name == rhs.name &amp;&amp; lhs.shape == rhs.shape<br></p><p>}<br></p><p><br></p><p>class Fruit:Hashable {<br></p><p>    let name:String<br></p><p><br></p><p>    var hashValue: Int {<br></p><p>        return 0<br></p><p>    }<br></p><p><br></p><p>    init(_ name:String = &quot;common fruit&quot;) {<br></p><p>        self.name = name<br></p><p>    }<br></p><p>}<br></p><p><br>enum FruitShape:Int {<br></p><p>    case small = 1000<br></p><p>    case medium = 2000<br></p><p>    case big = 3000<br></p><p>}<br></p><p><br>class Apple:Fruit {<br></p><p>    let shape:FruitShape = .medium<br></p><p><br></p><p>    override var hashValue: Int {<br></p><p>        return 5<br></p><p>    }<br></p><p>}<br></p><p><br>class Banana:Fruit {<br></p><p>    let shape:FruitShape = .big<br></p><p><br></p><p>    override var hashValue: Int {<br></p><p>        return 10<br></p><p>    }<br></p><p>}<br></p><p><br>let apple = Apple()<br></p><p>let banana = Banana()<br></p><p><br>print(apple == banana)<br></p><p>/*<br></p><p> 5<br></p><p> 10<br></p><p> true<br>*/<br></p><p>My question is, apple equals banana, but their hashValues (in their own<br>types)  don&#39;t. What&#39;s wrong here? Is that means we shouldn&#39;t override<br>hashValue in subclass in Swift?<br></p><p>Zhaoxin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160903/13ad4c82/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Can we `override var hashValue`?</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>September  3, 2016 at 02:00:00am</p></header><div class="content"><p>On Sat, Sep 3, 2016 at 1:31 AM, Zhao Xin via swift-users<br>&lt;swift-users at swift.org&gt; wrote:<br>&gt; func ==(lhs: Apple, rhs: Apple) -&gt; Bool {<br>&gt;     return lhs.name == rhs.name &amp;&amp; lhs.shape == rhs.shape<br>&gt; }<br>&gt;<br>&gt; func ==(lhs: Banana, rhs: Banana) -&gt; Bool {<br>&gt;     return lhs.name == rhs.name &amp;&amp; lhs.shape == rhs.shape<br>&gt; }<br></p><p>There is no reason to compare the shape, it is a constant in each of<br>these types.  (So I am not sure what your point is.)<br></p><p>&gt; My question is, apple equals banana, but their hashValues (in their own<br>&gt; types)  don&#39;t. What&#39;s wrong here? Is that means we shouldn&#39;t override<br>&gt; hashValue in subclass in Swift?<br></p><p>This means you should not override hashValue in this particular way.<br>If two values are equal, their hash values should be equal.  As long<br>as your override implementation guarantees this, you can override<br>hashValue.<br></p><p>You should also understand that the ==(Apple, Apple) and ==(Banana,<br>Banana) are not overrides for ==(Fruit, Fruit), and they would not be<br>called through dynamic dispatch when you have, for example, two apples<br>typed as fruits.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Can we `override var hashValue`?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>September  3, 2016 at 09:00:00am</p></header><div class="content"><p>&gt;<br>&gt; There is no reason to compare the shape, it is a constant in each of<br></p><p>these types.  (So I am not sure what your point is.)<br></p><p><br>Sorry. The `let shape` should be `var shape`. I just wanted to make the<br>subclass to be something more than the super class.<br></p><p>If two values are equal, their hash values should be equal.  As long<br>&gt; as your override implementation guarantees this, you can override<br>&gt; hashValue.<br></p><p><br>But the question is how? If this must be guaranteed by the subclass, how to<br>writing the override? Or it just can&#39;t be done?<br></p><p>You should also understand that the ==(Apple, Apple) and ==(Banana,<br>&gt; Banana) are not overrides for ==(Fruit, Fruit), and they would not be<br>&gt; called through dynamic dispatch when you have, for example, two apples<br>&gt; typed as fruits.<br></p><p><br>In fact, in my example code, `apple` and `banana` is instance of `Apple`<br>and `Banana`. They are not using `let apple:Fruit = Apple()`. The `==` used<br>the *`Fruit` version* as it was the only appropriate one. My big question<br>is, since they used the `*Fruit` version*, and the *`Fruit` version of<br>`hashValue`* could guarantee the `hashValue` equality, isn&#39;t that enough?<br></p><p>Zhaoxin<br></p><p><br>On Sat, Sep 3, 2016 at 7:02 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br></p><p>&gt; On Sat, Sep 3, 2016 at 1:31 AM, Zhao Xin via swift-users<br>&gt; &lt;swift-users at swift.org&gt; wrote:<br>&gt; &gt; func ==(lhs: Apple, rhs: Apple) -&gt; Bool {<br>&gt; &gt;     return lhs.name == rhs.name &amp;&amp; lhs.shape == rhs.shape<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; func ==(lhs: Banana, rhs: Banana) -&gt; Bool {<br>&gt; &gt;     return lhs.name == rhs.name &amp;&amp; lhs.shape == rhs.shape<br>&gt; &gt; }<br>&gt;<br>&gt; There is no reason to compare the shape, it is a constant in each of<br>&gt; these types.  (So I am not sure what your point is.)<br>&gt;<br>&gt; &gt; My question is, apple equals banana, but their hashValues (in their own<br>&gt; &gt; types)  don&#39;t. What&#39;s wrong here? Is that means we shouldn&#39;t override<br>&gt; &gt; hashValue in subclass in Swift?<br>&gt;<br>&gt; This means you should not override hashValue in this particular way.<br>&gt; If two values are equal, their hash values should be equal.  As long<br>&gt; as your override implementation guarantees this, you can override<br>&gt; hashValue.<br>&gt;<br>&gt; You should also understand that the ==(Apple, Apple) and ==(Banana,<br>&gt; Banana) are not overrides for ==(Fruit, Fruit), and they would not be<br>&gt; called through dynamic dispatch when you have, for example, two apples<br>&gt; typed as fruits.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160903/66f60bc0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Can we `override var hashValue`?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>September  3, 2016 at 09:00:00am</p></header><div class="content"><p>The key is how to write the `==` function. It should compare the`<br>dynamicType`(or `type(of:)` in Swift 3.0) if the class is not a final class.<br></p><p>func ==(lhs: Fruit, rhs: Fruit) -&gt; Bool {<br></p><p><br></p><p>    print(lhs.hashValue)<br></p><p>    print(rhs.hashValue)<br></p><p><br></p><p>    return type(of:lhs) == type(of:rhs) &amp;&amp; lhs.name == rhs.name<br></p><p>}<br></p><p><br>func ==(lhs: Apple, rhs: Apple) -&gt; Bool {<br></p><p>    return type(of:lhs) == type(of:rhs) &amp;&amp; lhs.name == rhs.name &amp;&amp; lhs.shape<br>== rhs.shape<br></p><p>}<br></p><p><br>func ==(lhs: Banana, rhs: Banana) -&gt; Bool {<br></p><p>    return type(of:lhs) == type(of:rhs) &amp;&amp; lhs.name == rhs.name &amp;&amp; lhs.shape<br>== rhs.shape<br></p><p>}<br></p><p><br></p><p>class Fruit:Hashable {<br></p><p>    let name:String<br></p><p><br></p><p>    var hashValue: Int {<br></p><p>        return 0<br></p><p>    }<br></p><p><br></p><p>    init(_ name:String = &quot;common fruit&quot;) {<br></p><p>        self.name = name<br></p><p>    }<br></p><p>}<br></p><p><br>enum FruitShape:Int {<br></p><p>    case small = 1000<br></p><p>    case medium = 2000<br></p><p>    case big = 3000<br></p><p>}<br></p><p><br>class Apple:Fruit {<br></p><p>    let shape:FruitShape<br></p><p><br></p><p>    override var hashValue: Int {<br></p><p>        return 5<br></p><p>    }<br></p><p><br></p><p>    required init(_ name:String = &quot;common fruit&quot;, shape:FruitShape = .medium)<br>{<br></p><p>        self.shape = shape<br></p><p>        super.init(name)<br></p><p>    }<br></p><p>}<br></p><p><br>class Banana:Fruit {<br></p><p>    let shape:FruitShape<br></p><p><br></p><p>    override var hashValue: Int {<br></p><p>        return 10<br></p><p>    }<br></p><p><br></p><p>    required init(_ name:String = &quot;common fruit&quot;, shape:FruitShape = .medium)<br>{<br></p><p>        self.shape = shape<br></p><p>        super.init(name)<br></p><p>    }<br></p><p>}<br></p><p><br>let apple = Apple()<br></p><p>let banana = Banana()<br></p><p><br>print(apple == banana)<br></p><p>/*<br></p><p> 5<br></p><p> 10<br></p><p> false<br></p><p>*/<br></p><p><br>I got the idea from book &quot;Core Java&quot;, mine is version 8, the latest is the<br>version 10. I learnt how to writing Object oriented code from it. I am glad<br>it is still useful.<br></p><p><br>Zhaoxin<br></p><p>On Sat, Sep 3, 2016 at 9:14 AM, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br></p><p>&gt; There is no reason to compare the shape, it is a constant in each of<br>&gt;<br>&gt; these types.  (So I am not sure what your point is.)<br>&gt;<br>&gt;<br>&gt; Sorry. The `let shape` should be `var shape`. I just wanted to make the<br>&gt; subclass to be something more than the super class.<br>&gt;<br>&gt; If two values are equal, their hash values should be equal.  As long<br>&gt;&gt; as your override implementation guarantees this, you can override<br>&gt;&gt; hashValue.<br>&gt;<br>&gt;<br>&gt; But the question is how? If this must be guaranteed by the subclass, how<br>&gt; to writing the override? Or it just can&#39;t be done?<br>&gt;<br>&gt; You should also understand that the ==(Apple, Apple) and ==(Banana,<br>&gt;&gt; Banana) are not overrides for ==(Fruit, Fruit), and they would not be<br>&gt;&gt; called through dynamic dispatch when you have, for example, two apples<br>&gt;&gt; typed as fruits.<br>&gt;<br>&gt;<br>&gt; In fact, in my example code, `apple` and `banana` is instance of `Apple`<br>&gt; and `Banana`. They are not using `let apple:Fruit = Apple()`. The `==` used<br>&gt; the *`Fruit` version* as it was the only appropriate one. My big question<br>&gt; is, since they used the `*Fruit` version*, and the *`Fruit` version of<br>&gt; `hashValue`* could guarantee the `hashValue` equality, isn&#39;t that enough?<br>&gt;<br>&gt; Zhaoxin<br>&gt;<br>&gt;<br>&gt; On Sat, Sep 3, 2016 at 7:02 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Sat, Sep 3, 2016 at 1:31 AM, Zhao Xin via swift-users<br>&gt;&gt; &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; &gt; func ==(lhs: Apple, rhs: Apple) -&gt; Bool {<br>&gt;&gt; &gt;     return lhs.name == rhs.name &amp;&amp; lhs.shape == rhs.shape<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; func ==(lhs: Banana, rhs: Banana) -&gt; Bool {<br>&gt;&gt; &gt;     return lhs.name == rhs.name &amp;&amp; lhs.shape == rhs.shape<br>&gt;&gt; &gt; }<br>&gt;&gt;<br>&gt;&gt; There is no reason to compare the shape, it is a constant in each of<br>&gt;&gt; these types.  (So I am not sure what your point is.)<br>&gt;&gt;<br>&gt;&gt; &gt; My question is, apple equals banana, but their hashValues (in their own<br>&gt;&gt; &gt; types)  don&#39;t. What&#39;s wrong here? Is that means we shouldn&#39;t override<br>&gt;&gt; &gt; hashValue in subclass in Swift?<br>&gt;&gt;<br>&gt;&gt; This means you should not override hashValue in this particular way.<br>&gt;&gt; If two values are equal, their hash values should be equal.  As long<br>&gt;&gt; as your override implementation guarantees this, you can override<br>&gt;&gt; hashValue.<br>&gt;&gt;<br>&gt;&gt; You should also understand that the ==(Apple, Apple) and ==(Banana,<br>&gt;&gt; Banana) are not overrides for ==(Fruit, Fruit), and they would not be<br>&gt;&gt; called through dynamic dispatch when you have, for example, two apples<br>&gt;&gt; typed as fruits.<br>&gt;&gt;<br>&gt;&gt; Dmitri<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160903/f6d581dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Can we `override var hashValue`?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>September  6, 2016 at 10:00:00am</p></header><div class="content"><p>As I’ve said before, this doesn’t work.<br></p><p>let x: Fruit = Apple(“a”, shape: .medium)<br>let y: Fruit = Apple(“a”, shape: .big)<br>print(x == y) // will print true<br></p><p>If you want == to behave differently for subclasses, it needs to call a method that can be overridden. Static overloads will not produce the same behavior.<br></p><p>Jordan<br></p><p><br></p><p>&gt; On Sep 2, 2016, at 18:42, Zhao Xin via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; The key is how to write the `==` function. It should compare the` dynamicType`(or `type(of:)` in Swift 3.0) if the class is not a final class.<br>&gt; <br>&gt; func ==(lhs: Fruit, rhs: Fruit) -&gt; Bool {<br>&gt;     <br>&gt;     print(lhs.hashValue)<br>&gt;     print(rhs.hashValue)<br>&gt;     <br>&gt;     return type(of:lhs) == type(of:rhs) &amp;&amp; lhs.name == rhs.name<br>&gt; }<br>&gt; <br>&gt; func ==(lhs: Apple, rhs: Apple) -&gt; Bool {<br>&gt;     return type(of:lhs) == type(of:rhs) &amp;&amp; lhs.name == rhs.name &amp;&amp; lhs.shape == rhs.shape<br>&gt; }<br>&gt; <br>&gt; func ==(lhs: Banana, rhs: Banana) -&gt; Bool {<br>&gt;     return type(of:lhs) == type(of:rhs) &amp;&amp; lhs.name == rhs.name &amp;&amp; lhs.shape == rhs.shape<br>&gt; }<br>&gt; <br>&gt; <br>&gt; class Fruit:Hashable {<br>&gt;     let name:String<br>&gt;     <br>&gt;     var hashValue: Int {<br>&gt;         return 0<br>&gt;     }<br>&gt;     <br>&gt;     init(_ name:String = &quot;common fruit&quot;) {<br>&gt;         self.name = name<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; enum FruitShape:Int {<br>&gt;     case small = 1000<br>&gt;     case medium = 2000<br>&gt;     case big = 3000<br>&gt; }<br>&gt; <br>&gt; class Apple:Fruit {<br>&gt;     let shape:FruitShape<br>&gt;     <br>&gt;     override var hashValue: Int {<br>&gt;         return 5<br>&gt;     }<br>&gt;     <br>&gt;     required init(_ name:String = &quot;common fruit&quot;, shape:FruitShape = .medium) {<br>&gt;         self.shape = shape<br>&gt;         super.init(name)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class Banana:Fruit {<br>&gt;     let shape:FruitShape<br>&gt;     <br>&gt;     override var hashValue: Int {<br>&gt;         return 10<br>&gt;     }<br>&gt;     <br>&gt;     required init(_ name:String = &quot;common fruit&quot;, shape:FruitShape = .medium) {<br>&gt;         self.shape = shape<br>&gt;         super.init(name)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let apple = Apple()<br>&gt; let banana = Banana()<br>&gt; <br>&gt; print(apple == banana)<br>&gt; /*<br>&gt;  5<br>&gt;  10<br>&gt;  false<br>&gt; */<br>&gt; <br>&gt; I got the idea from book &quot;Core Java&quot;, mine is version 8, the latest is the version 10. I learnt how to writing Object oriented code from it. I am glad it is still useful.<br>&gt; <br>&gt; Zhaoxin<br>&gt; <br>&gt; On Sat, Sep 3, 2016 at 9:14 AM, Zhao Xin &lt;owenzx at gmail.com &lt;mailto:owenzx at gmail.com&gt;&gt; wrote:<br>&gt; There is no reason to compare the shape, it is a constant in each of<br>&gt; these types.  (So I am not sure what your point is.)<br>&gt; <br>&gt; Sorry. The `let shape` should be `var shape`. I just wanted to make the subclass to be something more than the super class.<br>&gt; <br>&gt; If two values are equal, their hash values should be equal.  As long<br>&gt; as your override implementation guarantees this, you can override<br>&gt; hashValue.<br>&gt; <br>&gt; But the question is how? If this must be guaranteed by the subclass, how to writing the override? Or it just can&#39;t be done?<br>&gt; <br>&gt; You should also understand that the ==(Apple, Apple) and ==(Banana,<br>&gt; Banana) are not overrides for ==(Fruit, Fruit), and they would not be<br>&gt; called through dynamic dispatch when you have, for example, two apples<br>&gt; typed as fruits.<br>&gt; <br>&gt; In fact, in my example code, `apple` and `banana` is instance of `Apple` and `Banana`. They are not using `let apple:Fruit = Apple()`. The `==` used the `Fruit` version as it was the only appropriate one. My big question is, since they used the `Fruit` version, and the `Fruit` version of `hashValue` could guarantee the `hashValue` equality, isn&#39;t that enough?<br>&gt; <br>&gt; Zhaoxin<br>&gt;  <br>&gt; <br>&gt; On Sat, Sep 3, 2016 at 7:02 AM, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt; On Sat, Sep 3, 2016 at 1:31 AM, Zhao Xin via swift-users<br>&gt; &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; &gt; func ==(lhs: Apple, rhs: Apple) -&gt; Bool {<br>&gt; &gt;     return lhs.name &lt;http://lhs.name/&gt; == rhs.name &lt;http://rhs.name/&gt; &amp;&amp; lhs.shape == rhs.shape<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; func ==(lhs: Banana, rhs: Banana) -&gt; Bool {<br>&gt; &gt;     return lhs.name &lt;http://lhs.name/&gt; == rhs.name &lt;http://rhs.name/&gt; &amp;&amp; lhs.shape == rhs.shape<br>&gt; &gt; }<br>&gt; <br>&gt; There is no reason to compare the shape, it is a constant in each of<br>&gt; these types.  (So I am not sure what your point is.)<br>&gt; <br>&gt; &gt; My question is, apple equals banana, but their hashValues (in their own<br>&gt; &gt; types)  don&#39;t. What&#39;s wrong here? Is that means we shouldn&#39;t override<br>&gt; &gt; hashValue in subclass in Swift?<br>&gt; <br>&gt; This means you should not override hashValue in this particular way.<br>&gt; If two values are equal, their hash values should be equal.  As long<br>&gt; as your override implementation guarantees this, you can override<br>&gt; hashValue.<br>&gt; <br>&gt; You should also understand that the ==(Apple, Apple) and ==(Banana,<br>&gt; Banana) are not overrides for ==(Fruit, Fruit), and they would not be<br>&gt; called through dynamic dispatch when you have, for example, two apples<br>&gt; typed as fruits.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160906/0381be09/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b397983c72fc0400927bd578212b8b5e?s=50"></div><header><strong>Can we `override var hashValue`?</strong> from <string>Lou Zell</string> &lt;lzell11 at gmail.com&gt;<p>September  6, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; My question is, apple equals banana, but their hashValues (in their own<br>&gt; types)  don&#39;t. What&#39;s wrong here?<br></p><p>​<br>Hi Zhao.  In addition to what Jordan and Dmitri have said, I think part of<br>the confusion is that you are assuming hash values are implicitly used in<br>an equality check.  They are not.  They are used when your instances are<br>added to certain types of collections.<br></p><p>In your first example, where you print out the hash values but then compare<br>lhs.name to rhs.name, the names of the two fruits are both &quot;common fruit&quot;,<br>and the equality test returns true.  Hash never comes into play.  You can<br>test for yourself when the hash gets used:<br></p><p>import Foundation<br>class Foo: NSObject {<br>    override var hash: Int {<br>        print(&quot;Computing hash value!&quot;)<br>        return 1<br>    }<br>}<br>var f1 = Foo()<br>var f2 = Foo()<br>f1 == f2  // Doesn&#39;t print anything!<br>var aSet = Set&lt;Foo&gt;()<br>aSet.insert(f1)  // Prints &quot;Computing has value!&quot;<br></p><p>Lou<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160906/c26fd364/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Can we `override var hashValue`?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>September  7, 2016 at 07:00:00am</p></header><div class="content"><p>Thanks Lou.<br></p><p>In addition to what Jordan and Dmitri have said, I think part of the<br>&gt; confusion is that you are assuming hash values are implicitly used in an<br>&gt; equality check.  They are not.  They are used when your instances are added<br>&gt; to certain types of collections.<br></p><p><br>​You are very nice. But I was not assuming hash values were implicitly used<br>in an equality check. In fact, my problem was solved on the third email of<br>mine in this thread.<br></p><p>Here is the history of the question and the answer.<br></p><p>1. On the point of &quot;Can we `override var hashValue`&quot;, I was and am on the<br>side of definitely &quot;Yes&quot;. And Jordan Rose, was on the side of perhaps, &quot;but<br>someone should carefully implemented the `hashValue` on base class and<br>subclasses, so that the rule &quot;if `a==b`, then `a.hashValue==b.hashValue`<br>wouldn&#39;t be violated&quot;.<br></p><p>2. At the beginning, I still thought we could `override var hashValue`. But<br>it violated the rule with comparing between instances from different<br>subclasses. My explanation was that since the hashValue on the base class<br>was not violated the rule, the rule was not broken. Also I insisted that<br>thought it was not documented, the base of equality should be the types of<br>instances equaled at first.  I knew my point was weak, so I asked in this<br>thread to see if there was something I missed.<br></p><p>3. I got the reply from Michael Nisi. But I thought his point was alike<br>Jordan&#39;s. I knew I was gotten the point of &quot; the base of equality should be<br>the types of instances equaled at first&quot; from somewhere. So I looked up.<br>Turned out I found it in the book &quot;Core Java&quot;.<br></p><p>4. The conclusion: The rule should not be violated at any time. My previous<br>explanation of &quot;since the hashValue on the base class was not violated the<br>rule, the rule was not broken&quot; was wrong. However, Jordan&#39;s point &quot;someone<br>should carefully implemented the `hashValue` on base class and subclass, so<br>that the rule &quot;if `a==b`, then `a.hashValue==b.hashValue` wouldn&#39;t be<br>violated. &quot; was also not correct. As there was no way to `override<br>hashValue` like that.<br></p><p>Here are my points on &quot; Can we `override var hashValue`&quot;:<br></p><p>1. We can. But we should firstly test the `type(of:lhs) == type(of:rhs)`.<br>If that doesn&#39;t equal, we return false. This technique solved the problem<br>of mine in this thread. This should be the first choice of all situations.<br></p><p>2. We can but we may prefer not to. If we choose not to, we must keep that<br>to all subclasses of the base class. I don&#39;t prefer this way, but someone<br>may like it. I think doing this may gain more problems than it solves. But<br>again, since it does not violate any documented rules, it could exist.<br></p><p>3. In both 1 and 2, we must also write `==` for each subclasses.<br></p><p>Zhaoxin<br></p><p>On Wed, Sep 7, 2016 at 5:55 AM, Lou Zell &lt;lzell11 at gmail.com&gt; wrote:<br></p><p>&gt; My question is, apple equals banana, but their hashValues (in their own<br>&gt;&gt; types)  don&#39;t. What&#39;s wrong here?<br>&gt;<br>&gt; ​<br>&gt; Hi Zhao.  In addition to what Jordan and Dmitri have said, I think part of<br>&gt; the confusion is that you are assuming hash values are implicitly used in<br>&gt; an equality check.  They are not.  They are used when your instances are<br>&gt; added to certain types of collections.<br>&gt;<br>&gt; In your first example, where you print out the hash values but then<br>&gt; compare lhs.name to rhs.name, the names of the two fruits are both<br>&gt; &quot;common fruit&quot;, and the equality test returns true.  Hash never comes into<br>&gt; play.  You can test for yourself when the hash gets used:<br>&gt;<br>&gt; import Foundation<br>&gt; class Foo: NSObject {<br>&gt;     override var hash: Int {<br>&gt;         print(&quot;Computing hash value!&quot;)<br>&gt;         return 1<br>&gt;     }<br>&gt; }<br>&gt; var f1 = Foo()<br>&gt; var f2 = Foo()<br>&gt; f1 == f2  // Doesn&#39;t print anything!<br>&gt; var aSet = Set&lt;Foo&gt;()<br>&gt; aSet.insert(f1)  // Prints &quot;Computing has value!&quot;<br>&gt;<br>&gt; Lou<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160907/9a8ac6ca/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
