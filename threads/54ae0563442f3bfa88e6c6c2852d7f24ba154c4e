<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1ce0c2f50b9e462c6b6a90bd38d698c9?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya</string> &lt;ilya at harmonicsense.com&gt;<p>December  6, 2015 at 04:00:00am</p></header><div class="content"><p>I think the it would help a great deal to have an access level modifier<br>that is really private and visible only inside the class itself. Right now,<br>the only way to hide implementation details for a class is to hide the<br>class code in a separate file, which is very inconvenient for several<br>reasons:<br></p><p>1) the meaning of the code changes depending on which file the class is in.<br>It&#39;s very easy to accidentally expose class internal details and then call<br>class elements that are meant to be used only inside the class. Having a<br>keyword for class internals will allow the compiler to ensure that only the<br>public API for the class is used from the outside world. The user can check<br>types on his own, but it&#39;s better that the compiler does it automatically.<br>Similarly, the user can check that only the proper APIs are called, but<br>it&#39;s better that the compiler does it automatically.<br></p><p>2) accessibility by file structure may cause some really short files.<br></p><p>3) It&#39;s impossible to group related classes in one file but still hide<br>implementation details inside each class<br></p><p>I think that it the best solution is to make private keyword do what it<br>states -- keep the class element private to the class. But if it&#39;s really<br>important to have a separate keyword for backward compatibility, it would<br>be the next best thing.<br></p><p>--<br>Ilya Belenkiy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/54ae4c4e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6e4479b6097e171f8f46de71f35764ba?s=50"></div><header><strong>access control proposal</strong> from <string>Nikolai Vazquez</string> &lt;nvazquez1297 at gmail.com&gt;<p>December  6, 2015 at 05:00:00am</p></header><div class="content"><p>I agree that there should be an access level that hides implementation<br>details from other types in the same file. However, it shouldn’t replace<br>private, because 1) helper types might benefit from private elements and 2)<br>like you said, backwards compatibility.<br></p><p>On Sat, Dec 5, 2015 at 11:40 PM Ilya via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>I think the it would help a great deal to have an access level modifier<br>&gt; that is really private and visible only inside the class itself. Right now,<br>&gt; the only way to hide implementation details for a class is to hide the<br>&gt; class code in a separate file, which is very inconvenient for several<br>&gt; reasons:<br>&gt;<br>&gt; 1) the meaning of the code changes depending on which file the class is<br>&gt; in. It&#39;s very easy to accidentally expose class internal details and then<br>&gt; call class elements that are meant to be used only inside the class. Having<br>&gt; a keyword for class internals will allow the compiler to ensure that only<br>&gt; the public API for the class is used from the outside world. The user can<br>&gt; check types on his own, but it&#39;s better that the compiler does it<br>&gt; automatically. Similarly, the user can check that only the proper APIs are<br>&gt; called, but it&#39;s better that the compiler does it automatically.<br>&gt;<br>&gt; 2) accessibility by file structure may cause some really short files.<br>&gt;<br>&gt; 3) It&#39;s impossible to group related classes in one file but still hide<br>&gt; implementation details inside each class<br>&gt;<br>&gt; I think that it the best solution is to make private keyword do what it<br>&gt; states -- keep the class element private to the class. But if it&#39;s really<br>&gt; important to have a separate keyword for backward compatibility, it would<br>&gt; be the next best thing.<br>&gt;<br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/eb13aee8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>access control proposal</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December  5, 2015 at 10:00:00pm</p></header><div class="content"><p>I tend to disagree with this whole concept of access modifiers; what we have today is at least somewhat sane and consistent across all constructs.<br></p><p>As for your example, if other code within your file is leveraging these “private” pieces, doesn’t that suggest that your API model is already wrong? After all, those pieces wouldn’t be used if they weren’t needed. I’m also hard pressed to believe that this is solving a problem that isn’t purely academic.<br></p><p>I’d actually prefer the opposite extreme: I want everything public unless it’s prefixed with an _. To me, the _ prefix adds significantly more contextual awareness that I’m venturing into parts of the construct that are not intended for general use. It has the add benefit that it makes these types of uses grepable within the codebase so audits are quite trivial.<br></p><p>    struct F {<br>        func _privateUsage() {}<br>        func publicUsage() {}<br>    }<br></p><p>Right now, I find having to prefix nearly everything with public is extremely annoying.<br></p><p>Humorously enough, I’m actually running into issues with this right now. I’m looking into fixing some of the NSNumber functionality in corelib and the fact that some of the internal state is marked as private means it’s not readably testable nor easy to inspect to validate is doing the right thing.<br></p><p>-David<br></p><p>&gt; On Dec 5, 2015, at 9:04 PM, Nikolai Vazquez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree that there should be an access level that hides implementation details from other types in the same file. However, it shouldn’t replace private, because 1) helper types might benefit from private elements and 2) like you said, backwards compatibility.<br>&gt; <br>&gt; On Sat, Dec 5, 2015 at 11:40 PM Ilya via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; I think the it would help a great deal to have an access level modifier that is really private and visible only inside the class itself. Right now, the only way to hide implementation details for a class is to hide the class code in a separate file, which is very inconvenient for several reasons:<br>&gt; <br>&gt; 1) the meaning of the code changes depending on which file the class is in. It&#39;s very easy to accidentally expose class internal details and then call class elements that are meant to be used only inside the class. Having a keyword for class internals will allow the compiler to ensure that only the public API for the class is used from the outside world. The user can check types on his own, but it&#39;s better that the compiler does it automatically. Similarly, the user can check that only the proper APIs are called, but it&#39;s better that the compiler does it automatically.<br>&gt; <br>&gt; 2) accessibility by file structure may cause some really short files. <br>&gt; <br>&gt; 3) It&#39;s impossible to group related classes in one file but still hide implementation details inside each class<br>&gt; <br>&gt; I think that it the best solution is to make private keyword do what it states -- keep the class element private to the class. But if it&#39;s really important to have a separate keyword for backward compatibility, it would be the next best thing.<br>&gt; <br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/57430d82/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>access control proposal</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  5, 2015 at 11:00:00pm</p></header><div class="content"><p>On Sat, Dec 5, 2015, at 10:59 PM, David Owens II via swift-evolution wrote:<br>&gt; I’d actually prefer the opposite extreme: I want everything public unless it’s prefixed with an _. To me, the _ prefix adds significantly more contextual awareness that I’m venturing into parts of the construct that are not intended for general use. It has the add benefit that it makes these types of uses grepable within the codebase so audits are quite trivial.<br></p><p>You can already use a _ prefix today to mark any function/property that<br>is not meant for general use, even within the confines of the file.<br>That&#39;s what I do; private methods/properties are fair game (if<br>accessible), but anything that&#39;s considered an implementation detail<br>gets a _ prefix. Applying your proposed rule would actually remove the<br>ability to use _ to distinguish things like this (and you&#39;d start seeing<br>__ instead, which is even uglier).<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/a01a6420/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>access control proposal</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  6, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 5, 2015, at 8:39 PM, Ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think the it would help a great deal to have an access level modifier that is really private and visible only inside the class itself. Right now, the only way to hide implementation details for a class is to hide the class code in a separate file, which is very inconvenient for several reasons:<br>&gt; <br>&gt; 1) the meaning of the code changes depending on which file the class is in. It&#39;s very easy to accidentally expose class internal details and then call class elements that are meant to be used only inside the class. Having a keyword for class internals will allow the compiler to ensure that only the public API for the class is used from the outside world. The user can check types on his own, but it&#39;s better that the compiler does it automatically. Similarly, the user can check that only the proper APIs are called, but it&#39;s better that the compiler does it automatically.<br>&gt; <br>&gt; 2) accessibility by file structure may cause some really short files. <br>&gt; <br>&gt; 3) It&#39;s impossible to group related classes in one file but still hide implementation details inside each class<br>&gt; <br>&gt; I think that it the best solution is to make private keyword do what it states -- keep the class element private to the class. But if it&#39;s really important to have a separate keyword for backward compatibility, it would be the next best thing.<br></p><p>But on the flip side, with your proposed semantics for private, it would be impossible to write a group of related types, functions, and extensions that do need to refer to each other’s internal details without exposing those details to the entire module.  That’s not really acceptable.<br></p><p>The Swift language rule encourages you to put independent definitions in different files.  That definitely means that, if you want to enforce very tight separation of concerns, you’ll end up with more and smaller files.  You haven’t explained why that’s really a *problem*, though.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1ce0c2f50b9e462c6b6a90bd38d698c9?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya</string> &lt;ilya at harmonicsense.com&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>My main proposal was not to change the semantics of private (although I<br>would like that) but to introduce a way to keep class implementation<br>details inaccessible to anything outside the class. I think that it should<br>still be possible and useful to have the current level of sharing (I would<br>just name it differently, given what private usually means in other<br>languages).<br></p><p>Just as it is convenient to group several related classes that can refer to<br>each other&#39;s implementation details, it is very convenient to have several<br>classes that don&#39;t do this but are still related in other important way,<br>for example related APIs or classes that are based on the same<br>implementation idea (like array based data structures).<br></p><p>Having all code in one place rather than jumping through many small files<br>is a very nice thing to have because it really helps to keep everything<br>consistent. The more manual work people have to do for consistency, the<br>more likelihood that it won&#39;t be done.<br></p><p>--<br>Ilya Belenkiy<br>On Mon, Dec 7, 2015 at 12:21 AM John McCall &lt;rjmccall at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Dec 5, 2015, at 8:39 PM, Ilya via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I think the it would help a great deal to have an access level modifier<br>&gt; that is really private and visible only inside the class itself. Right now,<br>&gt; the only way to hide implementation details for a class is to hide the<br>&gt; class code in a separate file, which is very inconvenient for several<br>&gt; reasons:<br>&gt; &gt;<br>&gt; &gt; 1) the meaning of the code changes depending on which file the class is<br>&gt; in. It&#39;s very easy to accidentally expose class internal details and then<br>&gt; call class elements that are meant to be used only inside the class. Having<br>&gt; a keyword for class internals will allow the compiler to ensure that only<br>&gt; the public API for the class is used from the outside world. The user can<br>&gt; check types on his own, but it&#39;s better that the compiler does it<br>&gt; automatically. Similarly, the user can check that only the proper APIs are<br>&gt; called, but it&#39;s better that the compiler does it automatically.<br>&gt; &gt;<br>&gt; &gt; 2) accessibility by file structure may cause some really short files.<br>&gt; &gt;<br>&gt; &gt; 3) It&#39;s impossible to group related classes in one file but still hide<br>&gt; implementation details inside each class<br>&gt; &gt;<br>&gt; &gt; I think that it the best solution is to make private keyword do what it<br>&gt; states -- keep the class element private to the class. But if it&#39;s really<br>&gt; important to have a separate keyword for backward compatibility, it would<br>&gt; be the next best thing.<br>&gt;<br>&gt; But on the flip side, with your proposed semantics for private, it would<br>&gt; be impossible to write a group of related types, functions, and extensions<br>&gt; that do need to refer to each other’s internal details without exposing<br>&gt; those details to the entire module.  That’s not really acceptable.<br>&gt;<br>&gt; The Swift language rule encourages you to put independent definitions in<br>&gt; different files.  That definitely means that, if you want to enforce very<br>&gt; tight separation of concerns, you’ll end up with more and smaller files.<br>&gt; You haven’t explained why that’s really a *problem*, though.<br>&gt;<br>&gt; John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/06516d3b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1ce0c2f50b9e462c6b6a90bd38d698c9?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya</string> &lt;ilya at harmonicsense.com&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>Also, one problem with the current approach is that it&#39;s all or nothing.<br>The classes in one file see everything from the other classes, and it may<br>be useful to limit that and share only some additional APIs with those<br>related classes, but not all of the implementation details / internal<br>state, while still hiding those same APIs from unrelated classes.<br>Currently, there is no way of doing it, even when splitting code into<br>separate files (the class state must be all in one place and can&#39;t be in an<br>extension).<br></p><p>--<br>Ilya Belenkiy<br>On Mon, Dec 7, 2015 at 8:17 AM Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br></p><p>&gt; My main proposal was not to change the semantics of private (although I<br>&gt; would like that) but to introduce a way to keep class implementation<br>&gt; details inaccessible to anything outside the class. I think that it should<br>&gt; still be possible and useful to have the current level of sharing (I would<br>&gt; just name it differently, given what private usually means in other<br>&gt; languages).<br>&gt;<br>&gt; Just as it is convenient to group several related classes that can refer<br>&gt; to each other&#39;s implementation details, it is very convenient to have<br>&gt; several classes that don&#39;t do this but are still related in other important<br>&gt; way, for example related APIs or classes that are based on the same<br>&gt; implementation idea (like array based data structures).<br>&gt;<br>&gt; Having all code in one place rather than jumping through many small files<br>&gt; is a very nice thing to have because it really helps to keep everything<br>&gt; consistent. The more manual work people have to do for consistency, the<br>&gt; more likelihood that it won&#39;t be done.<br>&gt;<br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt; On Mon, Dec 7, 2015 at 12:21 AM John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Dec 5, 2015, at 8:39 PM, Ilya via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think the it would help a great deal to have an access level modifier<br>&gt;&gt; that is really private and visible only inside the class itself. Right now,<br>&gt;&gt; the only way to hide implementation details for a class is to hide the<br>&gt;&gt; class code in a separate file, which is very inconvenient for several<br>&gt;&gt; reasons:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; 1) the meaning of the code changes depending on which file the class is<br>&gt;&gt; in. It&#39;s very easy to accidentally expose class internal details and then<br>&gt;&gt; call class elements that are meant to be used only inside the class. Having<br>&gt;&gt; a keyword for class internals will allow the compiler to ensure that only<br>&gt;&gt; the public API for the class is used from the outside world. The user can<br>&gt;&gt; check types on his own, but it&#39;s better that the compiler does it<br>&gt;&gt; automatically. Similarly, the user can check that only the proper APIs are<br>&gt;&gt; called, but it&#39;s better that the compiler does it automatically.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; 2) accessibility by file structure may cause some really short files.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; 3) It&#39;s impossible to group related classes in one file but still hide<br>&gt;&gt; implementation details inside each class<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think that it the best solution is to make private keyword do what it<br>&gt;&gt; states -- keep the class element private to the class. But if it&#39;s really<br>&gt;&gt; important to have a separate keyword for backward compatibility, it would<br>&gt;&gt; be the next best thing.<br>&gt;&gt;<br>&gt;&gt; But on the flip side, with your proposed semantics for private, it would<br>&gt;&gt; be impossible to write a group of related types, functions, and extensions<br>&gt;&gt; that do need to refer to each other’s internal details without exposing<br>&gt;&gt; those details to the entire module.  That’s not really acceptable.<br>&gt;&gt;<br>&gt;&gt; The Swift language rule encourages you to put independent definitions in<br>&gt;&gt; different files.  That definitely means that, if you want to enforce very<br>&gt;&gt; tight separation of concerns, you’ll end up with more and smaller files.<br>&gt;&gt; You haven’t explained why that’s really a *problem*, though.<br>&gt;&gt;<br>&gt;&gt; John.<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/ededf1b9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>access control proposal</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December  7, 2015 at 08:00:00am</p></header><div class="content"><p>If such an extra-private access-control level (`classified`?) existed, how would it be intended to behave in snippets like below?<br></p><p>    private class Example {<br>      classified var data: TopSecretData<br>    }<br></p><p>    extension Example: Equatable {<br>    }<br> <br>    func ==(lhs: Example, rhs: Example) -&gt; Bool {<br>      return lhs.data == rhs.data <br>      // ^ ??? possible or not?<br>    }<br></p><p>…(assuming the rest of the language largely behaves as-before).<br></p><p>When such `classified` properties behave like values you could perhaps declare them as `private classified(set) var` but that wouldn’t really add much safety when they behave like references.<br>&gt; On Dec 7, 2015, at 7:45 AM, Ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Also, one problem with the current approach is that it&#39;s all or nothing. The classes in one file see everything from the other classes, and it may be useful to limit that and share only some additional APIs with those related classes, but not all of the implementation details / internal state, while still hiding those same APIs from unrelated classes. Currently, there is no way of doing it, even when splitting code into separate files (the class state must be all in one place and can&#39;t be in an extension).<br>&gt; <br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt; On Mon, Dec 7, 2015 at 8:17 AM Ilya &lt;ilya at harmonicsense.com &lt;mailto:ilya at harmonicsense.com&gt;&gt; wrote:<br>&gt; My main proposal was not to change the semantics of private (although I would like that) but to introduce a way to keep class implementation details inaccessible to anything outside the class. I think that it should still be possible and useful to have the current level of sharing (I would just name it differently, given what private usually means in other languages).<br>&gt; <br>&gt; Just as it is convenient to group several related classes that can refer to each other&#39;s implementation details, it is very convenient to have several classes that don&#39;t do this but are still related in other important way, for example related APIs or classes that are based on the same implementation idea (like array based data structures).<br>&gt; <br>&gt; Having all code in one place rather than jumping through many small files is a very nice thing to have because it really helps to keep everything consistent. The more manual work people have to do for consistency, the more likelihood that it won&#39;t be done.<br>&gt; <br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt; On Mon, Dec 7, 2015 at 12:21 AM John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Dec 5, 2015, at 8:39 PM, Ilya via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I think the it would help a great deal to have an access level modifier that is really private and visible only inside the class itself. Right now, the only way to hide implementation details for a class is to hide the class code in a separate file, which is very inconvenient for several reasons:<br>&gt; &gt;<br>&gt; &gt; 1) the meaning of the code changes depending on which file the class is in. It&#39;s very easy to accidentally expose class internal details and then call class elements that are meant to be used only inside the class. Having a keyword for class internals will allow the compiler to ensure that only the public API for the class is used from the outside world. The user can check types on his own, but it&#39;s better that the compiler does it automatically. Similarly, the user can check that only the proper APIs are called, but it&#39;s better that the compiler does it automatically.<br>&gt; &gt;<br>&gt; &gt; 2) accessibility by file structure may cause some really short files.<br>&gt; &gt;<br>&gt; &gt; 3) It&#39;s impossible to group related classes in one file but still hide implementation details inside each class<br>&gt; &gt;<br>&gt; &gt; I think that it the best solution is to make private keyword do what it states -- keep the class element private to the class. But if it&#39;s really important to have a separate keyword for backward compatibility, it would be the next best thing.<br>&gt; <br>&gt; But on the flip side, with your proposed semantics for private, it would be impossible to write a group of related types, functions, and extensions that do need to refer to each other’s internal details without exposing those details to the entire module.  That’s not really acceptable.<br>&gt; <br>&gt; The Swift language rule encourages you to put independent definitions in different files.  That definitely means that, if you want to enforce very tight separation of concerns, you’ll end up with more and smaller files.  You haven’t explained why that’s really a *problem*, though.<br>&gt; <br>&gt; John.<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/33475549/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  7, 2015 at 08:00:00am</p></header><div class="content"><p>I was not sure how I felt about Swift&#39;s access control when it was first announced but it didn&#39;t take long for me to believe it strikes a pretty good balance between complexity and ability to hide implementation details.<br></p><p>It follows a very straightforward scope-driven strategy.  If it is extended further I would like to see any enhancements follow the same scope-driven strategy rather than being type-driven as is seen in other languages.  Proposals along these lines might be interesting to consider and might be able to accomplish what you are hoping to accomplish while affording additional flexibility.<br></p><p>In a language where distributing the implementation of a type across several extensions sometimes in different files a type-driven access control model doesn&#39;t make a lot of sense to me.  I think it has a lot of potential to be confusing.  <br></p><p>What would it mean to limit access to a member to the type itself in Swift?  Would an extensions in the same (or different) files be able to see the member?  What about extensions in a different module?  And what about subclasses? Subclasses probably wouldn&#39;t have visibility to them, but any discussion of something like this will probably lead to discussion of protected as well.<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 7, 2015, at 7:45 AM, Ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Also, one problem with the current approach is that it&#39;s all or nothing. The classes in one file see everything from the other classes, and it may be useful to limit that and share only some additional APIs with those related classes, but not all of the implementation details / internal state, while still hiding those same APIs from unrelated classes. Currently, there is no way of doing it, even when splitting code into separate files (the class state must be all in one place and can&#39;t be in an extension).<br>&gt; <br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt;&gt; On Mon, Dec 7, 2015 at 8:17 AM Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt; My main proposal was not to change the semantics of private (although I would like that) but to introduce a way to keep class implementation details inaccessible to anything outside the class. I think that it should still be possible and useful to have the current level of sharing (I would just name it differently, given what private usually means in other languages).<br>&gt;&gt; <br>&gt;&gt; Just as it is convenient to group several related classes that can refer to each other&#39;s implementation details, it is very convenient to have several classes that don&#39;t do this but are still related in other important way, for example related APIs or classes that are based on the same implementation idea (like array based data structures).<br>&gt;&gt; <br>&gt;&gt; Having all code in one place rather than jumping through many small files is a very nice thing to have because it really helps to keep everything consistent. The more manual work people have to do for consistency, the more likelihood that it won&#39;t be done.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt; On Mon, Dec 7, 2015 at 12:21 AM John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Dec 5, 2015, at 8:39 PM, Ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I think the it would help a great deal to have an access level modifier that is really private and visible only inside the class itself. Right now, the only way to hide implementation details for a class is to hide the class code in a separate file, which is very inconvenient for several reasons:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; 1) the meaning of the code changes depending on which file the class is in. It&#39;s very easy to accidentally expose class internal details and then call class elements that are meant to be used only inside the class. Having a keyword for class internals will allow the compiler to ensure that only the public API for the class is used from the outside world. The user can check types on his own, but it&#39;s better that the compiler does it automatically. Similarly, the user can check that only the proper APIs are called, but it&#39;s better that the compiler does it automatically.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; 2) accessibility by file structure may cause some really short files.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; 3) It&#39;s impossible to group related classes in one file but still hide implementation details inside each class<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I think that it the best solution is to make private keyword do what it states -- keep the class element private to the class. But if it&#39;s really important to have a separate keyword for backward compatibility, it would be the next best thing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But on the flip side, with your proposed semantics for private, it would be impossible to write a group of related types, functions, and extensions that do need to refer to each other’s internal details without exposing those details to the entire module.  That’s not really acceptable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The Swift language rule encourages you to put independent definitions in different files.  That definitely means that, if you want to enforce very tight separation of concerns, you’ll end up with more and smaller files.  You haven’t explained why that’s really a *problem*, though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/f23436e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1ce0c2f50b9e462c6b6a90bd38d698c9?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya</string> &lt;ilya at harmonicsense.com&gt;<p>December  7, 2015 at 05:00:00pm</p></header><div class="content"><p>If it is not allowed in extensions or subclasses (and it shouldn&#39;t), the<br>model is still very simple.<br></p><p>I understand the current model, but I think that there is a lot of value in<br>getting the compiler&#39;s help in ensuring that class internals cannot be<br>broken by anything outside the class.<br></p><p>The current model doesn&#39;t solve this problem well. Putting everything in<br>separate files seems like a very unfortunate workaround.<br></p><p>--<br>Ilya Belenkiy<br></p><p>On Mon, Dec 7, 2015 at 9:41 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; I was not sure how I felt about Swift&#39;s access control when it was first<br>&gt; announced but it didn&#39;t take long for me to believe it strikes a pretty<br>&gt; good balance between complexity and ability to hide implementation details.<br>&gt;<br>&gt; It follows a very straightforward scope-driven strategy.  If it is<br>&gt; extended further I would like to see any enhancements follow the same<br>&gt; scope-driven strategy rather than being type-driven as is seen in other<br>&gt; languages.  Proposals along these lines might be interesting to consider<br>&gt; and might be able to accomplish what you are hoping to accomplish while<br>&gt; affording additional flexibility.<br>&gt;<br>&gt; In a language where distributing the implementation of a type across<br>&gt; several extensions sometimes in different files a type-driven access<br>&gt; control model doesn&#39;t make a lot of sense to me.  I think it has a lot of<br>&gt; potential to be confusing.<br>&gt;<br>&gt; What would it mean to limit access to a member to the type itself in<br>&gt; Swift?  Would an extensions in the same (or different) files be able to see<br>&gt; the member?  What about extensions in a different module?  And what about<br>&gt; subclasses? Subclasses probably wouldn&#39;t have visibility to them, but any<br>&gt; discussion of something like this will probably lead to discussion of<br>&gt; protected as well.<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Dec 7, 2015, at 7:45 AM, Ilya via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Also, one problem with the current approach is that it&#39;s all or nothing.<br>&gt; The classes in one file see everything from the other classes, and it may<br>&gt; be useful to limit that and share only some additional APIs with those<br>&gt; related classes, but not all of the implementation details / internal<br>&gt; state, while still hiding those same APIs from unrelated classes.<br>&gt; Currently, there is no way of doing it, even when splitting code into<br>&gt; separate files (the class state must be all in one place and can&#39;t be in an<br>&gt; extension).<br>&gt;<br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt; On Mon, Dec 7, 2015 at 8:17 AM Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;<br>&gt;&gt; My main proposal was not to change the semantics of private (although I<br>&gt;&gt; would like that) but to introduce a way to keep class implementation<br>&gt;&gt; details inaccessible to anything outside the class. I think that it should<br>&gt;&gt; still be possible and useful to have the current level of sharing (I would<br>&gt;&gt; just name it differently, given what private usually means in other<br>&gt;&gt; languages).<br>&gt;&gt;<br>&gt;&gt; Just as it is convenient to group several related classes that can refer<br>&gt;&gt; to each other&#39;s implementation details, it is very convenient to have<br>&gt;&gt; several classes that don&#39;t do this but are still related in other important<br>&gt;&gt; way, for example related APIs or classes that are based on the same<br>&gt;&gt; implementation idea (like array based data structures).<br>&gt;&gt;<br>&gt;&gt; Having all code in one place rather than jumping through many small files<br>&gt;&gt; is a very nice thing to have because it really helps to keep everything<br>&gt;&gt; consistent. The more manual work people have to do for consistency, the<br>&gt;&gt; more likelihood that it won&#39;t be done.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Ilya Belenkiy<br>&gt;&gt; On Mon, Dec 7, 2015 at 12:21 AM John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Dec 5, 2015, at 8:39 PM, Ilya via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I think the it would help a great deal to have an access level<br>&gt;&gt;&gt; modifier that is really private and visible only inside the class itself.<br>&gt;&gt;&gt; Right now, the only way to hide implementation details for a class is to<br>&gt;&gt;&gt; hide the class code in a separate file, which is very inconvenient for<br>&gt;&gt;&gt; several reasons:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; 1) the meaning of the code changes depending on which file the class<br>&gt;&gt;&gt; is in. It&#39;s very easy to accidentally expose class internal details and<br>&gt;&gt;&gt; then call class elements that are meant to be used only inside the class.<br>&gt;&gt;&gt; Having a keyword for class internals will allow the compiler to ensure that<br>&gt;&gt;&gt; only the public API for the class is used from the outside world. The user<br>&gt;&gt;&gt; can check types on his own, but it&#39;s better that the compiler does it<br>&gt;&gt;&gt; automatically. Similarly, the user can check that only the proper APIs are<br>&gt;&gt;&gt; called, but it&#39;s better that the compiler does it automatically.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; 2) accessibility by file structure may cause some really short files.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; 3) It&#39;s impossible to group related classes in one file but still hide<br>&gt;&gt;&gt; implementation details inside each class<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I think that it the best solution is to make private keyword do what<br>&gt;&gt;&gt; it states -- keep the class element private to the class. But if it&#39;s<br>&gt;&gt;&gt; really important to have a separate keyword for backward compatibility, it<br>&gt;&gt;&gt; would be the next best thing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But on the flip side, with your proposed semantics for private, it would<br>&gt;&gt;&gt; be impossible to write a group of related types, functions, and extensions<br>&gt;&gt;&gt; that do need to refer to each other’s internal details without exposing<br>&gt;&gt;&gt; those details to the entire module.  That’s not really acceptable.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The Swift language rule encourages you to put independent definitions in<br>&gt;&gt;&gt; different files.  That definitely means that, if you want to enforce very<br>&gt;&gt;&gt; tight separation of concerns, you’ll end up with more and smaller files.<br>&gt;&gt;&gt; You haven’t explained why that’s really a *problem*, though.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; John.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/0b75ea8c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  7, 2015 at 12:00:00pm</p></header><div class="content"><p>I think what you are really trying to accomplish is to restrict access to a member to the scope in which it is declared, which just happens to be a type declaration.  <br></p><p>By looking at it in terms of scope the feature would be come more generally applicable.  For example, you could have a &#39;classified&#39; member in an extension which is only visible inside the body of the extension.  This would be useful if the extension contains helper methods as part of its implementation.<br></p><p>I would absolutely support extending Swift&#39;s scope-based access control to allow for more granular control of visibility within a file by extending it to syntactic scopes.  It seems like a pretty natural enhancement to the existing feature.<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 7, 2015, at 11:02 AM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt; <br>&gt; If it is not allowed in extensions or subclasses  (and it shouldn&#39;t), the model is still very simple.<br>&gt; <br>&gt; I understand the current model, but I think that there is a lot of value in getting the compiler&#39;s help in ensuring that class internals cannot be broken by anything outside the class.<br>&gt; <br>&gt; The current model doesn&#39;t solve this problem well. Putting everything in separate files seems like a very unfortunate workaround.<br>&gt; <br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt; <br>&gt;&gt; On Mon, Dec 7, 2015 at 9:41 AM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; I was not sure how I felt about Swift&#39;s access control when it was first announced but it didn&#39;t take long for me to believe it strikes a pretty good balance between complexity and ability to hide implementation details.<br>&gt;&gt; <br>&gt;&gt; It follows a very straightforward scope-driven strategy.  If it is extended further I would like to see any enhancements follow the same scope-driven strategy rather than being type-driven as is seen in other languages.  Proposals along these lines might be interesting to consider and might be able to accomplish what you are hoping to accomplish while affording additional flexibility.<br>&gt;&gt; <br>&gt;&gt; In a language where distributing the implementation of a type across several extensions sometimes in different files a type-driven access control model doesn&#39;t make a lot of sense to me.  I think it has a lot of potential to be confusing.  <br>&gt;&gt; <br>&gt;&gt; What would it mean to limit access to a member to the type itself in Swift?  Would an extensions in the same (or different) files be able to see the member?  What about extensions in a different module?  And what about subclasses? Subclasses probably wouldn&#39;t have visibility to them, but any discussion of something like this will probably lead to discussion of protected as well.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 7:45 AM, Ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Also, one problem with the current approach is that it&#39;s all or nothing. The classes in one file see everything from the other classes, and it may be useful to limit that and share only some additional APIs with those related classes, but not all of the implementation details / internal state, while still hiding those same APIs from unrelated classes. Currently, there is no way of doing it, even when splitting code into separate files (the class state must be all in one place and can&#39;t be in an extension).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 8:17 AM Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;&gt;&gt; My main proposal was not to change the semantics of private (although I would like that) but to introduce a way to keep class implementation details inaccessible to anything outside the class. I think that it should still be possible and useful to have the current level of sharing (I would just name it differently, given what private usually means in other languages).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just as it is convenient to group several related classes that can refer to each other&#39;s implementation details, it is very convenient to have several classes that don&#39;t do this but are still related in other important way, for example related APIs or classes that are based on the same implementation idea (like array based data structures).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Having all code in one place rather than jumping through many small files is a very nice thing to have because it really helps to keep everything consistent. The more manual work people have to do for consistency, the more likelihood that it won&#39;t be done.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 12:21 AM John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; On Dec 5, 2015, at 8:39 PM, Ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I think the it would help a great deal to have an access level modifier that is really private and visible only inside the class itself. Right now, the only way to hide implementation details for a class is to hide the class code in a separate file, which is very inconvenient for several reasons:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; 1) the meaning of the code changes depending on which file the class is in. It&#39;s very easy to accidentally expose class internal details and then call class elements that are meant to be used only inside the class. Having a keyword for class internals will allow the compiler to ensure that only the public API for the class is used from the outside world. The user can check types on his own, but it&#39;s better that the compiler does it automatically. Similarly, the user can check that only the proper APIs are called, but it&#39;s better that the compiler does it automatically.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; 2) accessibility by file structure may cause some really short files.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; 3) It&#39;s impossible to group related classes in one file but still hide implementation details inside each class<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I think that it the best solution is to make private keyword do what it states -- keep the class element private to the class. But if it&#39;s really important to have a separate keyword for backward compatibility, it would be the next best thing.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But on the flip side, with your proposed semantics for private, it would be impossible to write a group of related types, functions, and extensions that do need to refer to each other’s internal details without exposing those details to the entire module.  That’s not really acceptable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The Swift language rule encourages you to put independent definitions in different files.  That definitely means that, if you want to enforce very tight separation of concerns, you’ll end up with more and smaller files.  You haven’t explained why that’s really a *problem*, though.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/2438636a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1ce0c2f50b9e462c6b6a90bd38d698c9?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya</string> &lt;ilya at harmonicsense.com&gt;<p>December  7, 2015 at 07:00:00pm</p></header><div class="content"><p>Yes, that&#39;s a great idea!<br></p><p>--<br>Ilya Belenkiy<br>On Mon, Dec 7, 2015 at 1:35 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; I think what you are really trying to accomplish is to restrict access to<br>&gt; a member to the scope in which it is declared, which just happens to be a<br>&gt; type declaration.<br>&gt;<br>&gt; By looking at it in terms of scope the feature would be come more<br>&gt; generally applicable.  For example, you could have a &#39;classified&#39; member in<br>&gt; an extension which is only visible inside the body of the extension.  This<br>&gt; would be useful if the extension contains helper methods as part of its<br>&gt; implementation.<br>&gt;<br>&gt; I would absolutely support extending Swift&#39;s scope-based access control to<br>&gt; allow for more granular control of visibility within a file by extending it<br>&gt; to syntactic scopes.  It seems like a pretty natural enhancement to the<br>&gt; existing feature.<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Dec 7, 2015, at 11:02 AM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;<br>&gt; If it is not allowed in extensions or subclasses (and it shouldn&#39;t), the<br>&gt; model is still very simple.<br>&gt;<br>&gt; I understand the current model, but I think that there is a lot of value<br>&gt; in getting the compiler&#39;s help in ensuring that class internals cannot be<br>&gt; broken by anything outside the class.<br>&gt;<br>&gt; The current model doesn&#39;t solve this problem well. Putting everything in<br>&gt; separate files seems like a very unfortunate workaround.<br>&gt;<br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt;<br>&gt; On Mon, Dec 7, 2015 at 9:41 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I was not sure how I felt about Swift&#39;s access control when it was first<br>&gt;&gt; announced but it didn&#39;t take long for me to believe it strikes a pretty<br>&gt;&gt; good balance between complexity and ability to hide implementation details.<br>&gt;&gt;<br>&gt;&gt; It follows a very straightforward scope-driven strategy.  If it is<br>&gt;&gt; extended further I would like to see any enhancements follow the same<br>&gt;&gt; scope-driven strategy rather than being type-driven as is seen in other<br>&gt;&gt; languages.  Proposals along these lines might be interesting to consider<br>&gt;&gt; and might be able to accomplish what you are hoping to accomplish while<br>&gt;&gt; affording additional flexibility.<br>&gt;&gt;<br>&gt;&gt; In a language where distributing the implementation of a type across<br>&gt;&gt; several extensions sometimes in different files a type-driven access<br>&gt;&gt; control model doesn&#39;t make a lot of sense to me.  I think it has a lot of<br>&gt;&gt; potential to be confusing.<br>&gt;&gt;<br>&gt;&gt; What would it mean to limit access to a member to the type itself in<br>&gt;&gt; Swift?  Would an extensions in the same (or different) files be able to see<br>&gt;&gt; the member?  What about extensions in a different module?  And what about<br>&gt;&gt; subclasses? Subclasses probably wouldn&#39;t have visibility to them, but any<br>&gt;&gt; discussion of something like this will probably lead to discussion of<br>&gt;&gt; protected as well.<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Dec 7, 2015, at 7:45 AM, Ilya via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Also, one problem with the current approach is that it&#39;s all or nothing.<br>&gt;&gt; The classes in one file see everything from the other classes, and it may<br>&gt;&gt; be useful to limit that and share only some additional APIs with those<br>&gt;&gt; related classes, but not all of the implementation details / internal<br>&gt;&gt; state, while still hiding those same APIs from unrelated classes.<br>&gt;&gt; Currently, there is no way of doing it, even when splitting code into<br>&gt;&gt; separate files (the class state must be all in one place and can&#39;t be in an<br>&gt;&gt; extension).<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Ilya Belenkiy<br>&gt;&gt; On Mon, Dec 7, 2015 at 8:17 AM Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; My main proposal was not to change the semantics of private (although I<br>&gt;&gt;&gt; would like that) but to introduce a way to keep class implementation<br>&gt;&gt;&gt; details inaccessible to anything outside the class. I think that it should<br>&gt;&gt;&gt; still be possible and useful to have the current level of sharing (I would<br>&gt;&gt;&gt; just name it differently, given what private usually means in other<br>&gt;&gt;&gt; languages).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Just as it is convenient to group several related classes that can refer<br>&gt;&gt;&gt; to each other&#39;s implementation details, it is very convenient to have<br>&gt;&gt;&gt; several classes that don&#39;t do this but are still related in other important<br>&gt;&gt;&gt; way, for example related APIs or classes that are based on the same<br>&gt;&gt;&gt; implementation idea (like array based data structures).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Having all code in one place rather than jumping through many small<br>&gt;&gt;&gt; files is a very nice thing to have because it really helps to keep<br>&gt;&gt;&gt; everything consistent. The more manual work people have to do for<br>&gt;&gt;&gt; consistency, the more likelihood that it won&#39;t be done.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt; On Mon, Dec 7, 2015 at 12:21 AM John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On Dec 5, 2015, at 8:39 PM, Ilya via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I think the it would help a great deal to have an access level<br>&gt;&gt;&gt;&gt; modifier that is really private and visible only inside the class itself.<br>&gt;&gt;&gt;&gt; Right now, the only way to hide implementation details for a class is to<br>&gt;&gt;&gt;&gt; hide the class code in a separate file, which is very inconvenient for<br>&gt;&gt;&gt;&gt; several reasons:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; 1) the meaning of the code changes depending on which file the class<br>&gt;&gt;&gt;&gt; is in. It&#39;s very easy to accidentally expose class internal details and<br>&gt;&gt;&gt;&gt; then call class elements that are meant to be used only inside the class.<br>&gt;&gt;&gt;&gt; Having a keyword for class internals will allow the compiler to ensure that<br>&gt;&gt;&gt;&gt; only the public API for the class is used from the outside world. The user<br>&gt;&gt;&gt;&gt; can check types on his own, but it&#39;s better that the compiler does it<br>&gt;&gt;&gt;&gt; automatically. Similarly, the user can check that only the proper APIs are<br>&gt;&gt;&gt;&gt; called, but it&#39;s better that the compiler does it automatically.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; 2) accessibility by file structure may cause some really short files.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; 3) It&#39;s impossible to group related classes in one file but still<br>&gt;&gt;&gt;&gt; hide implementation details inside each class<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I think that it the best solution is to make private keyword do what<br>&gt;&gt;&gt;&gt; it states -- keep the class element private to the class. But if it&#39;s<br>&gt;&gt;&gt;&gt; really important to have a separate keyword for backward compatibility, it<br>&gt;&gt;&gt;&gt; would be the next best thing.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; But on the flip side, with your proposed semantics for private, it<br>&gt;&gt;&gt;&gt; would be impossible to write a group of related types, functions, and<br>&gt;&gt;&gt;&gt; extensions that do need to refer to each other’s internal details without<br>&gt;&gt;&gt;&gt; exposing those details to the entire module.  That’s not really acceptable.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The Swift language rule encourages you to put independent definitions<br>&gt;&gt;&gt;&gt; in different files.  That definitely means that, if you want to enforce<br>&gt;&gt;&gt;&gt; very tight separation of concerns, you’ll end up with more and smaller<br>&gt;&gt;&gt;&gt; files.  You haven’t explained why that’s really a *problem*, though.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/e2da395c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>Glad you like my reframing!  Is anyone planning to write a proposal for this?<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 7, 2015, at 1:00 PM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt; <br>&gt; Yes, that&#39;s a great idea!<br>&gt; <br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt;&gt; On Mon, Dec 7, 2015 at 1:35 PM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; I think what you are really trying to accomplish is to restrict access to a member to the scope in which it is declared, which just happens to be a type declaration.  <br>&gt;&gt; <br>&gt;&gt; By looking at it in terms of scope the feature would be come more generally applicable.  For example, you could have a &#39;classified&#39; member in an extension which is only visible inside the body of the extension.  This would be useful if the extension contains helper methods as part of its implementation.<br>&gt;&gt; <br>&gt;&gt; I would absolutely support extending Swift&#39;s scope-based access control to allow for more granular control of visibility within a file by extending it to syntactic scopes.  It seems like a pretty natural enhancement to the existing feature.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 11:02 AM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If it is not allowed in extensions or subclasses  (and it shouldn&#39;t), the model is still very simple.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I understand the current model, but I think that there is a lot of value in getting the compiler&#39;s help in ensuring that class internals cannot be broken by anything outside the class.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The current model doesn&#39;t solve this problem well. Putting everything in separate files seems like a very unfortunate workaround.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 9:41 AM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; I was not sure how I felt about Swift&#39;s access control when it was first announced but it didn&#39;t take long for me to believe it strikes a pretty good balance between complexity and ability to hide implementation details.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It follows a very straightforward scope-driven strategy.  If it is extended further I would like to see any enhancements follow the same scope-driven strategy rather than being type-driven as is seen in other languages.  Proposals along these lines might be interesting to consider and might be able to accomplish what you are hoping to accomplish while affording additional flexibility.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In a language where distributing the implementation of a type across several extensions sometimes in different files a type-driven access control model doesn&#39;t make a lot of sense to me.  I think it has a lot of potential to be confusing.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What would it mean to limit access to a member to the type itself in Swift?  Would an extensions in the same (or different) files be able to see the member?  What about extensions in a different module?  And what about subclasses? Subclasses probably wouldn&#39;t have visibility to them, but any discussion of something like this will probably lead to discussion of protected as well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 7, 2015, at 7:45 AM, Ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Also, one problem with the current approach is that it&#39;s all or nothing. The classes in one file see everything from the other classes, and it may be useful to limit that and share only some additional APIs with those related classes, but not all of the implementation details / internal state, while still hiding those same APIs from unrelated classes. Currently, there is no way of doing it, even when splitting code into separate files (the class state must be all in one place and can&#39;t be in an extension).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 8:17 AM Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; My main proposal was not to change the semantics of private (although I would like that) but to introduce a way to keep class implementation details inaccessible to anything outside the class. I think that it should still be possible and useful to have the current level of sharing (I would just name it differently, given what private usually means in other languages).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Just as it is convenient to group several related classes that can refer to each other&#39;s implementation details, it is very convenient to have several classes that don&#39;t do this but are still related in other important way, for example related APIs or classes that are based on the same implementation idea (like array based data structures).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Having all code in one place rather than jumping through many small files is a very nice thing to have because it really helps to keep everything consistent. The more manual work people have to do for consistency, the more likelihood that it won&#39;t be done.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 12:21 AM John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Dec 5, 2015, at 8:39 PM, Ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I think the it would help a great deal to have an access level modifier that is really private and visible only inside the class itself. Right now, the only way to hide implementation details for a class is to hide the class code in a separate file, which is very inconvenient for several reasons:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; 1) the meaning of the code changes depending on which file the class is in. It&#39;s very easy to accidentally expose class internal details and then call class elements that are meant to be used only inside the class. Having a keyword for class internals will allow the compiler to ensure that only the public API for the class is used from the outside world. The user can check types on his own, but it&#39;s better that the compiler does it automatically. Similarly, the user can check that only the proper APIs are called, but it&#39;s better that the compiler does it automatically.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; 2) accessibility by file structure may cause some really short files.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; 3) It&#39;s impossible to group related classes in one file but still hide implementation details inside each class<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I think that it the best solution is to make private keyword do what it states -- keep the class element private to the class. But if it&#39;s really important to have a separate keyword for backward compatibility, it would be the next best thing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But on the flip side, with your proposed semantics for private, it would be impossible to write a group of related types, functions, and extensions that do need to refer to each other’s internal details without exposing those details to the entire module.  That’s not really acceptable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The Swift language rule encourages you to put independent definitions in different files.  That definitely means that, if you want to enforce very tight separation of concerns, you’ll end up with more and smaller files.  You haven’t explained why that’s really a *problem*, though.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/7cc8243f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1ce0c2f50b9e462c6b6a90bd38d698c9?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya</string> &lt;ilya at harmonicsense.com&gt;<p>December  8, 2015 at 01:00:00pm</p></header><div class="content"><p>Hi Matthew,<br></p><p>Maybe you could write the proposal? I&#39;d be happy to do it, but it was your<br>idea. Also, I think that you will express it better.<br></p><p>--<br>Ilya Belenkiy<br>On Mon, Dec 7, 2015 at 2:11 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; Glad you like my reframing!  Is anyone planning to write a proposal for<br>&gt; this?<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Dec 7, 2015, at 1:00 PM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;<br>&gt; Yes, that&#39;s a great idea!<br>&gt;<br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt; On Mon, Dec 7, 2015 at 1:35 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I think what you are really trying to accomplish is to restrict access to<br>&gt;&gt; a member to the scope in which it is declared, which just happens to be a<br>&gt;&gt; type declaration.<br>&gt;&gt;<br>&gt;&gt; By looking at it in terms of scope the feature would be come more<br>&gt;&gt; generally applicable.  For example, you could have a &#39;classified&#39; member in<br>&gt;&gt; an extension which is only visible inside the body of the extension.  This<br>&gt;&gt; would be useful if the extension contains helper methods as part of its<br>&gt;&gt; implementation.<br>&gt;&gt;<br>&gt;&gt; I would absolutely support extending Swift&#39;s scope-based access control<br>&gt;&gt; to allow for more granular control of visibility within a file by extending<br>&gt;&gt; it to syntactic scopes.  It seems like a pretty natural enhancement to the<br>&gt;&gt; existing feature.<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Dec 7, 2015, at 11:02 AM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; If it is not allowed in extensions or subclasses (and it shouldn&#39;t), the<br>&gt;&gt; model is still very simple.<br>&gt;&gt;<br>&gt;&gt; I understand the current model, but I think that there is a lot of value<br>&gt;&gt; in getting the compiler&#39;s help in ensuring that class internals cannot be<br>&gt;&gt; broken by anything outside the class.<br>&gt;&gt;<br>&gt;&gt; The current model doesn&#39;t solve this problem well. Putting everything in<br>&gt;&gt; separate files seems like a very unfortunate workaround.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Ilya Belenkiy<br>&gt;&gt;<br>&gt;&gt; On Mon, Dec 7, 2015 at 9:41 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I was not sure how I felt about Swift&#39;s access control when it was first<br>&gt;&gt;&gt; announced but it didn&#39;t take long for me to believe it strikes a pretty<br>&gt;&gt;&gt; good balance between complexity and ability to hide implementation details.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It follows a very straightforward scope-driven strategy.  If it is<br>&gt;&gt;&gt; extended further I would like to see any enhancements follow the same<br>&gt;&gt;&gt; scope-driven strategy rather than being type-driven as is seen in other<br>&gt;&gt;&gt; languages.  Proposals along these lines might be interesting to consider<br>&gt;&gt;&gt; and might be able to accomplish what you are hoping to accomplish while<br>&gt;&gt;&gt; affording additional flexibility.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In a language where distributing the implementation of a type across<br>&gt;&gt;&gt; several extensions sometimes in different files a type-driven access<br>&gt;&gt;&gt; control model doesn&#39;t make a lot of sense to me.  I think it has a lot of<br>&gt;&gt;&gt; potential to be confusing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What would it mean to limit access to a member to the type itself in<br>&gt;&gt;&gt; Swift?  Would an extensions in the same (or different) files be able to see<br>&gt;&gt;&gt; the member?  What about extensions in a different module?  And what about<br>&gt;&gt;&gt; subclasses? Subclasses probably wouldn&#39;t have visibility to them, but any<br>&gt;&gt;&gt; discussion of something like this will probably lead to discussion of<br>&gt;&gt;&gt; protected as well.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 7, 2015, at 7:45 AM, Ilya via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Also, one problem with the current approach is that it&#39;s all or nothing.<br>&gt;&gt;&gt; The classes in one file see everything from the other classes, and it may<br>&gt;&gt;&gt; be useful to limit that and share only some additional APIs with those<br>&gt;&gt;&gt; related classes, but not all of the implementation details / internal<br>&gt;&gt;&gt; state, while still hiding those same APIs from unrelated classes.<br>&gt;&gt;&gt; Currently, there is no way of doing it, even when splitting code into<br>&gt;&gt;&gt; separate files (the class state must be all in one place and can&#39;t be in an<br>&gt;&gt;&gt; extension).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt; On Mon, Dec 7, 2015 at 8:17 AM Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; My main proposal was not to change the semantics of private (although I<br>&gt;&gt;&gt;&gt; would like that) but to introduce a way to keep class implementation<br>&gt;&gt;&gt;&gt; details inaccessible to anything outside the class. I think that it should<br>&gt;&gt;&gt;&gt; still be possible and useful to have the current level of sharing (I would<br>&gt;&gt;&gt;&gt; just name it differently, given what private usually means in other<br>&gt;&gt;&gt;&gt; languages).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Just as it is convenient to group several related classes that can<br>&gt;&gt;&gt;&gt; refer to each other&#39;s implementation details, it is very convenient to have<br>&gt;&gt;&gt;&gt; several classes that don&#39;t do this but are still related in other important<br>&gt;&gt;&gt;&gt; way, for example related APIs or classes that are based on the same<br>&gt;&gt;&gt;&gt; implementation idea (like array based data structures).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Having all code in one place rather than jumping through many small<br>&gt;&gt;&gt;&gt; files is a very nice thing to have because it really helps to keep<br>&gt;&gt;&gt;&gt; everything consistent. The more manual work people have to do for<br>&gt;&gt;&gt;&gt; consistency, the more likelihood that it won&#39;t be done.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 12:21 AM John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Dec 5, 2015, at 8:39 PM, Ilya via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I think the it would help a great deal to have an access level<br>&gt;&gt;&gt;&gt;&gt; modifier that is really private and visible only inside the class itself.<br>&gt;&gt;&gt;&gt;&gt; Right now, the only way to hide implementation details for a class is to<br>&gt;&gt;&gt;&gt;&gt; hide the class code in a separate file, which is very inconvenient for<br>&gt;&gt;&gt;&gt;&gt; several reasons:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; 1) the meaning of the code changes depending on which file the class<br>&gt;&gt;&gt;&gt;&gt; is in. It&#39;s very easy to accidentally expose class internal details and<br>&gt;&gt;&gt;&gt;&gt; then call class elements that are meant to be used only inside the class.<br>&gt;&gt;&gt;&gt;&gt; Having a keyword for class internals will allow the compiler to ensure that<br>&gt;&gt;&gt;&gt;&gt; only the public API for the class is used from the outside world. The user<br>&gt;&gt;&gt;&gt;&gt; can check types on his own, but it&#39;s better that the compiler does it<br>&gt;&gt;&gt;&gt;&gt; automatically. Similarly, the user can check that only the proper APIs are<br>&gt;&gt;&gt;&gt;&gt; called, but it&#39;s better that the compiler does it automatically.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; 2) accessibility by file structure may cause some really short files.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; 3) It&#39;s impossible to group related classes in one file but still<br>&gt;&gt;&gt;&gt;&gt; hide implementation details inside each class<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I think that it the best solution is to make private keyword do what<br>&gt;&gt;&gt;&gt;&gt; it states -- keep the class element private to the class. But if it&#39;s<br>&gt;&gt;&gt;&gt;&gt; really important to have a separate keyword for backward compatibility, it<br>&gt;&gt;&gt;&gt;&gt; would be the next best thing.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; But on the flip side, with your proposed semantics for private, it<br>&gt;&gt;&gt;&gt;&gt; would be impossible to write a group of related types, functions, and<br>&gt;&gt;&gt;&gt;&gt; extensions that do need to refer to each other’s internal details without<br>&gt;&gt;&gt;&gt;&gt; exposing those details to the entire module.  That’s not really acceptable.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The Swift language rule encourages you to put independent definitions<br>&gt;&gt;&gt;&gt;&gt; in different files.  That definitely means that, if you want to enforce<br>&gt;&gt;&gt;&gt;&gt; very tight separation of concerns, you’ll end up with more and smaller<br>&gt;&gt;&gt;&gt;&gt; files.  You haven’t explained why that’s really a *problem*, though.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/098243dd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  8, 2015 at 10:00:00am</p></header><div class="content"><p>I would be happy to do it, but I would like to know how broad the interest in exploring this is first, and especially whether this is something the core team is willing to consider for Swift 3 (depending on details of course).<br></p><p>Sent from my iPhone<br></p><p>&gt; On Dec 8, 2015, at 7:37 AM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt; <br>&gt; Hi Matthew,<br>&gt; <br>&gt; Maybe you could write the proposal? I&#39;d be happy to do it, but it was your idea. Also, I think that you will express it better.<br>&gt; <br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt;&gt; On Mon, Dec 7, 2015 at 2:11 PM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; Glad you like my reframing!  Is anyone planning to write a proposal for this?<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 1:00 PM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, that&#39;s a great idea!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 1:35 PM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; I think what you are really trying to accomplish is to restrict access to a member to the scope in which it is declared, which just happens to be a type declaration.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; By looking at it in terms of scope the feature would be come more generally applicable.  For example, you could have a &#39;classified&#39; member in an extension which is only visible inside the body of the extension.  This would be useful if the extension contains helper methods as part of its implementation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would absolutely support extending Swift&#39;s scope-based access control to allow for more granular control of visibility within a file by extending it to syntactic scopes.  It seems like a pretty natural enhancement to the existing feature.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 7, 2015, at 11:02 AM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If it is not allowed in extensions or subclasses  (and it shouldn&#39;t), the model is still very simple.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I understand the current model, but I think that there is a lot of value in getting the compiler&#39;s help in ensuring that class internals cannot be broken by anything outside the class.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The current model doesn&#39;t solve this problem well. Putting everything in separate files seems like a very unfortunate workaround.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 9:41 AM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; I was not sure how I felt about Swift&#39;s access control when it was first announced but it didn&#39;t take long for me to believe it strikes a pretty good balance between complexity and ability to hide implementation details.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It follows a very straightforward scope-driven strategy.  If it is extended further I would like to see any enhancements follow the same scope-driven strategy rather than being type-driven as is seen in other languages.  Proposals along these lines might be interesting to consider and might be able to accomplish what you are hoping to accomplish while affording additional flexibility.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In a language where distributing the implementation of a type across several extensions sometimes in different files a type-driven access control model doesn&#39;t make a lot of sense to me.  I think it has a lot of potential to be confusing.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What would it mean to limit access to a member to the type itself in Swift?  Would an extensions in the same (or different) files be able to see the member?  What about extensions in a different module?  And what about subclasses? Subclasses probably wouldn&#39;t have visibility to them, but any discussion of something like this will probably lead to discussion of protected as well.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 7, 2015, at 7:45 AM, Ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Also, one problem with the current approach is that it&#39;s all or nothing. The classes in one file see everything from the other classes, and it may be useful to limit that and share only some additional APIs with those related classes, but not all of the implementation details / internal state, while still hiding those same APIs from unrelated classes. Currently, there is no way of doing it, even when splitting code into separate files (the class state must be all in one place and can&#39;t be in an extension).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 8:17 AM Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My main proposal was not to change the semantics of private (although I would like that) but to introduce a way to keep class implementation details inaccessible to anything outside the class. I think that it should still be possible and useful to have the current level of sharing (I would just name it differently, given what private usually means in other languages).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just as it is convenient to group several related classes that can refer to each other&#39;s implementation details, it is very convenient to have several classes that don&#39;t do this but are still related in other important way, for example related APIs or classes that are based on the same implementation idea (like array based data structures).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Having all code in one place rather than jumping through many small files is a very nice thing to have because it really helps to keep everything consistent. The more manual work people have to do for consistency, the more likelihood that it won&#39;t be done.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 12:21 AM John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Dec 5, 2015, at 8:39 PM, Ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I think the it would help a great deal to have an access level modifier that is really private and visible only inside the class itself. Right now, the only way to hide implementation details for a class is to hide the class code in a separate file, which is very inconvenient for several reasons:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; 1) the meaning of the code changes depending on which file the class is in. It&#39;s very easy to accidentally expose class internal details and then call class elements that are meant to be used only inside the class. Having a keyword for class internals will allow the compiler to ensure that only the public API for the class is used from the outside world. The user can check types on his own, but it&#39;s better that the compiler does it automatically. Similarly, the user can check that only the proper APIs are called, but it&#39;s better that the compiler does it automatically.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; 2) accessibility by file structure may cause some really short files.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; 3) It&#39;s impossible to group related classes in one file but still hide implementation details inside each class<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I think that it the best solution is to make private keyword do what it states -- keep the class element private to the class. But if it&#39;s really important to have a separate keyword for backward compatibility, it would be the next best thing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But on the flip side, with your proposed semantics for private, it would be impossible to write a group of related types, functions, and extensions that do need to refer to each other’s internal details without exposing those details to the entire module.  That’s not really acceptable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The Swift language rule encourages you to put independent definitions in different files.  That definitely means that, if you want to enforce very tight separation of concerns, you’ll end up with more and smaller files.  You haven’t explained why that’s really a *problem*, though.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/9616fd90/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>access control proposal</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December  8, 2015 at 03:00:00pm</p></header><div class="content"><p>As the primary implementer of the Swift access model when it first went in, I don&#39;t think we need something like &quot;classified&quot;. The purpose of access control is to make sure implementation details stay hidden from other parts of the program. If you&#39;re in the same file, you&#39;re not in another part of the program. (If your files are big enough that you are in another part of the program, maybe you should split things up into more files.)<br></p><p>I am glad that you&#39;re not treating extensions as &quot;just part of the type&quot;. A lot of people say &quot;oh, of course my &#39;just for the type&#39; modifier allows extensions to see things&quot;, forgetting that extensions be added in any file in the program, including outside the module. You can even add extensions for the sole purpose of accessing these members, and therefore there&#39;s no protection at all.<br></p><p>This doesn&#39;t mean you can&#39;t submit a proposal officially to the swift-evolution repo, or even that it won&#39;t get reviewed. (I&#39;m not on the core team, and even core team members can be overruled by the rest of the team.) It just means I&#39;m against it. :-) I am glad people are thinking about it, though!<br></p><p>As for &quot;Swift 3&quot; specifically, I&#39;ll repeat Chris&#39;s canned message: the schedule for Swift 3 is already pretty full with our documented goals, so there&#39;s really no guarantee about what will or won&#39;t get engineering time for that release.<br></p><p>Best,<br>Jordan<br></p><p>&gt; On Dec 8, 2015, at 8:07, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would be happy to do it, but I would like to know how broad the interest in exploring this is first, and especially whether this is something the core team is willing to consider for Swift 3 (depending on details of course).<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Dec 8, 2015, at 7:37 AM, Ilya &lt;ilya at harmonicsense.com &lt;mailto:ilya at harmonicsense.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Hi Matthew,<br>&gt;&gt; <br>&gt;&gt; Maybe you could write the proposal? I&#39;d be happy to do it, but it was your idea. Also, I think that you will express it better.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Ilya Belenkiy<br>&gt;&gt; On Mon, Dec 7, 2015 at 2:11 PM Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; Glad you like my reframing!  Is anyone planning to write a proposal for this?<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On Dec 7, 2015, at 1:00 PM, Ilya &lt;ilya at harmonicsense.com &lt;mailto:ilya at harmonicsense.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Yes, that&#39;s a great idea!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt; On Mon, Dec 7, 2015 at 1:35 PM Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I think what you are really trying to accomplish is to restrict access to a member to the scope in which it is declared, which just happens to be a type declaration.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By looking at it in terms of scope the feature would be come more generally applicable.  For example, you could have a &#39;classified&#39; member in an extension which is only visible inside the body of the extension.  This would be useful if the extension contains helper methods as part of its implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would absolutely support extending Swift&#39;s scope-based access control to allow for more granular control of visibility within a file by extending it to syntactic scopes.  It seems like a pretty natural enhancement to the existing feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 11:02 AM, Ilya &lt;ilya at harmonicsense.com &lt;mailto:ilya at harmonicsense.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If it is not allowed in extensions or subclasses  (and it shouldn&#39;t), the model is still very simple.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I understand the current model, but I think that there is a lot of value in getting the compiler&#39;s help in ensuring that class internals cannot be broken by anything outside the class.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The current model doesn&#39;t solve this problem well. Putting everything in separate files seems like a very unfortunate workaround.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 9:41 AM Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; I was not sure how I felt about Swift&#39;s access control when it was first announced but it didn&#39;t take long for me to believe it strikes a pretty good balance between complexity and ability to hide implementation details.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It follows a very straightforward scope-driven strategy.  If it is extended further I would like to see any enhancements follow the same scope-driven strategy rather than being type-driven as is seen in other languages.  Proposals along these lines might be interesting to consider and might be able to accomplish what you are hoping to accomplish while affording additional flexibility.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In a language where distributing the implementation of a type across several extensions sometimes in different files a type-driven access control model doesn&#39;t make a lot of sense to me.  I think it has a lot of potential to be confusing.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What would it mean to limit access to a member to the type itself in Swift?  Would an extensions in the same (or different) files be able to see the member?  What about extensions in a different module?  And what about subclasses? Subclasses probably wouldn&#39;t have visibility to them, but any discussion of something like this will probably lead to discussion of protected as well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 7:45 AM, Ilya via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Also, one problem with the current approach is that it&#39;s all or nothing. The classes in one file see everything from the other classes, and it may be useful to limit that and share only some additional APIs with those related classes, but not all of the implementation details / internal state, while still hiding those same APIs from unrelated classes. Currently, there is no way of doing it, even when splitting code into separate files (the class state must be all in one place and can&#39;t be in an extension).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 8:17 AM Ilya &lt;ilya at harmonicsense.com &lt;mailto:ilya at harmonicsense.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; My main proposal was not to change the semantics of private (although I would like that) but to introduce a way to keep class implementation details inaccessible to anything outside the class. I think that it should still be possible and useful to have the current level of sharing (I would just name it differently, given what private usually means in other languages).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Just as it is convenient to group several related classes that can refer to each other&#39;s implementation details, it is very convenient to have several classes that don&#39;t do this but are still related in other important way, for example related APIs or classes that are based on the same implementation idea (like array based data structures).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Having all code in one place rather than jumping through many small files is a very nice thing to have because it really helps to keep everything consistent. The more manual work people have to do for consistency, the more likelihood that it won&#39;t be done.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 12:21 AM John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; On Dec 5, 2015, at 8:39 PM, Ilya via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I think the it would help a great deal to have an access level modifier that is really private and visible only inside the class itself. Right now, the only way to hide implementation details for a class is to hide the class code in a separate file, which is very inconvenient for several reasons:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; 1) the meaning of the code changes depending on which file the class is in. It&#39;s very easy to accidentally expose class internal details and then call class elements that are meant to be used only inside the class. Having a keyword for class internals will allow the compiler to ensure that only the public API for the class is used from the outside world. The user can check types on his own, but it&#39;s better that the compiler does it automatically. Similarly, the user can check that only the proper APIs are called, but it&#39;s better that the compiler does it automatically.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; 2) accessibility by file structure may cause some really short files.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; 3) It&#39;s impossible to group related classes in one file but still hide implementation details inside each class<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I think that it the best solution is to make private keyword do what it states -- keep the class element private to the class. But if it&#39;s really important to have a separate keyword for backward compatibility, it would be the next best thing.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But on the flip side, with your proposed semantics for private, it would be impossible to write a group of related types, functions, and extensions that do need to refer to each other’s internal details without exposing those details to the entire module.  That’s not really acceptable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The Swift language rule encourages you to put independent definitions in different files.  That definitely means that, if you want to enforce very tight separation of concerns, you’ll end up with more and smaller files.  You haven’t explained why that’s really a *problem*, though.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/7acbdbbe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>Proposal: remove &quot;assert&quot; and always use &quot;precondition&quot; instead.</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>December  8, 2015 at 06:00:00pm</p></header><div class="content"><p>Swift is a safe language after all. Moreover, it is all too easy to accidentally type “assert” when you mean “precondition”.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>Proposal: remove &quot;assert&quot; and always use &quot;precondition&quot; instead.</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>December  9, 2015 at 12:00:00am</p></header><div class="content"><p>Strong -1, `assert` is a great tool for catching programmer errors in development phase, without compromising the stability in release mode.<br></p><p>Pozdrawiam – Regards,<br>Adrian Kashivskyy<br></p><p>&gt; Wiadomość napisana przez Amir Michail via swift-evolution &lt;swift-evolution at swift.org&gt; w dniu 09.12.2015, o godz. 00:52:<br>&gt; <br>&gt; Swift is a safe language after all. Moreover, it is all too easy to accidentally type “assert” when you mean “precondition”.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/c2895b27/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>Proposal: remove &quot;assert&quot; and always use &quot;precondition&quot; instead.</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>December  8, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 6:55 PM, Adrian Kashivskyy &lt;adrian.kashivskyy at me.com&gt; wrote:<br>&gt; <br>&gt; Strong -1, `assert` is a great tool for catching programmer errors in development phase, without compromising the stability in release mode.<br></p><p>You would rather have an ill-defined state rather than a crash with a useful bug report?<br></p><p>&gt; <br>&gt; Pozdrawiam – Regards,<br>&gt; Adrian Kashivskyy<br>&gt; <br>&gt;&gt; Wiadomość napisana przez Amir Michail via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; w dniu 09.12.2015, o godz. 00:52:<br>&gt;&gt; <br>&gt;&gt; Swift is a safe language after all. Moreover, it is all too easy to accidentally type “assert” when you mean “precondition”.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/e1f07580/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>Proposal: remove &quot;assert&quot; and always use &quot;precondition&quot; instead.</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>December  9, 2015 at 12:00:00am</p></header><div class="content"><p>That&#39;s a choice I would have to carefully make when designing the behavior. Not all asserts are non-recoverable.<br></p><p>Pozdrawiam – Regards,<br>Adrian Kashivskyy<br></p><p>&gt; Wiadomość napisana przez Amir Michail &lt;a.michail at me.com&gt; w dniu 09.12.2015, o godz. 00:56:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 6:55 PM, Adrian Kashivskyy &lt;adrian.kashivskyy at me.com &lt;mailto:adrian.kashivskyy at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Strong -1, `assert` is a great tool for catching programmer errors in development phase, without compromising the stability in release mode.<br>&gt; <br>&gt; You would rather have an ill-defined state rather than a crash with a useful bug report?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Pozdrawiam – Regards,<br>&gt;&gt; Adrian Kashivskyy<br>&gt;&gt; <br>&gt;&gt;&gt; Wiadomość napisana przez Amir Michail via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; w dniu 09.12.2015, o godz. 00:52:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift is a safe language after all. Moreover, it is all too easy to accidentally type “assert” when you mean “precondition”.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/07e0969b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>Proposal: remove &quot;assert&quot; and always use &quot;precondition&quot; instead.</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>December  8, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 6:59 PM, Adrian Kashivskyy &lt;adrian.kashivskyy at me.com&gt; wrote:<br>&gt; <br>&gt; That&#39;s a choice I would have to carefully make when designing the behavior. Not all asserts are non-recoverable.<br>&gt; <br></p><p>You could have precondition raise an exception so you can catch it if you really want to.<br></p><p>&gt; Pozdrawiam – Regards,<br>&gt; Adrian Kashivskyy<br>&gt; <br>&gt;&gt; Wiadomość napisana przez Amir Michail &lt;a.michail at me.com &lt;mailto:a.michail at me.com&gt;&gt; w dniu 09.12.2015, o godz. 00:56:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 8, 2015, at 6:55 PM, Adrian Kashivskyy &lt;adrian.kashivskyy at me.com &lt;mailto:adrian.kashivskyy at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Strong -1, `assert` is a great tool for catching programmer errors in development phase, without compromising the stability in release mode.<br>&gt;&gt; <br>&gt;&gt; You would rather have an ill-defined state rather than a crash with a useful bug report?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Pozdrawiam – Regards,<br>&gt;&gt;&gt; Adrian Kashivskyy<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Wiadomość napisana przez Amir Michail via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; w dniu 09.12.2015, o godz. 00:52:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift is a safe language after all. Moreover, it is all too easy to accidentally type “assert” when you mean “precondition”.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/e6bafaf7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>Proposal: remove &quot;assert&quot; and always use &quot;precondition&quot; instead.</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>December  9, 2015 at 01:00:00am</p></header><div class="content"><p>&gt; raise an exception<br></p><p>throw an error*<br></p><p>–<br></p><p>Or you could take advantage of powerful type system and error handling mechanisms and use neither `assert` nor `precondition`. Swift has so many features which ensure safety that using assertions is the last thing you could possibly lean towards – and I think that the flexibility to differentiate between `assert` and `precondition` is a precious choice to have, especially in high-performance code.<br></p><p><br>Pozdrawiam – Regards,<br>Adrian Kashivskyy<br></p><p>&gt; Wiadomość napisana przez Amir Michail &lt;a.michail at me.com&gt; w dniu 09.12.2015, o godz. 01:00:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 6:59 PM, Adrian Kashivskyy &lt;adrian.kashivskyy at me.com &lt;mailto:adrian.kashivskyy at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That&#39;s a choice I would have to carefully make when designing the behavior. Not all asserts are non-recoverable.<br>&gt;&gt; <br>&gt; <br>&gt; You could have precondition raise an exception so you can catch it if you really want to.<br>&gt; <br>&gt;&gt; Pozdrawiam – Regards,<br>&gt;&gt; Adrian Kashivskyy<br>&gt;&gt; <br>&gt;&gt;&gt; Wiadomość napisana przez Amir Michail &lt;a.michail at me.com &lt;mailto:a.michail at me.com&gt;&gt; w dniu 09.12.2015, o godz. 00:56:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 8, 2015, at 6:55 PM, Adrian Kashivskyy &lt;adrian.kashivskyy at me.com &lt;mailto:adrian.kashivskyy at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Strong -1, `assert` is a great tool for catching programmer errors in development phase, without compromising the stability in release mode.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You would rather have an ill-defined state rather than a crash with a useful bug report?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Pozdrawiam – Regards,<br>&gt;&gt;&gt;&gt; Adrian Kashivskyy<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Wiadomość napisana przez Amir Michail via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; w dniu 09.12.2015, o godz. 00:52:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift is a safe language after all. Moreover, it is all too easy to accidentally type “assert” when you mean “precondition”.<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/020aefdc/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: remove &quot;assert&quot; and always use &quot;precondition&quot; instead.</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 14, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 3:52 PM, Amir Michail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift is a safe language after all. Moreover, it is all too easy to accidentally type “assert” when you mean “precondition”.<br></p><p>Here’s some rationale that may be missing.  The two functions have distinct roles:<br></p><p>- assert: checking your own code for internal errors.<br>- precondition: for checking that your clients have given you valid arguments.<br></p><p>It’s actually important to distinguish these two cases because the second one demands public documentation while the first does not.<br></p><p>For example: in Swift’s standard library we promise never to allow memory errors unless you call (Obj)C code or use an explicitly labeled “unsafe” construct.  On the occasions where we need to do a check on the client’s parameters to avoid causing a memory error when we’re given invalid arguments, we document the requirements on the arguments as a precondition, and use (our equivalent of) precondition() to check it.  We also have a bunch of internal sanity checks to make sure our assumptions about our own code, where the type system doesn’t already guarantee them, are correct.  For those, we use (our equivalent of) assert(), because we don’t want to slow down *your* code as an artifact of our development process (the use of sanity checks).<br></p><p>Here are a couple of concrete examples:<br></p><p>/// A collection whose elements are all identical `Element`s.<br>public struct Repeat&lt;Element&gt; : CollectionType {<br>  ...<br>  /// Access the element at `position`.<br>  ///<br>  /// - Requires: `position` is a valid position in `self` and<br>  ///   `position != endIndex`.<br>  public subscript(position: Int) -&gt; Element {<br>    _precondition(position &gt;= 0 &amp;&amp; position &lt; count, &quot;Index out of range&quot;)<br>    return repeatedValue<br>  }<br>}<br></p><p>extension String.UTF8View {<br>  ...<br></p><p>  private func _encodeSomeContiguousUTF16AsUTF8(i: Int) -&gt; (Int, UTF8Chunk) {<br>    _sanityCheck(elementWidth == 2)<br>    _sanityCheck(!_baseAddress._isNull)<br></p><p>    let storage = UnsafeBufferPointer(start: startUTF16, count: self.count)<br>    return _transcodeSomeUTF16AsUTF8(storage, i)<br>  }<br>}<br></p><p>In the first example, we have a precondition that the client doesn’t index past the end of the collection.  In this case we’re not strictly bound to check it because we’re not avoiding a memory error,* but we do check it as a service to our clients; it will help them find their bugs sooner.<br></p><p>In the second example, this is a private function that is meant to be called only on a code path where we’ve ensured elementWidth == 2 and _baseAddress is not null (_sanityCheck is the stdlib’s equivalent of assert).  That is in fact how it is being used, but we want to ensure that ongoingly.  For example, we don’t want someone to add code later that uses it incorrectly. Since we run our tests in both debug and release and we have decent test coverage, the assertions are very likely to fire if that should happen.<br></p><p>You might think from the above that assert() only gets used in private methods and precondition() only gets used in public methods, but that’s not the case; you could inline any private method into the body of the public method it implements, and doing sanity checks there would still make sense.  Precondition checks occasionally appear in private methods, too.  The simplest example is where duplicated precondition checking code is factored out of a bunch of public methods and into a single private helper. <br></p><p>Hope this helps,<br>Dave<br></p><p>*  Note that some preconditions actually can’t be checked, so having a rule that all preconditions must be checked isn’t tenable.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/a1cc1b3b/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Proposal: remove &quot;assert&quot; and always use &quot;precondition&quot; instead.</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 15, 2015 at 04:00:00am</p></header><div class="content"><p>&gt; Here’s some rationale that may be missing.  The two functions have distinct roles:<br>&gt; <br>&gt; - assert: checking your own code for internal errors.<br>&gt; - precondition: for checking that your clients have given you valid arguments.<br></p><p>Makes sense.<br></p><p>I think the issue here is that for many people who write just plain apps, the following holds true:<br></p><p>1) assert performance is not a concern<br></p><p>2) asserts are used to prevent something terrible from happening<br></p><p>3) the most interesting bugs happen inside the code (where assert is appropriate), not on module/layer/class boundaries<br></p><p>Given #1 and #2, we&#39;d prefer to be able to write asserts that can guarantee that the asserted condition never happens below the assertion point.<br></p><p>Why not distinguish between them via assert? and assert!, with &quot;assert?&quot; highlighting the fact that execution may continue in some cases, and &quot;assert!&quot; highlighting the fact that it will always crash?<br></p><p>That would be beneficial when reading other people&#39;s code, because it&#39;ll show whether they assume that the subsequent code doesn&#39;t need to deal with the asserted condition.<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>Proposal: remove &quot;assert&quot; and always use &quot;precondition&quot; instead.</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>December 14, 2015 at 06:00:00pm</p></header><div class="content"><p>What about these renamings?<br></p><p>assert =&gt; debugAssert<br></p><p>precondition =&gt; assert<br></p><p>&gt; On Dec 14, 2015, at 5:48 PM, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt; <br>&gt;&gt; Here’s some rationale that may be missing.  The two functions have distinct roles:<br>&gt;&gt; <br>&gt;&gt; - assert: checking your own code for internal errors.<br>&gt;&gt; - precondition: for checking that your clients have given you valid arguments.<br>&gt; <br>&gt; Makes sense.<br>&gt; <br>&gt; I think the issue here is that for many people who write just plain apps, the following holds true:<br>&gt; <br>&gt; 1) assert performance is not a concern<br>&gt; <br>&gt; 2) asserts are used to prevent something terrible from happening<br>&gt; <br>&gt; 3) the most interesting bugs happen inside the code (where assert is appropriate), not on module/layer/class boundaries<br>&gt; <br>&gt; Given #1 and #2, we&#39;d prefer to be able to write asserts that can guarantee that the asserted condition never happens below the assertion point.<br>&gt; <br>&gt; Why not distinguish between them via assert? and assert!, with &quot;assert?&quot; highlighting the fact that execution may continue in some cases, and &quot;assert!&quot; highlighting the fact that it will always crash?<br>&gt; <br>&gt; That would be beneficial when reading other people&#39;s code, because it&#39;ll show whether they assume that the subsequent code doesn&#39;t need to deal with the asserted condition.<br>&gt; <br>&gt; A.<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Proposal: remove &quot;assert&quot; and always use &quot;precondition&quot; instead.</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 15, 2015 at 05:00:00am</p></header><div class="content"><p>Is it better than:<br></p><p>assert =&gt; assert?<br></p><p>precondition =&gt; assert!<br></p><p>?<br></p><p><br></p><p>&gt; On Dec 15, 2015, at 5:01 AM, Amir Michail &lt;a.michail at me.com&gt; wrote:<br>&gt; <br>&gt; What about these renamings?<br>&gt; <br>&gt; assert =&gt; debugAssert<br>&gt; <br>&gt; precondition =&gt; assert<br>&gt; <br>&gt;&gt; On Dec 14, 2015, at 5:48 PM, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Here’s some rationale that may be missing.  The two functions have distinct roles:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - assert: checking your own code for internal errors.<br>&gt;&gt;&gt; - precondition: for checking that your clients have given you valid arguments.<br>&gt;&gt; <br>&gt;&gt; Makes sense.<br>&gt;&gt; <br>&gt;&gt; I think the issue here is that for many people who write just plain apps, the following holds true:<br>&gt;&gt; <br>&gt;&gt; 1) assert performance is not a concern<br>&gt;&gt; <br>&gt;&gt; 2) asserts are used to prevent something terrible from happening<br>&gt;&gt; <br>&gt;&gt; 3) the most interesting bugs happen inside the code (where assert is appropriate), not on module/layer/class boundaries<br>&gt;&gt; <br>&gt;&gt; Given #1 and #2, we&#39;d prefer to be able to write asserts that can guarantee that the asserted condition never happens below the assertion point.<br>&gt;&gt; <br>&gt;&gt; Why not distinguish between them via assert? and assert!, with &quot;assert?&quot; highlighting the fact that execution may continue in some cases, and &quot;assert!&quot; highlighting the fact that it will always crash?<br>&gt;&gt; <br>&gt;&gt; That would be beneficial when reading other people&#39;s code, because it&#39;ll show whether they assume that the subsequent code doesn&#39;t need to deal with the asserted condition.<br>&gt;&gt; <br>&gt;&gt; A.<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>Proposal: remove &quot;assert&quot; and always use &quot;precondition&quot; instead.</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>December 14, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 6:01 PM, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt; <br>&gt; Is it better than:<br>&gt; <br>&gt; assert =&gt; assert?<br>&gt; <br>&gt; precondition =&gt; assert!<br>&gt; <br>&gt; ?<br>&gt; <br></p><p>I think so since ? and ! typically mean something different in Swift.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 5:01 AM, Amir Michail &lt;a.michail at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What about these renamings?<br>&gt;&gt; <br>&gt;&gt; assert =&gt; debugAssert<br>&gt;&gt; <br>&gt;&gt; precondition =&gt; assert<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 14, 2015, at 5:48 PM, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here’s some rationale that may be missing.  The two functions have distinct roles:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - assert: checking your own code for internal errors.<br>&gt;&gt;&gt;&gt; - precondition: for checking that your clients have given you valid arguments.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Makes sense.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the issue here is that for many people who write just plain apps, the following holds true:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) assert performance is not a concern<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2) asserts are used to prevent something terrible from happening<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3) the most interesting bugs happen inside the code (where assert is appropriate), not on module/layer/class boundaries<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given #1 and #2, we&#39;d prefer to be able to write asserts that can guarantee that the asserted condition never happens below the assertion point.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why not distinguish between them via assert? and assert!, with &quot;assert?&quot; highlighting the fact that execution may continue in some cases, and &quot;assert!&quot; highlighting the fact that it will always crash?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That would be beneficial when reading other people&#39;s code, because it&#39;ll show whether they assume that the subsequent code doesn&#39;t need to deal with the asserted condition.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0dc888223edca1a08d633bcaaa3f066f?s=50"></div><header><strong>Proposal: remove &quot;assert&quot; and always use &quot;precondition&quot; instead.</strong> from <string>sune.foldager at me.com</string> &lt;sune.foldager at me.com&gt;<p>December 15, 2015 at 12:00:00am</p></header><div class="content"><p>&gt; On 15 Dec 2015, at 00:01, Amir Michail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What about these renamings?<br>&gt; <br>&gt; assert =&gt; debugAssert<br>&gt; <br>&gt; precondition =&gt; assert<br></p><p>I think precondition is a better name because it clearly expresses that this is an expected precondition for calling the method. Precondition is similar to Microsoft code contract’s Contract.Requires.<br></p><p>Also, the traditional use of assert (also in other languages) is for guarding against your own programmer errors, which I think most people expect when they see assert. It may be useful for an assert that’s still active in optimised builds, true. I guess that could be called assert! or assertAlways.<br></p><p>-Sune<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1ce0c2f50b9e462c6b6a90bd38d698c9?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya</string> &lt;ilya at harmonicsense.com&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>Hi Jordan,<br></p><p>Thank you, I understand your reasoning. The current model is simple to<br>describe and implement. It’s a good solution for access control across<br>modules. That being said, it doesn’t solve the problem of hiding<br>implementation details at a smaller scale, which is also important. The<br>suggestion to put each class (or part of the class) in a separate file<br>works for large pieces of code but isn’t practical for smaller pieces. An<br>analogy: putting each chapter of a book into a separate file makes sense<br>but putting every paragraph in a separate file does not.<br></p><p>I think that Matthew had a great idea: add a scope based access control.<br>Swift already has some support for it: local functions. I actually use it a<br>lot and put functions into other functions to hide implementation details.<br>It’s not possible to use it everywhere, but when it is possible, it’s<br>great. If we could have a “local” access modifier that limited the entity<br>only to the scope in which it’s defined, that would allow much less<br>nesting, and it would make it possible to hide many more code.structures.<br></p><p>For me, hiding implementation details is a fundamental feature of the<br>language / compiler. It is possible to get by without it with coding by<br>convention, but it’s also possible to get by without a strong type system.<br>Having a way to hide implementation details that is enforced by the<br>language will help to have clearly defined interfaces and limit hacks and<br>mistakes for misusing APIs that are meant to be private.<br></p><p>I appreciate what you said about an official proposal. I’ll ask Matthew<br>again (since access by scope was his idea). If he is not up to it, I’ll<br>submit a proposal myself. For me, this issue was one of the driving forces<br>to join the mailing list.<br></p><p>—<br>Ilya Belenkiy<br></p><p>On Dec 8, 2015, at 6:49 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>As the primary implementer of the Swift access model when it first went in,<br>I don&#39;t think we need something like &quot;classified&quot;. The purpose of access<br>control is to make sure implementation details stay hidden from other parts<br>of the program. If you&#39;re in the same file, you&#39;re not in another part of<br>the program. (If your files are big enough that you *are* in another part<br>of the program, maybe you should split things up into more files.)<br></p><p>I *am* glad that you&#39;re not treating extensions as &quot;just part of the type&quot;.<br>A lot of people say &quot;oh, of course my &#39;just for the type&#39; modifier allows<br>extensions to see things&quot;, forgetting that extensions be added in any file<br>in the program, including outside the module. You can even add extensions<br>for the sole purpose of accessing these members, and therefore there&#39;s no<br>protection at all.<br></p><p>This doesn&#39;t mean you can&#39;t submit a proposal officially to the<br>swift-evolution repo, or even that it won&#39;t get reviewed. (I&#39;m not on the<br>core team, and even core team members can be overruled by the rest of the<br>team.) It just means I&#39;m against it. :-) I am glad people are thinking<br>about it, though!<br></p><p>As for &quot;Swift 3&quot; specifically, I&#39;ll repeat Chris&#39;s canned message: the<br>schedule for Swift 3 is already pretty full with our documented goals, so<br>there&#39;s really no guarantee about what will or won&#39;t get engineering time<br>for that release.<br></p><p>Best,<br>Jordan<br></p><p>On Dec 8, 2015, at 8:07, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>I would be happy to do it, but I would like to know how broad the interest<br>in exploring this is first, and especially whether this is something the<br>core team is willing to consider for Swift 3 (depending on details of<br>course).<br></p><p>Sent from my iPhone<br></p><p>On Dec 8, 2015, at 7:37 AM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br></p><p>Hi Matthew,<br></p><p>Maybe you could write the proposal? I&#39;d be happy to do it, but it was your<br>idea. Also, I think that you will express it better.<br></p><p>--<br>Ilya Belenkiy<br>On Mon, Dec 7, 2015 at 2:11 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; Glad you like my reframing!  Is anyone planning to write a proposal for<br>&gt; this?<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Dec 7, 2015, at 1:00 PM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;<br>&gt; Yes, that&#39;s a great idea!<br>&gt;<br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt; On Mon, Dec 7, 2015 at 1:35 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I think what you are really trying to accomplish is to restrict access to<br>&gt;&gt; a member to the scope in which it is declared, which just happens to be a<br>&gt;&gt; type declaration.<br>&gt;&gt;<br>&gt;&gt; By looking at it in terms of scope the feature would be come more<br>&gt;&gt; generally applicable.  For example, you could have a &#39;classified&#39; member in<br>&gt;&gt; an extension which is only visible inside the body of the extension.  This<br>&gt;&gt; would be useful if the extension contains helper methods as part of its<br>&gt;&gt; implementation.<br>&gt;&gt;<br>&gt;&gt; I would absolutely support extending Swift&#39;s scope-based access control<br>&gt;&gt; to allow for more granular control of visibility within a file by extending<br>&gt;&gt; it to syntactic scopes.  It seems like a pretty natural enhancement to the<br>&gt;&gt; existing feature.<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Dec 7, 2015, at 11:02 AM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; If it is not allowed in extensions or subclasses (and it shouldn&#39;t), the<br>&gt;&gt; model is still very simple.<br>&gt;&gt;<br>&gt;&gt; I understand the current model, but I think that there is a lot of value<br>&gt;&gt; in getting the compiler&#39;s help in ensuring that class internals cannot be<br>&gt;&gt; broken by anything outside the class.<br>&gt;&gt;<br>&gt;&gt; The current model doesn&#39;t solve this problem well. Putting everything in<br>&gt;&gt; separate files seems like a very unfortunate workaround.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Ilya Belenkiy<br>&gt;&gt;<br>&gt;&gt; On Mon, Dec 7, 2015 at 9:41 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I was not sure how I felt about Swift&#39;s access control when it was first<br>&gt;&gt;&gt; announced but it didn&#39;t take long for me to believe it strikes a pretty<br>&gt;&gt;&gt; good balance between complexity and ability to hide implementation details.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It follows a very straightforward scope-driven strategy.  If it is<br>&gt;&gt;&gt; extended further I would like to see any enhancements follow the same<br>&gt;&gt;&gt; scope-driven strategy rather than being type-driven as is seen in other<br>&gt;&gt;&gt; languages.  Proposals along these lines might be interesting to consider<br>&gt;&gt;&gt; and might be able to accomplish what you are hoping to accomplish while<br>&gt;&gt;&gt; affording additional flexibility.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In a language where distributing the implementation of a type across<br>&gt;&gt;&gt; several extensions sometimes in different files a type-driven access<br>&gt;&gt;&gt; control model doesn&#39;t make a lot of sense to me.  I think it has a lot of<br>&gt;&gt;&gt; potential to be confusing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What would it mean to limit access to a member to the type itself in<br>&gt;&gt;&gt; Swift?  Would an extensions in the same (or different) files be able to see<br>&gt;&gt;&gt; the member?  What about extensions in a different module?  And what about<br>&gt;&gt;&gt; subclasses? Subclasses probably wouldn&#39;t have visibility to them, but any<br>&gt;&gt;&gt; discussion of something like this will probably lead to discussion of<br>&gt;&gt;&gt; protected as well.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 7, 2015, at 7:45 AM, Ilya via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Also, one problem with the current approach is that it&#39;s all or nothing.<br>&gt;&gt;&gt; The classes in one file see everything from the other classes, and it may<br>&gt;&gt;&gt; be useful to limit that and share only some additional APIs with those<br>&gt;&gt;&gt; related classes, but not all of the implementation details / internal<br>&gt;&gt;&gt; state, while still hiding those same APIs from unrelated classes.<br>&gt;&gt;&gt; Currently, there is no way of doing it, even when splitting code into<br>&gt;&gt;&gt; separate files (the class state must be all in one place and can&#39;t be in an<br>&gt;&gt;&gt; extension).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt; On Mon, Dec 7, 2015 at 8:17 AM Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; My main proposal was not to change the semantics of private (although I<br>&gt;&gt;&gt;&gt; would like that) but to introduce a way to keep class implementation<br>&gt;&gt;&gt;&gt; details inaccessible to anything outside the class. I think that it should<br>&gt;&gt;&gt;&gt; still be possible and useful to have the current level of sharing (I would<br>&gt;&gt;&gt;&gt; just name it differently, given what private usually means in other<br>&gt;&gt;&gt;&gt; languages).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Just as it is convenient to group several related classes that can<br>&gt;&gt;&gt;&gt; refer to each other&#39;s implementation details, it is very convenient to have<br>&gt;&gt;&gt;&gt; several classes that don&#39;t do this but are still related in other important<br>&gt;&gt;&gt;&gt; way, for example related APIs or classes that are based on the same<br>&gt;&gt;&gt;&gt; implementation idea (like array based data structures).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Having all code in one place rather than jumping through many small<br>&gt;&gt;&gt;&gt; files is a very nice thing to have because it really helps to keep<br>&gt;&gt;&gt;&gt; everything consistent. The more manual work people have to do for<br>&gt;&gt;&gt;&gt; consistency, the more likelihood that it won&#39;t be done.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 12:21 AM John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Dec 5, 2015, at 8:39 PM, Ilya via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I think the it would help a great deal to have an access level<br>&gt;&gt;&gt;&gt;&gt; modifier that is really private and visible only inside the class itself.<br>&gt;&gt;&gt;&gt;&gt; Right now, the only way to hide implementation details for a class is to<br>&gt;&gt;&gt;&gt;&gt; hide the class code in a separate file, which is very inconvenient for<br>&gt;&gt;&gt;&gt;&gt; several reasons:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; 1) the meaning of the code changes depending on which file the class<br>&gt;&gt;&gt;&gt;&gt; is in. It&#39;s very easy to accidentally expose class internal details and<br>&gt;&gt;&gt;&gt;&gt; then call class elements that are meant to be used only inside the class.<br>&gt;&gt;&gt;&gt;&gt; Having a keyword for class internals will allow the compiler to ensure that<br>&gt;&gt;&gt;&gt;&gt; only the public API for the class is used from the outside world. The user<br>&gt;&gt;&gt;&gt;&gt; can check types on his own, but it&#39;s better that the compiler does it<br>&gt;&gt;&gt;&gt;&gt; automatically. Similarly, the user can check that only the proper APIs are<br>&gt;&gt;&gt;&gt;&gt; called, but it&#39;s better that the compiler does it automatically.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; 2) accessibility by file structure may cause some really short files.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; 3) It&#39;s impossible to group related classes in one file but still<br>&gt;&gt;&gt;&gt;&gt; hide implementation details inside each class<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I think that it the best solution is to make private keyword do what<br>&gt;&gt;&gt;&gt;&gt; it states -- keep the class element private to the class. But if it&#39;s<br>&gt;&gt;&gt;&gt;&gt; really important to have a separate keyword for backward compatibility, it<br>&gt;&gt;&gt;&gt;&gt; would be the next best thing.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; But on the flip side, with your proposed semantics for private, it<br>&gt;&gt;&gt;&gt;&gt; would be impossible to write a group of related types, functions, and<br>&gt;&gt;&gt;&gt;&gt; extensions that do need to refer to each other’s internal details without<br>&gt;&gt;&gt;&gt;&gt; exposing those details to the entire module.  That’s not really acceptable.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The Swift language rule encourages you to put independent definitions<br>&gt;&gt;&gt;&gt;&gt; in different files.  That definitely means that, if you want to enforce<br>&gt;&gt;&gt;&gt;&gt; very tight separation of concerns, you’ll end up with more and smaller<br>&gt;&gt;&gt;&gt;&gt; files.  You haven’t explained why that’s really a *problem*, though.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/2b2aa3c9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>access control proposal</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December  9, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 6:42 AM, Ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; For me, hiding implementation details is a fundamental feature of the language / compiler. It is possible to get by without it with coding by convention, but it’s also possible to get by without a strong type system. Having a way to hide implementation details that is enforced by the language will help to have clearly defined interfaces and limit hacks and mistakes for misusing APIs that are meant to be private.<br></p><p>The current implementation strikes a good balance here. Couldn’t project-specific requirements for where private variables/functions are accessed be enforced by a linter?<br></p><p>Stephen<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/98a4e690/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>access control proposal</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  9, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 3:42 AM, Ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hi Jordan,<br>&gt; <br>&gt; Thank you, I understand your reasoning. The current model is simple to describe and implement. It’s a good solution for access control across modules. That being said, it doesn’t solve the problem of hiding implementation details at a smaller scale, which is also important. The suggestion to put each class (or part of the class) in a separate file works for large pieces of code but isn’t practical for smaller pieces. An analogy: putting each chapter of a book into a separate file makes sense but putting every paragraph in a separate file does not.<br>&gt; <br>&gt; I think that Matthew had a great idea: add a scope based access control. Swift already has some support for it: local functions. I actually use it a lot and put functions into other functions to hide implementation details. It’s not possible to use it everywhere, but when it is possible, it’s great. If we could have a “local” access modifier that limited the entity only to the scope in which it’s defined, that would allow much less nesting, and it would make it possible to hide many more code.structures.<br></p><p>I’m still not completely convinced about the need for this level of access control, but I really like “local” as the keyword for it.<br></p><p>John.<br></p><p>&gt; <br>&gt; For me, hiding implementation details is a fundamental feature of the language / compiler. It is possible to get by without it with coding by convention, but it’s also possible to get by without a strong type system. Having a way to hide implementation details that is enforced by the language will help to have clearly defined interfaces and limit hacks and mistakes for misusing APIs that are meant to be private.<br>&gt; <br>&gt; I appreciate what you said about an official proposal. I’ll ask Matthew again (since access by scope was his idea). If he is not up to it, I’ll submit a proposal myself. For me, this issue was one of the driving forces to join the mailing list.<br>&gt; <br>&gt; —<br>&gt; Ilya Belenkiy<br>&gt;&gt; On Dec 8, 2015, at 6:49 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt; <br>&gt;&gt; As the primary implementer of the Swift access model when it first went in, I don&#39;t think we need something like &quot;classified&quot;. The purpose of access control is to make sure implementation details stay hidden from other parts of the program. If you&#39;re in the same file, you&#39;re not in another part of the program. (If your files are big enough that you are in another part of the program, maybe you should split things up into more files.)<br>&gt;&gt; <br>&gt;&gt; I am glad that you&#39;re not treating extensions as &quot;just part of the type&quot;. A lot of people say &quot;oh, of course my &#39;just for the type&#39; modifier allows extensions to see things&quot;, forgetting that extensions be added in any file in the program, including outside the module. You can even add extensions for the sole purpose of accessing these members, and therefore there&#39;s no protection at all.<br>&gt;&gt; <br>&gt;&gt; This doesn&#39;t mean you can&#39;t submit a proposal officially to the swift-evolution repo, or even that it won&#39;t get reviewed. (I&#39;m not on the core team, and even core team members can be overruled by the rest of the team.) It just means I&#39;m against it. :-) I am glad people are thinking about it, though!<br>&gt;&gt; <br>&gt;&gt; As for &quot;Swift 3&quot; specifically, I&#39;ll repeat Chris&#39;s canned message: the schedule for Swift 3 is already pretty full with our documented goals, so there&#39;s really no guarantee about what will or won&#39;t get engineering time for that release.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 8, 2015, at 8:07, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would be happy to do it, but I would like to know how broad the interest in exploring this is first, and especially whether this is something the core team is willing to consider for Swift 3 (depending on details of course).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 8, 2015, at 7:37 AM, Ilya &lt;ilya at harmonicsense.com &lt;mailto:ilya at harmonicsense.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Matthew,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Maybe you could write the proposal? I&#39;d be happy to do it, but it was your idea. Also, I think that you will express it better.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 2:11 PM Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Glad you like my reframing!  Is anyone planning to write a proposal for this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 1:00 PM, Ilya &lt;ilya at harmonicsense.com &lt;mailto:ilya at harmonicsense.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, that&#39;s a great idea!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 1:35 PM Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I think what you are really trying to accomplish is to restrict access to a member to the scope in which it is declared, which just happens to be a type declaration.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; By looking at it in terms of scope the feature would be come more generally applicable.  For example, you could have a &#39;classified&#39; member in an extension which is only visible inside the body of the extension.  This would be useful if the extension contains helper methods as part of its implementation.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would absolutely support extending Swift&#39;s scope-based access control to allow for more granular control of visibility within a file by extending it to syntactic scopes.  It seems like a pretty natural enhancement to the existing feature.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 7, 2015, at 11:02 AM, Ilya &lt;ilya at harmonicsense.com &lt;mailto:ilya at harmonicsense.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If it is not allowed in extensions or subclasses  (and it shouldn&#39;t), the model is still very simple.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I understand the current model, but I think that there is a lot of value in getting the compiler&#39;s help in ensuring that class internals cannot be broken by anything outside the class.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The current model doesn&#39;t solve this problem well. Putting everything in separate files seems like a very unfortunate workaround.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 9:41 AM Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; I was not sure how I felt about Swift&#39;s access control when it was first announced but it didn&#39;t take long for me to believe it strikes a pretty good balance between complexity and ability to hide implementation details.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It follows a very straightforward scope-driven strategy.  If it is extended further I would like to see any enhancements follow the same scope-driven strategy rather than being type-driven as is seen in other languages.  Proposals along these lines might be interesting to consider and might be able to accomplish what you are hoping to accomplish while affording additional flexibility.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In a language where distributing the implementation of a type across several extensions sometimes in different files a type-driven access control model doesn&#39;t make a lot of sense to me.  I think it has a lot of potential to be confusing.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What would it mean to limit access to a member to the type itself in Swift?  Would an extensions in the same (or different) files be able to see the member?  What about extensions in a different module?  And what about subclasses? Subclasses probably wouldn&#39;t have visibility to them, but any discussion of something like this will probably lead to discussion of protected as well.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 7, 2015, at 7:45 AM, Ilya via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Also, one problem with the current approach is that it&#39;s all or nothing. The classes in one file see everything from the other classes, and it may be useful to limit that and share only some additional APIs with those related classes, but not all of the implementation details / internal state, while still hiding those same APIs from unrelated classes. Currently, there is no way of doing it, even when splitting code into separate files (the class state must be all in one place and can&#39;t be in an extension).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 8:17 AM Ilya &lt;ilya at harmonicsense.com &lt;mailto:ilya at harmonicsense.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; My main proposal was not to change the semantics of private (although I would like that) but to introduce a way to keep class implementation details inaccessible to anything outside the class. I think that it should still be possible and useful to have the current level of sharing (I would just name it differently, given what private usually means in other languages).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just as it is convenient to group several related classes that can refer to each other&#39;s implementation details, it is very convenient to have several classes that don&#39;t do this but are still related in other important way, for example related APIs or classes that are based on the same implementation idea (like array based data structures).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Having all code in one place rather than jumping through many small files is a very nice thing to have because it really helps to keep everything consistent. The more manual work people have to do for consistency, the more likelihood that it won&#39;t be done.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 12:21 AM John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Dec 5, 2015, at 8:39 PM, Ilya via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I think the it would help a great deal to have an access level modifier that is really private and visible only inside the class itself. Right now, the only way to hide implementation details for a class is to hide the class code in a separate file, which is very inconvenient for several reasons:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; 1) the meaning of the code changes depending on which file the class is in. It&#39;s very easy to accidentally expose class internal details and then call class elements that are meant to be used only inside the class. Having a keyword for class internals will allow the compiler to ensure that only the public API for the class is used from the outside world. The user can check types on his own, but it&#39;s better that the compiler does it automatically. Similarly, the user can check that only the proper APIs are called, but it&#39;s better that the compiler does it automatically.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; 2) accessibility by file structure may cause some really short files.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; 3) It&#39;s impossible to group related classes in one file but still hide implementation details inside each class<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I think that it the best solution is to make private keyword do what it states -- keep the class element private to the class. But if it&#39;s really important to have a separate keyword for backward compatibility, it would be the next best thing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But on the flip side, with your proposed semantics for private, it would be impossible to write a group of related types, functions, and extensions that do need to refer to each other’s internal details without exposing those details to the entire module.  That’s not really acceptable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The Swift language rule encourages you to put independent definitions in different files.  That definitely means that, if you want to enforce very tight separation of concerns, you’ll end up with more and smaller files.  You haven’t explained why that’s really a *problem*, though.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/ded386eb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; I’m still not completely convinced about the need for this level of access control, but I really like “local” as the keyword for it.<br></p><p>I don&#39;t think we *need* it, but it does allow for more explicit statement of intent in code and enforcement of that intention by the compiler.  That is almost always a good thing IMO as long as it doesn&#39;t make your code excessively verbose.  In this case we would be replacing &#39;private&#39; with &#39;local&#39; so no verbosity would be added.  <br></p><p>I don&#39;t think it&#39;s a really high priority addition relative to a lot of other things, but it seems to me like a relatively low cost feature with few if any downsides.  Programmers who don&#39;t want to use it don&#39;t have to.  I wonder if there are any strong arguments against adding it other than it making the language ever so slightly larger.<br></p><p>The &#39;local&#39; keyword does seem pretty good.  I like it much better than &#39;classified&#39;.  My only question about it is whether some programmers might confuse it with local variables in a function.  <br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>access control proposal</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  9, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 9:16 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; I’m still not completely convinced about the need for this level of access control, but I really like “local” as the keyword for it.<br>&gt; <br>&gt; I don&#39;t think we *need* it, but it does allow for more explicit statement of intent in code and enforcement of that intention by the compiler.  That is almost always a good thing IMO as long as it doesn&#39;t make your code excessively verbose.  In this case we would be replacing &#39;private&#39; with &#39;local&#39; so no verbosity would be added.  <br>&gt; <br>&gt; I don&#39;t think it&#39;s a really high priority addition relative to a lot of other things, but it seems to me like a relatively low cost feature with few if any downsides.  Programmers who don&#39;t want to use it don&#39;t have to.  I wonder if there are any strong arguments against adding it other than it making the language ever so slightly larger.<br></p><p>Right, I think that’s the tension here: there’s clearly at least *some* value in it as an access specifier.  The concern is that it heavily overlaps with “private”, because when people write larger types, they’re likely to do so in a single file.  That means it’ll introduce a lot of confusion about which one to use, and you’ll probably see poorly-styled code bases that use them interchangeably.  This will be amplified by the fact that “private” is the one people are familiar with in other languages.<br></p><p>In other words, I can definitely see why it’s a good idea for *code*.  I am uncertain whether it is a good idea for *the language*.<br></p><p>&gt; The &#39;local&#39; keyword does seem pretty good.  I like it much better than &#39;classified&#39;.  My only question about it is whether some programmers might confuse it with local variables in a function.<br></p><p>We should be disallowing access modifiers in function contexts anyway.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; We should be disallowing access modifiers in function contexts anyway.<br></p><p>I didn&#39;t mean people would expect to use the access modifier in a function context, but it is common to refer to member variables as &#39;public&#39;, &#39;internal&#39; or &#39;private&#39; variables and it is common to refer to variables scoped to a function as local variables.  There has never been any potential for confusion because there has never been a language I know of with a &#39;local&#39; access modifier.  <br></p><p>If we add one using this keyword I could imagine confusion between members declared with the &#39;local&#39; access modifier and variables scoped to a function.  The potential for confusion would be most prevalent in new developers, but I can also imagine casual conversations between experienced developers where such confusion might arise.  It&#39;s something to consider when thinking about whether or not this would be the best keyword to use.<br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>access control proposal</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  9, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 9:57 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; We should be disallowing access modifiers in function contexts anyway.<br>&gt; <br>&gt; I didn&#39;t mean people would expect to use the access modifier in a function context, but it is common to refer to member variables as &#39;public&#39;, &#39;internal&#39; or &#39;private&#39; variables and it is common to refer to variables scoped to a function as local variables.  There has never been any potential for confusion because there has never been a language I know of with a &#39;local&#39; access modifier.  <br>&gt; <br>&gt; If we add one using this keyword I could imagine confusion between members declared with the &#39;local&#39; access modifier and variables scoped to a function.  The potential for confusion would be most prevalent in new developers, but I can also imagine casual conversations between experienced developers where such confusion might arise.  It&#39;s something to consider when thinking about whether or not this would be the best keyword to use.<br></p><p>That’s a very good point.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1ce0c2f50b9e462c6b6a90bd38d698c9?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya</string> &lt;ilya at harmonicsense.com&gt;<p>December 12, 2015 at 03:00:00am</p></header><div class="content"><p>I think that &quot;private&quot; as it is already causes more confusion than &quot;local&quot;.<br>Another alternative I can think of is &quot;scoped&quot; or some variant of that. It<br>would be nice to have a good unambiguous name for it. Right now I just hope<br>that we can get it with *some* name.  I&#39;d be willing to do the work if it<br>could help make it happen.<br></p><p>--<br>Ilya Belenkiy<br></p><p>On Wed, Dec 9, 2015 at 1:07 PM John McCall &lt;rjmccall at apple.com&gt; wrote:<br></p><p>&gt; &gt; On Dec 9, 2015, at 9:57 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt; We should be disallowing access modifiers in function contexts anyway.<br>&gt; &gt;<br>&gt; &gt; I didn&#39;t mean people would expect to use the access modifier in a<br>&gt; function context, but it is common to refer to member variables as<br>&gt; &#39;public&#39;, &#39;internal&#39; or &#39;private&#39; variables and it is common to refer to<br>&gt; variables scoped to a function as local variables.  There has never been<br>&gt; any potential for confusion because there has never been a language I know<br>&gt; of with a &#39;local&#39; access modifier.<br>&gt; &gt;<br>&gt; &gt; If we add one using this keyword I could imagine confusion between<br>&gt; members declared with the &#39;local&#39; access modifier and variables scoped to a<br>&gt; function.  The potential for confusion would be most prevalent in new<br>&gt; developers, but I can also imagine casual conversations between experienced<br>&gt; developers where such confusion might arise.  It&#39;s something to consider<br>&gt; when thinking about whether or not this would be the best keyword to use.<br>&gt;<br>&gt; That’s a very good point.<br>&gt;<br>&gt; John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/32b89aa1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 12, 2015 at 09:00:00am</p></header><div class="content"><p>I had been thinking “scope” might make sense. “scoped” might be even better.  I like both of those better than “local” and “classified”.<br></p><p>&gt; On Dec 11, 2015, at 9:45 PM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt; <br>&gt; I think that &quot;private&quot; as it is already causes more confusion than &quot;local&quot;. Another alternative I can think of is &quot;scoped&quot; or some variant of that. It would be nice to have a good unambiguous name for it. Right now I just hope that we can get it with *some* name.  I&#39;d be willing to do the work if it could help make it happen.<br>&gt; <br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt; <br>&gt; On Wed, Dec 9, 2015 at 1:07 PM John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt; &gt; On Dec 9, 2015, at 9:57 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; &gt;&gt; We should be disallowing access modifiers in function contexts anyway.<br>&gt; &gt;<br>&gt; &gt; I didn&#39;t mean people would expect to use the access modifier in a function context, but it is common to refer to member variables as &#39;public&#39;, &#39;internal&#39; or &#39;private&#39; variables and it is common to refer to variables scoped to a function as local variables.  There has never been any potential for confusion because there has never been a language I know of with a &#39;local&#39; access modifier.<br>&gt; &gt;<br>&gt; &gt; If we add one using this keyword I could imagine confusion between members declared with the &#39;local&#39; access modifier and variables scoped to a function.  The potential for confusion would be most prevalent in new developers, but I can also imagine casual conversations between experienced developers where such confusion might arise.  It&#39;s something to consider when thinking about whether or not this would be the best keyword to use.<br>&gt; <br>&gt; That’s a very good point.<br>&gt; <br>&gt; John.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/d2b2ca4b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  9, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; In other words, I can definitely see why it’s a good idea for *code*.  I am uncertain whether it is a good idea for *the language*.<br></p><p>I don&#39;t quite follow this.  Can you elaborate?  Code can&#39;t express it if it&#39;s not in the language...<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>access control proposal</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  9, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 7:04 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; In other words, I can definitely see why it’s a good idea for *code*.  I am uncertain whether it is a good idea for *the language*.<br>&gt; <br>&gt; I don&#39;t quite follow this.  Can you elaborate?  Code can&#39;t express it if it&#39;s not in the language...<br></p><p>Features that make individual code samples look better can still be strategic mistakes when examined holistically.  This a lesson that many, many languages learn too late.  But like I said, I’m still uncertain whether it applies here.<br></p><p>John.<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>Ilya,<br></p><p>I would be happy to write this up.  It sounds like there is a possibility to have a good discussion and possibly even a formal review even if there is some initial reluctance to accept it.<br></p><p>I can&#39;t guarantee how soon I will get to it though.  It may take me a week or two (maybe longer) as I have some other proposals already started and my life is pretty busy at the moment.  If you want to see something sooner than that you should probably start a draft and I&#39;ll pitch in where I can with feedback or as a co-author.<br></p><p>Matthew<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 9, 2015, at 5:42 AM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt; <br>&gt; Hi Jordan,<br>&gt; <br>&gt; Thank you, I understand your reasoning. The current model is simple to describe and implement. It’s a good solution for access control across modules. That being said, it doesn’t solve the problem of hiding implementation details at a smaller scale, which is also important. The suggestion to put each class (or part of the class) in a separate file works for large pieces of code but isn’t practical for smaller pieces. An analogy: putting each chapter of a book into a separate file makes sense but putting every paragraph in a separate file does not.<br>&gt; <br>&gt; I think that Matthew had a great idea: add a scope based access control. Swift already has some support for it: local functions. I actually use it a lot and put functions into other functions to hide implementation details. It’s not possible to use it everywhere, but when it is possible, it’s great. If we could have a “local” access modifier that limited the entity only to the scope in which it’s defined, that would allow much less nesting, and it would make it possible to hide many more code.structures.<br>&gt; <br>&gt; For me, hiding implementation details is a fundamental feature of the language / compiler. It is possible to get by without it with coding by convention, but it’s also possible to get by without a strong type system. Having a way to hide implementation details that is enforced by the language will help to have clearly defined interfaces and limit hacks and mistakes for misusing APIs that are meant to be private.<br>&gt; <br>&gt; I appreciate what you said about an official proposal. I’ll ask Matthew again (since access by scope was his idea). If he is not up to it, I’ll submit a proposal myself. For me, this issue was one of the driving forces to join the mailing list.<br>&gt; <br>&gt; —<br>&gt; Ilya Belenkiy<br>&gt;&gt; On Dec 8, 2015, at 6:49 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt; <br>&gt;&gt; As the primary implementer of the Swift access model when it first went in, I don&#39;t think we need something like &quot;classified&quot;. The purpose of access control is to make sure implementation details stay hidden from other parts of the program. If you&#39;re in the same file, you&#39;re not in another part of the program. (If your files are big enough that you are in another part of the program, maybe you should split things up into more files.)<br>&gt;&gt; <br>&gt;&gt; I am glad that you&#39;re not treating extensions as &quot;just part of the type&quot;. A lot of people say &quot;oh, of course my &#39;just for the type&#39; modifier allows extensions to see things&quot;, forgetting that extensions be added in any file in the program, including outside the module. You can even add extensions for the sole purpose of accessing these members, and therefore there&#39;s no protection at all.<br>&gt;&gt; <br>&gt;&gt; This doesn&#39;t mean you can&#39;t submit a proposal officially to the swift-evolution repo, or even that it won&#39;t get reviewed. (I&#39;m not on the core team, and even core team members can be overruled by the rest of the team.) It just means I&#39;m against it. :-) I am glad people are thinking about it, though!<br>&gt;&gt; <br>&gt;&gt; As for &quot;Swift 3&quot; specifically, I&#39;ll repeat Chris&#39;s canned message: the schedule for Swift 3 is already pretty full with our documented goals, so there&#39;s really no guarantee about what will or won&#39;t get engineering time for that release.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 8, 2015, at 8:07, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would be happy to do it, but I would like to know how broad the interest in exploring this is first, and especially whether this is something the core team is willing to consider for Swift 3 (depending on details of course).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 8, 2015, at 7:37 AM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Matthew,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Maybe you could write the proposal? I&#39;d be happy to do it, but it was your idea. Also, I think that you will express it better.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 2:11 PM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Glad you like my reframing!  Is anyone planning to write a proposal for this?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 7, 2015, at 1:00 PM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, that&#39;s a great idea!<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 1:35 PM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think what you are really trying to accomplish is to restrict access to a member to the scope in which it is declared, which just happens to be a type declaration.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; By looking at it in terms of scope the feature would be come more generally applicable.  For example, you could have a &#39;classified&#39; member in an extension which is only visible inside the body of the extension.  This would be useful if the extension contains helper methods as part of its implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would absolutely support extending Swift&#39;s scope-based access control to allow for more granular control of visibility within a file by extending it to syntactic scopes.  It seems like a pretty natural enhancement to the existing feature.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 7, 2015, at 11:02 AM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If it is not allowed in extensions or subclasses  (and it shouldn&#39;t), the model is still very simple.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I understand the current model, but I think that there is a lot of value in getting the compiler&#39;s help in ensuring that class internals cannot be broken by anything outside the class.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The current model doesn&#39;t solve this problem well. Putting everything in separate files seems like a very unfortunate workaround.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 9:41 AM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I was not sure how I felt about Swift&#39;s access control when it was first announced but it didn&#39;t take long for me to believe it strikes a pretty good balance between complexity and ability to hide implementation details.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It follows a very straightforward scope-driven strategy.  If it is extended further I would like to see any enhancements follow the same scope-driven strategy rather than being type-driven as is seen in other languages.  Proposals along these lines might be interesting to consider and might be able to accomplish what you are hoping to accomplish while affording additional flexibility.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In a language where distributing the implementation of a type across several extensions sometimes in different files a type-driven access control model doesn&#39;t make a lot of sense to me.  I think it has a lot of potential to be confusing.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What would it mean to limit access to a member to the type itself in Swift?  Would an extensions in the same (or different) files be able to see the member?  What about extensions in a different module?  And what about subclasses? Subclasses probably wouldn&#39;t have visibility to them, but any discussion of something like this will probably lead to discussion of protected as well.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 7, 2015, at 7:45 AM, Ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Also, one problem with the current approach is that it&#39;s all or nothing. The classes in one file see everything from the other classes, and it may be useful to limit that and share only some additional APIs with those related classes, but not all of the implementation details / internal state, while still hiding those same APIs from unrelated classes. Currently, there is no way of doing it, even when splitting code into separate files (the class state must be all in one place and can&#39;t be in an extension).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 8:17 AM Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My main proposal was not to change the semantics of private (although I would like that) but to introduce a way to keep class implementation details inaccessible to anything outside the class. I think that it should still be possible and useful to have the current level of sharing (I would just name it differently, given what private usually means in other languages).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just as it is convenient to group several related classes that can refer to each other&#39;s implementation details, it is very convenient to have several classes that don&#39;t do this but are still related in other important way, for example related APIs or classes that are based on the same implementation idea (like array based data structures).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Having all code in one place rather than jumping through many small files is a very nice thing to have because it really helps to keep everything consistent. The more manual work people have to do for consistency, the more likelihood that it won&#39;t be done.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 12:21 AM John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Dec 5, 2015, at 8:39 PM, Ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I think the it would help a great deal to have an access level modifier that is really private and visible only inside the class itself. Right now, the only way to hide implementation details for a class is to hide the class code in a separate file, which is very inconvenient for several reasons:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; 1) the meaning of the code changes depending on which file the class is in. It&#39;s very easy to accidentally expose class internal details and then call class elements that are meant to be used only inside the class. Having a keyword for class internals will allow the compiler to ensure that only the public API for the class is used from the outside world. The user can check types on his own, but it&#39;s better that the compiler does it automatically. Similarly, the user can check that only the proper APIs are called, but it&#39;s better that the compiler does it automatically.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; 2) accessibility by file structure may cause some really short files.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; 3) It&#39;s impossible to group related classes in one file but still hide implementation details inside each class<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I think that it the best solution is to make private keyword do what it states -- keep the class element private to the class. But if it&#39;s really important to have a separate keyword for backward compatibility, it would be the next best thing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But on the flip side, with your proposed semantics for private, it would be impossible to write a group of related types, functions, and extensions that do need to refer to each other’s internal details without exposing those details to the entire module.  That’s not really acceptable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The Swift language rule encourages you to put independent definitions in different files.  That definitely means that, if you want to enforce very tight separation of concerns, you’ll end up with more and smaller files.  You haven’t explained why that’s really a *problem*, though.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/4adf6563/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1ce0c2f50b9e462c6b6a90bd38d698c9?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya</string> &lt;ilya at harmonicsense.com&gt;<p>December 12, 2015 at 03:00:00am</p></header><div class="content"><p>I really want this feature, so I&#39;ll start working on a formal proposal.<br></p><p>--<br>Ilya Belenkiy<br></p><p>On Wed, Dec 9, 2015 at 12:20 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; Ilya,<br>&gt;<br>&gt; I would be happy to write this up.  It sounds like there is a possibility<br>&gt; to have a good discussion and possibly even a formal review even if there<br>&gt; is some initial reluctance to accept it.<br>&gt;<br>&gt; I can&#39;t guarantee how soon I will get to it though.  It may take me a week<br>&gt; or two (maybe longer) as I have some other proposals already started and my<br>&gt; life is pretty busy at the moment.  If you want to see something sooner<br>&gt; than that you should probably start a draft and I&#39;ll pitch in where I can<br>&gt; with feedback or as a co-author.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Dec 9, 2015, at 5:42 AM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;<br>&gt; Hi Jordan,<br>&gt;<br>&gt; Thank you, I understand your reasoning. The current model is simple to<br>&gt; describe and implement. It’s a good solution for access control across<br>&gt; modules. That being said, it doesn’t solve the problem of hiding<br>&gt; implementation details at a smaller scale, which is also important. The<br>&gt; suggestion to put each class (or part of the class) in a separate file<br>&gt; works for large pieces of code but isn’t practical for smaller pieces. An<br>&gt; analogy: putting each chapter of a book into a separate file makes sense<br>&gt; but putting every paragraph in a separate file does not.<br>&gt;<br>&gt; I think that Matthew had a great idea: add a scope based access control.<br>&gt; Swift already has some support for it: local functions. I actually use it a<br>&gt; lot and put functions into other functions to hide implementation details.<br>&gt; It’s not possible to use it everywhere, but when it is possible, it’s<br>&gt; great. If we could have a “local” access modifier that limited the entity<br>&gt; only to the scope in which it’s defined, that would allow much less<br>&gt; nesting, and it would make it possible to hide many more code.structures.<br>&gt;<br>&gt; For me, hiding implementation details is a fundamental feature of the<br>&gt; language / compiler. It is possible to get by without it with coding by<br>&gt; convention, but it’s also possible to get by without a strong type system.<br>&gt; Having a way to hide implementation details that is enforced by the<br>&gt; language will help to have clearly defined interfaces and limit hacks and<br>&gt; mistakes for misusing APIs that are meant to be private.<br>&gt;<br>&gt; I appreciate what you said about an official proposal. I’ll ask Matthew<br>&gt; again (since access by scope was his idea). If he is not up to it, I’ll<br>&gt; submit a proposal myself. For me, this issue was one of the driving forces<br>&gt; to join the mailing list.<br>&gt;<br>&gt; —<br>&gt; Ilya Belenkiy<br>&gt;<br>&gt; On Dec 8, 2015, at 6:49 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;<br>&gt; As the primary implementer of the Swift access model when it first went<br>&gt; in, I don&#39;t think we need something like &quot;classified&quot;. The purpose of<br>&gt; access control is to make sure implementation details stay hidden from<br>&gt; other parts of the program. If you&#39;re in the same file, you&#39;re not in<br>&gt; another part of the program. (If your files are big enough that you *are* in<br>&gt; another part of the program, maybe you should split things up into more<br>&gt; files.)<br>&gt;<br>&gt; I *am* glad that you&#39;re not treating extensions as &quot;just part of the<br>&gt; type&quot;. A lot of people say &quot;oh, of course my &#39;just for the type&#39; modifier<br>&gt; allows extensions to see things&quot;, forgetting that extensions be added in<br>&gt; any file in the program, including outside the module. You can even add<br>&gt; extensions for the sole purpose of accessing these members, and therefore<br>&gt; there&#39;s no protection at all.<br>&gt;<br>&gt; This doesn&#39;t mean you can&#39;t submit a proposal officially to the<br>&gt; swift-evolution repo, or even that it won&#39;t get reviewed. (I&#39;m not on the<br>&gt; core team, and even core team members can be overruled by the rest of the<br>&gt; team.) It just means I&#39;m against it. :-) I am glad people are thinking<br>&gt; about it, though!<br>&gt;<br>&gt; As for &quot;Swift 3&quot; specifically, I&#39;ll repeat Chris&#39;s canned message: the<br>&gt; schedule for Swift 3 is already pretty full with our documented goals, so<br>&gt; there&#39;s really no guarantee about what will or won&#39;t get engineering time<br>&gt; for that release.<br>&gt;<br>&gt; Best,<br>&gt; Jordan<br>&gt;<br>&gt; On Dec 8, 2015, at 8:07, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I would be happy to do it, but I would like to know how broad the interest<br>&gt; in exploring this is first, and especially whether this is something the<br>&gt; core team is willing to consider for Swift 3 (depending on details of<br>&gt; course).<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On Dec 8, 2015, at 7:37 AM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;<br>&gt; Hi Matthew,<br>&gt;<br>&gt; Maybe you could write the proposal? I&#39;d be happy to do it, but it was your<br>&gt; idea. Also, I think that you will express it better.<br>&gt;<br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt; On Mon, Dec 7, 2015 at 2:11 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Glad you like my reframing!  Is anyone planning to write a proposal for<br>&gt;&gt; this?<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Dec 7, 2015, at 1:00 PM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Yes, that&#39;s a great idea!<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Ilya Belenkiy<br>&gt;&gt; On Mon, Dec 7, 2015 at 1:35 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I think what you are really trying to accomplish is to restrict access<br>&gt;&gt;&gt; to a member to the scope in which it is declared, which just happens to be<br>&gt;&gt;&gt; a type declaration.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; By looking at it in terms of scope the feature would be come more<br>&gt;&gt;&gt; generally applicable.  For example, you could have a &#39;classified&#39; member in<br>&gt;&gt;&gt; an extension which is only visible inside the body of the extension.  This<br>&gt;&gt;&gt; would be useful if the extension contains helper methods as part of its<br>&gt;&gt;&gt; implementation.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I would absolutely support extending Swift&#39;s scope-based access control<br>&gt;&gt;&gt; to allow for more granular control of visibility within a file by extending<br>&gt;&gt;&gt; it to syntactic scopes.  It seems like a pretty natural enhancement to the<br>&gt;&gt;&gt; existing feature.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 7, 2015, at 11:02 AM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If it is not allowed in extensions or subclasses (and it shouldn&#39;t), the<br>&gt;&gt;&gt; model is still very simple.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I understand the current model, but I think that there is a lot of value<br>&gt;&gt;&gt; in getting the compiler&#39;s help in ensuring that class internals cannot be<br>&gt;&gt;&gt; broken by anything outside the class.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The current model doesn&#39;t solve this problem well. Putting everything in<br>&gt;&gt;&gt; separate files seems like a very unfortunate workaround.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, Dec 7, 2015 at 9:41 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I was not sure how I felt about Swift&#39;s access control when it was<br>&gt;&gt;&gt;&gt; first announced but it didn&#39;t take long for me to believe it strikes a<br>&gt;&gt;&gt;&gt; pretty good balance between complexity and ability to hide implementation<br>&gt;&gt;&gt;&gt; details.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It follows a very straightforward scope-driven strategy.  If it is<br>&gt;&gt;&gt;&gt; extended further I would like to see any enhancements follow the same<br>&gt;&gt;&gt;&gt; scope-driven strategy rather than being type-driven as is seen in other<br>&gt;&gt;&gt;&gt; languages.  Proposals along these lines might be interesting to consider<br>&gt;&gt;&gt;&gt; and might be able to accomplish what you are hoping to accomplish while<br>&gt;&gt;&gt;&gt; affording additional flexibility.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In a language where distributing the implementation of a type across<br>&gt;&gt;&gt;&gt; several extensions sometimes in different files a type-driven access<br>&gt;&gt;&gt;&gt; control model doesn&#39;t make a lot of sense to me.  I think it has a lot of<br>&gt;&gt;&gt;&gt; potential to be confusing.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; What would it mean to limit access to a member to the type itself in<br>&gt;&gt;&gt;&gt; Swift?  Would an extensions in the same (or different) files be able to see<br>&gt;&gt;&gt;&gt; the member?  What about extensions in a different module?  And what about<br>&gt;&gt;&gt;&gt; subclasses? Subclasses probably wouldn&#39;t have visibility to them, but any<br>&gt;&gt;&gt;&gt; discussion of something like this will probably lead to discussion of<br>&gt;&gt;&gt;&gt; protected as well.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 7:45 AM, Ilya via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Also, one problem with the current approach is that it&#39;s all or<br>&gt;&gt;&gt;&gt; nothing. The classes in one file see everything from the other classes, and<br>&gt;&gt;&gt;&gt; it may be useful to limit that and share only some additional APIs with<br>&gt;&gt;&gt;&gt; those related classes, but not all of the implementation details / internal<br>&gt;&gt;&gt;&gt; state, while still hiding those same APIs from unrelated classes.<br>&gt;&gt;&gt;&gt; Currently, there is no way of doing it, even when splitting code into<br>&gt;&gt;&gt;&gt; separate files (the class state must be all in one place and can&#39;t be in an<br>&gt;&gt;&gt;&gt; extension).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 8:17 AM Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; My main proposal was not to change the semantics of private (although<br>&gt;&gt;&gt;&gt;&gt; I would like that) but to introduce a way to keep class implementation<br>&gt;&gt;&gt;&gt;&gt; details inaccessible to anything outside the class. I think that it should<br>&gt;&gt;&gt;&gt;&gt; still be possible and useful to have the current level of sharing (I would<br>&gt;&gt;&gt;&gt;&gt; just name it differently, given what private usually means in other<br>&gt;&gt;&gt;&gt;&gt; languages).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Just as it is convenient to group several related classes that can<br>&gt;&gt;&gt;&gt;&gt; refer to each other&#39;s implementation details, it is very convenient to have<br>&gt;&gt;&gt;&gt;&gt; several classes that don&#39;t do this but are still related in other important<br>&gt;&gt;&gt;&gt;&gt; way, for example related APIs or classes that are based on the same<br>&gt;&gt;&gt;&gt;&gt; implementation idea (like array based data structures).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Having all code in one place rather than jumping through many small<br>&gt;&gt;&gt;&gt;&gt; files is a very nice thing to have because it really helps to keep<br>&gt;&gt;&gt;&gt;&gt; everything consistent. The more manual work people have to do for<br>&gt;&gt;&gt;&gt;&gt; consistency, the more likelihood that it won&#39;t be done.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 12:21 AM John McCall &lt;rjmccall at apple.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Dec 5, 2015, at 8:39 PM, Ilya via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I think the it would help a great deal to have an access level<br>&gt;&gt;&gt;&gt;&gt;&gt; modifier that is really private and visible only inside the class itself.<br>&gt;&gt;&gt;&gt;&gt;&gt; Right now, the only way to hide implementation details for a class is to<br>&gt;&gt;&gt;&gt;&gt;&gt; hide the class code in a separate file, which is very inconvenient for<br>&gt;&gt;&gt;&gt;&gt;&gt; several reasons:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; 1) the meaning of the code changes depending on which file the<br>&gt;&gt;&gt;&gt;&gt;&gt; class is in. It&#39;s very easy to accidentally expose class internal details<br>&gt;&gt;&gt;&gt;&gt;&gt; and then call class elements that are meant to be used only inside the<br>&gt;&gt;&gt;&gt;&gt;&gt; class. Having a keyword for class internals will allow the compiler to<br>&gt;&gt;&gt;&gt;&gt;&gt; ensure that only the public API for the class is used from the outside<br>&gt;&gt;&gt;&gt;&gt;&gt; world. The user can check types on his own, but it&#39;s better that the<br>&gt;&gt;&gt;&gt;&gt;&gt; compiler does it automatically. Similarly, the user can check that only the<br>&gt;&gt;&gt;&gt;&gt;&gt; proper APIs are called, but it&#39;s better that the compiler does it<br>&gt;&gt;&gt;&gt;&gt;&gt; automatically.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; 2) accessibility by file structure may cause some really short<br>&gt;&gt;&gt;&gt;&gt;&gt; files.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; 3) It&#39;s impossible to group related classes in one file but still<br>&gt;&gt;&gt;&gt;&gt;&gt; hide implementation details inside each class<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I think that it the best solution is to make private keyword do<br>&gt;&gt;&gt;&gt;&gt;&gt; what it states -- keep the class element private to the class. But if it&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt; really important to have a separate keyword for backward compatibility, it<br>&gt;&gt;&gt;&gt;&gt;&gt; would be the next best thing.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; But on the flip side, with your proposed semantics for private, it<br>&gt;&gt;&gt;&gt;&gt;&gt; would be impossible to write a group of related types, functions, and<br>&gt;&gt;&gt;&gt;&gt;&gt; extensions that do need to refer to each other’s internal details without<br>&gt;&gt;&gt;&gt;&gt;&gt; exposing those details to the entire module.  That’s not really acceptable.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; The Swift language rule encourages you to put independent definitions<br>&gt;&gt;&gt;&gt;&gt;&gt; in different files.  That definitely means that, if you want to enforce<br>&gt;&gt;&gt;&gt;&gt;&gt; very tight separation of concerns, you’ll end up with more and smaller<br>&gt;&gt;&gt;&gt;&gt;&gt; files.  You haven’t explained why that’s really a *problem*, though.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/78b7abd4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 12, 2015 at 06:00:00am</p></header><div class="content"><p>Sounds good Ilya.  I&#39;ll be happy to offer feedback and contribute to it.  I just haven&#39;t had time to write it myself yet.  Feel free to ping me privately if you would like to collaborate.<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 11, 2015, at 9:50 PM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt; <br>&gt; I really want this feature, so I&#39;ll start working on a formal proposal.<br>&gt; <br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt; <br>&gt;&gt; On Wed, Dec 9, 2015 at 12:20 PM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; Ilya,<br>&gt;&gt; <br>&gt;&gt; I would be happy to write this up.  It sounds like there is a possibility to have a good discussion and possibly even a formal review even if there is some initial reluctance to accept it.<br>&gt;&gt; <br>&gt;&gt; I can&#39;t guarantee how soon I will get to it though.  It may take me a week or two (maybe longer) as I have some other proposals already started and my life is pretty busy at the moment.  If you want to see something sooner than that you should probably start a draft and I&#39;ll pitch in where I can with feedback or as a co-author.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 5:42 AM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Jordan,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you, I understand your reasoning. The current model is simple to describe and implement. It’s a good solution for access control across modules. That being said, it doesn’t solve the problem of hiding implementation details at a smaller scale, which is also important. The suggestion to put each class (or part of the class) in a separate file works for large pieces of code but isn’t practical for smaller pieces. An analogy: putting each chapter of a book into a separate file makes sense but putting every paragraph in a separate file does not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that Matthew had a great idea: add a scope based access control. Swift already has some support for it: local functions. I actually use it a lot and put functions into other functions to hide implementation details. It’s not possible to use it everywhere, but when it is possible, it’s great. If we could have a “local” access modifier that limited the entity only to the scope in which it’s defined, that would allow much less nesting, and it would make it possible to hide many more code.structures.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For me, hiding implementation details is a fundamental feature of the language / compiler. It is possible to get by without it with coding by convention, but it’s also possible to get by without a strong type system. Having a way to hide implementation details that is enforced by the language will help to have clearly defined interfaces and limit hacks and mistakes for misusing APIs that are meant to be private.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I appreciate what you said about an official proposal. I’ll ask Matthew again (since access by scope was his idea). If he is not up to it, I’ll submit a proposal myself. For me, this issue was one of the driving forces to join the mailing list.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; —<br>&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt; On Dec 8, 2015, at 6:49 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As the primary implementer of the Swift access model when it first went in, I don&#39;t think we need something like &quot;classified&quot;. The purpose of access control is to make sure implementation details stay hidden from other parts of the program. If you&#39;re in the same file, you&#39;re not in another part of the program. (If your files are big enough that you are in another part of the program, maybe you should split things up into more files.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am glad that you&#39;re not treating extensions as &quot;just part of the type&quot;. A lot of people say &quot;oh, of course my &#39;just for the type&#39; modifier allows extensions to see things&quot;, forgetting that extensions be added in any file in the program, including outside the module. You can even add extensions for the sole purpose of accessing these members, and therefore there&#39;s no protection at all.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This doesn&#39;t mean you can&#39;t submit a proposal officially to the swift-evolution repo, or even that it won&#39;t get reviewed. (I&#39;m not on the core team, and even core team members can be overruled by the rest of the team.) It just means I&#39;m against it. :-) I am glad people are thinking about it, though!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As for &quot;Swift 3&quot; specifically, I&#39;ll repeat Chris&#39;s canned message: the schedule for Swift 3 is already pretty full with our documented goals, so there&#39;s really no guarantee about what will or won&#39;t get engineering time for that release.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 8, 2015, at 8:07, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would be happy to do it, but I would like to know how broad the interest in exploring this is first, and especially whether this is something the core team is willing to consider for Swift 3 (depending on details of course).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 8, 2015, at 7:37 AM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi Matthew,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Maybe you could write the proposal? I&#39;d be happy to do it, but it was your idea. Also, I think that you will express it better.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 2:11 PM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Glad you like my reframing!  Is anyone planning to write a proposal for this?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 7, 2015, at 1:00 PM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, that&#39;s a great idea!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 1:35 PM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think what you are really trying to accomplish is to restrict access to a member to the scope in which it is declared, which just happens to be a type declaration.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; By looking at it in terms of scope the feature would be come more generally applicable.  For example, you could have a &#39;classified&#39; member in an extension which is only visible inside the body of the extension.  This would be useful if the extension contains helper methods as part of its implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would absolutely support extending Swift&#39;s scope-based access control to allow for more granular control of visibility within a file by extending it to syntactic scopes.  It seems like a pretty natural enhancement to the existing feature.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 7, 2015, at 11:02 AM, Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If it is not allowed in extensions or subclasses  (and it shouldn&#39;t), the model is still very simple.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I understand the current model, but I think that there is a lot of value in getting the compiler&#39;s help in ensuring that class internals cannot be broken by anything outside the class.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The current model doesn&#39;t solve this problem well. Putting everything in separate files seems like a very unfortunate workaround.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 9:41 AM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I was not sure how I felt about Swift&#39;s access control when it was first announced but it didn&#39;t take long for me to believe it strikes a pretty good balance between complexity and ability to hide implementation details.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It follows a very straightforward scope-driven strategy.  If it is extended further I would like to see any enhancements follow the same scope-driven strategy rather than being type-driven as is seen in other languages.  Proposals along these lines might be interesting to consider and might be able to accomplish what you are hoping to accomplish while affording additional flexibility.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In a language where distributing the implementation of a type across several extensions sometimes in different files a type-driven access control model doesn&#39;t make a lot of sense to me.  I think it has a lot of potential to be confusing.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What would it mean to limit access to a member to the type itself in Swift?  Would an extensions in the same (or different) files be able to see the member?  What about extensions in a different module?  And what about subclasses? Subclasses probably wouldn&#39;t have visibility to them, but any discussion of something like this will probably lead to discussion of protected as well.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 7, 2015, at 7:45 AM, Ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Also, one problem with the current approach is that it&#39;s all or nothing. The classes in one file see everything from the other classes, and it may be useful to limit that and share only some additional APIs with those related classes, but not all of the implementation details / internal state, while still hiding those same APIs from unrelated classes. Currently, there is no way of doing it, even when splitting code into separate files (the class state must be all in one place and can&#39;t be in an extension).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 8:17 AM Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My main proposal was not to change the semantics of private (although I would like that) but to introduce a way to keep class implementation details inaccessible to anything outside the class. I think that it should still be possible and useful to have the current level of sharing (I would just name it differently, given what private usually means in other languages).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just as it is convenient to group several related classes that can refer to each other&#39;s implementation details, it is very convenient to have several classes that don&#39;t do this but are still related in other important way, for example related APIs or classes that are based on the same implementation idea (like array based data structures).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Having all code in one place rather than jumping through many small files is a very nice thing to have because it really helps to keep everything consistent. The more manual work people have to do for consistency, the more likelihood that it won&#39;t be done.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 12:21 AM John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Dec 5, 2015, at 8:39 PM, Ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I think the it would help a great deal to have an access level modifier that is really private and visible only inside the class itself. Right now, the only way to hide implementation details for a class is to hide the class code in a separate file, which is very inconvenient for several reasons:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; 1) the meaning of the code changes depending on which file the class is in. It&#39;s very easy to accidentally expose class internal details and then call class elements that are meant to be used only inside the class. Having a keyword for class internals will allow the compiler to ensure that only the public API for the class is used from the outside world. The user can check types on his own, but it&#39;s better that the compiler does it automatically. Similarly, the user can check that only the proper APIs are called, but it&#39;s better that the compiler does it automatically.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; 2) accessibility by file structure may cause some really short files.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; 3) It&#39;s impossible to group related classes in one file but still hide implementation details inside each class<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I think that it the best solution is to make private keyword do what it states -- keep the class element private to the class. But if it&#39;s really important to have a separate keyword for backward compatibility, it would be the next best thing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But on the flip side, with your proposed semantics for private, it would be impossible to write a group of related types, functions, and extensions that do need to refer to each other’s internal details without exposing those details to the entire module.  That’s not really acceptable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The Swift language rule encourages you to put independent definitions in different files.  That definitely means that, if you want to enforce very tight separation of concerns, you’ll end up with more and smaller files.  You haven’t explained why that’s really a *problem*, though.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/3bac7d76/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8a24682926961206ad452d8455b09457?s=50"></div><header><strong>access control proposal</strong> from <string>thorsten at portableinnovations.de</string> &lt;thorsten at portableinnovations.de&gt;<p>December  8, 2015 at 07:00:00pm</p></header><div class="content"><p>+1 for the scope based access control of Swift as opposed to the type based access control of other languages and for the nice writeup by Matthew.<br></p><p>I remember type based access control being criticized 20ish years ago to not allow access to internals of related classes. C++ created friends for that, Eiffel had something similar, but I like Swifts scope based model better, especially with respect to extensions.<br></p><p>Putting closely related things in one file and unrelated things in different files seems like a nice solution to me.<br></p><p>And its worth to note that private already means different things in different languages. In Java it means class private, in other languages it means object private (Ruby, I think).<br></p><p>That said I occasionally miss &quot;protected&quot; in the sense of subclass accessible.<br></p><p>-Thorsten<br></p><p>&gt; Am 07.12.2015 um 15:41 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I was not sure how I felt about Swift&#39;s access control when it was first announced but it didn&#39;t take long for me to believe it strikes a pretty good balance between complexity and ability to hide implementation details.<br>&gt; <br>&gt; It follows a very straightforward scope-driven strategy.  If it is extended further I would like to see any enhancements follow the same scope-driven strategy rather than being type-driven as is seen in other languages.  Proposals along these lines might be interesting to consider and might be able to accomplish what you are hoping to accomplish while affording additional flexibility.<br>&gt; <br>&gt; In a language where distributing the implementation of a type across several extensions sometimes in different files a type-driven access control model doesn&#39;t make a lot of sense to me.  I think it has a lot of potential to be confusing.  <br>&gt; <br>&gt; What would it mean to limit access to a member to the type itself in Swift?  Would an extensions in the same (or different) files be able to see the member?  What about extensions in a different module?  And what about subclasses? Subclasses probably wouldn&#39;t have visibility to them, but any discussion of something like this will probably lead to discussion of protected as well.<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 7:45 AM, Ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Also, one problem with the current approach is that it&#39;s all or nothing. The classes in one file see everything from the other classes, and it may be useful to limit that and share only some additional APIs with those related classes, but not all of the implementation details / internal state, while still hiding those same APIs from unrelated classes. Currently, there is no way of doing it, even when splitting code into separate files (the class state must be all in one place and can&#39;t be in an extension).<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt; On Mon, Dec 7, 2015 at 8:17 AM Ilya &lt;ilya at harmonicsense.com&gt; wrote:<br>&gt;&gt;&gt; My main proposal was not to change the semantics of private (although I would like that) but to introduce a way to keep class implementation details inaccessible to anything outside the class. I think that it should still be possible and useful to have the current level of sharing (I would just name it differently, given what private usually means in other languages).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just as it is convenient to group several related classes that can refer to each other&#39;s implementation details, it is very convenient to have several classes that don&#39;t do this but are still related in other important way, for example related APIs or classes that are based on the same implementation idea (like array based data structures).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Having all code in one place rather than jumping through many small files is a very nice thing to have because it really helps to keep everything consistent. The more manual work people have to do for consistency, the more likelihood that it won&#39;t be done.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 12:21 AM John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On Dec 5, 2015, at 8:39 PM, Ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I think the it would help a great deal to have an access level modifier that is really private and visible only inside the class itself. Right now, the only way to hide implementation details for a class is to hide the class code in a separate file, which is very inconvenient for several reasons:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; 1) the meaning of the code changes depending on which file the class is in. It&#39;s very easy to accidentally expose class internal details and then call class elements that are meant to be used only inside the class. Having a keyword for class internals will allow the compiler to ensure that only the public API for the class is used from the outside world. The user can check types on his own, but it&#39;s better that the compiler does it automatically. Similarly, the user can check that only the proper APIs are called, but it&#39;s better that the compiler does it automatically.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; 2) accessibility by file structure may cause some really short files.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; 3) It&#39;s impossible to group related classes in one file but still hide implementation details inside each class<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I think that it the best solution is to make private keyword do what it states -- keep the class element private to the class. But if it&#39;s really important to have a separate keyword for backward compatibility, it would be the next best thing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But on the flip side, with your proposed semantics for private, it would be impossible to write a group of related types, functions, and extensions that do need to refer to each other’s internal details without exposing those details to the entire module.  That’s not really acceptable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The Swift language rule encourages you to put independent definitions in different files.  That definitely means that, if you want to enforce very tight separation of concerns, you’ll end up with more and smaller files.  You haven’t explained why that’s really a *problem*, though.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/1b1c5fa8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
