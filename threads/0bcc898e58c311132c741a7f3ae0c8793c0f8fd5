<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 28, 2016 at 05:00:00pm</p></header><div class="content"><p>on Mon Mar 28 2016, Dave Abrahams &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; on Mon Mar 28 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;&gt; On Mar 28, 2016, at 3:54 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Mon Mar 28 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Mar 28, 2016, at 3:25 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Mon Mar 28 2016, Xiaodi Wu<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Right, Countable could refine Strideable. I&#39;m no expert on this, but<br>&gt;&gt;&gt;&gt;&gt;&gt; some cursory reading suggests that the analogous feature in C++ simply<br>&gt;&gt;&gt;&gt;&gt;&gt; requires the type to have operator++ defined. Obviously, that won&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt; work for Swift 3.0...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hmm, instead of defining a new protocol (Countable), what if we just use<br>&gt;&gt;&gt;&gt;&gt; “Strideable where Stride : Integer” as a constraint?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like a differentiation between continuous and discrete things<br>&gt;&gt;&gt;&gt; although both can have ranges, membership, fences,<br>&gt;&gt;&gt;&gt; and a way to stride through them<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Strideable where Stride : Integer expresses just exactly that.  Now if I<br>&gt;&gt;&gt; could only get the type-checker to cooperate...<br>&gt;&gt;<br>&gt;&gt; I am ridiculously excited about what you&#39;re doing there. <br>&gt;&gt; Looking forward to beautiful floating point strides if for no<br>&gt;&gt; other reason than I can point out how well they work for math<br>&gt;&gt; in comparison to traditional for;;loops, so maybe people will<br>&gt;&gt; stop burning semicolons on my lawn.<br>&gt;<br>&gt; The basics:<br>&gt; https://github.com/apple/swift/commit/a5c3c63c3d5d940f729c23aab342ea4d270d264a<br></p><p>Hi Erica,<br></p><p>After some consideration, while I want to see the smart<br>(x..&lt;y).striding(by: z) stuff happen too, it&#39;s somewhat incidental to<br>the (already massive) project we&#39;re undertaking in this branch.  Would<br>you like to take on the implementation and/or proposal?  I&#39;d be happy to<br>provide guidance.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>March 30, 2016 at 12:00:00am</p></header><div class="content"><p>Relatedly, while you&#39;re tackling this big revision:<br></p><p>I&#39;ve tried to play around with what it would take to write a generic<br>non-error-accumulating striding method, and afaict, it would be enormously<br>cleaner if Strideable types are guaranteed to have + and * (well,<br>Strideable.Stride needs *, to be more accurate), since the iterator needs<br>to be able to compute end = start + iteration * stride. Is that going to be<br>exposed somewhere in the cascade of numeric protocols that culminate in<br>Strideable?<br>On Mon, Mar 28, 2016 at 7:45 PM Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Mon Mar 28 2016, Dave Abrahams &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; on Mon Mar 28 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; On Mar 28, 2016, at 3:54 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; on Mon Mar 28 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Mar 28, 2016, at 3:25 PM, Dave Abrahams via swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; on Mon Mar 28 2016, Xiaodi Wu<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Right, Countable could refine Strideable. I&#39;m no expert on this, but<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; some cursory reading suggests that the analogous feature in C++<br>&gt; simply<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; requires the type to have operator++ defined. Obviously, that won&#39;t<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; work for Swift 3.0...<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Hmm, instead of defining a new protocol (Countable), what if we just<br>&gt; use<br>&gt; &gt;&gt;&gt;&gt;&gt; “Strideable where Stride : Integer” as a constraint?<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I like a differentiation between continuous and discrete things<br>&gt; &gt;&gt;&gt;&gt; although both can have ranges, membership, fences,<br>&gt; &gt;&gt;&gt;&gt; and a way to stride through them<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Strideable where Stride : Integer expresses just exactly that.  Now if<br>&gt; I<br>&gt; &gt;&gt;&gt; could only get the type-checker to cooperate...<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I am ridiculously excited about what you&#39;re doing there.<br>&gt; &gt;&gt; Looking forward to beautiful floating point strides if for no<br>&gt; &gt;&gt; other reason than I can point out how well they work for math<br>&gt; &gt;&gt; in comparison to traditional for;;loops, so maybe people will<br>&gt; &gt;&gt; stop burning semicolons on my lawn.<br>&gt; &gt;<br>&gt; &gt; The basics:<br>&gt; &gt;<br>&gt; https://github.com/apple/swift/commit/a5c3c63c3d5d940f729c23aab342ea4d270d264a<br>&gt;<br>&gt; Hi Erica,<br>&gt;<br>&gt; After some consideration, while I want to see the smart<br>&gt; (x..&lt;y).striding(by: z) stuff happen too, it&#39;s somewhat incidental to<br>&gt; the (already massive) project we&#39;re undertaking in this branch.  Would<br>&gt; you like to take on the implementation and/or proposal?  I&#39;d be happy to<br>&gt; provide guidance.<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/b0017fb1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 29, 2016 at 05:00:00pm</p></header><div class="content"><p>on Tue Mar 29 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; Relatedly, while you&#39;re tackling this big revision:<br>&gt;<br>&gt; I&#39;ve tried to play around with what it would take to write a generic<br>&gt; non-error-accumulating striding method, and afaict, it would be<br>&gt; enormously cleaner if Strideable types are guaranteed to have + and *<br>&gt; (well, Strideable.Stride needs *, to be more accurate), <br></p><p>That should happen automatically, since it conforms to SignedNumber,<br>when we get the Integer protocols updated (project currently on hold while<br>we land this other revision).<br></p><p>&gt; since the iterator needs to be able to compute end = start + iteration<br>&gt; * stride. <br></p><p>Don&#39;t you need division too if you&#39;re going to do this?<br></p><p>&gt; Is that going to be exposed somewhere in the cascade of numeric<br>&gt; protocols that culminate in Strideable?<br></p><p>That&#39;s not in the plan.  I&#39;m pretty sure we want UnsafePointer to be<br>Strideable and we don&#39;t want it to have multiplication or division.<br></p><p>I was thinking the StrideSequence (or some such) should be exposed as an<br>associated type of the Strideable, so it can be as efficient as possible<br>when no FP error is possible.  We don&#39;t want to spend divisions on<br>striding over Ints.<br></p><p>&gt; On Mon, Mar 28, 2016 at 7:45 PM Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     on Mon Mar 28 2016, Dave Abrahams &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     &gt; on Mon Mar 28 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;     &gt;<br>&gt;     &gt;&gt;&gt; On Mar 28, 2016, at 3:54 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; on Mon Mar 28 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; On Mar 28, 2016, at 3:25 PM, Dave Abrahams via swift-evolution<br>&gt;     &gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; on Mon Mar 28 2016, Xiaodi Wu<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;     &gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; Right, Countable could refine Strideable. I&#39;m no expert on this, but<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; some cursory reading suggests that the analogous feature in C++ simply<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; requires the type to have operator++ defined. Obviously, that won&#39;t<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; work for Swift 3.0...<br>&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; Hmm, instead of defining a new protocol (Countable), what if we just use<br>&gt;     &gt;&gt;&gt;&gt;&gt; “Strideable where Stride : Integer” as a constraint?<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; I like a differentiation between continuous and discrete things<br>&gt;     &gt;&gt;&gt;&gt; although both can have ranges, membership, fences,<br>&gt;     &gt;&gt;&gt;&gt; and a way to stride through them<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; Strideable where Stride : Integer expresses just exactly that. Now if I<br>&gt;     &gt;&gt;&gt; could only get the type-checker to cooperate...<br>&gt;     &gt;&gt;<br>&gt;     &gt;&gt; I am ridiculously excited about what you&#39;re doing there.<br>&gt;     &gt;&gt; Looking forward to beautiful floating point strides if for no<br>&gt;     &gt;&gt; other reason than I can point out how well they work for math<br>&gt;     &gt;&gt; in comparison to traditional for;;loops, so maybe people will<br>&gt;     &gt;&gt; stop burning semicolons on my lawn.<br>&gt;     &gt;<br>&gt;     &gt; The basics:<br>&gt;     &gt; https://github.com/apple/swift/commit/a5c3c63c3d5d940f729c23aab342ea4d270d264a<br>&gt;<br>&gt;     Hi Erica,<br>&gt;<br>&gt;     After some consideration, while I want to see the smart<br>&gt;     (x..&lt;y).striding(by: z) stuff happen too, it&#39;s somewhat incidental to<br>&gt;     the (already massive) project we&#39;re undertaking in this branch. Would<br>&gt;     you like to take on the implementation and/or proposal? I&#39;d be happy to<br>&gt;     provide guidance.<br>&gt;<br>&gt;     --<br>&gt;     Dave<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>March 30, 2016 at 12:00:00am</p></header><div class="content"><p>On Tue, Mar 29, 2016 at 7:48 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt; on Tue Mar 29 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Relatedly, while you&#39;re tackling this big revision:<br>&gt;&gt;<br>&gt;&gt; I&#39;ve tried to play around with what it would take to write a generic<br>&gt;&gt; non-error-accumulating striding method, and afaict, it would be<br>&gt;&gt; enormously cleaner if Strideable types are guaranteed to have + and *<br>&gt;&gt; (well, Strideable.Stride needs *, to be more accurate),<br>&gt;<br>&gt; That should happen automatically, since it conforms to SignedNumber,<br>&gt; when we get the Integer protocols updated (project currently on hold while<br>&gt; we land this other revision).<br>&gt;<br>&gt;&gt; since the iterator needs to be able to compute end = start + iteration<br>&gt;&gt; * stride.<br>&gt;<br>&gt; Don&#39;t you need division too if you&#39;re going to do this?<br></p><p>I didn&#39;t seem to ever need division. See attached playground (which<br>borrows shamelessly from existing code and Erica&#39;s proposal, and which<br>is written in Swift 2.2 because that&#39;s what I had handy).<br></p><p>&gt;<br>&gt;&gt; Is that going to be exposed somewhere in the cascade of numeric<br>&gt;&gt; protocols that culminate in Strideable?<br>&gt;<br>&gt; That&#39;s not in the plan.  I&#39;m pretty sure we want UnsafePointer to be<br>&gt; Strideable and we don&#39;t want it to have multiplication or division.<br></p><p>You&#39;re right. The type itself doesn&#39;t need to have multiplication or<br>division. In fact, writing this, I&#39;m going back and changing my<br>playground a bit. It&#39;s sufficient that UnsafePointer.Stride can be<br>multiplied, and if SignedNumber conformance will guarantee<br>multiplication for all conforming types, we&#39;re all set for floating<br>point.<br></p><p>&gt;<br>&gt; I was thinking the StrideSequence (or some such) should be exposed as an<br>&gt; associated type of the Strideable, so it can be as efficient as possible<br>&gt; when no FP error is possible.  We don&#39;t want to spend divisions on<br>&gt; striding over Ints.<br></p><p>Right, multiplication or division best avoided here. Not sure what the<br>associated type StrideSequence would be for though? Are you aiming for<br>one StrideTo type and one StrideThrough type instead of two apiece,<br>one for floating point and one for integer? I&#39;ve been lazy and<br>overloading `stride(from:to:by:)` instead, but there&#39;s a lot of<br>repeated code.<br></p><p><br>&gt;<br>&gt;&gt; On Mon, Mar 28, 2016 at 7:45 PM Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     on Mon Mar 28 2016, Dave Abrahams &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     &gt; on Mon Mar 28 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt;&gt;&gt; On Mar 28, 2016, at 3:54 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt; on Mon Mar 28 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt; On Mar 28, 2016, at 3:25 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt; on Mon Mar 28 2016, Xiaodi Wu<br>&gt;&gt;     &gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; Right, Countable could refine Strideable. I&#39;m no expert on this, but<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; some cursory reading suggests that the analogous feature in C++ simply<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; requires the type to have operator++ defined. Obviously, that won&#39;t<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; work for Swift 3.0...<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt; Hmm, instead of defining a new protocol (Countable), what if we just use<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt; “Strideable where Stride : Integer” as a constraint?<br>&gt;&gt;     &gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt; I like a differentiation between continuous and discrete things<br>&gt;&gt;     &gt;&gt;&gt;&gt; although both can have ranges, membership, fences,<br>&gt;&gt;     &gt;&gt;&gt;&gt; and a way to stride through them<br>&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt; Strideable where Stride : Integer expresses just exactly that. Now if I<br>&gt;&gt;     &gt;&gt;&gt; could only get the type-checker to cooperate...<br>&gt;&gt;     &gt;&gt;<br>&gt;&gt;     &gt;&gt; I am ridiculously excited about what you&#39;re doing there.<br>&gt;&gt;     &gt;&gt; Looking forward to beautiful floating point strides if for no<br>&gt;&gt;     &gt;&gt; other reason than I can point out how well they work for math<br>&gt;&gt;     &gt;&gt; in comparison to traditional for;;loops, so maybe people will<br>&gt;&gt;     &gt;&gt; stop burning semicolons on my lawn.<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; The basics:<br>&gt;&gt;     &gt; https://github.com/apple/swift/commit/a5c3c63c3d5d940f729c23aab342ea4d270d264a<br>&gt;&gt;<br>&gt;&gt;     Hi Erica,<br>&gt;&gt;<br>&gt;&gt;     After some consideration, while I want to see the smart<br>&gt;&gt;     (x..&lt;y).striding(by: z) stuff happen too, it&#39;s somewhat incidental to<br>&gt;&gt;     the (already massive) project we&#39;re undertaking in this branch. Would<br>&gt;&gt;     you like to take on the implementation and/or proposal? I&#39;d be happy to<br>&gt;&gt;     provide guidance.<br>&gt;&gt;<br>&gt;&gt;     --<br>&gt;&gt;     Dave<br>&gt;&gt;<br>&gt;&gt;     _______________________________________________<br>&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;     swift-evolution at swift.org<br>&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: FloatingPointStrideTo.playground.zip<br>Type: application/zip<br>Size: 8922 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/70d416ec/attachment.zip&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 30, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 29, 2016, at 11:26 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Tue, Mar 29, 2016 at 7:48 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; on Tue Mar 29 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Relatedly, while you&#39;re tackling this big revision:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve tried to play around with what it would take to write a generic<br>&gt;&gt;&gt; non-error-accumulating striding method, and afaict, it would be<br>&gt;&gt;&gt; enormously cleaner if Strideable types are guaranteed to have + and *<br>&gt;&gt;&gt; (well, Strideable.Stride needs *, to be more accurate),<br>&gt;&gt; <br>&gt;&gt; That should happen automatically, since it conforms to SignedNumber,<br>&gt;&gt; when we get the Integer protocols updated (project currently on hold while<br>&gt;&gt; we land this other revision).<br>&gt;&gt; <br>&gt;&gt;&gt; since the iterator needs to be able to compute end = start + iteration<br>&gt;&gt;&gt; * stride.<br>&gt;&gt; <br>&gt;&gt; Don&#39;t you need division too if you&#39;re going to do this?<br>&gt; <br>&gt; I didn&#39;t seem to ever need division. See attached playground (which<br>&gt; borrows shamelessly from existing code and Erica&#39;s proposal, and which<br>&gt; is written in Swift 2.2 because that&#39;s what I had handy).<br></p><p>Have you considered trying to extend the `swift-3-indexing-model &lt;https://github.com/apple/swift/tree/swift-3-indexing-model&gt;` branch<br>at the Swift repo to take the floating point approach into account? Dave A<br>is working on a massive overhaul of ranges (including `Countable` items<br>and one would presume floating point closed and open intervals as well), <br>and I&#39;d love to see better implementations of, for example,  `(x..&lt;y).striding(by:z)`<br>happen for Double types.<br></p><p>I&#39;d be happy to throw a proposal together based on a proof of concept,<br>if you had the flexibility to work on the coding.<br></p><p>-- Erica<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/16e6c7c2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>March 30, 2016 at 05:00:00pm</p></header><div class="content"><p>Sure, I could give it a shot this weekend.<br>On Wed, Mar 30, 2016 at 12:03 PM Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Mar 29, 2016, at 11:26 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Tue, Mar 29, 2016 at 7:48 PM, Dave Abrahams &lt;dabrahams at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Tue Mar 29 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com<br>&gt; &lt;http://xiaodi.wu-at-gmail.com&gt;&gt; wrote:<br>&gt;<br>&gt; Relatedly, while you&#39;re tackling this big revision:<br>&gt;<br>&gt; I&#39;ve tried to play around with what it would take to write a generic<br>&gt; non-error-accumulating striding method, and afaict, it would be<br>&gt; enormously cleaner if Strideable types are guaranteed to have + and *<br>&gt; (well, Strideable.Stride needs *, to be more accurate),<br>&gt;<br>&gt;<br>&gt; That should happen automatically, since it conforms to SignedNumber,<br>&gt; when we get the Integer protocols updated (project currently on hold while<br>&gt; we land this other revision).<br>&gt;<br>&gt; since the iterator needs to be able to compute end = start + iteration<br>&gt; * stride.<br>&gt;<br>&gt;<br>&gt; Don&#39;t you need division too if you&#39;re going to do this?<br>&gt;<br>&gt;<br>&gt; I didn&#39;t seem to ever need division. See attached playground (which<br>&gt; borrows shamelessly from existing code and Erica&#39;s proposal, and which<br>&gt; is written in Swift 2.2 because that&#39;s what I had handy).<br>&gt;<br>&gt;<br>&gt; Have you considered trying to extend the `swift-3-indexing-model<br>&gt; &lt;https://github.com/apple/swift/tree/swift-3-indexing-model&gt;` branch<br>&gt; at the Swift repo to take the floating point approach into account? Dave A<br>&gt; is working on a massive overhaul of ranges (including `Countable` items<br>&gt; and one would presume floating point closed and open intervals as well),<br>&gt; and I&#39;d love to see better implementations of, for example,<br>&gt;  `(x..&lt;y).striding(by:z)`<br>&gt; happen for Double types.<br>&gt;<br>&gt; I&#39;d be happy to throw a proposal together based on a proof of concept,<br>&gt; if you had the flexibility to work on the coding.<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/f6e66fad/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  2, 2016 at 05:00:00pm</p></header><div class="content"><p>All righty, here&#39;s a proof-of-concept for non-error-accumulating<br>stride based on the swift-3-indexing-model branch. I tried to<br>incorporate the feedback received in the interim. Namely:<br></p><p>1. Only floating point types get this slightly more computationally<br>intensive &quot;new&quot; stride; all other types get the &quot;classic&quot; stride. If<br>accepted, this new code could be appended to Stride.swift and exist<br>alongside current code, which doesn&#39;t need to be modified.<br></p><p>2. Based on discussions about UnsafePointer, etc., it dawned on me<br>that what really determines whether a StrideTo&lt;T&gt; accumulates error<br>isn&#39;t T but rather T.Stride, so based on Dave&#39;s insights above we get<br>&quot;new stride&quot; if T.Stride == FloatingPoint.<br></p><p>3. I need to multiply floating point values, and if I understand<br>correctly multiplication will be guaranteed by a revised SignedNumber<br>protocol; for now, I&#39;ve used a _FloatingPointStrideable protocol as a<br>workaround. Note that Float80 doesn&#39;t conform to FloatingPoint, so it<br>isn&#39;t retroactively modeled to conform to _FloatingPointStrideable.<br>Nothing&#39;s lost for the moment because we can&#39;t use Float80 values for<br>&quot;new stride&quot; anyway, since it doesn&#39;t currently implement the isNormal<br>property (see below for why I use that property).<br></p><p>4. I considered Dave&#39;s suggestion whether we could avoid introducing<br>new types, instead modifying the existing StrideToIterator and<br>StrideThroughIterator and relying on compiler optimization to turn<br>&quot;new&quot; stride into &quot;classic&quot; stride for StrideTo&lt;Int&gt;, etc.; however,<br>because the differences between &quot;classic&quot; stride and &quot;new&quot; stride<br>extend beyond the iterator&#39;s next() method (see below), I thought it<br>best to keep the floating point logic in distinct types.<br></p><p>5. One difference discussed was how to handle edge cases involving<br>lots of iterations; I incorporated Howard&#39;s suggestions here, so<br>whether a stride requires more than Int.max steps is tested<br>upfront--as a consequence, infinite loops are impossible. I would love<br>it if, as Thorsten suggests, we could use BigInts, but of course<br>there&#39;s no such type in the stdlib and adding one would have to be<br>another discussion altogether.<br></p><p>6. The stride increment can&#39;t be zero; for a floating point type, it<br>also obviously can&#39;t be infinity or NaN. I&#39;m inclined to think that<br>subnormal increments should be out of the question as well, so my<br>proposed streamlined criterion is simply `stride.isNormal`. Comments<br>on this are welcome...<br></p><p>Not included:<br>1. I know Ranges are in flux, so I&#39;ve held off on extending Range with<br>a striding(by:) method in this proof-of-concept.<br>2. No attempt at the suggested stride(from:to:steps:) quite yet.<br>2. No tests written yet for this proof-of-concept; I noticed that<br>there&#39;s a stub for testing strides with bounds of type Double, but<br>there&#39;s a comment about things not being ready because Double conforms<br>to RandomIndexType--not sure what to make of that.<br>3. Haven&#39;t gotten around to testing performance.<br></p><p><br>On Wed, Mar 30, 2016 at 12:03 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt; On Mar 29, 2016, at 11:26 PM, Xiaodi Wu via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Tue, Mar 29, 2016 at 7:48 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Tue Mar 29 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; Relatedly, while you&#39;re tackling this big revision:<br>&gt;<br>&gt; I&#39;ve tried to play around with what it would take to write a generic<br>&gt; non-error-accumulating striding method, and afaict, it would be<br>&gt; enormously cleaner if Strideable types are guaranteed to have + and *<br>&gt; (well, Strideable.Stride needs *, to be more accurate),<br>&gt;<br>&gt;<br>&gt; That should happen automatically, since it conforms to SignedNumber,<br>&gt; when we get the Integer protocols updated (project currently on hold while<br>&gt; we land this other revision).<br>&gt;<br>&gt; since the iterator needs to be able to compute end = start + iteration<br>&gt; * stride.<br>&gt;<br>&gt;<br>&gt; Don&#39;t you need division too if you&#39;re going to do this?<br>&gt;<br>&gt;<br>&gt; I didn&#39;t seem to ever need division. See attached playground (which<br>&gt; borrows shamelessly from existing code and Erica&#39;s proposal, and which<br>&gt; is written in Swift 2.2 because that&#39;s what I had handy).<br>&gt;<br>&gt;<br>&gt; Have you considered trying to extend the `swift-3-indexing-model` branch<br>&gt; at the Swift repo to take the floating point approach into account? Dave A<br>&gt; is working on a massive overhaul of ranges (including `Countable` items<br>&gt; and one would presume floating point closed and open intervals as well),<br>&gt; and I&#39;d love to see better implementations of, for example,<br>&gt; `(x..&lt;y).striding(by:z)`<br>&gt; happen for Double types.<br>&gt;<br>&gt; I&#39;d be happy to throw a proposal together based on a proof of concept,<br>&gt; if you had the flexibility to work on the coding.<br>&gt;<br>&gt; -- Erica<br>&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: FloatingPointStrideable.swift<br>Type: application/octet-stream<br>Size: 6384 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160402/a3565eaa/attachment.obj&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April  2, 2016 at 06:00:00pm</p></header><div class="content"><p>General numerics comments:<br>We’ll want internal state and computation to be Double for Float or Double, and Float80 for Float80.  This confers a couple significant advantages:<br></p><p>- There are useful loops with more than 2**31 steps, which means having _step be Int is insufficient on 32-bit systems.  By contrast, 2**53 steps is indistinguishable from “infinite loop” for consumer systems (tens of days for a loop that does no actual work).  At some point, we will want to use a wider state, but Double is sufficient for the foreseeable future, and this can be an internal detail so it’s easy to change if/when we need to so.<br></p><p>- Using Double is preferable to using Int64 because it allows us to avoid extra Int -&gt; FP conversions, and avoids multi-word arithmetic on 32-bit systems.<br></p><p>- Using Double internally for Float loops avoids catastrophic cancellation for loops that cross zero, e.g.:<br></p><p>	for x in stride(from: Float(-200000), through: Float(1), by: Float(0.1)) {<br>	}<br></p><p>If computed in Float, the last 20 values produced by this are:<br></p><p>-0.09375, 0, 0.109375, 0.203125, 0.296875, 0.40625, 0.5, 0.609375, 0.703125, 0.796875, 0.90625, 1, 1.109375, 1.203125, 1.296875, 1.40625, 1.5, 1.609375, 1.703125, 1.796875, 1.90625<br></p><p>Of course, it’s still possible to construct such examples for Double, but they require step size of such wildly disparate scale from the endpoints that you have to loop “forever” (hours/days) before the catastrophic cancellation becomes a significant concern.<br></p><p>- Double is no less computationally efficient than Float on modern x86 or ARM.<br></p><p>We should also make sure that we codegen _start + _step*_stride to a fused-multiply add when we have hardware support (x86 Haswell and later, all arm64, most current armv7).  This eliminates the catastrophic cancellation issue *entirely*, and is faster than a separate mul and add to boot.<br></p><p>One specific question:<br>I don’t see any reason to enforce that stride isn’t subnormal (and good reasons to allow it).  Why did you add that restriction?<br></p><p>Other than those notes, this approach seems perfectly workable to me.<br></p><p>– Steve<br></p><p>&gt; On Apr 2, 2016, at 3:26 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; All righty, here&#39;s a proof-of-concept for non-error-accumulating<br>&gt; stride based on the swift-3-indexing-model branch. I tried to<br>&gt; incorporate the feedback received in the interim. Namely:<br>&gt; <br>&gt; 1. Only floating point types get this slightly more computationally<br>&gt; intensive &quot;new&quot; stride; all other types get the &quot;classic&quot; stride. If<br>&gt; accepted, this new code could be appended to Stride.swift and exist<br>&gt; alongside current code, which doesn&#39;t need to be modified.<br>&gt; <br>&gt; 2. Based on discussions about UnsafePointer, etc., it dawned on me<br>&gt; that what really determines whether a StrideTo&lt;T&gt; accumulates error<br>&gt; isn&#39;t T but rather T.Stride, so based on Dave&#39;s insights above we get<br>&gt; &quot;new stride&quot; if T.Stride == FloatingPoint.<br>&gt; <br>&gt; 3. I need to multiply floating point values, and if I understand<br>&gt; correctly multiplication will be guaranteed by a revised SignedNumber<br>&gt; protocol; for now, I&#39;ve used a _FloatingPointStrideable protocol as a<br>&gt; workaround. Note that Float80 doesn&#39;t conform to FloatingPoint, so it<br>&gt; isn&#39;t retroactively modeled to conform to _FloatingPointStrideable.<br>&gt; Nothing&#39;s lost for the moment because we can&#39;t use Float80 values for<br>&gt; &quot;new stride&quot; anyway, since it doesn&#39;t currently implement the isNormal<br>&gt; property (see below for why I use that property).<br>&gt; <br>&gt; 4. I considered Dave&#39;s suggestion whether we could avoid introducing<br>&gt; new types, instead modifying the existing StrideToIterator and<br>&gt; StrideThroughIterator and relying on compiler optimization to turn<br>&gt; &quot;new&quot; stride into &quot;classic&quot; stride for StrideTo&lt;Int&gt;, etc.; however,<br>&gt; because the differences between &quot;classic&quot; stride and &quot;new&quot; stride<br>&gt; extend beyond the iterator&#39;s next() method (see below), I thought it<br>&gt; best to keep the floating point logic in distinct types.<br>&gt; <br>&gt; 5. One difference discussed was how to handle edge cases involving<br>&gt; lots of iterations; I incorporated Howard&#39;s suggestions here, so<br>&gt; whether a stride requires more than Int.max steps is tested<br>&gt; upfront--as a consequence, infinite loops are impossible. I would love<br>&gt; it if, as Thorsten suggests, we could use BigInts, but of course<br>&gt; there&#39;s no such type in the stdlib and adding one would have to be<br>&gt; another discussion altogether.<br>&gt; <br>&gt; 6. The stride increment can&#39;t be zero; for a floating point type, it<br>&gt; also obviously can&#39;t be infinity or NaN. I&#39;m inclined to think that<br>&gt; subnormal increments should be out of the question as well, so my<br>&gt; proposed streamlined criterion is simply `stride.isNormal`. Comments<br>&gt; on this are welcome...<br>&gt; <br>&gt; Not included:<br>&gt; 1. I know Ranges are in flux, so I&#39;ve held off on extending Range with<br>&gt; a striding(by:) method in this proof-of-concept.<br>&gt; 2. No attempt at the suggested stride(from:to:steps:) quite yet.<br>&gt; 2. No tests written yet for this proof-of-concept; I noticed that<br>&gt; there&#39;s a stub for testing strides with bounds of type Double, but<br>&gt; there&#39;s a comment about things not being ready because Double conforms<br>&gt; to RandomIndexType--not sure what to make of that.<br>&gt; 3. Haven&#39;t gotten around to testing performance.<br>&gt; <br>&gt; <br>&gt; On Wed, Mar 30, 2016 at 12:03 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Mar 29, 2016, at 11:26 PM, Xiaodi Wu via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Tue, Mar 29, 2016 at 7:48 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Tue Mar 29 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Relatedly, while you&#39;re tackling this big revision:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve tried to play around with what it would take to write a generic<br>&gt;&gt; non-error-accumulating striding method, and afaict, it would be<br>&gt;&gt; enormously cleaner if Strideable types are guaranteed to have + and *<br>&gt;&gt; (well, Strideable.Stride needs *, to be more accurate),<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; That should happen automatically, since it conforms to SignedNumber,<br>&gt;&gt; when we get the Integer protocols updated (project currently on hold while<br>&gt;&gt; we land this other revision).<br>&gt;&gt; <br>&gt;&gt; since the iterator needs to be able to compute end = start + iteration<br>&gt;&gt; * stride.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Don&#39;t you need division too if you&#39;re going to do this?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I didn&#39;t seem to ever need division. See attached playground (which<br>&gt;&gt; borrows shamelessly from existing code and Erica&#39;s proposal, and which<br>&gt;&gt; is written in Swift 2.2 because that&#39;s what I had handy).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Have you considered trying to extend the `swift-3-indexing-model` branch<br>&gt;&gt; at the Swift repo to take the floating point approach into account? Dave A<br>&gt;&gt; is working on a massive overhaul of ranges (including `Countable` items<br>&gt;&gt; and one would presume floating point closed and open intervals as well),<br>&gt;&gt; and I&#39;d love to see better implementations of, for example,<br>&gt;&gt; `(x..&lt;y).striding(by:z)`<br>&gt;&gt; happen for Double types.<br>&gt;&gt; <br>&gt;&gt; I&#39;d be happy to throw a proposal together based on a proof of concept,<br>&gt;&gt; if you had the flexibility to work on the coding.<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; <br>&gt; &lt;FloatingPointStrideable.swift&gt;_______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160402/bf7eb458/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April  2, 2016 at 06:00:00pm</p></header><div class="content"><p>Gah, hit send too soon, the values should be:<br></p><p>-1, -0.890625, -0.796875, -0.703125, -0.59375, -0.5, -0.390625, -0.296875, -0.203125, -0.09375, 0, 0.109375, 0.203125, 0.296875, 0.40625, 0.5, 0.609375, 0.703125, 0.796875, 0.90625<br></p><p>i.e. nearly 10% error for the values closest to zero.<br>– Steve<br></p><p>&gt; On Apr 2, 2016, at 6:30 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; General numerics comments:<br>&gt; We’ll want internal state and computation to be Double for Float or Double, and Float80 for Float80.  This confers a couple significant advantages:<br>&gt; <br>&gt; - There are useful loops with more than 2**31 steps, which means having _step be Int is insufficient on 32-bit systems.  By contrast, 2**53 steps is indistinguishable from “infinite loop” for consumer systems (tens of days for a loop that does no actual work).  At some point, we will want to use a wider state, but Double is sufficient for the foreseeable future, and this can be an internal detail so it’s easy to change if/when we need to so.<br>&gt; <br>&gt; - Using Double is preferable to using Int64 because it allows us to avoid extra Int -&gt; FP conversions, and avoids multi-word arithmetic on 32-bit systems.<br>&gt; <br>&gt; - Using Double internally for Float loops avoids catastrophic cancellation for loops that cross zero, e.g.:<br>&gt; <br>&gt; 	for x in stride(from: Float(-200000), through: Float(1), by: Float(0.1)) {<br>&gt; 	}<br>&gt; <br>&gt; If computed in Float, the last 20 values produced by this are:<br>&gt; <br>&gt; -0.09375, 0, 0.109375, 0.203125, 0.296875, 0.40625, 0.5, 0.609375, 0.703125, 0.796875, 0.90625, 1, 1.109375, 1.203125, 1.296875, 1.40625, 1.5, 1.609375, 1.703125, 1.796875, 1.90625<br>&gt; <br>&gt; Of course, it’s still possible to construct such examples for Double, but they require step size of such wildly disparate scale from the endpoints that you have to loop “forever” (hours/days) before the catastrophic cancellation becomes a significant concern.<br>&gt; <br>&gt; - Double is no less computationally efficient than Float on modern x86 or ARM.<br>&gt; <br>&gt; We should also make sure that we codegen _start + _step*_stride to a fused-multiply add when we have hardware support (x86 Haswell and later, all arm64, most current armv7).  This eliminates the catastrophic cancellation issue *entirely*, and is faster than a separate mul and add to boot.<br>&gt; <br>&gt; One specific question:<br>&gt; I don’t see any reason to enforce that stride isn’t subnormal (and good reasons to allow it).  Why did you add that restriction?<br>&gt; <br>&gt; Other than those notes, this approach seems perfectly workable to me.<br>&gt; <br>&gt; – Steve<br>&gt; <br>&gt;&gt; On Apr 2, 2016, at 3:26 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; All righty, here&#39;s a proof-of-concept for non-error-accumulating<br>&gt;&gt; stride based on the swift-3-indexing-model branch. I tried to<br>&gt;&gt; incorporate the feedback received in the interim. Namely:<br>&gt;&gt; <br>&gt;&gt; 1. Only floating point types get this slightly more computationally<br>&gt;&gt; intensive &quot;new&quot; stride; all other types get the &quot;classic&quot; stride. If<br>&gt;&gt; accepted, this new code could be appended to Stride.swift and exist<br>&gt;&gt; alongside current code, which doesn&#39;t need to be modified.<br>&gt;&gt; <br>&gt;&gt; 2. Based on discussions about UnsafePointer, etc., it dawned on me<br>&gt;&gt; that what really determines whether a StrideTo&lt;T&gt; accumulates error<br>&gt;&gt; isn&#39;t T but rather T.Stride, so based on Dave&#39;s insights above we get<br>&gt;&gt; &quot;new stride&quot; if T.Stride == FloatingPoint.<br>&gt;&gt; <br>&gt;&gt; 3. I need to multiply floating point values, and if I understand<br>&gt;&gt; correctly multiplication will be guaranteed by a revised SignedNumber<br>&gt;&gt; protocol; for now, I&#39;ve used a _FloatingPointStrideable protocol as a<br>&gt;&gt; workaround. Note that Float80 doesn&#39;t conform to FloatingPoint, so it<br>&gt;&gt; isn&#39;t retroactively modeled to conform to _FloatingPointStrideable.<br>&gt;&gt; Nothing&#39;s lost for the moment because we can&#39;t use Float80 values for<br>&gt;&gt; &quot;new stride&quot; anyway, since it doesn&#39;t currently implement the isNormal<br>&gt;&gt; property (see below for why I use that property).<br>&gt;&gt; <br>&gt;&gt; 4. I considered Dave&#39;s suggestion whether we could avoid introducing<br>&gt;&gt; new types, instead modifying the existing StrideToIterator and<br>&gt;&gt; StrideThroughIterator and relying on compiler optimization to turn<br>&gt;&gt; &quot;new&quot; stride into &quot;classic&quot; stride for StrideTo&lt;Int&gt;, etc.; however,<br>&gt;&gt; because the differences between &quot;classic&quot; stride and &quot;new&quot; stride<br>&gt;&gt; extend beyond the iterator&#39;s next() method (see below), I thought it<br>&gt;&gt; best to keep the floating point logic in distinct types.<br>&gt;&gt; <br>&gt;&gt; 5. One difference discussed was how to handle edge cases involving<br>&gt;&gt; lots of iterations; I incorporated Howard&#39;s suggestions here, so<br>&gt;&gt; whether a stride requires more than Int.max steps is tested<br>&gt;&gt; upfront--as a consequence, infinite loops are impossible. I would love<br>&gt;&gt; it if, as Thorsten suggests, we could use BigInts, but of course<br>&gt;&gt; there&#39;s no such type in the stdlib and adding one would have to be<br>&gt;&gt; another discussion altogether.<br>&gt;&gt; <br>&gt;&gt; 6. The stride increment can&#39;t be zero; for a floating point type, it<br>&gt;&gt; also obviously can&#39;t be infinity or NaN. I&#39;m inclined to think that<br>&gt;&gt; subnormal increments should be out of the question as well, so my<br>&gt;&gt; proposed streamlined criterion is simply `stride.isNormal`. Comments<br>&gt;&gt; on this are welcome...<br>&gt;&gt; <br>&gt;&gt; Not included:<br>&gt;&gt; 1. I know Ranges are in flux, so I&#39;ve held off on extending Range with<br>&gt;&gt; a striding(by:) method in this proof-of-concept.<br>&gt;&gt; 2. No attempt at the suggested stride(from:to:steps:) quite yet.<br>&gt;&gt; 2. No tests written yet for this proof-of-concept; I noticed that<br>&gt;&gt; there&#39;s a stub for testing strides with bounds of type Double, but<br>&gt;&gt; there&#39;s a comment about things not being ready because Double conforms<br>&gt;&gt; to RandomIndexType--not sure what to make of that.<br>&gt;&gt; 3. Haven&#39;t gotten around to testing performance.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Mar 30, 2016 at 12:03 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 29, 2016, at 11:26 PM, Xiaodi Wu via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Mar 29, 2016 at 7:48 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Tue Mar 29 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Relatedly, while you&#39;re tackling this big revision:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve tried to play around with what it would take to write a generic<br>&gt;&gt;&gt; non-error-accumulating striding method, and afaict, it would be<br>&gt;&gt;&gt; enormously cleaner if Strideable types are guaranteed to have + and *<br>&gt;&gt;&gt; (well, Strideable.Stride needs *, to be more accurate),<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That should happen automatically, since it conforms to SignedNumber,<br>&gt;&gt;&gt; when we get the Integer protocols updated (project currently on hold while<br>&gt;&gt;&gt; we land this other revision).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; since the iterator needs to be able to compute end = start + iteration<br>&gt;&gt;&gt; * stride.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Don&#39;t you need division too if you&#39;re going to do this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I didn&#39;t seem to ever need division. See attached playground (which<br>&gt;&gt;&gt; borrows shamelessly from existing code and Erica&#39;s proposal, and which<br>&gt;&gt;&gt; is written in Swift 2.2 because that&#39;s what I had handy).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Have you considered trying to extend the `swift-3-indexing-model` branch<br>&gt;&gt;&gt; at the Swift repo to take the floating point approach into account? Dave A<br>&gt;&gt;&gt; is working on a massive overhaul of ranges (including `Countable` items<br>&gt;&gt;&gt; and one would presume floating point closed and open intervals as well),<br>&gt;&gt;&gt; and I&#39;d love to see better implementations of, for example,<br>&gt;&gt;&gt; `(x..&lt;y).striding(by:z)`<br>&gt;&gt;&gt; happen for Double types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d be happy to throw a proposal together based on a proof of concept,<br>&gt;&gt;&gt; if you had the flexibility to work on the coding.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt; <br>&gt;&gt; &lt;FloatingPointStrideable.swift&gt;_______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  3, 2016 at 02:00:00am</p></header><div class="content"><p>On Sat, Apr 2, 2016 at 8:30 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; General numerics comments:<br>&gt; We’ll want internal state and computation to be Double for Float or Double,<br>&gt; and Float80 for Float80.<br></p><p>One argument why Float for Float might be sufficient:<br></p><p>1. Given that `Float(-200000) + Float(1) * Float(199999.9) ==<br>Float(-0.09375)`, -0.09375 *should* be a value in the sequence when<br>striding from Float(-200000) to Float(1) by Float(0.1). Otherwise, it<br>could be astonishing for users that StrideTo&lt;Float&gt; is somehow more<br>accurate than bare arithmetic using Float, since the documentation<br>explains explicitly how the values are being calculated (for stride as<br>it is now, the documentation says &quot;self, self + stride, self + stride<br>+ stride ... last&quot;, which I changed for floating point types to &quot;self,<br>self + stride, self + stride * 2 ... last&quot;). A user that wants<br>double-precision accuracy in that computation should explicitly cast<br>stride arguments to Double.<br></p><p>2. While there are definitely useful loops with more than 2**31 steps,<br>and I agree that we should ensure at least 2**53 steps for<br>`stride&lt;Double&gt;(...)` even on 32-bit systems, loops using<br>`stride&lt;Float&gt;(...)` with more than 2**24 steps should be rare. Users<br>who wish to go beyond 2**24 steps can always cast stride arguments to<br>Double, which has the benefit of being more explicit and less magical.<br></p><p>I&#39;ve played with using Double for Double and Float for Float (which<br>confers, I think, the rest of the advantages over Int named below),<br>but Double for Float is definitely a new twist. One disadvantage is<br>that using Double internally for Float would require Float bounds to<br>be represented internally as Double bounds. I was trying to be clever<br>with the generics so that any stride&lt;T : Strideable where T.Stride :<br>FloatingPoint&gt;(...) would be non-error-accumulating, but I can&#39;t think<br>of a way to do this while also avoiding catastrophic cancellation for<br>Float because the generic algorithm does not care that T and T.Stride<br>have the same precision or, for that matter, whether T is a floating<br>point type at all. Thoughts?<br></p><p>&gt; This confers a couple significant advantages:<br>&gt;<br>&gt; - There are useful loops with more than 2**31 steps, which means having<br>&gt; _step be Int is insufficient on 32-bit systems.  By contrast, 2**53 steps is<br>&gt; indistinguishable from “infinite loop” for consumer systems (tens of days<br>&gt; for a loop that does no actual work).  At some point, we will want to use a<br>&gt; wider state, but Double is sufficient for the foreseeable future, and this<br>&gt; can be an internal detail so it’s easy to change if/when we need to so.<br>&gt;<br>&gt; - Using Double is preferable to using Int64 because it allows us to avoid<br>&gt; extra Int -&gt; FP conversions, and avoids multi-word arithmetic on 32-bit<br>&gt; systems.<br>&gt;<br>&gt; - Using Double internally for Float loops avoids catastrophic cancellation<br>&gt; for loops that cross zero, e.g.:<br>&gt;<br>&gt; for x in stride(from: Float(-200000), through: Float(1), by: Float(0.1)) {<br>&gt; }<br>&gt;<br>&gt; If computed in Float, the last 20 values produced by this are:<br>&gt;<br>&gt; -0.09375, 0, 0.109375, 0.203125, 0.296875, 0.40625, 0.5, 0.609375, 0.703125,<br>&gt; 0.796875, 0.90625, 1, 1.109375, 1.203125, 1.296875, 1.40625, 1.5, 1.609375,<br>&gt; 1.703125, 1.796875, 1.90625<br>&gt;<br>&gt; Of course, it’s still possible to construct such examples for Double, but<br>&gt; they require step size of such wildly disparate scale from the endpoints<br>&gt; that you have to loop “forever” (hours/days) before the catastrophic<br>&gt; cancellation becomes a significant concern.<br>&gt;<br>&gt; - Double is no less computationally efficient than Float on modern x86 or<br>&gt; ARM.<br>&gt;<br>&gt; We should also make sure that we codegen _start + _step*_stride to a<br>&gt; fused-multiply add when we have hardware support (x86 Haswell and later, all<br>&gt; arm64, most current armv7).  This eliminates the catastrophic cancellation<br>&gt; issue *entirely*, and is faster than a separate mul and add to boot.<br>&gt;<br>&gt; One specific question:<br>&gt; I don’t see any reason to enforce that stride isn’t subnormal (and good<br>&gt; reasons to allow it).  Why did you add that restriction?<br></p><p>The restriction was poorly thought out based on a vague notion that<br>&quot;typically sized&quot; ranges and very small strides would be somehow &quot;not<br>good.&quot; I can also now think of some good reasons to change that as<br>well, such that what&#39;s enforced is only `stride.isFinite &amp;&amp;<br>!stride.isZero`.<br></p><p>&gt; Other than those notes, this approach seems perfectly workable to me.<br></p><p>Hurray!<br></p><p>&gt; – Steve<br>&gt;<br>&gt; On Apr 2, 2016, at 3:26 PM, Xiaodi Wu via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; All righty, here&#39;s a proof-of-concept for non-error-accumulating<br>&gt; stride based on the swift-3-indexing-model branch. I tried to<br>&gt; incorporate the feedback received in the interim. Namely:<br>&gt;<br>&gt; 1. Only floating point types get this slightly more computationally<br>&gt; intensive &quot;new&quot; stride; all other types get the &quot;classic&quot; stride. If<br>&gt; accepted, this new code could be appended to Stride.swift and exist<br>&gt; alongside current code, which doesn&#39;t need to be modified.<br>&gt;<br>&gt; 2. Based on discussions about UnsafePointer, etc., it dawned on me<br>&gt; that what really determines whether a StrideTo&lt;T&gt; accumulates error<br>&gt; isn&#39;t T but rather T.Stride, so based on Dave&#39;s insights above we get<br>&gt; &quot;new stride&quot; if T.Stride == FloatingPoint.<br>&gt;<br>&gt; 3. I need to multiply floating point values, and if I understand<br>&gt; correctly multiplication will be guaranteed by a revised SignedNumber<br>&gt; protocol; for now, I&#39;ve used a _FloatingPointStrideable protocol as a<br>&gt; workaround. Note that Float80 doesn&#39;t conform to FloatingPoint, so it<br>&gt; isn&#39;t retroactively modeled to conform to _FloatingPointStrideable.<br>&gt; Nothing&#39;s lost for the moment because we can&#39;t use Float80 values for<br>&gt; &quot;new stride&quot; anyway, since it doesn&#39;t currently implement the isNormal<br>&gt; property (see below for why I use that property).<br>&gt;<br>&gt; 4. I considered Dave&#39;s suggestion whether we could avoid introducing<br>&gt; new types, instead modifying the existing StrideToIterator and<br>&gt; StrideThroughIterator and relying on compiler optimization to turn<br>&gt; &quot;new&quot; stride into &quot;classic&quot; stride for StrideTo&lt;Int&gt;, etc.; however,<br>&gt; because the differences between &quot;classic&quot; stride and &quot;new&quot; stride<br>&gt; extend beyond the iterator&#39;s next() method (see below), I thought it<br>&gt; best to keep the floating point logic in distinct types.<br>&gt;<br>&gt; 5. One difference discussed was how to handle edge cases involving<br>&gt; lots of iterations; I incorporated Howard&#39;s suggestions here, so<br>&gt; whether a stride requires more than Int.max steps is tested<br>&gt; upfront--as a consequence, infinite loops are impossible. I would love<br>&gt; it if, as Thorsten suggests, we could use BigInts, but of course<br>&gt; there&#39;s no such type in the stdlib and adding one would have to be<br>&gt; another discussion altogether.<br>&gt;<br>&gt; 6. The stride increment can&#39;t be zero; for a floating point type, it<br>&gt; also obviously can&#39;t be infinity or NaN. I&#39;m inclined to think that<br>&gt; subnormal increments should be out of the question as well, so my<br>&gt; proposed streamlined criterion is simply `stride.isNormal`. Comments<br>&gt; on this are welcome...<br>&gt;<br>&gt; Not included:<br>&gt; 1. I know Ranges are in flux, so I&#39;ve held off on extending Range with<br>&gt; a striding(by:) method in this proof-of-concept.<br>&gt; 2. No attempt at the suggested stride(from:to:steps:) quite yet.<br>&gt; 2. No tests written yet for this proof-of-concept; I noticed that<br>&gt; there&#39;s a stub for testing strides with bounds of type Double, but<br>&gt; there&#39;s a comment about things not being ready because Double conforms<br>&gt; to RandomIndexType--not sure what to make of that.<br>&gt; 3. Haven&#39;t gotten around to testing performance.<br>&gt;<br>&gt;<br>&gt; On Wed, Mar 30, 2016 at 12:03 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Mar 29, 2016, at 11:26 PM, Xiaodi Wu via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Tue, Mar 29, 2016 at 7:48 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Tue Mar 29 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; Relatedly, while you&#39;re tackling this big revision:<br>&gt;<br>&gt; I&#39;ve tried to play around with what it would take to write a generic<br>&gt; non-error-accumulating striding method, and afaict, it would be<br>&gt; enormously cleaner if Strideable types are guaranteed to have + and *<br>&gt; (well, Strideable.Stride needs *, to be more accurate),<br>&gt;<br>&gt;<br>&gt; That should happen automatically, since it conforms to SignedNumber,<br>&gt; when we get the Integer protocols updated (project currently on hold while<br>&gt; we land this other revision).<br>&gt;<br>&gt; since the iterator needs to be able to compute end = start + iteration<br>&gt; * stride.<br>&gt;<br>&gt;<br>&gt; Don&#39;t you need division too if you&#39;re going to do this?<br>&gt;<br>&gt;<br>&gt; I didn&#39;t seem to ever need division. See attached playground (which<br>&gt; borrows shamelessly from existing code and Erica&#39;s proposal, and which<br>&gt; is written in Swift 2.2 because that&#39;s what I had handy).<br>&gt;<br>&gt;<br>&gt; Have you considered trying to extend the `swift-3-indexing-model` branch<br>&gt; at the Swift repo to take the floating point approach into account? Dave A<br>&gt; is working on a massive overhaul of ranges (including `Countable` items<br>&gt; and one would presume floating point closed and open intervals as well),<br>&gt; and I&#39;d love to see better implementations of, for example,<br>&gt; `(x..&lt;y).striding(by:z)`<br>&gt; happen for Double types.<br>&gt;<br>&gt; I&#39;d be happy to throw a proposal together based on a proof of concept,<br>&gt; if you had the flexibility to work on the coding.<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt; &lt;FloatingPointStrideable.swift&gt;_______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  4, 2016 at 11:00:00am</p></header><div class="content"><p>on Sat Apr 02 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; All righty, here&#39;s a proof-of-concept for non-error-accumulating<br>&gt; stride based on the swift-3-indexing-model branch. I tried to<br>&gt; incorporate the feedback received in the interim. Namely:<br>&gt;<br>&gt; 1. Only floating point types get this slightly more computationally<br>&gt; intensive &quot;new&quot; stride; all other types get the &quot;classic&quot; stride. If<br>&gt; accepted, this new code could be appended to Stride.swift and exist<br>&gt; alongside current code, which doesn&#39;t need to be modified.<br>&gt;<br>&gt; 2. Based on discussions about UnsafePointer, etc., it dawned on me<br>&gt; that what really determines whether a StrideTo&lt;T&gt; accumulates error<br>&gt; isn&#39;t T but rather T.Stride, so based on Dave&#39;s insights above we get<br>&gt; &quot;new stride&quot; if T.Stride == FloatingPoint.<br>&gt;<br>&gt; 3. I need to multiply floating point values, and if I understand<br>&gt; correctly multiplication will be guaranteed by a revised SignedNumber<br>&gt; protocol; for now, I&#39;ve used a _FloatingPointStrideable protocol as a<br>&gt; workaround. Note that Float80 doesn&#39;t conform to FloatingPoint, so it<br>&gt; isn&#39;t retroactively modeled to conform to _FloatingPointStrideable.<br>&gt; Nothing&#39;s lost for the moment because we can&#39;t use Float80 values for<br>&gt; &quot;new stride&quot; anyway, since it doesn&#39;t currently implement the isNormal<br>&gt; property (see below for why I use that property).<br>&gt;<br>&gt; 4. I considered Dave&#39;s suggestion whether we could avoid introducing<br>&gt; new types, instead modifying the existing StrideToIterator and<br>&gt; StrideThroughIterator and relying on compiler optimization to turn<br>&gt; &quot;new&quot; stride into &quot;classic&quot; stride for StrideTo&lt;Int&gt;, etc.; however,<br>&gt; because the differences between &quot;classic&quot; stride and &quot;new&quot; stride<br>&gt; extend beyond the iterator&#39;s next() method (see below), I thought it<br>&gt; best to keep the floating point logic in distinct types.<br>&gt;<br>&gt; 5. One difference discussed was how to handle edge cases involving<br>&gt; lots of iterations; I incorporated Howard&#39;s suggestions here, so<br>&gt; whether a stride requires more than Int.max steps is tested<br>&gt; upfront--as a consequence, infinite loops are impossible. I would love<br>&gt; it if, as Thorsten suggests, we could use BigInts, but of course<br>&gt; there&#39;s no such type in the stdlib and adding one would have to be<br>&gt; another discussion altogether.<br>&gt;<br>&gt; 6. The stride increment can&#39;t be zero; for a floating point type, it<br>&gt; also obviously can&#39;t be infinity or NaN. I&#39;m inclined to think that<br>&gt; subnormal increments should be out of the question as well, so my<br>&gt; proposed streamlined criterion is simply `stride.isNormal`. Comments<br>&gt; on this are welcome...<br>&gt;<br>&gt; Not included:<br>&gt; 1. I know Ranges are in flux, so I&#39;ve held off on extending Range with<br>&gt; a striding(by:) method in this proof-of-concept.<br></p><p>They&#39;re not in flux, except for not having been reviewed yet; they are<br>settled in the swift-3-indexing-model branch.<br></p><p>&gt; 2. No attempt at the suggested stride(from:to:steps:) quite yet.<br></p><p>#1 and #2 are mutually exclusive; we prefer #1 as it removes questions<br>about the meaning of &quot;to&quot; or &quot;through.&quot;<br></p><p>&gt; 2. No tests written yet for this proof-of-concept; I noticed that<br>&gt; there&#39;s a stub for testing strides with bounds of type Double, but<br>&gt; there&#39;s a comment about things not being ready because Double conforms<br>&gt; to RandomIndexType--not sure what to make of that.  <br></p><p>Comments in that branch are badly out-of-date.  It&#39;s worth trying that,<br>especially since there is no RandomAccessIndexType in that branch any<br>longer.<br></p><p>&gt; 3. Haven&#39;t gotten around to testing performance.<br>&gt;<br>&gt; On Wed, Mar 30, 2016 at 12:03 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Mar 29, 2016, at 11:26 PM, Xiaodi Wu via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Tue, Mar 29, 2016 at 7:48 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; on Tue Mar 29 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Relatedly, while you&#39;re tackling this big revision:<br>&gt;&gt;<br>&gt;&gt; I&#39;ve tried to play around with what it would take to write a generic<br>&gt;&gt; non-error-accumulating striding method, and afaict, it would be<br>&gt;&gt; enormously cleaner if Strideable types are guaranteed to have + and *<br>&gt;&gt; (well, Strideable.Stride needs *, to be more accurate),<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That should happen automatically, since it conforms to SignedNumber,<br>&gt;&gt; when we get the Integer protocols updated (project currently on hold while<br>&gt;&gt; we land this other revision).<br>&gt;&gt;<br>&gt;&gt; since the iterator needs to be able to compute end = start + iteration<br>&gt;&gt; * stride.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Don&#39;t you need division too if you&#39;re going to do this?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I didn&#39;t seem to ever need division. See attached playground (which<br>&gt;&gt; borrows shamelessly from existing code and Erica&#39;s proposal, and which<br>&gt;&gt; is written in Swift 2.2 because that&#39;s what I had handy).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Have you considered trying to extend the `swift-3-indexing-model` branch<br>&gt;&gt; at the Swift repo to take the floating point approach into account? Dave A<br>&gt;&gt; is working on a massive overhaul of ranges (including `Countable` items<br>&gt;&gt; and one would presume floating point closed and open intervals as well),<br>&gt;&gt; and I&#39;d love to see better implementations of, for example,<br>&gt;&gt; `(x..&lt;y).striding(by:z)`<br>&gt;&gt; happen for Double types.<br>&gt;&gt;<br>&gt;&gt; I&#39;d be happy to throw a proposal together based on a proof of concept,<br>&gt;&gt; if you had the flexibility to work on the coding.<br>&gt;&gt;<br>&gt;&gt; -- Erica<br>&gt;&gt;<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  5, 2016 at 10:00:00am</p></header><div class="content"><p>On Mon, Apr 4, 2016 at 1:22 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt; on Sat Apr 02 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; [snip]<br>&gt;&gt;<br>&gt;&gt; Not included:<br>&gt;&gt; 1. I know Ranges are in flux, so I&#39;ve held off on extending Range with<br>&gt;&gt; a striding(by:) method in this proof-of-concept.<br>&gt;<br>&gt; They&#39;re not in flux, except for not having been reviewed yet; they are<br>&gt; settled in the swift-3-indexing-model branch.<br></p><p>Did not know that. Will have to study what&#39;s there in more detail.<br></p><p>&gt;&gt; 2. No attempt at the suggested stride(from:to:steps:) quite yet.<br>&gt;<br>&gt; #1 and #2 are mutually exclusive; we prefer #1 as it removes questions<br>&gt; about the meaning of &quot;to&quot; or &quot;through.&quot;<br></p><p>I wasn&#39;t aware that was the thinking. Limiting strides to<br>`striding(by:)` removes the ability to express `stride(from: 0, to:<br>-10, by: -1)` because Range enforces (and it looks like it will<br>continue to do so in the swift-3-indexing-model branch?) `lowerBound<br>&lt;= upperBound`, and in a half-open range it&#39;s the upper bound that&#39;s<br>excluded.<br></p><p>&gt;&gt; 2. No tests written yet for this proof-of-concept; I noticed that<br>&gt;&gt; there&#39;s a stub for testing strides with bounds of type Double, but<br>&gt;&gt; there&#39;s a comment about things not being ready because Double conforms<br>&gt;&gt; to RandomIndexType--not sure what to make of that.<br>&gt;<br>&gt; Comments in that branch are badly out-of-date.  It&#39;s worth trying that,<br>&gt; especially since there is no RandomAccessIndexType in that branch any<br>&gt; longer.<br>&gt;<br>&gt;&gt; 3. Haven&#39;t gotten around to testing performance.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  5, 2016 at 12:00:00pm</p></header><div class="content"><p>on Tue Apr 05 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Mon, Apr 4, 2016 at 1:22 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; on Sat Apr 02 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; [snip]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Not included:<br>&gt;&gt;&gt; 1. I know Ranges are in flux, so I&#39;ve held off on extending Range with<br>&gt;&gt;&gt; a striding(by:) method in this proof-of-concept.<br>&gt;&gt;<br>&gt;&gt; They&#39;re not in flux, except for not having been reviewed yet; they are<br>&gt;&gt; settled in the swift-3-indexing-model branch.<br>&gt;<br>&gt; Did not know that. Will have to study what&#39;s there in more detail.<br>&gt;<br>&gt;&gt;&gt; 2. No attempt at the suggested stride(from:to:steps:) quite yet.<br>&gt;&gt;<br>&gt;&gt; #1 and #2 are mutually exclusive; we prefer #1 as it removes questions<br>&gt;&gt; about the meaning of &quot;to&quot; or &quot;through.&quot;<br>&gt;<br>&gt; I wasn&#39;t aware that was the thinking. Limiting strides to<br>&gt; `striding(by:)` removes the ability to express `stride(from: 0, to:<br>&gt; -10, by: -1)` <br></p><p>IMO this:<br></p><p>  (-9...0).reverse()<br></p><p>is better than <br></p><p>  stride(from: 0, to: -10, by: -1)<br></p><p>What do you think?<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  5, 2016 at 08:00:00pm</p></header><div class="content"><p>Certainly, for integer literals and strides of -1.<br></p><p>I meant more generally that removal of stride(...) will eliminate the<br>possibility of striding to but not through arbitrary half-open intervals<br>(a, b], where a &lt; b, by a negative increment, because there is no such<br>thing as `a&gt;..b` to express such an interval as a Swift range.<br></p><p>Of course, all such cases can be handled by adjusting the endpoint and<br>using a closed range instead, but the same can be said for all half-open<br>ranges.<br>On Tue, Apr 5, 2016 at 2:54 PM Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; on Tue Apr 05 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; On Mon, Apr 4, 2016 at 1:22 PM, Dave Abrahams &lt;dabrahams at apple.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Sat Apr 02 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; [snip]<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Not included:<br>&gt; &gt;&gt;&gt; 1. I know Ranges are in flux, so I&#39;ve held off on extending Range with<br>&gt; &gt;&gt;&gt; a striding(by:) method in this proof-of-concept.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; They&#39;re not in flux, except for not having been reviewed yet; they are<br>&gt; &gt;&gt; settled in the swift-3-indexing-model branch.<br>&gt; &gt;<br>&gt; &gt; Did not know that. Will have to study what&#39;s there in more detail.<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; 2. No attempt at the suggested stride(from:to:steps:) quite yet.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; #1 and #2 are mutually exclusive; we prefer #1 as it removes questions<br>&gt; &gt;&gt; about the meaning of &quot;to&quot; or &quot;through.&quot;<br>&gt; &gt;<br>&gt; &gt; I wasn&#39;t aware that was the thinking. Limiting strides to<br>&gt; &gt; `striding(by:)` removes the ability to express `stride(from: 0, to:<br>&gt; &gt; -10, by: -1)`<br>&gt;<br>&gt; IMO this:<br>&gt;<br>&gt;   (-9...0).reverse()<br>&gt;<br>&gt; is better than<br>&gt;<br>&gt;   stride(from: 0, to: -10, by: -1)<br>&gt;<br>&gt; What do you think?<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/b475c4af/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April  5, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 5 Apr 2016, at 20:54, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; IMO this:<br>&gt; <br>&gt;  (-9...0).reverse()<br>&gt; <br>&gt; is better than <br>&gt; <br>&gt;  stride(from: 0, to: -10, by: -1)<br>&gt; <br>&gt; What do you think?<br>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>Are we absolutely certain that an operator could not be found such that (I use `&lt;` and `&gt;` here for illustrative purposes only):<br></p><p>    for i in 1...5 &gt; 2 {<br>        i // 1, 3, 5<br>    }<br></p><p>    for i in 1...5 &lt; 2 {<br>        i // 5, 3, 1<br>    }<br></p><p>milos<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/f88ed712/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April  6, 2016 at 06:00:00am</p></header><div class="content"><p>I much prefer (0 ... -9).by(-1) and  (0 ..&lt; -10).by(-1)<br></p><p>On Wednesday, 6 April 2016, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Tue Apr 05 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; On Mon, Apr 4, 2016 at 1:22 PM, Dave Abrahams &lt;dabrahams at apple.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Sat Apr 02 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; [snip]<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Not included:<br>&gt; &gt;&gt;&gt; 1. I know Ranges are in flux, so I&#39;ve held off on extending Range with<br>&gt; &gt;&gt;&gt; a striding(by:) method in this proof-of-concept.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; They&#39;re not in flux, except for not having been reviewed yet; they are<br>&gt; &gt;&gt; settled in the swift-3-indexing-model branch.<br>&gt; &gt;<br>&gt; &gt; Did not know that. Will have to study what&#39;s there in more detail.<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; 2. No attempt at the suggested stride(from:to:steps:) quite yet.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; #1 and #2 are mutually exclusive; we prefer #1 as it removes questions<br>&gt; &gt;&gt; about the meaning of &quot;to&quot; or &quot;through.&quot;<br>&gt; &gt;<br>&gt; &gt; I wasn&#39;t aware that was the thinking. Limiting strides to<br>&gt; &gt; `striding(by:)` removes the ability to express `stride(from: 0, to:<br>&gt; &gt; -10, by: -1)`<br>&gt;<br>&gt; IMO this:<br>&gt;<br>&gt;   (-9...0).reverse()<br>&gt;<br>&gt; is better than<br>&gt;<br>&gt;   stride(from: 0, to: -10, by: -1)<br>&gt;<br>&gt; What do you think?<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/80955e1e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  5, 2016 at 08:00:00pm</p></header><div class="content"><p>Howard, the point I am raising is that `0...(-9)` is not valid Swift<br>because the first, &quot;lower&quot; bound is enforced to be less than the second,<br>&quot;upper&quot; bound.<br></p><p>The problem is that with that restriction certain types of half-open<br>intervals, namely those where the lower bound is the one being excluded,<br>cannot be represented as a Range either currently or in Dave A&#39;s branch.<br>On Tue, Apr 5, 2016 at 3:30 PM Howard Lovatt &lt;howard.lovatt at gmail.com&gt;<br>wrote:<br></p><p>&gt; I much prefer (0 ... -9).by(-1) and  (0 ..&lt; -10).by(-1)<br>&gt;<br>&gt; On Wednesday, 6 April 2016, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Tue Apr 05 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; On Mon, Apr 4, 2016 at 1:22 PM, Dave Abrahams &lt;dabrahams at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; on Sat Apr 02 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; [snip]<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Not included:<br>&gt;&gt; &gt;&gt;&gt; 1. I know Ranges are in flux, so I&#39;ve held off on extending Range with<br>&gt;&gt; &gt;&gt;&gt; a striding(by:) method in this proof-of-concept.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; They&#39;re not in flux, except for not having been reviewed yet; they are<br>&gt;&gt; &gt;&gt; settled in the swift-3-indexing-model branch.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Did not know that. Will have to study what&#39;s there in more detail.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; 2. No attempt at the suggested stride(from:to:steps:) quite yet.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; #1 and #2 are mutually exclusive; we prefer #1 as it removes questions<br>&gt;&gt; &gt;&gt; about the meaning of &quot;to&quot; or &quot;through.&quot;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I wasn&#39;t aware that was the thinking. Limiting strides to<br>&gt;&gt; &gt; `striding(by:)` removes the ability to express `stride(from: 0, to:<br>&gt;&gt; &gt; -10, by: -1)`<br>&gt;&gt;<br>&gt;&gt; IMO this:<br>&gt;&gt;<br>&gt;&gt;   (-9...0).reverse()<br>&gt;&gt;<br>&gt;&gt; is better than<br>&gt;&gt;<br>&gt;&gt;   stride(from: 0, to: -10, by: -1)<br>&gt;&gt;<br>&gt;&gt; What do you think?<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; -- Howard.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/d5cc4730/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April  6, 2016 at 06:00:00am</p></header><div class="content"><p>Yes I know what you are saying and I am suggesting changing that so that:<br></p><p> (0 ... -9) and  (0 ..&lt; -10)<br></p><p>Are both empty ranges rather than errors because they implicitly have a<br>&#39;by&#39; of 1.<br></p><p>On Wednesday, 6 April 2016, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; Howard, the point I am raising is that `0...(-9)` is not valid Swift<br>&gt; because the first, &quot;lower&quot; bound is enforced to be less than the second,<br>&gt; &quot;upper&quot; bound.<br>&gt;<br>&gt; The problem is that with that restriction certain types of half-open<br>&gt; intervals, namely those where the lower bound is the one being excluded,<br>&gt; cannot be represented as a Range either currently or in Dave A&#39;s branch.<br>&gt; On Tue, Apr 5, 2016 at 3:30 PM Howard Lovatt &lt;howard.lovatt at gmail.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;howard.lovatt at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; I much prefer (0 ... -9).by(-1) and  (0 ..&lt; -10).by(-1)<br>&gt;&gt;<br>&gt;&gt; On Wednesday, 6 April 2016, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; on Tue Apr 05 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Mon, Apr 4, 2016 at 1:22 PM, Dave Abrahams &lt;dabrahams at apple.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; on Sat Apr 02 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; [snip]<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Not included:<br>&gt;&gt;&gt; &gt;&gt;&gt; 1. I know Ranges are in flux, so I&#39;ve held off on extending Range<br>&gt;&gt;&gt; with<br>&gt;&gt;&gt; &gt;&gt;&gt; a striding(by:) method in this proof-of-concept.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; They&#39;re not in flux, except for not having been reviewed yet; they are<br>&gt;&gt;&gt; &gt;&gt; settled in the swift-3-indexing-model branch.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Did not know that. Will have to study what&#39;s there in more detail.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; 2. No attempt at the suggested stride(from:to:steps:) quite yet.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; #1 and #2 are mutually exclusive; we prefer #1 as it removes questions<br>&gt;&gt;&gt; &gt;&gt; about the meaning of &quot;to&quot; or &quot;through.&quot;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I wasn&#39;t aware that was the thinking. Limiting strides to<br>&gt;&gt;&gt; &gt; `striding(by:)` removes the ability to express `stride(from: 0, to:<br>&gt;&gt;&gt; &gt; -10, by: -1)`<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMO this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   (-9...0).reverse()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; is better than<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   stride(from: 0, to: -10, by: -1)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What do you think?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; -- Howard.<br>&gt;&gt;<br>&gt;<br></p><p>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/83db8396/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  5, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Apr 5, 2016, at 1:54 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; IMO this:<br>&gt; <br>&gt;  (-9...0).reverse()<br>&gt; <br>&gt; is better than <br>&gt; <br>&gt;  stride(from: 0, to: -10, by: -1)<br>&gt; <br>&gt; What do you think?<br></p><p>The latter better reflects an author&#39;s actual intent. The former depends on implementation details, which can be hazy, especially, around the edge cases. It is quicker to read, understand, and verify that the latter is what is meant.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/663b2f2a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 30, 2016 at 11:00:00am</p></header><div class="content"><p>on Tue Mar 29 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Tue, Mar 29, 2016 at 7:48 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; on Tue Mar 29 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Relatedly, while you&#39;re tackling this big revision:<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt; I&#39;ve tried to play around with what it would take to write a generic<br>&gt;&gt;&gt; non-error-accumulating striding method, and afaict, it would be<br>&gt;&gt;&gt; enormously cleaner if Strideable types are guaranteed to have + and *<br>&gt;&gt;&gt; (well, Strideable.Stride needs *, to be more accurate),<br>&gt;&gt;<br>&gt;&gt; That should happen automatically, since it conforms to SignedNumber,<br>&gt;&gt; when we get the Integer protocols updated (project currently on hold while<br>&gt;&gt; we land this other revision).<br>&gt;&gt;<br>&gt;&gt;&gt; since the iterator needs to be able to compute end = start + iteration<br>&gt;&gt;&gt; * stride.<br>&gt;&gt;<br>&gt;&gt; Don&#39;t you need division too if you&#39;re going to do this?<br>&gt;<br>&gt; I didn&#39;t seem to ever need division. See attached playground (which<br>&gt; borrows shamelessly from existing code and Erica&#39;s proposal, and which<br>&gt; is written in Swift 2.2 because that&#39;s what I had handy).<br></p><p>I guess it depends what semantics you want.  Maybe the semantics that<br>need division are better suited to a different API:<br></p><p>  (a..&lt;b).striding(stepCount: 10)<br></p><p>&gt;&gt;&gt; Is that going to be exposed somewhere in the cascade of numeric<br>&gt;&gt;&gt; protocols that culminate in Strideable?<br>&gt;&gt;<br>&gt;&gt; That&#39;s not in the plan.  I&#39;m pretty sure we want UnsafePointer to be<br>&gt;&gt; Strideable and we don&#39;t want it to have multiplication or division.<br>&gt;<br>&gt; You&#39;re right. The type itself doesn&#39;t need to have multiplication or<br>&gt; division. In fact, writing this, I&#39;m going back and changing my<br>&gt; playground a bit. It&#39;s sufficient that UnsafePointer.Stride can be<br>&gt; multiplied, and if SignedNumber conformance will guarantee<br>&gt; multiplication for all conforming types, we&#39;re all set for floating<br>&gt; point.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; I was thinking the StrideSequence (or some such) should be exposed as an<br>&gt;&gt; associated type of the Strideable, so it can be as efficient as possible<br>&gt;&gt; when no FP error is possible.  We don&#39;t want to spend divisions on<br>&gt;&gt; striding over Ints.<br>&gt;<br>&gt; Right, multiplication or division best avoided here. Not sure what the<br>&gt; associated type StrideSequence would be for though? <br></p><p>Well, the multiplications can likely be optimized away, so maybe it&#39;s a<br>non-issue. It&#39;s really worth looking at the code you get at -O, to see<br>if we can avoid complicating the API.<br></p><p>The thinking was that a Strideable type could have a StrideSequence with<br>a default of StrideByAdding&lt;Self&gt;, while FloatingPoint types would use<br>StrideSequence = StrideByMultiplying&lt;Self&gt;.<br></p><p>&gt; Are you aiming for one StrideTo type and one StrideThrough type<br>&gt; instead of two apiece<br></p><p>Either way would be reasonable, depending on how well it optimizes.<br></p><p>&gt; , one for floating point and one for integer?<br></p><p>No, one for FP and one for most everything else.<br></p><p>&gt; I&#39;ve been lazy and overloading `stride(from:to:by:)` instead, but<br>&gt; there&#39;s a lot of repeated code.<br>&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On Mon, Mar 28, 2016 at 7:45 PM Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     on Mon Mar 28 2016, Dave Abrahams &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     &gt; on Mon Mar 28 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;     &gt;<br>&gt;&gt;&gt;     &gt;&gt;&gt; On Mar 28, 2016, at 3:54 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;&gt;     &gt;&gt;&gt; on Mon Mar 28 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;&gt;     &gt;&gt;<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt; On Mar 28, 2016, at 3:25 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt; on Mon Mar 28 2016, Xiaodi Wu<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; Right, Countable could refine Strideable. I&#39;m no expert on this, but<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; some cursory reading suggests that the analogous feature in C++ simply<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; requires the type to have operator++ defined. Obviously, that won&#39;t<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; work for Swift 3.0...<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt; Hmm, instead of defining a new protocol (Countable), what if we just use<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt; “Strideable where Stride : Integer” as a constraint?<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt; I like a differentiation between continuous and discrete things<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt; although both can have ranges, membership, fences,<br>&gt;&gt;&gt;     &gt;&gt;&gt;&gt; and a way to stride through them<br>&gt;&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;&gt;     &gt;&gt;&gt; Strideable where Stride : Integer expresses just exactly that. Now if I<br>&gt;&gt;&gt;     &gt;&gt;&gt; could only get the type-checker to cooperate...<br>&gt;&gt;&gt;     &gt;&gt;<br>&gt;&gt;&gt;     &gt;&gt; I am ridiculously excited about what you&#39;re doing there.<br>&gt;&gt;&gt;     &gt;&gt; Looking forward to beautiful floating point strides if for no<br>&gt;&gt;&gt;     &gt;&gt; other reason than I can point out how well they work for math<br>&gt;&gt;&gt;     &gt;&gt; in comparison to traditional for;;loops, so maybe people will<br>&gt;&gt;&gt;     &gt;&gt; stop burning semicolons on my lawn.<br>&gt;&gt;&gt;     &gt;<br>&gt;&gt;&gt;     &gt; The basics:<br>&gt;&gt;&gt;     &gt; https://github.com/apple/swift/commit/a5c3c63c3d5d940f729c23aab342ea4d270d264a<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Hi Erica,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     After some consideration, while I want to see the smart<br>&gt;&gt;&gt;     (x..&lt;y).striding(by: z) stuff happen too, it&#39;s somewhat incidental to<br>&gt;&gt;&gt;     the (already massive) project we&#39;re undertaking in this branch. Would<br>&gt;&gt;&gt;     you like to take on the implementation and/or proposal? I&#39;d be happy to<br>&gt;&gt;&gt;     provide guidance.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     --<br>&gt;&gt;&gt;     Dave<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     _______________________________________________<br>&gt;&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;&gt;     swift-evolution at swift.org<br>&gt;&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>March 31, 2016 at 12:00:00pm</p></header><div class="content"><p>Thoughts on an edge case: so long as it&#39;s possible to use<br>`stride(from:to:by:)` with Double, we&#39;ll need to figure out what<br>happens when you have `stride(from: 0.0, to: DBL_MAX, by: DBL_MIN)`.<br>Bounds may be unknown at compile time, obviously.<br></p><p>Currently (this is by reasoning through the code, not actually<br>observing it run), `for i in stride(from: 0.0, to: DBL_MAX, by:<br>DBL_MIN) { }` degenerates into an infinite loop once you reach<br>sufficient large values such that `current + stride == current`, which<br>for a stride of DBL_MIN should happen pretty quickly.<br></p><p>In Erica&#39;s proposed floating point Stride, an Int is used to count<br>iterations (and iterations need to be counted in order to avoid<br>accumulating error). Thus, one must break from `for i in stride(from:<br>0.0, to: DBL_MAX, by: DBL_MIN) { }` before the iteration counter<br>overflows or it will trap. IMO, trapping at some point is fine, but I<br>think a limit of Int.max iterations might be rather arbitrary for a<br>StrideTo&lt;Double&gt; (or whatever it will be named) and I&#39;m not sure how<br>one can justify why the behavior of StrideTo&lt;Double&gt; would change from<br>machine to machine based on the size of Int.<br></p><p>I&#39;ve been waffling between using an Int counter as Erica does or a<br>counter of type Strideable.Stride in `StrideTo&lt;Strideable where<br>Strideable.Stride : FloatingPoint&gt;`. In the latter alternative, no<br>trapping occurs, but error begins to accumulate when the iteration<br>counter is too large to represent integers exactly (e.g., 2^53 for<br>Double). In that case, `for i in stride(from: 0.0, to: DBL_MAX, by:<br>DBL_MIN) { }` degenerates into an infinite loop eventually (once<br>`iterationCount + 1.0 == iterationCount`) and never traps, which I&#39;m<br>not sure I like, but a limit of 2^53 iterations bears at least a<br>rational connection to Double and is known at compile time independent<br>of the supplied bounds. We could alternatively return nil on reaching<br>2^53 iterations, trap, etc.<br></p><p>Comments?<br></p><p><br>On Wed, Mar 30, 2016 at 1:42 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt; on Tue Mar 29 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Tue, Mar 29, 2016 at 7:48 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; on Tue Mar 29 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Relatedly, while you&#39;re tackling this big revision:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;ve tried to play around with what it would take to write a generic<br>&gt;&gt;&gt;&gt; non-error-accumulating striding method, and afaict, it would be<br>&gt;&gt;&gt;&gt; enormously cleaner if Strideable types are guaranteed to have + and *<br>&gt;&gt;&gt;&gt; (well, Strideable.Stride needs *, to be more accurate),<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That should happen automatically, since it conforms to SignedNumber,<br>&gt;&gt;&gt; when we get the Integer protocols updated (project currently on hold while<br>&gt;&gt;&gt; we land this other revision).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; since the iterator needs to be able to compute end = start + iteration<br>&gt;&gt;&gt;&gt; * stride.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Don&#39;t you need division too if you&#39;re going to do this?<br>&gt;&gt;<br>&gt;&gt; I didn&#39;t seem to ever need division. See attached playground (which<br>&gt;&gt; borrows shamelessly from existing code and Erica&#39;s proposal, and which<br>&gt;&gt; is written in Swift 2.2 because that&#39;s what I had handy).<br>&gt;<br>&gt; I guess it depends what semantics you want.  Maybe the semantics that<br>&gt; need division are better suited to a different API:<br>&gt;<br>&gt;   (a..&lt;b).striding(stepCount: 10)<br>&gt;<br>&gt;&gt;&gt;&gt; Is that going to be exposed somewhere in the cascade of numeric<br>&gt;&gt;&gt;&gt; protocols that culminate in Strideable?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That&#39;s not in the plan.  I&#39;m pretty sure we want UnsafePointer to be<br>&gt;&gt;&gt; Strideable and we don&#39;t want it to have multiplication or division.<br>&gt;&gt;<br>&gt;&gt; You&#39;re right. The type itself doesn&#39;t need to have multiplication or<br>&gt;&gt; division. In fact, writing this, I&#39;m going back and changing my<br>&gt;&gt; playground a bit. It&#39;s sufficient that UnsafePointer.Stride can be<br>&gt;&gt; multiplied, and if SignedNumber conformance will guarantee<br>&gt;&gt; multiplication for all conforming types, we&#39;re all set for floating<br>&gt;&gt; point.<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I was thinking the StrideSequence (or some such) should be exposed as an<br>&gt;&gt;&gt; associated type of the Strideable, so it can be as efficient as possible<br>&gt;&gt;&gt; when no FP error is possible.  We don&#39;t want to spend divisions on<br>&gt;&gt;&gt; striding over Ints.<br>&gt;&gt;<br>&gt;&gt; Right, multiplication or division best avoided here. Not sure what the<br>&gt;&gt; associated type StrideSequence would be for though?<br>&gt;<br>&gt; Well, the multiplications can likely be optimized away, so maybe it&#39;s a<br>&gt; non-issue. It&#39;s really worth looking at the code you get at -O, to see<br>&gt; if we can avoid complicating the API.<br>&gt;<br>&gt; The thinking was that a Strideable type could have a StrideSequence with<br>&gt; a default of StrideByAdding&lt;Self&gt;, while FloatingPoint types would use<br>&gt; StrideSequence = StrideByMultiplying&lt;Self&gt;.<br>&gt;<br>&gt;&gt; Are you aiming for one StrideTo type and one StrideThrough type<br>&gt;&gt; instead of two apiece<br>&gt;<br>&gt; Either way would be reasonable, depending on how well it optimizes.<br>&gt;<br>&gt;&gt; , one for floating point and one for integer?<br>&gt;<br>&gt; No, one for FP and one for most everything else.<br>&gt;<br>&gt;&gt; I&#39;ve been lazy and overloading `stride(from:to:by:)` instead, but<br>&gt;&gt; there&#39;s a lot of repeated code.<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Mon, Mar 28, 2016 at 7:45 PM Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     on Mon Mar 28 2016, Dave Abrahams &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     &gt; on Mon Mar 28 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;     &gt;<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt; On Mar 28, 2016, at 3:54 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt; on Mon Mar 28 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     &gt;&gt;<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt; On Mar 28, 2016, at 3:25 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt; on Mon Mar 28 2016, Xiaodi Wu<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; Right, Countable could refine Strideable. I&#39;m no expert on this, but<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; some cursory reading suggests that the analogous feature in C++ simply<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; requires the type to have operator++ defined. Obviously, that won&#39;t<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; work for Swift 3.0...<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt; Hmm, instead of defining a new protocol (Countable), what if we just use<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt;&gt; “Strideable where Stride : Integer” as a constraint?<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt; I like a differentiation between continuous and discrete things<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt; although both can have ranges, membership, fences,<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;&gt; and a way to stride through them<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt; Strideable where Stride : Integer expresses just exactly that. Now if I<br>&gt;&gt;&gt;&gt;     &gt;&gt;&gt; could only get the type-checker to cooperate...<br>&gt;&gt;&gt;&gt;     &gt;&gt;<br>&gt;&gt;&gt;&gt;     &gt;&gt; I am ridiculously excited about what you&#39;re doing there.<br>&gt;&gt;&gt;&gt;     &gt;&gt; Looking forward to beautiful floating point strides if for no<br>&gt;&gt;&gt;&gt;     &gt;&gt; other reason than I can point out how well they work for math<br>&gt;&gt;&gt;&gt;     &gt;&gt; in comparison to traditional for;;loops, so maybe people will<br>&gt;&gt;&gt;&gt;     &gt;&gt; stop burning semicolons on my lawn.<br>&gt;&gt;&gt;&gt;     &gt;<br>&gt;&gt;&gt;&gt;     &gt; The basics:<br>&gt;&gt;&gt;&gt;     &gt; https://github.com/apple/swift/commit/a5c3c63c3d5d940f729c23aab342ea4d270d264a<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Hi Erica,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     After some consideration, while I want to see the smart<br>&gt;&gt;&gt;&gt;     (x..&lt;y).striding(by: z) stuff happen too, it&#39;s somewhat incidental to<br>&gt;&gt;&gt;&gt;     the (already massive) project we&#39;re undertaking in this branch. Would<br>&gt;&gt;&gt;&gt;     you like to take on the implementation and/or proposal? I&#39;d be happy to<br>&gt;&gt;&gt;&gt;     provide guidance.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     --<br>&gt;&gt;&gt;&gt;     Dave<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     _______________________________________________<br>&gt;&gt;&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;&gt;&gt;     swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Dave<br>&gt;&gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 31, 2016 at 11:00:00am</p></header><div class="content"><p>on Thu Mar 31 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; Thoughts on an edge case: so long as it&#39;s possible to use<br>&gt; `stride(from:to:by:)` with Double, we&#39;ll need to figure out what<br>&gt; happens when you have `stride(from: 0.0, to: DBL_MAX, by: DBL_MIN)`.<br>&gt; Bounds may be unknown at compile time, obviously.<br>&gt;<br>&gt; Currently (this is by reasoning through the code, not actually<br>&gt; observing it run), `for i in stride(from: 0.0, to: DBL_MAX, by:<br>&gt; DBL_MIN) { }` degenerates into an infinite loop once you reach<br>&gt; sufficient large values such that `current + stride == current`, which<br>&gt; for a stride of DBL_MIN should happen pretty quickly.<br>&gt;<br>&gt; In Erica&#39;s proposed floating point Stride, an Int is used to count<br>&gt; iterations (and iterations need to be counted in order to avoid<br>&gt; accumulating error). Thus, one must break from `for i in stride(from:<br>&gt; 0.0, to: DBL_MAX, by: DBL_MIN) { }` before the iteration counter<br>&gt; overflows or it will trap. IMO, trapping at some point is fine, but I<br>&gt; think a limit of Int.max iterations might be rather arbitrary for a<br>&gt; StrideTo&lt;Double&gt; (or whatever it will be named) and I&#39;m not sure how<br>&gt; one can justify why the behavior of StrideTo&lt;Double&gt; would change from<br>&gt; machine to machine based on the size of Int.<br>&gt;<br>&gt; I&#39;ve been waffling between using an Int counter as Erica does or a<br>&gt; counter of type Strideable.Stride in `StrideTo&lt;Strideable where<br>&gt; Strideable.Stride : FloatingPoint&gt;`. In the latter alternative, no<br>&gt; trapping occurs, but error begins to accumulate when the iteration<br>&gt; counter is too large to represent integers exactly (e.g., 2^53 for<br>&gt; Double). In that case, `for i in stride(from: 0.0, to: DBL_MAX, by:<br>&gt; DBL_MIN) { }` degenerates into an infinite loop eventually (once<br>&gt; `iterationCount + 1.0 == iterationCount`) and never traps, which I&#39;m<br>&gt; not sure I like, but a limit of 2^53 iterations bears at least a<br>&gt; rational connection to Double and is known at compile time independent<br>&gt; of the supplied bounds. We could alternatively return nil on reaching<br>&gt; 2^53 iterations, trap, etc.<br>&gt;<br>&gt; Comments?<br></p><p>I think I want to hear Steve Canon&#39;s input on this one.  I defer to him<br>on most things numeric.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/49f329a0267f5a1773a77017882a82a8?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Rainer Brockerhoff</string> &lt;rainer at brockerhoff.net&gt;<p>March 31, 2016 at 03:00:00pm</p></header><div class="content"><p>On 3/31/16 15:06, Dave Abrahams via swift-evolution wrote:<br>&gt; <br>&gt; on Thu Mar 31 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; Thoughts on an edge case: so long as it&#39;s possible to use<br>&gt;&gt; `stride(from:to:by:)` with Double, we&#39;ll need to figure out what<br>&gt;&gt; happens when you have `stride(from: 0.0, to: DBL_MAX, by: DBL_MIN)`.<br>&gt;&gt; Bounds may be unknown at compile time, obviously.<br>&gt;&gt;<br>&gt;&gt; Currently (this is by reasoning through the code, not actually<br>&gt;&gt; observing it run), `for i in stride(from: 0.0, to: DBL_MAX, by:<br>&gt;&gt; DBL_MIN) { }` degenerates into an infinite loop once you reach<br>&gt;&gt; sufficient large values such that `current + stride == current`, which<br>&gt;&gt; for a stride of DBL_MIN should happen pretty quickly.<br>&gt;&gt;<br>&gt;&gt; In Erica&#39;s proposed floating point Stride, an Int is used to count<br>&gt;&gt; iterations (and iterations need to be counted in order to avoid<br>&gt;&gt; accumulating error). Thus, one must break from `for i in stride(from:<br>&gt;&gt; 0.0, to: DBL_MAX, by: DBL_MIN) { }` before the iteration counter<br>&gt;&gt; overflows or it will trap. IMO, trapping at some point is fine, but I<br>&gt;&gt; think a limit of Int.max iterations might be rather arbitrary for a<br>&gt;&gt; StrideTo&lt;Double&gt; (or whatever it will be named) and I&#39;m not sure how<br>&gt;&gt; one can justify why the behavior of StrideTo&lt;Double&gt; would change from<br>&gt;&gt; machine to machine based on the size of Int.<br>&gt;&gt;<br>&gt;&gt; I&#39;ve been waffling between using an Int counter as Erica does or a<br>&gt;&gt; counter of type Strideable.Stride in `StrideTo&lt;Strideable where<br>&gt;&gt; Strideable.Stride : FloatingPoint&gt;`. In the latter alternative, no<br>&gt;&gt; trapping occurs, but error begins to accumulate when the iteration<br>&gt;&gt; counter is too large to represent integers exactly (e.g., 2^53 for<br>&gt;&gt; Double). In that case, `for i in stride(from: 0.0, to: DBL_MAX, by:<br>&gt;&gt; DBL_MIN) { }` degenerates into an infinite loop eventually (once<br>&gt;&gt; `iterationCount + 1.0 == iterationCount`) and never traps, which I&#39;m<br>&gt;&gt; not sure I like, but a limit of 2^53 iterations bears at least a<br>&gt;&gt; rational connection to Double and is known at compile time independent<br>&gt;&gt; of the supplied bounds. We could alternatively return nil on reaching<br>&gt;&gt; 2^53 iterations, trap, etc.<br>&gt;&gt;<br>&gt;&gt; Comments?<br>&gt; <br>&gt; I think I want to hear Steve Canon&#39;s input on this one.  I defer to him<br>&gt; on most things numeric.<br></p><p>In particular, should Steve confirm that the IEEE754 Decimal128 format<br>is being worked on, and if simple decimal constants like those in<br>	`for i in stride(from: 0.0, to: DBL_MAX, by: DBL_MIN) { }`<br>will be type-inferred as Decimal128, all that would &quot;just work&quot;.<br></p><p>;-)<br>-- <br>Rainer Brockerhoff  &lt;rainer at brockerhoff.net&gt;<br>Belo Horizonte, Brazil<br>&quot;In the affairs of others even fools are wise<br>In their own business even sages err.&quot;<br>http://brockerhoff.net/blog/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>March 31, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 31, 2016, at 11:16 AM, Rainer Brockerhoff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 3/31/16 15:06, Dave Abrahams via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt; on Thu Mar 31 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Thoughts on an edge case: so long as it&#39;s possible to use<br>&gt;&gt;&gt; `stride(from:to:by:)` with Double, we&#39;ll need to figure out what<br>&gt;&gt;&gt; happens when you have `stride(from: 0.0, to: DBL_MAX, by: DBL_MIN)`.<br>&gt;&gt;&gt; Bounds may be unknown at compile time, obviously.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently (this is by reasoning through the code, not actually<br>&gt;&gt;&gt; observing it run), `for i in stride(from: 0.0, to: DBL_MAX, by:<br>&gt;&gt;&gt; DBL_MIN) { }` degenerates into an infinite loop once you reach<br>&gt;&gt;&gt; sufficient large values such that `current + stride == current`, which<br>&gt;&gt;&gt; for a stride of DBL_MIN should happen pretty quickly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Erica&#39;s proposed floating point Stride, an Int is used to count<br>&gt;&gt;&gt; iterations (and iterations need to be counted in order to avoid<br>&gt;&gt;&gt; accumulating error). Thus, one must break from `for i in stride(from:<br>&gt;&gt;&gt; 0.0, to: DBL_MAX, by: DBL_MIN) { }` before the iteration counter<br>&gt;&gt;&gt; overflows or it will trap. IMO, trapping at some point is fine, but I<br>&gt;&gt;&gt; think a limit of Int.max iterations might be rather arbitrary for a<br>&gt;&gt;&gt; StrideTo&lt;Double&gt; (or whatever it will be named) and I&#39;m not sure how<br>&gt;&gt;&gt; one can justify why the behavior of StrideTo&lt;Double&gt; would change from<br>&gt;&gt;&gt; machine to machine based on the size of Int.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve been waffling between using an Int counter as Erica does or a<br>&gt;&gt;&gt; counter of type Strideable.Stride in `StrideTo&lt;Strideable where<br>&gt;&gt;&gt; Strideable.Stride : FloatingPoint&gt;`. In the latter alternative, no<br>&gt;&gt;&gt; trapping occurs, but error begins to accumulate when the iteration<br>&gt;&gt;&gt; counter is too large to represent integers exactly (e.g., 2^53 for<br>&gt;&gt;&gt; Double). In that case, `for i in stride(from: 0.0, to: DBL_MAX, by:<br>&gt;&gt;&gt; DBL_MIN) { }` degenerates into an infinite loop eventually (once<br>&gt;&gt;&gt; `iterationCount + 1.0 == iterationCount`) and never traps, which I&#39;m<br>&gt;&gt;&gt; not sure I like, but a limit of 2^53 iterations bears at least a<br>&gt;&gt;&gt; rational connection to Double and is known at compile time independent<br>&gt;&gt;&gt; of the supplied bounds. We could alternatively return nil on reaching<br>&gt;&gt;&gt; 2^53 iterations, trap, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comments?<br>&gt;&gt; <br>&gt;&gt; I think I want to hear Steve Canon&#39;s input on this one.  I defer to him<br>&gt;&gt; on most things numeric.<br>&gt; <br>&gt; In particular, should Steve confirm that the IEEE754 Decimal128 format<br>&gt; is being worked on, and if simple decimal constants like those in<br>&gt; 	`for i in stride(from: 0.0, to: DBL_MAX, by: DBL_MIN) { }`<br>&gt; will be type-inferred as Decimal128, all that would &quot;just work&quot;.<br></p><p>Decimal is something that I would like to see happen.  However, I would not expect any such proposal to result in that loop being type inferred to Decimal, since the to: and by: values are explicitly (binary floating-point) Doubles.<br></p><p>I also don’t think that such a loop is particularly useful.  For floating-point types, something like stride(from: T, to: T, steps: Int) seems safer and more workable to me (this is just my immediate reaction, I haven’t thought this through in detail, and am likely to change my mind if someone makes a good case).<br></p><p>– Steve<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/49f329a0267f5a1773a77017882a82a8?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Rainer Brockerhoff</string> &lt;rainer at brockerhoff.net&gt;<p>March 31, 2016 at 03:00:00pm</p></header><div class="content"><p>On 3/31/16 15:29, Stephen Canon via swift-evolution wrote:<br>&gt; <br>&gt;&gt; On Mar 31, 2016, at 11:16 AM, Rainer Brockerhoff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On 3/31/16 15:06, Dave Abrahams via swift-evolution wrote:<br>&gt;&gt;&gt;...<br>&gt;&gt;&gt; I think I want to hear Steve Canon&#39;s input on this one.  I defer to him<br>&gt;&gt;&gt; on most things numeric.<br>&gt;&gt;<br>&gt;&gt; In particular, should Steve confirm that the IEEE754 Decimal128 format<br>&gt;&gt; is being worked on, and if simple decimal constants like those in<br>&gt;&gt; 	`for i in stride(from: 0.0, to: DBL_MAX, by: DBL_MIN) { }`<br>&gt;&gt; will be type-inferred as Decimal128, all that would &quot;just work&quot;.<br>&gt; <br>&gt; Decimal is something that I would like to see happen.  However, I<br>&gt; would not expect any such proposal to result in that loop being type<br>&gt; inferred to Decimal, since the to: and by: values are explicitly<br>&gt; (binary floating-point) Doubles.<br></p><p>Oopsie. Pressed &#39;send&#39; accidentally before re-editing this to<br>	for i in stride(from: 0.0, to: 1.0, by: 0.1)...<br>Sorry about that.<br></p><p>&gt; I also don’t think that such a loop is particularly useful.  For<br>&gt; floating-point types, something like stride(from: T, to: T, steps:<br>&gt; Int) seems safer and more workable to me (this is just my immediate<br>&gt; reaction, I haven’t thought this through in detail, and am likely to<br>&gt; change my mind if someone makes a good case).<br></p><p>`steps:` is OK for me too, though certain people would probably be<br>compelled to write, say,<br>	stride(from: floatA, to: floatB, steps: (floatB-floatA/0.1) )<br>perish forbid.<br></p><p>-- <br>Rainer Brockerhoff  &lt;rainer at brockerhoff.net&gt;<br>Belo Horizonte, Brazil<br>&quot;In the affairs of others even fools are wise<br>In their own business even sages err.&quot;<br>http://brockerhoff.net/blog/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 31, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Mar 31, 2016, at 12:29 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I also don’t think that such a loop is particularly useful.  For floating-point types, something like stride(from: T, to: T, steps: Int) seems safer and more workable to me (this is just my immediate reaction, I haven’t thought this through in detail, and am likely to change my mind if someone makes a good case).<br></p><p><br>While I do not object to n-steps, allowing a step difference is equally important in my opinion.<br>&quot;I want to sample every n deciRuncibles&quot; versus &quot;I want to sample 8 times between 1 deciRuncible <br>and 10 deciRuncibles&quot;<br></p><p>I disagree that the former is less useful than the latter.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/a556ebfb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>March 31, 2016 at 02:00:00pm</p></header><div class="content"><p>Yes, I&#39;ve had occasion to sample every n deciRuncibles as well.<br>Although there are difficulties with edge cases, I think it would be<br>throwing out the baby with the bath water (so to speak) to forbid<br>striding from 1.0 to 10.0 by 0.5, which I think most users would<br>expect to be able to do if they can stride from 1 to 10 by 1 (and<br>which they can do at present, just with accumulating error).<br></p><p>By contrast, I really can&#39;t imagine that too many intentional use<br>cases would push up against any possible upper iteration limits,<br>whether it&#39;s 2^64 or 2^53, but the Swifty thing would be to have<br>predictable behavior if those limits are reached.<br></p><p><br>On Thu, Mar 31, 2016 at 1:40 PM, Erica Sadun via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Mar 31, 2016, at 12:29 PM, Stephen Canon via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I also don’t think that such a loop is particularly useful.  For<br>&gt; floating-point types, something like stride(from: T, to: T, steps: Int)<br>&gt; seems safer and more workable to me (this is just my immediate reaction, I<br>&gt; haven’t thought this through in detail, and am likely to change my mind if<br>&gt; someone makes a good case).<br>&gt;<br>&gt;<br>&gt; While I do not object to n-steps, allowing a step difference is equally<br>&gt; important in my opinion.<br>&gt; &quot;I want to sample every n deciRuncibles&quot; versus &quot;I want to sample 8 times<br>&gt; between 1 deciRuncible<br>&gt; and 10 deciRuncibles&quot;<br>&gt;<br>&gt; I disagree that the former is less useful than the latter.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April  1, 2016 at 08:00:00am</p></header><div class="content"><p>If you define a range as range[i] = first + i * stride where i is an Int<br>then this generates an error when there are more than Int_Max steps, see<br>code previously posted. The error is generated when the range is formed,<br>which is ideal since an error part way along an iteration or a never ending<br>iteration would be difficult to track down.<br></p><p>On Friday, 1 April 2016, Stephen Canon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Mar 31, 2016, at 11:16 AM, Rainer Brockerhoff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On 3/31/16 15:06, Dave Abrahams via swift-evolution wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Thu Mar 31 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Thoughts on an edge case: so long as it&#39;s possible to use<br>&gt; &gt;&gt;&gt; `stride(from:to:by:)` with Double, we&#39;ll need to figure out what<br>&gt; &gt;&gt;&gt; happens when you have `stride(from: 0.0, to: DBL_MAX, by: DBL_MIN)`.<br>&gt; &gt;&gt;&gt; Bounds may be unknown at compile time, obviously.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Currently (this is by reasoning through the code, not actually<br>&gt; &gt;&gt;&gt; observing it run), `for i in stride(from: 0.0, to: DBL_MAX, by:<br>&gt; &gt;&gt;&gt; DBL_MIN) { }` degenerates into an infinite loop once you reach<br>&gt; &gt;&gt;&gt; sufficient large values such that `current + stride == current`, which<br>&gt; &gt;&gt;&gt; for a stride of DBL_MIN should happen pretty quickly.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; In Erica&#39;s proposed floating point Stride, an Int is used to count<br>&gt; &gt;&gt;&gt; iterations (and iterations need to be counted in order to avoid<br>&gt; &gt;&gt;&gt; accumulating error). Thus, one must break from `for i in stride(from:<br>&gt; &gt;&gt;&gt; 0.0, to: DBL_MAX, by: DBL_MIN) { }` before the iteration counter<br>&gt; &gt;&gt;&gt; overflows or it will trap. IMO, trapping at some point is fine, but I<br>&gt; &gt;&gt;&gt; think a limit of Int.max iterations might be rather arbitrary for a<br>&gt; &gt;&gt;&gt; StrideTo&lt;Double&gt; (or whatever it will be named) and I&#39;m not sure how<br>&gt; &gt;&gt;&gt; one can justify why the behavior of StrideTo&lt;Double&gt; would change from<br>&gt; &gt;&gt;&gt; machine to machine based on the size of Int.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I&#39;ve been waffling between using an Int counter as Erica does or a<br>&gt; &gt;&gt;&gt; counter of type Strideable.Stride in `StrideTo&lt;Strideable where<br>&gt; &gt;&gt;&gt; Strideable.Stride : FloatingPoint&gt;`. In the latter alternative, no<br>&gt; &gt;&gt;&gt; trapping occurs, but error begins to accumulate when the iteration<br>&gt; &gt;&gt;&gt; counter is too large to represent integers exactly (e.g., 2^53 for<br>&gt; &gt;&gt;&gt; Double). In that case, `for i in stride(from: 0.0, to: DBL_MAX, by:<br>&gt; &gt;&gt;&gt; DBL_MIN) { }` degenerates into an infinite loop eventually (once<br>&gt; &gt;&gt;&gt; `iterationCount + 1.0 == iterationCount`) and never traps, which I&#39;m<br>&gt; &gt;&gt;&gt; not sure I like, but a limit of 2^53 iterations bears at least a<br>&gt; &gt;&gt;&gt; rational connection to Double and is known at compile time independent<br>&gt; &gt;&gt;&gt; of the supplied bounds. We could alternatively return nil on reaching<br>&gt; &gt;&gt;&gt; 2^53 iterations, trap, etc.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Comments?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I think I want to hear Steve Canon&#39;s input on this one.  I defer to him<br>&gt; &gt;&gt; on most things numeric.<br>&gt; &gt;<br>&gt; &gt; In particular, should Steve confirm that the IEEE754 Decimal128 format<br>&gt; &gt; is being worked on, and if simple decimal constants like those in<br>&gt; &gt;       `for i in stride(from: 0.0, to: DBL_MAX, by: DBL_MIN) { }`<br>&gt; &gt; will be type-inferred as Decimal128, all that would &quot;just work&quot;.<br>&gt;<br>&gt; Decimal is something that I would like to see happen.  However, I would<br>&gt; not expect any such proposal to result in that loop being type inferred to<br>&gt; Decimal, since the to: and by: values are explicitly (binary<br>&gt; floating-point) Doubles.<br>&gt;<br>&gt; I also don’t think that such a loop is particularly useful.  For<br>&gt; floating-point types, something like stride(from: T, to: T, steps: Int)<br>&gt; seems safer and more workable to me (this is just my immediate reaction, I<br>&gt; haven’t thought this through in detail, and am likely to change my mind if<br>&gt; someone makes a good case).<br>&gt;<br>&gt; – Steve<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160401/25da5059/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>March 31, 2016 at 10:00:00pm</p></header><div class="content"><p>All true. I call that Erica&#39;s solution because her proposal is where I<br>first found it sketched out.<br></p><p>I&#39;m not convinced that Erica&#39;s solution is definitely the right answer<br>because:<br></p><p>(a) Use of an iteration counter of type Int to stride through Doubles is an<br>implementation detail which is not an obviously correct choice; users might<br>find it surprising that how many steps they get for StrideTo&lt;Double&gt; is<br>constrained by Int.max<br></p><p>(b) I&#39;m not completely certain that there is no use case for a loop with<br>more than Int.max steps so long as you break before the end, so I&#39;m not<br>completely certain that an error right off the bat is the most ideal<br>behavior; for example, someone may wish to increment by a user-supplied<br>epsilon from one user-supplied value to another but break after a certain<br>amount of time has elapsed<br></p><p>(c) I agree with you that it&#39;s Swiftier to do nothing than to start<br>returning approximately correct values, but in a scenario such as `for _ in<br>stride(from: 0, to: DBL_MAX, by: someAbsurdlySmallValue) { }` it may not<br>matter (I cannot imagine a use case for this ridiculous loop, but for the<br>sake of argument here let&#39;s take it); one alternative solution someone<br>might propose, for example, would be to fall back to the old<br>error-accumulating algorithm after the iteration counter has reached its<br>max possible value<br></p><p>So I guess the feedback I&#39;m interested in is:<br></p><p>- Would you be surprised to find that Stride&lt;Double&gt; may become constrained<br>by an upper limit in the number of steps?<br></p><p>- If not, would it irk you that such a limit is based on the size of a<br>totally unrelated numeric type (namely, Int) which is an implementation<br>detail? Would you prefer that the limit be something related to the nature<br>of the type itself (for example, a maximum number of steps for<br>StrideTo&lt;Double&gt; that reflects the maximum exactly representable integer in<br>a Double)?<br></p><p>- If there is to be an upper limit on steps, would you prefer an error when<br>the Stride is being initialized or when the iteration counter overflows?<br></p><p>- Would you rather instead be able to stride indefinitely, as is currently<br>the case in Swift 2, accepting that error will start accumulating at some<br>point?<br></p><p>On Thu, Mar 31, 2016 at 4:33 PM Howard Lovatt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; If you define a range as range[i] = first + i * stride where i is an Int<br>&gt; then this generates an error when there are more than Int_Max steps, see<br>&gt; code previously posted. The error is generated when the range is formed,<br>&gt; which is ideal since an error part way along an iteration or a never ending<br>&gt; iteration would be difficult to track down.<br>&gt;<br>&gt; On Friday, 1 April 2016, Stephen Canon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Mar 31, 2016, at 11:16 AM, Rainer Brockerhoff via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On 3/31/16 15:06, Dave Abrahams via swift-evolution wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; on Thu Mar 31 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Thoughts on an edge case: so long as it&#39;s possible to use<br>&gt;&gt; &gt;&gt;&gt; `stride(from:to:by:)` with Double, we&#39;ll need to figure out what<br>&gt;&gt; &gt;&gt;&gt; happens when you have `stride(from: 0.0, to: DBL_MAX, by: DBL_MIN)`.<br>&gt;&gt; &gt;&gt;&gt; Bounds may be unknown at compile time, obviously.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Currently (this is by reasoning through the code, not actually<br>&gt;&gt; &gt;&gt;&gt; observing it run), `for i in stride(from: 0.0, to: DBL_MAX, by:<br>&gt;&gt; &gt;&gt;&gt; DBL_MIN) { }` degenerates into an infinite loop once you reach<br>&gt;&gt; &gt;&gt;&gt; sufficient large values such that `current + stride == current`, which<br>&gt;&gt; &gt;&gt;&gt; for a stride of DBL_MIN should happen pretty quickly.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; In Erica&#39;s proposed floating point Stride, an Int is used to count<br>&gt;&gt; &gt;&gt;&gt; iterations (and iterations need to be counted in order to avoid<br>&gt;&gt; &gt;&gt;&gt; accumulating error). Thus, one must break from `for i in stride(from:<br>&gt;&gt; &gt;&gt;&gt; 0.0, to: DBL_MAX, by: DBL_MIN) { }` before the iteration counter<br>&gt;&gt; &gt;&gt;&gt; overflows or it will trap. IMO, trapping at some point is fine, but I<br>&gt;&gt; &gt;&gt;&gt; think a limit of Int.max iterations might be rather arbitrary for a<br>&gt;&gt; &gt;&gt;&gt; StrideTo&lt;Double&gt; (or whatever it will be named) and I&#39;m not sure how<br>&gt;&gt; &gt;&gt;&gt; one can justify why the behavior of StrideTo&lt;Double&gt; would change from<br>&gt;&gt; &gt;&gt;&gt; machine to machine based on the size of Int.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I&#39;ve been waffling between using an Int counter as Erica does or a<br>&gt;&gt; &gt;&gt;&gt; counter of type Strideable.Stride in `StrideTo&lt;Strideable where<br>&gt;&gt; &gt;&gt;&gt; Strideable.Stride : FloatingPoint&gt;`. In the latter alternative, no<br>&gt;&gt; &gt;&gt;&gt; trapping occurs, but error begins to accumulate when the iteration<br>&gt;&gt; &gt;&gt;&gt; counter is too large to represent integers exactly (e.g., 2^53 for<br>&gt;&gt; &gt;&gt;&gt; Double). In that case, `for i in stride(from: 0.0, to: DBL_MAX, by:<br>&gt;&gt; &gt;&gt;&gt; DBL_MIN) { }` degenerates into an infinite loop eventually (once<br>&gt;&gt; &gt;&gt;&gt; `iterationCount + 1.0 == iterationCount`) and never traps, which I&#39;m<br>&gt;&gt; &gt;&gt;&gt; not sure I like, but a limit of 2^53 iterations bears at least a<br>&gt;&gt; &gt;&gt;&gt; rational connection to Double and is known at compile time independent<br>&gt;&gt; &gt;&gt;&gt; of the supplied bounds. We could alternatively return nil on reaching<br>&gt;&gt; &gt;&gt;&gt; 2^53 iterations, trap, etc.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Comments?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I think I want to hear Steve Canon&#39;s input on this one.  I defer to him<br>&gt;&gt; &gt;&gt; on most things numeric.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In particular, should Steve confirm that the IEEE754 Decimal128 format<br>&gt;&gt; &gt; is being worked on, and if simple decimal constants like those in<br>&gt;&gt; &gt;       `for i in stride(from: 0.0, to: DBL_MAX, by: DBL_MIN) { }`<br>&gt;&gt; &gt; will be type-inferred as Decimal128, all that would &quot;just work&quot;.<br>&gt;&gt;<br>&gt;&gt; Decimal is something that I would like to see happen.  However, I would<br>&gt;&gt; not expect any such proposal to result in that loop being type inferred to<br>&gt;&gt; Decimal, since the to: and by: values are explicitly (binary<br>&gt;&gt; floating-point) Doubles.<br>&gt;&gt;<br>&gt;&gt; I also don’t think that such a loop is particularly useful.  For<br>&gt;&gt; floating-point types, something like stride(from: T, to: T, steps: Int)<br>&gt;&gt; seems safer and more workable to me (this is just my immediate reaction, I<br>&gt;&gt; haven’t thought this through in detail, and am likely to change my mind if<br>&gt;&gt; someone makes a good case).<br>&gt;&gt;<br>&gt;&gt; – Steve<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; -- Howard.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/f8fe79cd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April  2, 2016 at 10:00:00am</p></header><div class="content"><p>No I would not be surprised by a limit based on Int provided that:<br></p><p>  1. It was articulated in the documentation<br>  2. The error occurred when the Range/stride was created<br>  3. The error message stated that there were too many steps and what the<br>step limit was<br></p><p>What I don&#39;t think would be acceptable was if:<br></p><p>  1. The error occurred part way through the iteration; not at creation time<br>  2. There was no error and the loop turned into an infinite loop silently<br></p><p>On Friday, 1 April 2016, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; All true. I call that Erica&#39;s solution because her proposal is where I<br>&gt; first found it sketched out.<br>&gt;<br>&gt; I&#39;m not convinced that Erica&#39;s solution is definitely the right answer<br>&gt; because:<br>&gt;<br>&gt; (a) Use of an iteration counter of type Int to stride through Doubles is<br>&gt; an implementation detail which is not an obviously correct choice; users<br>&gt; might find it surprising that how many steps they get for StrideTo&lt;Double&gt;<br>&gt; is constrained by Int.max<br>&gt;<br>&gt; (b) I&#39;m not completely certain that there is no use case for a loop with<br>&gt; more than Int.max steps so long as you break before the end, so I&#39;m not<br>&gt; completely certain that an error right off the bat is the most ideal<br>&gt; behavior; for example, someone may wish to increment by a user-supplied<br>&gt; epsilon from one user-supplied value to another but break after a certain<br>&gt; amount of time has elapsed<br>&gt;<br>&gt; (c) I agree with you that it&#39;s Swiftier to do nothing than to start<br>&gt; returning approximately correct values, but in a scenario such as `for _ in<br>&gt; stride(from: 0, to: DBL_MAX, by: someAbsurdlySmallValue) { }` it may not<br>&gt; matter (I cannot imagine a use case for this ridiculous loop, but for the<br>&gt; sake of argument here let&#39;s take it); one alternative solution someone<br>&gt; might propose, for example, would be to fall back to the old<br>&gt; error-accumulating algorithm after the iteration counter has reached its<br>&gt; max possible value<br>&gt;<br>&gt; So I guess the feedback I&#39;m interested in is:<br>&gt;<br>&gt; - Would you be surprised to find that Stride&lt;Double&gt; may become<br>&gt; constrained by an upper limit in the number of steps?<br>&gt;<br>&gt; - If not, would it irk you that such a limit is based on the size of a<br>&gt; totally unrelated numeric type (namely, Int) which is an implementation<br>&gt; detail? Would you prefer that the limit be something related to the nature<br>&gt; of the type itself (for example, a maximum number of steps for<br>&gt; StrideTo&lt;Double&gt; that reflects the maximum exactly representable integer in<br>&gt; a Double)?<br>&gt;<br>&gt; - If there is to be an upper limit on steps, would you prefer an error<br>&gt; when the Stride is being initialized or when the iteration counter<br>&gt; overflows?<br>&gt;<br>&gt; - Would you rather instead be able to stride indefinitely, as is currently<br>&gt; the case in Swift 2, accepting that error will start accumulating at some<br>&gt; point?<br>&gt;<br>&gt; On Thu, Mar 31, 2016 at 4:33 PM Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; If you define a range as range[i] = first + i * stride where i is an Int<br>&gt;&gt; then this generates an error when there are more than Int_Max steps, see<br>&gt;&gt; code previously posted. The error is generated when the range is formed,<br>&gt;&gt; which is ideal since an error part way along an iteration or a never ending<br>&gt;&gt; iteration would be difficult to track down.<br>&gt;&gt;<br>&gt;&gt; On Friday, 1 April 2016, Stephen Canon via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Mar 31, 2016, at 11:16 AM, Rainer Brockerhoff via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; On 3/31/16 15:06, Dave Abrahams via swift-evolution wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; on Thu Mar 31 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Thoughts on an edge case: so long as it&#39;s possible to use<br>&gt;&gt;&gt; &gt;&gt;&gt; `stride(from:to:by:)` with Double, we&#39;ll need to figure out what<br>&gt;&gt;&gt; &gt;&gt;&gt; happens when you have `stride(from: 0.0, to: DBL_MAX, by: DBL_MIN)`.<br>&gt;&gt;&gt; &gt;&gt;&gt; Bounds may be unknown at compile time, obviously.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Currently (this is by reasoning through the code, not actually<br>&gt;&gt;&gt; &gt;&gt;&gt; observing it run), `for i in stride(from: 0.0, to: DBL_MAX, by:<br>&gt;&gt;&gt; &gt;&gt;&gt; DBL_MIN) { }` degenerates into an infinite loop once you reach<br>&gt;&gt;&gt; &gt;&gt;&gt; sufficient large values such that `current + stride == current`,<br>&gt;&gt;&gt; which<br>&gt;&gt;&gt; &gt;&gt;&gt; for a stride of DBL_MIN should happen pretty quickly.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; In Erica&#39;s proposed floating point Stride, an Int is used to count<br>&gt;&gt;&gt; &gt;&gt;&gt; iterations (and iterations need to be counted in order to avoid<br>&gt;&gt;&gt; &gt;&gt;&gt; accumulating error). Thus, one must break from `for i in stride(from:<br>&gt;&gt;&gt; &gt;&gt;&gt; 0.0, to: DBL_MAX, by: DBL_MIN) { }` before the iteration counter<br>&gt;&gt;&gt; &gt;&gt;&gt; overflows or it will trap. IMO, trapping at some point is fine, but I<br>&gt;&gt;&gt; &gt;&gt;&gt; think a limit of Int.max iterations might be rather arbitrary for a<br>&gt;&gt;&gt; &gt;&gt;&gt; StrideTo&lt;Double&gt; (or whatever it will be named) and I&#39;m not sure how<br>&gt;&gt;&gt; &gt;&gt;&gt; one can justify why the behavior of StrideTo&lt;Double&gt; would change<br>&gt;&gt;&gt; from<br>&gt;&gt;&gt; &gt;&gt;&gt; machine to machine based on the size of Int.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; I&#39;ve been waffling between using an Int counter as Erica does or a<br>&gt;&gt;&gt; &gt;&gt;&gt; counter of type Strideable.Stride in `StrideTo&lt;Strideable where<br>&gt;&gt;&gt; &gt;&gt;&gt; Strideable.Stride : FloatingPoint&gt;`. In the latter alternative, no<br>&gt;&gt;&gt; &gt;&gt;&gt; trapping occurs, but error begins to accumulate when the iteration<br>&gt;&gt;&gt; &gt;&gt;&gt; counter is too large to represent integers exactly (e.g., 2^53 for<br>&gt;&gt;&gt; &gt;&gt;&gt; Double). In that case, `for i in stride(from: 0.0, to: DBL_MAX, by:<br>&gt;&gt;&gt; &gt;&gt;&gt; DBL_MIN) { }` degenerates into an infinite loop eventually (once<br>&gt;&gt;&gt; &gt;&gt;&gt; `iterationCount + 1.0 == iterationCount`) and never traps, which I&#39;m<br>&gt;&gt;&gt; &gt;&gt;&gt; not sure I like, but a limit of 2^53 iterations bears at least a<br>&gt;&gt;&gt; &gt;&gt;&gt; rational connection to Double and is known at compile time<br>&gt;&gt;&gt; independent<br>&gt;&gt;&gt; &gt;&gt;&gt; of the supplied bounds. We could alternatively return nil on reaching<br>&gt;&gt;&gt; &gt;&gt;&gt; 2^53 iterations, trap, etc.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Comments?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I think I want to hear Steve Canon&#39;s input on this one.  I defer to<br>&gt;&gt;&gt; him<br>&gt;&gt;&gt; &gt;&gt; on most things numeric.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; In particular, should Steve confirm that the IEEE754 Decimal128 format<br>&gt;&gt;&gt; &gt; is being worked on, and if simple decimal constants like those in<br>&gt;&gt;&gt; &gt;       `for i in stride(from: 0.0, to: DBL_MAX, by: DBL_MIN) { }`<br>&gt;&gt;&gt; &gt; will be type-inferred as Decimal128, all that would &quot;just work&quot;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Decimal is something that I would like to see happen.  However, I would<br>&gt;&gt;&gt; not expect any such proposal to result in that loop being type inferred to<br>&gt;&gt;&gt; Decimal, since the to: and by: values are explicitly (binary<br>&gt;&gt;&gt; floating-point) Doubles.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I also don’t think that such a loop is particularly useful.  For<br>&gt;&gt;&gt; floating-point types, something like stride(from: T, to: T, steps: Int)<br>&gt;&gt;&gt; seems safer and more workable to me (this is just my immediate reaction, I<br>&gt;&gt;&gt; haven’t thought this through in detail, and am likely to change my mind if<br>&gt;&gt;&gt; someone makes a good case).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; – Steve<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; -- Howard.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br></p><p>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160402/7438015b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April  2, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 01.04.2016 um 00:23 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; All true. I call that Erica&#39;s solution because her proposal is where I first found it sketched out.<br>&gt; <br>&gt; I&#39;m not convinced that Erica&#39;s solution is definitely the right answer because:<br>&gt; <br>&gt; (a) Use of an iteration counter of type Int to stride through Doubles is an implementation detail which is not an obviously correct choice; users might find it surprising that how many steps they get for StrideTo&lt;Double&gt; is constrained by Int.max<br></p><p>Couldn’t we use a BigInt internally (if necessary)? This would make this problem disappear.<br></p><p>-Thorsten<br></p><p><br>&gt; (b) I&#39;m not completely certain that there is no use case for a loop with more than Int.max steps so long as you break before the end, so I&#39;m not completely certain that an error right off the bat is the most ideal behavior; for example, someone may wish to increment by a user-supplied epsilon from one user-supplied value to another but break after a certain amount of time has elapsed<br>&gt; <br>&gt; (c) I agree with you that it&#39;s Swiftier to do nothing than to start returning approximately correct values, but in a scenario such as `for _ in stride(from: 0, to: DBL_MAX, by: someAbsurdlySmallValue) { }` it may not matter (I cannot imagine a use case for this ridiculous loop, but for the sake of argument here let&#39;s take it); one alternative solution someone might propose, for example, would be to fall back to the old error-accumulating algorithm after the iteration counter has reached its max possible value<br>&gt; <br>&gt; So I guess the feedback I&#39;m interested in is:<br>&gt; <br>&gt; - Would you be surprised to find that Stride&lt;Double&gt; may become constrained by an upper limit in the number of steps?<br>&gt; <br>&gt; - If not, would it irk you that such a limit is based on the size of a totally unrelated numeric type (namely, Int) which is an implementation detail? Would you prefer that the limit be something related to the nature of the type itself (for example, a maximum number of steps for StrideTo&lt;Double&gt; that reflects the maximum exactly representable integer in a Double)?<br>&gt; <br>&gt; - If there is to be an upper limit on steps, would you prefer an error when the Stride is being initialized or when the iteration counter overflows?<br>&gt; <br>&gt; - Would you rather instead be able to stride indefinitely, as is currently the case in Swift 2, accepting that error will start accumulating at some point?<br>&gt; <br>&gt; On Thu, Mar 31, 2016 at 4:33 PM Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; If you define a range as range[i] = first + i * stride where i is an Int then this generates an error when there are more than Int_Max steps, see code previously posted. The error is generated when the range is formed, which is ideal since an error part way along an iteration or a never ending iteration would be difficult to track down. <br>&gt; <br>&gt; On Friday, 1 April 2016, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Mar 31, 2016, at 11:16 AM, Rainer Brockerhoff via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On 3/31/16 15:06, Dave Abrahams via swift-evolution wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Thu Mar 31 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com &lt;http://xiaodi.wu-at-gmail.com/&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Thoughts on an edge case: so long as it&#39;s possible to use<br>&gt; &gt;&gt;&gt; `stride(from:to:by:)` with Double, we&#39;ll need to figure out what<br>&gt; &gt;&gt;&gt; happens when you have `stride(from: 0.0, to: DBL_MAX, by: DBL_MIN)`.<br>&gt; &gt;&gt;&gt; Bounds may be unknown at compile time, obviously.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Currently (this is by reasoning through the code, not actually<br>&gt; &gt;&gt;&gt; observing it run), `for i in stride(from: 0.0, to: DBL_MAX, by:<br>&gt; &gt;&gt;&gt; DBL_MIN) { }` degenerates into an infinite loop once you reach<br>&gt; &gt;&gt;&gt; sufficient large values such that `current + stride == current`, which<br>&gt; &gt;&gt;&gt; for a stride of DBL_MIN should happen pretty quickly.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; In Erica&#39;s proposed floating point Stride, an Int is used to count<br>&gt; &gt;&gt;&gt; iterations (and iterations need to be counted in order to avoid<br>&gt; &gt;&gt;&gt; accumulating error). Thus, one must break from `for i in stride(from:<br>&gt; &gt;&gt;&gt; 0.0, to: DBL_MAX, by: DBL_MIN) { }` before the iteration counter<br>&gt; &gt;&gt;&gt; overflows or it will trap. IMO, trapping at some point is fine, but I<br>&gt; &gt;&gt;&gt; think a limit of Int.max iterations might be rather arbitrary for a<br>&gt; &gt;&gt;&gt; StrideTo&lt;Double&gt; (or whatever it will be named) and I&#39;m not sure how<br>&gt; &gt;&gt;&gt; one can justify why the behavior of StrideTo&lt;Double&gt; would change from<br>&gt; &gt;&gt;&gt; machine to machine based on the size of Int.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I&#39;ve been waffling between using an Int counter as Erica does or a<br>&gt; &gt;&gt;&gt; counter of type Strideable.Stride in `StrideTo&lt;Strideable where<br>&gt; &gt;&gt;&gt; Strideable.Stride : FloatingPoint&gt;`. In the latter alternative, no<br>&gt; &gt;&gt;&gt; trapping occurs, but error begins to accumulate when the iteration<br>&gt; &gt;&gt;&gt; counter is too large to represent integers exactly (e.g., 2^53 for<br>&gt; &gt;&gt;&gt; Double). In that case, `for i in stride(from: 0.0, to: DBL_MAX, by:<br>&gt; &gt;&gt;&gt; DBL_MIN) { }` degenerates into an infinite loop eventually (once<br>&gt; &gt;&gt;&gt; `iterationCount + 1.0 == iterationCount`) and never traps, which I&#39;m<br>&gt; &gt;&gt;&gt; not sure I like, but a limit of 2^53 iterations bears at least a<br>&gt; &gt;&gt;&gt; rational connection to Double and is known at compile time independent<br>&gt; &gt;&gt;&gt; of the supplied bounds. We could alternatively return nil on reaching<br>&gt; &gt;&gt;&gt; 2^53 iterations, trap, etc.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Comments?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I think I want to hear Steve Canon&#39;s input on this one.  I defer to him<br>&gt; &gt;&gt; on most things numeric.<br>&gt; &gt;<br>&gt; &gt; In particular, should Steve confirm that the IEEE754 Decimal128 format<br>&gt; &gt; is being worked on, and if simple decimal constants like those in<br>&gt; &gt;       `for i in stride(from: 0.0, to: DBL_MAX, by: DBL_MIN) { }`<br>&gt; &gt; will be type-inferred as Decimal128, all that would &quot;just work&quot;.<br>&gt; <br>&gt; Decimal is something that I would like to see happen.  However, I would not expect any such proposal to result in that loop being type inferred to Decimal, since the to: and by: values are explicitly (binary floating-point) Doubles.<br>&gt; <br>&gt; I also don’t think that such a loop is particularly useful.  For floating-point types, something like stride(from: T, to: T, steps: Int) seems safer and more workable to me (this is just my immediate reaction, I haven’t thought this through in detail, and am likely to change my mind if someone makes a good case).<br>&gt; <br>&gt; – Steve<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; -- Howard.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160402/59f77a47/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April  2, 2016 at 09:00:00pm</p></header><div class="content"><p>Another alternative would be to sub-divide the generator into segments of Int.max elements. This means that error may still potentially creep in if there are enough of these steps, but it would be considerably less error-prone than the accumulation method, without the same performance penalty of BigInt. Basically if you have a start and end index you move the start index up every Int.max (or Uint.max) elements so long as start index is less than end index.<br></p><p>This should allow for a lot less error than accumulation, without the performance/memory overhead that a big integer could introduce, though it would still have some small inaccuracy (but then so does everything involving floating point types).<br></p><p>&gt; On 2 Apr 2016, at 18:43, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 01.04.2016 um 00:23 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; All true. I call that Erica&#39;s solution because her proposal is where I first found it sketched out.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not convinced that Erica&#39;s solution is definitely the right answer because:<br>&gt;&gt; <br>&gt;&gt; (a) Use of an iteration counter of type Int to stride through Doubles is an implementation detail which is not an obviously correct choice; users might find it surprising that how many steps they get for StrideTo&lt;Double&gt; is constrained by Int.max<br>&gt; <br>&gt; Couldn’t we use a BigInt internally (if necessary)? This would make this problem disappear.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; (b) I&#39;m not completely certain that there is no use case for a loop with more than Int.max steps so long as you break before the end, so I&#39;m not completely certain that an error right off the bat is the most ideal behavior; for example, someone may wish to increment by a user-supplied epsilon from one user-supplied value to another but break after a certain amount of time has elapsed<br>&gt;&gt; <br>&gt;&gt; (c) I agree with you that it&#39;s Swiftier to do nothing than to start returning approximately correct values, but in a scenario such as `for _ in stride(from: 0, to: DBL_MAX, by: someAbsurdlySmallValue) { }` it may not matter (I cannot imagine a use case for this ridiculous loop, but for the sake of argument here let&#39;s take it); one alternative solution someone might propose, for example, would be to fall back to the old error-accumulating algorithm after the iteration counter has reached its max possible value<br>&gt;&gt; <br>&gt;&gt; So I guess the feedback I&#39;m interested in is:<br>&gt;&gt; <br>&gt;&gt; - Would you be surprised to find that Stride&lt;Double&gt; may become constrained by an upper limit in the number of steps?<br>&gt;&gt; <br>&gt;&gt; - If not, would it irk you that such a limit is based on the size of a totally unrelated numeric type (namely, Int) which is an implementation detail? Would you prefer that the limit be something related to the nature of the type itself (for example, a maximum number of steps for StrideTo&lt;Double&gt; that reflects the maximum exactly representable integer in a Double)?<br>&gt;&gt; <br>&gt;&gt; - If there is to be an upper limit on steps, would you prefer an error when the Stride is being initialized or when the iteration counter overflows?<br>&gt;&gt; <br>&gt;&gt; - Would you rather instead be able to stride indefinitely, as is currently the case in Swift 2, accepting that error will start accumulating at some point?<br>&gt;&gt; <br>&gt;&gt; On Thu, Mar 31, 2016 at 4:33 PM Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; If you define a range as range[i] = first + i * stride where i is an Int then this generates an error when there are more than Int_Max steps, see code previously posted. The error is generated when the range is formed, which is ideal since an error part way along an iteration or a never ending iteration would be difficult to track down. <br>&gt;&gt; <br>&gt;&gt; On Friday, 1 April 2016, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On Mar 31, 2016, at 11:16 AM, Rainer Brockerhoff via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On 3/31/16 15:06, Dave Abrahams via swift-evolution wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; on Thu Mar 31 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com &lt;http://xiaodi.wu-at-gmail.com/&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Thoughts on an edge case: so long as it&#39;s possible to use<br>&gt;&gt; &gt;&gt;&gt; `stride(from:to:by:)` with Double, we&#39;ll need to figure out what<br>&gt;&gt; &gt;&gt;&gt; happens when you have `stride(from: 0.0, to: DBL_MAX, by: DBL_MIN)`.<br>&gt;&gt; &gt;&gt;&gt; Bounds may be unknown at compile time, obviously.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Currently (this is by reasoning through the code, not actually<br>&gt;&gt; &gt;&gt;&gt; observing it run), `for i in stride(from: 0.0, to: DBL_MAX, by:<br>&gt;&gt; &gt;&gt;&gt; DBL_MIN) { }` degenerates into an infinite loop once you reach<br>&gt;&gt; &gt;&gt;&gt; sufficient large values such that `current + stride == current`, which<br>&gt;&gt; &gt;&gt;&gt; for a stride of DBL_MIN should happen pretty quickly.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; In Erica&#39;s proposed floating point Stride, an Int is used to count<br>&gt;&gt; &gt;&gt;&gt; iterations (and iterations need to be counted in order to avoid<br>&gt;&gt; &gt;&gt;&gt; accumulating error). Thus, one must break from `for i in stride(from:<br>&gt;&gt; &gt;&gt;&gt; 0.0, to: DBL_MAX, by: DBL_MIN) { }` before the iteration counter<br>&gt;&gt; &gt;&gt;&gt; overflows or it will trap. IMO, trapping at some point is fine, but I<br>&gt;&gt; &gt;&gt;&gt; think a limit of Int.max iterations might be rather arbitrary for a<br>&gt;&gt; &gt;&gt;&gt; StrideTo&lt;Double&gt; (or whatever it will be named) and I&#39;m not sure how<br>&gt;&gt; &gt;&gt;&gt; one can justify why the behavior of StrideTo&lt;Double&gt; would change from<br>&gt;&gt; &gt;&gt;&gt; machine to machine based on the size of Int.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I&#39;ve been waffling between using an Int counter as Erica does or a<br>&gt;&gt; &gt;&gt;&gt; counter of type Strideable.Stride in `StrideTo&lt;Strideable where<br>&gt;&gt; &gt;&gt;&gt; Strideable.Stride : FloatingPoint&gt;`. In the latter alternative, no<br>&gt;&gt; &gt;&gt;&gt; trapping occurs, but error begins to accumulate when the iteration<br>&gt;&gt; &gt;&gt;&gt; counter is too large to represent integers exactly (e.g., 2^53 for<br>&gt;&gt; &gt;&gt;&gt; Double). In that case, `for i in stride(from: 0.0, to: DBL_MAX, by:<br>&gt;&gt; &gt;&gt;&gt; DBL_MIN) { }` degenerates into an infinite loop eventually (once<br>&gt;&gt; &gt;&gt;&gt; `iterationCount + 1.0 == iterationCount`) and never traps, which I&#39;m<br>&gt;&gt; &gt;&gt;&gt; not sure I like, but a limit of 2^53 iterations bears at least a<br>&gt;&gt; &gt;&gt;&gt; rational connection to Double and is known at compile time independent<br>&gt;&gt; &gt;&gt;&gt; of the supplied bounds. We could alternatively return nil on reaching<br>&gt;&gt; &gt;&gt;&gt; 2^53 iterations, trap, etc.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Comments?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I think I want to hear Steve Canon&#39;s input on this one.  I defer to him<br>&gt;&gt; &gt;&gt; on most things numeric.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In particular, should Steve confirm that the IEEE754 Decimal128 format<br>&gt;&gt; &gt; is being worked on, and if simple decimal constants like those in<br>&gt;&gt; &gt;       `for i in stride(from: 0.0, to: DBL_MAX, by: DBL_MIN) { }`<br>&gt;&gt; &gt; will be type-inferred as Decimal128, all that would &quot;just work&quot;.<br>&gt;&gt; <br>&gt;&gt; Decimal is something that I would like to see happen.  However, I would not expect any such proposal to result in that loop being type inferred to Decimal, since the to: and by: values are explicitly (binary floating-point) Doubles.<br>&gt;&gt; <br>&gt;&gt; I also don’t think that such a loop is particularly useful.  For floating-point types, something like stride(from: T, to: T, steps: Int) seems safer and more workable to me (this is just my immediate reaction, I haven’t thought this through in detail, and am likely to change my mind if someone makes a good case).<br>&gt;&gt; <br>&gt;&gt; – Steve<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -- Howard.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160402/081d363e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April  7, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Mar 30, 2016, at 12:26 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I didn&#39;t seem to ever need division. See attached playground (which<br>&gt; borrows shamelessly from existing code and Erica&#39;s proposal, and which<br>&gt; is written in Swift 2.2 because that&#39;s what I had handy).<br></p><p>Appending the following code to the playground reveals a bug/glitch:<br>import Darwin<br>let start = pow(2.0, 54)<br>let end = nextafter(start, Double.infinity)<br>let containsRepeatedValues = Array((start..&lt;end).striding(by: 1.0))<br>print(containsRepeatedValues) //prints &quot;[18014398509481984.0, 18014398509481984.0, 18014398509481984.0]\n&quot;<br></p><p>IMHO, this should be a bug, since the `FloatingPointStrideTo` init function has &quot;stride != 0&quot; as a precondition, and this behavior essentially breaks that. Although, having repeated values is probably preferable to getting in an infinite loop like this code does:<br>let stridesForever = Array(start.stride(to: end, by: 1.0))<br>print(stridesForever) //prints, well, nothing because it strides forever and the playground never finishes running<br></p><p>The problem in both cases is not enough floating point resolution.<br></p><p>I see three potential solutions:<br>1) If a value repeats, end the sequence early.<br>2) If a value repeats, skip it.<br>3) Accept the practical reality that sometimes floating point types just can’t have nice things, and move them to a different protocol which makes the dangers more obvious.<br></p><p>Thoughts? It seems to me that 1 &amp; 2 both have unexpected behavior of their own, but I’m not sure it matters in practice.<br></p><p>- Dave Sweeris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/5e95a07a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
