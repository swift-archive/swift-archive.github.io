<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Type Safe Algorithms</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January  6, 2016 at 03:00:00pm</p></header><div class="content"><p>I implemented a way of type safeing a calculation in Swift. I.e marking an<br>Int as a Degree and then being able to convert to a Radian. (At the bottom<br>of the page)<br></p><p>The magic for these special structs was the AngleType protocol which allows<br>you to Box up a value (in this case a number) and it handles the Conversion<br>(Apart from two of the methods which I had to implement).<br></p><p>In theory we could abstract this protocol out, so that others could use it<br>in the library. Then they just use it with their structs and they can<br>handle converting between these types.<br></p><p>So two questions do we have something like this already? and if not would<br>this be useful ?<br></p><p>import Foundation<br></p><p><br>//MARK:- AngleType<br></p><p><br>protocol AngleType: FloatLiteralConvertible, IntegerLiteralConvertible {<br></p><p><br></p><p>    var value: Double { get set }<br></p><p><br></p><p>    init(_ value: Double)<br></p><p>    init(_ value: Int)<br></p><p>    init&lt;T: IntegerType&gt;(integerLiteral value: T)<br></p><p>    init&lt;T: FloatingPointType&gt;(floatLiteral value: T)<br></p><p>}<br></p><p><br>// Implement FloatLiteralConvertible and IntegerLiteralConvertible<br></p><p><br>extension AngleType {<br></p><p><br>    init&lt;T: IntegerType&gt;(integerLiteral value: T)<br></p><p>    {<br></p><p>        self.init(value)<br></p><p>    }<br></p><p><br></p><p>    init&lt;T: IntegerType&gt;(_ value: T)<br></p><p>    {<br></p><p>        self.init(integerLiteral: value)<br></p><p>    }<br></p><p><br></p><p>    init&lt;T: FloatingPointType&gt;(floatLiteral value: T)<br></p><p>    {<br></p><p>        self.init(value)<br></p><p>    }<br></p><p><br></p><p>    init&lt;T: FloatingPointType&gt;(_ value: T)<br></p><p>    {<br></p><p>        self.init(floatLiteral: value)<br></p><p>    }<br></p><p>}<br></p><p><br>//MARK:- Degree<br></p><p><br>struct Degree: AngleType {<br></p><p><br></p><p>    typealias FloatLiteralType = Double<br></p><p>    typealias IntegerLiteralType = Int<br></p><p><br></p><p>    var value: Double<br></p><p><br></p><p>    init(_ value: Double) {<br></p><p>        self.value = value<br></p><p>    }<br></p><p><br></p><p>    init(_ value: Int) {<br></p><p>        self.value = Double(value)<br></p><p>    }<br></p><p>}<br></p><p><br>protocol DegreeConvertiable {<br></p><p>    init(degreeLiteral value: Degree)<br></p><p>}<br></p><p><br>extension Degree: CustomStringConvertible, CustomDebugStringConvertible {<br></p><p>    var description: String {<br></p><p>        return self.value.description<br></p><p>    }<br></p><p><br></p><p>    var debugDescription: String {<br></p><p>        return &quot;\(self.value.description)°&quot;<br></p><p>    }<br></p><p>}<br></p><p><br>extension Degree: RadianConvertiable {<br></p><p>    init(radianLiteral value: Radian) {<br></p><p>        self.value = Double(radianLiteral:value) * 180.0 / M_PI<br></p><p>    }<br></p><p><br></p><p>    init(_ value: Radian) {<br></p><p>        self.init(radianLiteral: value)<br></p><p>    }<br></p><p>}<br></p><p><br>//MARK:- Radian<br></p><p><br>struct Radian: AngleType {<br></p><p><br></p><p>    typealias FloatLiteralType = Double<br></p><p>    typealias IntegerLiteralType = Int<br></p><p><br></p><p>    var value: Double<br></p><p><br></p><p>    init(_ value: Double) {<br></p><p>        self.value = value<br></p><p>    }<br></p><p><br></p><p>    init(_ value: Int) {<br></p><p>        self.value = Double(value)<br></p><p>    }<br></p><p>}<br></p><p><br>protocol RadianConvertiable {<br></p><p>    init(radianLiteral value: Radian)<br></p><p>}<br></p><p><br>extension Radian: CustomStringConvertible, CustomDebugStringConvertible {<br></p><p>    var description: String {<br></p><p>        return self.value.description<br></p><p>    }<br></p><p><br></p><p>    var debugDescription: String {<br></p><p>        return &quot;\(self.value.description)㎭&quot;<br></p><p>    }<br></p><p>}<br></p><p><br>extension Radian: DegreeConvertiable {<br></p><p>    init(degreeLiteral value: Degree) {<br></p><p>        self.value = Double(degreeLiteral: value) * M_PI / 180.0<br></p><p>    }<br></p><p><br></p><p>    init(_ value: Degree) {<br></p><p>        self.init(degreeLiteral: value)<br></p><p>    }<br></p><p>}<br></p><p><br>//MARK:- Adding Conformance To Built In Types<br></p><p><br>extension FloatLiteralType: DegreeConvertiable, RadianConvertiable<br></p><p>{<br></p><p>    init(degreeLiteral degree: Degree) {<br></p><p>        self.value = degree.value.value<br></p><p>    }<br></p><p><br></p><p>    init(radianLiteral radian: Radian) {<br></p><p>        self.value = radian.value.value<br></p><p>    }<br></p><p>}<br></p><p><br>extension CGFloat: DegreeConvertiable, RadianConvertiable<br></p><p>{<br></p><p>    init(degreeLiteral degree: Degree) {<br></p><p>        self.init(degree.value)<br></p><p>    }<br></p><p><br></p><p>    init(radianLiteral radian: Radian) {<br></p><p>        self.init(radian.value)<br></p><p>    }<br></p><p><br></p><p>    init(_ degree: Degree) {<br></p><p>        self.init(degreeLiteral: degree)<br></p><p>    }<br></p><p><br></p><p>    init(_ radian: Radian) {<br></p><p>        self.init(radianLiteral: radian)<br></p><p>    }<br></p><p>}<br>-- <br> Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/ebd6359e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Type Safe Algorithms</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  6, 2016 at 11:00:00am</p></header><div class="content"><p>There are lots of people who had an idea like this one, the latest just yesterday, where the other threads had been collected: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005353.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005353.html&gt;<br></p><p>So there&#39;s definitely a lot of interest in that.<br></p><p>Freshly out of engineering school, I really liked how my calculator handled that (a bulky old TI Voyage 200, though I think that the N-Spire line can do it too).<br></p><p>Félix<br></p><p>&gt; Le 6 janv. 2016 à 10:17:23, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I implemented a way of type safeing a calculation in Swift. I.e marking an Int as a Degree and then being able to convert to a Radian. (At the bottom of the page)<br>&gt; <br>&gt; The magic for these special structs was the AngleType protocol which allows you to Box up a value (in this case a number) and it handles the Conversion (Apart from two of the methods which I had to implement).<br>&gt; <br>&gt; In theory we could abstract this protocol out, so that others could use it in the library. Then they just use it with their structs and they can handle converting between these types. <br>&gt; <br>&gt; So two questions do we have something like this already? and if not would this be useful ?<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; <br>&gt; <br>&gt; //MARK:- AngleType<br>&gt; <br>&gt; <br>&gt; <br>&gt; protocol AngleType: FloatLiteralConvertible, IntegerLiteralConvertible {<br>&gt; <br>&gt;     <br>&gt;     var value: Double { get set }<br>&gt; <br>&gt;     <br>&gt;     init(_ value: Double)<br>&gt; <br>&gt;     init(_ value: Int)<br>&gt; <br>&gt;     init&lt;T: IntegerType&gt;(integerLiteral value: T)<br>&gt; <br>&gt;     init&lt;T: FloatingPointType&gt;(floatLiteral value: T)<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; // Implement FloatLiteralConvertible and IntegerLiteralConvertible<br>&gt; <br>&gt; <br>&gt; <br>&gt; extension AngleType {<br>&gt; <br>&gt; <br>&gt; <br>&gt;     init&lt;T: IntegerType&gt;(integerLiteral value: T)<br>&gt; <br>&gt;     {<br>&gt; <br>&gt;         self.init(value)<br>&gt; <br>&gt;     }<br>&gt; <br>&gt;     <br>&gt;     init&lt;T: IntegerType&gt;(_ value: T)<br>&gt; <br>&gt;     {<br>&gt; <br>&gt;         self.init(integerLiteral: value)<br>&gt; <br>&gt;     }<br>&gt; <br>&gt;     <br>&gt;     init&lt;T: FloatingPointType&gt;(floatLiteral value: T)<br>&gt; <br>&gt;     {<br>&gt; <br>&gt;         self.init(value)<br>&gt; <br>&gt;     }<br>&gt; <br>&gt;     <br>&gt;     init&lt;T: FloatingPointType&gt;(_ value: T)<br>&gt; <br>&gt;     {<br>&gt; <br>&gt;         self.init(floatLiteral: value)<br>&gt; <br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; //MARK:- Degree<br>&gt; <br>&gt; <br>&gt; <br>&gt; struct Degree: AngleType {<br>&gt; <br>&gt;     <br>&gt;     typealias FloatLiteralType = Double<br>&gt; <br>&gt;     typealias IntegerLiteralType = Int<br>&gt; <br>&gt;     <br>&gt;     var value: Double<br>&gt; <br>&gt;     <br>&gt;     init(_ value: Double) {<br>&gt; <br>&gt;         self.value = value<br>&gt; <br>&gt;     }<br>&gt; <br>&gt;     <br>&gt;     init(_ value: Int) {<br>&gt; <br>&gt;         self.value = Double(value)<br>&gt; <br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; protocol DegreeConvertiable {<br>&gt; <br>&gt;     init(degreeLiteral value: Degree)<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; extension Degree: CustomStringConvertible, CustomDebugStringConvertible {<br>&gt; <br>&gt;     var description: String {<br>&gt; <br>&gt;         return self.value.description<br>&gt; <br>&gt;     }<br>&gt; <br>&gt;     <br>&gt;     var debugDescription: String {<br>&gt; <br>&gt;         return &quot;\(self.value.description)°&quot;<br>&gt; <br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; extension Degree: RadianConvertiable {<br>&gt; <br>&gt;     init(radianLiteral value: Radian) {<br>&gt; <br>&gt;         self.value = Double(radianLiteral:value) * 180.0 / M_PI<br>&gt; <br>&gt;     }<br>&gt; <br>&gt;     <br>&gt;     init(_ value: Radian) {<br>&gt; <br>&gt;         self.init(radianLiteral: value)<br>&gt; <br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; //MARK:- Radian<br>&gt; <br>&gt; <br>&gt; <br>&gt; struct Radian: AngleType {<br>&gt; <br>&gt;     <br>&gt;     typealias FloatLiteralType = Double<br>&gt; <br>&gt;     typealias IntegerLiteralType = Int<br>&gt; <br>&gt;     <br>&gt;     var value: Double<br>&gt; <br>&gt;     <br>&gt;     init(_ value: Double) {<br>&gt; <br>&gt;         self.value = value<br>&gt; <br>&gt;     }<br>&gt; <br>&gt;     <br>&gt;     init(_ value: Int) {<br>&gt; <br>&gt;         self.value = Double(value)<br>&gt; <br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; protocol RadianConvertiable {<br>&gt; <br>&gt;     init(radianLiteral value: Radian)<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; extension Radian: CustomStringConvertible, CustomDebugStringConvertible {<br>&gt; <br>&gt;     var description: String {<br>&gt; <br>&gt;         return self.value.description<br>&gt; <br>&gt;     }<br>&gt; <br>&gt;     <br>&gt;     var debugDescription: String {<br>&gt; <br>&gt;         return &quot;\(self.value.description)㎭&quot;<br>&gt; <br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; extension Radian: DegreeConvertiable {<br>&gt; <br>&gt;     init(degreeLiteral value: Degree) {<br>&gt; <br>&gt;         self.value = Double(degreeLiteral: value) * M_PI / 180.0<br>&gt; <br>&gt;     }<br>&gt; <br>&gt;     <br>&gt;     init(_ value: Degree) {<br>&gt; <br>&gt;         self.init(degreeLiteral: value)<br>&gt; <br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; //MARK:- Adding Conformance To Built In Types<br>&gt; <br>&gt; <br>&gt; <br>&gt; extension FloatLiteralType: DegreeConvertiable, RadianConvertiable<br>&gt; <br>&gt; {<br>&gt; <br>&gt;     init(degreeLiteral degree: Degree) {<br>&gt; <br>&gt;         self.value = degree.value.value<br>&gt; <br>&gt;     }<br>&gt; <br>&gt;     <br>&gt;     init(radianLiteral radian: Radian) {<br>&gt; <br>&gt;         self.value = radian.value.value<br>&gt; <br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; extension CGFloat: DegreeConvertiable, RadianConvertiable<br>&gt; <br>&gt; {<br>&gt; <br>&gt;     init(degreeLiteral degree: Degree) {<br>&gt; <br>&gt;         self.init(degree.value)<br>&gt; <br>&gt;     }<br>&gt; <br>&gt;     <br>&gt;     init(radianLiteral radian: Radian) {<br>&gt; <br>&gt;         self.init(radian.value)<br>&gt; <br>&gt;     }<br>&gt; <br>&gt;     <br>&gt;     init(_ degree: Degree) {<br>&gt; <br>&gt;         self.init(degreeLiteral: degree)<br>&gt; <br>&gt;     }<br>&gt; <br>&gt;     <br>&gt;     init(_ radian: Radian) {<br>&gt; <br>&gt;         self.init(radianLiteral: radian)<br>&gt; <br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; -- <br>&gt;  Wizard<br>&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;<br>&gt; +44 7523 279 698<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/5b9187ea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Type Safe Algorithms</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January  6, 2016 at 04:00:00pm</p></header><div class="content"><p>Seem like the protocol I implemented is actually a Box, so perhaps just<br>adding a box type would allow us to do most of these things.<br></p><p>https://github.com/robrix/Box<br></p><p>On Wed, Jan 6, 2016 at 4:02 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br></p><p>&gt; There are lots of people who had an idea like this one, the latest just<br>&gt; yesterday, where the other threads had been collected:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005353.html<br>&gt;<br>&gt; So there&#39;s definitely a lot of interest in that.<br>&gt;<br>&gt; Freshly out of engineering school, I really liked how my calculator<br>&gt; handled that (a bulky old TI Voyage 200, though I think that the N-Spire<br>&gt; line can do it too).<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 6 janv. 2016 à 10:17:23, James Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; I implemented a way of type safeing a calculation in Swift. I.e marking an<br>&gt; Int as a Degree and then being able to convert to a Radian. (At the bottom<br>&gt; of the page)<br>&gt;<br>&gt; The magic for these special structs was the AngleType protocol which<br>&gt; allows you to Box up a value (in this case a number) and it handles the<br>&gt; Conversion (Apart from two of the methods which I had to implement).<br>&gt;<br>&gt; In theory we could abstract this protocol out, so that others could use it<br>&gt; in the library. Then they just use it with their structs and they can<br>&gt; handle converting between these types.<br>&gt;<br>&gt; So two questions do we have something like this already? and if not would<br>&gt; this be useful ?<br>&gt;<br>&gt; import Foundation<br>&gt;<br>&gt;<br>&gt; //MARK:- AngleType<br>&gt;<br>&gt;<br>&gt; protocol AngleType: FloatLiteralConvertible, IntegerLiteralConvertible {<br>&gt;<br>&gt;<br>&gt;     var value: Double { get set }<br>&gt;<br>&gt;<br>&gt;     init(_ value: Double)<br>&gt;<br>&gt;     init(_ value: Int)<br>&gt;<br>&gt;     init&lt;T: IntegerType&gt;(integerLiteral value: T)<br>&gt;<br>&gt;     init&lt;T: FloatingPointType&gt;(floatLiteral value: T)<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; // Implement FloatLiteralConvertible and IntegerLiteralConvertible<br>&gt;<br>&gt;<br>&gt; extension AngleType {<br>&gt;<br>&gt;<br>&gt;     init&lt;T: IntegerType&gt;(integerLiteral value: T)<br>&gt;<br>&gt;     {<br>&gt;<br>&gt;         self.init(value)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     init&lt;T: IntegerType&gt;(_ value: T)<br>&gt;<br>&gt;     {<br>&gt;<br>&gt;         self.init(integerLiteral: value)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     init&lt;T: FloatingPointType&gt;(floatLiteral value: T)<br>&gt;<br>&gt;     {<br>&gt;<br>&gt;         self.init(value)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     init&lt;T: FloatingPointType&gt;(_ value: T)<br>&gt;<br>&gt;     {<br>&gt;<br>&gt;         self.init(floatLiteral: value)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; //MARK:- Degree<br>&gt;<br>&gt;<br>&gt; struct Degree: AngleType {<br>&gt;<br>&gt;<br>&gt;     typealias FloatLiteralType = Double<br>&gt;<br>&gt;     typealias IntegerLiteralType = Int<br>&gt;<br>&gt;<br>&gt;     var value: Double<br>&gt;<br>&gt;<br>&gt;     init(_ value: Double) {<br>&gt;<br>&gt;         self.value = value<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     init(_ value: Int) {<br>&gt;<br>&gt;         self.value = Double(value)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; protocol DegreeConvertiable {<br>&gt;<br>&gt;     init(degreeLiteral value: Degree)<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; extension Degree: CustomStringConvertible, CustomDebugStringConvertible {<br>&gt;<br>&gt;     var description: String {<br>&gt;<br>&gt;         return self.value.description<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     var debugDescription: String {<br>&gt;<br>&gt;         return &quot;\(self.value.description)°&quot;<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; extension Degree: RadianConvertiable {<br>&gt;<br>&gt;     init(radianLiteral value: Radian) {<br>&gt;<br>&gt;         self.value = Double(radianLiteral:value) * 180.0 / M_PI<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     init(_ value: Radian) {<br>&gt;<br>&gt;         self.init(radianLiteral: value)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; //MARK:- Radian<br>&gt;<br>&gt;<br>&gt; struct Radian: AngleType {<br>&gt;<br>&gt;<br>&gt;     typealias FloatLiteralType = Double<br>&gt;<br>&gt;     typealias IntegerLiteralType = Int<br>&gt;<br>&gt;<br>&gt;     var value: Double<br>&gt;<br>&gt;<br>&gt;     init(_ value: Double) {<br>&gt;<br>&gt;         self.value = value<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     init(_ value: Int) {<br>&gt;<br>&gt;         self.value = Double(value)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; protocol RadianConvertiable {<br>&gt;<br>&gt;     init(radianLiteral value: Radian)<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; extension Radian: CustomStringConvertible, CustomDebugStringConvertible {<br>&gt;<br>&gt;     var description: String {<br>&gt;<br>&gt;         return self.value.description<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     var debugDescription: String {<br>&gt;<br>&gt;         return &quot;\(self.value.description)㎭&quot;<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; extension Radian: DegreeConvertiable {<br>&gt;<br>&gt;     init(degreeLiteral value: Degree) {<br>&gt;<br>&gt;         self.value = Double(degreeLiteral: value) * M_PI / 180.0<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     init(_ value: Degree) {<br>&gt;<br>&gt;         self.init(degreeLiteral: value)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; //MARK:- Adding Conformance To Built In Types<br>&gt;<br>&gt;<br>&gt; extension FloatLiteralType: DegreeConvertiable, RadianConvertiable<br>&gt;<br>&gt; {<br>&gt;<br>&gt;     init(degreeLiteral degree: Degree) {<br>&gt;<br>&gt;         self.value = degree.value.value<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     init(radianLiteral radian: Radian) {<br>&gt;<br>&gt;         self.value = radian.value.value<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; extension CGFloat: DegreeConvertiable, RadianConvertiable<br>&gt;<br>&gt; {<br>&gt;<br>&gt;     init(degreeLiteral degree: Degree) {<br>&gt;<br>&gt;         self.init(degree.value)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     init(radianLiteral radian: Radian) {<br>&gt;<br>&gt;         self.init(radian.value)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     init(_ degree: Degree) {<br>&gt;<br>&gt;         self.init(degreeLiteral: degree)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     init(_ radian: Radian) {<br>&gt;<br>&gt;         self.init(radianLiteral: radian)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt; --<br>&gt;  Wizard<br>&gt; james at supmenow.com<br>&gt; +44 7523 279 698<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br> Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/5192c558/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
