<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May  6, 2016 at 12:00:00pm</p></header><div class="content"><p>Am 05. Mai 2016 um 14:59 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br></p><p><br></p><p><br>Sent from my iPad<br></p><p>On May 5, 2016, at 7:30 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br></p><p><br>To me it reads as a constraint on R. Otherwise we would have to write `protocol R where … : Q where …, S where … { … }` which would not only be confusing but would not make much sense IMHO because I want to be able to write constraints which combine associated types from R, Q and S, i.e. from all sources contributing to R.<br></p><p><br>My early post was poorly worded.  It reads as a constraint on the associated types R inherits (from Q in this example).  You would be able to relate any inherited associated types to each other here if desired.  Any new associated types introduced by R should be constrained where they are introduced.<br></p><p><br>Ah, yes, you are right, of course!<br></p><p>New associated types introduced by R do have their own where clause, so that would be the proper place to constrain them.<br></p><p><br></p><p> <br></p><p><br>Answering Doug’s question: I’d like the name lookup to start in R and to be able to refer to an associated type newly defined in R.<br></p><p><br>This seems confusing to me.  The associated type has not been introduced until inside the body of R.  It doesn&#39;t make sense to allow them to be constrained prior to introduction and it offers no additional functionality.  Separating the constraints on inherited associated types from the constraints on newly introduced associated types adds clarity and readability IMO.  Lookup should only consider inherited protocols.<br></p><p><br>I totally agree.<br></p><p><br>-Thorsten<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br>-Thorsten<br></p><p><br></p><p><br>Am 03.05.2016 um 14:03 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p><br></p><p><br>Sent from my iPad<br></p><p>On May 3, 2016, at 3:37 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br></p><p><br>Sent from my iPhone<br></p><p>On May 2, 2016, at 3:50 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br></p><p><br>Hi Doug,<br></p><p><br>In the latest version of the proposal, which is now linked to a pull request, I mentioned in the Detail Design section that the following syntax be valid:<br></p><p><br>protocol R : Q where AssocType : P {<br>  // …<br>}<br></p><p><br>Can you read through that part of the proposal and let me know if it is descriptive enough?<br></p><p><br>I think you need to clarify the intended name lookup semantics. Does name lookup for &quot;AssocType&quot; start its lookup in R or in Q? If the former, can one refer to an associated type newly defined in R?<br></p><p><br>To me this syntax reads as a constraint on Q only.  If we need a constraint on associated types defined in R the constraint should be attached to the definition.<br></p><p><br></p><p><br>  - Doug<br></p><p><br></p><p><br></p><p><br>David.<br></p><p><br>On 26 Apr 2016, at 05:28, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br></p><p><br></p><p><br>On Apr 24, 2016, at 1:34 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br>I wrote the proposal which was discussed to introduce generic constraints for associated types. I’d like to get some feedback on it and get it ready before submitting it:<br></p><p><br>More Powerful Constraints for Associated Types<br>Proposal: SE-XXXX<br></p><p>Author(s): David Hart<br></p><p>Status: TBD<br>Review manager: TBD<br>Introduction<br></p><p>This proposal seeks to introduce a where expression to associated types declarations to bring the same expressive power as generic type constraints.<br></p><p>This proposal was discussed on the Swift Evolution list in the [swift-evolution] [Completing Generics] Arbitrary requirements in protocols thread.<br></p><p>Believe it or not, I support this direction…<br></p><p><br>Motivation<br></p><p>Currently, associated type declarations can only express simple inheritance constraints and not the more sophisticated constraints available to generic types with the where expression. Some designs, including many in the Standard Library, require more powerful constraints for associated types to be truly elegant. For example, the SequenceType protocol can be declared as follows:<br></p><p>protocol Sequence {<br>    associatedtype Iterator : IteratorProtocol<br>    associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>    ...<br>}<br></p><p>Detail Design<br></p><p>With this proposal, the grammar for protocols associated types would be modified to:<br></p><p>protocol-associated-type-declaration → attributesopt access-level-modifieropt associatedtype typealias-name ­type-inheritance-clause­opt­ typealias-assignment­opt requirement-clauseopt<br></p><p>The new requirement-clause is then used by the compiler to validate the associated types of conforming types.<br></p><p>The only thing that bothers me about this syntax is that I have to introduce an associated type to add requirements. For example, what if I want my inheriting protocol to add a requirement to an existing associated type?<br></p><p><br>protocol P { }<br></p><p><br>protocol Q {<br>  typealias AssocType<br>}<br></p><p><br>protocol R : Q {<br>  // I want to just add “AssocType : P”, but I have to redeclare AssocType to do so<br>  typealias AssocType where AssocType : P<br>}<br></p><p><br>Did you consider an alternate syntax that puts the where clause outside the braces, e.g.,<br></p><p><br>protocol R : Q where AssocType : P {<br>  // …<br>}<br></p><p><br>There are two things I like about this. First, it breaks the unnecessary link between an associated type and a (possibly unrelated) where clause, eliminating the need to redeclare associated types in inheriting protocols. Second, it’s effectively the same syntax as constrained extensions, which have a similar feel.<br></p><p><br>Note that, if we do the above, I’d love to make it an error to define a new associated type with the same name as an associated type in an inherited protocol. It’s odd that we do so, and IIRC the only use case for it is to add requirement to an “existing” associated type.<br></p><p><br> - Doug<br></p><p><br></p><p><br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/71971174/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
