<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8ae34e6aaf28c0e1fe929f36897d107e?s=50"></div><header><strong>Revisiting Optionals as Sequences</strong> from <string>Harlan Haskins</string> &lt;harlan at harlanhaskins.com&gt;<p>December  4, 2015 at 11:00:00pm</p></header><div class="content"><p>Y’know, map and flatMap being part of SequenceType is really a misnomer.<br></p><p>We could always just add Functor and Monad in the standard library!<br></p><p>protocol Functor {<br>    typealias A<br>    typealias B<br>    typealias FB<br>    <br>    func map(_: A -&gt; B) -&gt; FB<br>}<br></p><p>protocol Monad: Functor {<br>    static func pure(f: A) -&gt; Self<br>    func flatMap(f: A -&gt; FB) -&gt; FB<br>    func &gt;&gt;=(x: Self, f: A -&gt; FB) -&gt; FB<br>}<br></p><p>infix operator &gt;&gt;= { associativity left }<br>func &gt;&gt;=&lt;M: Monad&gt;(x: M, f: M.A -&gt; M.FB) -&gt; M.FB {<br>    return x.flatMap(f)<br>}<br>&gt; A few months ago I sent a pair of radars (22414579 nee 22448207 and 21961711) about Optional’s extant overloading of flatMap and how it doesn’t align with either the STL or the reasons given for the closing of both radars.  <br>&gt; <br>&gt; &gt; This issue behaves as intended based on the following:<br>&gt; &gt; <br>&gt; &gt; Yes, we are aware that this overload of flatMap could be viewed as unconventional. Nevertheless, it is useful and fits the overload set in general, if you view Optional as a sequence of zero or one T. It resembles this overload, where the closure returns an arbitrary sequence:<br>&gt; &gt; <br>&gt; &gt; extension SequenceType {<br>&gt; &gt;   public func flatMap&lt;S : SequenceType&gt;(transform: (Generator.Element) -&gt; S) -&gt; [S.Generator.Element]<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; The type checker ensures that there is no ambiguity between the two overloads, and we don&#39;t see a reason to give one of the overloads a different name (and force users to learn it, and differentiate between the two), since conceptually the operation is the same.<br>&gt; <br>&gt; If Swift wishes to regard Optionals as collections with 1 or 0 elements, then I propose that it should reflect that thinking with additions to the standard library.<br>&gt; <br>&gt; Possible changes include:<br>&gt; <br>&gt; 1) Remove or rename Optional’s flatMap.  <br>&gt; This would cause a bit of breaking behavior, but it’s nothing some fixits couldn’t help with.<br>&gt; <br>&gt; 2) Add a SequenceType instance for Optional.<br>&gt; This kills 2 birds with 1 stone in that, if the radar rejection is to ring true, Optional should have a SequenceType instance in the STL, and such an instance would automatically come with its own proper overloading flatMap necessitating change 1.<br>&gt; <br>&gt;  Over in TypeLift land we’ve already implemented what we believe the SequenceType extensions should look like (https://github.com/typelift/Swiftz/blob/master/Swiftz/OptionalExt.swift#L139-L145 &lt;https://github.com/typelift/Swiftz/blob/master/Swiftz/OptionalExt.swift#L139-L145&gt; &lt;https://github.com/typelift/Swiftz/blob/master/Swiftz/OptionalExt.swift#L139-L145 &lt;https://github.com/typelift/Swiftz/blob/master/Swiftz/OptionalExt.swift#L139-L145&gt;&gt;).<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/186a6e80/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Revisiting Optionals as Sequences</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  4, 2015 at 10:00:00pm</p></header><div class="content"><p>That definition is unusable, since it restricts the type of the<br>map operation to be whatever type you chose when you implemented<br>the protocol.<br></p><p>To see this for yourself, try implementing Functor on Array. You can&#39;t<br>do it, unless you pick the B type ahead of time, and if you do that you<br>can only ever map() to that single type B. The map() function is<br>supposed to be generic on the result type of the function, but since<br>Swift doesn&#39;t have higher-order types there&#39;s no way to express that the<br>result of the map() function is the same underlying data structure with<br>a separate generic parameter.<br></p><p>-Kevin Ballard<br></p><p><br>On Fri, Dec 4, 2015, at 08:56 PM, Harlan Haskins wrote:<br>&gt;<br>&gt; Y’know, map and flatMap being part of SequenceType is really a<br>&gt; misnomer.<br>&gt;<br>&gt; We could always just add Functor and Monad in the standard library!<br>&gt;<br>&gt; protocol Functor {    typealias A    typealias B    typealias FB<br>&gt;<br></p><p><br>&gt; func map(_: A -&gt; B) -&gt; FB }<br>&gt;<br>&gt; protocol Monad: Functor {    static func pure(f: A) -&gt; Self    func<br>&gt; flatMap(f: A -&gt; FB) -&gt; FB    func &gt;&gt;=(x: Self, f: A -&gt; FB) -&gt; FB }<br>&gt;<br>&gt; infix operator &gt;&gt;= { associativity left } func &gt;&gt;=&lt;M: Monad&gt;(x: M, f:<br>&gt; M.A -&gt; M.FB) -&gt; M.FB {    return x.flatMap(f) }<br>&gt;&gt; A few months ago I sent a pair of radars (22414579 nee 22448207 and<br>&gt;&gt; 21961711) about Optional’s extant overloading of flatMap and how it<br>&gt;&gt; doesn’t align with either the STL or the reasons given for the<br>&gt;&gt; closing of both radars.<br></p><p>&gt;* This issue behaves as intended based on the following:<br>*&gt;**&gt;* Yes, we are aware that this overload of flatMap could be viewed<br>as unconventional. Nevertheless, it is useful and fits the overload set<br>in general, if you view Optional as a sequence of zero or one T. It<br>resembles this overload, where the closure returns an arbitrary<br>sequence: *&gt;**&gt;* extension SequenceType { *&gt;*   public func flatMap&lt;S :<br>SequenceType&gt;(transform: (Generator.Element) -&gt; S) -&gt;<br>[S.Generator.Element] *&gt;* } *&gt;**&gt;* The type checker ensures that there<br>is no ambiguity between the two overloads, and we don&#39;t see a reason to<br>give one of the overloads a different name (and force users to learn it,<br>and differentiate between the two), since conceptually the operation is<br>the same. * If Swift wishes to regard Optionals as collections with 1 or<br>0 elements, then I propose that it should reflect that thinking with<br>additions to the standard library.<br></p><p>Possible changes include:<br></p><p>1) Remove or rename Optional’s flatMap. This would cause a bit of<br>   breaking behavior, but it’s nothing some fixits couldn’t help with.<br></p><p>2) Add a SequenceType instance for Optional. This kills 2 birds with 1<br>   stone in that, if the radar rejection is to ring true, Optional<br>   should have a SequenceType instance in the STL, and such an instance<br>   would automatically come with its own proper overloading flatMap<br>   necessitating change 1.<br></p><p> Over in TypeLift land we’ve already implemented what we believe the<br> SequenceType extensions should look like (https://github.com/typelift/-<br> Swiftz/blob/master/Swiftz/OptionalExt.swift#L139-L145<br> &lt;https://github.com/typelift/Swiftz/blob/master/Swiftz/OptionalExt.swift#L139-L145&gt;<br> ).<br>&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/b57a7251/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Revisiting Optionals as Sequences</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>December  5, 2015 at 12:00:00am</p></header><div class="content"><p>Oh please, please, never let those leave TypeLift&#39;s repositories until HKTs get merged... :P<br></p><p>I guess what I want is consistency, either of implementation or of terminology.  Because right now the language has neither and is trampling a function with a very consistent, rigorous definition for what I&#39;m not sure?<br></p><p>~Robert Widmann<br></p><p>2015/12/04 23:56、Harlan Haskins &lt;harlan at harlanhaskins.com&gt; のメッセージ:<br></p><p>&gt; Y’know, map and flatMap being part of SequenceType is really a misnomer.<br>&gt; <br>&gt; We could always just add Functor and Monad in the standard library!<br>&gt; <br>&gt; protocol Functor {<br>&gt;     typealias A<br>&gt;     typealias B<br>&gt;     typealias FB<br>&gt;     <br>&gt;     func map(_: A -&gt; B) -&gt; FB<br>&gt; }<br>&gt; <br>&gt; protocol Monad: Functor {<br>&gt;     static func pure(f: A) -&gt; Self<br>&gt;     func flatMap(f: A -&gt; FB) -&gt; FB<br>&gt;     func &gt;&gt;=(x: Self, f: A -&gt; FB) -&gt; FB<br>&gt; }<br>&gt; <br>&gt; infix operator &gt;&gt;= { associativity left }<br>&gt; func &gt;&gt;=&lt;M: Monad&gt;(x: M, f: M.A -&gt; M.FB) -&gt; M.FB {<br>&gt;     return x.flatMap(f)<br>&gt; }<br>&gt;&gt; A few months ago I sent a pair of radars (22414579 nee 22448207 and 21961711) about Optional’s extant overloading of flatMap and how it doesn’t align with either the STL or the reasons given for the closing of both radars.  <br>&gt;&gt; <br>&gt;&gt; &gt; This issue behaves as intended based on the following:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Yes, we are aware that this overload of flatMap could be viewed as unconventional. Nevertheless, it is useful and fits the overload set in general, if you view Optional as a sequence of zero or one T. It resembles this overload, where the closure returns an arbitrary sequence:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; extension SequenceType {<br>&gt;&gt; &gt;   public func flatMap&lt;S : SequenceType&gt;(transform: (Generator.Element) -&gt; S) -&gt; [S.Generator.Element]<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; The type checker ensures that there is no ambiguity between the two overloads, and we don&#39;t see a reason to give one of the overloads a different name (and force users to learn it, and differentiate between the two), since conceptually the operation is the same.<br>&gt;&gt; <br>&gt;&gt; If Swift wishes to regard Optionals as collections with 1 or 0 elements, then I propose that it should reflect that thinking with additions to the standard library.<br>&gt;&gt; <br>&gt;&gt; Possible changes include:<br>&gt;&gt; <br>&gt;&gt; 1) Remove or rename Optional’s flatMap.  <br>&gt;&gt; This would cause a bit of breaking behavior, but it’s nothing some fixits couldn’t help with.<br>&gt;&gt; <br>&gt;&gt; 2) Add a SequenceType instance for Optional.<br>&gt;&gt; This kills 2 birds with 1 stone in that, if the radar rejection is to ring true, Optional should have a SequenceType instance in the STL, and such an instance would automatically come with its own proper overloading flatMap necessitating change 1.<br>&gt;&gt; <br>&gt;&gt;  Over in TypeLift land we’ve already implemented what we believe the SequenceType extensions should look like (https://github.com/typelift/Swiftz/blob/master/Swiftz/OptionalExt.swift#L139-L145 &lt;https://github.com/typelift/Swiftz/blob/master/Swiftz/OptionalExt.swift#L139-L145&gt;).<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/7c4ce914/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
