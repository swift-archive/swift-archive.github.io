<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  3, 2016 at 05:00:00pm</p></header><div class="content"><p>on Wed Feb 03 2016, Radosław Pietruszewski &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Overall, great guidelines (and +1 to the rules Erica wrote up), and<br>&gt; I’m +1 on conveying these nuances in the guidelines.<br>&gt;<br>&gt;&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;&gt;   should go in the base name rather than in a label:<br>&gt;&gt; <br>&gt;&gt;      a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;      a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;&gt; <br>&gt;&gt;      a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;&gt;      a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;&gt; <br>&gt;&gt;   [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;&gt;   ambiguous]<br>&gt;&gt; <br>&gt;&gt;   Words that describe attributes of an instance *to be created* should<br>&gt;&gt;   go in argument labels, rather than the base name (for parity with<br>&gt;&gt;   initializers):<br>&gt;&gt; <br>&gt;&gt;      AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;&gt;      trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt; <br>&gt;&gt;      trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;<br>&gt; The rationale for doing this is stronger when we talk about automatic<br>&gt; translation of Objective-C APIs.<br></p><p>For better or worse, it is a requirement that Cocoa as imported very<br>closely approximates full conformance to the guidelines we choose.  We<br>are shooting for consistency across APIs used in swift.<br></p><p>&gt; But in APIs designed for Swift, I feel like this is wrong IMHO, because:<br>&gt;<br>&gt; - “media type” is still a parameter, so it shouldn’t be in the base<br>&gt;   name itself<br></p><p>That doesn&#39;t seem obvious to me.  Whether that &quot;should&quot; be in the base<br>name depends on what guidelines we choose.  <br></p><p>&gt; - this breaks the symmetry with other methods due to the reason above<br>&gt;   (like the “newTrack” you mentioned yourself) <br></p><p>Yes, it would be more consistent if these two cases were the same.  <br></p><p>&gt; - doesn’t play well with method families (searching for tracks is<br>&gt;   searching for tracks. the criteria for search are just parameters).<br></p><p>I don&#39;t really believe that “method families” are something we want to<br>optimize for in Swift.  There are almost always alternatives that impose<br>lower cognitive overhead on users.<br></p><p>&gt; If we do<br>&gt;<br>&gt;    trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;<br>&gt; I don’t see why it’s OK to do<br>&gt;<br>&gt;    a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br></p><p>That&#39;s just the consistency argument again, right?<br></p><p>&gt; Of course just “tracks” is confusing, and we agree on that, but I<br>&gt; would strongly recommend that for new APIs we don’t just name the<br>&gt; method with a word of an already-existing instance, rather, we start<br>&gt; it with a verb:<br>&gt;<br>&gt; a.findTracks(mediaType: “BetaMax”) // or “searchTracks”, or alternatively “tracksMatching&quot;<br>&gt; a.removeFirstTrackMatching(mediaType: “BetaMax”)   — ad 2<br>&gt; fac.newTrack(mediaType: “Wax Cylinder”)<br>&gt;<br>&gt; Symmetric, predictable, follows the same convention, plays well with<br>&gt; method families (i.e. different search criterion than media type), and<br>&gt; no clarity problems.<br></p><p>Unfortunately, this is the reality:<br></p><p>1. The pattern of omitting prefix verbs like “get” and “find” is<br>   something of a sacred cow; I think it would be very hard to sell to<br>   certain important people.<br></p><p>2. if we were to standardize on the opposite, we would need an<br>   objective-C import strategy that would add these verbs automatically.<br></p><p>If you can get a handle on solving #2, it *might* be worth me taking a<br>shot at solving #1. Otherwise, I&#39;m afraid this idea is dead in the<br>water.  Nothing that leaves glaring inconsistencies between imported<br>Cocoa and the API guidelines is going to be acceptable.<br></p><p>&gt; Ad 2: I can see why you don’t like “removeFirstTrack”. It sounds like<br>&gt; removing _the_ first track, rather than the first track that matches<br>&gt; criteria in parameters list. Perhaps a word like “Matching” would work<br>&gt; well to fix this concern. (And sounds/conveys intention better than<br>&gt; “with” or “having” IMHO)<br></p><p>There are contexts in which &quot;matching&quot; is more ambiguous than &quot;having&quot;,<br>e.g.<br></p><p>    x.trackMatchingMediaType(t) // track the matching media type?<br></p><p>    x.trackHavingMediaType(t)   // track is obviously a non-verb here.<br></p><p>Yes, I see how this relates to your &quot;put back the verb&quot; idea.<br></p><p>&gt;<br>&gt; Just my 2¢,<br>&gt; — Radek<br>&gt;<br>&gt;&gt; On 03 Feb 2016, at 01:32, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt;&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt;&gt; guidelines that:<br>&gt;&gt; <br>&gt;&gt; * describe when and where to use argument labels<br>&gt;&gt; * require labels in many of the cases people have asked for them<br>&gt;&gt; * are understandable by humans<br>&gt;&gt; * preserve important semantics communicated by existing APIs.<br>&gt;&gt; <br>&gt;&gt; Here&#39;s what I&#39;m thinking<br>&gt;&gt; <br>&gt;&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;&gt;   beginning in the base name and describing the primary semantics of<br>&gt;&gt;   the call, it gets no argument label:<br>&gt;&gt; <br>&gt;&gt;     a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;&gt;     a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt;&gt; <br>&gt;&gt;     a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;&gt;                            // doesn&#39;t describe the semantics at all, <br>&gt;&gt;                            // thus we add a label for b.<br>&gt;&gt; <br>&gt;&gt;     a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;&gt;                              // but doesn&#39;t describe the primary <br>&gt;&gt;                              // semantics, which are to move in both<br>&gt;&gt;                              // x and y.  Thus, x gets a label.<br>&gt;&gt; <br>&gt;&gt;     a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;&gt;                              // the primary semantics, so u gets no<br>&gt;&gt;                              // label. b is an<br>&gt;&gt;                              // option that tunes the primary<br>&gt;&gt;                              // semantics<br>&gt;&gt; <br>&gt;&gt;   [Note that this covers all the direct object cases and, I believe,<br>&gt;&gt;   all the default argument cases too, so maybe that exception can be<br>&gt;&gt;   dropped.  We still need the exceptions for full-width type<br>&gt;&gt;   conversions and indistinguishable peers]<br>&gt;&gt; <br>&gt;&gt;   Note: when there is a noun in the base name describing the role of the<br>&gt;&gt;   first argument, we skip it in considering this criterion:<br>&gt;&gt; <br>&gt;&gt;      a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>&gt;&gt;                       // the semantics.  &quot;Observer&quot; is omitted in <br>&gt;&gt;                       // making this determination.<br>&gt;&gt; <br>&gt;&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;&gt;  clause doesn&#39;t rule out any important use-cases (see<br>&gt;&gt;  https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;&gt;  point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;&gt;  universally-understood term.<br>&gt;&gt; <br>&gt;&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;&gt;   should go in the base name rather than in a label:<br>&gt;&gt; <br>&gt;&gt;      a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;      a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;&gt; <br>&gt;&gt;      a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;&gt;      a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;&gt; <br>&gt;&gt;   [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;&gt;   ambiguous]<br>&gt;&gt; <br>&gt;&gt;   Words that describe attributes of an instance *to be created* should<br>&gt;&gt;   go in argument labels, rather than the base name (for parity with<br>&gt;&gt;   initializers):<br>&gt;&gt; <br>&gt;&gt;      AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;&gt;      trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt; <br>&gt;&gt;      trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;&gt; <br>&gt;&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;&gt;   *identifier* of the subject in the base name, do not label it or<br>&gt;&gt;   describe it in the base name.<br>&gt;&gt; <br>&gt;&gt;      a.transitionToScene(.GreatHall)               // yes<br>&gt;&gt;      a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt;&gt; <br>&gt;&gt;      let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;&gt;      let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;&gt;      let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 04 Feb 2016, at 02:20, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Feb 03 2016, Radosław Pietruszewski &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Overall, great guidelines (and +1 to the rules Erica wrote up), and<br>&gt;&gt; I’m +1 on conveying these nuances in the guidelines.<br>&gt;&gt; <br>&gt;&gt;&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;&gt;&gt;  should go in the base name rather than in a label:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;&gt;     a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;&gt;&gt;     a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;&gt;&gt;  ambiguous]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Words that describe attributes of an instance *to be created* should<br>&gt;&gt;&gt;  go in argument labels, rather than the base name (for parity with<br>&gt;&gt;&gt;  initializers):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;&gt;&gt;     trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;&gt; <br>&gt;&gt; The rationale for doing this is stronger when we talk about automatic<br>&gt;&gt; translation of Objective-C APIs.<br>&gt; <br>&gt; For better or worse, it is a requirement that Cocoa as imported very<br>&gt; closely approximates full conformance to the guidelines we choose.  We<br>&gt; are shooting for consistency across APIs used in swift.<br></p><p>Hmm. Understood, but sigh. Personally I think it’s a shame to constrain ourselves to (imho) inferior naming convention because it’s what existing ObjC APIs use. Definitely understandable, but considering this isn’t a _really_ super common pattern, I think it would be just fine to leave the translations in good-enough state (whatever the decision on SE-0005 is), and follow a new convention in new Swift APIs.<br></p><p>&gt; <br>&gt;&gt; But in APIs designed for Swift, I feel like this is wrong IMHO, because:<br>&gt;&gt; <br>&gt;&gt; - “media type” is still a parameter, so it shouldn’t be in the base<br>&gt;&gt;  name itself<br>&gt; <br>&gt; That doesn&#39;t seem obvious to me.  Whether that &quot;should&quot; be in the base<br>&gt; name depends on what guidelines we choose.  <br></p><p>Of course. The way I think of it: the primary semantic is “find a track”, and media type is a criterion for search. I understand method families aren’t something you’re looking to optimize, but you can imagine that _if_ this was a family, it would still be “find a track”, just with different criteria.<br></p><p>&gt;&gt; - this breaks the symmetry with other methods due to the reason above<br>&gt;&gt;  (like the “newTrack” you mentioned yourself) <br>&gt; <br>&gt; Yes, it would be more consistent if these two cases were the same.  <br>&gt; <br>&gt;&gt; - doesn’t play well with method families (searching for tracks is<br>&gt;&gt;  searching for tracks. the criteria for search are just parameters).<br>&gt; <br>&gt; I don&#39;t really believe that “method families” are something we want to<br>&gt; optimize for in Swift.  There are almost always alternatives that impose<br>&gt; lower cognitive overhead on users.<br></p><p>Fair.<br></p><p>&gt; <br>&gt;&gt; If we do<br>&gt;&gt; <br>&gt;&gt;   trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt; <br>&gt;&gt; I don’t see why it’s OK to do<br>&gt;&gt; <br>&gt;&gt;   a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt; <br>&gt; That&#39;s just the consistency argument again, right?<br></p><p>Yes.<br></p><p>&gt; <br>&gt;&gt; Of course just “tracks” is confusing, and we agree on that, but I<br>&gt;&gt; would strongly recommend that for new APIs we don’t just name the<br>&gt;&gt; method with a word of an already-existing instance, rather, we start<br>&gt;&gt; it with a verb:<br>&gt;&gt; <br>&gt;&gt; a.findTracks(mediaType: “BetaMax”) // or “searchTracks”, or alternatively “tracksMatching&quot;<br>&gt;&gt; a.removeFirstTrackMatching(mediaType: “BetaMax”)   — ad 2<br>&gt;&gt; fac.newTrack(mediaType: “Wax Cylinder”)<br>&gt;&gt; <br>&gt;&gt; Symmetric, predictable, follows the same convention, plays well with<br>&gt;&gt; method families (i.e. different search criterion than media type), and<br>&gt;&gt; no clarity problems.<br>&gt; <br>&gt; Unfortunately, this is the reality:<br>&gt; <br>&gt; 1. The pattern of omitting prefix verbs like “get” and “find” is<br>&gt;   something of a sacred cow; I think it would be very hard to sell to<br>&gt;   certain important people.<br></p><p>Hmm, I didn’t think of that. “get” is sort of understandable, I can see how in some languages you’d do “getFoo()”, whereas in Swift it would probably be a property “foo”. I don’t see a problem with “find”, though, as it really does help convey the intent.<br></p><p>&gt; <br>&gt; 2. if we were to standardize on the opposite, we would need an<br>&gt;   objective-C import strategy that would add these verbs automatically.<br>&gt; <br>&gt; If you can get a handle on solving #2, it *might* be worth me taking a<br>&gt; shot at solving #1. Otherwise, I&#39;m afraid this idea is dead in the<br>&gt; water.  Nothing that leaves glaring inconsistencies between imported<br>&gt; Cocoa and the API guidelines is going to be acceptable.<br></p><p>Then perhaps let’s meet halfway:<br></p><p>   a.tracksWith(mediaType: “BetaMax”)<br>   a.removeFirstTrackWith(mediaType: “BetaMax”)<br>   fac.newTrack(mediaType: “Wax Cyllinder”)<br></p><p>(replace “with” with “matching” or “having” if you prefer)<br></p><p>I don’t love it, but like it much more than “tracksHavingMediaType”:<br></p><p>- still much more consistent about what goes into explicit parameters<br>- having a “with”/etc helps convey that parameters are the criteria for tracks returned<br>- doable as an automatic translation from ObjC<br></p><p>&gt;&gt; Ad 2: I can see why you don’t like “removeFirstTrack”. It sounds like<br>&gt;&gt; removing _the_ first track, rather than the first track that matches<br>&gt;&gt; criteria in parameters list. Perhaps a word like “Matching” would work<br>&gt;&gt; well to fix this concern. (And sounds/conveys intention better than<br>&gt;&gt; “with” or “having” IMHO)<br>&gt; <br>&gt; There are contexts in which &quot;matching&quot; is more ambiguous than &quot;having&quot;,<br>&gt; e.g.<br>&gt; <br>&gt;    x.trackMatchingMediaType(t) // track the matching media type?<br>&gt; <br>&gt;    x.trackHavingMediaType(t)   // track is obviously a non-verb here.<br>&gt; <br>&gt; Yes, I see how this relates to your &quot;put back the verb&quot; idea.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Just my 2¢,<br>&gt;&gt; — Radek<br>&gt;&gt; <br>&gt;&gt;&gt; On 03 Feb 2016, at 01:32, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt;&gt;&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt;&gt;&gt; guidelines that:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * describe when and where to use argument labels<br>&gt;&gt;&gt; * require labels in many of the cases people have asked for them<br>&gt;&gt;&gt; * are understandable by humans<br>&gt;&gt;&gt; * preserve important semantics communicated by existing APIs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here&#39;s what I&#39;m thinking<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;&gt;&gt;  beginning in the base name and describing the primary semantics of<br>&gt;&gt;&gt;  the call, it gets no argument label:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;&gt;&gt;    a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;&gt;&gt;                           // doesn&#39;t describe the semantics at all, <br>&gt;&gt;&gt;                           // thus we add a label for b.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;&gt;&gt;                             // but doesn&#39;t describe the primary <br>&gt;&gt;&gt;                             // semantics, which are to move in both<br>&gt;&gt;&gt;                             // x and y.  Thus, x gets a label.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;&gt;&gt;                             // the primary semantics, so u gets no<br>&gt;&gt;&gt;                             // label. b is an<br>&gt;&gt;&gt;                             // option that tunes the primary<br>&gt;&gt;&gt;                             // semantics<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  [Note that this covers all the direct object cases and, I believe,<br>&gt;&gt;&gt;  all the default argument cases too, so maybe that exception can be<br>&gt;&gt;&gt;  dropped.  We still need the exceptions for full-width type<br>&gt;&gt;&gt;  conversions and indistinguishable peers]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Note: when there is a noun in the base name describing the role of the<br>&gt;&gt;&gt;  first argument, we skip it in considering this criterion:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>&gt;&gt;&gt;                      // the semantics.  &quot;Observer&quot; is omitted in <br>&gt;&gt;&gt;                      // making this determination.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;&gt;&gt; clause doesn&#39;t rule out any important use-cases (see<br>&gt;&gt;&gt; https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;&gt;&gt; point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;&gt;&gt; universally-understood term.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;&gt;&gt;  should go in the base name rather than in a label:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;&gt;     a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;&gt;&gt;     a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;&gt;&gt;  ambiguous]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Words that describe attributes of an instance *to be created* should<br>&gt;&gt;&gt;  go in argument labels, rather than the base name (for parity with<br>&gt;&gt;&gt;  initializers):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;&gt;&gt;     trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;&gt;&gt;  *identifier* of the subject in the base name, do not label it or<br>&gt;&gt;&gt;  describe it in the base name.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     a.transitionToScene(.GreatHall)               // yes<br>&gt;&gt;&gt;     a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;&gt;&gt;     let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;&gt;&gt;     let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>February  4, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Feb 4, 2016, at 00:23, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Personally I think it’s a shame to constrain ourselves to (imho) inferior naming convention because it’s what existing ObjC APIs use. Definitely understandable, but considering this isn’t a _really_ super common pattern, I think it would be just fine to leave the translations in good-enough state (whatever the decision on SE-0005 is), and follow a new convention in new Swift APIs.<br></p><p>+1.  Strongly agree on this.<br></p><p>Matt<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 4, 2016, at 8:21 AM, Matt Whiteside &lt;mwhiteside.dev at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 4, 2016, at 00:23, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Personally I think it’s a shame to constrain ourselves to (imho) inferior naming convention because it’s what existing ObjC APIs use. Definitely understandable, but considering this isn’t a _really_ super common pattern, I think it would be just fine to leave the translations in good-enough state (whatever the decision on SE-0005 is), and follow a new convention in new Swift APIs.<br>&gt; <br>&gt; +1.  Strongly agree on this.<br></p><p>Well, let me just say that there may be room for these kinds of principles to evolve in the future, but those are the constraints we have to work within to get this first round of guidelines out.  This importer technique can only carry us so far: Swift will acquire new expressive capabilities, and we (Apple) will have to consider other ways to make sure Cocoa&#39;s APIs keep up.  <br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>February  4, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 4, 2016, at 11:04, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 4, 2016, at 8:21 AM, Matt Whiteside &lt;mwhiteside.dev at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 4, 2016, at 00:23, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally I think it’s a shame to constrain ourselves to (imho) inferior naming convention because it’s what existing ObjC APIs use. Definitely understandable, but considering this isn’t a _really_ super common pattern, I think it would be just fine to leave the translations in good-enough state (whatever the decision on SE-0005 is), and follow a new convention in new Swift APIs.<br>&gt;&gt; <br>&gt;&gt; +1.  Strongly agree on this.<br>&gt; <br>&gt; Well, let me just say that there may be room for these kinds of principles to evolve in the future, but those are the constraints we have to work within to get this first round of guidelines out.  <br>That’s understandable.<br></p><p>&gt; This importer technique can only carry us so far: Swift will acquire new expressive capabilities, and we (Apple) will have to consider other ways to make sure Cocoa&#39;s APIs keep up.  <br>This is reassuring to hear.  My earlier concerns seem much less pressing with this in mind.<br></p><p>Matt<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  4, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 4, 2016, at 12:23 AM, Radosław Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 04 Feb 2016, at 02:20, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Feb 03 2016, Radosław Pietruszewski &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Overall, great guidelines (and +1 to the rules Erica wrote up), and<br>&gt;&gt;&gt; I’m +1 on conveying these nuances in the guidelines.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;&gt;&gt;&gt; should go in the base name rather than in a label:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;&gt;&gt;    a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;&gt;&gt;&gt;    a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;&gt;&gt;&gt; ambiguous]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Words that describe attributes of an instance *to be created* should<br>&gt;&gt;&gt;&gt; go in argument labels, rather than the base name (for parity with<br>&gt;&gt;&gt;&gt; initializers):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;&gt;&gt;&gt;    trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The rationale for doing this is stronger when we talk about automatic<br>&gt;&gt;&gt; translation of Objective-C APIs.<br>&gt;&gt; <br>&gt;&gt; For better or worse, it is a requirement that Cocoa as imported very<br>&gt;&gt; closely approximates full conformance to the guidelines we choose.  We<br>&gt;&gt; are shooting for consistency across APIs used in swift.<br>&gt; <br>&gt; Hmm. Understood, but sigh. Personally I think it’s a shame to constrain ourselves to (imho) inferior naming convention because it’s what existing ObjC APIs use. Definitely understandable, but considering this isn’t a _really_ super common pattern, I think it would be just fine to leave the translations in good-enough state (whatever the decision on SE-0005 is), and follow a new convention in new Swift APIs.<br></p><p>Well, to give you an idea, we&#39;ve been going with the ground rule that the number of APIs that need to be fixed up with NS_SWIFT_NAME because they become actively worse needs to be &lt;1%.  I estimate that we can accept maybe 3% of APIs looking not-quite-right but no worse than before.<br></p><p>If these fall into that 3%, it might be acceptable.<br></p><p>&gt;&gt;&gt; But in APIs designed for Swift, I feel like this is wrong IMHO, because:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - “media type” is still a parameter, so it shouldn’t be in the base<br>&gt;&gt;&gt; name itself<br>&gt;&gt; <br>&gt;&gt; That doesn&#39;t seem obvious to me.  Whether that &quot;should&quot; be in the base<br>&gt;&gt; name depends on what guidelines we choose.  <br>&gt; <br>&gt; Of course. The way I think of it: the primary semantic is “find a track”, and media type is a criterion for search. I understand method families aren’t something you’re looking to optimize, but you can imagine that _if_ this was a family, it would still be “find a track”, just with different criteria.<br></p><p>Yes, this makes a lot of sense to me.  Maybe we can distinguish the &quot;find&quot; cases from the &quot;get&quot; cases as you suggest below.<br></p><p>&gt;&gt;&gt; - this breaks the symmetry with other methods due to the reason above<br>&gt;&gt;&gt; (like the “newTrack” you mentioned yourself) <br>&gt;&gt; <br>&gt;&gt; Yes, it would be more consistent if these two cases were the same.  <br>&gt;&gt; <br>&gt;&gt;&gt; - doesn’t play well with method families (searching for tracks is<br>&gt;&gt;&gt; searching for tracks. the criteria for search are just parameters).<br>&gt;&gt; <br>&gt;&gt; I don&#39;t really believe that “method families” are something we want to<br>&gt;&gt; optimize for in Swift.  There are almost always alternatives that impose<br>&gt;&gt; lower cognitive overhead on users.<br>&gt; <br>&gt; Fair.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; If we do<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t see why it’s OK to do<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt; <br>&gt;&gt; That&#39;s just the consistency argument again, right?<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Of course just “tracks” is confusing, and we agree on that, but I<br>&gt;&gt;&gt; would strongly recommend that for new APIs we don’t just name the<br>&gt;&gt;&gt; method with a word of an already-existing instance, rather, we start<br>&gt;&gt;&gt; it with a verb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; a.findTracks(mediaType: “BetaMax”) // or “searchTracks”, or alternatively “tracksMatching&quot;<br>&gt;&gt;&gt; a.removeFirstTrackMatching(mediaType: “BetaMax”)   — ad 2<br>&gt;&gt;&gt; fac.newTrack(mediaType: “Wax Cylinder”)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Symmetric, predictable, follows the same convention, plays well with<br>&gt;&gt;&gt; method families (i.e. different search criterion than media type), and<br>&gt;&gt;&gt; no clarity problems.<br>&gt;&gt; <br>&gt;&gt; Unfortunately, this is the reality:<br>&gt;&gt; <br>&gt;&gt; 1. The pattern of omitting prefix verbs like “get” and “find” is<br>&gt;&gt;  something of a sacred cow; I think it would be very hard to sell to<br>&gt;&gt;  certain important people.<br>&gt; <br>&gt; Hmm, I didn’t think of that. “get” is sort of understandable, I can see how in some languages you’d do “getFoo()”, whereas in Swift it would probably be a property “foo”. I don’t see a problem with “find”, though, as it really does help convey the intent.<br></p><p>I&#39;m not sure I know how to make that case without getting into arguments about efficiency.  Some people have a *very* strong resistance to allowing naming guidelines to be dependent on efficiency.  Ideas?<br></p><p>&gt;&gt; <br>&gt;&gt; 2. if we were to standardize on the opposite, we would need an<br>&gt;&gt;  objective-C import strategy that would add these verbs automatically.<br>&gt;&gt; <br>&gt;&gt; If you can get a handle on solving #2, it *might* be worth me taking a<br>&gt;&gt; shot at solving #1. Otherwise, I&#39;m afraid this idea is dead in the<br>&gt;&gt; water.  Nothing that leaves glaring inconsistencies between imported<br>&gt;&gt; Cocoa and the API guidelines is going to be acceptable.<br>&gt; <br>&gt; Then perhaps let’s meet halfway:<br>&gt; <br>&gt;   a.tracksWith(mediaType: “BetaMax”)<br>&gt;   a.removeFirstTrackWith(mediaType: “BetaMax”)<br>&gt;   fac.newTrack(mediaType: “Wax Cyllinder”)<br>&gt; <br>&gt; (replace “with” with “matching” or “having” if you prefer)<br>&gt; <br>&gt; I don’t love it, but like it much more than “tracksHavingMediaType”:<br>&gt; <br>&gt; - still much more consistent about what goes into explicit parameters<br>&gt; - having a “with”/etc helps convey that parameters are the criteria for tracks returned<br></p><p>I can&#39;t disagree.  At least one of us in the guidelines working group has a visceral negative reaction to ending a basename with &quot;With&quot;.  I&#39;ll have to ask whether that applies to every preposition or not.<br></p><p>&gt; - doable as an automatic translation from ObjC<br></p><p>Hmm, are you sure?  The problem may be identifying those places where &quot;with&quot; functions this way vs. as a vacuous separator.  The latest best heuristic we&#39;ve got for doing that is to consider it a vacuous separator when there&#39;s a verb in the name, but that will fall down on removeFirstTrackWith...<br>It&#39;s all about finding an automated approximation to the actual guidelines that gives a fairly low error rate.<br></p><p>&gt;&gt;&gt; Ad 2: I can see why you don’t like “removeFirstTrack”. It sounds like<br>&gt;&gt;&gt; removing _the_ first track, rather than the first track that matches<br>&gt;&gt;&gt; criteria in parameters list. Perhaps a word like “Matching” would work<br>&gt;&gt;&gt; well to fix this concern. (And sounds/conveys intention better than<br>&gt;&gt;&gt; “with” or “having” IMHO)<br>&gt;&gt; <br>&gt;&gt; There are contexts in which &quot;matching&quot; is more ambiguous than &quot;having&quot;,<br>&gt;&gt; e.g.<br>&gt;&gt; <br>&gt;&gt;   x.trackMatchingMediaType(t) // track the matching media type?<br>&gt;&gt; <br>&gt;&gt;   x.trackHavingMediaType(t)   // track is obviously a non-verb here.<br>&gt;&gt; <br>&gt;&gt; Yes, I see how this relates to your &quot;put back the verb&quot; idea.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just my 2¢,<br>&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 03 Feb 2016, at 01:32, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt;&gt;&gt;&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt;&gt;&gt;&gt; guidelines that:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * describe when and where to use argument labels<br>&gt;&gt;&gt;&gt; * require labels in many of the cases people have asked for them<br>&gt;&gt;&gt;&gt; * are understandable by humans<br>&gt;&gt;&gt;&gt; * preserve important semantics communicated by existing APIs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here&#39;s what I&#39;m thinking<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;&gt;&gt;&gt; beginning in the base name and describing the primary semantics of<br>&gt;&gt;&gt;&gt; the call, it gets no argument label:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;&gt;&gt;&gt;   a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;&gt;&gt;&gt;                          // doesn&#39;t describe the semantics at all, <br>&gt;&gt;&gt;&gt;                          // thus we add a label for b.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;&gt;&gt;&gt;                            // but doesn&#39;t describe the primary <br>&gt;&gt;&gt;&gt;                            // semantics, which are to move in both<br>&gt;&gt;&gt;&gt;                            // x and y.  Thus, x gets a label.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;&gt;&gt;&gt;                            // the primary semantics, so u gets no<br>&gt;&gt;&gt;&gt;                            // label. b is an<br>&gt;&gt;&gt;&gt;                            // option that tunes the primary<br>&gt;&gt;&gt;&gt;                            // semantics<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [Note that this covers all the direct object cases and, I believe,<br>&gt;&gt;&gt;&gt; all the default argument cases too, so maybe that exception can be<br>&gt;&gt;&gt;&gt; dropped.  We still need the exceptions for full-width type<br>&gt;&gt;&gt;&gt; conversions and indistinguishable peers]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note: when there is a noun in the base name describing the role of the<br>&gt;&gt;&gt;&gt; first argument, we skip it in considering this criterion:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>&gt;&gt;&gt;&gt;                     // the semantics.  &quot;Observer&quot; is omitted in <br>&gt;&gt;&gt;&gt;                     // making this determination.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;&gt;&gt;&gt; clause doesn&#39;t rule out any important use-cases (see<br>&gt;&gt;&gt;&gt; https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;&gt;&gt;&gt; point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;&gt;&gt;&gt; universally-understood term.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;&gt;&gt;&gt; should go in the base name rather than in a label:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;&gt;&gt;    a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;&gt;&gt;&gt;    a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;&gt;&gt;&gt; ambiguous]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Words that describe attributes of an instance *to be created* should<br>&gt;&gt;&gt;&gt; go in argument labels, rather than the base name (for parity with<br>&gt;&gt;&gt;&gt; initializers):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;&gt;&gt;&gt;    trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;&gt;&gt;&gt; *identifier* of the subject in the base name, do not label it or<br>&gt;&gt;&gt;&gt; describe it in the base name.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    a.transitionToScene(.GreatHall)               // yes<br>&gt;&gt;&gt;&gt;    a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;&gt;&gt;&gt;    let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;&gt;&gt;&gt;    let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 4, 2016, at 10:58 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 4, 2016, at 12:23 AM, Radosław Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 04 Feb 2016, at 02:20, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Wed Feb 03 2016, Radosław Pietruszewski &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Overall, great guidelines (and +1 to the rules Erica wrote up), and<br>&gt;&gt;&gt;&gt; I’m +1 on conveying these nuances in the guidelines.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;&gt;&gt;&gt;&gt; should go in the base name rather than in a label:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;&gt;&gt;&gt;   a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;&gt;&gt;&gt;&gt;   a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;&gt;&gt;&gt;&gt; ambiguous]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Words that describe attributes of an instance *to be created* should<br>&gt;&gt;&gt;&gt;&gt; go in argument labels, rather than the base name (for parity with<br>&gt;&gt;&gt;&gt;&gt; initializers):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;&gt;&gt;&gt;&gt;   trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The rationale for doing this is stronger when we talk about automatic<br>&gt;&gt;&gt;&gt; translation of Objective-C APIs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For better or worse, it is a requirement that Cocoa as imported very<br>&gt;&gt;&gt; closely approximates full conformance to the guidelines we choose.  We<br>&gt;&gt;&gt; are shooting for consistency across APIs used in swift.<br>&gt;&gt; <br>&gt;&gt; Hmm. Understood, but sigh. Personally I think it’s a shame to constrain ourselves to (imho) inferior naming convention because it’s what existing ObjC APIs use. Definitely understandable, but considering this isn’t a _really_ super common pattern, I think it would be just fine to leave the translations in good-enough state (whatever the decision on SE-0005 is), and follow a new convention in new Swift APIs.<br>&gt; <br>&gt; Well, to give you an idea, we&#39;ve been going with the ground rule that the number of APIs that need to be fixed up with NS_SWIFT_NAME because they become actively worse needs to be &lt;1%.  I estimate that we can accept maybe 3% of APIs looking not-quite-right but no worse than before.<br>&gt; <br>&gt; If these fall into that 3%, it might be acceptable.<br>&gt; <br>&gt;&gt;&gt;&gt; But in APIs designed for Swift, I feel like this is wrong IMHO, because:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - “media type” is still a parameter, so it shouldn’t be in the base<br>&gt;&gt;&gt;&gt; name itself<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That doesn&#39;t seem obvious to me.  Whether that &quot;should&quot; be in the base<br>&gt;&gt;&gt; name depends on what guidelines we choose.  <br>&gt;&gt; <br>&gt;&gt; Of course. The way I think of it: the primary semantic is “find a track”, and media type is a criterion for search. I understand method families aren’t something you’re looking to optimize, but you can imagine that _if_ this was a family, it would still be “find a track”, just with different criteria.<br>&gt; <br>&gt; Yes, this makes a lot of sense to me.  Maybe we can distinguish the &quot;find&quot; cases from the &quot;get&quot; cases as you suggest below.<br>&gt; <br>&gt;&gt;&gt;&gt; - this breaks the symmetry with other methods due to the reason above<br>&gt;&gt;&gt;&gt; (like the “newTrack” you mentioned yourself) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, it would be more consistent if these two cases were the same.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - doesn’t play well with method families (searching for tracks is<br>&gt;&gt;&gt;&gt; searching for tracks. the criteria for search are just parameters).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t really believe that “method families” are something we want to<br>&gt;&gt;&gt; optimize for in Swift.  There are almost always alternatives that impose<br>&gt;&gt;&gt; lower cognitive overhead on users.<br>&gt;&gt; <br>&gt;&gt; Fair.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we do<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t see why it’s OK to do<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s just the consistency argument again, right?<br>&gt;&gt; <br>&gt;&gt; Yes.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Of course just “tracks” is confusing, and we agree on that, but I<br>&gt;&gt;&gt;&gt; would strongly recommend that for new APIs we don’t just name the<br>&gt;&gt;&gt;&gt; method with a word of an already-existing instance, rather, we start<br>&gt;&gt;&gt;&gt; it with a verb:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; a.findTracks(mediaType: “BetaMax”) // or “searchTracks”, or alternatively “tracksMatching&quot;<br>&gt;&gt;&gt;&gt; a.removeFirstTrackMatching(mediaType: “BetaMax”)   — ad 2<br>&gt;&gt;&gt;&gt; fac.newTrack(mediaType: “Wax Cylinder”)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Symmetric, predictable, follows the same convention, plays well with<br>&gt;&gt;&gt;&gt; method families (i.e. different search criterion than media type), and<br>&gt;&gt;&gt;&gt; no clarity problems.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately, this is the reality:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. The pattern of omitting prefix verbs like “get” and “find” is<br>&gt;&gt;&gt; something of a sacred cow; I think it would be very hard to sell to<br>&gt;&gt;&gt; certain important people.<br>&gt;&gt; <br>&gt;&gt; Hmm, I didn’t think of that. “get” is sort of understandable, I can see how in some languages you’d do “getFoo()”, whereas in Swift it would probably be a property “foo”. I don’t see a problem with “find”, though, as it really does help convey the intent.<br>&gt; <br>&gt; I&#39;m not sure I know how to make that case without getting into arguments about efficiency.  Some people have a *very* strong resistance to allowing naming guidelines to be dependent on efficiency.  Ideas?<br></p><p>Maybe something about the possibility of not finding anything is the way to distinguish these.<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. if we were to standardize on the opposite, we would need an<br>&gt;&gt;&gt; objective-C import strategy that would add these verbs automatically.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you can get a handle on solving #2, it *might* be worth me taking a<br>&gt;&gt;&gt; shot at solving #1. Otherwise, I&#39;m afraid this idea is dead in the<br>&gt;&gt;&gt; water.  Nothing that leaves glaring inconsistencies between imported<br>&gt;&gt;&gt; Cocoa and the API guidelines is going to be acceptable.<br>&gt;&gt; <br>&gt;&gt; Then perhaps let’s meet halfway:<br>&gt;&gt; <br>&gt;&gt;  a.tracksWith(mediaType: “BetaMax”)<br>&gt;&gt;  a.removeFirstTrackWith(mediaType: “BetaMax”)<br>&gt;&gt;  fac.newTrack(mediaType: “Wax Cyllinder”)<br>&gt;&gt; <br>&gt;&gt; (replace “with” with “matching” or “having” if you prefer)<br>&gt;&gt; <br>&gt;&gt; I don’t love it, but like it much more than “tracksHavingMediaType”:<br>&gt;&gt; <br>&gt;&gt; - still much more consistent about what goes into explicit parameters<br>&gt;&gt; - having a “with”/etc helps convey that parameters are the criteria for tracks returned<br>&gt; <br>&gt; I can&#39;t disagree.  At least one of us in the guidelines working group has a visceral negative reaction to ending a basename with &quot;With&quot;.  I&#39;ll have to ask whether that applies to every preposition or not.<br>&gt; <br>&gt;&gt; - doable as an automatic translation from ObjC<br>&gt; <br>&gt; Hmm, are you sure?  The problem may be identifying those places where &quot;with&quot; functions this way vs. as a vacuous separator. The latest best heuristic we&#39;ve got for doing that is to consider it a vacuous separator when there&#39;s a verb in the name, but that will fall down on removeFirstTrackWith...<br>&gt; It&#39;s all about finding an automated approximation to the actual guidelines that gives a fairly low error rate.<br>&gt; <br>&gt;&gt;&gt;&gt; Ad 2: I can see why you don’t like “removeFirstTrack”. It sounds like<br>&gt;&gt;&gt;&gt; removing _the_ first track, rather than the first track that matches<br>&gt;&gt;&gt;&gt; criteria in parameters list. Perhaps a word like “Matching” would work<br>&gt;&gt;&gt;&gt; well to fix this concern. (And sounds/conveys intention better than<br>&gt;&gt;&gt;&gt; “with” or “having” IMHO)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are contexts in which &quot;matching&quot; is more ambiguous than &quot;having&quot;,<br>&gt;&gt;&gt; e.g.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  x.trackMatchingMediaType(t) // track the matching media type?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  x.trackHavingMediaType(t)   // track is obviously a non-verb here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, I see how this relates to your &quot;put back the verb&quot; idea.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just my 2¢,<br>&gt;&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 03 Feb 2016, at 01:32, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt;&gt;&gt;&gt;&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt;&gt;&gt;&gt;&gt; guidelines that:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * describe when and where to use argument labels<br>&gt;&gt;&gt;&gt;&gt; * require labels in many of the cases people have asked for them<br>&gt;&gt;&gt;&gt;&gt; * are understandable by humans<br>&gt;&gt;&gt;&gt;&gt; * preserve important semantics communicated by existing APIs.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here&#39;s what I&#39;m thinking<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;&gt;&gt;&gt;&gt; beginning in the base name and describing the primary semantics of<br>&gt;&gt;&gt;&gt;&gt; the call, it gets no argument label:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;&gt;&gt;&gt;&gt;  a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;&gt;&gt;&gt;&gt;                         // doesn&#39;t describe the semantics at all, <br>&gt;&gt;&gt;&gt;&gt;                         // thus we add a label for b.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;&gt;&gt;&gt;&gt;                           // but doesn&#39;t describe the primary <br>&gt;&gt;&gt;&gt;&gt;                           // semantics, which are to move in both<br>&gt;&gt;&gt;&gt;&gt;                           // x and y.  Thus, x gets a label.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;&gt;&gt;&gt;&gt;                           // the primary semantics, so u gets no<br>&gt;&gt;&gt;&gt;&gt;                           // label. b is an<br>&gt;&gt;&gt;&gt;&gt;                           // option that tunes the primary<br>&gt;&gt;&gt;&gt;&gt;                           // semantics<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; [Note that this covers all the direct object cases and, I believe,<br>&gt;&gt;&gt;&gt;&gt; all the default argument cases too, so maybe that exception can be<br>&gt;&gt;&gt;&gt;&gt; dropped.  We still need the exceptions for full-width type<br>&gt;&gt;&gt;&gt;&gt; conversions and indistinguishable peers]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Note: when there is a noun in the base name describing the role of the<br>&gt;&gt;&gt;&gt;&gt; first argument, we skip it in considering this criterion:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>&gt;&gt;&gt;&gt;&gt;                    // the semantics.  &quot;Observer&quot; is omitted in <br>&gt;&gt;&gt;&gt;&gt;                    // making this determination.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;&gt;&gt;&gt;&gt; clause doesn&#39;t rule out any important use-cases (see<br>&gt;&gt;&gt;&gt;&gt; https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;&gt;&gt;&gt;&gt; point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;&gt;&gt;&gt;&gt; universally-understood term.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;&gt;&gt;&gt;&gt; should go in the base name rather than in a label:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;&gt;&gt;&gt;   a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;&gt;&gt;&gt;&gt;   a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;&gt;&gt;&gt;&gt; ambiguous]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Words that describe attributes of an instance *to be created* should<br>&gt;&gt;&gt;&gt;&gt; go in argument labels, rather than the base name (for parity with<br>&gt;&gt;&gt;&gt;&gt; initializers):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;&gt;&gt;&gt;&gt;   trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;&gt;&gt;&gt;&gt; *identifier* of the subject in the base name, do not label it or<br>&gt;&gt;&gt;&gt;&gt; describe it in the base name.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   a.transitionToScene(.GreatHall)               // yes<br>&gt;&gt;&gt;&gt;&gt;   a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;&gt;&gt;&gt;&gt;   let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;&gt;&gt;&gt;&gt;   let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
