<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ca58147038d0210e502aa8dd9e2bc5ce?s=50"></div><header><strong>Question about heterogeneous collections</strong> from <string>Jason Sadler</string> &lt;jason.sadler at gmail.com&gt;<p>March 30, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi folks,<br></p><p>I have an issue with using a heterogeneous array of objects conforming to a<br>protocol - I want to write an extension on Array (or CollectionType) that<br>applies only when Element : MyProtocol, but I can’t call methods in that<br>extension from an instance of [MyProtocol] because &quot;Using ‘MyProtocol&#39; as a<br>concrete type conforming to protocol ‘MyProtocol&#39; is not supported”<br></p><p>(For more background, my full use case can be seen in this gist:<br>https://gist.github.com/sadlerjw/2cc16b4375b02fe7f400)<br></p><p>I’ve asked about this on swift-users (<br>https://lists.swift.org/pipermail/swift-users/Week-of-Mon-20160321/001560.html)<br>and got some good workarounds but no one was able to provide me with<br>information on any future plans in swift to address this issue - whether<br>that’s making protocols conform to themselves, or some other improved<br>approach to heterogeneous collections. I wonder if anyone here can shed<br>some light on this? (I’m new to the mailing lists, sorry!)<br></p><p>Thanks<br>Jason<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/28755a72/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Question about heterogeneous collections</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 31, 2016 at 11:00:00am</p></header><div class="content"><p>Protocols aren’t like parent-classes, they can’t be used interchangeably as different struct implementations of MyProtocol may have radically different memory footprints. I think you can define a protocol for classes only which may allow you to use MyProtocol as a concrete type, but personally I don’t like the idea of limiting a protocol in that way; the correct way to store elements of MyProtocol is to define a type-erased wrapper AnyMyType that takes any instance of MyProtocol and hides it.<br></p><p>Type-erased wrappers are bit of a pain in the ass to define; in fact, in the discussion you linked someone recommended a method using closures to do it, but while this is a neat way to do it, it’s very inefficient in terms of memory (if you have four or five methods in your protocol then suddenly the wrapper will be adding hundreds of bytes of overhead). The correct way to implement these is outlined in the following guide:<br></p><p>https://realm.io/news/type-erased-wrappers-in-swift/ &lt;https://realm.io/news/type-erased-wrappers-in-swift/&gt;<br></p><p>This is a horrible process with a ton of boiler-plate though, so there’s certainly an argument to be made for features that can reduce or eliminate the need for this. In fact, it’d be great if protocols had type-erased wrappers generated automatically, as this could avoid the somewhat unintuitive cases like the one you’ve run into, but then it would end up hiding the complexity of what’s actually happening.<br></p><p>For example, if you want to save a bunch of different MyProtocol variations in a collection, then you might consider declaring them as classes with a common ancestor instead, then use that ancestor as your array type, as this is one of the advantage of classes over structs (even though I generally prefer the latter in most cases). Type-erased wrappers also add overhead that you should be aware of, but typically a lot less (if you use the boxing method, the closure method adds tons of overhead despite appearing much simpler).<br></p><p>&gt; On 30 Mar 2016, at 18:11, Jason Sadler via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi folks,<br>&gt; <br>&gt; I have an issue with using a heterogeneous array of objects conforming to a protocol - I want to write an extension on Array (or CollectionType) that applies only when Element : MyProtocol, but I can’t call methods in that extension from an instance of [MyProtocol] because &quot;Using ‘MyProtocol&#39; as a concrete type conforming to protocol ‘MyProtocol&#39; is not supported”<br>&gt; <br>&gt; (For more background, my full use case can be seen in this gist: https://gist.github.com/sadlerjw/2cc16b4375b02fe7f400 &lt;https://gist.github.com/sadlerjw/2cc16b4375b02fe7f400&gt;)<br>&gt; <br>&gt; I’ve asked about this on swift-users (https://lists.swift.org/pipermail/swift-users/Week-of-Mon-20160321/001560.html &lt;https://lists.swift.org/pipermail/swift-users/Week-of-Mon-20160321/001560.html&gt;) and got some good workarounds but no one was able to provide me with information on any future plans in swift to address this issue - whether that’s making protocols conform to themselves, or some other improved approach to heterogeneous collections. I wonder if anyone here can shed some light on this? (I’m new to the mailing lists, sorry!)<br>&gt; <br>&gt; Thanks<br>&gt; Jason<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/82931eea/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
