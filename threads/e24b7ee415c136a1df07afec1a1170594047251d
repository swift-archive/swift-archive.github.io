<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>access control</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 25, 2016 at 03:00:00pm</p></header><div class="content"><p>on Mon Jan 25 2016, Ilya Belenkiy &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; Why should the compiler enforce this? That’s my design decision.<br>&gt;<br>&gt; It would enforce whatever design decision you make.<br>&gt;<br>&gt;&gt; For the same reason the compiler does not enforce where I have to<br>&gt;&gt; put „private“ (it can make suggestions like many IDEs do and offer<br>&gt;&gt; fix-its, like „this method can be made private as it is not used<br>&gt;&gt; outside the class“ or „this class can be put into its own file as<br>&gt;&gt; its private methods are not used by other components in this file“.<br>&gt;<br>&gt; But once you do put it, it enforces it, and that’s the whole point of having access control.<br>&gt;<br>&gt;&gt; No, there is a clear difference: making the type name part of the<br>&gt;&gt; variable name enforces no compiler checks whereas putting something<br>&gt;&gt; into different files does.<br>&gt;<br>&gt; Similarly, putting all of the source code in the same file is<br>&gt; equivalent to no checks.<br></p><p>The place where I&#39;m most concerned about this is in playgrounds.  If<br>we&#39;re going to use them to teach programming, it should be possible to<br>demonstrate encapsulation there.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 25, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 25, 2016, at 5:47 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Jan 25 2016, Ilya Belenkiy &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Why should the compiler enforce this? That’s my design decision.<br>&gt;&gt; <br>&gt;&gt; It would enforce whatever design decision you make.<br>&gt;&gt; <br>&gt;&gt;&gt; For the same reason the compiler does not enforce where I have to<br>&gt;&gt;&gt; put „private“ (it can make suggestions like many IDEs do and offer<br>&gt;&gt;&gt; fix-its, like „this method can be made private as it is not used<br>&gt;&gt;&gt; outside the class“ or „this class can be put into its own file as<br>&gt;&gt;&gt; its private methods are not used by other components in this file“.<br>&gt;&gt; <br>&gt;&gt; But once you do put it, it enforces it, and that’s the whole point of having access control.<br>&gt;&gt; <br>&gt;&gt;&gt; No, there is a clear difference: making the type name part of the<br>&gt;&gt;&gt; variable name enforces no compiler checks whereas putting something<br>&gt;&gt;&gt; into different files does.<br>&gt;&gt; <br>&gt;&gt; Similarly, putting all of the source code in the same file is<br>&gt;&gt; equivalent to no checks.<br>&gt; <br>&gt; The place where I&#39;m most concerned about this is in playgrounds.  If<br>&gt; we&#39;re going to use them to teach programming, it should be possible to<br>&gt; demonstrate encapsulation there.<br>&gt; <br></p><p>Using playgrounds for teaching is a great example of a use case for this.  Thanks for mentioning it!<br></p><p>I also think the fact that “surrounding scope” is actually the most frequent use of `private` members (in code I have surveyed) indicates that it is a very reasonable feature request.  Allowing us to declare the actual intent aids readability and clarity.<br></p><p>-Matthew<br></p><p>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>access control</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 26, 2016 at 01:00:00pm</p></header><div class="content"><p>I like file scoped private, it&#39;s way better than C++&#39;s `friend`. I also<br>often feel that it&#39;s unsafe when I&#39;ve mentally scoped implementation<br>details to a class or extension, but the implementations are in the same<br>file.<br></p><p>I would support something like this:<br>    * `private(module)` alternatively `internal`, the default.<br>    * `private` alternatively `private(file)`<br>    * `private(class)`<br>    * `private(extension)`<br>    * `public`<br></p><p>Perhaps this could let us deprecate/remove the keyword `internal`, I&#39;m not<br>sure of many circumstances when you&#39;d actually need to write it.<br></p><p>I also think that `private(module)` is also more intuitively understood<br>than `internal`.<br></p><p>*My reasoning:*<br></p><p>This seems to come down to:<br></p><p>   - It lowers the cognitive load if you can put related concepts in the<br>   same file.<br>   - It lowers the cognitive load if you can reduce the number of things a<br>   class needs to understand.<br>   - People like the current system, its simple and it works for them.<br></p><p>&quot;Everyone knows that debugging is twice as hard as writing a program in the<br>first place. So if you&#39;re as clever as you can be when you write it, how<br>will you ever debug it?&quot; - The Elements of Programming Style<br></p><p>On Tue, Jan 26, 2016 at 12:46 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 25, 2016, at 5:47 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; on Mon Jan 25 2016, Ilya Belenkiy &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; Why should the compiler enforce this? That’s my design decision.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; It would enforce whatever design decision you make.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; For the same reason the compiler does not enforce where I have to<br>&gt; &gt;&gt;&gt; put „private“ (it can make suggestions like many IDEs do and offer<br>&gt; &gt;&gt;&gt; fix-its, like „this method can be made private as it is not used<br>&gt; &gt;&gt;&gt; outside the class“ or „this class can be put into its own file as<br>&gt; &gt;&gt;&gt; its private methods are not used by other components in this file“.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; But once you do put it, it enforces it, and that’s the whole point of<br>&gt; having access control.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; No, there is a clear difference: making the type name part of the<br>&gt; &gt;&gt;&gt; variable name enforces no compiler checks whereas putting something<br>&gt; &gt;&gt;&gt; into different files does.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Similarly, putting all of the source code in the same file is<br>&gt; &gt;&gt; equivalent to no checks.<br>&gt; &gt;<br>&gt; &gt; The place where I&#39;m most concerned about this is in playgrounds.  If<br>&gt; &gt; we&#39;re going to use them to teach programming, it should be possible to<br>&gt; &gt; demonstrate encapsulation there.<br>&gt; &gt;<br>&gt;<br>&gt; Using playgrounds for teaching is a great example of a use case for this.<br>&gt; Thanks for mentioning it!<br>&gt;<br>&gt; I also think the fact that “surrounding scope” is actually the most<br>&gt; frequent use of `private` members (in code I have surveyed) indicates that<br>&gt; it is a very reasonable feature request.  Allowing us to declare the actual<br>&gt; intent aids readability and clarity.<br>&gt;<br>&gt; -Matthew<br>&gt;<br>&gt; &gt; --<br>&gt; &gt; -Dave<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/0fd19bf3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 25, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 25, 2016, at 8:37 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; I like file scoped private, it&#39;s way better than C++&#39;s `friend`. I also often feel that it&#39;s unsafe when I&#39;ve mentally scoped implementation details to a class or extension, but the implementations are in the same file.<br>&gt; <br>&gt; I would support something like this:<br>&gt;     * `private(module)` alternatively `internal`, the default.<br>&gt;     * `private` alternatively `private(file)`<br>&gt;     * `private(class)`<br>&gt;     * `private(extension)`<br>&gt;     * `public`<br></p><p>I like the basic breakdown of functionality here, but why overload private with so many variations?  This is more verbose than necessary.  I think we can get away with being more clear and concise (access modifiers are decl modifiers, not keywords so they don’t steal identifiers, IIUC).<br></p><p>Why not this:<br></p><p>    * `public`<br>    * `module`, the default (currently `internal`).<br>    * `file` (currently `private`)<br>    * `private` (no current equivalent: containing scope whether class, struct, enum, extension, etc)<br></p><p>&gt; <br>&gt; Perhaps this could let us deprecate/remove the keyword `internal`, I&#39;m not sure of many circumstances when you&#39;d actually need to write it.<br>&gt; <br>&gt; I also think that `private(module)` is also more intuitively understood than `internal`.<br>&gt; <br>&gt; My reasoning:<br>&gt; <br>&gt; This seems to come down to:<br>&gt; It lowers the cognitive load if you can put related concepts in the same file.<br>&gt; It lowers the cognitive load if you can reduce the number of things a class needs to understand.<br>&gt; People like the current system, its simple and it works for them.<br>&gt; &quot;Everyone knows that debugging is twice as hard as writing a program in the first place. So if you&#39;re as clever as you can be when you write it, how will you ever debug it?&quot; - The Elements of Programming Style<br>&gt; <br>&gt; On Tue, Jan 26, 2016 at 12:46 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Jan 25, 2016, at 5:47 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; on Mon Jan 25 2016, Ilya Belenkiy &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; Why should the compiler enforce this? That’s my design decision.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; It would enforce whatever design decision you make.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; For the same reason the compiler does not enforce where I have to<br>&gt; &gt;&gt;&gt; put „private“ (it can make suggestions like many IDEs do and offer<br>&gt; &gt;&gt;&gt; fix-its, like „this method can be made private as it is not used<br>&gt; &gt;&gt;&gt; outside the class“ or „this class can be put into its own file as<br>&gt; &gt;&gt;&gt; its private methods are not used by other components in this file“.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; But once you do put it, it enforces it, and that’s the whole point of having access control.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; No, there is a clear difference: making the type name part of the<br>&gt; &gt;&gt;&gt; variable name enforces no compiler checks whereas putting something<br>&gt; &gt;&gt;&gt; into different files does.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Similarly, putting all of the source code in the same file is<br>&gt; &gt;&gt; equivalent to no checks.<br>&gt; &gt;<br>&gt; &gt; The place where I&#39;m most concerned about this is in playgrounds.  If<br>&gt; &gt; we&#39;re going to use them to teach programming, it should be possible to<br>&gt; &gt; demonstrate encapsulation there.<br>&gt; &gt;<br>&gt; <br>&gt; Using playgrounds for teaching is a great example of a use case for this.  Thanks for mentioning it!<br>&gt; <br>&gt; I also think the fact that “surrounding scope” is actually the most frequent use of `private` members (in code I have surveyed) indicates that it is a very reasonable feature request.  Allowing us to declare the actual intent aids readability and clarity.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt; &gt; --<br>&gt; &gt; -Dave<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/1d202042/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>access control</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 26, 2016 at 02:00:00pm</p></header><div class="content"><p>It seems to be the opposite, these example work in a playground:<br></p><p>let public: Int = 123<br></p><p>error: keyword &#39;public&#39; cannot be used as an identifier<br></p><p><br>However:<br></p><p>struct Test {<br></p><p>    private(set) var set: Int<br></p><p>}<br></p><p><br>no errors<br></p><p>I think that `module` and `file` without further context may be confusing.<br>I also think that `class` that I had is probably confusing.<br></p><p>I don&#39;t see the additional verbosity as a problem, I think the more<br>frequently used ones are probably fine.<br></p><p>I&#39;m happy for them all to be keywords, the original proposal had some good<br>suggestions there, I just think what I&#39;ve suggested is a bit nicer.<br></p><p>I think that what I&#39;m suggesting would increase safety and granularity,<br>with only one new case you didn&#39;t have, and it would actually reduce the<br>number of keywords.<br></p><p><br>On Tue, Jan 26, 2016 at 1:51 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jan 25, 2016, at 8:37 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;<br>&gt; I like file scoped private, it&#39;s way better than C++&#39;s `friend`. I also<br>&gt; often feel that it&#39;s unsafe when I&#39;ve mentally scoped implementation<br>&gt; details to a class or extension, but the implementations are in the same<br>&gt; file.<br>&gt;<br>&gt; I would support something like this:<br>&gt;     * `private(module)` alternatively `internal`, the default.<br>&gt;     * `private` alternatively `private(file)`<br>&gt;     * `private(class)`<br>&gt;     * `private(extension)`<br>&gt;     * `public`<br>&gt;<br>&gt;<br>&gt; I like the basic breakdown of functionality here, but why overload private<br>&gt; with so many variations?  This is more verbose than necessary.  I think we<br>&gt; can get away with being more clear and concise (access modifiers are decl<br>&gt; modifiers, not keywords so they don’t steal identifiers, IIUC).<br>&gt;<br>&gt; Why not this:<br>&gt;<br>&gt;     * `public`<br>&gt;     * `module`, the default (currently `internal`).<br>&gt;     * `file` (currently `private`)<br>&gt;     * `private` (no current equivalent: containing scope whether class,<br>&gt; struct, enum, extension, etc)<br>&gt;<br>&gt;<br>&gt; Perhaps this could let us deprecate/remove the keyword `internal`, I&#39;m<br>&gt; not sure of many circumstances when you&#39;d actually need to write it.<br>&gt;<br>&gt; I also think that `private(module)` is also more intuitively understood<br>&gt; than `internal`.<br>&gt;<br>&gt; *My reasoning:*<br>&gt;<br>&gt; This seems to come down to:<br>&gt;<br>&gt;    - It lowers the cognitive load if you can put related concepts in the<br>&gt;    same file.<br>&gt;    - It lowers the cognitive load if you can reduce the number of things<br>&gt;    a class needs to understand.<br>&gt;    - People like the current system, its simple and it works for them.<br>&gt;<br>&gt; &quot;Everyone knows that debugging is twice as hard as writing a program in<br>&gt; the first place. So if you&#39;re as clever as you can be when you write it,<br>&gt; how will you ever debug it?&quot; - The Elements of Programming Style<br>&gt;<br>&gt; On Tue, Jan 26, 2016 at 12:46 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Jan 25, 2016, at 5:47 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; on Mon Jan 25 2016, Ilya Belenkiy &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; Why should the compiler enforce this? That’s my design decision.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; It would enforce whatever design decision you make.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; For the same reason the compiler does not enforce where I have to<br>&gt;&gt; &gt;&gt;&gt; put „private“ (it can make suggestions like many IDEs do and offer<br>&gt;&gt; &gt;&gt;&gt; fix-its, like „this method can be made private as it is not used<br>&gt;&gt; &gt;&gt;&gt; outside the class“ or „this class can be put into its own file as<br>&gt;&gt; &gt;&gt;&gt; its private methods are not used by other components in this file“.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; But once you do put it, it enforces it, and that’s the whole point of<br>&gt;&gt; having access control.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; No, there is a clear difference: making the type name part of the<br>&gt;&gt; &gt;&gt;&gt; variable name enforces no compiler checks whereas putting something<br>&gt;&gt; &gt;&gt;&gt; into different files does.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Similarly, putting all of the source code in the same file is<br>&gt;&gt; &gt;&gt; equivalent to no checks.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The place where I&#39;m most concerned about this is in playgrounds.  If<br>&gt;&gt; &gt; we&#39;re going to use them to teach programming, it should be possible to<br>&gt;&gt; &gt; demonstrate encapsulation there.<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;&gt; Using playgrounds for teaching is a great example of a use case for<br>&gt;&gt; this.  Thanks for mentioning it!<br>&gt;&gt;<br>&gt;&gt; I also think the fact that “surrounding scope” is actually the most<br>&gt;&gt; frequent use of `private` members (in code I have surveyed) indicates that<br>&gt;&gt; it is a very reasonable feature request.  Allowing us to declare the actual<br>&gt;&gt; intent aids readability and clarity.<br>&gt;&gt;<br>&gt;&gt; -Matthew<br>&gt;&gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; -Dave<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/6494ecf5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 26, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jan 25, 2016, at 9:22 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; It seems to be the opposite, these example work in a playground:<br>&gt; <br>&gt; let public: Int = 123<br>&gt; <br>&gt; error: keyword &#39;public&#39; cannot be used as an identifier<br>&gt; <br>&gt; However:<br>&gt; <br>&gt; struct Test {<br>&gt;     private(set) var set: Int<br>&gt; }<br>&gt; <br>&gt; no errors<br></p><p>You are right.  The access modifiers are not available as identifiers while most other decl modifiers are allowed: https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/doc/uid/TP40014097-CH30-ID410 &lt;https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/doc/uid/TP40014097-CH30-ID410&gt;.  I should have checked before mentioning what I did about decl modifiers.<br></p><p>&gt; <br>&gt; I think that `module` and `file` without further context may be confusing. I also think that `class` that I had is probably confusing.<br></p><p>You’re probably right about `module` and `file` having potential for confusion without context.  With that in mind, `internal` is probably better than `module` and is what we already have..<br></p><p>&gt; <br>&gt; I don&#39;t see the additional verbosity as a problem, I think the more frequently used ones are probably fine.<br>&gt; <br>&gt; I&#39;m happy for them all to be keywords, the original proposal had some good suggestions there, I just think what I&#39;ve suggested is a bit nicer.<br>&gt; <br>&gt; I think that what I&#39;m suggesting would increase safety and granularity, with only one new case you didn&#39;t have, and it would actually reduce the number of keywords.<br></p><p>I did cover all of your cases.  Making a distinction based on the type of scope (class vs extension) doesn’t seem to be worthwhile.  If you really wanted to stick with the private syntax `private(scope)` would make the most sense and would work for any kind of scope.<br></p><p>However I think that is verbose.  I think we have a couple of reasonable options.<br></p><p>Ilya’s proposal and closest to current state:<br>* public, internal, private, local (or scoped)<br></p><p>Change `private` to be scope-based and come up with something new for file-level visibility:<br>* public, internal, ??? file level, private<br></p><p>My preference depends on what we could come up with for file-level visibility.  If it’s better than `local` or `scoped` I would prefer that.  If not, I would prefer Ilya’s proposal.  In other words, we should choose the option with the best overall clarity.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; <br>&gt; On Tue, Jan 26, 2016 at 1:51 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 25, 2016, at 8:37 PM, Andrew Bennett &lt;cacoyi at gmail.com &lt;mailto:cacoyi at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like file scoped private, it&#39;s way better than C++&#39;s `friend`. I also often feel that it&#39;s unsafe when I&#39;ve mentally scoped implementation details to a class or extension, but the implementations are in the same file.<br>&gt;&gt; <br>&gt;&gt; I would support something like this:<br>&gt;&gt;     * `private(module)` alternatively `internal`, the default.<br>&gt;&gt;     * `private` alternatively `private(file)`<br>&gt;&gt;     * `private(class)`<br>&gt;&gt;     * `private(extension)`<br>&gt;&gt;     * `public`<br>&gt; <br>&gt; I like the basic breakdown of functionality here, but why overload private with so many variations?  This is more verbose than necessary.  I think we can get away with being more clear and concise (access modifiers are decl modifiers, not keywords so they don’t steal identifiers, IIUC).<br>&gt; <br>&gt; Why not this:<br>&gt; <br>&gt;     * `public`<br>&gt;     * `module`, the default (currently `internal`).<br>&gt;     * `file` (currently `private`)<br>&gt;     * `private` (no current equivalent: containing scope whether class, struct, enum, extension, etc)<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Perhaps this could let us deprecate/remove the keyword `internal`, I&#39;m not sure of many circumstances when you&#39;d actually need to write it.<br>&gt;&gt; <br>&gt;&gt; I also think that `private(module)` is also more intuitively understood than `internal`.<br>&gt;&gt; <br>&gt;&gt; My reasoning:<br>&gt;&gt; <br>&gt;&gt; This seems to come down to:<br>&gt;&gt; It lowers the cognitive load if you can put related concepts in the same file.<br>&gt;&gt; It lowers the cognitive load if you can reduce the number of things a class needs to understand.<br>&gt;&gt; People like the current system, its simple and it works for them.<br>&gt;&gt; &quot;Everyone knows that debugging is twice as hard as writing a program in the first place. So if you&#39;re as clever as you can be when you write it, how will you ever debug it?&quot; - The Elements of Programming Style<br>&gt;&gt; <br>&gt;&gt; On Tue, Jan 26, 2016 at 12:46 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On Jan 25, 2016, at 5:47 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; on Mon Jan 25 2016, Ilya Belenkiy &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; Why should the compiler enforce this? That’s my design decision.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; It would enforce whatever design decision you make.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; For the same reason the compiler does not enforce where I have to<br>&gt;&gt; &gt;&gt;&gt; put „private“ (it can make suggestions like many IDEs do and offer<br>&gt;&gt; &gt;&gt;&gt; fix-its, like „this method can be made private as it is not used<br>&gt;&gt; &gt;&gt;&gt; outside the class“ or „this class can be put into its own file as<br>&gt;&gt; &gt;&gt;&gt; its private methods are not used by other components in this file“.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; But once you do put it, it enforces it, and that’s the whole point of having access control.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; No, there is a clear difference: making the type name part of the<br>&gt;&gt; &gt;&gt;&gt; variable name enforces no compiler checks whereas putting something<br>&gt;&gt; &gt;&gt;&gt; into different files does.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Similarly, putting all of the source code in the same file is<br>&gt;&gt; &gt;&gt; equivalent to no checks.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The place where I&#39;m most concerned about this is in playgrounds.  If<br>&gt;&gt; &gt; we&#39;re going to use them to teach programming, it should be possible to<br>&gt;&gt; &gt; demonstrate encapsulation there.<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; Using playgrounds for teaching is a great example of a use case for this.  Thanks for mentioning it!<br>&gt;&gt; <br>&gt;&gt; I also think the fact that “surrounding scope” is actually the most frequent use of `private` members (in code I have surveyed) indicates that it is a very reasonable feature request.  Allowing us to declare the actual intent aids readability and clarity.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; -Dave<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/d9457207/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 26, 2016 at 07:00:00am</p></header><div class="content"><p>&gt;&gt;   If we&#39;re going to use them to teach programming, it should be possible to<br>&gt;&gt; demonstrate encapsulation there.<br></p><p>A very important use case. In addition, it would be especially sad if there was a workaround for this particular case, and students learned the concept but could not apply it in real Swift code.<br></p><p>&gt; On Jan 25, 2016, at 8:46 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 25, 2016, at 5:47 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon Jan 25 2016, Ilya Belenkiy &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Why should the compiler enforce this? That’s my design decision.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would enforce whatever design decision you make.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For the same reason the compiler does not enforce where I have to<br>&gt;&gt;&gt;&gt; put „private“ (it can make suggestions like many IDEs do and offer<br>&gt;&gt;&gt;&gt; fix-its, like „this method can be made private as it is not used<br>&gt;&gt;&gt;&gt; outside the class“ or „this class can be put into its own file as<br>&gt;&gt;&gt;&gt; its private methods are not used by other components in this file“.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But once you do put it, it enforces it, and that’s the whole point of having access control.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, there is a clear difference: making the type name part of the<br>&gt;&gt;&gt;&gt; variable name enforces no compiler checks whereas putting something<br>&gt;&gt;&gt;&gt; into different files does.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Similarly, putting all of the source code in the same file is<br>&gt;&gt;&gt; equivalent to no checks.<br>&gt;&gt; <br>&gt;&gt; The place where I&#39;m most concerned about this is in playgrounds.  If<br>&gt;&gt; we&#39;re going to use them to teach programming, it should be possible to<br>&gt;&gt; demonstrate encapsulation there.<br>&gt;&gt; <br>&gt; <br>&gt; Using playgrounds for teaching is a great example of a use case for this.  Thanks for mentioning it!<br>&gt; <br>&gt; I also think the fact that “surrounding scope” is actually the most frequent use of `private` members (in code I have surveyed) indicates that it is a very reasonable feature request.  Allowing us to declare the actual intent aids readability and clarity.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/58a11bd6/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>access control</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 27, 2016 at 08:00:00am</p></header><div class="content"><p>Sorry if I&#39;ve missed it, but I didn&#39;t see these comments addressed in a way that I thought was sufficient.<br></p><p>&gt; On Jan 25, 2016, at 3:47 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The place where I&#39;m most concerned about this is in playgrounds.  If<br>&gt; we&#39;re going to use them to teach programming, it should be possible to<br>&gt; demonstrate encapsulation there.<br></p><p>Playgrounds support multiple files. Doesn&#39;t this alleviate this problem? Of course you can&#39;t model Swift&#39;s model in a single-file, but that&#39;s by-design. <br></p><p><br>&gt; On Jan 27, 2016, at 7:44 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Aside from that, as has been noted several times, the most common need is “current scope only”.  It would be nice if that could actually be expressed in the language.  There are often valid reasons to organize code such that more than one scope exists in the same file without a desire to share implementation details between the scopes.  Right now there is a tension between code layout and the visibility semantics we actually desire and intend.<br></p><p>I disagree. You can pattern your code so that this appears to be the &quot;most common need&quot;, but you can also pattern identical functioning code so that this feature doesn&#39;t even work.<br></p><p>For instance, I know in my code, this really isn&#39;t the &quot;most common need&quot;. In fact, in nearly all of my code, local would be completely useless because I put the majority of my APIs in extensions. I like to model the data on the type definition and the APIs in extensions.<br></p><p>This proposal would make using extensions as a means of grouping functionality impossible:<br></p><p>struct Foo {<br>    local count: Int = 0<br>}<br></p><p>extension Foo {<br>    func hidden() { count += 1 }  // error: count is not visible<br>}<br></p><p>So now we have to arbitrarily make `count` private, move `hidden()` into the `Foo` definition, or make `local` a whole lot more complicated.<br></p><p>If you design and write your code like you do in other languages, then ok, I can see a margin of usefulness from `local`. <br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/9a13e524/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 10:35 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry if I&#39;ve missed it, but I didn&#39;t see these comments addressed in a way that I thought was sufficient.<br>&gt; <br>&gt;&gt; On Jan 25, 2016, at 3:47 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The place where I&#39;m most concerned about this is in playgrounds.  If<br>&gt;&gt; we&#39;re going to use them to teach programming, it should be possible to<br>&gt;&gt; demonstrate encapsulation there.<br>&gt; <br>&gt; Playgrounds support multiple files. Doesn&#39;t this alleviate this problem? Of course you can&#39;t model Swift&#39;s model in a single-file, but that&#39;s by-design. <br>&gt; <br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 7:44 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Aside from that, as has been noted several times, the most common need is “current scope only”.  It would be nice if that could actually be expressed in the language.  There are often valid reasons to organize code such that more than one scope exists in the same file without a desire to share implementation details between the scopes.  Right now there is a tension between code layout and the visibility semantics we actually desire and intend.<br>&gt; <br>&gt; I disagree. You can pattern your code so that this appears to be the &quot;most common need&quot;, but you can also pattern identical functioning code so that this feature doesn&#39;t even work.<br>&gt; <br>&gt; For instance, I know in my code, this really isn&#39;t the &quot;most common need&quot;. In fact, in nearly all of my code, local would be completely useless because I put the majority of my APIs in extensions. I like to model the data on the type definition and the APIs in extensions.<br>&gt; <br>&gt; This proposal would make using extensions as a means of grouping functionality impossible:<br>&gt; <br>&gt; struct Foo {<br>&gt;     local count: Int = 0<br>&gt; }<br>&gt; <br>&gt; extension Foo {<br>&gt;     func hidden() { count += 1 }  // error: count is not visible<br>&gt; }<br>&gt; <br>&gt; So now we have to arbitrarily make `count` private, move `hidden()` into the `Foo` definition, or make `local` a whole lot more complicated.<br>&gt; <br>&gt; If you design and write your code like you do in other languages, then ok, I can see a margin of usefulness from `local`. <br></p><p>Sure, if you use this method of organizing code `local` would be less useful and the need for file-level access would be much more common.  I can see the benefits of organizing code this way; it is how code is organized in functional languages.  When you follow this approach `local` would still be useful if you have helpers inside an extension.  But you are right, it would not be the most common need.<br></p><p>I haven’t seen much Swift code actually organized this way in the wild.  Maybe that will change, maybe not.  But I stand by the assertion that they way most people are writing Swift today leads to “current scope only” is the most common need in practice.<br></p><p>Both `local` and `private` are useful.  I would like to see both of them in the language.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/f773c17b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
