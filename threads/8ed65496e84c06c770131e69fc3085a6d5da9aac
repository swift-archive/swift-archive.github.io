<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add replace(_:with:) function to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 13, 2015 at 02:00:00pm</p></header><div class="content"><p>A function I find myself defining in a lot of my projects looks like the following:<br></p><p>/// Replace the value of `a` with `b` and return the old value. public<br>func replace&lt;T&gt;(inout a: T, with b: T) -&gt; T {    var value = b<br>swap(&amp;a, &amp;value)    return value }<br></p><p>This is a pretty simple function, and useful in a wide variety of<br>circumstances, so I&#39;d love to get it into the standard library. It<br>doesn&#39;t actually enable any behavior that wasn&#39;t previously possible,<br>but it does shrink some common code patterns, and I find the shorter<br>code easier to read.<br></p><p>An example of a place where I use it often is in replacing an optional<br>property with a new value (or with nil) and cleaning up the previous<br>value. Assuming a property like<br></p><p>var task: NSURLSessionTask?<br></p><p>This replaces<br></p><p>if let task = self.task {    task.cancel() } task = nil<br></p><p>with<br></p><p>replace(&amp;task, with: nil)?.cancel()<br></p><p>Or sometimes I use it like<br></p><p>if let value = replace(&amp;prop, with: newValue) {    // multi-line cleanup<br>}<br></p><p>This is particularly nice if it&#39;s a COW value that I want to mutate, as<br>it means I don&#39;t have to worry about getting unwanted copies due to the<br>property still holding the old value while I muck with it.<br></p><p>Question: For trivial backwards-compatible API changes like this, does a<br>proposal PR need to be submitted to the swift-evolution repo, or is<br>discussion on this ML sufficient before submitting a patch?<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/8ed69aac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: Add replace(_:with:) function to the stdlib</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 13, 2015 at 10:00:00pm</p></header><div class="content"><p>Nice idiom! Even if it doesn’t make it into stdlib, I might have to use that in some project-local utilities. Quite slick.<br></p><p>Is there a way to make it read more grammatically?<br></p><p>    replace(&amp;task, with: nil).andWithPreviousValue?.cancel()<br></p><p>Yuck. I don’t see a way that works well … but you see what I’m getting at.<br></p><p>P<br></p><p>&gt; On Dec 13, 2015, at 4:21 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A function I find myself defining in a lot of my projects looks like the following:<br>&gt;  <br>&gt; /// Replace the value of `a` with `b` and return the old value.<br>&gt; public func replace&lt;T&gt;(inout a: T, with b: T) -&gt; T {<br>&gt;     var value = b<br>&gt;     swap(&amp;a, &amp;value)<br>&gt;     return value<br>&gt; }<br>&gt;  <br>&gt; This is a pretty simple function, and useful in a wide variety of circumstances, so I&#39;d love to get it into the standard library. It doesn&#39;t actually enable any behavior that wasn&#39;t previously possible, but it does shrink some common code patterns, and I find the shorter code easier to read.<br>&gt;  <br>&gt; An example of a place where I use it often is in replacing an optional property with a new value (or with nil) and cleaning up the previous value. Assuming a property like<br>&gt;  <br>&gt; var task: NSURLSessionTask?<br>&gt;  <br>&gt; This replaces<br>&gt;  <br>&gt; if let task = self.task {<br>&gt;     task.cancel()<br>&gt; }<br>&gt; task = nil<br>&gt;  <br>&gt; with<br>&gt;  <br>&gt; replace(&amp;task, with: nil)?.cancel()<br>&gt;  <br>&gt; Or sometimes I use it like<br>&gt;  <br>&gt; if let value = replace(&amp;prop, with: newValue) {<br>&gt;     // multi-line cleanup<br>&gt; }<br>&gt;  <br>&gt; This is particularly nice if it&#39;s a COW value that I want to mutate, as it means I don&#39;t have to worry about getting unwanted copies due to the property still holding the old value while I muck with it.<br>&gt;  <br>&gt; Question: For trivial backwards-compatible API changes like this, does a proposal PR need to be submitted to the swift-evolution repo, or is discussion on this ML sufficient before submitting a patch?<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/4f8081f8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Add replace(_:with:) function to the stdlib</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 13, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 2:21 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A function I find myself defining in a lot of my projects looks like the following:<br>&gt;  <br>&gt; /// Replace the value of `a` with `b` and return the old value.<br>&gt; public func replace&lt;T&gt;(inout a: T, with b: T) -&gt; T {<br>&gt;     var value = b<br>&gt;     swap(&amp;a, &amp;value)<br>&gt;     return value<br>&gt; }<br>&gt;  <br>&gt; This is a pretty simple function, and useful in a wide variety of circumstances, so I&#39;d love to get it into the standard library. It doesn&#39;t actually enable any behavior that wasn&#39;t previously possible, but it does shrink some common code patterns, and I find the shorter code easier to read.<br>&gt;  <br>&gt; An example of a place where I use it often is in replacing an optional property with a new value (or with nil) and cleaning up the previous value. Assuming a property like<br>&gt;  <br>&gt; var task: NSURLSessionTask?<br>&gt;  <br>&gt; This replaces<br>&gt;  <br>&gt; if let task = self.task {<br>&gt;     task.cancel()<br>&gt; }<br>&gt; task = nil<br>&gt;  <br>&gt; with<br>&gt;  <br>&gt; replace(&amp;task, with: nil)?.cancel()<br>&gt;  <br>&gt; Or sometimes I use it like<br>&gt;  <br>&gt; if let value = replace(&amp;prop, with: newValue) {<br>&gt;     // multi-line cleanup<br>&gt; }<br>&gt;  <br>&gt; This is particularly nice if it&#39;s a COW value that I want to mutate, as it means I don&#39;t have to worry about getting unwanted copies due to the property still holding the old value while I muck with it.<br></p><p>This is a generalization of the postincrement pattern (mutate a value and return the original) and given that we&#39;re moving away from that I&#39;m not sure it&#39;s something we want to enshrine in the standard library. That said, here&#39;s a question: looking at your use cases, how many of them are using something other than nil (or some moral equivalent) as the second argument?  If this is effectively a non-destructive move in nearly all cases, I&#39;d rather support that more directly.<br></p><p>If cases other than &quot;nondestructive move&quot; are common enough, I&#39;d consider something like this syntax instead:<br></p><p>  (task &lt;- nil).cancel()<br></p><p>But I strongly suspect this isn&#39;t a common enough pattern to warrant introducing an operator.<br></p><p>&gt; Question: For trivial backwards-compatible API changes like this, does a proposal PR need to be submitted to the swift-evolution repo, or is discussion on this ML sufficient before submitting a patch?<br></p><p>A proposal is needed for all new/changed API.<br></p><p>-Dave<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/bf7b8587/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Add replace(_:with:) function to the stdlib</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 14, 2015 at 10:00:00am</p></header><div class="content"><p>That&#39;s a useful pattern, but the implementation above creates a function<br>that has both a return value and a side effect, which is likely to be<br>unexpected for many readers.<br></p><p>public func replace&lt;T&gt;(inout a: T?, with b: T?, andCleanOldValue<br>clean:T-&gt;()) { ... }<br></p><p>replace(&amp;prop, with: newValue) { oldValue in<br>    oldValue.clean()<br>}<br></p><p>As a bonus one can automatically unwrap nil.<br></p><p>Although in real life I tend to move this logic to property accessors, e.g.<br></p><p>// Currently executing task. This property manages task state.<br></p><p>var task: NSURLSessionTask? {<br>  willSet { task?.cancel() }<br>  didSet { task?.resume() }<br>}<br></p><p>On Mon, Dec 14, 2015 at 7:59 AM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 13, 2015, at 2:21 PM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; A function I find myself defining in a lot of my projects looks like the<br>&gt; following:<br>&gt;<br>&gt; /// Replace the value of `a` with `b` and return the old value.<br>&gt; public func replace&lt;T&gt;(inout a: T, with b: T) -&gt; T {<br>&gt;     var value = b<br>&gt;     swap(&amp;a, &amp;value)<br>&gt;     return value<br>&gt; }<br>&gt;<br>&gt; This is a pretty simple function, and useful in a wide variety of<br>&gt; circumstances, so I&#39;d love to get it into the standard library. It doesn&#39;t<br>&gt; actually enable any behavior that wasn&#39;t previously possible, but it does<br>&gt; shrink some common code patterns, and I find the shorter code easier to<br>&gt; read.<br>&gt;<br>&gt; An example of a place where I use it often is in replacing an optional<br>&gt; property with a new value (or with nil) and cleaning up the previous value.<br>&gt; Assuming a property like<br>&gt;<br>&gt; var task: NSURLSessionTask?<br>&gt;<br>&gt; This replaces<br>&gt;<br>&gt; if let task = self.task {<br>&gt;     task.cancel()<br>&gt; }<br>&gt; task = nil<br>&gt;<br>&gt; with<br>&gt;<br>&gt; replace(&amp;task, with: nil)?.cancel()<br>&gt;<br>&gt; Or sometimes I use it like<br>&gt;<br>&gt; if let value = replace(&amp;prop, with: newValue) {<br>&gt;     // multi-line cleanup<br>&gt; }<br>&gt;<br>&gt; This is particularly nice if it&#39;s a COW value that I want to mutate, as it<br>&gt; means I don&#39;t have to worry about getting unwanted copies due to the<br>&gt; property still holding the old value while I muck with it.<br>&gt;<br>&gt;<br>&gt; This is a generalization of the postincrement pattern (mutate a value and<br>&gt; return the original) and given that we&#39;re moving away from that I&#39;m not<br>&gt; sure it&#39;s something we want to enshrine in the standard library. That said,<br>&gt; here&#39;s a question: looking at your use cases, how many of them are using<br>&gt; something other than nil (or some moral equivalent) as the second<br>&gt; argument?  If this is effectively a non-destructive move in nearly all<br>&gt; cases, I&#39;d rather support that more directly.<br>&gt;<br>&gt; If cases other than &quot;nondestructive move&quot; are common *enough*, I&#39;d<br>&gt; consider something like this syntax instead:<br>&gt;<br>&gt;   (task &lt;- nil).cancel()<br>&gt;<br>&gt; But I strongly suspect this isn&#39;t a common enough pattern to warrant<br>&gt; introducing an operator.<br>&gt;<br>&gt; Question: For trivial backwards-compatible API changes like this, does a<br>&gt; proposal PR need to be submitted to the swift-evolution repo, or is<br>&gt; discussion on this ML sufficient before submitting a patch?<br>&gt;<br>&gt;<br>&gt; A proposal is needed for all new/changed API.<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/b48773bf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add replace(_:with:) function to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 14, 2015 at 12:00:00am</p></header><div class="content"><p>Your versions throw away the whole point of the function, which is to make common patterns easier, not more awkward. Adding an unnecessary scope there just makes it impossible to use the function in otherwise-valid circumstances. You&#39;re also focusing on the one example I gave, which is tearing down an old value (which cannot be done in property observers if it should only happen sometimes).<br></p><p>I&#39;ll grant you that it&#39;s uncommon to have functions with both side-effects and return values, but it&#39;s certainly not unheard-of. Heck, that&#39;s how Generators work!<br></p><p>-Kevin Ballard<br></p><p>On Dec 13, 2015, 11:36 PM -0800, ilya&lt;ilya.nikokoshev at gmail.com&gt;, wrote:<br>&gt; That&#39;s a useful pattern, but the implementation above creates a function that has both a return value and a side effect, which is likely to be unexpected for many readers.<br>&gt; <br>&gt; public func replace&lt;T&gt;(inout a: T?, with b: T?, andCleanOldValue clean:T-&gt;()) { ... }<br>&gt; <br>&gt; replace(&amp;prop, with: newValue) { oldValue in<br>&gt; oldValue.clean()<br>&gt; }<br>&gt; <br>&gt; As a bonus one can automatically unwrap nil.<br>&gt; <br>&gt; Although in real life I tend to move this logic to property accessors, e.g.<br>&gt; <br>&gt; // Currently executing task. This property manages task state.<br>&gt; <br>&gt; var task: NSURLSessionTask? {<br>&gt; willSet { task?.cancel() }<br>&gt; didSet { task?.resume() }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; On Mon, Dec 14, 2015 at 7:59 AM, Dave Abrahams via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; <br>&gt; &gt; &gt; On Dec 13, 2015, at 2:21 PM, Kevin Ballard via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt; A function I find myself defining in a lot of my projects looks like the following:<br>&gt; &gt; &gt; /// Replace the value of `a` with `b` and return the old value.<br>&gt; &gt; &gt; public func replace&lt;T&gt;(inout a: T, with b: T) -&gt;T {<br>&gt; &gt; &gt; var value = b<br>&gt; &gt; &gt; swap(&amp;a,&amp;value)<br>&gt; &gt; &gt; return value<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt; This is a pretty simple function, and useful in a wide variety of circumstances, so I&#39;d love to get it into the standard library. It doesn&#39;t actually enable any behavior that wasn&#39;t previously possible, but it does shrink some common code patterns, and I find the shorter code easier to read.<br>&gt; &gt; &gt; An example of a place where I use it often is in replacing an optional property with a new value (or with nil) and cleaning up the previous value. Assuming a property like<br>&gt; &gt; &gt; var task: NSURLSessionTask?<br>&gt; &gt; &gt; This replaces<br>&gt; &gt; &gt; if let task = self.task {<br>&gt; &gt; &gt; task.cancel()<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt; task = nil<br>&gt; &gt; &gt; with<br>&gt; &gt; &gt; replace(&amp;task, with: nil)?.cancel()<br>&gt; &gt; &gt; Or sometimes I use it like<br>&gt; &gt; &gt; if let value = replace(&amp;prop, with: newValue) {<br>&gt; &gt; &gt; // multi-line cleanup<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt; This is particularly nice if it&#39;s a COW value that I want to mutate, as it means I don&#39;t have to worry about getting unwanted copies due to the property still holding the old value while I muck with it.<br>&gt; &gt; <br>&gt; &gt; This is a generalization of the postincrement pattern (mutate a value and return the original) and given that we&#39;re moving away from that I&#39;m not sure it&#39;s something we want to enshrine in the standard library. That said, here&#39;s a question: looking at your use cases, how many of them are using something other than nil (or some moral equivalent) as the second argument?If this is effectively a non-destructive move in nearly all cases, I&#39;d rather support that more directly.<br>&gt; &gt; <br>&gt; &gt; If cases other than &quot;nondestructive move&quot; are commonenough, I&#39;d consider something like this syntax instead:<br>&gt; &gt; <br>&gt; &gt; (task&lt;- nil).cancel()<br>&gt; &gt; <br>&gt; &gt; But I strongly suspect this isn&#39;t a common enough pattern to warrant introducing an operator.<br>&gt; &gt; <br>&gt; &gt; &gt; Question: For trivial backwards-compatible API changes like this, does a proposal PR need to be submitted to the swift-evolution repo, or is discussion on this ML sufficient before submitting a patch?<br>&gt; &gt; A proposal is needed for all new/changed API.<br>&gt; &gt; <br>&gt; &gt; -Dave<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/1959aef5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/661c58274e3f437234236553e2dc156f?s=50"></div><header><strong>Proposal: Add replace(_:with:) function to the stdlib</strong> from <string>Martin Kühl</string> &lt;martin.kuehl at gmail.com&gt;<p>December 14, 2015 at 04:00:00pm</p></header><div class="content"><p>On 14 December 2015 at 09:30, Kevin Ballard via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;ll grant you that it&#39;s uncommon to have functions with both side-effects and return values, but it&#39;s certainly not unheard-of. Heck, that&#39;s how Generators work!<br></p><p>It’s also how all mutating funcs on Dictionary behave.<br></p><p>-Martin<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add replace(_:with:) function to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 14, 2015 at 01:00:00pm</p></header><div class="content"><p>On Sun, Dec 13, 2015, at 08:59 PM, Dave Abrahams wrote:<br>&gt; This is a generalization of the postincrement pattern (mutate a value<br>&gt; and return the original) and given that we&#39;re moving away from that<br>&gt; I&#39;m not sure it&#39;s something we want to enshrine in the standard<br>&gt; library.<br></p><p>It&#39;s also a generalization of Dictionary.updateValue(_:forKey:) and<br>Dictionary.removeValueForKey(_:), and those aren&#39;t going away. Actually<br>I&#39;d say it&#39;s a lot more like the Dictionary methods and less like<br>postincrement because it&#39;s not actually mutating the original value,<br>it&#39;s simply replacing it with a new value.<br></p><p>&gt; That said, here&#39;s a question: looking at your use cases, how many of<br>&gt; them are using something other than nil (or some moral equivalent) as<br>&gt; the second argument?  If this is effectively a non-destructive move in<br>&gt; nearly all cases, I&#39;d rather support that more directly.<br></p><p>In my current codebase, I have 21 uses of replace(&amp;foo, with: nil) and 1<br>use of replace(&amp;foo, with: bar). That said, in my last big Swift project<br>at my previous job I&#39;m pretty sure I had more uses of replace(&amp;foo,<br>with: bar) (but I don&#39;t have the source anymore to check).<br></p><p>&gt; If cases other than &quot;nondestructive move&quot; are common _enough_, I&#39;d<br>&gt; consider something like this syntax instead:<br>&gt;<br>&gt; (task &lt;- nil).cancel()<br>&gt;<br>&gt; But I strongly suspect this isn&#39;t a common enough pattern to warrant<br>&gt; introducing an operator.<br></p><p>Interesting idea. I&#39;m inclined to agree that this isn&#39;t common enough to<br>introduce an operator for.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/5c2848a2/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add replace(_:with:) function to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  9, 2016 at 04:00:00pm</p></header><div class="content"><p>Proposal PR submitted as https://github.com/apple/swift-evolution/pull/93<br></p><p>-Kevin Ballard<br></p><p>On Sun, Dec 13, 2015, at 02:21 PM, Kevin Ballard wrote:<br>&gt; A function I find myself defining in a lot of my projects looks like<br>&gt; the following:<br>&gt;<br>&gt; /// Replace the value of `a` with `b` and return the old value. public<br>&gt; func replace&lt;T&gt;(inout a: T, with b: T) -&gt; T {    var value = b<br>&gt; swap(&amp;a, &amp;value)    return value }<br>&gt;<br>&gt; This is a pretty simple function, and useful in a wide variety of<br>&gt; circumstances, so I&#39;d love to get it into the standard library. It<br>&gt; doesn&#39;t actually enable any behavior that wasn&#39;t previously possible,<br>&gt; but it does shrink some common code patterns, and I find the shorter<br>&gt; code easier to read.<br>&gt;<br>&gt; An example of a place where I use it often is in replacing an optional<br>&gt; property with a new value (or with nil) and cleaning up the previous<br>&gt; value. Assuming a property like<br>&gt;<br>&gt; var task: NSURLSessionTask?<br>&gt;<br>&gt; This replaces<br>&gt;<br>&gt; if let task = self.task {    task.cancel() } task = nil<br>&gt;<br>&gt; with<br>&gt;<br>&gt; replace(&amp;task, with: nil)?.cancel()<br>&gt;<br>&gt; Or sometimes I use it like<br>&gt;<br>&gt; if let value = replace(&amp;prop, with: newValue) {    // multi-line<br>&gt; cleanup }<br>&gt;<br>&gt; This is particularly nice if it&#39;s a COW value that I want to mutate,<br>&gt; as it means I don&#39;t have to worry about getting unwanted copies due to<br>&gt; the property still holding the old value while I muck with it.<br>&gt;<br>&gt; Question: For trivial backwards-compatible API changes like this, does<br>&gt; a proposal PR need to be submitted to the swift-evolution repo, or is<br>&gt; discussion on this ML sufficient before submitting a patch?<br>&gt;<br>&gt; -Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/5d5fed21/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Proposal: Add replace(_:with:) function to the stdlib</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>January 10, 2016 at 01:00:00pm</p></header><div class="content"><p>what is the code<br></p><p>*var a = 1*<br>*var b = -1*<br>*var c = replace(&amp;a, with: b*)<br></p><p>different from<br></p><p>*var a = 1*<br>*var b = -1*<br>*var c = a*<br>*a = b*<br></p><p>?<br></p><p>For me, the latter is more clearer.<br></p><p>On Sun, Jan 10, 2016 at 8:48 AM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Proposal PR submitted as https://github.com/apple/swift-evolution/pull/93<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Sun, Dec 13, 2015, at 02:21 PM, Kevin Ballard wrote:<br>&gt;<br>&gt; A function I find myself defining in a lot of my projects looks like the<br>&gt; following:<br>&gt;<br>&gt; /// Replace the value of `a` with `b` and return the old value.<br>&gt; public func replace&lt;T&gt;(inout a: T, with b: T) -&gt; T {<br>&gt;     var value = b<br>&gt;     swap(&amp;a, &amp;value)<br>&gt;     return value<br>&gt; }<br>&gt;<br>&gt; This is a pretty simple function, and useful in a wide variety of<br>&gt; circumstances, so I&#39;d love to get it into the standard library. It doesn&#39;t<br>&gt; actually enable any behavior that wasn&#39;t previously possible, but it does<br>&gt; shrink some common code patterns, and I find the shorter code easier to<br>&gt; read.<br>&gt;<br>&gt; An example of a place where I use it often is in replacing an optional<br>&gt; property with a new value (or with nil) and cleaning up the previous value.<br>&gt; Assuming a property like<br>&gt;<br>&gt; var task: NSURLSessionTask?<br>&gt;<br>&gt; This replaces<br>&gt;<br>&gt; if let task = self.task {<br>&gt;     task.cancel()<br>&gt; }<br>&gt; task = nil<br>&gt;<br>&gt; with<br>&gt;<br>&gt; replace(&amp;task, with: nil)?.cancel()<br>&gt;<br>&gt; Or sometimes I use it like<br>&gt;<br>&gt; if let value = replace(&amp;prop, with: newValue) {<br>&gt;     // multi-line cleanup<br>&gt; }<br>&gt;<br>&gt; This is particularly nice if it&#39;s a COW value that I want to mutate, as it<br>&gt; means I don&#39;t have to worry about getting unwanted copies due to the<br>&gt; property still holding the old value while I muck with it.<br>&gt;<br>&gt; Question: For trivial backwards-compatible API changes like this, does a<br>&gt; proposal PR need to be submitted to the swift-evolution repo, or is<br>&gt; discussion on this ML sufficient before submitting a patch?<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br></p><p>Owen Zhao<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/bc7b13b8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add replace(_:with:) function to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 10, 2016 at 01:00:00pm</p></header><div class="content"><p>Neither code snippet appears to be doing much at all. It&#39;s hard to judge<br>anything at all when the code has been reduced that far.<br></p><p>-Kevin Ballard<br></p><p>On Sat, Jan 9, 2016, at 09:53 PM, 肇鑫 wrote:<br>&gt; what is the code<br>&gt;<br>&gt; *var a = 1* *var b = -1* *var c = replace(&amp;a, with: b*)<br>&gt;<br>&gt; different from<br>&gt;<br>&gt; *var a = 1* *var b = -1* *var c = a* *a = b*<br>&gt;<br>&gt; ?<br>&gt;<br>&gt; For me, the latter is more clearer.<br>&gt;<br>&gt; On Sun, Jan 10, 2016 at 8:48 AM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt; __<br>&gt;&gt; Proposal PR submitted as<br>&gt;&gt; https://github.com/apple/swift-evolution/pull/93<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; On Sun, Dec 13, 2015, at 02:21 PM, Kevin Ballard wrote:<br>&gt;&gt;&gt; A function I find myself defining in a lot of my projects looks like<br>&gt;&gt;&gt; the following:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; /// Replace the value of `a` with `b` and return the old value.<br>&gt;&gt;&gt; public func replace&lt;T&gt;(inout a: T, with b: T) -&gt; T {    var value =<br>&gt;&gt;&gt; b    swap(&amp;a, &amp;value)    return value }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is a pretty simple function, and useful in a wide variety of<br>&gt;&gt;&gt; circumstances, so I&#39;d love to get it into the standard library. It<br>&gt;&gt;&gt; doesn&#39;t actually enable any behavior that wasn&#39;t previously<br>&gt;&gt;&gt; possible, but it does shrink some common code patterns, and I find<br>&gt;&gt;&gt; the shorter code easier to read.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; An example of a place where I use it often is in replacing an<br>&gt;&gt;&gt; optional property with a new value (or with nil) and cleaning up the<br>&gt;&gt;&gt; previous value. Assuming a property like<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var task: NSURLSessionTask?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This replaces<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let task = self.task {    task.cancel() } task = nil<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; with<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; replace(&amp;task, with: nil)?.cancel()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Or sometimes I use it like<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let value = replace(&amp;prop, with: newValue) {    // multi-line<br>&gt;&gt;&gt; cleanup }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is particularly nice if it&#39;s a COW value that I want to mutate,<br>&gt;&gt;&gt; as it means I don&#39;t have to worry about getting unwanted copies due<br>&gt;&gt;&gt; to the property still holding the old value while I muck with it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Question: For trivial backwards-compatible API changes like this,<br>&gt;&gt;&gt; does a proposal PR need to be submitted to the swift-evolution repo,<br>&gt;&gt;&gt; or is discussion on this ML sufficient before submitting a patch?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt;<br>swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;<br>&gt; Owen Zhao<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/56bc8b57/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Add replace(_:with:) function to the stdlib</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 10, 2016 at 04:00:00pm</p></header><div class="content"><p>One thing I noticed is that this appears to be a generalization of `Dictionary.updateValue(_:forKey:)`. Should the dictionary-specific version continue to exist? If it should, should we modify one or the other to have more closely-matching naming or argument ordering?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add replace(_:with:) function to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 10, 2016 at 05:00:00pm</p></header><div class="content"><p>On Sun, Jan 10, 2016, at 04:30 PM, Brent Royal-Gordon wrote:<br>&gt; One thing I noticed is that this appears to be a generalization of `Dictionary.updateValue(_:forKey:)`. Should the dictionary-specific version continue to exist? If it should, should we modify one or the other to have more closely-matching naming or argument ordering?<br></p><p>Good question. I&#39;m inclined to say that we should keep Dictionary.updateValue(_:forKey:) for two reasons:<br></p><p>1. Documentation. It&#39;s reasonable to expect a function like Dictionary.updateValue(_:forKey:) to be found on Dictionary.<br>2. Performance. Dictionary&#39;s getter/setter combo is implemented using a classic computed getter/setter pair (as opposed to mutableAddressWithPinnedNativeOwner), which makes sense because adding or deleting keys need to do more than manipulate the contents of an address. But because of this, using an inout expression &amp;d[key] actually invokes the getter, performs the mutations, and then invokes the setter with the new value. This means that the expression `replace(&amp;d[key], with: newValue)` actually looks up the key in the hashtable twice, whereas Dictionary.updateValue(_:forKey:) only has to look it up once.<br></p><p>I don&#39;t think it makes sense to swap the arguments for replace(_:with:). We could change updateValue(_:forKey:) to instead be called something like updateKey(_:withValue:), but the current name updateValue(_:forKey:) is consistent with the method removeValueForKey(_:).<br></p><p>So ultimately, while I recognize that `replace(&amp;d[key], with: newValue)` is equivalent to `d.updateValue(newValue, forKey: key)` (though likely with slightly worse performance), I think we should keep both replace(_:with:) and Dictionary.updateValue(_:forKey:) as-is.<br></p><p>-Kevin Ballard<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Add replace(_:with:) function to the stdlib</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 11, 2016 at 01:00:00pm</p></header><div class="content"><p>-1 from me as well, for the same reason as Dave. In the Dictionary case, doing a lookup and then a replacement isn&#39;t just more verbose; it&#39;s actually less efficient. And I still wouldn&#39;t embed an updateValue(_:forKey:) in a larger expression, for clarity&#39;s sake.<br></p><p>Now, admittedly, if the assigned-to value were some complicated expression (e.g. &quot;view.frame.size.height&quot;), the same performance argument applies. But I still think I&#39;d rather people just use a temporary variable.<br></p><p>self.task?.cancel()<br>self.task = nil<br></p><p>let oldValue = self.prop<br>self.prop = newValue<br>if let oldValue = oldValue {<br>  // multi-line cleanup<br>}<br></p><p>I&#39;ll admit the latter is not as nice, but it&#39;s definitely easier for me to read.<br></p><p>Jordan<br></p><p><br>&gt; On Jan 9, 2016, at 16:48, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Proposal PR submitted as https://github.com/apple/swift-evolution/pull/93 &lt;https://github.com/apple/swift-evolution/pull/93&gt;<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Sun, Dec 13, 2015, at 02:21 PM, Kevin Ballard wrote:<br>&gt;&gt; A function I find myself defining in a lot of my projects looks like the following:<br>&gt;&gt;  <br>&gt;&gt; /// Replace the value of `a` with `b` and return the old value.<br>&gt;&gt; public func replace&lt;T&gt;(inout a: T, with b: T) -&gt; T {<br>&gt;&gt;     var value = b<br>&gt;&gt;     swap(&amp;a, &amp;value)<br>&gt;&gt;     return value<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; This is a pretty simple function, and useful in a wide variety of circumstances, so I&#39;d love to get it into the standard library. It doesn&#39;t actually enable any behavior that wasn&#39;t previously possible, but it does shrink some common code patterns, and I find the shorter code easier to read.<br>&gt;&gt;  <br>&gt;&gt; An example of a place where I use it often is in replacing an optional property with a new value (or with nil) and cleaning up the previous value. Assuming a property like<br>&gt;&gt;  <br>&gt;&gt; var task: NSURLSessionTask?<br>&gt;&gt;  <br>&gt;&gt; This replaces<br>&gt;&gt;  <br>&gt;&gt; if let task = self.task {<br>&gt;&gt;     task.cancel()<br>&gt;&gt; }<br>&gt;&gt; task = nil<br>&gt;&gt;  <br>&gt;&gt; with<br>&gt;&gt;  <br>&gt;&gt; replace(&amp;task, with: nil)?.cancel()<br>&gt;&gt;  <br>&gt;&gt; Or sometimes I use it like<br>&gt;&gt;  <br>&gt;&gt; if let value = replace(&amp;prop, with: newValue) {<br>&gt;&gt;     // multi-line cleanup<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; This is particularly nice if it&#39;s a COW value that I want to mutate, as it means I don&#39;t have to worry about getting unwanted copies due to the property still holding the old value while I muck with it.<br>&gt;&gt;  <br>&gt;&gt; Question: For trivial backwards-compatible API changes like this, does a proposal PR need to be submitted to the swift-evolution repo, or is discussion on this ML sufficient before submitting a patch?<br>&gt;&gt;  <br>&gt;&gt; -Kevin Ballard<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/ca28f85b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add replace(_:with:) function to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 13, 2016 at 01:00:00pm</p></header><div class="content"><p>FWIW, in the code I&#39;ve written over the past few days in a new project, I&#39;ve already used my local replace(_:with:) 6 times, and I just tried to use it a 7th from within the unit tests and got an error because the function is private &gt;_&lt;<br></p><p>It does turn out that nearly all of my particular uses for this function<br>end up replacing the value with `nil`, but there certainly are cases<br>where you&#39;d want to replace a value with some other non-nil value (such<br>as the example I listed in the proposal about a spot where it might be<br>used in the stdlib).<br></p><p>On Mon, Jan 11, 2016, at 01:22 PM, Jordan Rose wrote:<br>&gt; -1 from me as well, for the same reason as Dave. In the Dictionary<br>&gt; case, doing a lookup and then a replacement isn&#39;t just more verbose;<br>&gt; it&#39;s actually less efficient. And I *still* wouldn&#39;t embed an<br>&gt; updateValue(_:forKey:) in a larger expression, for clarity&#39;s sake.<br></p><p>I&#39;m not recommending that replace(_:with:) be used as a replacement for<br>Dictionary.updateValue(_:forKey:). I just found it interesting that it<br>has the exact same semantics (but, as you said, it&#39;s less performant).<br></p><p>&gt; Now, admittedly, if the assigned-to value were some complicated<br>&gt; expression (e.g. &quot;view.frame.size.height&quot;), the same performance<br>&gt; argument applies. But I still think I&#39;d rather people just use a<br>&gt; temporary variable.<br></p><p>What do you mean? Using `replace(&amp;view.frame.size.height, with:<br>newHeight)` is no less performant than doing things manually. The<br>Dictionary.updateValue(_:forKey:) case only differs because<br>accessing the subscript getter + setter has to look up the key<br>twice, but `&amp;view.frame.size.height` doesn&#39;t have to look up<br>anything, it just has to read the property and then set it again,<br>which is exactly what you have to do if you want to read the old<br>value and assign a new one regardless of whether you&#39;re using a<br>function like replace(_:with:) to do it.<br></p><p>&gt;&gt; self.task?.cancel() self.task = nil<br>&gt;&gt;<br>&gt;&gt; let oldValue = self.prop self.prop = newValue if let oldValue =<br>&gt;&gt; oldValue {  // multi-line cleanup }<br>&gt;<br>&gt; I&#39;ll admit the latter is not as nice, but it&#39;s definitely easier for<br>&gt; me to read.<br></p><p>Maybe for you. I find it much easier to read<br></p><p>if let oldValue = replace(&amp;self.prop, with: nil) {<br></p><p><br>// ...<br></p><p><br>}<br></p><p><br></p><p>I recognize that many people will prefer the &quot;manual&quot; version, but I&#39;m<br>sure many people will be like me and prefer the replace(_:with:)<br>version. I don&#39;t find the argument &quot;I think it&#39;s easier to read &lt;some<br>other way&gt;&quot; to be very compelling when it comes to stdlib or language<br>features, because we already have plenty of precedent for being able to<br>write the same thing in multiple ways. There&#39;s also a middle ground<br>here, if you just don&#39;t like embedding replace(_:with:) in a larger<br>construct, that still uses a temporary variable but allows you to avoid<br>duplicating complicated accessor expressions, e.g.<br></p><p>let oldValue =<br>replace(&amp;self.sections[indexPath.section].rows[indexPath.row].data,<br>with: newValue)<br></p><p>if let oldValue = oldValue {<br></p><p>// ...<br></p><p>}<br></p><p><br>I&#39;ve also found a lot of use for replace(_:with:) in `guard let`<br>expressions. There especially the &quot;manual&quot; version sucks because it<br>leaves a second variable lying around that you don&#39;t want anymore. In<br>the library I&#39;m working on right now, I have a bunch of uses of<br>replace(_:with:) that look like<br></p><p>guard var request = replace(&amp;self.request, with; nil) else {<br></p><p>writeResponse(Response(status: .InternalServerError, text: &quot;Internal<br>server error: couldn&#39;t find active request&quot;))<br></p><p>return<br></p><p>}<br></p><p><br>(yes, this is actually for an HTTP server written in Swift, which I&#39;m<br>using to test networking code)<br></p><p>What&#39;s your opinion on the alternative &lt;- operator (which IIRC Dave<br>suggested)? I much prefer replace(_:with:), and I don&#39;t think it<br>conflicts with stdlib conventions (it&#39;s no different than a mutating<br>method that returns a value, it just happens to be a function, but<br>there&#39;s not much of a difference between mutating methods and functions<br>that take an inout first parameter), but I&#39;d rather have this<br>functionality as an &lt;- operator than not have it at all. As an example,<br>the previous two code samples, when written with &lt;-, would look like<br></p><p>let oldValue =<br>(self.sections[indexPath.section].rows[indexPath.row].data &lt;- newValue)<br></p><p>if let oldValue = oldValue {<br></p><p>// ...<br></p><p>}<br></p><p><br></p><p>and<br></p><p>guard var request = (self.request &lt;- nil) else {<br></p><p>writeResponse(Response(status: .InternalServerError, text: &quot;Internal<br>server error: couldn&#39;t find active request&quot;))<br></p><p>return<br></p><p>}<br></p><p><br>-Kevin Ballard<br></p><p>&gt; Jordan<br>&gt;<br>&gt;<br>&gt;&gt; On Jan 9, 2016, at 16:48, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Proposal PR submitted as<br>&gt;&gt; https://github.com/apple/swift-evolution/pull/93<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; On Sun, Dec 13, 2015, at 02:21 PM, Kevin Ballard wrote:<br>&gt;&gt;&gt; A function I find myself defining in a lot of my projects looks like<br>&gt;&gt;&gt; the following:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; /// Replace the value of `a` with `b` and return the old value.<br>&gt;&gt;&gt; public func replace&lt;T&gt;(inout a: T, with b: T) -&gt; T {    var value =<br>&gt;&gt;&gt; b    swap(&amp;a, &amp;value)    return value }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is a pretty simple function, and useful in a wide variety of<br>&gt;&gt;&gt; circumstances, so I&#39;d love to get it into the standard library. It<br>&gt;&gt;&gt; doesn&#39;t actually enable any behavior that wasn&#39;t previously<br>&gt;&gt;&gt; possible, but it does shrink some common code patterns, and I find<br>&gt;&gt;&gt; the shorter code easier to read.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; An example of a place where I use it often is in replacing an<br>&gt;&gt;&gt; optional property with a new value (or with nil) and cleaning up the<br>&gt;&gt;&gt; previous value. Assuming a property like<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var task: NSURLSessionTask?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This replaces<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let task = self.task {    task.cancel() } task = nil<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; with<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; replace(&amp;task, with: nil)?.cancel()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Or sometimes I use it like<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let value = replace(&amp;prop, with: newValue) {    // multi-line<br>&gt;&gt;&gt; cleanup }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is particularly nice if it&#39;s a COW value that I want to mutate,<br>&gt;&gt;&gt; as it means I don&#39;t have to worry about getting unwanted copies due<br>&gt;&gt;&gt; to the property still holding the old value while I muck with it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Question: For trivial backwards-compatible API changes like this,<br>&gt;&gt;&gt; does a proposal PR need to be submitted to the swift-evolution repo,<br>&gt;&gt;&gt; or is discussion on this ML sufficient before submitting a patch?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/dcbbc366/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
