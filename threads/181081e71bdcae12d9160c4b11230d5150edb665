<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>map-like operation that returns a dictionary</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>January 10, 2016 at 09:00:00am</p></header><div class="content"><p>Hi All.<br></p><p>I find that instead of using map() on arrays, I more often use an operation that returns a dictionary from an array. A common case is fetching an array of data, then creating a local cache of it indexed by ID.<br></p><p>Is there a name for this operation? Is this something that others would like to see added to the standard library?<br></p><p>-Kenny<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>map-like operation that returns a dictionary</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>January 11, 2016 at 02:00:00am</p></header><div class="content"><p>You can use dictionary in a map. You just ignore the return value of the<br>map.<br></p><p>var dic = [Int:String]()<br>var index = 0<br></p><p>[&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, &quot;Kavin&quot;].map {<br>    dic.updateValue($0, forKey: index)<br>    index += 1<br>}<br></p><p>print(dic) // [2: &quot;Amy&quot;, 0: &quot;John&quot;, 1: &quot;Mike&quot;, 3: &quot;Kavin&quot;]<br></p><p>zhaoxin<br></p><p>On Mon, Jan 11, 2016 at 1:50 AM, Kenny Leung via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi All.<br>&gt;<br>&gt; I find that instead of using map() on arrays, I more often use an<br>&gt; operation that returns a dictionary from an array. A common case is<br>&gt; fetching an array of data, then creating a local cache of it indexed by ID.<br>&gt;<br>&gt; Is there a name for this operation? Is this something that others would<br>&gt; like to see added to the standard library?<br>&gt;<br>&gt; -Kenny<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br></p><p>Owen Zhao<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/47febf02/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f5228ad4a1fad94f1a7d3d05b0c0ff6a?s=50"></div><header><strong>map-like operation that returns a dictionary</strong> from <string>Donnacha Oisín Kidney</string> &lt;oisin.kidney at gmail.com&gt;<p>January 10, 2016 at 07:00:00pm</p></header><div class="content"><p>I think that use of map is generally discouraged. forEach would probably be more explicit, or a for-loop.<br></p><p>&gt; On 10 Jan 2016, at 18:58, 肇鑫 via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; You can use dictionary in a map. You just ignore the return value of the map.<br>&gt; <br>&gt; var dic = [Int:String]()<br>&gt; var index = 0<br>&gt; <br>&gt; [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, &quot;Kavin&quot;].map {<br>&gt;     dic.updateValue($0, forKey: index)<br>&gt;     index += 1<br>&gt; }<br>&gt; <br>&gt; print(dic) // [2: &quot;Amy&quot;, 0: &quot;John&quot;, 1: &quot;Mike&quot;, 3: &quot;Kavin&quot;]<br>&gt; <br>&gt; zhaoxin<br>&gt; <br>&gt; On Mon, Jan 11, 2016 at 1:50 AM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi All.<br>&gt; <br>&gt; I find that instead of using map() on arrays, I more often use an operation that returns a dictionary from an array. A common case is fetching an array of data, then creating a local cache of it indexed by ID.<br>&gt; <br>&gt; Is there a name for this operation? Is this something that others would like to see added to the standard library?<br>&gt; <br>&gt; -Kenny<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; <br>&gt; Owen Zhao<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/d30fdff7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>map-like operation that returns a dictionary</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>January 10, 2016 at 07:00:00pm</p></header><div class="content"><p>Or an enumeration followed by a forEach.<br>[&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, Kavin&quot;].enumerate().forEach {<br>    dic[$0] = $1<br>}<br>That said, it requires creating a dictionary var first, not a let. If there<br>was an initialiser for Dictionary which took an Array or EnumerateSequence,<br>that might be useful. I&#39;m not sure how I&#39;d attempt to write such an<br>initialiser though.<br></p><p><br>On Sun, Jan 10, 2016 at 7:08 PM, Donnacha Oisín Kidney &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think that use of map is generally discouraged. forEach would probably<br>&gt; be more explicit, or a for-loop.<br>&gt;<br>&gt; On 10 Jan 2016, at 18:58, 肇鑫 via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; You can use dictionary in a map. You just ignore the return value of the<br>&gt; map.<br>&gt;<br>&gt; var dic = [Int:String]()<br>&gt; var index = 0<br>&gt;<br>&gt; [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, &quot;Kavin&quot;].map {<br>&gt;     dic.updateValue($0, forKey: index)<br>&gt;     index += 1<br>&gt; }<br>&gt;<br>&gt; print(dic) // [2: &quot;Amy&quot;, 0: &quot;John&quot;, 1: &quot;Mike&quot;, 3: &quot;Kavin&quot;]<br>&gt;<br>&gt; zhaoxin<br>&gt;<br>&gt; On Mon, Jan 11, 2016 at 1:50 AM, Kenny Leung via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi All.<br>&gt;&gt;<br>&gt;&gt; I find that instead of using map() on arrays, I more often use an<br>&gt;&gt; operation that returns a dictionary from an array. A common case is<br>&gt;&gt; fetching an array of data, then creating a local cache of it indexed by ID.<br>&gt;&gt;<br>&gt;&gt; Is there a name for this operation? Is this something that others would<br>&gt;&gt; like to see added to the standard library?<br>&gt;&gt;<br>&gt;&gt; -Kenny<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;<br>&gt; Owen Zhao<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/31066e51/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>map-like operation that returns a dictionary</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 11, 2016 at 02:00:00am</p></header><div class="content"><p>There is no equivalent to something like <br></p><p>array.zipWithIndex.toMap (or in this case array.zipWithIndex.toDictionary // where zipWithIndex creates tuples with the index - a specialized case of zip for Arrays with indexes.<br></p><p><br></p><p>&gt; On 2016-01-11, at 2:41:59, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Or an enumeration followed by a forEach.<br>&gt; [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, Kavin&quot;].enumerate().forEach {<br>&gt;     dic[$0] = $1<br>&gt; }<br>&gt; That said, it requires creating a dictionary var first, not a let. If there was an initialiser for Dictionary which took an Array or EnumerateSequence, that might be useful. I&#39;m not sure how I&#39;d attempt to write such an initialiser though.<br>&gt; <br>&gt; <br>&gt; On Sun, Jan 10, 2016 at 7:08 PM, Donnacha Oisín Kidney &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I think that use of map is generally discouraged. forEach would probably be more explicit, or a for-loop.<br>&gt; <br>&gt;&gt; On 10 Jan 2016, at 18:58, 肇鑫 via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; You can use dictionary in a map. You just ignore the return value of the map.<br>&gt;&gt; <br>&gt;&gt; var dic = [Int:String]()<br>&gt;&gt; var index = 0<br>&gt;&gt; <br>&gt;&gt; [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, &quot;Kavin&quot;].map {<br>&gt;&gt;     dic.updateValue($0, forKey: index)<br>&gt;&gt;     index += 1<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; print(dic) // [2: &quot;Amy&quot;, 0: &quot;John&quot;, 1: &quot;Mike&quot;, 3: &quot;Kavin&quot;]<br>&gt;&gt; <br>&gt;&gt; zhaoxin<br>&gt;&gt; <br>&gt;&gt; On Mon, Jan 11, 2016 at 1:50 AM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hi All.<br>&gt;&gt; <br>&gt;&gt; I find that instead of using map() on arrays, I more often use an operation that returns a dictionary from an array. A common case is fetching an array of data, then creating a local cache of it indexed by ID.<br>&gt;&gt; <br>&gt;&gt; Is there a name for this operation? Is this something that others would like to see added to the standard library?<br>&gt;&gt; <br>&gt;&gt; -Kenny<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; <br>&gt;&gt; Owen Zhao<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/0763d006/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85ade213ef182c4a30916753b3c82b1e?s=50"></div><header><strong>map-like operation that returns a dictionary</strong> from <string>Ian Ynda-Hummel</string> &lt;ianynda at gmail.com&gt;<p>January 10, 2016 at 09:00:00pm</p></header><div class="content"><p>I think this probably wants to be a `reduce`. Given the above example:<br></p><p>    [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, &quot;Kavin&quot;].enumerate().reduce([Int: String]()) {<br>(var dictionary, data) in<br>        dictionary[data.index] = data.element<br>        return dictionary<br>    }<br></p><p>Which means you create an immutable dictionary with `let`. This could<br>probably look nicer, but I think it illustrates the idea, at least.<br></p><p>-Ian<br></p><p>On Sun, Jan 10, 2016 at 2:46 PM Craig Cruden via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; There is no equivalent to something like<br>&gt;<br>&gt; array.zipWithIndex.toMap (or in this case array.zipWithIndex.toDictionary<br>&gt; // where zipWithIndex creates tuples with the index - a specialized case of<br>&gt; zip for Arrays with indexes.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 2016-01-11, at 2:41:59, Ross O&#39;Brien via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Or an enumeration followed by a forEach.<br>&gt; [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, Kavin&quot;].enumerate().forEach {<br>&gt;     dic[$0] = $1<br>&gt; }<br>&gt; That said, it requires creating a dictionary var first, not a let. If<br>&gt; there was an initialiser for Dictionary which took an Array or<br>&gt; EnumerateSequence, that might be useful. I&#39;m not sure how I&#39;d attempt to<br>&gt; write such an initialiser though.<br>&gt;<br>&gt;<br>&gt; On Sun, Jan 10, 2016 at 7:08 PM, Donnacha Oisín Kidney &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I think that use of map is generally discouraged. forEach would probably<br>&gt;&gt; be more explicit, or a for-loop.<br>&gt;&gt;<br>&gt;&gt; On 10 Jan 2016, at 18:58, 肇鑫 via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; You can use dictionary in a map. You just ignore the return value of the<br>&gt;&gt; map.<br>&gt;&gt;<br>&gt;&gt; var dic = [Int:String]()<br>&gt;&gt; var index = 0<br>&gt;&gt;<br>&gt;&gt; [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, &quot;Kavin&quot;].map {<br>&gt;&gt;     dic.updateValue($0, forKey: index)<br>&gt;&gt;     index += 1<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; print(dic) // [2: &quot;Amy&quot;, 0: &quot;John&quot;, 1: &quot;Mike&quot;, 3: &quot;Kavin&quot;]<br>&gt;&gt;<br>&gt;&gt; zhaoxin<br>&gt;&gt;<br>&gt;&gt; On Mon, Jan 11, 2016 at 1:50 AM, Kenny Leung via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hi All.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I find that instead of using map() on arrays, I more often use an<br>&gt;&gt;&gt; operation that returns a dictionary from an array. A common case is<br>&gt;&gt;&gt; fetching an array of data, then creating a local cache of it indexed by ID.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Is there a name for this operation? Is this something that others would<br>&gt;&gt;&gt; like to see added to the standard library?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Kenny<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;<br>&gt;&gt; Owen Zhao<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/bee30918/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ccbc60826cca6a6f9c527b671cdad531?s=50"></div><header><strong>map-like operation that returns a dictionary</strong> from <string>Loïc Lecrenier</string> &lt;loiclecrenier at icloud.com&gt;<p>January 10, 2016 at 10:00:00pm</p></header><div class="content"><p>I think this is O(n^2) though, so it’s not really usable.<br>(It is destroying and copying the dictionary each time)<br></p><p>There really isn’t anything like map for dictionaries. <br>I am not convinced we should add it to the standard library though.<br></p><p>&gt; On Jan 10, 2016, at 10:19 PM, Ian Ynda-Hummel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think this probably wants to be a `reduce`. Given the above example:<br>&gt; <br>&gt;     [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, &quot;Kavin&quot;].enumerate().reduce([Int: String]()) { (var dictionary, data) in<br>&gt;         dictionary[data.index] = data.element<br>&gt;         return dictionary<br>&gt;     }<br>&gt; <br>&gt; Which means you create an immutable dictionary with `let`. This could probably look nicer, but I think it illustrates the idea, at least.<br>&gt; <br>&gt; -Ian<br>&gt; <br>&gt; On Sun, Jan 10, 2016 at 2:46 PM Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; There is no equivalent to something like <br>&gt; <br>&gt; array.zipWithIndex.toMap (or in this case array.zipWithIndex.toDictionary // where zipWithIndex creates tuples with the index - a specialized case of zip for Arrays with indexes.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 2016-01-11, at 2:41:59, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Or an enumeration followed by a forEach.<br>&gt;&gt; [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, Kavin&quot;].enumerate().forEach {<br>&gt;&gt;     dic[$0] = $1<br>&gt;&gt; }<br>&gt;&gt; That said, it requires creating a dictionary var first, not a let. If there was an initialiser for Dictionary which took an Array or EnumerateSequence, that might be useful. I&#39;m not sure how I&#39;d attempt to write such an initialiser though.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sun, Jan 10, 2016 at 7:08 PM, Donnacha Oisín Kidney &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I think that use of map is generally discouraged. forEach would probably be more explicit, or a for-loop.<br>&gt;&gt; <br>&gt;&gt;&gt; On 10 Jan 2016, at 18:58, 肇鑫 via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can use dictionary in a map. You just ignore the return value of the map.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var dic = [Int:String]()<br>&gt;&gt;&gt; var index = 0<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, &quot;Kavin&quot;].map {<br>&gt;&gt;&gt;     dic.updateValue($0, forKey: index)<br>&gt;&gt;&gt;     index += 1<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(dic) // [2: &quot;Amy&quot;, 0: &quot;John&quot;, 1: &quot;Mike&quot;, 3: &quot;Kavin&quot;]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; zhaoxin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Jan 11, 2016 at 1:50 AM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Hi All.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I find that instead of using map() on arrays, I more often use an operation that returns a dictionary from an array. A common case is fetching an array of data, then creating a local cache of it indexed by ID.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there a name for this operation? Is this something that others would like to see added to the standard library?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kenny<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Owen Zhao<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/07fd59204e51d141632898356a6c1d00?s=50"></div><header><strong>map-like operation that returns a dictionary</strong> from <string>Jo Albright</string> &lt;me at jo2.co&gt;<p>January 10, 2016 at 05:00:00pm</p></header><div class="content"><p>Possible solution to do what you are wanting. <br></p><p>extension Array {<br>    <br>    func map&lt;T&gt;(var d: [String:T] = [:], @noescape transform: (Int,Array.Generator.Element) throws -&gt; [String:T]) rethrows -&gt; [String:T] {<br>        <br>        for (i,item) in self.enumerate() {<br>            <br>            try d += transform(i,item)<br>            <br>        }<br>        <br>        return d<br>        <br>    }<br>    <br>}<br></p><p>func += &lt;T&gt;(inout lhs: [String:T], rhs: [String:T]) -&gt; [String:T] {<br>    <br>    for (k,v) in rhs { lhs[k] = v }; return lhs<br>    <br>}<br></p><p><br>let names = [&quot;Jo&quot;,&quot;Jenna&quot;,&quot;Jake&quot;,&quot;Julie&quot;]<br>let ages = [32,20,46,39]<br>    <br>let namesInfo1 = names.map { [&quot;\($0)&quot;: $1] }<br>namesInfo1 // [&quot;2&quot;: &quot;Jake&quot;, &quot;1&quot;: &quot;Jenna&quot;, &quot;0&quot;: &quot;Jo&quot;, &quot;3&quot;: &quot;Julie&quot;]<br></p><p>let namesInfo2 = names.map([&quot;6&quot;:&quot;Jim&quot;]) { [&quot;\($0)&quot;: $1] }<br>namesInfo2 // [&quot;2&quot;: &quot;Jake&quot;, &quot;1&quot;: &quot;Jenna&quot;, &quot;0&quot;: &quot;Jo&quot;, &quot;6&quot;: &quot;Jim&quot;, &quot;3&quot;: &quot;Julie&quot;]<br></p><p>let namesInfo3 = names.map { [$1: ages[$0]] }<br>namesInfo3 // [&quot;Jenna&quot;: 20, &quot;Jo&quot;: 32, &quot;Jake&quot;: 46, &quot;Julie&quot;: 39]<br></p><p>Designer . Developer .  Nerd <br>Jo Albright<br></p><p><br>&gt; On Jan 10, 2016, at 4:25 PM, Loïc Lecrenier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think this is O(n^2) though, so it’s not really usable.<br>&gt; (It is destroying and copying the dictionary each time)<br>&gt; <br>&gt; There really isn’t anything like map for dictionaries. <br>&gt; I am not convinced we should add it to the standard library though.<br>&gt; <br>&gt;&gt; On Jan 10, 2016, at 10:19 PM, Ian Ynda-Hummel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think this probably wants to be a `reduce`. Given the above example:<br>&gt;&gt; <br>&gt;&gt;    [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, &quot;Kavin&quot;].enumerate().reduce([Int: String]()) { (var dictionary, data) in<br>&gt;&gt;        dictionary[data.index] = data.element<br>&gt;&gt;        return dictionary<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; Which means you create an immutable dictionary with `let`. This could probably look nicer, but I think it illustrates the idea, at least.<br>&gt;&gt; <br>&gt;&gt; -Ian<br>&gt;&gt; <br>&gt;&gt; On Sun, Jan 10, 2016 at 2:46 PM Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; There is no equivalent to something like <br>&gt;&gt; <br>&gt;&gt; array.zipWithIndex.toMap (or in this case array.zipWithIndex.toDictionary // where zipWithIndex creates tuples with the index - a specialized case of zip for Arrays with indexes.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 2016-01-11, at 2:41:59, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or an enumeration followed by a forEach.<br>&gt;&gt;&gt; [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, Kavin&quot;].enumerate().forEach {<br>&gt;&gt;&gt;    dic[$0] = $1<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; That said, it requires creating a dictionary var first, not a let. If there was an initialiser for Dictionary which took an Array or EnumerateSequence, that might be useful. I&#39;m not sure how I&#39;d attempt to write such an initialiser though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sun, Jan 10, 2016 at 7:08 PM, Donnacha Oisín Kidney &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I think that use of map is generally discouraged. forEach would probably be more explicit, or a for-loop.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 10 Jan 2016, at 18:58, 肇鑫 via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You can use dictionary in a map. You just ignore the return value of the map.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var dic = [Int:String]()<br>&gt;&gt;&gt;&gt; var index = 0<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, &quot;Kavin&quot;].map {<br>&gt;&gt;&gt;&gt;    dic.updateValue($0, forKey: index)<br>&gt;&gt;&gt;&gt;    index += 1<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; print(dic) // [2: &quot;Amy&quot;, 0: &quot;John&quot;, 1: &quot;Mike&quot;, 3: &quot;Kavin&quot;]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; zhaoxin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Jan 11, 2016 at 1:50 AM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Hi All.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I find that instead of using map() on arrays, I more often use an operation that returns a dictionary from an array. A common case is fetching an array of data, then creating a local cache of it indexed by ID.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there a name for this operation? Is this something that others would like to see added to the standard library?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Kenny<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Owen Zhao<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/a297eeb6/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>map-like operation that returns a dictionary</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>January 11, 2016 at 08:00:00am</p></header><div class="content"><p>I would like to keep this lightweight for the consumer, so you could write:<br></p><p>let people :[Person] = fetchPeople()<br>let cache :[Int:Person] = people.map {return $0.id}<br></p><p>-Kenny<br></p><p><br>&gt; On Jan 10, 2016, at 2:24 PM, Jo Albright via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Possible solution to do what you are wanting. <br>&gt; <br>&gt; extension Array {<br>&gt;     <br>&gt;     func map&lt;T&gt;(var d: [String:T] = [:], @noescape transform: (Int,Array.Generator.Element) throws -&gt; [String:T]) rethrows -&gt; [String:T] {<br>&gt;         <br>&gt;         for (i,item) in self.enumerate() {<br>&gt;             <br>&gt;             try d += transform(i,item)<br>&gt;             <br>&gt;         }<br>&gt;         <br>&gt;         return d<br>&gt;         <br>&gt;     }<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; func += &lt;T&gt;(inout lhs: [String:T], rhs: [String:T]) -&gt; [String:T] {<br>&gt;     <br>&gt;     for (k,v) in rhs { lhs[k] = v }; return lhs<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; <br>&gt; let names = [&quot;Jo&quot;,&quot;Jenna&quot;,&quot;Jake&quot;,&quot;Julie&quot;]<br>&gt; let ages = [32,20,46,39]<br>&gt;     <br>&gt; let namesInfo1 = names.map { [&quot;\($0)&quot;: $1] }<br>&gt; namesInfo1 // [&quot;2&quot;: &quot;Jake&quot;, &quot;1&quot;: &quot;Jenna&quot;, &quot;0&quot;: &quot;Jo&quot;, &quot;3&quot;: &quot;Julie&quot;]<br>&gt; <br>&gt; let namesInfo2 = names.map([&quot;6&quot;:&quot;Jim&quot;]) { [&quot;\($0)&quot;: $1] }<br>&gt; namesInfo2 // [&quot;2&quot;: &quot;Jake&quot;, &quot;1&quot;: &quot;Jenna&quot;, &quot;0&quot;: &quot;Jo&quot;, &quot;6&quot;: &quot;Jim&quot;, &quot;3&quot;: &quot;Julie&quot;]<br>&gt; <br>&gt; let namesInfo3 = names.map { [$1: ages[$0]] }<br>&gt; namesInfo3 // [&quot;Jenna&quot;: 20, &quot;Jo&quot;: 32, &quot;Jake&quot;: 46, &quot;Julie&quot;: 39]<br>&gt; <br>&gt; Designer . Developer .  Nerd <br>&gt; Jo Albright<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 10, 2016, at 4:25 PM, Loïc Lecrenier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think this is O(n^2) though, so it’s not really usable.<br>&gt;&gt; (It is destroying and copying the dictionary each time)<br>&gt;&gt; <br>&gt;&gt; There really isn’t anything like map for dictionaries. <br>&gt;&gt; I am not convinced we should add it to the standard library though.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 10, 2016, at 10:19 PM, Ian Ynda-Hummel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this probably wants to be a `reduce`. Given the above example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, &quot;Kavin&quot;].enumerate().reduce([Int: String]()) { (var dictionary, data) in<br>&gt;&gt;&gt;        dictionary[data.index] = data.element<br>&gt;&gt;&gt;        return dictionary<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Which means you create an immutable dictionary with `let`. This could probably look nicer, but I think it illustrates the idea, at least.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Ian<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sun, Jan 10, 2016 at 2:46 PM Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; There is no equivalent to something like <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; array.zipWithIndex.toMap (or in this case array.zipWithIndex.toDictionary // where zipWithIndex creates tuples with the index - a specialized case of zip for Arrays with indexes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 2016-01-11, at 2:41:59, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or an enumeration followed by a forEach.<br>&gt;&gt;&gt;&gt; [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, Kavin&quot;].enumerate().forEach {<br>&gt;&gt;&gt;&gt;    dic[$0] = $1<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; That said, it requires creating a dictionary var first, not a let. If there was an initialiser for Dictionary which took an Array or EnumerateSequence, that might be useful. I&#39;m not sure how I&#39;d attempt to write such an initialiser though.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sun, Jan 10, 2016 at 7:08 PM, Donnacha Oisín Kidney &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; I think that use of map is generally discouraged. forEach would probably be more explicit, or a for-loop.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 10 Jan 2016, at 18:58, 肇鑫 via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You can use dictionary in a map. You just ignore the return value of the map.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; var dic = [Int:String]()<br>&gt;&gt;&gt;&gt;&gt; var index = 0<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, &quot;Kavin&quot;].map {<br>&gt;&gt;&gt;&gt;&gt;    dic.updateValue($0, forKey: index)<br>&gt;&gt;&gt;&gt;&gt;    index += 1<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; print(dic) // [2: &quot;Amy&quot;, 0: &quot;John&quot;, 1: &quot;Mike&quot;, 3: &quot;Kavin&quot;]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; zhaoxin<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mon, Jan 11, 2016 at 1:50 AM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hi All.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I find that instead of using map() on arrays, I more often use an operation that returns a dictionary from an array. A common case is fetching an array of data, then creating a local cache of it indexed by ID.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is there a name for this operation? Is this something that others would like to see added to the standard library?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Kenny<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Owen Zhao<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>map-like operation that returns a dictionary</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 12, 2016 at 07:00:00pm</p></header><div class="content"><p>struct Person {<br>    var id: Int<br>    var name: String<br>}<br>let tom   = Person(id: 1, name: &quot;Tom&quot;)<br>let dick  = Person(id: 2, name: &quot;Dick&quot;)<br>let harry = Person(id: 3, name: &quot;Harry&quot;)<br>let people = [tom, dick, harry]<br></p><p>extension SequenceType {<br>    <br>    func toDict&lt;Key: Hashable&gt;(@noescape withKey extractKey: Self.Generator.Element -&gt; Key) <br>	-&gt; [Key:Self.Generator.Element]<br>    {<br>        return toDict { element in (extractKey(element), element) }<br>    }<br>    <br>    func toDict&lt;Key: Hashable, Value&gt;(@noescape mapping: Self.Generator.Element -&gt; (Key, Value))<br>        -&gt; [Key:Value]<br>    {<br>        var result: [Key:Value] = [:]<br>        for element in self {<br>            let (key, value) = mapping(element)<br>            result.updateValue(value, forKey: key)<br>        }<br>        return result<br>    }<br>}<br></p><p>let cache = people.toDict { $0.id }<br>cache<br></p><p>I named the method(s) „toDict“ instead of „map“ because map normally returns a collection which is either the same as the receiver or a simple one.<br>The second version is more general and allows to do things like<br></p><p>let dict = [&quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;].enumerate().toDict { (index, value) in (index + 1, value) }<br></p><p><br>-Thorsten<br></p><p><br>&gt; Am 11.01.2016 um 17:56 schrieb Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I would like to keep this lightweight for the consumer, so you could write:<br>&gt; <br>&gt; let people :[Person] = fetchPeople()<br>&gt; let cache :[Int:Person] = people.map {return $0.id}<br>&gt; <br>&gt; -Kenny<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 10, 2016, at 2:24 PM, Jo Albright via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Possible solution to do what you are wanting. <br>&gt;&gt; <br>&gt;&gt; extension Array {<br>&gt;&gt; <br>&gt;&gt;    func map&lt;T&gt;(var d: [String:T] = [:], @noescape transform: (Int,Array.Generator.Element) throws -&gt; [String:T]) rethrows -&gt; [String:T] {<br>&gt;&gt; <br>&gt;&gt;        for (i,item) in self.enumerate() {<br>&gt;&gt; <br>&gt;&gt;            try d += transform(i,item)<br>&gt;&gt; <br>&gt;&gt;        }<br>&gt;&gt; <br>&gt;&gt;        return d<br>&gt;&gt; <br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func += &lt;T&gt;(inout lhs: [String:T], rhs: [String:T]) -&gt; [String:T] {<br>&gt;&gt; <br>&gt;&gt;    for (k,v) in rhs { lhs[k] = v }; return lhs<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; let names = [&quot;Jo&quot;,&quot;Jenna&quot;,&quot;Jake&quot;,&quot;Julie&quot;]<br>&gt;&gt; let ages = [32,20,46,39]<br>&gt;&gt; <br>&gt;&gt; let namesInfo1 = names.map { [&quot;\($0)&quot;: $1] }<br>&gt;&gt; namesInfo1 // [&quot;2&quot;: &quot;Jake&quot;, &quot;1&quot;: &quot;Jenna&quot;, &quot;0&quot;: &quot;Jo&quot;, &quot;3&quot;: &quot;Julie&quot;]<br>&gt;&gt; <br>&gt;&gt; let namesInfo2 = names.map([&quot;6&quot;:&quot;Jim&quot;]) { [&quot;\($0)&quot;: $1] }<br>&gt;&gt; namesInfo2 // [&quot;2&quot;: &quot;Jake&quot;, &quot;1&quot;: &quot;Jenna&quot;, &quot;0&quot;: &quot;Jo&quot;, &quot;6&quot;: &quot;Jim&quot;, &quot;3&quot;: &quot;Julie&quot;]<br>&gt;&gt; <br>&gt;&gt; let namesInfo3 = names.map { [$1: ages[$0]] }<br>&gt;&gt; namesInfo3 // [&quot;Jenna&quot;: 20, &quot;Jo&quot;: 32, &quot;Jake&quot;: 46, &quot;Julie&quot;: 39]<br>&gt;&gt; <br>&gt;&gt; Designer . Developer .  Nerd <br>&gt;&gt; Jo Albright<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 10, 2016, at 4:25 PM, Loïc Lecrenier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this is O(n^2) though, so it’s not really usable.<br>&gt;&gt;&gt; (It is destroying and copying the dictionary each time)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There really isn’t anything like map for dictionaries. <br>&gt;&gt;&gt; I am not convinced we should add it to the standard library though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 10, 2016, at 10:19 PM, Ian Ynda-Hummel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think this probably wants to be a `reduce`. Given the above example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, &quot;Kavin&quot;].enumerate().reduce([Int: String]()) { (var dictionary, data) in<br>&gt;&gt;&gt;&gt;       dictionary[data.index] = data.element<br>&gt;&gt;&gt;&gt;       return dictionary<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Which means you create an immutable dictionary with `let`. This could probably look nicer, but I think it illustrates the idea, at least.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Ian<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sun, Jan 10, 2016 at 2:46 PM Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; There is no equivalent to something like <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; array.zipWithIndex.toMap (or in this case array.zipWithIndex.toDictionary // where zipWithIndex creates tuples with the index - a specialized case of zip for Arrays with indexes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 2016-01-11, at 2:41:59, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Or an enumeration followed by a forEach.<br>&gt;&gt;&gt;&gt;&gt; [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, Kavin&quot;].enumerate().forEach {<br>&gt;&gt;&gt;&gt;&gt;   dic[$0] = $1<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; That said, it requires creating a dictionary var first, not a let. If there was an initialiser for Dictionary which took an Array or EnumerateSequence, that might be useful. I&#39;m not sure how I&#39;d attempt to write such an initialiser though.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sun, Jan 10, 2016 at 7:08 PM, Donnacha Oisín Kidney &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I think that use of map is generally discouraged. forEach would probably be more explicit, or a for-loop.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 10 Jan 2016, at 18:58, 肇鑫 via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You can use dictionary in a map. You just ignore the return value of the map.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; var dic = [Int:String]()<br>&gt;&gt;&gt;&gt;&gt;&gt; var index = 0<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, &quot;Kavin&quot;].map {<br>&gt;&gt;&gt;&gt;&gt;&gt;   dic.updateValue($0, forKey: index)<br>&gt;&gt;&gt;&gt;&gt;&gt;   index += 1<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; print(dic) // [2: &quot;Amy&quot;, 0: &quot;John&quot;, 1: &quot;Mike&quot;, 3: &quot;Kavin&quot;]<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; zhaoxin<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Jan 11, 2016 at 1:50 AM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Hi All.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I find that instead of using map() on arrays, I more often use an operation that returns a dictionary from an array. A common case is fetching an array of data, then creating a local cache of it indexed by ID.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Is there a name for this operation? Is this something that others would like to see added to the standard library?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Kenny<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Owen Zhao<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/66a907d3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>map-like operation that returns a dictionary</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 13, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; <br>&gt; <br>&gt; I named the method(s) „toDict“ instead of „map“ because map normally returns a collection which is either the same as the receiver or a simple one.<br>&gt; The second version is more general and allows to do things like<br>&gt; <br>&gt; let dict = [&quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;].enumerate().toDict { (index, value) in (index + 1, value) }<br>&gt; <br></p><p>Map would probably be a more correct mathematically speaking — but it would be inconsistent with the naming convention already chosen for Swift.  So for Swift - toDict (or toDictionary) would be the best choice.<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/de61d75e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>map-like operation that returns a dictionary</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>January 13, 2016 at 08:00:00am</p></header><div class="content"><p>This solution looks great! How do you feel about “mapDict”?<br></p><p>-Kenny<br></p><p><br>&gt; On Jan 12, 2016, at 10:28 AM, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I named the method(s) „toDict“ instead of „map“ because map normally returns a collection which is either the same as the receiver or a simple one.<br>&gt;&gt; The second version is more general and allows to do things like<br>&gt;&gt; <br>&gt;&gt; let dict = [&quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;].enumerate().toDict { (index, value) in (index + 1, value) }<br>&gt;&gt; <br>&gt; <br>&gt; Map would probably be a more correct mathematically speaking — but it would be inconsistent with the naming convention already chosen for Swift.  So for Swift - toDict (or toDictionary) would be the best choice.<br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>map-like operation that returns a dictionary</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 13, 2016 at 11:00:00am</p></header><div class="content"><p>When we drew these up in Swiftz we called them `mapAssociate` and `mapAssociateLabel` after the combinators &quot;associate&quot; and &quot;label&quot; in other languages <br></p><p>https://github.com/typelift/Swiftz/blob/master/Swiftz/ArrayExt.swift#L491-L504<br></p><p>~Robert Widmann<br></p><p>2016/01/13 11:13、Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; This solution looks great! How do you feel about “mapDict”?<br>&gt; <br>&gt; -Kenny<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jan 12, 2016, at 10:28 AM, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I named the method(s) „toDict“ instead of „map“ because map normally returns a collection which is either the same as the receiver or a simple one.<br>&gt;&gt;&gt; The second version is more general and allows to do things like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let dict = [&quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;].enumerate().toDict { (index, value) in (index + 1, value) }<br>&gt;&gt; <br>&gt;&gt; Map would probably be a more correct mathematically speaking — but it would be inconsistent with the naming convention already chosen for Swift.  So for Swift - toDict (or toDictionary) would be the best choice.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>map-like operation that returns a dictionary</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 13, 2016 at 06:00:00pm</p></header><div class="content"><p>I&#39;d prefer &quot;mapToDict&quot; otherwise it sounds like a dictionary gets mapped, at least for me.<br></p><p>-Thorsten<br></p><p>&gt; Am 13.01.2016 um 17:13 schrieb Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; This solution looks great! How do you feel about “mapDict”?<br>&gt; <br>&gt; -Kenny<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jan 12, 2016, at 10:28 AM, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I named the method(s) „toDict“ instead of „map“ because map normally returns a collection which is either the same as the receiver or a simple one.<br>&gt;&gt;&gt; The second version is more general and allows to do things like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let dict = [&quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;].enumerate().toDict { (index, value) in (index + 1, value) }<br>&gt;&gt; <br>&gt;&gt; Map would probably be a more correct mathematically speaking — but it would be inconsistent with the naming convention already chosen for Swift.  So for Swift - toDict (or toDictionary) would be the best choice.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>map-like operation that returns a dictionary</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>January 13, 2016 at 06:00:00pm</p></header><div class="content"><p>Doesn’t Swift prefer initializers?<br></p><p>So let’s build a Dictionary initializer that eats any sequence of (key, value) pairs:<br></p><p>extension Dictionary {<br>    init&lt;S: SequenceType where S.Generator.Element == (Key, Value)&gt;(keyValueSequence s: S) {<br>        self.init()<br>        for (key, value) in s {<br>            self[key] = value<br>        }<br>    }<br>}<br></p><p>do {<br>    // From array of (key, value) pairs<br>    let input = [(&quot;foo&quot;, 1), (&quot;bar&quot;, 2)]<br>    let d = Dictionary(keyValueSequence: input)<br>    print(d)<br>}<br>do {<br>    // From another dictionary<br>    let input = [1: &quot;foo&quot;, 2: &quot;bar&quot;]<br>    let d = Dictionary(keyValueSequence: input)<br>    print(d)<br>}<br>do {<br>    // Reverse key and values<br>    let input = [1: &quot;foo&quot;, 2: &quot;bar&quot;]<br>    let d = Dictionary(keyValueSequence: input.map { ($1, $0) })<br>    print(d)<br>}<br></p><p>Gwendal<br></p><p>&gt; Le 13 janv. 2016 à 18:41, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I&#39;d prefer &quot;mapToDict&quot; otherwise it sounds like a dictionary gets mapped, at least for me.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt;&gt; Am 13.01.2016 um 17:13 schrieb Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; This solution looks great! How do you feel about “mapDict”?<br>&gt;&gt; <br>&gt;&gt; -Kenny<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 12, 2016, at 10:28 AM, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I named the method(s) „toDict“ instead of „map“ because map normally returns a collection which is either the same as the receiver or a simple one.<br>&gt;&gt;&gt;&gt; The second version is more general and allows to do things like<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let dict = [&quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;].enumerate().toDict { (index, value) in (index + 1, value) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Map would probably be a more correct mathematically speaking — but it would be inconsistent with the naming convention already chosen for Swift.  So for Swift - toDict (or toDictionary) would be the best choice.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/0cce2bf1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>Proposal: Add a sequence-based initializer to Dictionary</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>January 14, 2016 at 06:00:00pm</p></header><div class="content"><p>A brief draft is below... I had mostly written this up before I saw the thread and Gwendal&#39;s similar contribution -- happy to hear feedback and fold in comments/revisions!<br></p><p>Nate<br></p><p><br>---<br></p><p><br>Introduction<br></p><p>The Dictionary type should allow initialization from a sequence of (Key, Value) tuples.<br></p><p>Motivation<br></p><p>Array and Set both have initializers that create a new instance from a sequence of elements. The Array initializer is useful for converting other sequences and collections to the &quot;standard&quot; collection type, but the Set initializer is essential for recovering set operations after performing any functional operations on a set. For example, filtering a set produces a collection without any kind of set operations available:<br></p><p>let numberSet = Set(1 ... 100)<br>let fivesOnly = numberSet.lazy.filter { $0 % 5 == 0 }<br></p><p>&quot;fivesOnly&quot; is a LazyFilterCollection&lt;Set&lt;Int&gt;&gt; instead of a Set -- sending that back through the Set sequence initializer restores the expected methods:<br></p><p>let fivesOnlySet = Set(numberSet.lazy.filter { $0 % 5 == 0 })<br>fivesOnlySet.isSubsetOf(numberSet) // true<br></p><p>Dictionary, on the other hand, has no such initializer, so a similar operation leaves no room except for building a mutable Dictionary via iteration or functional methods with dubious performance. These techniques also don&#39;t support type inference from the source sequence, increasing verbosity:<br></p><p>var viaIteration: [String: Int] = [:]<br>for (key, value) in evenOnly {<br>    viaIteration[key] = value<br>}<br></p><p>let viaFunction: [String: Int] = evenOnly.reduce([:]) { (cumulative, keyValue) in<br>    var mutableDictionary = cumulative<br>    mutableDictionary[keyValue.0] = keyValue.1<br>    return mutableDictionary<br>}<br></p><p>Proposed solution<br></p><p>The proposed solution would add an initializer to Dictionary that accepts any sequence of (Key, Value) tuple pairs, matching the Dictionary&#39;s element type when treated as a sequence:<br></p><p>init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_ sequence: S)<br></p><p>Instead of the techniques for recovering a Dictionary shown above, the proposed initializer would allow a much cleaner syntax to be written:<br></p><p>let viaProposed = Dictionary(evenOnly)<br></p><p>Moreover, this new initializer would allow for some convenient uses that aren&#39;t currently possible.<br></p><p>👍🏼 Initializing from an array of tuples: <br></p><p>let dictFromArray = Dictionary([(&quot;a&quot;, 1), (&quot;b&quot;, 2), (&quot;c&quot;, 3), (&quot;d&quot;, 4)])<br></p><p>👏🏼 Initializing from a DictionaryLiteral (the type, not an actual literal): <br></p><p>let literal: DictionaryLiteral = [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4]<br>let dictFromDL = Dictionary(literal)<br></p><p>🎉 Initializing from a pair of zipped sequences (examples abound): <br></p><p>let letters = &quot;abcdefghij&quot;.characters.lazy.map { String($0) }<br>let dictFromZip = Dictionary(zip(letters, 1...10))<br>// [&quot;b&quot;: 2, &quot;a&quot;: 1, &quot;i&quot;: 9, &quot;j&quot;: 10, &quot;c&quot;: 3, &quot;e&quot;: 5, &quot;f&quot;: 6, &quot;g&quot;: 7, &quot;d&quot;: 4, &quot;h&quot;: 8]<br></p><p>Potential pitfalls<br></p><p>One caveat is that the new initializer doesn&#39;t prevent using a sequence with multiple identical keys. In such a case, the last key/value would &quot;win&quot; and exist in the dictionary. Such an initialization is a compile-time error with a dictionary literal, but succeeds under the new initializer:<br></p><p>let _ = [&quot;z&quot;: 1, &quot;z&quot;: 2, &quot;z&quot;: 3, &quot;z&quot;: 4]<br>// fatal error: Dictionary literal contains duplicate keys<br>Dictionary([(&quot;z&quot;, 1), (&quot;z&quot;, 2), (&quot;z&quot;, 3), (&quot;z&quot;, 4)])<br>// [&quot;z&quot;: 4]<br></p><p>This behavior is particularly troublesome when used in conjunction with a mapping operation that modifies a dictionary&#39;s keys, since dictionaries have no particular guaranteed order:<br></p><p>let overlapping = Dictionary(dictFromArray.lazy.map { (_, value) in (&quot;z&quot;, value) })<br>// [&quot;z&quot;: ???]<br></p><p>While a pitfall, this behavior is less a symptom of the proposed API and more an inherent problem with recovering a dictionary after modifying its keys. The current ways of rebuilding a dictionary (as shown above) are just as susceptible to silently dropping values. Moreover, the sequence-based initializer for Set exhibits the same behavior, though slightly less problematic in most cases:<br></p><p>let dividedNumbers = Set(numberSet.map { $0 / 20 })<br>// {4, 5, 2, 0, 1, 3}<br></p><p>Given the potential lossiness of the initializer, should it use a parameter name for the sequence? I would suggest not, to match the syntax of Array.init(_:) and Set.init(_:), but a parameter like &quot;collapsingKeys&quot; would make the risk clear to users.<br></p><p>Detailed design<br></p><p>The implementation is simple enough to show in the proposal:<br></p><p>extension Dictionary {<br>    /// Creates a dictionary with the keys and values in the given sequence.<br>    init&lt;S: SequenceType where S.Generator.Element == Generator.Element&gt;(_ sequence: S) {<br>        self.init()<br>        for (key, value) in sequence {<br>            updateValue(value, forKey: key)<br>        }<br>    }<br>}<br></p><p>(As part of the standard library, this could use the nativeUpdateValue method.)<br></p><p>Impact on existing code<br></p><p>As a new API, this will have no impact on existing code.<br></p><p>Alternatives considered<br></p><p>As suggested in the thread below, a method could be added to SequenceType that would build a dictionary. This approach seems less of a piece with the rest of the standard library, and overly verbose when used with a Dictionary that is only passing through filtering or mapping operations. I don&#39;t think the current protocol extension system could handle a passthrough case (i.e., something like &quot;extension SequenceType where Generator.Element == (Key, Value)&quot;).<br></p><p>Alternately, the status quo could be maintained. Which would be sad.<br></p><p><br></p><p><br>&gt; On Jan 13, 2016, at 11:55 AM, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Doesn’t Swift prefer initializers?<br>&gt; <br>&gt; So let’s build a Dictionary initializer that eats any sequence of (key, value) pairs:<br>&gt; <br>&gt; extension Dictionary {<br>&gt;     init&lt;S: SequenceType where S.Generator.Element == (Key, Value)&gt;(keyValueSequence s: S) {<br>&gt;         self.init()<br>&gt;         for (key, value) in s {<br>&gt;             self[key] = value<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; do {<br>&gt;     // From array of (key, value) pairs<br>&gt;     let input = [(&quot;foo&quot;, 1), (&quot;bar&quot;, 2)]<br>&gt;     let d = Dictionary(keyValueSequence: input)<br>&gt;     print(d)<br>&gt; }<br>&gt; do {<br>&gt;     // From another dictionary<br>&gt;     let input = [1: &quot;foo&quot;, 2: &quot;bar&quot;]<br>&gt;     let d = Dictionary(keyValueSequence: input)<br>&gt;     print(d)<br>&gt; }<br>&gt; do {<br>&gt;     // Reverse key and values<br>&gt;     let input = [1: &quot;foo&quot;, 2: &quot;bar&quot;]<br>&gt;     let d = Dictionary(keyValueSequence: input.map { ($1, $0) })<br>&gt;     print(d)<br>&gt; }<br>&gt; <br>&gt; Gwendal<br>&gt; <br>&gt;&gt; Le 13 janv. 2016 à 18:41, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I&#39;d prefer &quot;mapToDict&quot; otherwise it sounds like a dictionary gets mapped, at least for me.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt;&gt; Am 13.01.2016 um 17:13 schrieb Kenny Leung via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This solution looks great! How do you feel about “mapDict”?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kenny<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 12, 2016, at 10:28 AM, Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I named the method(s) „toDict“ instead of „map“ because map normally returns a collection which is either the same as the receiver or a simple one.<br>&gt;&gt;&gt;&gt;&gt; The second version is more general and allows to do things like<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let dict = [&quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;].enumerate().toDict { (index, value) in (index + 1, value) }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Map would probably be a more correct mathematically speaking — but it would be inconsistent with the naming convention already chosen for Swift.  So for Swift - toDict (or toDictionary) would be the best choice.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/3586f816/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Add a sequence-based initializer to Dictionary</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 14, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; One caveat is that the new initializer doesn&#39;t prevent using a sequence with multiple identical keys. In such a case, the last key/value would &quot;win&quot; and exist in the dictionary.<br></p><p>Another alternative would be to make the initializer failable and have it fail if a key is duplicated.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Proposal: Add a sequence-based initializer to Dictionary</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>January 15, 2016 at 09:00:00am</p></header><div class="content"><p>It may sound counter-intuitive to have such an initialiser failable for many users. I *think* I would prefer it to silently use the last key.<br></p><p>&gt; On 15 Jan 2016, at 01:31, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; One caveat is that the new initializer doesn&#39;t prevent using a sequence with multiple identical keys. In such a case, the last key/value would &quot;win&quot; and exist in the dictionary.<br>&gt; <br>&gt; Another alternative would be to make the initializer failable and have it fail if a key is duplicated.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Proposal: Add a sequence-based initializer to Dictionary</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>January 15, 2016 at 10:00:00am</p></header><div class="content"><p>Agreed, for three reasons:<br></p><p>1. A failable initializer would require the user to validate the input sequence, which is painful, and inefficient. Do you see yourself checking if `Set(sequence.map { $0.0 }).count == 1` before creating the dictionary ? If user cares about unique keys, it’s much easier to post-check for `dic.count == input.count`.<br></p><p>2. We can assume that users will be well aware that a dictionary builder from a sequence will lose information for duplicated keys, just as users are already well aware that an inversed dictionary (key &lt;-&gt; values) loses information for duplicated values. A failable initializer would actually *surprise* most users.<br></p><p>3. A clear rule on which value is used in case of duplicated key (such as: the last one is used) allows users to opt-in for explicit choice of the first one by reversing the sequence.<br></p><p>Gwendal<br></p><p>&gt; Le 15 janv. 2016 à 09:45, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; It may sound counter-intuitive to have such an initialiser failable for many users. I *think* I would prefer it to silently use the last key.<br>&gt; <br>&gt;&gt; On 15 Jan 2016, at 01:31, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; One caveat is that the new initializer doesn&#39;t prevent using a sequence with multiple identical keys. In such a case, the last key/value would &quot;win&quot; and exist in the dictionary.<br>&gt;&gt; <br>&gt;&gt; Another alternative would be to make the initializer failable and have it fail if a key is duplicated.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>map-like operation that returns a dictionary</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>January 13, 2016 at 08:00:00am</p></header><div class="content"><p>Hmm…<br></p><p>Now that I look seriously at it, I have no idea how the first function works! Back to the books…<br></p><p>-Kenny<br></p><p><br>&gt; On Jan 12, 2016, at 10:11 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; struct Person {<br>&gt;     var id: Int<br>&gt;     var name: String<br>&gt; }<br>&gt; let tom   = Person(id: 1, name: &quot;Tom&quot;)<br>&gt; let dick  = Person(id: 2, name: &quot;Dick&quot;)<br>&gt; let harry = Person(id: 3, name: &quot;Harry&quot;)<br>&gt; let people = [tom, dick, harry]<br>&gt; <br>&gt; extension SequenceType {<br>&gt;     <br>&gt;     func toDict&lt;Key: Hashable&gt;(@noescape withKey extractKey: Self.Generator.Element -&gt; Key) <br>&gt; 	-&gt; [Key:Self.Generator.Element]<br>&gt;     {<br>&gt;         return toDict { element in (extractKey(element), element) }<br>&gt;     }<br>&gt;     <br>&gt;     func toDict&lt;Key: Hashable, Value&gt;(@noescape mapping: Self.Generator.Element -&gt; (Key, Value))<br>&gt;         -&gt; [Key:Value]<br>&gt;     {<br>&gt;         var result: [Key:Value] = [:]<br>&gt;         for element in self {<br>&gt;             let (key, value) = mapping(element)<br>&gt;             result.updateValue(value, forKey: key)<br>&gt;         }<br>&gt;         return result<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let cache = people.toDict { $0.id }<br>&gt; cache<br>&gt; <br>&gt; I named the method(s) „toDict“ instead of „map“ because map normally returns a collection which is either the same as the receiver or a simple one.<br>&gt; The second version is more general and allows to do things like<br>&gt; <br>&gt; let dict = [&quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;].enumerate().toDict { (index, value) in (index + 1, value) }<br>&gt; <br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; Am 11.01.2016 um 17:56 schrieb Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; I would like to keep this lightweight for the consumer, so you could write:<br>&gt;&gt; <br>&gt;&gt; let people :[Person] = fetchPeople()<br>&gt;&gt; let cache :[Int:Person] = people.map {return $0.id}<br>&gt;&gt; <br>&gt;&gt; -Kenny<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 10, 2016, at 2:24 PM, Jo Albright via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Possible solution to do what you are wanting. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Array {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    func map&lt;T&gt;(var d: [String:T] = [:], @noescape transform: (Int,Array.Generator.Element) throws -&gt; [String:T]) rethrows -&gt; [String:T] {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        for (i,item) in self.enumerate() {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            try d += transform(i,item)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        return d<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func += &lt;T&gt;(inout lhs: [String:T], rhs: [String:T]) -&gt; [String:T] {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    for (k,v) in rhs { lhs[k] = v }; return lhs<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let names = [&quot;Jo&quot;,&quot;Jenna&quot;,&quot;Jake&quot;,&quot;Julie&quot;]<br>&gt;&gt;&gt; let ages = [32,20,46,39]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let namesInfo1 = names.map { [&quot;\($0)&quot;: $1] }<br>&gt;&gt;&gt; namesInfo1 // [&quot;2&quot;: &quot;Jake&quot;, &quot;1&quot;: &quot;Jenna&quot;, &quot;0&quot;: &quot;Jo&quot;, &quot;3&quot;: &quot;Julie&quot;]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let namesInfo2 = names.map([&quot;6&quot;:&quot;Jim&quot;]) { [&quot;\($0)&quot;: $1] }<br>&gt;&gt;&gt; namesInfo2 // [&quot;2&quot;: &quot;Jake&quot;, &quot;1&quot;: &quot;Jenna&quot;, &quot;0&quot;: &quot;Jo&quot;, &quot;6&quot;: &quot;Jim&quot;, &quot;3&quot;: &quot;Julie&quot;]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let namesInfo3 = names.map { [$1: ages[$0]] }<br>&gt;&gt;&gt; namesInfo3 // [&quot;Jenna&quot;: 20, &quot;Jo&quot;: 32, &quot;Jake&quot;: 46, &quot;Julie&quot;: 39]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Designer . Developer .  Nerd <br>&gt;&gt;&gt; Jo Albright<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 10, 2016, at 4:25 PM, Loïc Lecrenier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think this is O(n^2) though, so it’s not really usable.<br>&gt;&gt;&gt;&gt; (It is destroying and copying the dictionary each time)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There really isn’t anything like map for dictionaries. <br>&gt;&gt;&gt;&gt; I am not convinced we should add it to the standard library though.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 10, 2016, at 10:19 PM, Ian Ynda-Hummel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think this probably wants to be a `reduce`. Given the above example:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, &quot;Kavin&quot;].enumerate().reduce([Int: String]()) { (var dictionary, data) in<br>&gt;&gt;&gt;&gt;&gt;       dictionary[data.index] = data.element<br>&gt;&gt;&gt;&gt;&gt;       return dictionary<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Which means you create an immutable dictionary with `let`. This could probably look nicer, but I think it illustrates the idea, at least.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Ian<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sun, Jan 10, 2016 at 2:46 PM Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; There is no equivalent to something like <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; array.zipWithIndex.toMap (or in this case array.zipWithIndex.toDictionary // where zipWithIndex creates tuples with the index - a specialized case of zip for Arrays with indexes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 2016-01-11, at 2:41:59, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Or an enumeration followed by a forEach.<br>&gt;&gt;&gt;&gt;&gt;&gt; [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, Kavin&quot;].enumerate().forEach {<br>&gt;&gt;&gt;&gt;&gt;&gt;   dic[$0] = $1<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; That said, it requires creating a dictionary var first, not a let. If there was an initialiser for Dictionary which took an Array or EnumerateSequence, that might be useful. I&#39;m not sure how I&#39;d attempt to write such an initialiser though.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sun, Jan 10, 2016 at 7:08 PM, Donnacha Oisín Kidney &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; I think that use of map is generally discouraged. forEach would probably be more explicit, or a for-loop.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 10 Jan 2016, at 18:58, 肇鑫 via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; You can use dictionary in a map. You just ignore the return value of the map.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var dic = [Int:String]()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var index = 0<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; [&quot;John&quot;, &quot;Mike&quot;, &quot;Amy&quot;, &quot;Kavin&quot;].map {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   dic.updateValue($0, forKey: index)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   index += 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; print(dic) // [2: &quot;Amy&quot;, 0: &quot;John&quot;, 1: &quot;Mike&quot;, 3: &quot;Kavin&quot;]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; zhaoxin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Jan 11, 2016 at 1:50 AM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi All.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I find that instead of using map() on arrays, I more often use an operation that returns a dictionary from an array. A common case is fetching an array of data, then creating a local cache of it indexed by ID.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is there a name for this operation? Is this something that others would like to see added to the standard library?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kenny<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Owen Zhao<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>map-like operation that returns a dictionary</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 10, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; If there was an initialiser for Dictionary which took an Array or EnumerateSequence, that might be useful. I&#39;m not sure how I&#39;d attempt to write such an initialiser though.<br></p><p>Well, we can begin with a simple &quot;initialize from key-value tuple sequence&quot; initializer:<br></p><p>	init?&lt;Sequence: SequenceType where Sequence.Generator.Element == Element&gt;(_ seq: Sequence) {<br>		self.init()<br>		for (key, value) in seq {<br>			let oldValue = updateValue(value, forKey: key)<br>			<br>			// Did this key already have a value?<br>			if oldValue != nil {<br>				return nil<br>			}<br>		}<br>	}<br></p><p>Now you can say things like:<br></p><p>	Dictionary(array.map { ($0.identifier, $0) })<br></p><p>If you want to special-case &quot;invert a collection into an element-to-index dictionary&quot;, you could add something like this:<br></p><p>	init?&lt;Collection: CollectionType where Collection.Generator.Element == Key, Collection.Index == Value&gt;(ofIndices collection: Collection) {<br>		self.init(zip(collection, collection.indices))<br>	}<br></p><p>Unfortunately, this specific implementation emits a bizarre error on the `collection.indices` expression, complaining that &quot;value of type &#39;Collection&#39; has no member &#39;IntegerLiteralType&#39;&quot;; I must be doing something wrong. But a properly working version of that would allow you to say:<br></p><p>	Dictionary(ofIndices: array)<br></p><p>These two initializers might be useful enough to be worth including in the standard library.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
