<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Revisiting package conflicts</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 31, 2016 at 12:00:00pm</p></header><div class="content"><p>I&#39;m trying to clean up a few things while my kids are on Spring Break and decided to rewrite my package<br>conflict proposal, which follows.<br></p><p>This updated version does not require any language change (although one could be adopted later), does not<br>require any package change, and only affects the target directories and module names.<br></p><p>I&#39;d appreciate any feedback you could give.<br></p><p>Thanks, -- Erica<br></p><p><br>Disambiguating SwiftPM Naming Conflicts<br></p><p>Proposal: TBD<br>Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://gist.github.com/erica/c6553a5f6f35e7462074#introduction&gt;Introduction<br></p><p>This proposal creates a way to resolve SwiftPM module conflicts. It introduces namespacing to handle the rare case of name overlaps without requiring a central package registry.<br></p><p>This proposal was discussed on the Swift-Dev and Swift-Build-Dev lists in the &quot;Right List? &lt;http://article.gmane.org/gmane.comp.lang.swift.devel/1149&gt;&quot; thread.<br></p><p> &lt;https://gist.github.com/erica/c6553a5f6f35e7462074#motivation&gt;Motivation<br></p><p>Swift offers a built in mechanism for distinguishing symbol conflicts. When working with NSView, using Swift.printoutputs text to the console or stream. NSView&#39;s  print creates a print job. Swift does not yet offer a solution for conflicting module names.<br></p><p>Like many other Swift developers, I have spent considerable time building utility packages. Mine use obvious names like SwiftString and SwiftCollections because simple clear naming is a hallmark of Swift design. At the same time, this style introduces the possibility of package name conflicts. <br></p><p>import SwiftString // mine<br>import SwiftString // someone else&#39;s. oops.<br>Two SwiftString packages cannot be used simultaneously without some form of namespace resolution. Moving back to Cocoa-style namespacing, for example ESSwiftString, feels ugly and antithetical to Swift. Swift should encourage recognizable, easy-to-understand module names. This proposal addresses this rare but possible conflict.<br></p><p>Under the current system, same-named modules:<br></p><p>import PackageDescription<br>let package = Package (<br>    name: &quot;myutility&quot;,<br>        dependencies: [<br>        .Package(url: &quot;https://github.com/erica/SwiftString.git&quot;,<br>                 majorVersion: 1),<br>        .Package(url: &quot;https://github.com/nudas/SwiftString.git&quot;,<br>                 majorVersion: 1),<br>        ]<br></p><p>)<br>produce the following error:<br></p><p>% swift build<br>Cloning Packages/SwiftString<br>Using version 1.0.5 of package SwiftString<br>Cloning Packages/SwiftString<br>/usr/bin/git clone --recursive --depth 10 https://github.com/nudas/SwiftString.git /home/erica/Work/test/Packages/SwiftString<br>fatal: destination path &#39;/home/erica/Work/test/Packages/SwiftString&#39; already exists and is not an empty directory.<br></p><p>swift-build: Failed to clone https://github.com/nudas/SwiftString.git to /home/erica/Work/test/Packages/SwiftString<br>Makefile:3: recipe for target &#39;all&#39; failed<br>make: *** [all] Error 1<br> &lt;https://gist.github.com/erica/c6553a5f6f35e7462074#detail-design&gt;Detail Design<br></p><p>Under this proposal, the Swift Package manager uses reverse domain naming to differentiate otherwise identically-named items. The two conflicting packages in the following example:<br></p><p>import PackageDescription<br>let package = Package (<br>    name: &quot;MyUtility&quot;,<br>    dependencies: [<br>    .Package(url: &quot;https://github.com/erica/SwiftString.git&quot;,<br>                 majorVersion: 1),<br>    .Package(url: &quot;https://github.com/bob/SwiftString.git&quot;,<br>                 majorVersion: 1),<br>    ]<br>)<br>unpack to Packages/com.github.erica.SwiftString and Packages/com.github.bob.SwiftString rather than Packages/SwiftString.<br></p><p>These can then be imported using the full RDN notation:<br></p><p>import com.github.erica.SwiftString<br>import com.github.bob.SwiftString<br>Reverse domain names<br></p><p>are rarely used outside the import statement and only to distinguish overlapping implementations<br>are relatively short<br>are already well established for Apple app distribution<br>are tied to the hosting repo<br> &lt;https://gist.github.com/erica/c6553a5f6f35e7462074#future-directions&gt;Future Directions<br></p><p>However concise, using reverse domain names bring verbiage to name conflicts. Upon adopting this proposal, I intend following through with language specific proposals that allow either import as or right-to-left namespacing.<br></p><p>A Swift import as statement would allow a developer to rename a module on import:<br></p><p>import com.github.erica.SwiftString as EricaString<br>A right-to-left alternative would require only as much of the reverse domain name prefix as needed to distinguish one implementation from another, for example:<br></p><p>erica.SwiftString.print(x)<br>bob.SwiftString.print(x)<br>although presumably the fully specified RDN prefix could be used as well:<br></p><p>com.github.erica.SwiftString.print(x)<br> &lt;https://gist.github.com/erica/c6553a5f6f35e7462074#acknowledgements&gt;Acknowledgements<br></p><p>Thanks to Joe Groff &lt;https://github.com/jckarter&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;, Max Howell, Daniel Dunbar, Kostiantyn Koval<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160331/253010c8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05540cd6be96706f76aa66a4519f7db9?s=50"></div><header><strong>Revisiting package conflicts</strong> from <string>Ankit Agarwal</string> &lt;ankit at ankit.im&gt;<p>April  1, 2016 at 12:00:00am</p></header><div class="content"><p>I think if swiftpm renames `SwiftString` to `com.github.erica.SwiftString`,<br>any other dependency having either `SwiftString` as dependency will not be<br>able to use `import SwiftString` and thus fail to build.<br></p><p>On Thu, Mar 31, 2016 at 11:54 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt; I&#39;m trying to clean up a few things while my kids are on Spring Break and<br>&gt; decided to rewrite my package<br>&gt; conflict proposal, which follows.<br>&gt;<br>&gt; This updated version does not require any language change (although one<br>&gt; could be adopted later), does not<br>&gt; require any package change, and only affects the target directories and<br>&gt; module names.<br>&gt;<br>&gt; I&#39;d appreciate any feedback you could give.<br>&gt;<br>&gt; Thanks, -- Erica<br>&gt;<br>&gt;<br>&gt; Disambiguating SwiftPM Naming Conflicts<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c6553a5f6f35e7462074#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal creates a way to resolve SwiftPM module conflicts. It<br>&gt; introduces namespacing to handle the rare case of name overlaps without<br>&gt; requiring a central package registry.<br>&gt;<br>&gt; This proposal was discussed on the Swift-Dev and Swift-Build-Dev lists in<br>&gt; the &quot;Right List?<br>&gt; &lt;http://article.gmane.org/gmane.comp.lang.swift.devel/1149&gt;&quot; thread.<br>&gt; &lt;https://gist.github.com/erica/c6553a5f6f35e7462074#motivation&gt;Motivation<br>&gt;<br>&gt; Swift offers a built in mechanism for distinguishing symbol conflicts.<br>&gt; When working with NSView, using Swift.printoutputs text to the console or<br>&gt; stream. NSView&#39;s  print creates a print job. Swift does not yet offer a<br>&gt; solution for conflicting module names.<br>&gt;<br>&gt; Like many other Swift developers, I have spent considerable time building<br>&gt; utility packages. Mine use obvious names like SwiftString and<br>&gt; SwiftCollections because simple clear naming is a hallmark of Swift<br>&gt; design. At the same time, this style introduces the possibility of package<br>&gt; name conflicts.<br>&gt;<br>&gt; import SwiftString // mineimport SwiftString // someone else&#39;s. oops.<br>&gt;<br>&gt; Two SwiftString packages cannot be used simultaneously without some form<br>&gt; of namespace resolution. Moving back to Cocoa-style namespacing, for<br>&gt; example ESSwiftString, feels ugly and antithetical to Swift. Swift should<br>&gt; encourage recognizable, easy-to-understand module names. This proposal<br>&gt; addresses this rare but possible conflict.<br>&gt;<br>&gt; Under the current system, same-named modules:<br>&gt;<br>&gt; import PackageDescription<br>&gt; let package = Package (<br>&gt;     name: &quot;myutility&quot;,<br>&gt;         dependencies: [<br>&gt;         .Package(url: &quot;https://github.com/erica/SwiftString.git&quot;,<br>&gt;                  majorVersion: 1),<br>&gt;         .Package(url: &quot;https://github.com/nudas/SwiftString.git&quot;,<br>&gt;                  majorVersion: 1),<br>&gt;         ]<br>&gt;<br>&gt; )<br>&gt;<br>&gt; produce the following error:<br>&gt;<br>&gt; % swift build<br>&gt; Cloning Packages/SwiftString<br>&gt; Using version 1.0.5 of package SwiftString<br>&gt; Cloning Packages/SwiftString<br>&gt; /usr/bin/git clone --recursive --depth 10 https://github.com/nudas/SwiftString.git /home/erica/Work/test/Packages/SwiftString<br>&gt; fatal: destination path &#39;/home/erica/Work/test/Packages/SwiftString&#39; already exists and is not an empty directory.<br>&gt;<br>&gt; swift-build: Failed to clone https://github.com/nudas/SwiftString.git to /home/erica/Work/test/Packages/SwiftString<br>&gt; Makefile:3: recipe for target &#39;all&#39; failed<br>&gt; make: *** [all] Error 1<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c6553a5f6f35e7462074#detail-design&gt;Detail<br>&gt; Design<br>&gt;<br>&gt; Under this proposal, the Swift Package manager uses reverse domain naming<br>&gt; to differentiate otherwise identically-named items. The two conflicting<br>&gt; packages in the following example:<br>&gt;<br>&gt; import PackageDescriptionlet package = Package (<br>&gt;     name: &quot;MyUtility&quot;,<br>&gt;     dependencies: [<br>&gt;     .Package(url: &quot;https://github.com/erica/SwiftString.git&quot;,<br>&gt;                  majorVersion: 1),<br>&gt;     .Package(url: &quot;https://github.com/bob/SwiftString.git&quot;,<br>&gt;                  majorVersion: 1),<br>&gt;     ]<br>&gt; )<br>&gt;<br>&gt; unpack to Packages/com.github.erica.SwiftString and<br>&gt; Packages/com.github.bob.SwiftString rather than Packages/SwiftString.<br>&gt;<br>&gt; These can then be imported using the full RDN notation:<br>&gt;<br>&gt; import com.github.erica.SwiftString<br>&gt; import com.github.bob.SwiftString<br>&gt;<br>&gt; Reverse domain names<br>&gt;<br>&gt;    - are rarely used outside the import statement and only to distinguish<br>&gt;    overlapping implementations<br>&gt;    - are relatively short<br>&gt;    - are already well established for Apple app distribution<br>&gt;    - are tied to the hosting repo<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c6553a5f6f35e7462074#future-directions&gt;Future<br>&gt; Directions<br>&gt;<br>&gt; However concise, using reverse domain names bring verbiage to name<br>&gt; conflicts. Upon adopting this proposal, I intend following through with<br>&gt; language specific proposals that allow either import as or right-to-left<br>&gt; namespacing.<br>&gt;<br>&gt; A Swift import as statement would allow a developer to rename a module on<br>&gt; import:<br>&gt;<br>&gt; import com.github.erica.SwiftString as EricaString<br>&gt;<br>&gt; A right-to-left alternative would require only as much of the reverse<br>&gt; domain name prefix as needed to distinguish one implementation from<br>&gt; another, for example:<br>&gt;<br>&gt; erica.SwiftString.print(x)<br>&gt; bob.SwiftString.print(x)<br>&gt;<br>&gt; although presumably the fully specified RDN prefix could be used as well:<br>&gt;<br>&gt; com.github.erica.SwiftString.print(x)<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c6553a5f6f35e7462074#acknowledgements&gt;<br>&gt; Acknowledgements<br>&gt; Thanks to Joe Groff &lt;https://github.com/jckarter&gt;, Ankit Aggarwal<br>&gt; &lt;https://github.com/aciidb0mb3r&gt;, Max Howell, Daniel Dunbar, Kostiantyn<br>&gt; Koval<br>&gt;<br></p><p><br></p><p>-- <br>Ankit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160401/46a8c210/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Revisiting package conflicts</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 31, 2016 at 04:00:00pm</p></header><div class="content"><p>*headbang* *headbang* *headbang*<br></p><p>Possible situations:<br></p><p>* One package knows there&#39;s name conflicts, uses full dependency reverse namespacing<br>* Dependent package does not know there&#39;s name conflicts, but it has a dependency listed, so it uses only the nearest/most visible declaration.<br></p><p>Is there a way to resolve using some sort of rule system so that this somehow works? Can I assume that each module is compiled from the bottom to the top of the dependency graph so that the only conflicts ever seen would be higher in the graph where they know a priori that there&#39;s a more complicated import?<br></p><p>-- E<br></p><p><br>&gt; On Mar 31, 2016, at 12:37 PM, Ankit Agarwal &lt;ankit at ankit.im&gt; wrote:<br>&gt; <br>&gt; I think if swiftpm renames `SwiftString` to `com.github.erica.SwiftString`, any other dependency having either `SwiftString` as dependency will not be able to use `import SwiftString` and thus fail to build.<br>&gt; <br>&gt; On Thu, Mar 31, 2016 at 11:54 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt; I&#39;m trying to clean up a few things while my kids are on Spring Break and decided to rewrite my package<br>&gt; conflict proposal, which follows.<br>&gt; <br>&gt; This updated version does not require any language change (although one could be adopted later), does not<br>&gt; require any package change, and only affects the target directories and module names.<br>&gt; <br>&gt; I&#39;d appreciate any feedback you could give.<br>&gt; <br>&gt; Thanks, -- Erica<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160331/30724084/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Revisiting package conflicts</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>April  1, 2016 at 10:00:00am</p></header><div class="content"><p>I’m sorry I haven’t been as active in this issue.<br></p><p>For me, this is one of the really important issues and I want to make sure we do it right, so I’m letting my mind spin on it regularly.<br></p><p>Namespacing is more than just avoiding conflicts, it becomes part of a package’s identity, so it has social and community consequences.<br></p><p>&gt; On Mar 31, 2016, at 3:20 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; *headbang* *headbang* *headbang*<br>&gt; <br>&gt; Possible situations:<br>&gt; <br>&gt; * One package knows there&#39;s name conflicts, uses full dependency reverse namespacing<br>&gt; * Dependent package does not know there&#39;s name conflicts, but it has a dependency listed, so it uses only the nearest/most visible declaration.<br>&gt; <br>&gt; Is there a way to resolve using some sort of rule system so that this somehow works? Can I assume that each module is compiled from the bottom to the top of the dependency graph so that the only conflicts ever seen would be higher in the graph where they know a priori that there&#39;s a more complicated import?<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 31, 2016, at 12:37 PM, Ankit Agarwal &lt;ankit at ankit.im &lt;mailto:ankit at ankit.im&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think if swiftpm renames `SwiftString` to `com.github.erica.SwiftString`, any other dependency having either `SwiftString` as dependency will not be able to use `import SwiftString` and thus fail to build.<br>&gt;&gt; <br>&gt;&gt; On Thu, Mar 31, 2016 at 11:54 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; I&#39;m trying to clean up a few things while my kids are on Spring Break and decided to rewrite my package<br>&gt;&gt; conflict proposal, which follows.<br>&gt;&gt; <br>&gt;&gt; This updated version does not require any language change (although one could be adopted later), does not<br>&gt;&gt; require any package change, and only affects the target directories and module names.<br>&gt;&gt; <br>&gt;&gt; I&#39;d appreciate any feedback you could give.<br>&gt;&gt; <br>&gt;&gt; Thanks, -- Erica<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160401/c777c367/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Revisiting package conflicts</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>April  3, 2016 at 11:00:00pm</p></header><div class="content"><p>I think my high level opinion on this problem is that it is still a questionable thing to support in this particular form.<br></p><p>I agree that using clear names, like SwiftString, is useful. However, I also think it would be very unfortunate if a product ended up using a SwiftString module from multiple authors within a single build graph. That would be confusing to work on, and especially doing it without involvement from Swift the language would be problematic (e.g., there might be mangling collisions, how would the user understand which types they were seeing in places outside of a specific module with an explicit import).<br></p><p>I think having more namespacing options at the language level is the right place to push on this, after which SwiftPM can adopt them (if indeed any work is required).<br></p><p>For example, one situation where I think this is reasonable to support is when a large package has a complicated internal module structure, most of which clients cannot see. Such a package might want to have a &quot;Util&quot; module, as might many other such packages, and they shouldn&#39;t collide. However, for this case to work the package needs to be written in such a way that it is clear which imports have visibility into which namespaces, it isn&#39;t just a renaming operation at the SwiftPM level.<br></p><p> - Daniel<br></p><p>&gt; On Mar 31, 2016, at 11:24 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m trying to clean up a few things while my kids are on Spring Break and decided to rewrite my package<br>&gt; conflict proposal, which follows.<br>&gt; <br>&gt; This updated version does not require any language change (although one could be adopted later), does not<br>&gt; require any package change, and only affects the target directories and module names.<br>&gt; <br>&gt; I&#39;d appreciate any feedback you could give.<br>&gt; <br>&gt; Thanks, -- Erica<br>&gt; <br>&gt; <br>&gt; Disambiguating SwiftPM Naming Conflicts<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/erica/c6553a5f6f35e7462074#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal creates a way to resolve SwiftPM module conflicts. It introduces namespacing to handle the rare case of name overlaps without requiring a central package registry.<br>&gt; <br>&gt; This proposal was discussed on the Swift-Dev and Swift-Build-Dev lists in the &quot;Right List? &lt;http://article.gmane.org/gmane.comp.lang.swift.devel/1149&gt;&quot; thread.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/c6553a5f6f35e7462074#motivation&gt;Motivation<br>&gt; <br>&gt; Swift offers a built in mechanism for distinguishing symbol conflicts. When working with NSView, using Swift.printoutputs text to the console or stream. NSView&#39;s  print creates a print job. Swift does not yet offer a solution for conflicting module names.<br>&gt; <br>&gt; Like many other Swift developers, I have spent considerable time building utility packages. Mine use obvious names like SwiftString and SwiftCollections because simple clear naming is a hallmark of Swift design. At the same time, this style introduces the possibility of package name conflicts. <br>&gt; <br>&gt; import SwiftString // mine<br>&gt; import SwiftString // someone else&#39;s. oops.<br>&gt; Two SwiftString packages cannot be used simultaneously without some form of namespace resolution. Moving back to Cocoa-style namespacing, for example ESSwiftString, feels ugly and antithetical to Swift. Swift should encourage recognizable, easy-to-understand module names. This proposal addresses this rare but possible conflict.<br>&gt; <br>&gt; Under the current system, same-named modules:<br>&gt; <br>&gt; import PackageDescription<br>&gt; let package = Package (<br>&gt;     name: &quot;myutility&quot;,<br>&gt;         dependencies: [<br>&gt;         .Package(url: &quot;https://github.com/erica/SwiftString.git &lt;https://github.com/erica/SwiftString.git&gt;&quot;,<br>&gt;                  majorVersion: 1),<br>&gt;         .Package(url: &quot;https://github.com/nudas/SwiftString.git &lt;https://github.com/nudas/SwiftString.git&gt;&quot;,<br>&gt;                  majorVersion: 1),<br>&gt;         ]<br>&gt; <br>&gt; )<br>&gt; produce the following error:<br>&gt; <br>&gt; % swift build<br>&gt; Cloning Packages/SwiftString<br>&gt; Using version 1.0.5 of package SwiftString<br>&gt; Cloning Packages/SwiftString<br>&gt; /usr/bin/git clone --recursive --depth 10 https://github.com/nudas/SwiftString.git &lt;https://github.com/nudas/SwiftString.git&gt; /home/erica/Work/test/Packages/SwiftString<br>&gt; fatal: destination path &#39;/home/erica/Work/test/Packages/SwiftString&#39; already exists and is not an empty directory.<br>&gt; <br>&gt; swift-build: Failed to clone https://github.com/nudas/SwiftString.git &lt;https://github.com/nudas/SwiftString.git&gt; to /home/erica/Work/test/Packages/SwiftString<br>&gt; Makefile:3: recipe for target &#39;all&#39; failed<br>&gt; make: *** [all] Error 1<br>&gt;  &lt;https://gist.github.com/erica/c6553a5f6f35e7462074#detail-design&gt;Detail Design<br>&gt; <br>&gt; Under this proposal, the Swift Package manager uses reverse domain naming to differentiate otherwise identically-named items. The two conflicting packages in the following example:<br>&gt; <br>&gt; import PackageDescription<br>&gt; let package = Package (<br>&gt;     name: &quot;MyUtility&quot;,<br>&gt;     dependencies: [<br>&gt;     .Package(url: &quot;https://github.com/erica/SwiftString.git &lt;https://github.com/erica/SwiftString.git&gt;&quot;,<br>&gt;                  majorVersion: 1),<br>&gt;     .Package(url: &quot;https://github.com/bob/SwiftString.git &lt;https://github.com/bob/SwiftString.git&gt;&quot;,<br>&gt;                  majorVersion: 1),<br>&gt;     ]<br>&gt; )<br>&gt; unpack to Packages/com.github.erica.SwiftString and Packages/com.github.bob.SwiftString rather than Packages/SwiftString.<br>&gt; <br>&gt; These can then be imported using the full RDN notation:<br>&gt; <br>&gt; import com.github.erica.SwiftString<br>&gt; import com.github.bob.SwiftString<br>&gt; Reverse domain names<br>&gt; <br>&gt; are rarely used outside the import statement and only to distinguish overlapping implementations<br>&gt; are relatively short<br>&gt; are already well established for Apple app distribution<br>&gt; are tied to the hosting repo<br>&gt;  &lt;https://gist.github.com/erica/c6553a5f6f35e7462074#future-directions&gt;Future Directions<br>&gt; <br>&gt; However concise, using reverse domain names bring verbiage to name conflicts. Upon adopting this proposal, I intend following through with language specific proposals that allow either import as or right-to-left namespacing.<br>&gt; <br>&gt; A Swift import as statement would allow a developer to rename a module on import:<br>&gt; <br>&gt; import com.github.erica.SwiftString as EricaString<br>&gt; A right-to-left alternative would require only as much of the reverse domain name prefix as needed to distinguish one implementation from another, for example:<br>&gt; <br>&gt; erica.SwiftString.print(x)<br>&gt; bob.SwiftString.print(x)<br>&gt; although presumably the fully specified RDN prefix could be used as well:<br>&gt; <br>&gt; com.github.erica.SwiftString.print(x)<br>&gt;  &lt;https://gist.github.com/erica/c6553a5f6f35e7462074#acknowledgements&gt;Acknowledgements<br>&gt; <br>&gt; Thanks to Joe Groff &lt;https://github.com/jckarter&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;, Max Howell, Daniel Dunbar, Kostiantyn Koval<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160403/aa91f660/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Revisiting package conflicts</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>April  6, 2016 at 10:00:00am</p></header><div class="content"><p>Collision in the wild: https://bugs.swift.org/browse/SR-1168<br></p><p>&gt; On Apr 3, 2016, at 11:43 PM, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt; wrote:<br>&gt; <br>&gt; I think my high level opinion on this problem is that it is still a questionable thing to support in this particular form.<br>&gt; <br>&gt; I agree that using clear names, like SwiftString, is useful. However, I also think it would be very unfortunate if a product ended up using a SwiftString module from multiple authors within a single build graph. That would be confusing to work on, and especially doing it without involvement from Swift the language would be problematic (e.g., there might be mangling collisions, how would the user understand which types they were seeing in places outside of a specific module with an explicit import).<br>&gt; <br>&gt; I think having more namespacing options at the language level is the right place to push on this, after which SwiftPM can adopt them (if indeed any work is required).<br>&gt; <br>&gt; For example, one situation where I think this is reasonable to support is when a large package has a complicated internal module structure, most of which clients cannot see. Such a package might want to have a &quot;Util&quot; module, as might many other such packages, and they shouldn&#39;t collide. However, for this case to work the package needs to be written in such a way that it is clear which imports have visibility into which namespaces, it isn&#39;t just a renaming operation at the SwiftPM level.<br>&gt; <br>&gt;  - Daniel<br>&gt; <br>&gt;&gt; On Mar 31, 2016, at 11:24 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m trying to clean up a few things while my kids are on Spring Break and decided to rewrite my package<br>&gt;&gt; conflict proposal, which follows.<br>&gt;&gt; <br>&gt;&gt; This updated version does not require any language change (although one could be adopted later), does not<br>&gt;&gt; require any package change, and only affects the target directories and module names.<br>&gt;&gt; <br>&gt;&gt; I&#39;d appreciate any feedback you could give.<br>&gt;&gt; <br>&gt;&gt; Thanks, -- Erica<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Disambiguating SwiftPM Naming Conflicts<br>&gt;&gt; Proposal: TBD<br>&gt;&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://gist.github.com/erica/c6553a5f6f35e7462074#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal creates a way to resolve SwiftPM module conflicts. It introduces namespacing to handle the rare case of name overlaps without requiring a central package registry.<br>&gt;&gt; <br>&gt;&gt; This proposal was discussed on the Swift-Dev and Swift-Build-Dev lists in the &quot;Right List? &lt;http://article.gmane.org/gmane.comp.lang.swift.devel/1149&gt;&quot; thread.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/c6553a5f6f35e7462074#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; Swift offers a built in mechanism for distinguishing symbol conflicts. When working with NSView, using Swift.printoutputs text to the console or stream. NSView&#39;s  print creates a print job. Swift does not yet offer a solution for conflicting module names.<br>&gt;&gt; <br>&gt;&gt; Like many other Swift developers, I have spent considerable time building utility packages. Mine use obvious names like SwiftString and SwiftCollections because simple clear naming is a hallmark of Swift design. At the same time, this style introduces the possibility of package name conflicts. <br>&gt;&gt; <br>&gt;&gt; import SwiftString // mine<br>&gt;&gt; import SwiftString // someone else&#39;s. oops.<br>&gt;&gt; Two SwiftString packages cannot be used simultaneously without some form of namespace resolution. Moving back to Cocoa-style namespacing, for example ESSwiftString, feels ugly and antithetical to Swift. Swift should encourage recognizable, easy-to-understand module names. This proposal addresses this rare but possible conflict.<br>&gt;&gt; <br>&gt;&gt; Under the current system, same-named modules:<br>&gt;&gt; <br>&gt;&gt; import PackageDescription<br>&gt;&gt; let package = Package (<br>&gt;&gt;     name: &quot;myutility&quot;,<br>&gt;&gt;         dependencies: [<br>&gt;&gt;         .Package(url: &quot;https://github.com/erica/SwiftString.git &lt;https://github.com/erica/SwiftString.git&gt;&quot;,<br>&gt;&gt;                  majorVersion: 1),<br>&gt;&gt;         .Package(url: &quot;https://github.com/nudas/SwiftString.git &lt;https://github.com/nudas/SwiftString.git&gt;&quot;,<br>&gt;&gt;                  majorVersion: 1),<br>&gt;&gt;         ]<br>&gt;&gt; <br>&gt;&gt; )<br>&gt;&gt; produce the following error:<br>&gt;&gt; <br>&gt;&gt; % swift build<br>&gt;&gt; Cloning Packages/SwiftString<br>&gt;&gt; Using version 1.0.5 of package SwiftString<br>&gt;&gt; Cloning Packages/SwiftString<br>&gt;&gt; /usr/bin/git clone --recursive --depth 10 https://github.com/nudas/SwiftString.git &lt;https://github.com/nudas/SwiftString.git&gt; /home/erica/Work/test/Packages/SwiftString<br>&gt;&gt; fatal: destination path &#39;/home/erica/Work/test/Packages/SwiftString&#39; already exists and is not an empty directory.<br>&gt;&gt; <br>&gt;&gt; swift-build: Failed to clone https://github.com/nudas/SwiftString.git &lt;https://github.com/nudas/SwiftString.git&gt; to /home/erica/Work/test/Packages/SwiftString<br>&gt;&gt; Makefile:3: recipe for target &#39;all&#39; failed<br>&gt;&gt; make: *** [all] Error 1<br>&gt;&gt;  &lt;https://gist.github.com/erica/c6553a5f6f35e7462074#detail-design&gt;Detail Design<br>&gt;&gt; <br>&gt;&gt; Under this proposal, the Swift Package manager uses reverse domain naming to differentiate otherwise identically-named items. The two conflicting packages in the following example:<br>&gt;&gt; <br>&gt;&gt; import PackageDescription<br>&gt;&gt; let package = Package (<br>&gt;&gt;     name: &quot;MyUtility&quot;,<br>&gt;&gt;     dependencies: [<br>&gt;&gt;     .Package(url: &quot;https://github.com/erica/SwiftString.git &lt;https://github.com/erica/SwiftString.git&gt;&quot;,<br>&gt;&gt;                  majorVersion: 1),<br>&gt;&gt;     .Package(url: &quot;https://github.com/bob/SwiftString.git &lt;https://github.com/bob/SwiftString.git&gt;&quot;,<br>&gt;&gt;                  majorVersion: 1),<br>&gt;&gt;     ]<br>&gt;&gt; )<br>&gt;&gt; unpack to Packages/com.github.erica.SwiftString and Packages/com.github.bob.SwiftString rather than Packages/SwiftString.<br>&gt;&gt; <br>&gt;&gt; These can then be imported using the full RDN notation:<br>&gt;&gt; <br>&gt;&gt; import com.github.erica.SwiftString<br>&gt;&gt; import com.github.bob.SwiftString<br>&gt;&gt; Reverse domain names<br>&gt;&gt; <br>&gt;&gt; are rarely used outside the import statement and only to distinguish overlapping implementations<br>&gt;&gt; are relatively short<br>&gt;&gt; are already well established for Apple app distribution<br>&gt;&gt; are tied to the hosting repo<br>&gt;&gt;  &lt;https://gist.github.com/erica/c6553a5f6f35e7462074#future-directions&gt;Future Directions<br>&gt;&gt; <br>&gt;&gt; However concise, using reverse domain names bring verbiage to name conflicts. Upon adopting this proposal, I intend following through with language specific proposals that allow either import as or right-to-left namespacing.<br>&gt;&gt; <br>&gt;&gt; A Swift import as statement would allow a developer to rename a module on import:<br>&gt;&gt; <br>&gt;&gt; import com.github.erica.SwiftString as EricaString<br>&gt;&gt; A right-to-left alternative would require only as much of the reverse domain name prefix as needed to distinguish one implementation from another, for example:<br>&gt;&gt; <br>&gt;&gt; erica.SwiftString.print(x)<br>&gt;&gt; bob.SwiftString.print(x)<br>&gt;&gt; although presumably the fully specified RDN prefix could be used as well:<br>&gt;&gt; <br>&gt;&gt; com.github.erica.SwiftString.print(x)<br>&gt;&gt;  &lt;https://gist.github.com/erica/c6553a5f6f35e7462074#acknowledgements&gt;Acknowledgements<br>&gt;&gt; <br>&gt;&gt; Thanks to Joe Groff &lt;https://github.com/jckarter&gt;, Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;, Max Howell, Daniel Dunbar, Kostiantyn Koval<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160406/4ac590c9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
