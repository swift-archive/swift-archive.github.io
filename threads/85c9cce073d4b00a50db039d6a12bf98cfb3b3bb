<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>February 12, 2016 at 10:00:00am</p></header><div class="content"><p>For example:<br></p><p>let x:Int<br>if … { x = 1 }<br>else if … { x = 2 }<br>else { precondition(false) } // no initialization needed<br></p><p>Similarly,<br></p><p>let x:Int<br>switch ... {<br>case …: x = 1<br>case …: x = 2<br>default: precondition(false) // no initialization needed<br>}<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>February 12, 2016 at 04:00:00pm</p></header><div class="content"><p>It would be really helpful if you could describe the problem you&#39;re<br>experiencing so I don&#39;t have to guess what it is from your example code.<br></p><p>Am I guessing right if I say that you want a change to Swift such that a<br>switch initialisation can be &#39;force-unwrapped&#39;, such that if none of the<br>cases apply, the app crashes, in a more explicit fashion?<br></p><p>I&#39;ve written code like this, but I&#39;ve tended towards &#39;default:<br>fatalError()&#39;, which wouldn&#39;t be covered by your suggestion. &#39;precondition&#39;<br>isn&#39;t at fault here.<br></p><p>Just as a digression, I&#39;ve just learned that &#39;precondition(false)&#39; doesn&#39;t<br>cause any immediately following code to receive the compiler warning &#39;will<br>never be executed&#39; that code in a &#39;if false { ... }&#39; does. So that would be<br>nice.<br></p><p>On Fri, Feb 12, 2016 at 3:59 PM, Amir Michail via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; For example:<br>&gt;<br>&gt; let x:Int<br>&gt; if … { x = 1 }<br>&gt; else if … { x = 2 }<br>&gt; else { precondition(false) } // no initialization needed<br>&gt;<br>&gt; Similarly,<br>&gt;<br>&gt; let x:Int<br>&gt; switch ... {<br>&gt; case …: x = 1<br>&gt; case …: x = 2<br>&gt; default: precondition(false) // no initialization needed<br>&gt; }<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/0b21039b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>February 12, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 12, 2016, at 11:27 AM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; It would be really helpful if you could describe the problem you&#39;re experiencing so I don&#39;t have to guess what it is from your example code.<br>&gt; <br></p><p>I want to ensure that one of the cases applies. Otherwise, there is a bug in my code. That’s why I have the precondition(false).<br></p><p>However, writing code like this is annoying:<br></p><p>let x:Int<br>if … { x = 1 }<br>else if … { x = 2 }<br>else { x = dummyValue; precondition(false) } <br></p><p>&gt; Am I guessing right if I say that you want a change to Swift such that a switch initialisation can be &#39;force-unwrapped&#39;, such that if none of the cases apply, the app crashes, in a more explicit fashion?<br>&gt; <br>&gt; I&#39;ve written code like this, but I&#39;ve tended towards &#39;default: fatalError()&#39;, which wouldn&#39;t be covered by your suggestion. &#39;precondition&#39; isn&#39;t at fault here.<br>&gt; <br>&gt; Just as a digression, I&#39;ve just learned that &#39;precondition(false)&#39; doesn&#39;t cause any immediately following code to receive the compiler warning &#39;will never be executed&#39; that code in a &#39;if false { ... }&#39; does. So that would be nice.<br>&gt; <br>&gt; On Fri, Feb 12, 2016 at 3:59 PM, Amir Michail via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; For example:<br>&gt; <br>&gt; let x:Int<br>&gt; if … { x = 1 }<br>&gt; else if … { x = 2 }<br>&gt; else { precondition(false) } // no initialization needed<br>&gt; <br>&gt; Similarly,<br>&gt; <br>&gt; let x:Int<br>&gt; switch ... {<br>&gt; case …: x = 1<br>&gt; case …: x = 2<br>&gt; default: precondition(false) // no initialization needed<br>&gt; }<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/0f614432/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7321934b88ca8da079d7b89926501a9c?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>David Turnbull</string> &lt;dturnbull at gmail.com&gt;<p>February 12, 2016 at 08:00:00am</p></header><div class="content"><p>Use preconditionFailure() instead of precondition(false).<br></p><p>-david<br></p><p>On Fri, Feb 12, 2016 at 7:59 AM, Amir Michail via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; For example:<br>&gt;<br>&gt; let x:Int<br>&gt; if … { x = 1 }<br>&gt; else if … { x = 2 }<br>&gt; else { precondition(false) } // no initialization needed<br>&gt;<br>&gt; Similarly,<br>&gt;<br>&gt; let x:Int<br>&gt; switch ... {<br>&gt; case …: x = 1<br>&gt; case …: x = 2<br>&gt; default: precondition(false) // no initialization needed<br>&gt; }<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/57b16889/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>February 12, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 12, 2016, at 11:29 AM, David Turnbull &lt;dturnbull at gmail.com&gt; wrote:<br>&gt; <br>&gt; Use preconditionFailure() instead of precondition(false).<br>&gt; <br></p><p>That works! But I think precondition(false) should also work.<br></p><p>&gt; -david<br>&gt; <br>&gt; On Fri, Feb 12, 2016 at 7:59 AM, Amir Michail via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; For example:<br>&gt; <br>&gt; let x:Int<br>&gt; if … { x = 1 }<br>&gt; else if … { x = 2 }<br>&gt; else { precondition(false) } // no initialization needed<br>&gt; <br>&gt; Similarly,<br>&gt; <br>&gt; let x:Int<br>&gt; switch ... {<br>&gt; case …: x = 1<br>&gt; case …: x = 2<br>&gt; default: precondition(false) // no initialization needed<br>&gt; }<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/9e7d72d1/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February 12, 2016 at 06:00:00pm</p></header><div class="content"><p>I think what you mean is `fatalError()`.<br></p><p>You can’t do what you suggest, because you can’t prove that the expression passed to precondition will evaluate to false. (You theoretically could if the compiler checked for you passing `false`, but that makes no sense. Just go with `fatalError` or `preconditionFailure`.)<br></p><p>— Radek<br></p><p>&gt; On 12 Feb 2016, at 16:59, Amir Michail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; For example:<br>&gt; <br>&gt; let x:Int<br>&gt; if … { x = 1 }<br>&gt; else if … { x = 2 }<br>&gt; else { precondition(false) } // no initialization needed<br>&gt; <br>&gt; Similarly,<br>&gt; <br>&gt; let x:Int<br>&gt; switch ... {<br>&gt; case …: x = 1<br>&gt; case …: x = 2<br>&gt; default: precondition(false) // no initialization needed<br>&gt; }<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>February 12, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 12, 2016, at 12:09 PM, Radosław Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think what you mean is `fatalError()`.<br>&gt; <br>&gt; You can’t do what you suggest, because you can’t prove that the expression passed to precondition will evaluate to false. (You theoretically could if the compiler checked for you passing `false`, but that makes no sense. Just go with `fatalError` or `preconditionFailure`.)<br>&gt; <br></p><p>What’s wrong with having the compiler explicitly check for “false”?<br></p><p>&gt; — Radek<br>&gt; <br>&gt;&gt; On 12 Feb 2016, at 16:59, Amir Michail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; For example:<br>&gt;&gt; <br>&gt;&gt; let x:Int<br>&gt;&gt; if … { x = 1 }<br>&gt;&gt; else if … { x = 2 }<br>&gt;&gt; else { precondition(false) } // no initialization needed<br>&gt;&gt; <br>&gt;&gt; Similarly,<br>&gt;&gt; <br>&gt;&gt; let x:Int<br>&gt;&gt; switch ... {<br>&gt;&gt; case …: x = 1<br>&gt;&gt; case …: x = 2<br>&gt;&gt; default: precondition(false) // no initialization needed<br>&gt;&gt; }<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 12, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Feb 12, 2016, at 9:15 AM, Amir Michail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 12, 2016, at 12:09 PM, Radosław Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think what you mean is `fatalError()`.<br>&gt;&gt; <br>&gt;&gt; You can’t do what you suggest, because you can’t prove that the expression passed to precondition will evaluate to false. (You theoretically could if the compiler checked for you passing `false`, but that makes no sense. Just go with `fatalError` or `preconditionFailure`.)<br>&gt;&gt; <br>&gt; <br>&gt; What’s wrong with having the compiler explicitly check for “false”?<br></p><p>Weird special cases make the compiler less predictable.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>February 12, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 12, 2016, at 12:23 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 12, 2016, at 9:15 AM, Amir Michail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 12, 2016, at 12:09 PM, Radosław Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think what you mean is `fatalError()`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can’t do what you suggest, because you can’t prove that the expression passed to precondition will evaluate to false. (You theoretically could if the compiler checked for you passing `false`, but that makes no sense. Just go with `fatalError` or `preconditionFailure`.)<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What’s wrong with having the compiler explicitly check for “false”?<br>&gt; <br>&gt; Weird special cases make the compiler less predictable.<br></p><p>True, but not having them requires deeper knowledge of the standard libraries.<br></p><p>In practice, just checking for “false” would solve this problem.<br></p><p>&gt; <br>&gt; -Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 12, 2016 at 09:00:00am</p></header><div class="content"><p>On Feb 12, 2016, at 9:27 AM, Amir Michail &lt;a.michail at me.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What’s wrong with having the compiler explicitly check for “false”?<br>&gt;&gt; <br>&gt;&gt; Weird special cases make the compiler less predictable.<br>&gt; <br>&gt; True, but not having them requires deeper knowledge of the standard libraries.<br>&gt; <br>&gt; In practice, just checking for “false” would solve this problem.<br></p><p>That is not what you’re actually proposing.  You are proposing that the compiler encode special knowledge of the precondition *library function* into the compiler, and teach it about a single special case.  We don’t like the compiler to have special cases like this for a large number of reasons, in particular, if we did this, someone would file a bug asking for *their* equivalent reimplementation of precondition to have the same magic blessed behavior. <br></p><p>This is a slippery slope that leads to a lot of complexity downstream, it is better to keep the compiler simple and predictable.  Also, as other people have pointed out, this has already been solved for you: just use preconditionFailure.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>February 12, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 12, 2016, at 12:32 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Feb 12, 2016, at 9:27 AM, Amir Michail &lt;a.michail at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What’s wrong with having the compiler explicitly check for “false”?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Weird special cases make the compiler less predictable.<br>&gt;&gt; <br>&gt;&gt; True, but not having them requires deeper knowledge of the standard libraries.<br>&gt;&gt; <br>&gt;&gt; In practice, just checking for “false” would solve this problem.<br>&gt; <br>&gt; That is not what you’re actually proposing.  You are proposing that the compiler encode special knowledge of the precondition *library function* into the compiler, and teach it about a single special case.  We don’t like the compiler to have special cases like this for a large number of reasons, in particular, if we did this, someone would file a bug asking for *their* equivalent reimplementation of precondition to have the same magic blessed behavior. <br>&gt; <br></p><p>What about having the compiler issue a warning pointing you to preconditionFailure whenever it sees precondition(false)?<br></p><p>&gt; This is a slippery slope that leads to a lot of complexity downstream, it is better to keep the compiler simple and predictable.  Also, as other people have pointed out, this has already been solved for you: just use preconditionFailure.<br>&gt; <br>&gt; -Chris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>February 12, 2016 at 05:00:00pm</p></header><div class="content"><p>I have a suggestion.<br>Suppose we think of &#39;switch&#39; as being like a non-optional type. The<br>compiler does its thing and tries to ensure that the switched expression<br>will match something, and enforces a default if it cannot verify a matching<br>state.<br>Could we force the switch? i.e. suffix the &#39;switch&#39; keyword with an<br>exclamation mark, to say: the programmer insists that one of these cases<br>will match; there&#39;s no need for a default case, but if nothing matches then<br>crash.<br></p><p>For example:<br>let x:Int<br>switch! expression<br>{<br>    case ... { x = 1 }<br>    case ... { x = 2 }<br>    // no default. the ! signifies that the app should crash if none of<br>these cases matches the expression<br>}<br></p><p><br></p><p><br>On Fri, Feb 12, 2016 at 5:32 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Feb 12, 2016, at 9:27 AM, Amir Michail &lt;a.michail at me.com&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; What’s wrong with having the compiler explicitly check for “false”?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Weird special cases make the compiler less predictable.<br>&gt; &gt;<br>&gt; &gt; True, but not having them requires deeper knowledge of the standard<br>&gt; libraries.<br>&gt; &gt;<br>&gt; &gt; In practice, just checking for “false” would solve this problem.<br>&gt;<br>&gt; That is not what you’re actually proposing.  You are proposing that the<br>&gt; compiler encode special knowledge of the precondition *library function*<br>&gt; into the compiler, and teach it about a single special case.  We don’t like<br>&gt; the compiler to have special cases like this for a large number of reasons,<br>&gt; in particular, if we did this, someone would file a bug asking for *their*<br>&gt; equivalent reimplementation of precondition to have the same magic blessed<br>&gt; behavior.<br>&gt;<br>&gt; This is a slippery slope that leads to a lot of complexity downstream, it<br>&gt; is better to keep the compiler simple and predictable.  Also, as other<br>&gt; people have pointed out, this has already been solved for you: just use<br>&gt; preconditionFailure.<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/188cc594/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>February 12, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 12, 2016, at 12:41 PM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; I have a suggestion.<br>&gt; Suppose we think of &#39;switch&#39; as being like a non-optional type. The compiler does its thing and tries to ensure that the switched expression will match something, and enforces a default if it cannot verify a matching state.<br>&gt; Could we force the switch? i.e. suffix the &#39;switch&#39; keyword with an exclamation mark, to say: the programmer insists that one of these cases will match; there&#39;s no need for a default case, but if nothing matches then crash.<br>&gt; <br></p><p>This doesn’t solve the more general problem — namely, that of required deep knowledge of the standard libraries.<br></p><p>A more general solution would be to provide a way for API writers to issue (heuristic) warnings for suboptimal usage of their APIs.<br></p><p>&gt; For example:<br>&gt; let x:Int<br>&gt; switch! expression<br>&gt; {<br>&gt;     case ... { x = 1 }<br>&gt;     case ... { x = 2 }<br>&gt;     // no default. the ! signifies that the app should crash if none of these cases matches the expression<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On Fri, Feb 12, 2016 at 5:32 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; On Feb 12, 2016, at 9:27 AM, Amir Michail &lt;a.michail at me.com &lt;mailto:a.michail at me.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; What’s wrong with having the compiler explicitly check for “false”?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Weird special cases make the compiler less predictable.<br>&gt; &gt;<br>&gt; &gt; True, but not having them requires deeper knowledge of the standard libraries.<br>&gt; &gt;<br>&gt; &gt; In practice, just checking for “false” would solve this problem.<br>&gt; <br>&gt; That is not what you’re actually proposing.  You are proposing that the compiler encode special knowledge of the precondition *library function* into the compiler, and teach it about a single special case.  We don’t like the compiler to have special cases like this for a large number of reasons, in particular, if we did this, someone would file a bug asking for *their* equivalent reimplementation of precondition to have the same magic blessed behavior.<br>&gt; <br>&gt; This is a slippery slope that leads to a lot of complexity downstream, it is better to keep the compiler simple and predictable.  Also, as other people have pointed out, this has already been solved for you: just use preconditionFailure.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/b7e26777/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>February 12, 2016 at 05:00:00pm</p></header><div class="content"><p>Okay, but the original general problem was that you wanted to ensure that<br>one of the cases applied, and my suggestion addressed that problem.<br></p><p>Since then it&#39;s become whether or not the developer has knowledge of<br>fatalError(), preconditionFailure(), and then the more general<br>&#39;precondition&#39;. It seems to me that the compiler clearly does have some<br>boolean evaluation routine in place, or &#39;if false { ... }&#39; wouldn&#39;t<br>generate the &#39;this will never be executed&#39; warning I mentioned earlier, and<br>perhaps this routine could be applied to precondition calls as well.<br></p><p>Providing a way for me to issue warnings for suboptimal use of APIs I write<br>is a third thing entirely.<br></p><p>On Fri, Feb 12, 2016 at 5:45 PM, Amir Michail &lt;a.michail at me.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Feb 12, 2016, at 12:41 PM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; I have a suggestion.<br>&gt; Suppose we think of &#39;switch&#39; as being like a non-optional type. The<br>&gt; compiler does its thing and tries to ensure that the switched expression<br>&gt; will match something, and enforces a default if it cannot verify a matching<br>&gt; state.<br>&gt; Could we force the switch? i.e. suffix the &#39;switch&#39; keyword with an<br>&gt; exclamation mark, to say: the programmer insists that one of these cases<br>&gt; will match; there&#39;s no need for a default case, but if nothing matches then<br>&gt; crash.<br>&gt;<br>&gt;<br>&gt; This doesn’t solve the more general problem — namely, that of required<br>&gt; deep knowledge of the standard libraries.<br>&gt;<br>&gt; A more general solution would be to provide a way for API writers to issue<br>&gt; (heuristic) warnings for suboptimal usage of their APIs.<br>&gt;<br>&gt; For example:<br>&gt; let x:Int<br>&gt; switch! expression<br>&gt; {<br>&gt;     case ... { x = 1 }<br>&gt;     case ... { x = 2 }<br>&gt;     // no default. the ! signifies that the app should crash if none of<br>&gt; these cases matches the expression<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Fri, Feb 12, 2016 at 5:32 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Feb 12, 2016, at 9:27 AM, Amir Michail &lt;a.michail at me.com&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; What’s wrong with having the compiler explicitly check for “false”?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Weird special cases make the compiler less predictable.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; True, but not having them requires deeper knowledge of the standard<br>&gt;&gt; libraries.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In practice, just checking for “false” would solve this problem.<br>&gt;&gt;<br>&gt;&gt; That is not what you’re actually proposing.  You are proposing that the<br>&gt;&gt; compiler encode special knowledge of the precondition *library function*<br>&gt;&gt; into the compiler, and teach it about a single special case.  We don’t like<br>&gt;&gt; the compiler to have special cases like this for a large number of reasons,<br>&gt;&gt; in particular, if we did this, someone would file a bug asking for *their*<br>&gt;&gt; equivalent reimplementation of precondition to have the same magic blessed<br>&gt;&gt; behavior.<br>&gt;&gt;<br>&gt;&gt; This is a slippery slope that leads to a lot of complexity downstream, it<br>&gt;&gt; is better to keep the compiler simple and predictable.  Also, as other<br>&gt;&gt; people have pointed out, this has already been solved for you: just use<br>&gt;&gt; preconditionFailure.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/272fdd6c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>February 12, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 12, 2016, at 12:56 PM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; Okay, but the original general problem was that you wanted to ensure that one of the cases applied, and my suggestion addressed that problem.<br>&gt; <br>&gt; Since then it&#39;s become whether or not the developer has knowledge of fatalError(), preconditionFailure(), and then the more general &#39;precondition&#39;. It seems to me that the compiler clearly does have some boolean evaluation routine in place, or &#39;if false { ... }&#39; wouldn&#39;t generate the &#39;this will never be executed&#39; warning I mentioned earlier, and perhaps this routine could be applied to precondition calls as well.<br>&gt; <br>&gt; Providing a way for me to issue warnings for suboptimal use of APIs I write is a third thing entirely.<br></p><p>It would also provide a solution to this problem in particular.<br></p><p>&gt; <br>&gt; On Fri, Feb 12, 2016 at 5:45 PM, Amir Michail &lt;a.michail at me.com &lt;mailto:a.michail at me.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Feb 12, 2016, at 12:41 PM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com &lt;mailto:narrativium+swift at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have a suggestion.<br>&gt;&gt; Suppose we think of &#39;switch&#39; as being like a non-optional type. The compiler does its thing and tries to ensure that the switched expression will match something, and enforces a default if it cannot verify a matching state.<br>&gt;&gt; Could we force the switch? i.e. suffix the &#39;switch&#39; keyword with an exclamation mark, to say: the programmer insists that one of these cases will match; there&#39;s no need for a default case, but if nothing matches then crash.<br>&gt;&gt; <br>&gt; <br>&gt; This doesn’t solve the more general problem — namely, that of required deep knowledge of the standard libraries.<br>&gt; <br>&gt; A more general solution would be to provide a way for API writers to issue (heuristic) warnings for suboptimal usage of their APIs.<br>&gt; <br>&gt;&gt; For example:<br>&gt;&gt; let x:Int<br>&gt;&gt; switch! expression<br>&gt;&gt; {<br>&gt;&gt;     case ... { x = 1 }<br>&gt;&gt;     case ... { x = 2 }<br>&gt;&gt;     // no default. the ! signifies that the app should crash if none of these cases matches the expression<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, Feb 12, 2016 at 5:32 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On Feb 12, 2016, at 9:27 AM, Amir Michail &lt;a.michail at me.com &lt;mailto:a.michail at me.com&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; What’s wrong with having the compiler explicitly check for “false”?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Weird special cases make the compiler less predictable.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; True, but not having them requires deeper knowledge of the standard libraries.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In practice, just checking for “false” would solve this problem.<br>&gt;&gt; <br>&gt;&gt; That is not what you’re actually proposing.  You are proposing that the compiler encode special knowledge of the precondition *library function* into the compiler, and teach it about a single special case.  We don’t like the compiler to have special cases like this for a large number of reasons, in particular, if we did this, someone would file a bug asking for *their* equivalent reimplementation of precondition to have the same magic blessed behavior.<br>&gt;&gt; <br>&gt;&gt; This is a slippery slope that leads to a lot of complexity downstream, it is better to keep the compiler simple and predictable.  Also, as other people have pointed out, this has already been solved for you: just use preconditionFailure.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/4b5a16dc/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 12, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Feb 12, 2016, at 9:45 , Amir Michail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 12, 2016, at 12:41 PM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com &lt;mailto:narrativium+swift at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have a suggestion.<br>&gt;&gt; Suppose we think of &#39;switch&#39; as being like a non-optional type. The compiler does its thing and tries to ensure that the switched expression will match something, and enforces a default if it cannot verify a matching state.<br>&gt;&gt; Could we force the switch? i.e. suffix the &#39;switch&#39; keyword with an exclamation mark, to say: the programmer insists that one of these cases will match; there&#39;s no need for a default case, but if nothing matches then crash.<br>&gt;&gt; <br>&gt; <br>&gt; This doesn’t solve the more general problem — namely, that of required deep knowledge of the standard libraries.<br>&gt; <br>&gt; A more general solution would be to provide a way for API writers to issue (heuristic) warnings for suboptimal usage of their APIs.<br></p><p>This is a good observation. I think it deserves its own design and its own thread, though.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/74d8ec57/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>February 12, 2016 at 09:00:00am</p></header><div class="content"><p>On Fri, Feb 12, 2016 at 9:15 AM, Amir Michail via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Feb 12, 2016, at 12:09 PM, Radosław Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I think what you mean is `fatalError()`.<br>&gt;&gt;<br>&gt;&gt; You can’t do what you suggest, because you can’t prove that the expression passed to precondition will evaluate to false. (You theoretically could if the compiler checked for you passing `false`, but that makes no sense. Just go with `fatalError` or `preconditionFailure`.)<br>&gt;&gt;<br>&gt;<br>&gt; What’s wrong with having the compiler explicitly check for “false”?<br></p><p>How far would you require the compiler to go?  precondition(2 &lt; 1)?<br>precondition(someFunctionThatAlwaysReturnsFalse())?<br>precondition(isFermatsLastTheoremTrue())?<br></p><p>This is important to define precisely since the answer to this<br>question changes the set of the programs that the compiler accepts.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>February 12, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 12, 2016, at 12:24 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Feb 12, 2016 at 9:15 AM, Amir Michail via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 12, 2016, at 12:09 PM, Radosław Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think what you mean is `fatalError()`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can’t do what you suggest, because you can’t prove that the expression passed to precondition will evaluate to false. (You theoretically could if the compiler checked for you passing `false`, but that makes no sense. Just go with `fatalError` or `preconditionFailure`.)<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What’s wrong with having the compiler explicitly check for “false”?<br>&gt; <br>&gt; How far would you require the compiler to go?  precondition(2 &lt; 1)?<br>&gt; precondition(someFunctionThatAlwaysReturnsFalse())?<br>&gt; precondition(isFermatsLastTheoremTrue())?<br>&gt; <br></p><p>Just “false”. Why would you write anything else?<br></p><p>&gt; This is important to define precisely since the answer to this<br>&gt; question changes the set of the programs that the compiler accepts.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 18, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Am 12.02.2016 um 18:26 schrieb Amir Michail via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; How far would you require the compiler to go?  precondition(2 &lt; 1)?<br>&gt;&gt; precondition(someFunctionThatAlwaysReturnsFalse())?<br>&gt;&gt; precondition(isFermatsLastTheoremTrue())?<br>&gt; <br>&gt; Just “false”. Why would you write anything else?<br></p><p>Why would you write anything else than preconditionFailure()??<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>February 18, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Feb 18, 2016, at 4:52 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 12.02.2016 um 18:26 schrieb Amir Michail via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; How far would you require the compiler to go?  precondition(2 &lt; 1)?<br>&gt;&gt;&gt; precondition(someFunctionThatAlwaysReturnsFalse())?<br>&gt;&gt;&gt; precondition(isFermatsLastTheoremTrue())?<br>&gt;&gt; <br>&gt;&gt; Just “false”. Why would you write anything else?<br>&gt; <br>&gt; Why would you write anything else than preconditionFailure()??<br></p><p>Everyone knows about “false” but not everyone knows about preconditionFailure().<br></p><p>&gt; <br>&gt; -Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Initialization should not be required in precondition(false) case.</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 19, 2016 at 06:00:00am</p></header><div class="content"><p>Not everyone knows about precondition() in the first place, so when he finds it he will probably find preconditionFailure(), too. On top of that the autocomplete will show it to him each time he starts to type precondition. Third it is a common pattern to provide a failure function, where one does not have to supply a false argument, e.g. In unit test assertions.<br></p><p>-Thorsten <br></p><p>&gt; Am 18.02.2016 um 23:21 schrieb Amir Michail &lt;a.michail at me.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 18, 2016, at 4:52 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 12.02.2016 um 18:26 schrieb Amir Michail via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How far would you require the compiler to go?  precondition(2 &lt; 1)?<br>&gt;&gt;&gt;&gt; precondition(someFunctionThatAlwaysReturnsFalse())?<br>&gt;&gt;&gt;&gt; precondition(isFermatsLastTheoremTrue())?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just “false”. Why would you write anything else?<br>&gt;&gt; <br>&gt;&gt; Why would you write anything else than preconditionFailure()??<br>&gt; <br>&gt; Everyone knows about “false” but not everyone knows about preconditionFailure().<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
