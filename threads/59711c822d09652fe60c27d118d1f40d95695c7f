<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Protected Access</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>October  7, 2016 at 03:00:00pm</p></header><div class="content"><p>The discussion of private/fileprivate reminded me of other access modifier issues that have been bugging me.  I agree that the old system is better, but I am ambivalent about changing it back…<br></p><p>What I pretty much constantly want is an access modifier which lets me access something from an extension (which is potentially in a different file), but otherwise have it be private.  The vast majority of my use of “fileprivate” is so that I can access internal properties/functions from an extension (which I am forced to place in the same file).<br></p><p>Access from subclasses is a larger discussion, but I run into this most often with Structs and their extensions.<br></p><p><br>The other pieces which seem to be missing are modifiers which allow finer grained control of how class methods are overridden and used.  <br></p><p>It is a fairly common pattern in cocoa, for example, to have customization point methods which are designed to be overridden, but are not supposed to be called directly. Right now, this is enforced via documentation.  One potential solution is to have a @noExternalCall attribute which says that it can only be called from the class/subclass/extensions… but if you think about it, this is basically another view of the first issue. If we could mark that method as only visible within the class/subclasses/extensions, then the behavior we want just falls out naturally. It can’t be called externally, because no one on the outside can see it.<br></p><p>I also occasionally run into this with protocols.  I find that I have a property on the protocol which is needed for default implementations, but I really want to make it private with respect to the protocol (and its inheritors/extensions).  That is, I want the implementor of the protocol to have visibility for that property, but not the caller of the protocol.  Right now, I have to expose it to everyone (which clutters my external API), and then note in documentation not to call those properties.<br></p><p>Basically, I want to do the following:<br></p><p>	protocol P {<br>		hidden var a:Int<br>		var b:Int<br>	}<br></p><p>	extension P {<br>		var c:Int { return self.a + self.b}<br>	}<br></p><p>	struct A:P {<br>		private var a:Int = 5  // ‘A’ must implement, but it doesn’t have to expose it externally<br>		var b:Int = 2<br>	}<br></p><p>	struct B:P{<br>		var a:Int = 3  // ‘B’ chooses to expose, which is ok too<br>		var b:Int = 4<br>	}<br></p><p>	let ans = A().c  // 7<br>	let ohNo = A().a // Error!<br></p><p>Basically ‘hidden’ in the protocol means that the implementor must implement the property, but it is not required to expose it to the world.  I don’t really care whether that is spelled hidden, protected, or private, but I would use this fairly often.<br></p><p>Thanks,<br>Jon<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Protected Access</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>October  7, 2016 at 10:00:00pm</p></header><div class="content"><p>I agree with and also feel access modifiers / controls are missing and the<br>ones we have may not be the best if you factor in these additional needs. I<br>also agree that I would prefer the discussion be more focused on this type<br>of thing. Thanks for capturing some of the things you have seen (I have<br>been meaning to do that myself but lacking in time and will do far).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/9da80eb7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0411520c60ef1131670f84bb42dc8949?s=50"></div><header><strong>Protected Access</strong> from <string>Swift)</string> &lt;swift-callionica at callionica.com (Callionica&gt;<p>October  7, 2016 at 04:00:00pm</p></header><div class="content"><p>For overridable, but not callable, you can use the technique outlined at<br>http://www.callionica.com/developer/#swift-protected<br>(give your method a parameter of a type that only the base class can create)<br></p><p>On Friday, October 7, 2016, Jonathan Hull via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The discussion of private/fileprivate reminded me of other access modifier<br>&gt; issues that have been bugging me.  I agree that the old system is better,<br>&gt; but I am ambivalent about changing it back…<br>&gt;<br>&gt; What I pretty much constantly want is an access modifier which lets me<br>&gt; access something from an extension (which is potentially in a different<br>&gt; file), but otherwise have it be private.  The vast majority of my use of<br>&gt; “fileprivate” is so that I can access internal properties/functions from an<br>&gt; extension (which I am forced to place in the same file).<br>&gt;<br>&gt; Access from subclasses is a larger discussion, but I run into this most<br>&gt; often with Structs and their extensions.<br>&gt;<br>&gt;<br>&gt; The other pieces which seem to be missing are modifiers which allow finer<br>&gt; grained control of how class methods are overridden and used.<br>&gt;<br>&gt; It is a fairly common pattern in cocoa, for example, to have customization<br>&gt; point methods which are designed to be overridden, but are not supposed to<br>&gt; be called directly. Right now, this is enforced via documentation.  One<br>&gt; potential solution is to have a @noExternalCall attribute which says that<br>&gt; it can only be called from the class/subclass/extensions… but if you think<br>&gt; about it, this is basically another view of the first issue. If we could<br>&gt; mark that method as only visible within the class/subclasses/extensions,<br>&gt; then the behavior we want just falls out naturally. It can’t be called<br>&gt; externally, because no one on the outside can see it.<br>&gt;<br>&gt; I also occasionally run into this with protocols.  I find that I have a<br>&gt; property on the protocol which is needed for default implementations, but I<br>&gt; really want to make it private with respect to the protocol (and its<br>&gt; inheritors/extensions).  That is, I want the implementor of the protocol to<br>&gt; have visibility for that property, but not the caller of the protocol.<br>&gt; Right now, I have to expose it to everyone (which clutters my external<br>&gt; API), and then note in documentation not to call those properties.<br>&gt;<br>&gt; Basically, I want to do the following:<br>&gt;<br>&gt;         protocol P {<br>&gt;                 hidden var a:Int<br>&gt;                 var b:Int<br>&gt;         }<br>&gt;<br>&gt;         extension P {<br>&gt;                 var c:Int { return self.a + self.b}<br>&gt;         }<br>&gt;<br>&gt;         struct A:P {<br>&gt;                 private var a:Int = 5  // ‘A’ must implement, but it<br>&gt; doesn’t have to expose it externally<br>&gt;                 var b:Int = 2<br>&gt;         }<br>&gt;<br>&gt;         struct B:P{<br>&gt;                 var a:Int = 3  // ‘B’ chooses to expose, which is ok too<br>&gt;                 var b:Int = 4<br>&gt;         }<br>&gt;<br>&gt;         let ans = A().c  // 7<br>&gt;         let ohNo = A().a // Error!<br>&gt;<br>&gt; Basically ‘hidden’ in the protocol means that the implementor must<br>&gt; implement the property, but it is not required to expose it to the world.<br>&gt; I don’t really care whether that is spelled hidden, protected, or private,<br>&gt; but I would use this fairly often.<br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/759d26ac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Protected Access</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October  7, 2016 at 09:00:00pm</p></header><div class="content"><p>Jon--earlier in the week, there was another thread which once against<br>raised the idea of internal or private protocol conformances; would that be<br>another way of addressing your use case here?<br></p><p><br>On Fri, Oct 7, 2016 at 6:36 PM, Callionica (Swift) via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; For overridable, but not callable, you can use the technique outlined at<br>&gt; http://www.callionica.com/developer/#swift-protected<br>&gt; (give your method a parameter of a type that only the base class can<br>&gt; create)<br>&gt;<br>&gt;<br>&gt; On Friday, October 7, 2016, Jonathan Hull via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; The discussion of private/fileprivate reminded me of other access<br>&gt;&gt; modifier issues that have been bugging me.  I agree that the old system is<br>&gt;&gt; better, but I am ambivalent about changing it back…<br>&gt;&gt;<br>&gt;&gt; What I pretty much constantly want is an access modifier which lets me<br>&gt;&gt; access something from an extension (which is potentially in a different<br>&gt;&gt; file), but otherwise have it be private.  The vast majority of my use of<br>&gt;&gt; “fileprivate” is so that I can access internal properties/functions from an<br>&gt;&gt; extension (which I am forced to place in the same file).<br>&gt;&gt;<br>&gt;&gt; Access from subclasses is a larger discussion, but I run into this most<br>&gt;&gt; often with Structs and their extensions.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The other pieces which seem to be missing are modifiers which allow finer<br>&gt;&gt; grained control of how class methods are overridden and used.<br>&gt;&gt;<br>&gt;&gt; It is a fairly common pattern in cocoa, for example, to have<br>&gt;&gt; customization point methods which are designed to be overridden, but are<br>&gt;&gt; not supposed to be called directly. Right now, this is enforced via<br>&gt;&gt; documentation.  One potential solution is to have a @noExternalCall<br>&gt;&gt; attribute which says that it can only be called from the<br>&gt;&gt; class/subclass/extensions… but if you think about it, this is basically<br>&gt;&gt; another view of the first issue. If we could mark that method as only<br>&gt;&gt; visible within the class/subclasses/extensions, then the behavior we want<br>&gt;&gt; just falls out naturally. It can’t be called externally, because no one on<br>&gt;&gt; the outside can see it.<br>&gt;&gt;<br>&gt;&gt; I also occasionally run into this with protocols.  I find that I have a<br>&gt;&gt; property on the protocol which is needed for default implementations, but I<br>&gt;&gt; really want to make it private with respect to the protocol (and its<br>&gt;&gt; inheritors/extensions).  That is, I want the implementor of the protocol to<br>&gt;&gt; have visibility for that property, but not the caller of the protocol.<br>&gt;&gt; Right now, I have to expose it to everyone (which clutters my external<br>&gt;&gt; API), and then note in documentation not to call those properties.<br>&gt;&gt;<br>&gt;&gt; Basically, I want to do the following:<br>&gt;&gt;<br>&gt;&gt;         protocol P {<br>&gt;&gt;                 hidden var a:Int<br>&gt;&gt;                 var b:Int<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         extension P {<br>&gt;&gt;                 var c:Int { return self.a + self.b}<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         struct A:P {<br>&gt;&gt;                 private var a:Int = 5  // ‘A’ must implement, but it<br>&gt;&gt; doesn’t have to expose it externally<br>&gt;&gt;                 var b:Int = 2<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         struct B:P{<br>&gt;&gt;                 var a:Int = 3  // ‘B’ chooses to expose, which is ok too<br>&gt;&gt;                 var b:Int = 4<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         let ans = A().c  // 7<br>&gt;&gt;         let ohNo = A().a // Error!<br>&gt;&gt;<br>&gt;&gt; Basically ‘hidden’ in the protocol means that the implementor must<br>&gt;&gt; implement the property, but it is not required to expose it to the world.<br>&gt;&gt; I don’t really care whether that is spelled hidden, protected, or private,<br>&gt;&gt; but I would use this fairly often.<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/6ef5d152/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Protected Access</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>October  7, 2016 at 11:00:00pm</p></header><div class="content"><p>While that’s true, it’s pretty clearly a hack. Having this built into the language would not only be a lot more elegant, but could also prevent override-only methods from showing up in Xcode’s autocomplete.<br></p><p>Charles<br></p><p>&gt; On Oct 7, 2016, at 6:36 PM, Callionica (Swift) via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; For overridable, but not callable, you can use the technique outlined at http://www.callionica.com/developer/#swift-protected &lt;http://www.callionica.com/developer/#swift-protected&gt;<br>&gt; (give your method a parameter of a type that only the base class can create)<br>&gt; <br>&gt; On Friday, October 7, 2016, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; The discussion of private/fileprivate reminded me of other access modifier issues that have been bugging me.  I agree that the old system is better, but I am ambivalent about changing it back…<br>&gt; <br>&gt; What I pretty much constantly want is an access modifier which lets me access something from an extension (which is potentially in a different file), but otherwise have it be private.  The vast majority of my use of “fileprivate” is so that I can access internal properties/functions from an extension (which I am forced to place in the same file).<br>&gt; <br>&gt; Access from subclasses is a larger discussion, but I run into this most often with Structs and their extensions.<br>&gt; <br>&gt; <br>&gt; The other pieces which seem to be missing are modifiers which allow finer grained control of how class methods are overridden and used.<br>&gt; <br>&gt; It is a fairly common pattern in cocoa, for example, to have customization point methods which are designed to be overridden, but are not supposed to be called directly. Right now, this is enforced via documentation.  One potential solution is to have a @noExternalCall attribute which says that it can only be called from the class/subclass/extensions… but if you think about it, this is basically another view of the first issue. If we could mark that method as only visible within the class/subclasses/extensions, then the behavior we want just falls out naturally. It can’t be called externally, because no one on the outside can see it.<br>&gt; <br>&gt; I also occasionally run into this with protocols.  I find that I have a property on the protocol which is needed for default implementations, but I really want to make it private with respect to the protocol (and its inheritors/extensions).  That is, I want the implementor of the protocol to have visibility for that property, but not the caller of the protocol.  Right now, I have to expose it to everyone (which clutters my external API), and then note in documentation not to call those properties.<br>&gt; <br>&gt; Basically, I want to do the following:<br>&gt; <br>&gt;         protocol P {<br>&gt;                 hidden var a:Int<br>&gt;                 var b:Int<br>&gt;         }<br>&gt; <br>&gt;         extension P {<br>&gt;                 var c:Int { return self.a + self.b}<br>&gt;         }<br>&gt; <br>&gt;         struct A:P {<br>&gt;                 private var a:Int = 5  // ‘A’ must implement, but it doesn’t have to expose it externally<br>&gt;                 var b:Int = 2<br>&gt;         }<br>&gt; <br>&gt;         struct B:P{<br>&gt;                 var a:Int = 3  // ‘B’ chooses to expose, which is ok too<br>&gt;                 var b:Int = 4<br>&gt;         }<br>&gt; <br>&gt;         let ans = A().c  // 7<br>&gt;         let ohNo = A().a // Error!<br>&gt; <br>&gt; Basically ‘hidden’ in the protocol means that the implementor must implement the property, but it is not required to expose it to the world.  I don’t really care whether that is spelled hidden, protected, or private, but I would use this fairly often.<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161007/75bea796/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
