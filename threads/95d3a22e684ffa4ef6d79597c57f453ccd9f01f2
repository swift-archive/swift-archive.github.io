<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: Deinit for structs</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 23, 2015 at 03:00:00pm</p></header><div class="content"><p>Introduction:<br></p><p>This is a rather simple proposal, requesting that structs allow the ‘deinit’ destructor, as classes currently do.<br></p><p>Motivation:<br></p><p>Sometimes it is necessary to create an object that wraps a network connection (that needs to be closed when the object is destroyed), or that writes to a file on the disk (that has to be closed when the object is destroyed). Often these objects will implement a close() method, but in the case that the user forgets to call this before the object is disposed of, it is good to call it in deinit just in case. However, deinit currently is available only to classes and not to structs. This means that value types currently cannot be used for network and file-backed constructs. Given Swift’s emphasis on value types, it seems that it would be good to add this functionality to value types.<br></p><p>Proposed Solution:<br></p><p>Allow the deinit destructor in structs.<br></p><p>Impact on Existing Code:<br></p><p>Should be no impact on existing code.<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Pitch: Deinit for structs</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 23, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 1:07 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Introduction:<br>&gt; <br>&gt; This is a rather simple proposal, requesting that structs allow the ‘deinit’ destructor, as classes currently do.<br>&gt; <br>&gt; Motivation:<br>&gt; <br>&gt; Sometimes it is necessary to create an object that wraps a network connection (that needs to be closed when the object is destroyed), or that writes to a file on the disk (that has to be closed when the object is destroyed). Often these objects will implement a close() method, but in the case that the user forgets to call this before the object is disposed of, it is good to call it in deinit just in case. However, deinit currently is available only to classes and not to structs. This means that value types currently cannot be used for network and file-backed constructs. Given Swift’s emphasis on value types, it seems that it would be good to add this functionality to value types.<br></p><p>Network and file-backed constructs naturally have identity, so classes are appropriate. What benefit would you get from making them structs? What does it mean to copy a socket?<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Pitch: Deinit for structs</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 05:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 23, 2015, at 3:15 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 1:07 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Introduction:<br>&gt;&gt; <br>&gt;&gt; This is a rather simple proposal, requesting that structs allow the ‘deinit’ destructor, as classes currently do.<br>&gt;&gt; <br>&gt;&gt; Motivation:<br>&gt;&gt; <br>&gt;&gt; Sometimes it is necessary to create an object that wraps a network connection (that needs to be closed when the object is destroyed), or that writes to a file on the disk (that has to be closed when the object is destroyed). Often these objects will implement a close() method, but in the case that the user forgets to call this before the object is disposed of, it is good to call it in deinit just in case. However, deinit currently is available only to classes and not to structs. This means that value types currently cannot be used for network and file-backed constructs. Given Swift’s emphasis on value types, it seems that it would be good to add this functionality to value types.<br>&gt; <br>&gt; Network and file-backed constructs naturally have identity, so classes are appropriate. What benefit would you get from making them structs? What does it mean to copy a socket?<br>&gt; <br></p><p>I wonder if the goal is to avoid a heap allocation.  Under what circumstances can stack promotion be guaranteed for a final class?<br></p><p>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Pitch: Deinit for structs</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 23, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 3:16 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 3:15 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 23, 2015, at 1:07 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a rather simple proposal, requesting that structs allow the ‘deinit’ destructor, as classes currently do.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sometimes it is necessary to create an object that wraps a network connection (that needs to be closed when the object is destroyed), or that writes to a file on the disk (that has to be closed when the object is destroyed). Often these objects will implement a close() method, but in the case that the user forgets to call this before the object is disposed of, it is good to call it in deinit just in case. However, deinit currently is available only to classes and not to structs. This means that value types currently cannot be used for network and file-backed constructs. Given Swift’s emphasis on value types, it seems that it would be good to add this functionality to value types.<br>&gt;&gt; <br>&gt;&gt; Network and file-backed constructs naturally have identity, so classes are appropriate. What benefit would you get from making them structs? What does it mean to copy a socket?<br>&gt;&gt; <br>&gt; <br>&gt; I wonder if the goal is to avoid a heap allocation.  Under what circumstances can stack promotion be guaranteed for a final class?<br></p><p>cc&#39;ing Erik, who&#39;s working on stack promotion. We need to know the object&#39;s lifetime by proving it isn&#39;t escaped to somewhere that can extend its lifetime, which is hard to guarantee if you&#39;re calling functions from other modules. To guarantee a stack allocation it might be reasonable to have an attribute to say &quot;I want this object to be stack allocated, so assert that it&#39;s still uniquely referenced by the time it goes out of scope&quot; or something like that.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/e8ca5f35/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Pitch: Deinit for structs</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 5:25 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 23, 2015, at 3:16 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 23, 2015, at 3:15 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 23, 2015, at 1:07 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Introduction:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a rather simple proposal, requesting that structs allow the ‘deinit’ destructor, as classes currently do.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Motivation:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sometimes it is necessary to create an object that wraps a network connection (that needs to be closed when the object is destroyed), or that writes to a file on the disk (that has to be closed when the object is destroyed). Often these objects will implement a close() method, but in the case that the user forgets to call this before the object is disposed of, it is good to call it in deinit just in case. However, deinit currently is available only to classes and not to structs. This means that value types currently cannot be used for network and file-backed constructs. Given Swift’s emphasis on value types, it seems that it would be good to add this functionality to value types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Network and file-backed constructs naturally have identity, so classes are appropriate. What benefit would you get from making them structs? What does it mean to copy a socket?<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I wonder if the goal is to avoid a heap allocation.  Under what circumstances can stack promotion be guaranteed for a final class?<br>&gt; <br>&gt; cc&#39;ing Erik, who&#39;s working on stack promotion. We need to know the object&#39;s lifetime by proving it isn&#39;t escaped to somewhere that can extend its lifetime, which is hard to guarantee if you&#39;re calling functions from other modules. To guarantee a stack allocation it might be reasonable to have an attribute to say &quot;I want this object to be stack allocated, so assert that it&#39;s still uniquely referenced by the time it goes out of scope&quot; or something like that.<br></p><p>Thanks for looping in Erik.  An attribute would be cool.  I would guess stack promotion maybe be easier to guarantee if / when we have a Rust-like ownership system that could allow “borrowing” without transferring ownership as well.  Is that correct?<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/5b7b5b00/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Pitch: Deinit for structs</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 23, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 3:29 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 5:25 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 23, 2015, at 3:16 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 23, 2015, at 3:15 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 1:07 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Introduction:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is a rather simple proposal, requesting that structs allow the ‘deinit’ destructor, as classes currently do.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Motivation:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sometimes it is necessary to create an object that wraps a network connection (that needs to be closed when the object is destroyed), or that writes to a file on the disk (that has to be closed when the object is destroyed). Often these objects will implement a close() method, but in the case that the user forgets to call this before the object is disposed of, it is good to call it in deinit just in case. However, deinit currently is available only to classes and not to structs. This means that value types currently cannot be used for network and file-backed constructs. Given Swift’s emphasis on value types, it seems that it would be good to add this functionality to value types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Network and file-backed constructs naturally have identity, so classes are appropriate. What benefit would you get from making them structs? What does it mean to copy a socket?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wonder if the goal is to avoid a heap allocation.  Under what circumstances can stack promotion be guaranteed for a final class?<br>&gt;&gt; <br>&gt;&gt; cc&#39;ing Erik, who&#39;s working on stack promotion. We need to know the object&#39;s lifetime by proving it isn&#39;t escaped to somewhere that can extend its lifetime, which is hard to guarantee if you&#39;re calling functions from other modules. To guarantee a stack allocation it might be reasonable to have an attribute to say &quot;I want this object to be stack allocated, so assert that it&#39;s still uniquely referenced by the time it goes out of scope&quot; or something like that.<br>&gt; <br>&gt; Thanks for looping in Erik.  An attribute would be cool.  I would guess stack promotion maybe be easier to guarantee if / when we have a Rust-like ownership system that could allow “borrowing” without transferring ownership as well.  Is that correct?<br></p><p>That&#39;d certainly make it easier, if everything you interact with is correctly annotated. I think you&#39;d still want to be able to interop with code that hasn&#39;t been annotated with ownership conventions, or that needs to temporarily share ownership while still dynamically converging on a fixed lifetime.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/a3c7c28c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Pitch: Deinit for structs</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 23, 2015 at 01:00:00pm</p></header><div class="content"><p>This is something I asked for before, then I realized it wouldn’t work.<br></p><p>func helper(rs: ResourceHandle) {}<br></p><p>let resource = ResourceHandle()<br>helper(resource)<br></p><p>result.doSomething() // error<br></p><p>Another example:<br></p><p>let x = Handle()<br></p><p>do {<br>  let y = x<br>} // resources are freed here as deinit is called<br></p><p>// x is not safe to use, and freed again when x goes out of scope<br></p><p>Everytime the struct value goes out of scope, the deinit would be called. The other option is to create move and copy semantics, as both would be required.<br></p><p>&gt; Given Swift’s emphasis on value types<br></p><p>I think this is a mischaracterization, and one that I’ve made in the past. Swift’s emphasis in on clarity and providing you the mechanism to create things that are value-types for APIs that should behave like a value. However, that doesn’t mean that everything should a struct first.<br></p><p>-David<br></p><p>&gt; On Dec 23, 2015, at 1:07 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Introduction:<br>&gt; <br>&gt; This is a rather simple proposal, requesting that structs allow the ‘deinit’ destructor, as classes currently do.<br>&gt; <br>&gt; Motivation:<br>&gt; <br>&gt; Sometimes it is necessary to create an object that wraps a network connection (that needs to be closed when the object is destroyed), or that writes to a file on the disk (that has to be closed when the object is destroyed). Often these objects will implement a close() method, but in the case that the user forgets to call this before the object is disposed of, it is good to call it in deinit just in case. However, deinit currently is available only to classes and not to structs. This means that value types currently cannot be used for network and file-backed constructs. Given Swift’s emphasis on value types, it seems that it would be good to add this functionality to value types.<br>&gt; <br>&gt; Proposed Solution:<br>&gt; <br>&gt; Allow the deinit destructor in structs.<br>&gt; <br>&gt; Impact on Existing Code:<br>&gt; <br>&gt; Should be no impact on existing code.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/27bc0741/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Pitch: Deinit for structs</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 23, 2015 at 05:00:00pm</p></header><div class="content"><p>Just chiming in with you two: deinit for a struct doesn&#39;t really work because structs are copied and destroyed all the time. Putting a file descriptor in a struct (along with destruction logic) would fail pretty hard without C++-like copy/move semantics.<br></p><p>Félix<br></p><p>&gt; Le 23 déc. 2015 à 16:21:42, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; This is something I asked for before, then I realized it wouldn’t work.<br>&gt; <br>&gt; func helper(rs: ResourceHandle) {}<br>&gt; <br>&gt; let resource = ResourceHandle()<br>&gt; helper(resource)<br>&gt; <br>&gt; result.doSomething() // error<br>&gt; <br>&gt; Another example:<br>&gt; <br>&gt; let x = Handle()<br>&gt; <br>&gt; do {<br>&gt;   let y = x<br>&gt; } // resources are freed here as deinit is called<br>&gt; <br>&gt; // x is not safe to use, and freed again when x goes out of scope<br>&gt; <br>&gt; Everytime the struct value goes out of scope, the deinit would be called. The other option is to create move and copy semantics, as both would be required.<br>&gt; <br>&gt;&gt; Given Swift’s emphasis on value types<br>&gt; <br>&gt; I think this is a mischaracterization, and one that I’ve made in the past. Swift’s emphasis in on clarity and providing you the mechanism to create things that are value-types for APIs that should behave like a value. However, that doesn’t mean that everything should a struct first.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 1:07 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Introduction:<br>&gt;&gt; <br>&gt;&gt; This is a rather simple proposal, requesting that structs allow the ‘deinit’ destructor, as classes currently do.<br>&gt;&gt; <br>&gt;&gt; Motivation:<br>&gt;&gt; <br>&gt;&gt; Sometimes it is necessary to create an object that wraps a network connection (that needs to be closed when the object is destroyed), or that writes to a file on the disk (that has to be closed when the object is destroyed). Often these objects will implement a close() method, but in the case that the user forgets to call this before the object is disposed of, it is good to call it in deinit just in case. However, deinit currently is available only to classes and not to structs. This means that value types currently cannot be used for network and file-backed constructs. Given Swift’s emphasis on value types, it seems that it would be good to add this functionality to value types.<br>&gt;&gt; <br>&gt;&gt; Proposed Solution:<br>&gt;&gt; <br>&gt;&gt; Allow the deinit destructor in structs.<br>&gt;&gt; <br>&gt;&gt; Impact on Existing Code:<br>&gt;&gt; <br>&gt;&gt; Should be no impact on existing code.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/04ff3b83/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
