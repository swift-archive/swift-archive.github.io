<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/26f915253dca7b08d59b61c883ae2e54?s=50"></div><header><strong>[Idea] Syntactic sugar for using methods as functions</strong> from <string>admin at wheerd.de</string> &lt;admin at wheerd.de&gt;<p>June 27, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi everyone,<br></p><p>I was thinking it would be nice to have a similar short notation for<br>using methods in a functional way as there is for enum cases (and as<br>I&#39;ve been told static members in general).<br>Let me give a rather contrived example:<br></p><p>struct Foo {<br>    let bar: Int<br></p><p>    func getBar() -&gt; Int {<br>        return self.bar<br>    }<br></p><p>}<br></p><p>let foos = [Foo(bar: 1), Foo(bar: 2), Foo(bar: 3)]<br>let bars = foos.map{ $0.getBar() }<br></p><p>What I am suggesting is to add syntactic sugar to bridge the gap between<br>functional and object oriented programming. So instead you could write<br>the following:<br></p><p>let bars = foos.map(.getBar)<br></p><p>While for parameterless functions this might not seem like much of an<br>improvement, I think it helps when there are parameters involved:<br></p><p>struct Foo {<br>    let bar: Int<br>    <br>    func combine(other: Foo) -&gt; Foo {<br>        return Foo(bar: other.bar + self.bar)<br>    }<br>}<br></p><p>let foos = [Foo(bar: 5), Foo(bar: 6), Foo(bar: 1)]<br>let reduced = foos.reduce(Foo(bar: 0)) { $0.combine(other: $1) }<br></p><p>Which could become:<br></p><p>let reduced = foos.reduce(Foo(bar: 0), .combine)<br></p><p>This would also enable easier usage of custom operators for partial<br>functions etc. on these methods.<br></p><p>Basically whenever there is a parameter type (T, ...) -&gt; U somewhere,<br>one could write the prefix dot shortcut and the compiler would look for<br>a method in type T with a signature (...) -&gt; U and wrap the call to the<br>method in a closure. In case that no such method can be found or it<br>cannot be uniquely determined, it will result in a compile time error.<br></p><p>This is just an idea though. Do you think this would be useful? I could<br>see it help libraries like the Dollar library. It could then be used in<br>both functional and object oriented ways, since most functions could<br>become methods while maintaining a short syntax.<br></p><p><br>Kind regards, Manuel<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Idea] Syntactic sugar for using methods as functions</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>June 27, 2016 at 04:00:00pm</p></header><div class="content"><p>+1. This makes sense to me. <br></p><p>Since the API Guidelines say: “Prefer methods and properties to free functions”, it would make sense to add sugar like this to make methods just as convenient and clear to pass to higher order functions as free functions currently are.<br></p><p>I’m also wondering if the same syntactic sugar could work for property getters.<br></p><p>- David<br></p><p>&gt; On 27 Jun 2016, at 12:00, Manuel Krebber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; I was thinking it would be nice to have a similar short notation for<br>&gt; using methods in a functional way as there is for enum cases (and as<br>&gt; I&#39;ve been told static members in general).<br>&gt; Let me give a rather contrived example:<br>&gt; <br>&gt; struct Foo {<br>&gt;    let bar: Int<br>&gt; <br>&gt;    func getBar() -&gt; Int {<br>&gt;        return self.bar<br>&gt;    }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; let foos = [Foo(bar: 1), Foo(bar: 2), Foo(bar: 3)]<br>&gt; let bars = foos.map{ $0.getBar() }<br>&gt; <br>&gt; What I am suggesting is to add syntactic sugar to bridge the gap between<br>&gt; functional and object oriented programming. So instead you could write<br>&gt; the following:<br>&gt; <br>&gt; let bars = foos.map(.getBar)<br>&gt; <br>&gt; While for parameterless functions this might not seem like much of an<br>&gt; improvement, I think it helps when there are parameters involved:<br>&gt; <br>&gt; struct Foo {<br>&gt;    let bar: Int<br>&gt; <br>&gt;    func combine(other: Foo) -&gt; Foo {<br>&gt;        return Foo(bar: other.bar + self.bar)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; let foos = [Foo(bar: 5), Foo(bar: 6), Foo(bar: 1)]<br>&gt; let reduced = foos.reduce(Foo(bar: 0)) { $0.combine(other: $1) }<br>&gt; <br>&gt; Which could become:<br>&gt; <br>&gt; let reduced = foos.reduce(Foo(bar: 0), .combine)<br>&gt; <br>&gt; This would also enable easier usage of custom operators for partial<br>&gt; functions etc. on these methods.<br>&gt; <br>&gt; Basically whenever there is a parameter type (T, ...) -&gt; U somewhere,<br>&gt; one could write the prefix dot shortcut and the compiler would look for<br>&gt; a method in type T with a signature (...) -&gt; U and wrap the call to the<br>&gt; method in a closure. In case that no such method can be found or it<br>&gt; cannot be uniquely determined, it will result in a compile time error.<br>&gt; <br>&gt; This is just an idea though. Do you think this would be useful? I could<br>&gt; see it help libraries like the Dollar library. It could then be used in<br>&gt; both functional and object oriented ways, since most functions could<br>&gt; become methods while maintaining a short syntax.<br>&gt; <br>&gt; <br>&gt; Kind regards, Manuel<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Idea] Syntactic sugar for using methods as functions</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>June 27, 2016 at 08:00:00am</p></header><div class="content"><p>I don&#39;t have anything against it, besides that it is an additive feature and should probably wait for after Swift 3.<br></p><p>Félix<br></p><p>&gt; Le 27 juin 2016 à 07:22:42, David Rönnqvist via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; +1. This makes sense to me. <br>&gt; <br>&gt; Since the API Guidelines say: “Prefer methods and properties to free functions”, it would make sense to add sugar like this to make methods just as convenient and clear to pass to higher order functions as free functions currently are.<br>&gt; <br>&gt; I’m also wondering if the same syntactic sugar could work for property getters.<br>&gt; <br>&gt; - David<br>&gt; <br>&gt;&gt; On 27 Jun 2016, at 12:00, Manuel Krebber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi everyone,<br>&gt;&gt; <br>&gt;&gt; I was thinking it would be nice to have a similar short notation for<br>&gt;&gt; using methods in a functional way as there is for enum cases (and as<br>&gt;&gt; I&#39;ve been told static members in general).<br>&gt;&gt; Let me give a rather contrived example:<br>&gt;&gt; <br>&gt;&gt; struct Foo {<br>&gt;&gt;   let bar: Int<br>&gt;&gt; <br>&gt;&gt;   func getBar() -&gt; Int {<br>&gt;&gt;       return self.bar<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let foos = [Foo(bar: 1), Foo(bar: 2), Foo(bar: 3)]<br>&gt;&gt; let bars = foos.map{ $0.getBar() }<br>&gt;&gt; <br>&gt;&gt; What I am suggesting is to add syntactic sugar to bridge the gap between<br>&gt;&gt; functional and object oriented programming. So instead you could write<br>&gt;&gt; the following:<br>&gt;&gt; <br>&gt;&gt; let bars = foos.map(.getBar)<br>&gt;&gt; <br>&gt;&gt; While for parameterless functions this might not seem like much of an<br>&gt;&gt; improvement, I think it helps when there are parameters involved:<br>&gt;&gt; <br>&gt;&gt; struct Foo {<br>&gt;&gt;   let bar: Int<br>&gt;&gt; <br>&gt;&gt;   func combine(other: Foo) -&gt; Foo {<br>&gt;&gt;       return Foo(bar: other.bar + self.bar)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let foos = [Foo(bar: 5), Foo(bar: 6), Foo(bar: 1)]<br>&gt;&gt; let reduced = foos.reduce(Foo(bar: 0)) { $0.combine(other: $1) }<br>&gt;&gt; <br>&gt;&gt; Which could become:<br>&gt;&gt; <br>&gt;&gt; let reduced = foos.reduce(Foo(bar: 0), .combine)<br>&gt;&gt; <br>&gt;&gt; This would also enable easier usage of custom operators for partial<br>&gt;&gt; functions etc. on these methods.<br>&gt;&gt; <br>&gt;&gt; Basically whenever there is a parameter type (T, ...) -&gt; U somewhere,<br>&gt;&gt; one could write the prefix dot shortcut and the compiler would look for<br>&gt;&gt; a method in type T with a signature (...) -&gt; U and wrap the call to the<br>&gt;&gt; method in a closure. In case that no such method can be found or it<br>&gt;&gt; cannot be uniquely determined, it will result in a compile time error.<br>&gt;&gt; <br>&gt;&gt; This is just an idea though. Do you think this would be useful? I could<br>&gt;&gt; see it help libraries like the Dollar library. It could then be used in<br>&gt;&gt; both functional and object oriented ways, since most functions could<br>&gt;&gt; become methods while maintaining a short syntax.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Kind regards, Manuel<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/994b6b0c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Idea] Syntactic sugar for using methods as functions</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June 28, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 27 Jun 2016, at 11:00, Manuel Krebber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; I was thinking it would be nice to have a similar short notation for<br>&gt; using methods in a functional way as there is for enum cases (and as<br>&gt; I&#39;ve been told static members in general).<br>&gt; Let me give a rather contrived example:<br>&gt; <br>&gt; struct Foo {<br>&gt;    let bar: Int<br>&gt; <br>&gt;    func getBar() -&gt; Int {<br>&gt;        return self.bar<br>&gt;    }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; let foos = [Foo(bar: 1), Foo(bar: 2), Foo(bar: 3)]<br>&gt; let bars = foos.map{ $0.getBar() }<br>&gt; <br>&gt; What I am suggesting is to add syntactic sugar to bridge the gap between<br>&gt; functional and object oriented programming. So instead you could write<br>&gt; the following:<br>&gt; <br>&gt; let bars = foos.map(.getBar)<br></p><p>While I see some potential in this, I wonder if it&#39;s a bit too ambiguous at the moment, and might require a wider rethink of the dot shorthand; in the example above it&#39;s not clear at a glance that this references the .getBar method of elements, vs a property or method of foos, or self, or Self. Enums are kind of a special case, but they are at least a static member so there&#39;s a clearer case for them vs this example which is an instance member, which could lead to ambiguity.<br></p><p>I mean, I&#39;d be all for allowing this shorthand for instance members as well, but we&#39;d need to get around issues of this ambiguity, perhaps with a shorthand identifier for type? As pointed out, you can actually use Foo.getBar, but while this is fine for a type with such a short name, it&#39;s not convenient if your type name is much longer, meaning in many cases it will remain easiest to just do { $0.getBar() } or similar. If we could reserve a special type identifier, or use $T or something it might be easier, but it&#39;d need to be an elegant choice (I don&#39;t really like either of mine, it&#39;s just to give the idea).<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
