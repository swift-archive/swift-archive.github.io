<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7c131c370cf3332cf0ed8c7d71a63e21?s=50"></div><header><strong>Changing the curried static methods</strong> from <string>Brandon Williams</string> &lt;mbw234 at gmail.com&gt;<p>March 12, 2016 at 09:00:00pm</p></header><div class="content"><p>Right now instance methods on a type get a curried, static method for free,<br>e.g. CGRect.insetBy is a curried function CGRect -&gt; (CGFloat, CGFloat) -&gt;<br>CGRect. This is super cool and great for code reusability.<br></p><p>Unfortunately, I think the order of the curry makes it difficult to use<br>most of the time. With the above example you would use it as such:<br></p><p>CGRect.insetBy(rect)(10.0, 10.0)<br></p><p>That doesn’t read very nicely, and it’s more likely that you know (10.0,<br>10.0) before you know rect, hence you would want to call it as:<br></p><p>CGRect.insetBy(10.0, 10.0)(rect)<br></p><p>In general, I would expect a method:<br></p><p>struct A {<br>  func method &lt;B, C&gt; (b: B) -&gt; C<br>}<br></p><p>to have a static method of the form<br></p><p>A.method: B -&gt; A -&gt; C<br></p><p>Does this make sense? Is there a reason for the current design that I’m not<br>seeing?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160312/775a0cdf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Changing the curried static methods</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>March 12, 2016 at 03:00:00pm</p></header><div class="content"><p>Hm, I always justified the existing behavior to myself because it reminds me of how Objective-C passes parameters in method calls (i.e. you get self, [SEL], params).<br></p><p>~Robert Widmann<br></p><p>2016/03/12 14:46、Brandon Williams via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; Right now instance methods on a type get a curried, static method for free, e.g. CGRect.insetBy is a curried function CGRect -&gt; (CGFloat, CGFloat) -&gt; CGRect. This is super cool and great for code reusability. <br>&gt; <br>&gt; Unfortunately, I think the order of the curry makes it difficult to use most of the time. With the above example you would use it as such:<br>&gt; <br>&gt; CGRect.insetBy(rect)(10.0, 10.0)<br>&gt; <br>&gt; That doesn’t read very nicely, and it’s more likely that you know (10.0, 10.0) before you know rect, hence you would want to call it as:<br>&gt; <br>&gt; CGRect.insetBy(10.0, 10.0)(rect)<br>&gt; <br>&gt; In general, I would expect a method:<br>&gt; <br>&gt; struct A {<br>&gt;   func method &lt;B, C&gt; (b: B) -&gt; C<br>&gt; }<br>&gt; <br>&gt; to have a static method of the form<br>&gt; <br>&gt; A.method: B -&gt; A -&gt; C<br>&gt; <br>&gt; Does this make sense? Is there a reason for the current design that I’m not seeing?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Changing the curried static methods</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>March 13, 2016 at 02:00:00pm</p></header><div class="content"><p>A relegated issue is that it&#39;s complicated to use curried static methods with map &amp; foreach<br>(for example, this<br>view.subviews.forEach(UIView.removeFromSuperview)<br>doesn&#39;t work )<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160313/3dda4be8/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 2448 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160313/3dda4be8/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Changing the curried static methods</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>March 13, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Mar 13, 2016, at 9:17 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A relegated issue is that it&#39;s complicated to use curried static methods with map &amp; foreach<br>&gt; (for example, this<br>&gt; view.subviews.forEach(UIView.removeFromSuperview)<br>&gt; doesn&#39;t work )<br></p><p>With a final Void return value, wouldn&#39;t that just become the following?<br></p><p>    view.subviews.forEach(UIView.removeFromSuperview())<br></p><p>I have to wonder how common this pattern is, anyway, when the following is as short and arguably easier to read:<br></p><p>    view.subviews.forEach { $0.removeFromSuperview() }<br></p><p>Does the current convention give us anything else?<br></p><p>It&#39;s easy enough to define a `flip` library function that converts `A -&gt; B -&gt; C` to `B -&gt; A -&gt; C`, but I do see the latter being a more powerful default than the former, even if it&#39;s unconventional.<br></p><p>Stephen<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Changing the curried static methods</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 13, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 13, 2016, at 11:09 AM, Stephen Celis via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Mar 13, 2016, at 9:17 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; A relegated issue is that it&#39;s complicated to use curried static methods with map &amp; foreach<br>&gt;&gt; (for example, this<br>&gt;&gt; view.subviews.forEach(UIView.removeFromSuperview)<br>&gt;&gt; doesn&#39;t work )<br>&gt; <br>&gt; With a final Void return value, wouldn&#39;t that just become the following?<br>&gt; <br>&gt;    view.subviews.forEach(UIView.removeFromSuperview())<br>&gt; <br>&gt; I have to wonder how common this pattern is, anyway, when the following is as short and arguably easier to read:<br>&gt; <br>&gt;    view.subviews.forEach { $0.removeFromSuperview() }<br>&gt; <br>&gt; Does the current convention give us anything else?<br>&gt; <br>&gt; It&#39;s easy enough to define a `flip` library function that converts `A -&gt; B -&gt; C` to `B -&gt; A -&gt; C`, but I do see the latter being a more powerful default than the former, even if it&#39;s unconventional.<br></p><p><br></p><p>Since removeFromSuperview doesn&#39;t take a UIView argument, it sounds like what you&#39;re looking for is<br>something that acts like &quot;apply&quot;, to apply a lambda/closure/selector/whatever to each member of a collection.<br></p><p>view.subviews.apply(UIView.removeFromSuperview)<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Changing the curried static methods</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>March 13, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Mar 13, 2016, at 1:18 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; Since removeFromSuperview doesn&#39;t take a UIView argument, it sounds like what you&#39;re looking for is<br>&gt; something that acts like &quot;apply&quot;, to apply a lambda/closure/selector/whatever to each member of a collection.<br>&gt; <br>&gt; view.subviews.apply(UIView.removeFromSuperview)<br>&gt; <br>&gt; -- E<br></p><p>This is what `forEach` currently does with the existing curried static syntax, right?<br></p><p>I was more interested in the implications of an example brought up in the OP:<br></p><p>    frames.map(CGRect.insetBy(-10, -10))<br></p><p>- Stephen<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Changing the curried static methods</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 13, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 13, 2016, at 11:30 AM, Stephen Celis &lt;stephen.celis at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Mar 13, 2016, at 1:18 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Since removeFromSuperview doesn&#39;t take a UIView argument, it sounds like what you&#39;re looking for is<br>&gt;&gt; something that acts like &quot;apply&quot;, to apply a lambda/closure/selector/whatever to each member of a collection.<br>&gt;&gt; <br>&gt;&gt; view.subviews.apply(UIView.removeFromSuperview)<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt; <br>&gt; This is what `forEach` currently does with the existing curried static syntax, right?<br>&gt; <br>&gt; I was more interested in the implications of an example brought up in the OP:<br>&gt; <br>&gt;    frames.map(CGRect.insetBy(-10, -10))<br>&gt; <br>&gt; - Stephen<br></p><p>forEach currently does f(x).<br>apply would do x.f()<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7c131c370cf3332cf0ed8c7d71a63e21?s=50"></div><header><strong>Changing the curried static methods</strong> from <string>Brandon Williams</string> &lt;mbw234 at gmail.com&gt;<p>March 13, 2016 at 07:00:00pm</p></header><div class="content"><p>I think this highlights some of the confusion around the current curried<br>convention. Void methods are curried as A -&gt; () -&gt; (), which means you<br>would use it like:<br></p><p>UIView.removeFromSuperview # =&gt; UIView -&gt; () -&gt; ()<br>UIView.removeFromSuperview(view) # =&gt; () -&gt; ()<br>UIView.removeFromSuperview(view)() #&gt; ()<br></p><p>I find this confusing because removeFromSuperview reads as an action, yet<br>UIView.removeFromSuperview(view) does not perform the action but rather is<br>an action itself that requires a further invocation ().<br></p><p>With arguments flipped we would have:<br></p><p>UIView.removeFromSuperview # =&gt; () -&gt; UIView -&gt; ()<br>UIView.removeFromSuperview() # =&gt; UIView -&gt; ()<br>UIView.removeFromSuperview()(view) #&gt; ()<br></p><p>It now reads to me that UIView.removeFromSuperview() is the action that<br>will do the removing, and UIView.removeFromSuperview()(view) is applying<br>the action to a view.<br></p><p>I don’t advocate using removeFromSuperview in this manner, but if one were<br>to I believe the latter convention is easier to reason about without having<br>to look up types in a playground (as I had to do a few times to write this<br>:P)<br></p><p><br>On Sun, Mar 13, 2016 at 1:50 PM Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Mar 13, 2016, at 11:30 AM, Stephen Celis &lt;stephen.celis at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Mar 13, 2016, at 1:18 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Since removeFromSuperview doesn&#39;t take a UIView argument, it sounds<br>&gt; like what you&#39;re looking for is<br>&gt; &gt;&gt; something that acts like &quot;apply&quot;, to apply a<br>&gt; lambda/closure/selector/whatever to each member of a collection.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; view.subviews.apply(UIView.removeFromSuperview)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -- E<br>&gt; &gt;<br>&gt; &gt; This is what `forEach` currently does with the existing curried static<br>&gt; syntax, right?<br>&gt; &gt;<br>&gt; &gt; I was more interested in the implications of an example brought up in<br>&gt; the OP:<br>&gt; &gt;<br>&gt; &gt;    frames.map(CGRect.insetBy(-10, -10))<br>&gt; &gt;<br>&gt; &gt; - Stephen<br>&gt;<br>&gt; forEach currently does f(x).<br>&gt; apply would do x.f()<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160313/e453fa2e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Changing the curried static methods</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 13, 2016 at 01:00:00pm</p></header><div class="content"><p>I&#39;m probably missing the point here, so apologize in advance. Instead of reducing a function with an n-arity set of arguments to a partially applied function with (m|m&lt;n)-arity set of arguments, it&#39;s building a functional application and applying that to an arbitrary receiver.<br></p><p>	`UIView.removeFromSuperview(receiver) `<br></p><p>defines<br></p><p>	`receiver.removeFromSuperview`<br></p><p>which can then be applied with whatever arguments, () in this case.<br></p><p>	`UIView.removeFromSuperview(receiver)()` aka `receiver.removeFromSuperview()`<br></p><p>With mapping, you can do:<br></p><p>let v = UIView()<br>(1...5).forEach{_ in v.addSubview(UIView())}<br></p><p>// You can apply each subview as a receiver, returning a function<br>let applied = v.subviews.map(UIView.removeFromSuperview) <br>// [(Function), (Function), (Function), (Function), (Function)]<br></p><p>// And then you an execute them in forEach<br>print(v.subviews.count) // 5<br>v.subviews.map(UIView.removeFromSuperview).forEach{$0()}<br>print(v.subviews.count) // 0<br></p><p>The whole map/forEach could be defined down to apply in a possible language extension, as I mentioned before.<br></p><p>-- E, who apologizes for really not getting this<br></p><p><br>&gt; On Mar 13, 2016, at 1:21 PM, Brandon Williams &lt;mbw234 at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think this highlights some of the confusion around the current curried convention. Void methods are curried as A -&gt; () -&gt; (), which means you would use it like:<br>&gt; <br>&gt; UIView.removeFromSuperview # =&gt; UIView -&gt; () -&gt; ()<br>&gt; UIView.removeFromSuperview(view) # =&gt; () -&gt; ()<br>&gt; UIView.removeFromSuperview(view)() #&gt; ()<br>&gt; <br>&gt; I find this confusing because removeFromSuperview reads as an action, yet UIView.removeFromSuperview(view) does not perform the action but rather is an action itself that requires a further invocation ().<br>&gt; <br>&gt; With arguments flipped we would have:<br>&gt; <br>&gt; UIView.removeFromSuperview # =&gt; () -&gt; UIView -&gt; ()<br>&gt; UIView.removeFromSuperview() # =&gt; UIView -&gt; ()<br>&gt; UIView.removeFromSuperview()(view) #&gt; ()<br>&gt; <br>&gt; It now reads to me that UIView.removeFromSuperview() is the action that will do the removing, and UIView.removeFromSuperview()(view) is applying the action to a view.<br>&gt; <br>&gt; I don’t advocate using removeFromSuperview in this manner, but if one were to I believe the latter convention is easier to reason about without having to look up types in a playground (as I had to do a few times to write this :P)<br>&gt; <br>&gt; <br>&gt; On Sun, Mar 13, 2016 at 1:50 PM Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Mar 13, 2016, at 11:30 AM, Stephen Celis &lt;stephen.celis at gmail.com &lt;mailto:stephen.celis at gmail.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Mar 13, 2016, at 1:18 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Since removeFromSuperview doesn&#39;t take a UIView argument, it sounds like what you&#39;re looking for is<br>&gt; &gt;&gt; something that acts like &quot;apply&quot;, to apply a lambda/closure/selector/whatever to each member of a collection.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; view.subviews.apply(UIView.removeFromSuperview)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -- E<br>&gt; &gt;<br>&gt; &gt; This is what `forEach` currently does with the existing curried static syntax, right?<br>&gt; &gt;<br>&gt; &gt; I was more interested in the implications of an example brought up in the OP:<br>&gt; &gt;<br>&gt; &gt;    frames.map(CGRect.insetBy(-10, -10))<br>&gt; &gt;<br>&gt; &gt; - Stephen<br>&gt; <br>&gt; forEach currently does f(x).<br>&gt; apply would do x.f()<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160313/3578ac24/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7c131c370cf3332cf0ed8c7d71a63e21?s=50"></div><header><strong>Changing the curried static methods</strong> from <string>Brandon Williams</string> &lt;mbw234 at gmail.com&gt;<p>March 13, 2016 at 10:00:00pm</p></header><div class="content"><p>No problem Erica, I find this to be pretty subtle!<br></p><p>That&#39;s definitely how static versions of instance methods work today, and<br>it does it&#39;s job pretty well! My suggestion to flip the arguments is a bid<br>to increase the readability and re-usability of these methods without<br>changing any of the real semantics.<br></p><p>Here&#39;s how we can do it manually in order to see the benefits. The<br>following function:<br></p><p>func flip &lt;A, B, C&gt; (f: A -&gt; B -&gt; C) -&gt; B -&gt; A -&gt; C {<br>  return { b in { a in f(a)(b) } }<br>}<br></p><p>simply converts `A -&gt; B -&gt; C` to `B -&gt; A -&gt; C`, i.e. flips its arguments.<br>Let&#39;s use it make a version of `UIView.removeFromSuperview` that I think is<br>more understandable:<br></p><p>extension UIView {<br>  @nonobjc static let _removeFromSuperview =<br>flip(UIView.removeFromSuperview)<br>}<br></p><p>(ignore that @nonobjc, it&#39;s only necessary cause Swift is trying to<br>generate a dynamic accessor)<br></p><p>With this method your code example becomes<br></p><p>v.subviews.forEach(UIView._removeFromSuperview())<br></p><p>To me this reads: for each subview of `v`, apply the action<br>`UIView._removeFromSuperview()`. Compare this to the equivalent with<br>today&#39;s static method:<br></p><p>v.subviews.map(UIView.removeFromSuperview).forEach{ $0() }<br></p><p>This is read as: map the subviews of `v` into an array of actions, and then<br>invoke those actions.<br></p><p>The benefits of this flip are easier to see with different examples,<br>because I agree with Stephen that it&#39;s hard to beat a simple<br>`v.subviews.forEach { $0.removeSuperView() }` in this particular example.<br></p><p>If static methods had their arguments flipped, we&#39;d be able to easily<br>construct functions like `CGRect.insetBy(10.0, 10.0)` and<br>`CGRect.offsetBy(-20.0, 10.0)`. These are now free functions without any<br>mention to a specific rectangle. We could compose them to get a function<br>that simulataneously insets and translates, all without mentioning a<br>rectangle. With today&#39;s static methods we&#39;d have to apply `flip` to each<br>one, i.e. `flip(CGRect.insetBy)(10.0, 10.0)`.<br></p><p>This becomes very powerful with constructing data pipelines that describe<br>how to transform data without ever actually mentioning the data. There are<br>quite a few examples of things like this in Cocoa. A nice one is Core<br>Image, in which you can build a pipeline of filters that you can feed<br>images into.<br></p><p><br></p><p><br></p><p>On Sun, Mar 13, 2016 at 3:45 PM Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt; I&#39;m probably missing the point here, so apologize in advance. Instead of<br>&gt; reducing a function with an n-arity set of arguments to a partially applied<br>&gt; function with (m|m&lt;n)-arity set of arguments, it&#39;s building a functional<br>&gt; application and applying that to an arbitrary receiver.<br>&gt;<br>&gt; `UIView.removeFromSuperview(receiver) `<br>&gt;<br>&gt; defines<br>&gt;<br>&gt; `receiver.removeFromSuperview`<br>&gt;<br>&gt; which can then be applied with whatever arguments, () in this case.<br>&gt;<br>&gt; `UIView.removeFromSuperview(receiver)()` aka<br>&gt; `receiver.removeFromSuperview()`<br>&gt;<br>&gt; With mapping, you can do:<br>&gt;<br>&gt; let v = UIView()<br>&gt; (1...5).forEach{_ in v.addSubview(UIView())}<br>&gt;<br>&gt; // You can apply each subview as a receiver, returning a function<br>&gt; let applied = v.subviews.map(UIView.removeFromSuperview)<br>&gt; // [(Function), (Function), (Function), (Function), (Function)]<br>&gt;<br>&gt; // And then you an execute them in forEach<br>&gt; print(v.subviews.count) // 5<br>&gt; v.subviews.map(UIView.removeFromSuperview).forEach{$0()}<br>&gt; print(v.subviews.count) // 0<br>&gt;<br>&gt; The whole map/forEach could be defined down to apply in a possible<br>&gt; language extension, as I mentioned before.<br>&gt;<br>&gt; -- E, who apologizes for really not getting this<br>&gt;<br>&gt;<br>&gt; On Mar 13, 2016, at 1:21 PM, Brandon Williams &lt;mbw234 at gmail.com&gt; wrote:<br>&gt;<br>&gt; I think this highlights some of the confusion around the current curried<br>&gt; convention. Void methods are curried as A -&gt; () -&gt; (), which means you<br>&gt; would use it like:<br>&gt;<br>&gt; UIView.removeFromSuperview # =&gt; UIView -&gt; () -&gt; ()<br>&gt; UIView.removeFromSuperview(view) # =&gt; () -&gt; ()<br>&gt; UIView.removeFromSuperview(view)() #&gt; ()<br>&gt;<br>&gt; I find this confusing because removeFromSuperview reads as an action, yet<br>&gt; UIView.removeFromSuperview(view) does not perform the action but rather is<br>&gt; an action itself that requires a further invocation ().<br>&gt;<br>&gt; With arguments flipped we would have:<br>&gt;<br>&gt; UIView.removeFromSuperview # =&gt; () -&gt; UIView -&gt; ()<br>&gt; UIView.removeFromSuperview() # =&gt; UIView -&gt; ()<br>&gt; UIView.removeFromSuperview()(view) #&gt; ()<br>&gt;<br>&gt; It now reads to me that UIView.removeFromSuperview() is the action that<br>&gt; will do the removing, and UIView.removeFromSuperview()(view) is applying<br>&gt; the action to a view.<br>&gt;<br>&gt; I don’t advocate using removeFromSuperview in this manner, but if one were<br>&gt; to I believe the latter convention is easier to reason about without having<br>&gt; to look up types in a playground (as I had to do a few times to write this<br>&gt; :P)<br>&gt;<br>&gt;<br>&gt; On Sun, Mar 13, 2016 at 1:50 PM Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Mar 13, 2016, at 11:30 AM, Stephen Celis &lt;stephen.celis at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Mar 13, 2016, at 1:18 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Since removeFromSuperview doesn&#39;t take a UIView argument, it sounds<br>&gt;&gt; like what you&#39;re looking for is<br>&gt;&gt; &gt;&gt; something that acts like &quot;apply&quot;, to apply a<br>&gt;&gt; lambda/closure/selector/whatever to each member of a collection.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; view.subviews.apply(UIView.removeFromSuperview)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; -- E<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This is what `forEach` currently does with the existing curried static<br>&gt;&gt; syntax, right?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I was more interested in the implications of an example brought up in<br>&gt;&gt; the OP:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;    frames.map(CGRect.insetBy(-10, -10))<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; - Stephen<br>&gt;&gt;<br>&gt;&gt; forEach currently does f(x).<br>&gt;&gt; apply would do x.f()<br>&gt;&gt;<br>&gt;&gt; -- E<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160313/830efcc4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Changing the curried static methods</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 13, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; If static methods had their arguments flipped, we&#39;d be able to easily construct functions like `CGRect.insetBy(10.0, 10.0)` and `CGRect.offsetBy(-20.0, 10.0)`. These are now free functions without any mention to a specific rectangle. We could compose them to get a function that simulataneously insets and translates, all without mentioning a rectangle. With today&#39;s static methods we&#39;d have to apply `flip` to each one, i.e. `flip(CGRect.insetBy)(10.0, 10.0)`.<br>&gt; <br>&gt; This becomes very powerful with constructing data pipelines that describe how to transform data without ever actually mentioning the data. There are quite a few examples of things like this in Cocoa. A nice one is Core Image, in which you can build a pipeline of filters that you can feed images into.<br>&gt; <br></p><p>By your description, it sort of sounds like you could want to create a method cascade:<br></p><p>myRect<br>   ..insetBy(args)<br>   ..offsetBy(args)<br></p><p>In this, the instance passes through each of the function calls, joining them into a fluent declaration<br>with an implicit receiver.<br></p><p>But it also sounds like you want to use functional chaining. Core Image can chain because it always has <br>inputImage and outputImage and set defaults:<br></p><p>myRect = myRect.insetBy(args).offsetBy(args)<br></p><p>Alternative, you could be doing some kind of weird chaining thing where so long as the output and inputs match<br>up they can be composed together:<br></p><p>f = (x: insetByAble).insetBy(args)-&gt;(T:offsetByAble).offsetBy(args)-&gt;U<br>myRect = f(myRect)<br></p><p>But in the end, it kind of almost really sounds like you just want to write a function<br></p><p>f(x: CGRect) -&gt; CGRect {<br>   x.insetBy(10.0, 10.0)<br>   x.offsetBy(-20.0, 10.0)<br>   return x<br>}<br></p><p>Which of these are you aiming for?<br>            <br>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7c131c370cf3332cf0ed8c7d71a63e21?s=50"></div><header><strong>Changing the curried static methods</strong> from <string>Brandon Williams</string> &lt;mbw234 at gmail.com&gt;<p>March 14, 2016 at 02:00:00pm</p></header><div class="content"><p>Sorry for the confusion, I’m not looking for help to model something in<br>particular. These are examples to show the difference between the current<br>curried static convention and the one I think is more expressive.<br></p><p>To iterate, right now CGRect.insetBy(rect)(insets) just reads incorrectly<br>to me. Considering that Swift aims to be expressive through method names<br>and argument labels, I would expect this to be CGRect.insetBy(insets)(rect).<br></p><p><br>On Sun, Mar 13, 2016 at 10:54 PM Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt; &gt; If static methods had their arguments flipped, we&#39;d be able to easily<br>&gt; construct functions like `CGRect.insetBy(10.0, 10.0)` and<br>&gt; `CGRect.offsetBy(-20.0, 10.0)`. These are now free functions without any<br>&gt; mention to a specific rectangle. We could compose them to get a function<br>&gt; that simulataneously insets and translates, all without mentioning a<br>&gt; rectangle. With today&#39;s static methods we&#39;d have to apply `flip` to each<br>&gt; one, i.e. `flip(CGRect.insetBy)(10.0, 10.0)`.<br>&gt; &gt;<br>&gt; &gt; This becomes very powerful with constructing data pipelines that<br>&gt; describe how to transform data without ever actually mentioning the data.<br>&gt; There are quite a few examples of things like this in Cocoa. A nice one is<br>&gt; Core Image, in which you can build a pipeline of filters that you can feed<br>&gt; images into.<br>&gt; &gt;<br>&gt;<br>&gt; By your description, it sort of sounds like you could want to create a<br>&gt; method cascade:<br>&gt;<br>&gt; myRect<br>&gt;    ..insetBy(args)<br>&gt;    ..offsetBy(args)<br>&gt;<br>&gt; In this, the instance passes through each of the function calls, joining<br>&gt; them into a fluent declaration<br>&gt; with an implicit receiver.<br>&gt;<br>&gt; But it also sounds like you want to use functional chaining. Core Image<br>&gt; can chain because it always has<br>&gt; inputImage and outputImage and set defaults:<br>&gt;<br>&gt; myRect = myRect.insetBy(args).offsetBy(args)<br>&gt;<br>&gt; Alternative, you could be doing some kind of weird chaining thing where so<br>&gt; long as the output and inputs match<br>&gt; up they can be composed together:<br>&gt;<br>&gt; f = (x: insetByAble).insetBy(args)-&gt;(T:offsetByAble).offsetBy(args)-&gt;U<br>&gt; myRect = f(myRect)<br>&gt;<br>&gt; But in the end, it kind of almost really sounds like you just want to<br>&gt; write a function<br>&gt;<br>&gt; f(x: CGRect) -&gt; CGRect {<br>&gt;    x.insetBy(10.0, 10.0)<br>&gt;    x.offsetBy(-20.0, 10.0)<br>&gt;    return x<br>&gt; }<br>&gt;<br>&gt; Which of these are you aiming for?<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/a685e976/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Changing the curried static methods</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 14, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 14, 2016, at 8:39 AM, Brandon Williams &lt;mbw234 at gmail.com&gt; wrote:<br>&gt; <br>&gt; Sorry for the confusion, I’m not looking for help to model something in particular. These are examples to show the difference between the current curried static convention and the one I think is more expressive.<br>&gt; <br>&gt; To iterate, right now CGRect.insetBy(rect)(insets) just reads incorrectly to me. Considering that Swift aims to be expressive through method names and argument labels, I would expect this to be CGRect.insetBy(insets)(rect).<br>&gt; <br></p><p>Ah. I think I finally understand what you&#39;re getting at.<br></p><p>You&#39;d like to be able to create a version of the call *with arguments* before applying the call to a receiver. Right?<br></p><p>But isn&#39;t currying in that form dead? Or is the Class.member(instance) currying going to persist into Swift 3?<br></p><p>-- E<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Changing the curried static methods</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 14, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 12, 2016, at 1:46 PM, Brandon Williams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Right now instance methods on a type get a curried, static method for free, e.g. CGRect.insetBy is a curried function CGRect -&gt; (CGFloat, CGFloat) -&gt; CGRect. This is super cool and great for code reusability. <br>&gt; <br>&gt; Unfortunately, I think the order of the curry makes it difficult to use most of the time. With the above example you would use it as such:<br>&gt; <br>&gt; CGRect.insetBy(rect)(10.0, 10.0)<br>&gt; <br>&gt; That doesn’t read very nicely, and it’s more likely that you know (10.0, 10.0) before you know rect, hence you would want to call it as:<br>&gt; <br>&gt; CGRect.insetBy(10.0, 10.0)(rect)<br>&gt; <br>&gt; In general, I would expect a method:<br>&gt; <br>&gt; struct A {<br>&gt;   func method &lt;B, C&gt; (b: B) -&gt; C<br>&gt; }<br>&gt; <br>&gt; to have a static method of the form<br>&gt; <br>&gt; A.method: B -&gt; A -&gt; C<br>&gt; <br>&gt; Does this make sense? Is there a reason for the current design that I’m not seeing?<br></p><p>Note that there&#39;s a proposal open to flatten away the currying altogether:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0042-flatten-method-types.md<br></p><p>I agree that it would often be more useful to bind the non-self arguments first. Maybe we could provide a different shorthand for that, though; a number of people for instance have suggested `.insetBy(10.0, 10.0)` as a possibility.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/ed32df70/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7c131c370cf3332cf0ed8c7d71a63e21?s=50"></div><header><strong>Changing the curried static methods</strong> from <string>Brandon Williams</string> &lt;mbw234 at gmail.com&gt;<p>March 14, 2016 at 05:00:00pm</p></header><div class="content"><p>Ah, thanks for the reference. I wasn’t aware of that proposal.<br></p><p>I wish currying wasn’t going away, but aside from that I think there’s<br>still a strong case for flipping the arguments since it simply reads better<br>for the arguments to follow the name of the method.<br></p><p><br></p><p><br>On Mon, Mar 14, 2016 at 1:09 PM Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Mar 12, 2016, at 1:46 PM, Brandon Williams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Right now instance methods on a type get a curried, static method for<br>&gt; free, e.g. CGRect.insetBy is a curried function CGRect -&gt; (CGFloat,<br>&gt; CGFloat) -&gt; CGRect. This is super cool and great for code reusability.<br>&gt;<br>&gt; Unfortunately, I think the order of the curry makes it difficult to use<br>&gt; most of the time. With the above example you would use it as such:<br>&gt;<br>&gt; CGRect.insetBy(rect)(10.0, 10.0)<br>&gt;<br>&gt; That doesn’t read very nicely, and it’s more likely that you know (10.0,<br>&gt; 10.0) before you know rect, hence you would want to call it as:<br>&gt;<br>&gt; CGRect.insetBy(10.0, 10.0)(rect)<br>&gt;<br>&gt; In general, I would expect a method:<br>&gt;<br>&gt; struct A {<br>&gt;   func method &lt;B, C&gt; (b: B) -&gt; C<br>&gt; }<br>&gt;<br>&gt; to have a static method of the form<br>&gt;<br>&gt; A.method: B -&gt; A -&gt; C<br>&gt;<br>&gt; Does this make sense? Is there a reason for the current design that I’m<br>&gt; not seeing?<br>&gt;<br>&gt;<br>&gt; Note that there&#39;s a proposal open to flatten away the currying altogether:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0042-flatten-method-types.md<br>&gt;<br>&gt;<br>&gt; I agree that it would often be more useful to bind the non-self arguments<br>&gt; first. Maybe we could provide a different shorthand for that, though; a<br>&gt; number of people for instance have suggested `.insetBy(10.0, 10.0)` as a<br>&gt; possibility.<br>&gt;<br>&gt; -Joe<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/23ad4a4a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Changing the curried static methods</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>March 15, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Mar 14, 2016, at 1:09 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Note that there&#39;s a proposal open to flatten away the currying altogether:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0042-flatten-method-types.md<br>&gt; <br>&gt; I agree that it would often be more useful to bind the non-self arguments first. Maybe we could provide a different shorthand for that, though; a number of people for instance have suggested `.insetBy(10.0, 10.0)` as a possibility.<br></p><p>Interesting proposal! Is there a migration path for code that takes advantage of the current currying? The following is a convoluted example, but I&#39;ve appreciated the flexibility in actual code:<br></p><p>  func flip&lt;A, B, C&gt;(input: A -&gt; B -&gt; C) -&gt; B -&gt; A -&gt; C {<br>    return { b in { a in input(a)(b) } }<br>  }<br>  let insetBy = flip(CGRect.insetBy)<br>  let grow = { insetBy((-$0, -$0)) }<br>  grow(50)(.zero)<br></p><p><br>- Stephen<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
