<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  3, 2016 at 12:00:00pm</p></header><div class="content"><p>on Sat Apr 30 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; Second, this proposal should explain why it&#39;s reinventing the wheel<br>&gt;&gt; instead of standardizing existing, very successful, prior art.<br>&gt; Answer<br>&gt;&gt; the question: “what compelling advantages does this syntax have over<br>&gt;&gt; Python&#39;s?”<br>&gt;<br>&gt; Sure.<br>&gt;<br>&gt; First of all, I will admit up front that I have not written much<br>&gt; Python (a couple weeks ago, &quot;much&quot; would have been &quot;any&quot;) and I may<br>&gt; not fully understand their string literals. So I&#39;ll start by<br>&gt; describing my understanding of the design in question; then I&#39;ll<br>&gt; critique the design as I understand it. So if something in this<br>&gt; section is wrong, please forgive any related mistakes in the critique.<br>&gt;<br>&gt; Python offers a `&quot;&quot;&quot;` string which is almost the same as the `&quot;`<br>&gt; string:<br>&gt;<br>&gt; 	* Every character between the first `&quot;&quot;&quot;` and the second `&quot;&quot;&quot;`<br>&gt; is part of its contents.<br>&gt; 	* Escapes are processed normally.<br>&gt; 	* There is no special behavior with regards to whitespace.<br>&gt;<br>&gt; The only difference is that a `&quot;&quot;&quot;` string allows real, unescaped<br>&gt; newlines in it, while a `&quot;` string forbids them. (And, of course,<br>&gt; since the delimiter is `&quot;&quot;&quot;`, the strings `&quot;` and `&quot;&quot;` are interpreted<br>&gt; literally.)<br></p><p>IMO you really can&#39;t consider `&quot;&quot;&quot;` without `r`-prefixed raw strings,<br>and the apostrophe (single-quote) variants, and how they all compose.<br></p><p>&gt; This approach is really simple, which is a plus, but it has a number<br>&gt; of issues.<br>&gt;<br>&gt; CONTENT FORMATTING<br>&gt;<br>&gt; A number of aspects of the design combine to make `&quot;&quot;&quot;` strings harder<br>&gt; to read than they should be:<br>&gt;<br>&gt; 	* You can&#39;t indent the contents of a `&quot;&quot;&quot;` string to match the<br>&gt; code it&#39;s in. This is actually pretty shocking considering how<br>&gt; sensitive Python is to indentation, and it necessitates a number of<br>&gt; strange hacks (for instance, Python&#39;s `help()` function unindents all<br>&gt; but the first line of doc strings).<br></p><p>True, but there&#39;s a standard function for stripping off the extra<br>indentation, if that&#39;s important to you.  In some use-cases, it makes<br>sense, but I wouldn&#39;t say it&#39;s uniformly desirable to add indentation to<br>a multiline string literal in the first place.<br></p><p>&gt; 	* You can&#39;t put all of the contents against the left margin,<br>&gt; either, because a newline right after the `&quot;&quot;&quot;` is counted as part of<br>&gt; the string&#39;s contents. (You can use a backslash to work around this.)<br></p><p>Meh.<br></p><p>&quot;&quot;&quot;<br>stringContents<br>&quot;&quot;&quot;[1:]<br></p><p>works fine if a leading newline is important to avoid.<br></p><p>&gt; * The last line of the string also has to have the delimiter in it,<br>&gt; because again, a newline right before the `&quot;&quot;&quot;`is counted as part of<br>&gt; the string&#39;s contents. (You can use a backslash to work around this,<br>&gt; but the backslash is *not* in the mirror position of the start of the<br>&gt; string, so good luck remembering it.)<br></p><p>Meh.<br></p><p>&quot;&quot;&quot;<br>stringContents<br>&quot;&quot;&quot;[1:-1]<br></p><p>works fine if leading and trailing newlines are important to avoid.  In<br>my experience with real use-cases, extra newlines are very seldom<br>harmful.<br></p><p>&gt; In other words, the first and last lines have to be adulterated by<br>&gt; adding a `&quot;&quot;&quot;`, and the middle lines can&#39;t be indented to line up with<br>&gt; either the surrounding code or the beginning of the first line. If one<br>&gt; of the selling points of this feature is that you just stick your<br>&gt; contents in verbatim without alteration, that isn&#39;t great.<br></p><p>This argument doesn&#39;t make any sense to me.  You *do* just stick your<br>contents in (between `&quot;&quot;&quot;`s) without alteration. The fact that you may<br>see the quotes on the same line as the content doesn&#39;t change that.<br></p><p>&gt; This is such a problem that, in researching `&quot;&quot;&quot;` to be sure I<br>&gt; understood how it works, I came across a Stack Overflow question whose<br>&gt; answers are full of people recommending a different, more highly<br>&gt; punctuated, feature instead:<br>&gt; &lt;http://stackoverflow.com/questions/1520548/how-does-pythons-triple-quote-string-work&gt;<br></p><p>That&#39;s because the OP didn&#39;t *want* a multiline string in the first<br>place.  The answer he wanted contained *no newlines*.  He merely picked<br>the wrong tool for the job.  This is a very weak argument against `&quot;&quot;&quot;`.<br></p><p>&gt; (There is an alternate design which would fix the beginning and end<br>&gt; problems: make a newline after the opening delimiter and before the<br>&gt; closing delimiter mandatory and part of the delimiter. You might then<br>&gt; choose to fix the indentation problem by taking the whitespace between<br>&gt; the closing delimiter and the newline before it as the amount of<br>&gt; indentation for the entire string, and removing that much indentation<br>&gt; from each line. But that&#39;s not what Python does, and it&#39;s not what you<br>&gt; seem to be proposing.)<br>&gt;<br>&gt; BREAKING UP EXPRESSIONS<br>&gt;<br>&gt; String literals are expressions, and in fact, they are expressions<br>&gt; with no side effects. To do anything useful, they *must* be put into a<br>&gt; larger expression. Often this expression is an assignment, but it<br>&gt; could be anything—concatenation, method call, function parameter, you<br>&gt; name it.<br></p><p>How is this different from array literals?<br></p><p>&gt; This creates a challenge for multiline strings, because they can<br>&gt; become very large and effectively break up the expression they&#39;re<br>&gt; in. The continuation-quote-based multiline strings I&#39;m proposing are<br>&gt; aimed primarily at relatively short strings*, where this is less of a<br>&gt; concern. <br></p><p>Why are relatively short strings the right target for a multiline string<br>proposal?  I think this really goes to the crux of the question: **what<br>is the use case you&#39;re aiming at, how does this proposal address that<br>use case, and why is that use-case more important than others**.?<br></p><p>&gt; But `&quot;&quot;&quot;` aims to be used not only for short strings, but for ones<br>&gt; which may be many dozens or even hundreds of lines long. You&#39;re going<br>&gt; to end up with code like:<br>&gt;<br>&gt; 	print(&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; 	&lt;catalog&gt;<br>&gt; 		&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt; 			...<br>&gt; 			...<br>&gt; 			...a hundred more lines of XML with<br>&gt; interpolations in it...<br>&gt; 			...<br>&gt; 			...<br>&gt; 		&lt;/book&gt;<br>&gt; 	&lt;/catalog&gt;&quot;&quot;&quot;)<br>&gt;<br>&gt; What does that `)` mean? Who knows? We saw the beginning of the<br>&gt; expression an hour and a half ago. (It&#39;s common to avoid this issue by<br>&gt; assigning the string to a constant even if it&#39;s only going to be used<br>&gt; once, but that just changes the problem a little—now you&#39;re trying to<br>&gt; remember the name of a local variable declared a hundred lines ago.)<br></p><p>This seems to be an argument that one shouldn&#39;t create large literals of<br>any kind.<br></p><p>&gt; Heredocs cleverly avoid this issue by not trying to put the literal&#39;s<br>&gt; contents in the middle of the expression. Instead, they put a short<br>&gt; placeholder in the expression, then start the contents on the next<br>&gt; line. The expression is readable as an expression, while the contents<br>&gt; of the literal are adjacent but separate. That&#39;s why I think they&#39;re a<br>&gt; better solution than `&quot;&quot;&quot;` for truly massive string literals.<br></p><p>I don&#39;t see how this addresses your complaint.  By the time you get to<br>the closing delimiter you&#39;ve still lost track of any context and you<br>don&#39;t know how the string is being used.  Furthermore, there&#39;s no reason<br>to think you&#39;ll even recognize the closing delimiter.<br></p><p>&gt; * This is something I am not saying in the proposal, but I really<br>&gt; should.<br>&gt;<br>&gt; NESTING<br>&gt;<br>&gt; Another problem is that you don&#39;t get another choice besides<br>&gt; `&quot;&quot;&quot;`. That&#39;s not so bad, though, right? It&#39;s such an uncommon<br>&gt; sequence of characters, surely you&#39;ll never encounter it?<br>&gt;<br>&gt; Well, sure...until you try to generate code.<br>&gt;<br>&gt; For instance, suppose you&#39;re writing a web app using a barebones Swift<br>&gt; framework and you have a lot of code like this:<br>&gt;<br>&gt; 	response.send(&quot;&quot;&quot;&lt;tr&gt;<br>&gt; 		&lt;td&gt;\(name)&lt;/td&gt;<br>&gt; 		&lt;td&gt;\(value)&lt;/td&gt;<br>&gt; 	&lt;/tr&gt;<br>&gt; 	&quot;&quot;&quot;)<br>&gt;<br>&gt; Every 90s Perl hacker knows what a pain this is, <br></p><p>Sorry, where&#39;s the pain here?<br></p><p>&gt; and every 90s Perl hacker knows the solution: a template language.<br></p><p>You mean https://github.com/apple/swift/blob/master/utils/gyb.py?<br>;-)<br></p><p>&gt; Hack together some kind of simple syntax for embedding commands in a<br>&gt; file of content, and then convert it into runnable code with a tool<br>&gt; that does things like:<br>&gt;<br>&gt; 	print(&quot;&quot;&quot;<br>&gt; 	response.send(&quot;&quot;&quot;\(escapedContent)&quot;&quot;&quot;)<br>&gt; 	&quot;&quot;&quot;)<br>&gt;<br>&gt; ...oh. Wait a minute there.<br></p><p>You seem to understand what you&#39;re saying here, but I don&#39;t get it.  I<br>truly don&#39;t understand why you&#39;d use `&quot;&quot;&quot;` strings for generalized<br>substitutions like this in your template language.  You get to design<br>the language.<br></p><p>&gt; To get around this, you really need to support, not two delimiters,<br>&gt; but *n* delimiters. Heredocs let you choose an arbitrary<br>&gt; delimiter. C++ lets you augment the delimiter with arbitrary<br>&gt; characters. Perl&#39;s `qq` construct lets you choose a single character,<br>&gt; but it can be almost anything you want (and some of them nest). I&#39;m<br>&gt; thinking about letting you extend the delimiter with an arbitrary<br>&gt; number of underscores. All of these solutions have in common that they<br>&gt; don&#39;t just have &quot;primary&quot; and &quot;alternate&quot; delimiters, but an<br>&gt; effectively endless number of them.<br>&gt;<br>&gt; `&quot;&quot;&quot;` does not have this feature—you just have the primary delimiter<br>&gt; and the alternate delimiter, and if neither of them works for you, you<br>&gt; have to escape. That isn&#39;t ideal.<br>&gt;<br>&gt; RUNAWAY LITERALS<br>&gt;<br>&gt; `&quot;&quot;&quot;` does not offer much help with preventing or diagnosing runaway<br>&gt; literals or highlighting code with half-written literals. Heredocs<br>&gt; don&#39;t either, but I envision heredocs being used less often than `&quot;&quot;&quot;`<br>&gt; strings would be, since continuation quotes would handle shorter<br>&gt; strings.<br>&gt;<br>&gt; SYNTAX HIGHLIGHTING<br>&gt;<br>&gt; So, let&#39;s talk about this:<br>&gt;<br>&gt;&gt;&gt;  (like Python&#39;s &quot;&quot;&quot; strings) which trick some syntax<br>&gt;&gt;&gt; highlighters into working some of the time with some contents, we<br>&gt; don&#39;t think<br>&gt;&gt;&gt; this occasional, accidental compatibility is a big enough gain to<br>&gt; justify<br>&gt;&gt;&gt;  changing the design.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve never seen a syntax highlighter have problems with it, I don&#39;t<br>&gt; see<br>&gt;&gt; how it *could* ever cause a problem, and lastly I think it&#39;s both<br>&gt; naïve<br>&gt;&gt; and presumptuous to call these effects accidental.<br>&gt;<br>&gt; I call these effects &quot;accidental&quot; because the syntax highlighter was<br>&gt; not designed to handle the `&quot;&quot;&quot;`; it just happens to handle it<br>&gt; correctly because it misinterprets a `&quot;&quot;&quot;` string as an empty `&quot;`<br>&gt; string, followed by a non-empty `&quot;` string, followed by another empty<br>&gt; `&quot;` string. It&#39;s &quot;accidental&quot; from the perspective of the syntax<br>&gt; highlighter designer, not the language designer, who probably intended<br>&gt; that to happen.<br>&gt;<br>&gt; And it only works in a specific subset of cases. It breaks if:<br>&gt;<br>&gt; * The syntax highlighter tries to apply smarter per-language rules.<br>&gt; * The syntax highlighter assumes that strings are not allowed to be<br>&gt; multi-line. (This is true of many languages, including C derivatives<br>&gt; and Swift 2.)<br>&gt; * The string literal contains any `&quot;` characters, which `&quot;&quot;&quot;` is often<br>&gt; used in order to permit.<br></p><p>Okay, that&#39;s fair.<br></p><p>&gt; * The string literal contains any escapes or special features that the<br>&gt; syntax highlighter misinterprets, like an interpolation which itself<br>&gt; contains a string literal.<br>&gt;<br>&gt; Yes, it will often work, or at least sort-of work. But I just don&#39;t<br>&gt; see that as very valuable.<br>&gt;<br>&gt; WHAT&#39;S GOOD ABOUT `&quot;&quot;&quot;`?<br>&gt;<br>&gt; In my opinion, the best thing about `&quot;&quot;&quot;` (the language feature) is<br>&gt; `&quot;&quot;&quot;` (the token).<br>&gt;<br>&gt; A sequence of three quote marks is a fantastic token for a feature<br>&gt; meant to create long string literals. It clearly has something to do<br>&gt; with string literals, but it cannot be an empty string, because there<br>&gt; are too many quote marks—that is, it&#39;s too long. It&#39;s a really clever<br>&gt; mnemonic which also parses unambiguously.<br>&gt;<br>&gt; I&#39;ve spoken before in this thread and others about potentially using<br>&gt; `&quot;&quot;&quot;` as an alternate delimiter (which could be extended to `&quot;&quot;&quot;&quot;&quot;`<br>&gt; and beyond). I&#39;m also considering the idea that it might be a good<br>&gt; token for a Perl-style heredoc syntax:<br>&gt;<br>&gt; 	print(&quot;&quot;&quot; + e&quot;&quot;&quot;)<br>&gt; 	It was a dark and stormy \(timeOfDay) when <br>&gt; 	&quot;&quot;&quot;<br>&gt; 	the Swift core team invented the \(interpolation) syntax.<br>&gt; 	&quot;&quot;&quot;<br>&gt;<br>&gt; Nesting could be achieved with a version of whatever alternate<br>&gt; delimiter syntax we use for `&quot;` strings. For instance, if we adopted<br>&gt; the `_&quot;foo&quot;_` syntax I sketched:<br>&gt;<br>&gt; 	print(_&quot;&quot;&quot;_)<br>&gt; 	response.send(&quot;&quot;&quot;)<br>&gt; 	\(escapedContent)<br>&gt; 	&quot;&quot;&quot;<br>&gt; 	_&quot;&quot;&quot;_<br>&gt;<br>&gt; (P.S. If this post seems way too long to have been written in a couple<br>&gt; hours, that&#39;s because I&#39;ve been drafting a version of it on and off<br>&gt; for a day or two; it just so happened that Dave directly asked me to<br>&gt; confront `&quot;&quot;&quot;` today.)<br></p><p>-- <br>Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
