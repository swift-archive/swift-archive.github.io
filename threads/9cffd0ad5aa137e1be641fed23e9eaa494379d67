<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>isUniquelyReferenced issues</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>April  1, 2016 at 09:00:00am</p></header><div class="content"><p>In trying to implement a COW type, but I&#39;m running into problems with<br>isUniqueReferenced breaking in even fairly simple cases. For example (with<br>-O) the code below prints &quot;bar: false&quot;, commenting out the print in<br>test() makes<br>it print &quot;bar: true&quot;, and removing the var parameter var foo: Foo and using<br>var foo = foo instead breaks it again. Am I doing something wrong here?<br></p><p>class FooStorage { var x: Int = 0 }<br></p><p><br>struct Foo { var storage = FooStorage() }<br></p><p><br>func bar(var foo: Foo) {<br></p><p>print(&quot;bar: \(isUniquelyReferencedNonObjC(&amp;foo.storage))&quot;)<br></p><p>}<br></p><p><br>func test() {<br></p><p>var foo = Foo()<br></p><p>print(&quot;test: \(isUniquelyReferencedNonObjC(&amp;foo.storage))&quot;)<br></p><p>bar(foo)<br></p><p>}<br></p><p><br>test()<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160401/9cff9d67/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>isUniquelyReferenced issues</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 31, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Mar 31, 2016, at 3:58 PM, Patrick Pijnappel via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; In trying to implement a COW type, but I&#39;m running into problems with isUniqueReferenced breaking in even fairly simple cases. For example (with -O) the code below prints &quot;bar: false&quot;, commenting out the print in test() makes it print &quot;bar: true&quot;, and removing the var parameter var foo: Foo and using var foo = foo instead breaks it again. Am I doing something wrong here?<br>&gt; <br>&gt; class FooStorage { var x: Int = 0 }<br>&gt; <br>&gt; struct Foo { var storage = FooStorage() }<br>&gt; <br>&gt; func bar(var foo: Foo) {<br>&gt; 	print(&quot;bar: \(isUniquelyReferencedNonObjC(&amp;foo.storage))&quot;)<br>&gt; }<br>&gt; <br>&gt; func test() {<br>&gt; 	var foo = Foo()<br>&gt; 	print(&quot;test: \(isUniquelyReferencedNonObjC(&amp;foo.storage))&quot;)<br>&gt; 	bar(foo)<br>&gt; }<br>&gt; <br>&gt; test()<br></p><p>You&#39;re not doing anything wrong, this is just the ARC optimizer at work. `foo` inside `test` is dead after the call to `bar`, so ownership is transferred directly to `bar`&#39;s parameter.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>isUniquelyReferenced issues</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 31, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Mar 31, 2016, at 4:21 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 31, 2016, at 3:58 PM, Patrick Pijnappel via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In trying to implement a COW type, but I&#39;m running into problems with isUniqueReferenced breaking in even fairly simple cases. For example (with -O) the code below prints &quot;bar: false&quot;, commenting out the print in test() makes it print &quot;bar: true&quot;, and removing the var parameter var foo: Foo and using var foo = foo instead breaks it again. Am I doing something wrong here?<br>&gt;&gt; <br>&gt;&gt; class FooStorage { var x: Int = 0 }<br>&gt;&gt; <br>&gt;&gt; struct Foo { var storage = FooStorage() }<br>&gt;&gt; <br>&gt;&gt; func bar(var foo: Foo) {<br>&gt;&gt; 	print(&quot;bar: \(isUniquelyReferencedNonObjC(&amp;foo.storage))&quot;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func test() {<br>&gt;&gt; 	var foo = Foo()<br>&gt;&gt; 	print(&quot;test: \(isUniquelyReferencedNonObjC(&amp;foo.storage))&quot;)<br>&gt;&gt; 	bar(foo)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; test()<br>&gt; <br>&gt; You&#39;re not doing anything wrong, this is just the ARC optimizer at work. `foo` inside `test` is dead after the call to `bar`, so ownership is transferred directly to `bar`&#39;s parameter.<br></p><p>If you want to ensure that `foo` remains alive despite this, you can use `withExtendedLifetime`:<br></p><p>class FooStorage { var x: Int = 0 }<br></p><p>struct Foo { var storage = FooStorage() }<br></p><p>func bar(var foo: Foo) {<br>	print(&quot;bar: \(isUniquelyReferencedNonObjC(&amp;foo.storage))&quot;)<br>}<br></p><p>func test() {<br>	var foo = Foo()<br>	print(&quot;test: \(isUniquelyReferencedNonObjC(&amp;foo.storage))&quot;)<br>	withExtendedLifetime(foo) {<br>		bar(foo)<br>	}<br>}<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>isUniquelyReferenced issues</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>April  1, 2016 at 05:00:00pm</p></header><div class="content"><p>The modified version doesn&#39;t seem to change any of the results (on -O or<br>-Onone). Note that the problem is that it&#39;s *not* uniquely referenced<br>inside bar where it actually should be â€“ that would mean that ownership is<br>currently not directly transferred right?<br></p><p>On Fri, Apr 1, 2016 at 10:27 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Mar 31, 2016, at 4:21 PM, Joe Groff via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Mar 31, 2016, at 3:58 PM, Patrick Pijnappel via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; In trying to implement a COW type, but I&#39;m running into problems with<br>&gt; isUniqueReferenced breaking in even fairly simple cases. For example (with<br>&gt; -O) the code below prints &quot;bar: false&quot;, commenting out the print in test()<br>&gt; makes it print &quot;bar: true&quot;, and removing the var parameter var foo: Foo and<br>&gt; using var foo = foo instead breaks it again. Am I doing something wrong<br>&gt; here?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; class FooStorage { var x: Int = 0 }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; struct Foo { var storage = FooStorage() }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func bar(var foo: Foo) {<br>&gt; &gt;&gt;      print(&quot;bar: \(isUniquelyReferencedNonObjC(&amp;foo.storage))&quot;)<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func test() {<br>&gt; &gt;&gt;      var foo = Foo()<br>&gt; &gt;&gt;      print(&quot;test: \(isUniquelyReferencedNonObjC(&amp;foo.storage))&quot;)<br>&gt; &gt;&gt;      bar(foo)<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; test()<br>&gt; &gt;<br>&gt; &gt; You&#39;re not doing anything wrong, this is just the ARC optimizer at work.<br>&gt; `foo` inside `test` is dead after the call to `bar`, so ownership is<br>&gt; transferred directly to `bar`&#39;s parameter.<br>&gt;<br>&gt; If you want to ensure that `foo` remains alive despite this, you can use<br>&gt; `withExtendedLifetime`:<br>&gt;<br>&gt; class FooStorage { var x: Int = 0 }<br>&gt;<br>&gt; struct Foo { var storage = FooStorage() }<br>&gt;<br>&gt; func bar(var foo: Foo) {<br>&gt;         print(&quot;bar: \(isUniquelyReferencedNonObjC(&amp;foo.storage))&quot;)<br>&gt; }<br>&gt;<br>&gt; func test() {<br>&gt;         var foo = Foo()<br>&gt;         print(&quot;test: \(isUniquelyReferencedNonObjC(&amp;foo.storage))&quot;)<br>&gt;         withExtendedLifetime(foo) {<br>&gt;                 bar(foo)<br>&gt;         }<br>&gt; }<br>&gt;<br>&gt; -Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160401/adb56a87/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>isUniquelyReferenced issues</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>April  1, 2016 at 06:00:00pm</p></header><div class="content"><p>Ok I checked, in the version from my original email we have:<br></p><p>callq _swift_retain<br></p><p>movq %rbx, %rdi<br></p><p>callq __TF4main3barFVS_3FooT_<br></p><p>movq %rbx, %rdi<br></p><p>callq _swift_release<br></p><p><br>Which makes foo obviously non-uniquely referenced inside bar, preventing<br>COW optimization. So it seems the optimizer somehow doesn&#39;t notice it&#39;s<br>dead here and doesn&#39;t transfer ownership (?).<br></p><p>On Fri, Apr 1, 2016 at 5:49 PM, Patrick Pijnappel &lt;<br>patrickpijnappel at gmail.com&gt; wrote:<br></p><p>&gt; The modified version doesn&#39;t seem to change any of the results (on -O or<br>&gt; -Onone). Note that the problem is that it&#39;s *not* uniquely referenced<br>&gt; inside bar where it actually should be â€“ that would mean that ownership is<br>&gt; currently not directly transferred right?<br>&gt;<br>&gt; On Fri, Apr 1, 2016 at 10:27 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Mar 31, 2016, at 4:21 PM, Joe Groff via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; On Mar 31, 2016, at 3:58 PM, Patrick Pijnappel via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; In trying to implement a COW type, but I&#39;m running into problems with<br>&gt;&gt; isUniqueReferenced breaking in even fairly simple cases. For example (with<br>&gt;&gt; -O) the code below prints &quot;bar: false&quot;, commenting out the print in test()<br>&gt;&gt; makes it print &quot;bar: true&quot;, and removing the var parameter var foo: Foo and<br>&gt;&gt; using var foo = foo instead breaks it again. Am I doing something wrong<br>&gt;&gt; here?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; class FooStorage { var x: Int = 0 }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; struct Foo { var storage = FooStorage() }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func bar(var foo: Foo) {<br>&gt;&gt; &gt;&gt;      print(&quot;bar: \(isUniquelyReferencedNonObjC(&amp;foo.storage))&quot;)<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func test() {<br>&gt;&gt; &gt;&gt;      var foo = Foo()<br>&gt;&gt; &gt;&gt;      print(&quot;test: \(isUniquelyReferencedNonObjC(&amp;foo.storage))&quot;)<br>&gt;&gt; &gt;&gt;      bar(foo)<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; test()<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; You&#39;re not doing anything wrong, this is just the ARC optimizer at<br>&gt;&gt; work. `foo` inside `test` is dead after the call to `bar`, so ownership is<br>&gt;&gt; transferred directly to `bar`&#39;s parameter.<br>&gt;&gt;<br>&gt;&gt; If you want to ensure that `foo` remains alive despite this, you can use<br>&gt;&gt; `withExtendedLifetime`:<br>&gt;&gt;<br>&gt;&gt; class FooStorage { var x: Int = 0 }<br>&gt;&gt;<br>&gt;&gt; struct Foo { var storage = FooStorage() }<br>&gt;&gt;<br>&gt;&gt; func bar(var foo: Foo) {<br>&gt;&gt;         print(&quot;bar: \(isUniquelyReferencedNonObjC(&amp;foo.storage))&quot;)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; func test() {<br>&gt;&gt;         var foo = Foo()<br>&gt;&gt;         print(&quot;test: \(isUniquelyReferencedNonObjC(&amp;foo.storage))&quot;)<br>&gt;&gt;         withExtendedLifetime(foo) {<br>&gt;&gt;                 bar(foo)<br>&gt;&gt;         }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; -Joe<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160401/ac8c2f01/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>isUniquelyReferenced issues</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April  1, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Mar 31, 2016, at 11:49 PM, Patrick Pijnappel &lt;patrickpijnappel at gmail.com&gt; wrote:<br>&gt; <br>&gt; The modified version doesn&#39;t seem to change any of the results (on -O or -Onone). Note that the problem is that it&#39;s not uniquely referenced inside bar where it actually should be â€“ that would mean that ownership is currently not directly transferred right?<br></p><p>You&#39;re right, I&#39;m sorry, I misread your original comment. If the ARC optimizer didn&#39;t transfer ownership, then it is correct for `isUniquelyReferenced` to be false inside `bar`, since the `foo` inside of `test` and the `foo` parameter to `bar` are semantically independent values. If this weren&#39;t the case, then `bar` could modify a COW value type and have its changes be seen back in `test`&#39;s copy.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>isUniquelyReferenced issues</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>April  1, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Apr 1, 2016, at 8:43 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 31, 2016, at 11:49 PM, Patrick Pijnappel &lt;patrickpijnappel at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The modified version doesn&#39;t seem to change any of the results (on -O or -Onone). Note that the problem is that it&#39;s not uniquely referenced inside bar where it actually should be â€“ that would mean that ownership is currently not directly transferred right?<br>&gt; <br>&gt; You&#39;re right, I&#39;m sorry, I misread your original comment. If the ARC optimizer didn&#39;t transfer ownership, then it is correct for `isUniquelyReferenced` to be false inside `bar`, since the `foo` inside of `test` and the `foo` parameter to `bar` are semantically independent values. If this weren&#39;t the case, then `bar` could modify a COW value type and have its changes be seen back in `test`&#39;s copy.<br></p><p>In other words, to avoid a copy, the COW value must be passed â€˜inoutâ€™. This is normally true anyway for functions that mutate the value.<br></p><p>It would be neat to have a â€˜moveâ€™ operator that handed ownership of the COW value off to the callee. But the memory safety of that would be problematic in general.<br></p><p>-Andy<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>isUniquelyReferenced issues</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April  1, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Apr 1, 2016, at 4:10 PM, Andrew Trick via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; On Apr 1, 2016, at 8:43 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 31, 2016, at 11:49 PM, Patrick Pijnappel &lt;patrickpijnappel at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The modified version doesn&#39;t seem to change any of the results (on -O or -Onone). Note that the problem is that it&#39;s not uniquely referenced inside bar where it actually should be â€“ that would mean that ownership is currently not directly transferred right?<br>&gt;&gt; <br>&gt;&gt; You&#39;re right, I&#39;m sorry, I misread your original comment. If the ARC optimizer didn&#39;t transfer ownership, then it is correct for `isUniquelyReferenced` to be false inside `bar`, since the `foo` inside of `test` and the `foo` parameter to `bar` are semantically independent values. If this weren&#39;t the case, then `bar` could modify a COW value type and have its changes be seen back in `test`&#39;s copy.<br>&gt; <br>&gt; In other words, to avoid a copy, the COW value must be passed â€˜inoutâ€™. This is normally true anyway for functions that mutate the value.<br>&gt; <br>&gt; It would be neat to have a â€˜moveâ€™ operator that handed ownership of the COW value off to the callee. But the memory safety of that would be problematic in general.<br></p><p>It could be supported on local variables, which would probably be good enough.  DI would just ensure that the value wasn&#39;t used after that point.  Similar DI work will be necessary in the long run anyway to implement unique-ownership types.<br></p><p>John.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
