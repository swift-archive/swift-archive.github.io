<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>SE-0111 and Curried argument labels: Unintended Consequences</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October  4, 2016 at 10:00:00am</p></header><div class="content"><p>SE-0111 established that Swift&#39;s type system would not allow function argument labels to be expressed as part of a function type. As I&#39;ve been working with curried functions, I&#39;m discovering an unintended consequence of this proposal in that it strips curried functions of their external labels and the resulting calls of their readability.<br></p><p>```<br>public func projected(<br>    function f: @escaping (CGFloat) -&gt; CGFloat) -&gt;<br>    (_ p0: CGPoint, _ p1: CGPoint) -&gt; <br>    (_ percent: CGFloat) -&gt; CGPoint<br>{<br>```<br></p><p>Calling the first level of currying still reads acceptably:<br></p><p>```<br>let projectedFunction = projected(function: fToApply)<br>```<br></p><p>But after that, the enforced label-less arguments mean all further semantics have to stay within the name of the assigned partially applied function symbol and all arguments must be supplied without meaning, which is not in the spirit of API guidelines or under the umbrella of Swiftiness:<br></p><p>```<br>let fixedFunction = projectedFunction(p0, p1)<br>let value = fixedFunction(0.2)<br>```<br></p><p>There&#39;s no way to give either the line segment start and end points or the percent-of-progress arguments any labels.  Further, Xcode/QuickHelp does not provide any support for documenting the roles of each curried return type.<br></p><p>Could this be addressed specifically for currying or has the boat sailed forever on this topic?<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161004/7c6ae759/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>SE-0111 and Curried argument labels: Unintended Consequences</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>October  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 4, 2016, at 9:21 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; SE-0111 established that Swift&#39;s type system would not allow function argument labels to be expressed as part of a function type. As I&#39;ve been working with curried functions, I&#39;m discovering an unintended consequence of this proposal in that it strips curried functions of their external labels and the resulting calls of their readability.<br>&gt; <br>&gt; ```<br>&gt; public func projected(<br>&gt;     function f: @escaping (CGFloat) -&gt; CGFloat) -&gt;<br>&gt;     (_ p0: CGPoint, _ p1: CGPoint) -&gt; <br>&gt;     (_ percent: CGFloat) -&gt; CGPoint<br>&gt; {<br>&gt; ```<br>&gt; <br>&gt; Calling the first level of currying still reads acceptably:<br>&gt; <br>&gt; ```<br>&gt; let projectedFunction = projected(function: fToApply)<br>&gt; ```<br>&gt; <br>&gt; But after that, the enforced label-less arguments mean all further semantics have to stay within the name of the assigned partially applied function symbol and all arguments must be supplied without meaning, which is not in the spirit of API guidelines or under the umbrella of Swiftiness:<br>&gt; <br>&gt; ```<br>&gt; let fixedFunction = projectedFunction(p0, p1)<br>&gt; let value = fixedFunction(0.2)<br>&gt; ```<br>&gt; <br>&gt; There&#39;s no way to give either the line segment start and end points or the percent-of-progress arguments any labels.  Further, Xcode/QuickHelp does not provide any support for documenting the roles of each curried return type.<br>&gt; <br>&gt; Could this be addressed specifically for currying or has the boat sailed forever on this topic?<br>&gt; <br></p><p>This could be expressed by allowing local variable names to have compound names when of function type. I would not require it to be expressed this way, but it would be a nice addition. This would look something like the following:<br></p><p>let projectedFunction(from:to:) = projected(function: fToApply)<br>let scale(by:) = projectedFunction(from: myPoint1, to: myPoint2)<br>let finalPoint = scale(by: 3.0)<br></p><p>When it comes to local assignment, it makes sense to allow local control over argument labels. For people who don’t care to have their closures be applied with labels, maybe allow current syntax:<br></p><p>let projectedFunction = projected(function: fToApply)<br>let scale = projectedFunction(myPoint1, myPoint2)<br>let finalPoint = scale(3.0)<br></p><p>I’m not sure if we want to force compound names always (demonstrate arity and explicit label-less-ness), but one could envision a strict enforcement like:<br></p><p>let projectedFunction(_:_:) = projected(function: fToApply)<br>let scale(_:) = projectedFunction(myPoint1, myPoint2)<br>let finalPoint = scale(3.0)<br></p><p><br>Probably out of scope for Swift 4 stage 1<br></p><p><br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161004/b2408b6a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>SE-0111 and Curried argument labels: Unintended Consequences</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>October  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 4, 2016, at 9:32 AM, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 4, 2016, at 9:21 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; SE-0111 established that Swift&#39;s type system would not allow function argument labels to be expressed as part of a function type. As I&#39;ve been working with curried functions, I&#39;m discovering an unintended consequence of this proposal in that it strips curried functions of their external labels and the resulting calls of their readability.<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; public func projected(<br>&gt;&gt;     function f: @escaping (CGFloat) -&gt; CGFloat) -&gt;<br>&gt;&gt;     (_ p0: CGPoint, _ p1: CGPoint) -&gt; <br>&gt;&gt;     (_ percent: CGFloat) -&gt; CGPoint<br>&gt;&gt; {<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Calling the first level of currying still reads acceptably:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; let projectedFunction = projected(function: fToApply)<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; But after that, the enforced label-less arguments mean all further semantics have to stay within the name of the assigned partially applied function symbol and all arguments must be supplied without meaning, which is not in the spirit of API guidelines or under the umbrella of Swiftiness:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; let fixedFunction = projectedFunction(p0, p1)<br>&gt;&gt; let value = fixedFunction(0.2)<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; There&#39;s no way to give either the line segment start and end points or the percent-of-progress arguments any labels.  Further, Xcode/QuickHelp does not provide any support for documenting the roles of each curried return type.<br>&gt;&gt; <br>&gt;&gt; Could this be addressed specifically for currying or has the boat sailed forever on this topic?<br>&gt;&gt; <br>&gt; <br>&gt; This could be expressed by allowing local variable names to have compound names when of function type. I would not require it to be expressed this way, but it would be a nice addition. This would look something like the following:<br>&gt; <br>&gt; let projectedFunction(from:to:) = projected(function: fToApply)<br>&gt; let scale(by:) = projectedFunction(from: myPoint1, to: myPoint2)<br>&gt; let finalPoint = scale(by: 3.0)<br>&gt; <br>&gt; When it comes to local assignment, it makes sense to allow local control over argument labels. For people who don’t care to have their closures be applied with labels, maybe allow current syntax:<br>&gt; <br>&gt; let projectedFunction = projected(function: fToApply)<br>&gt; let scale = projectedFunction(myPoint1, myPoint2)<br>&gt; let finalPoint = scale(3.0)<br>&gt; <br>&gt; I’m not sure if we want to force compound names always (demonstrate arity and explicit label-less-ness), but one could envision a strict enforcement like:<br>&gt; <br>&gt; let projectedFunction(_:_:) = projected(function: fToApply)<br>&gt; let scale(_:) = projectedFunction(myPoint1, myPoint2)<br>&gt; let finalPoint = scale(3.0)<br>&gt; <br></p><p>To clarify, I’m not in favor of strict enforcing of this final form, and it would need extreme justification to make that pitch. But, it might be possible to encourage that form in linting tools. And, if there is strong, albeit not extreme, justification, enforce through a warning/fix-it).<br></p><p><br>&gt; <br>&gt; Probably out of scope for Swift 4 stage 1<br>&gt; <br>&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161004/fb93e6c7/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>SE-0111 and Curried argument labels: Unintended Consequences</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>October  4, 2016 at 10:00:00pm</p></header><div class="content"><p>I do not think the boat has sailed. I do remember this issue being actually revisited after initial approval because of the impact it had and quite a few members in this list, myself included, thought it was not helping readability and clarity and that it was strange this came after putting so much emphasis on argument labels for methods... and rightfully so.<br></p><p>From what I remember Chris L. said the actual state of things is not how the final solution of the problem will look like, but that for Swift 3.0 they needed to simplify how argument labels were treated as part of the type system and short term needs won, but that the team agreed that the solution had to be revisited and solved. I will try to look for that message.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 4 Oct 2016, at 17:21, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; SE-0111 established that Swift&#39;s type system would not allow function argument labels to be expressed as part of a function type. As I&#39;ve been working with curried functions, I&#39;m discovering an unintended consequence of this proposal in that it strips curried functions of their external labels and the resulting calls of their readability.<br>&gt; <br>&gt; ```<br>&gt; public func projected(<br>&gt;     function f: @escaping (CGFloat) -&gt; CGFloat) -&gt;<br>&gt;     (_ p0: CGPoint, _ p1: CGPoint) -&gt; <br>&gt;     (_ percent: CGFloat) -&gt; CGPoint<br>&gt; {<br>&gt; ```<br>&gt; <br>&gt; Calling the first level of currying still reads acceptably:<br>&gt; <br>&gt; ```<br>&gt; let projectedFunction = projected(function: fToApply)<br>&gt; ```<br>&gt; <br>&gt; But after that, the enforced label-less arguments mean all further semantics have to stay within the name of the assigned partially applied function symbol and all arguments must be supplied without meaning, which is not in the spirit of API guidelines or under the umbrella of Swiftiness:<br>&gt; <br>&gt; ```<br>&gt; let fixedFunction = projectedFunction(p0, p1)<br>&gt; let value = fixedFunction(0.2)<br>&gt; ```<br>&gt; <br>&gt; There&#39;s no way to give either the line segment start and end points or the percent-of-progress arguments any labels.  Further, Xcode/QuickHelp does not provide any support for documenting the roles of each curried return type.<br>&gt; <br>&gt; Could this be addressed specifically for currying or has the boat sailed forever on this topic?<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161004/8235dee4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>SE-0111 and Curried argument labels: Unintended Consequences</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>October  4, 2016 at 05:00:00pm</p></header><div class="content"><p>I noticed this immediately and assumed that it was recognized as suboptimal<br>but tolerable for now. The required underscores were meant to leave space<br>for improvement in this regard, no? If not… sad face.<br></p><p>TJ<br></p><p>On Tue, Oct 4, 2016 at 12:21 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; SE-0111 established that Swift&#39;s type system would not allow function<br>&gt; argument labels to be expressed as part of a function type. As I&#39;ve been<br>&gt; working with curried functions, I&#39;m discovering an unintended consequence<br>&gt; of this proposal in that it strips curried functions of their external<br>&gt; labels and the resulting calls of their readability.<br>&gt;<br>&gt; ```<br>&gt; public func projected(<br>&gt;     function f: @escaping (CGFloat) -&gt; CGFloat) -&gt;<br>&gt;     (_ p0: CGPoint, _ p1: CGPoint) -&gt;<br>&gt;     (_ percent: CGFloat) -&gt; CGPoint<br>&gt; {<br>&gt; ```<br>&gt;<br>&gt; Calling the first level of currying still reads acceptably:<br>&gt;<br>&gt; ```<br>&gt; let projectedFunction = projected(function: fToApply)<br>&gt; ```<br>&gt;<br>&gt; But after that, the enforced label-less arguments mean all further<br>&gt; semantics have to stay within the name of the assigned partially applied<br>&gt; function symbol and all arguments must be supplied without meaning, which<br>&gt; is not in the spirit of API guidelines or under the umbrella of Swiftiness:<br>&gt;<br>&gt; ```<br>&gt; let fixedFunction = projectedFunction(p0, p1)<br>&gt; let value = fixedFunction(0.2)<br>&gt; ```<br>&gt;<br>&gt; There&#39;s no way to give either the line segment start and end points or the<br>&gt; percent-of-progress arguments any labels.  Further, Xcode/QuickHelp does<br>&gt; not provide any support for documenting the roles of each curried return<br>&gt; type.<br>&gt;<br>&gt; Could this be addressed specifically for currying or has the boat sailed<br>&gt; forever on this topic?<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161004/a3007e11/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>SE-0111 and Curried argument labels: Unintended Consequences</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>October  4, 2016 at 11:00:00pm</p></header><div class="content"><p>Here is the message I was talking about:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160711/024331.html<br></p><p>Message quoted here for your convenience:<br></p><p>&gt; *Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md&gt;<br>&gt;<br>&gt; Shortly after SE-0111 was accepted last week, several people newly noticed the proposal and started a discussion about how it appears to be a regression for closure parameters (e.g. callbacks) that could formerly carry labels, but are now not allowed to.  These folks observed that it would be more expressive (and consistent with the rest of Swift) to allow parameter labels in function types, because the invocation site of a closure “should&quot; be required to provide those labels.  The core team has been following the discussion, agrees that this is a concern, and wants to update the community with a path forward.<br>&gt;<br>&gt; The reality of the situation is that the current implementation of parameter labels in function types is inherently broken.  Specifically, as one example, there is an implicit conversion from &quot;(a: Int) -&gt; Int” to “(Int) -&gt; Int”.  However, there is also an implicit conversion from &quot;(Int) -&gt; Int” to “(b : Int) -&gt; Int”.  This means that the compiler currently allows converting from “(a: Int) -&gt; Int” to “(b: Int) -&gt; Int”, which doesn’t make sense, introduces surprising behavior, introduces complexity into the compiler implementation, and is generally a problem.  We do have one specific hack to prevent conversion of (e.g.) “(a : Int, b : Int) -&gt; Void” to “(b : Int, a : Int) -&gt; Void”, but this only triggers in specific cases.  There are other more complex cases as well, e.g. when using generics &quot;T&lt;(a : Int)-&gt;Int&gt;” cannot be considered compatible with &quot;T&lt;(b : Int)-&gt;Int&gt;”.<br>&gt;<br>&gt; These problems are what initially motivated SE-0111.  However, given the feedback, the core team went back to the drawing board to determine whether: a) SE-0111 by itself is the right long term answer, b) whether there were alternate models that could solve the same problems in a different way, or c) whether SE-0111 was the right first step to &quot;ultimate glory&quot; in the field of closure parameter labels.  After a long discussion, and many alternatives considered, the core team believes in c), that SE-0111 (with a minor modification) is the right step for Swift 3, because it paves the way for the right model over the long term.<br>&gt;<br>&gt; ----8&lt;----<br>&gt;<br>&gt; The specific revision requested by the core team to SE-0111 is that all “cosmetic” labels should be required to include an API name of _.  For example, this would not be allowed:<br>&gt;<br>&gt;    var op : (lhs : Int, rhs : Int) -&gt; Int<br>&gt;<br>&gt; instead, it should be spelled as:<br>&gt;<br>&gt;    var op : (_ lhs : Int, _ rhs : Int) -&gt; Int<br>&gt;<br>&gt; With this change, we believe that we have paved the way for a purely additive proposal (and thus, post-Swift 3) that will restore the expressive capability of closures with parameter labels.<br>&gt;<br>&gt; ----8&lt;----<br>&gt;<br>&gt; Here is a sketch of how that would work, in two steps:<br>&gt;<br>&gt;<br>&gt; First, we extend declaration names for variables, properties, and parameters to allow *parameter names* as part of their declaration name.  For example:<br>&gt;<br>&gt;    var op(lhs:,rhs:) : (Int, Int) -&gt; Int    // variable or property.<br>&gt;    x = op(lhs: 1, rhs: 2)       // use of the variable or property.<br>&gt;<br>&gt;    // API name of parameter is “opToUse”, internal name is &quot;op(lhs:,rhs:)”.<br>&gt;    func foo(opToUse  op(lhs:,rhs:) : (Int, Int) -&gt; Int) {<br>&gt;      x = op(lhs: 1, rhs: 2)     // use of the parameter<br>&gt;    }<br>&gt;    foo(opToUse: +)             // call of the function<br>&gt;<br>&gt; This will restore the ability to express the idea of a closure parameter that carries labels as part of its declaration, without requiring parameter labels to be part of the type system (allowing, e.g. the operator + to be passed into something that requires parameter labels).<br>&gt;<br>&gt;<br>&gt; Second, extend the rules for function types to allow parameter API labels *if and only if* they are used as the type of a declaration that allows parameter labels, and interpret them as a sugar form for providing those labels on the underlying declaration.  This means that the example above could be spelled as:<br>&gt;<br>&gt;    var op : (lhs: Int, rhs: Int) -&gt; Int    // Nice declaration syntax<br>&gt;    x = op(lhs: 1, rhs: 2)                  // Same as above<br>&gt;<br>&gt;    // API name of parameter is “opToUse”, internal name is &quot;op(lhs:,rhs:)”.<br>&gt;    func foo(opToUse op : (lhs: Int, rhs: Int) -&gt; Int) {<br>&gt;      x = op(lhs: 1, rhs: 2)     // Same as above.<br>&gt;    }<br>&gt;    foo(opToUse: +)              // Same as above.<br>&gt;<br>&gt;<br>&gt; These two steps will provide the simple and expressive design approach that we have now, without all of the problems that representing parameter labels in the type system introduces.  The core team believes that the temporary regression in expressiveness is an acceptable loss for Swift 3, particularly given that this will have no impact on Cocoa or the standard library.  In the case of Cocoa, recall that C and Objective-C don’t have parameter labels on their corresponding concepts (Blocks and C function pointers), and the higher order functions in the standard library should not require parameter labels either.<br>&gt;<br>&gt; -Chris &amp; the Core Team*<br>&gt;<br>&gt;<br>On Tue, Oct 4, 2016 at 10:27 PM, T.J. Usiyan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I noticed this immediately and assumed that it was recognized as<br>&gt; suboptimal but tolerable for now. The required underscores were meant to<br>&gt; leave space for improvement in this regard, no? If not… sad face.<br>&gt;<br>&gt; TJ<br>&gt;<br>&gt; On Tue, Oct 4, 2016 at 12:21 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; SE-0111 established that Swift&#39;s type system would not allow function<br>&gt;&gt; argument labels to be expressed as part of a function type. As I&#39;ve been<br>&gt;&gt; working with curried functions, I&#39;m discovering an unintended consequence<br>&gt;&gt; of this proposal in that it strips curried functions of their external<br>&gt;&gt; labels and the resulting calls of their readability.<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; public func projected(<br>&gt;&gt;     function f: @escaping (CGFloat) -&gt; CGFloat) -&gt;<br>&gt;&gt;     (_ p0: CGPoint, _ p1: CGPoint) -&gt;<br>&gt;&gt;     (_ percent: CGFloat) -&gt; CGPoint<br>&gt;&gt; {<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; Calling the first level of currying still reads acceptably:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; let projectedFunction = projected(function: fToApply)<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; But after that, the enforced label-less arguments mean all further<br>&gt;&gt; semantics have to stay within the name of the assigned partially applied<br>&gt;&gt; function symbol and all arguments must be supplied without meaning, which<br>&gt;&gt; is not in the spirit of API guidelines or under the umbrella of Swiftiness:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; let fixedFunction = projectedFunction(p0, p1)<br>&gt;&gt; let value = fixedFunction(0.2)<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; There&#39;s no way to give either the line segment start and end points or<br>&gt;&gt; the percent-of-progress arguments any labels.  Further, Xcode/QuickHelp<br>&gt;&gt; does not provide any support for documenting the roles of each curried<br>&gt;&gt; return type.<br>&gt;&gt;<br>&gt;&gt; Could this be addressed specifically for currying or has the boat sailed<br>&gt;&gt; forever on this topic?<br>&gt;&gt;<br>&gt;&gt; -- E<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161004/31a7a701/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>SE-0111 and Curried argument labels: Unintended Consequences</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October  4, 2016 at 07:00:00pm</p></header><div class="content"><p>Thank you for that!<br></p><p>-- E<br></p><p>&gt; On Oct 4, 2016, at 4:58 PM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Here is the message I was talking about: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160711/024331.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160711/024331.html&gt;<br>&gt; <br>&gt; Message quoted here for your convenience:<br>&gt; Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md&gt;<br>&gt; <br>&gt; Shortly after SE-0111 was accepted last week, several people newly noticed the proposal and started a discussion about how it appears to be a regression for closure parameters (e.g. callbacks) that could formerly carry labels, but are now not allowed to.  These folks observed that it would be more expressive (and consistent with the rest of Swift) to allow parameter labels in function types, because the invocation site of a closure “should&quot; be required to provide those labels.  The core team has been following the discussion, agrees that this is a concern, and wants to update the community with a path forward.<br>&gt; <br>&gt; The reality of the situation is that the current implementation of parameter labels in function types is inherently broken.  Specifically, as one example, there is an implicit conversion from &quot;(a: Int) -&gt; Int” to “(Int) -&gt; Int”.  However, there is also an implicit conversion from &quot;(Int) -&gt; Int” to “(b : Int) -&gt; Int”.  This means that the compiler currently allows converting from “(a: Int) -&gt; Int” to “(b: Int) -&gt; Int”, which doesn’t make sense, introduces surprising behavior, introduces complexity into the compiler implementation, and is generally a problem.  We do have one specific hack to prevent conversion of (e.g.) “(a : Int, b : Int) -&gt; Void” to “(b : Int, a : Int) -&gt; Void”, but this only triggers in specific cases.  There are other more complex cases as well, e.g. when using generics &quot;T&lt;(a : Int)-&gt;Int&gt;” cannot be considered compatible with &quot;T&lt;(b : Int)-&gt;Int&gt;”.<br>&gt; <br>&gt; These problems are what initially motivated SE-0111.  However, given the feedback, the core team went back to the drawing board to determine whether: a) SE-0111 by itself is the right long term answer, b) whether there were alternate models that could solve the same problems in a different way, or c) whether SE-0111 was the right first step to &quot;ultimate glory&quot; in the field of closure parameter labels.  After a long discussion, and many alternatives considered, the core team believes in c), that SE-0111 (with a minor modification) is the right step for Swift 3, because it paves the way for the right model over the long term.<br>&gt; <br>&gt; ----8&lt;----<br>&gt; <br>&gt; The specific revision requested by the core team to SE-0111 is that all “cosmetic” labels should be required to include an API name of _.  For example, this would not be allowed:<br>&gt; <br>&gt;    var op : (lhs : Int, rhs : Int) -&gt; Int<br>&gt; <br>&gt; instead, it should be spelled as:<br>&gt; <br>&gt;    var op : (_ lhs : Int, _ rhs : Int) -&gt; Int<br>&gt; <br>&gt; With this change, we believe that we have paved the way for a purely additive proposal (and thus, post-Swift 3) that will restore the expressive capability of closures with parameter labels.  <br>&gt; <br>&gt; ----8&lt;----<br>&gt; <br>&gt; Here is a sketch of how that would work, in two steps:<br>&gt; <br>&gt; <br>&gt; First, we extend declaration names for variables, properties, and parameters to allow *parameter names* as part of their declaration name.  For example:<br>&gt; <br>&gt;    var op(lhs:,rhs:) : (Int, Int) -&gt; Int    // variable or property.<br>&gt;    x = op(lhs: 1, rhs: 2)       // use of the variable or property.<br>&gt; <br>&gt;    // API name of parameter is “opToUse”, internal name is &quot;op(lhs:,rhs:)”.<br>&gt;    func foo(opToUse  op(lhs:,rhs:) : (Int, Int) -&gt; Int) {<br>&gt;      x = op(lhs: 1, rhs: 2)     // use of the parameter<br>&gt;    }<br>&gt;    foo(opToUse: +)             // call of the function<br>&gt; <br>&gt; This will restore the ability to express the idea of a closure parameter that carries labels as part of its declaration, without requiring parameter labels to be part of the type system (allowing, e.g. the operator + to be passed into something that requires parameter labels).<br>&gt; <br>&gt; <br>&gt; Second, extend the rules for function types to allow parameter API labels *if and only if* they are used as the type of a declaration that allows parameter labels, and interpret them as a sugar form for providing those labels on the underlying declaration.  This means that the example above could be spelled as:<br>&gt; <br>&gt;    var op : (lhs: Int, rhs: Int) -&gt; Int    // Nice declaration syntax<br>&gt;    x = op(lhs: 1, rhs: 2)                  // Same as above<br>&gt; <br>&gt;    // API name of parameter is “opToUse”, internal name is &quot;op(lhs:,rhs:)”.<br>&gt;    func foo(opToUse op : (lhs: Int, rhs: Int) -&gt; Int) {<br>&gt;      x = op(lhs: 1, rhs: 2)     // Same as above.<br>&gt;    }<br>&gt;    foo(opToUse: +)              // Same as above.<br>&gt; <br>&gt; <br>&gt; These two steps will provide the simple and expressive design approach that we have now, without all of the problems that representing parameter labels in the type system introduces.  The core team believes that the temporary regression in expressiveness is an acceptable loss for Swift 3, particularly given that this will have no impact on Cocoa or the standard library.  In the case of Cocoa, recall that C and Objective-C don’t have parameter labels on their corresponding concepts (Blocks and C function pointers), and the higher order functions in the standard library should not require parameter labels either.<br>&gt; <br>&gt; -Chris &amp; the Core Team<br>&gt; <br>&gt; On Tue, Oct 4, 2016 at 10:27 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I noticed this immediately and assumed that it was recognized as suboptimal but tolerable for now. The required underscores were meant to leave space for improvement in this regard, no? If not… sad face.<br>&gt; <br>&gt; TJ<br>&gt; <br>&gt; On Tue, Oct 4, 2016 at 12:21 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; SE-0111 established that Swift&#39;s type system would not allow function argument labels to be expressed as part of a function type. As I&#39;ve been working with curried functions, I&#39;m discovering an unintended consequence of this proposal in that it strips curried functions of their external labels and the resulting calls of their readability.<br>&gt; <br>&gt; ```<br>&gt; public func projected(<br>&gt;     function f: @escaping (CGFloat) -&gt; CGFloat) -&gt;<br>&gt;     (_ p0: CGPoint, _ p1: CGPoint) -&gt; <br>&gt;     (_ percent: CGFloat) -&gt; CGPoint<br>&gt; {<br>&gt; ```<br>&gt; <br>&gt; Calling the first level of currying still reads acceptably:<br>&gt; <br>&gt; ```<br>&gt; let projectedFunction = projected(function: fToApply)<br>&gt; ```<br>&gt; <br>&gt; But after that, the enforced label-less arguments mean all further semantics have to stay within the name of the assigned partially applied function symbol and all arguments must be supplied without meaning, which is not in the spirit of API guidelines or under the umbrella of Swiftiness:<br>&gt; <br>&gt; ```<br>&gt; let fixedFunction = projectedFunction(p0, p1)<br>&gt; let value = fixedFunction(0.2)<br>&gt; ```<br>&gt; <br>&gt; There&#39;s no way to give either the line segment start and end points or the percent-of-progress arguments any labels.  Further, Xcode/QuickHelp does not provide any support for documenting the roles of each curried return type.<br>&gt; <br>&gt; Could this be addressed specifically for currying or has the boat sailed forever on this topic?<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161004/0d6359bf/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f526807a5a76bc96427760ca78707cfb?s=50"></div><header><strong>SE-0111 and Curried argument labels: Unintended Consequences</strong> from <string>Jon Akhtar</string> &lt;jona at herbalife.com&gt;<p>October  5, 2016 at 03:00:00pm</p></header><div class="content"><p>I agree this seems like a pretty serious oversight. This is very un-swifty. Currying at one time was touted as a language feature, now it is more of an afterthought.<br></p><p>-Jon<br></p><p>From: &lt;swift-evolution-bounces at swift.org&lt;mailto:swift-evolution-bounces at swift.org&gt;&gt; on behalf of Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>Reply-To: Erica Sadun &lt;erica at ericasadun.com&lt;mailto:erica at ericasadun.com&gt;&gt;<br>Date: Tuesday, October 4, 2016 at 09:21<br>To: swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>Subject: [swift-evolution] SE-0111 and Curried argument labels: Unintended Consequences<br></p><p>SE-0111 established that Swift&#39;s type system would not allow function argument labels to be expressed as part of a function type. As I&#39;ve been working with curried functions, I&#39;m discovering an unintended consequence of this proposal in that it strips curried functions of their external labels and the resulting calls of their readability.<br></p><p>```<br>public func projected(<br>    function f: @escaping (CGFloat) -&gt; CGFloat) -&gt;<br>    (_ p0: CGPoint, _ p1: CGPoint) -&gt;<br>    (_ percent: CGFloat) -&gt; CGPoint<br>{<br>```<br></p><p>Calling the first level of currying still reads acceptably:<br></p><p>```<br>let projectedFunction = projected(function: fToApply)<br>```<br></p><p>But after that, the enforced label-less arguments mean all further semantics have to stay within the name of the assigned partially applied function symbol and all arguments must be supplied without meaning, which is not in the spirit of API guidelines or under the umbrella of Swiftiness:<br></p><p>```<br>let fixedFunction = projectedFunction(p0, p1)<br>let value = fixedFunction(0.2)<br>```<br></p><p>There&#39;s no way to give either the line segment start and end points or the percent-of-progress arguments any labels.  Further, Xcode/QuickHelp does not provide any support for documenting the roles of each curried return type.<br></p><p>Could this be addressed specifically for currying or has the boat sailed forever on this topic?<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161005/ddad052c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>SE-0111 and Curried argument labels: Unintended Consequences</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>October  5, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 5, 2016, at 8:15 AM, Jon Akhtar via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree this seems like a pretty serious oversight. This is very un-swifty. Currying at one time was touted as a language feature, now it is more of an afterthought.<br></p><p>I see it as a feature that has mostly been removed in Swift 3: SE-0002 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md&gt; eliminating the syntax that defined curried functions, and SE-0042 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0042-flatten-method-types.md&gt; eliminates the production of curried functions when referring to an instance member.  I think that’s because, as a language feature, currying wasn’t really carrying it’s conceptual weight: it wasn’t being used *that* often in practice, but—unless you’re already familiar with currying from another language—it’s a fairly complicated notion to understand, and Swift didn’t ever have a complete implementation of currying.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; -Jon<br>&gt; <br>&gt; From: &lt;swift-evolution-bounces at swift.org &lt;mailto:swift-evolution-bounces at swift.org&gt;&gt; on behalf of Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; Reply-To: Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt;<br>&gt; Date: Tuesday, October 4, 2016 at 09:21<br>&gt; To: swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; Subject: [swift-evolution] SE-0111 and Curried argument labels: Unintended Consequences<br>&gt; <br>&gt; SE-0111 established that Swift&#39;s type system would not allow function argument labels to be expressed as part of a function type. As I&#39;ve been working with curried functions, I&#39;m discovering an unintended consequence of this proposal in that it strips curried functions of their external labels and the resulting calls of their readability.<br>&gt; <br>&gt; ```<br>&gt; public func projected(<br>&gt;     function f: @escaping (CGFloat) -&gt; CGFloat) -&gt;<br>&gt;     (_ p0: CGPoint, _ p1: CGPoint) -&gt; <br>&gt;     (_ percent: CGFloat) -&gt; CGPoint<br>&gt; {<br>&gt; ```<br>&gt; <br>&gt; Calling the first level of currying still reads acceptably:<br>&gt; <br>&gt; ```<br>&gt; let projectedFunction = projected(function: fToApply)<br>&gt; ```<br>&gt; <br>&gt; But after that, the enforced label-less arguments mean all further semantics have to stay within the name of the assigned partially applied function symbol and all arguments must be supplied without meaning, which is not in the spirit of API guidelines or under the umbrella of Swiftiness:<br>&gt; <br>&gt; ```<br>&gt; let fixedFunction = projectedFunction(p0, p1)<br>&gt; let value = fixedFunction(0.2)<br>&gt; ```<br>&gt; <br>&gt; There&#39;s no way to give either the line segment start and end points or the percent-of-progress arguments any labels.  Further, Xcode/QuickHelp does not provide any support for documenting the roles of each curried return type.<br>&gt; <br>&gt; Could this be addressed specifically for currying or has the boat sailed forever on this topic?<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161005/e368ff30/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
