<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>August  2, 2016 at 12:00:00pm</p></header><div class="content"><p>on Sun Jul 31 2016, Bram Beernink &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi Karl and Haravikk,<br>&gt;<br>&gt; Thank you for your replies. <br>&gt;<br>&gt; I was assuming that the cases I represented are not always optimized for several reasons:<br>&gt; Swift’s book only talks about optimization in the context of arrays,<br>&gt; strings and dictionaries. Not in the context of structs in general:<br>&gt; “The description above refers to the “copying” of strings, arrays, and<br>&gt; dictionaries. The behavior you see in your code will always be as if a<br>&gt; copy took place. However, Swift only performs an actual copy behind<br>&gt; the scenes when it is absolutely necessary to do so. Swift manages all<br>&gt; value copying to ensure optimal performance, <br></p><p>If it says that, it&#39;s... not quite right.  There are things we could do<br>to make some value copies more optimal.  For example, any value type<br>containing multiple class references—or multiple other value types (such<br>as arrays or strings or dictionaries) that contain class references—will<br>cost more to copy than a single class reference does.  At the cost of<br>some allocation and indirection, we could reduce the copying cost of<br>such values.  It&#39;s an optimization we&#39;ve considered making, but haven&#39;t<br>prioritized.  <br></p><p>You can put a CoW wrapper around your value to do it manually.  I hacked<br>one up using ManagedBuffer for someone at WWDC but I don&#39;t seem to have<br>saved the code, sadly.<br></p><p>&gt; and you should not avoid assignment to try to preempt this<br>&gt; optimization.”  <br></p><p>But that&#39;s basically still true.  The CoW wrapper technique is a good<br>way to tune things later if you find it necessary, without distorting<br>your code.<br></p><p>&gt; Excerpt From: Apple Inc. “The Swift Programming Language (Swift 2.2).”<br>&gt; iBooks. https://itun.es/nl/jEUH0.l &lt;https://itun.es/nl/jEUH0.l&gt; In<br>&gt; https://github.com/apple/swift/tree/eb27bb65a7c17bd9b4255baee5c4e4f9c214bde6/stdlib/public/core<br>&gt; &lt;https://github.com/apple/swift/tree/eb27bb65a7c17bd9b4255baee5c4e4f9c214bde6/stdlib/public/core&gt;<br>&gt; I see public mutating func append(_ newElement: Element) , line 1268,<br>&gt; using _makeUniqueAndReserveCapacityIfNotUnique() at line 1269, leading<br>&gt; me to suspect that to have COW, you have to do additional work.  Doing<br>&gt; some manual tests some time ago, isUniquelyReferenced seemed to return<br>&gt; false in a case like append_one as<br>&gt; https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#advice-use-inplace-mutation-instead-of-object-reassignment<br>&gt; &lt;https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#advice-use-inplace-mutation-instead-of-object-reassignment&gt;<br>&gt; mentioned by Karl, meaning that it indeed leads to unnecessary<br>&gt; copying.<br>&gt;<br>&gt; In any case,<br>&gt; https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#advice-use-inplace-mutation-instead-of-object-reassignment<br>&gt; &lt;https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#advice-use-inplace-mutation-instead-of-object-reassignment&gt;<br>&gt; does mention that: “Sometimes COW can introduce additional unexpected<br>&gt; copies if the user is not careful.” I would argue that what we need is<br>&gt; not only COW, but Copy On Write When Necessary, COWWN. In COWWN copies<br>&gt; are only made when writing to the shared reference if it is not unique<br>&gt; and the shared reference’s old state is still referred to in next<br>&gt; statements. <br></p><p>That&#39;s what the standard library CoW types do currently, and yours can<br>too.  See isKnownUniquelyReferenced (née isUniquelyReferenced).<br></p><p>&gt; So not only is the current reference count taken into account, but<br>&gt; also whether the old state is needed afterwards. This is both runtime<br>&gt; as well as compile-time data.<br>&gt;<br>&gt; So my questions would be:<br>&gt; Why does Swift sometimes do additional unnecessary copying, as implied<br>&gt; by<br>&gt; https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#advice-use-inplace-mutation-instead-of-object-reassignment<br>&gt; &lt;https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#advice-use-inplace-mutation-instead-of-object-reassignment&gt;<br>&gt; in the case of append_one? <br></p><p>In this case it could be needlessly copied because the optimizer is either <br></p><p>a) off (-Onone)<br>b) not smart enough to know that `a` isn&#39;t used before being reassigned<br></p><p>&gt; Is this a problem that cannot be solved?<br></p><p>I think this particular example can be solved.  There are other cases<br>where avoiding a needless copy is impossible due to the existence of a<br>separate compilation boundary (e.g. across frameworks, or files if<br>whole-module-optimization is disabled).<br></p><p>&gt; (In C++ you would solve this example using<br>&gt; a=a.append_one(std::move(a)). But I would think that since Swift does<br>&gt; not have to deal with pointers and manual memory management, it can<br>&gt; automatically detect such cases unlike C++?)  <br></p><p>In principle, yes.  In practice, it depends on visibility through<br>function call boundaries.<br></p><p>&gt; If/once structs are COWWN, can Swift introduce immutable functions for<br>&gt; the standard library, such as func appended(_ newElement: Element) -&gt;<br>&gt; Array&lt;Element&gt;?<br></p><p>That would be “appending.”  We could introduce that method today, though<br>I&#39;m not sure it&#39;s useful enough to justify its existence.<br></p><p>&gt;<br>&gt; Best regards,<br>&gt; Bram.<br>&gt;<br>&gt;&gt; On 30 jul. 2016, at 12:46, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 29 Jul 2016, at 17:42, Bram Beernink via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would it be possible to improve value and move semantics<br>&gt;&gt;&gt; (performance) in Swift? Consider this possible Swift code in a<br>&gt;&gt;&gt; future release of Swift:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let array1 : [String] = [&quot;Val1&quot;, &quot;Val2&quot;]<br>&gt;&gt;&gt; let array2 = array1.appended(“Val3”) // Copy of array1 with “Val3”<br>&gt;&gt;&gt; appended. array1 is left untouched. Nothing special yet.<br>&gt;&gt;&gt; var array3 : [String] = [“Var1”]<br>&gt;&gt;&gt; array3 = array3.appended(“Var2”) // array3 can just be mutated to<br>&gt;&gt;&gt; add “Var2”, while maintaining value semantics. Swift can recognize<br>&gt;&gt;&gt; that array3’s old state is not referenced anywhere in the future.<br>&gt;&gt;&gt; let array4 = array2.appended(&quot;Val4&quot;).appended(&quot;Val5&quot;) // Copy of<br>&gt;&gt;&gt; array2 with both &quot;Val4&quot; and &quot;Val5&quot; appended. In this case, “Val5”<br>&gt;&gt;&gt; can also be appended by mutation.<br>&gt;&gt; <br>&gt;&gt; Well, for the array3 = array3.appended(&quot;Var2&quot;) example this could<br>&gt;&gt; possibly be addressed by an attribute to indicate to the compiler<br>&gt;&gt; that .appended() has a mutating variant, as this will allow it to<br>&gt;&gt; issue a warning when the assignment is to the same variable, which<br>&gt;&gt; would address that simple case (and provide more awareness of the<br>&gt;&gt; mutating options and encourage developers to use them).<br>&gt;&gt; <br>&gt;&gt;&gt; This example illustrates improved value semantics with a string array. But it would be good if this can work with any struct. Maybe via something similar to isUniquelyReferenced? Or maybe you can even have a “smart” self in a non-mutating func in a struct:<br>&gt;&gt;&gt; struct Array&lt;T&gt; {<br>&gt;&gt;&gt;     func appended(e : T) -&gt; Array&lt;T&gt; { // No mutating keyword!<br>&gt;&gt;&gt;         self.append(e) // self would either be mutated here if the current ref count of self is 1, and self is either a “rvalue” or self’s old state cannot possibly referenced anymore after this call. Otherwise, &quot;self” would actually be a copy of self.<br>&gt;&gt;&gt;         return self<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know about allowing mutation of self in non-mutating<br>&gt;&gt; methods, that seems confusing; however, I&#39;d be surprised if the<br>&gt;&gt; compiler doesn&#39;t already detect variables that only exist to create<br>&gt;&gt; a copy that is discarded.<br>&gt;&gt; <br>&gt;&gt; The compiler should already be trying to inline very simple methods<br>&gt;&gt; like the common copy -&gt; mutate -&gt; return style of non-mutating<br>&gt;&gt; implementations, in which case it should be able to identify that a<br>&gt;&gt; copy is being created only to overwrite the original anyway, so can<br>&gt;&gt; be eliminated. Do you believe that this isn&#39;t currently being done?<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>August  2, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Aug 2, 2016, at 12:06 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If it says that, it&#39;s... not quite right.  There are things we could do<br>&gt; to make some value copies more optimal.  For example, any value type<br>&gt; containing multiple class references—or multiple other value types (such<br>&gt; as arrays or strings or dictionaries) that contain class references—will<br>&gt; cost more to copy than a single class reference does.  At the cost of<br>&gt; some allocation and indirection, we could reduce the copying cost of<br>&gt; such values.  It&#39;s an optimization we&#39;ve considered making, but haven&#39;t<br>&gt; prioritized.  <br>&gt; <br>&gt; You can put a CoW wrapper around your value to do it manually.  I hacked<br>&gt; one up using ManagedBuffer for someone at WWDC but I don&#39;t seem to have<br>&gt; saved the code, sadly.<br></p><p>Slightly off-topic, but one day I would like to see `indirect` turned into a generalized COW feature:<br></p><p>* `indirect` can only be applied to a value type (or at least to a type with `mutating` members, so reference types would have to gain those).<br>* The value type is boxed in a reference type.<br>* Any use of a mutating member (and thus, use of the setter) is guarded with `isKnownUniquelyReferenced` and a copy.<br>* `indirect` can be applied to an enum case with a payload (the payload is boxed), a stored property (the value is boxed), or a type (the entire type is boxed).<br></p><p>Then you can just slap `indirect` on a struct whose copying is too complicated and let Swift transparently COW it for you. (And it would also permit recursive structs and other such niceties.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>August  2, 2016 at 02:00:00pm</p></header><div class="content"><p>on Tue Aug 02 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br></p><p>&gt;&gt; On Aug 2, 2016, at 12:06 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If it says that, it&#39;s... not quite right.  There are things we could do<br>&gt;&gt; to make some value copies more optimal.  For example, any value type<br>&gt;&gt; containing multiple class references—or multiple other value types (such<br>&gt;&gt; as arrays or strings or dictionaries) that contain class references—will<br>&gt;&gt; cost more to copy than a single class reference does.  At the cost of<br>&gt;&gt; some allocation and indirection, we could reduce the copying cost of<br>&gt;&gt; such values.  It&#39;s an optimization we&#39;ve considered making, but haven&#39;t<br>&gt;&gt; prioritized.  <br>&gt;&gt; <br>&gt;&gt; You can put a CoW wrapper around your value to do it manually.  I hacked<br>&gt;&gt; one up using ManagedBuffer for someone at WWDC but I don&#39;t seem to have<br>&gt;&gt; saved the code, sadly.<br>&gt;<br>&gt; Slightly off-topic, but one day I would like to see `indirect` turned<br>&gt; into a generalized COW feature:<br>&gt;<br>&gt; * `indirect` can only be applied to a value type (or at least to a<br>&gt; type with `mutating` members, so reference types would have to gain<br>&gt; those).<br>&gt; * The value type is boxed in a reference type.<br>&gt; * Any use of a mutating member (and thus, use of the setter) is<br>&gt; guarded with `isKnownUniquelyReferenced` and a copy.<br>&gt; * `indirect` can be applied to an enum case with a payload (the<br>&gt; payload is boxed), a stored property (the value is boxed), or a type<br>&gt; (the entire type is boxed).<br>&gt;<br>&gt; Then you can just slap `indirect` on a struct whose copying is too<br>&gt; complicated and let Swift transparently COW it for you. (And it would<br>&gt; also permit recursive structs and other such niceties.)<br></p><p>My vision for this feature is:<br></p><p>a. We indirect automatically based on some heuristic, as an<br>   optimization.<br></p><p>b. We allow you to indirect manually.<br></p><p>c. We provide an attribute that suppresses automatic indirection to<br>   whatever depth possible given resilience boundaries.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>August  3, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Aug 2, 2016, at 4:54 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Tue Aug 02 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Aug 2, 2016, at 12:06 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If it says that, it&#39;s... not quite right.  There are things we could do<br>&gt;&gt;&gt; to make some value copies more optimal.  For example, any value type<br>&gt;&gt;&gt; containing multiple class references—or multiple other value types (such<br>&gt;&gt;&gt; as arrays or strings or dictionaries) that contain class references—will<br>&gt;&gt;&gt; cost more to copy than a single class reference does.  At the cost of<br>&gt;&gt;&gt; some allocation and indirection, we could reduce the copying cost of<br>&gt;&gt;&gt; such values.  It&#39;s an optimization we&#39;ve considered making, but haven&#39;t<br>&gt;&gt;&gt; prioritized.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can put a CoW wrapper around your value to do it manually.  I hacked<br>&gt;&gt;&gt; one up using ManagedBuffer for someone at WWDC but I don&#39;t seem to have<br>&gt;&gt;&gt; saved the code, sadly.<br>&gt;&gt; <br>&gt;&gt; Slightly off-topic, but one day I would like to see `indirect` turned<br>&gt;&gt; into a generalized COW feature:<br>&gt;&gt; <br>&gt;&gt; * `indirect` can only be applied to a value type (or at least to a<br>&gt;&gt; type with `mutating` members, so reference types would have to gain<br>&gt;&gt; those).<br>&gt;&gt; * The value type is boxed in a reference type.<br>&gt;&gt; * Any use of a mutating member (and thus, use of the setter) is<br>&gt;&gt; guarded with `isKnownUniquelyReferenced` and a copy.<br>&gt;&gt; * `indirect` can be applied to an enum case with a payload (the<br>&gt;&gt; payload is boxed), a stored property (the value is boxed), or a type<br>&gt;&gt; (the entire type is boxed).<br>&gt;&gt; <br>&gt;&gt; Then you can just slap `indirect` on a struct whose copying is too<br>&gt;&gt; complicated and let Swift transparently COW it for you. (And it would<br>&gt;&gt; also permit recursive structs and other such niceties.)<br>&gt; <br>&gt; My vision for this feature is:<br>&gt; <br>&gt; a. We indirect automatically based on some heuristic, as an<br>&gt;   optimization.<br>&gt; <br>&gt; b. We allow you to indirect manually.<br>&gt; <br>&gt; c. We provide an attribute that suppresses automatic indirection to<br>&gt;   whatever depth possible given resilience boundaries.<br></p><p>This all sounds great.  Does any of this fit into Swift 4 (either phase 1 or phase 2)?  It seems like at least the automatic part would have ABI impact.<br></p><p>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>August  3, 2016 at 04:00:00pm</p></header><div class="content"><p>On Aug 3, 2016, at 6:41 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Then you can just slap `indirect` on a struct whose copying is too<br>&gt;&gt;&gt; complicated and let Swift transparently COW it for you. (And it would<br>&gt;&gt;&gt; also permit recursive structs and other such niceties.)<br>&gt;&gt; <br>&gt;&gt; My vision for this feature is:<br>&gt;&gt; <br>&gt;&gt; a. We indirect automatically based on some heuristic, as an<br>&gt;&gt;  optimization.<br></p><p>I weakly disagree with this, because it is important that we provide a predictable model.  I’d rather the user get what they write, and tell people to write ‘indirect’ as a performance tuning option.  “Too magic” is bad.<br></p><p>&gt;&gt; b. We allow you to indirect manually.<br>&gt;&gt; <br>&gt;&gt; c. We provide an attribute that suppresses automatic indirection to<br>&gt;&gt;  whatever depth possible given resilience boundaries.<br>&gt; <br>&gt; This all sounds great.  Does any of this fit into Swift 4 (either phase 1 or phase 2)?  It seems like at least the automatic part would have ABI impact.<br></p><p>This is very low priority, because it is generally additive. After the major topics for ABI stability are figured out, we can have the philosophic discussion about the automatic part.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>August  3, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Aug 3, 2016, at 4:58 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Aug 3, 2016, at 6:41 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Then you can just slap `indirect` on a struct whose copying is too<br>&gt;&gt;&gt;&gt; complicated and let Swift transparently COW it for you. (And it would<br>&gt;&gt;&gt;&gt; also permit recursive structs and other such niceties.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My vision for this feature is:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; a. We indirect automatically based on some heuristic, as an<br>&gt;&gt;&gt; optimization.<br>&gt; <br>&gt; I weakly disagree with this, because it is important that we provide a predictable model.  I’d rather the user get what they write, and tell people to write ‘indirect’ as a performance tuning option.  “Too magic” is bad.<br></p><p>I think &#39;indirect&#39; structs with a heuristic default are important to the way people are writing Swift in practice. We&#39;ve seen many users fully invest in value semantics types, because they wants the benefits of isolated state, without appreciating the code size and performance impacts. Furthermore, implementing &#39;indirect&#39; by hand is a lot of boilerplate. Putting indirectness entirely in users&#39; hands feels to me a lot like the &quot;value if word sized, const&amp; if struct&quot; heuristics C++ makes you internalize, since there are similar heuristics where &#39;indirect&#39; is almost always a win in Swift too.<br></p><p>-Joe<br></p><p>&gt;&gt;&gt; b. We allow you to indirect manually.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; c. We provide an attribute that suppresses automatic indirection to<br>&gt;&gt;&gt; whatever depth possible given resilience boundaries.<br>&gt;&gt; <br>&gt;&gt; This all sounds great.  Does any of this fit into Swift 4 (either phase 1 or phase 2)?  It seems like at least the automatic part would have ABI impact.<br>&gt; <br>&gt; This is very low priority, because it is generally additive. After the major topics for ABI stability are figured out, we can have the philosophic discussion about the automatic part.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>August  3, 2016 at 08:00:00pm</p></header><div class="content"><p>On Aug 3, 2016, at 7:57 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; a. We indirect automatically based on some heuristic, as an<br>&gt;&gt;&gt;&gt; optimization.<br>&gt;&gt; <br>&gt;&gt; I weakly disagree with this, because it is important that we provide a predictable model.  I’d rather the user get what they write, and tell people to write ‘indirect’ as a performance tuning option.  “Too magic” is bad.<br>&gt; <br>&gt; I think &#39;indirect&#39; structs with a heuristic default are important to the way people are writing Swift in practice. We&#39;ve seen many users fully invest in value semantics types, because they wants the benefits of isolated state, without appreciating the code size and performance impacts. Furthermore, implementing &#39;indirect&#39; by hand is a lot of boilerplate. Putting indirectness entirely in users&#39; hands feels to me a lot like the &quot;value if word sized, const&amp; if struct&quot; heuristics C++ makes you internalize, since there are similar heuristics where &#39;indirect&#39; is almost always a win in Swift too.<br></p><p>I understand with much of your motivation, but I still disagree with your conclusion.  I see this as exactly analogous to the situation and discussion when we added indirect to enums.  At the time, some argued for a magic model where the compiler figured out what to do in the most common “obvious” cases.  <br></p><p>We agreed to use our current model though because:<br>1) Better to be explicit about allocations &amp; indirection that implicit.  <br>2) The compiler can guide the user in the “obvious” case to add the keyword with a fixit, preserving the discoverability / ease of use.<br>3) When indirection is necessary, there are choices to make about where the best place to do it is.<br>4) In the most common case, the “boilerplate” is a single “indirect” keyword added to the enum decl itself.  In the less common case, you want the “boilerplate” so that you know where the indirections are happening.<br></p><p>Overall, I think this model has worked well for enums and I’m still very happy with it.  If you generalize it to structs, you also have to consider that this should be part of a larger model that includes better support for COW.  I think it would be really unfortunate to “magically indirect” struct, when the right answer may actually be to COW them instead.  I’d rather have a model where someone can use:<br></p><p>// simple, predictable, always inline, slow in some cases.<br>struct S1 { … }  <br></p><p>And then upgrade to one of:<br></p><p>indirect struct S2 {…}<br>cow struct S3 { … } <br></p><p>Depending on the structure of their data.  In any case, to reiterate, this really isn’t the time to have this debate, since it is clearly outside of stage 1.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>August  3, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Aug 3, 2016, at 8:46 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Aug 3, 2016, at 7:57 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; a. We indirect automatically based on some heuristic, as an<br>&gt;&gt;&gt;&gt;&gt; optimization.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I weakly disagree with this, because it is important that we provide a predictable model.  I’d rather the user get what they write, and tell people to write ‘indirect’ as a performance tuning option.  “Too magic” is bad.<br>&gt;&gt; <br>&gt;&gt; I think &#39;indirect&#39; structs with a heuristic default are important to the way people are writing Swift in practice. We&#39;ve seen many users fully invest in value semantics types, because they wants the benefits of isolated state, without appreciating the code size and performance impacts. Furthermore, implementing &#39;indirect&#39; by hand is a lot of boilerplate. Putting indirectness entirely in users&#39; hands feels to me a lot like the &quot;value if word sized, const&amp; if struct&quot; heuristics C++ makes you internalize, since there are similar heuristics where &#39;indirect&#39; is almost always a win in Swift too.<br>&gt; <br>&gt; I understand with much of your motivation, but I still disagree with your conclusion.<br></p><p>^I understand and agree with much of your motivation...<br></p><p>-Chris<br></p><p>&gt;  I see this as exactly analogous to the situation and discussion when we added indirect to enums.  At the time, some argued for a magic model where the compiler figured out what to do in the most common “obvious” cases.  <br>&gt; <br>&gt; We agreed to use our current model though because:<br>&gt; 1) Better to be explicit about allocations &amp; indirection that implicit.  <br>&gt; 2) The compiler can guide the user in the “obvious” case to add the keyword with a fixit, preserving the discoverability / ease of use.<br>&gt; 3) When indirection is necessary, there are choices to make about where the best place to do it is.<br>&gt; 4) In the most common case, the “boilerplate” is a single “indirect” keyword added to the enum decl itself.  In the less common case, you want the “boilerplate” so that you know where the indirections are happening.<br>&gt; <br>&gt; Overall, I think this model has worked well for enums and I’m still very happy with it.  If you generalize it to structs, you also have to consider that this should be part of a larger model that includes better support for COW.  I think it would be really unfortunate to “magically indirect” struct, when the right answer may actually be to COW them instead.  I’d rather have a model where someone can use:<br>&gt; <br>&gt; // simple, predictable, always inline, slow in some cases.<br>&gt; struct S1 { … }  <br>&gt; <br>&gt; And then upgrade to one of:<br>&gt; <br>&gt; indirect struct S2 {…}<br>&gt; cow struct S3 { … } <br>&gt; <br>&gt; Depending on the structure of their data.  In any case, to reiterate, this really isn’t the time to have this debate, since it is clearly outside of stage 1.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>August  3, 2016 at 09:00:00pm</p></header><div class="content"><p>on Wed Aug 03 2016, Chris Lattner &lt;clattner-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Aug 3, 2016, at 8:46 PM, Chris Lattner via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Aug 3, 2016, at 7:57 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; a. We indirect automatically based on some heuristic, as an<br>&gt;&gt;&gt;&gt;&gt;&gt; optimization.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I weakly disagree with this, because it is important that we<br>&gt;&gt;&gt;&gt; provide a predictable model.  I’d rather the user get what they<br>&gt;&gt;&gt;&gt; write, and tell people to write ‘indirect’ as a performance tuning<br>&gt;&gt;&gt;&gt; option.  “Too magic” is bad.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think &#39;indirect&#39; structs with a heuristic default are important<br>&gt;&gt;&gt; to the way people are writing Swift in practice. We&#39;ve seen many<br>&gt;&gt;&gt; users fully invest in value semantics types, because they wants the<br>&gt;&gt;&gt; benefits of isolated state, without appreciating the code size and<br>&gt;&gt;&gt; performance impacts. Furthermore, implementing &#39;indirect&#39; by hand<br>&gt;&gt;&gt; is a lot of boilerplate. Putting indirectness entirely in users&#39;<br>&gt;&gt;&gt; hands feels to me a lot like the &quot;value if word sized, const&amp; if<br>&gt;&gt;&gt; struct&quot; heuristics C++ makes you internalize, since there are<br>&gt;&gt;&gt; similar heuristics where &#39;indirect&#39; is almost always a win in Swift<br>&gt;&gt;&gt; too.<br>&gt;&gt; <br>&gt;&gt; I understand with much of your motivation, but I still disagree with your conclusion.<br>&gt;<br>&gt; ^I understand and agree with much of your motivation...<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;&gt;  I see this as exactly analogous to the situation and discussion<br>&gt;&gt; when we added indirect to enums.  At the time, some argued for a<br>&gt;&gt; magic model where the compiler figured out what to do in the most<br>&gt;&gt; common “obvious” cases.<br>&gt;&gt; <br>&gt;&gt; We agreed to use our current model though because:<br>&gt;&gt; 1) Better to be explicit about allocations &amp; indirection that implicit.  <br>&gt;&gt; 2) The compiler can guide the user in the “obvious” case to add the<br>&gt;&gt; keyword with a fixit, preserving the discoverability / ease of use.<br>&gt;&gt; 3) When indirection is necessary, there are choices to make about<br>&gt;&gt; where the best place to do it is.<br>&gt;&gt; 4) In the most common case, the “boilerplate” is a single “indirect”<br>&gt;&gt; keyword added to the enum decl itself.  In the less common case, you<br>&gt;&gt; want the “boilerplate” so that you know where the indirections are<br>&gt;&gt; happening.<br>&gt;&gt; <br>&gt;&gt; Overall, I think this model has worked well for enums and I’m still<br>&gt;&gt; very happy with it.  If you generalize it to structs, you also have<br>&gt;&gt; to consider that this should be part of a larger model that includes<br>&gt;&gt; better support for COW.  I think it would be really unfortunate to<br>&gt;&gt; “magically indirect” struct, when the right answer may actually be<br>&gt;&gt; to COW them instead.  <br></p><p>COW&#39;ing the struct is implied by indirecting it.  You&#39;re not allowed to<br>break its value semantics just because it&#39;s being stored indirectly, and<br>we&#39;re darned sure not going to introduce an eagerly copied box there; I<br>think we all agree that the eager boxes we currently have must evolve<br>into COWs before ABI stability sets in.<br></p><p>&gt;&gt; I’d rather have a model where someone can use:<br>&gt;&gt; <br>&gt;&gt; // simple, predictable, always inline, slow in some cases.<br>&gt;&gt; struct S1 { … }  <br>&gt;&gt; <br>&gt;&gt; And then upgrade to one of:<br>&gt;&gt; <br>&gt;&gt; indirect struct S2 {…}<br>&gt;&gt; cow struct S3 { … } <br>&gt;&gt; <br>&gt;&gt; Depending on the structure of their data.  In any case, to<br>&gt;&gt; reiterate, this really isn’t the time to have this debate, since it<br>&gt;&gt; is clearly outside of stage 1.<br></p><p>Well, I don&#39;t want to draw it out either, but I do want to add one<br>point: the “predictable performance” argument rings pretty hollow for<br>me.  There are already hard-to-anticipate performance cliffs wherever we<br>have an inline buffer (e.g. existentials), an opportunity for stack<br>promotion, or where we mutate a COW data structure that might turn out<br>to have non-uniquely-referenced storage.  All of these effects add up to<br>code that performs well without too much intervention in most cases. We<br>should continue to make Swift perform well automatically, and give<br>people the tools they need to make adjustments when profiling reveals an<br>issue.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>August  4, 2016 at 07:00:00am</p></header><div class="content"><p>While I understand both your position and Joe&#39;s one, I think that it is good if in the Swift community at large, outside of this mailing list itself, more thought was given also to the side effects / losses in moving everything over to value types over references (one could have said with careful use of copy constructors and other solutions reference types can be tamed so why bother with value type renaissance? People seemed to make a lot of production code before...) and how those can and should be tamed.<br></p><p>Value types and the impact on performance (copies were advertised as almost free in Dave&#39;s talks but even when implementing CoW smartly like you have done with Array, Dictionary, etc... this still may mean surprising large copies happening at times some users may not expect them to be). <br></p><p>Regardless of the outcome I still see debate on this and putting yesterday&#39;s values to the test of today&#39;s data and knowledge pragmatic and it should not be seen as raining on the language&#39;s parade :).<br></p><p>Sorry for the rant-ish nature of my reply.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 4 Aug 2016, at 04:46, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Aug 3, 2016, at 7:57 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; a. We indirect automatically based on some heuristic, as an<br>&gt;&gt;&gt;&gt;&gt; optimization.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I weakly disagree with this, because it is important that we provide a predictable model.  I’d rather the user get what they write, and tell people to write ‘indirect’ as a performance tuning option.  “Too magic” is bad.<br>&gt;&gt; <br>&gt;&gt; I think &#39;indirect&#39; structs with a heuristic default are important to the way people are writing Swift in practice. We&#39;ve seen many users fully invest in value semantics types, because they wants the benefits of isolated state, without appreciating the code size and performance impacts. Furthermore, implementing &#39;indirect&#39; by hand is a lot of boilerplate. Putting indirectness entirely in users&#39; hands feels to me a lot like the &quot;value if word sized, const&amp; if struct&quot; heuristics C++ makes you internalize, since there are similar heuristics where &#39;indirect&#39; is almost always a win in Swift too.<br>&gt; <br>&gt; I understand with much of your motivation, but I still disagree with your conclusion.  I see this as exactly analogous to the situation and discussion when we added indirect to enums.  At the time, some argued for a magic model where the compiler figured out what to do in the most common “obvious” cases.  <br>&gt; <br>&gt; We agreed to use our current model though because:<br>&gt; 1) Better to be explicit about allocations &amp; indirection that implicit.  <br>&gt; 2) The compiler can guide the user in the “obvious” case to add the keyword with a fixit, preserving the discoverability / ease of use.<br>&gt; 3) When indirection is necessary, there are choices to make about where the best place to do it is.<br>&gt; 4) In the most common case, the “boilerplate” is a single “indirect” keyword added to the enum decl itself.  In the less common case, you want the “boilerplate” so that you know where the indirections are happening.<br>&gt; <br>&gt; Overall, I think this model has worked well for enums and I’m still very happy with it.  If you generalize it to structs, you also have to consider that this should be part of a larger model that includes better support for COW.  I think it would be really unfortunate to “magically indirect” struct, when the right answer may actually be to COW them instead.  I’d rather have a model where someone can use:<br>&gt; <br>&gt; // simple, predictable, always inline, slow in some cases.<br>&gt; struct S1 { … }  <br>&gt; <br>&gt; And then upgrade to one of:<br>&gt; <br>&gt; indirect struct S2 {…}<br>&gt; cow struct S3 { … } <br>&gt; <br>&gt; Depending on the structure of their data.  In any case, to reiterate, this really isn’t the time to have this debate, since it is clearly outside of stage 1.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>August  4, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Aug 3, 2016, at 8:46 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Aug 3, 2016, at 7:57 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; a. We indirect automatically based on some heuristic, as an<br>&gt;&gt;&gt;&gt;&gt; optimization.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I weakly disagree with this, because it is important that we provide a predictable model.  I’d rather the user get what they write, and tell people to write ‘indirect’ as a performance tuning option.  “Too magic” is bad.<br>&gt;&gt; <br>&gt;&gt; I think &#39;indirect&#39; structs with a heuristic default are important to the way people are writing Swift in practice. We&#39;ve seen many users fully invest in value semantics types, because they wants the benefits of isolated state, without appreciating the code size and performance impacts. Furthermore, implementing &#39;indirect&#39; by hand is a lot of boilerplate. Putting indirectness entirely in users&#39; hands feels to me a lot like the &quot;value if word sized, const&amp; if struct&quot; heuristics C++ makes you internalize, since there are similar heuristics where &#39;indirect&#39; is almost always a win in Swift too.<br>&gt; <br>&gt; I understand with much of your motivation, but I still disagree with your conclusion.  I see this as exactly analogous to the situation and discussion when we added indirect to enums.  At the time, some argued for a magic model where the compiler figured out what to do in the most common “obvious” cases.  <br>&gt; <br>&gt; We agreed to use our current model though because:<br>&gt; 1) Better to be explicit about allocations &amp; indirection that implicit.  <br>&gt; 2) The compiler can guide the user in the “obvious” case to add the keyword with a fixit, preserving the discoverability / ease of use.<br>&gt; 3) When indirection is necessary, there are choices to make about where the best place to do it is.<br>&gt; 4) In the most common case, the “boilerplate” is a single “indirect” keyword added to the enum decl itself.  In the less common case, you want the “boilerplate” so that you know where the indirections are happening.<br>&gt; <br>&gt; Overall, I think this model has worked well for enums and I’m still very happy with it.  If you generalize it to structs, you also have to consider that this should be part of a larger model that includes better support for COW.  I think it would be really unfortunate to “magically indirect” struct, when the right answer may actually be to COW them instead.  I’d rather have a model where someone can use:<br>&gt; <br>&gt; // simple, predictable, always inline, slow in some cases.<br>&gt; struct S1 { … }  <br>&gt; <br>&gt; And then upgrade to one of:<br>&gt; <br>&gt; indirect struct S2 {…}<br>&gt; cow struct S3 { … } <br>&gt; <br>&gt; Depending on the structure of their data.  In any case, to reiterate, this really isn’t the time to have this debate, since it is clearly outside of stage 1.<br></p><p>In my mind, indirect *is* cow. An indirect struct without value semantics is a class, so there would be no reason to implement &#39;indirect&#39; for structs without providing copy-on-write behavior. I believe that the situation with structs and enums is also different. Indirecting enums has a bigger impact on interface because they enable recursive data structures, and while there are places where indirecting a struct may make new recursion possible, that&#39;s much rarer of a reason to introduce indirectness for structs. Performance and code size are the more common reasons, and we&#39;ve described how to build COW boxes manually to work around performance problems at the last two years&#39; WWDC. There are pretty good heuristics for when indirection almost always beats inline storage: once you have more than one refcounted field, passing around a box and retaining once becomes cheaper than retaining the fields individually. Once you exceed the fixed-sized buffer threshold of three words, indirecting some or all of your fields becomes necessary to avoid falling off a cliff in unspecialized generic or protocol-type-based code. Considering that we hope to explore other layout optimizations, such as automatically reordering fields to minimize padding, and that, as with padding, there are simple rules for indirecting that can be mechanically followed to get good results in the 99% case, it seems perfectly reasonable to me to automate this.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>August  4, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Aug 4, 2016, at 9:39 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 3, 2016, at 8:46 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Aug 3, 2016, at 7:57 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; a. We indirect automatically based on some heuristic, as an<br>&gt;&gt;&gt;&gt;&gt;&gt; optimization.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I weakly disagree with this, because it is important that we provide a predictable model.  I’d rather the user get what they write, and tell people to write ‘indirect’ as a performance tuning option.  “Too magic” is bad.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think &#39;indirect&#39; structs with a heuristic default are important to the way people are writing Swift in practice. We&#39;ve seen many users fully invest in value semantics types, because they wants the benefits of isolated state, without appreciating the code size and performance impacts. Furthermore, implementing &#39;indirect&#39; by hand is a lot of boilerplate. Putting indirectness entirely in users&#39; hands feels to me a lot like the &quot;value if word sized, const&amp; if struct&quot; heuristics C++ makes you internalize, since there are similar heuristics where &#39;indirect&#39; is almost always a win in Swift too.<br>&gt;&gt; <br>&gt;&gt; I understand with much of your motivation, but I still disagree with your conclusion.  I see this as exactly analogous to the situation and discussion when we added indirect to enums.  At the time, some argued for a magic model where the compiler figured out what to do in the most common “obvious” cases.  <br>&gt;&gt; <br>&gt;&gt; We agreed to use our current model though because:<br>&gt;&gt; 1) Better to be explicit about allocations &amp; indirection that implicit.  <br>&gt;&gt; 2) The compiler can guide the user in the “obvious” case to add the keyword with a fixit, preserving the discoverability / ease of use.<br>&gt;&gt; 3) When indirection is necessary, there are choices to make about where the best place to do it is.<br>&gt;&gt; 4) In the most common case, the “boilerplate” is a single “indirect” keyword added to the enum decl itself.  In the less common case, you want the “boilerplate” so that you know where the indirections are happening.<br>&gt;&gt; <br>&gt;&gt; Overall, I think this model has worked well for enums and I’m still very happy with it.  If you generalize it to structs, you also have to consider that this should be part of a larger model that includes better support for COW.  I think it would be really unfortunate to “magically indirect” struct, when the right answer may actually be to COW them instead.  I’d rather have a model where someone can use:<br>&gt;&gt; <br>&gt;&gt; // simple, predictable, always inline, slow in some cases.<br>&gt;&gt; struct S1 { … }  <br>&gt;&gt; <br>&gt;&gt; And then upgrade to one of:<br>&gt;&gt; <br>&gt;&gt; indirect struct S2 {…}<br>&gt;&gt; cow struct S3 { … } <br>&gt;&gt; <br>&gt;&gt; Depending on the structure of their data.  In any case, to reiterate, this really isn’t the time to have this debate, since it is clearly outside of stage 1.<br>&gt; <br>&gt; In my mind, indirect *is* cow. An indirect struct without value semantics is a class, so there would be no reason to implement &#39;indirect&#39; for structs without providing copy-on-write behavior.<br></p><p>This is my view as well.  Chris, what is the distinction in your mind?<br></p><p>&gt; I believe that the situation with structs and enums is also different. Indirecting enums has a bigger impact on interface because they enable recursive data structures, and while there are places where indirecting a struct may make new recursion possible, that&#39;s much rarer of a reason to introduce indirectness for structs. Performance and code size are the more common reasons, and we&#39;ve described how to build COW boxes manually to work around performance problems at the last two years&#39; WWDC. There are pretty good heuristics for when indirection almost always beats inline storage: once you have more than one refcounted field, passing around a box and retaining once becomes cheaper than retaining the fields individually. Once you exceed the fixed-sized buffer threshold of three words, indirecting some or all of your fields becomes necessary to avoid falling off a cliff in unspecialized generic or protocol-type-based code.  Considering that we hope to explore other layout optimizations, such as automatically reordering fields to minimize padding, and that, as with padding, there are simple rules for indirecting that can be mechanically followed to get good results in the 99% case, it seems perfectly reasonable to me to automate this.<br>&gt; <br>&gt; -Joe<br></p><p><br>I think everyone is making good points in this discussion.  Predictability is an important value, but so is default performance.  To some degree there is a natural tension between them, but I think it can be mitigated.  <br></p><p>Swift relies so heavily on the optimizer for performance that I don’t think the default performance is ever going to be perfectly predictable.  But that’s actually a good thing because, as this allows the compiler to provide *better* performance for unannotated code than it would otherwise be able to do.  We should strive to make the default characteristics, behaviors, heuristics, etc as predictable as possible without compromising the goal of good performance by default.  We’re already pretty fair down this path.  It’s not clear to me why indirect value types would be treated any differently.  I don’t think anyone will complain as long as it is very rare for performance to be *worse* than the 100% predictable choice (always inline in this case).<br></p><p>It seems reasonable to me to expect developers who are reasoning about relatively low level performance details (i.e. not Big-O performance) to understand some lower level details of the language defaults.  It is also important to offer tools for developers to take direct, manual control when desired to make performance and behavior as predictable as possible.<br></p><p>For example, if we commit to and document the size of the inline existential buffer it is possible to reason about whether or not a value type is small enough to fit.  If the indirection heuristic is relatively simple - such as exceeding the inline buffer size, having more than one ref counted field (including types implemented with CoW), etc the default behavior will still be reasonably predictable.  These commitments don’t necessarily need to cover *every* case and don’t necessarily need to happen immediately, but hopefully the language will reach a stage of maturity where the core team feels confident in committing to some of the details that are relevant to common use cases.<br></p><p>We just need to also support users that want / need complete predictability and optimal performance for their specific use case by allowing opt-in annotations that offer more precise control.<br></p><p>Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160804/99e3b6d3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>August  4, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Am 04.08.2016 um 17:26 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 4, 2016, at 9:39 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Aug 3, 2016, at 8:46 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Aug 3, 2016, at 7:57 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a. We indirect automatically based on some heuristic, as an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; optimization.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I weakly disagree with this, because it is important that we provide a predictable model.  I’d rather the user get what they write, and tell people to write ‘indirect’ as a performance tuning option.  “Too magic” is bad.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think &#39;indirect&#39; structs with a heuristic default are important to the way people are writing Swift in practice. We&#39;ve seen many users fully invest in value semantics types, because they wants the benefits of isolated state, without appreciating the code size and performance impacts. Furthermore, implementing &#39;indirect&#39; by hand is a lot of boilerplate. Putting indirectness entirely in users&#39; hands feels to me a lot like the &quot;value if word sized, const&amp; if struct&quot; heuristics C++ makes you internalize, since there are similar heuristics where &#39;indirect&#39; is almost always a win in Swift too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I understand with much of your motivation, but I still disagree with your conclusion.  I see this as exactly analogous to the situation and discussion when we added indirect to enums.  At the time, some argued for a magic model where the compiler figured out what to do in the most common “obvious” cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We agreed to use our current model though because:<br>&gt;&gt;&gt; 1) Better to be explicit about allocations &amp; indirection that implicit.<br>&gt;&gt;&gt; 2) The compiler can guide the user in the “obvious” case to add the keyword with a fixit, preserving the discoverability / ease of use.<br>&gt;&gt;&gt; 3) When indirection is necessary, there are choices to make about where the best place to do it is.<br>&gt;&gt;&gt; 4) In the most common case, the “boilerplate” is a single “indirect” keyword added to the enum decl itself.  In the less common case, you want the “boilerplate” so that you know where the indirections are happening.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Overall, I think this model has worked well for enums and I’m still very happy with it.  If you generalize it to structs, you also have to consider that this should be part of a larger model that includes better support for COW.  I think it would be really unfortunate to “magically indirect” struct, when the right answer may actually be to COW them instead.  I’d rather have a model where someone can use:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // simple, predictable, always inline, slow in some cases.<br>&gt;&gt;&gt; struct S1 { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And then upgrade to one of:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; indirect struct S2 {…}<br>&gt;&gt;&gt; cow struct S3 { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Depending on the structure of their data.  In any case, to reiterate, this really isn’t the time to have this debate, since it is clearly outside of stage 1.<br>&gt;&gt; <br>&gt;&gt; In my mind, indirect *is* cow. An indirect struct without value semantics is a class, so there would be no reason to implement &#39;indirect&#39; for structs without providing copy-on-write behavior.<br>&gt; <br>&gt; This is my view as well.  Chris, what is the distinction in your mind?<br>&gt; <br>&gt;&gt; I believe that the situation with structs and enums is also different. Indirecting enums has a bigger impact on interface because they enable recursive data structures, and while there are places where indirecting a struct may make new recursion possible, that&#39;s much rarer of a reason to introduce indirectness for structs. Performance and code size are the more common reasons, and we&#39;ve described how to build COW boxes manually to work around performance problems at the last two years&#39; WWDC. There are pretty good heuristics for when indirection almost always beats inline storage: once you have more than one refcounted field, passing around a box and retaining once becomes cheaper than retaining the fields individually. Once you exceed the fixed-sized buffer threshold of three words, indirecting some or all of your fields becomes necessary to avoid falling off a cliff in unspecialized generic or protocol-type-based code.  Considering that we hope to explore other layout optimizations, such as automatically reordering fields to minimize padding, and that, as with padding, there are simple rules for indirecting that can be mechanically followed to get good results in the 99% case, it seems perfectly reasonable to me to automate this.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; I think everyone is making good points in this discussion.  Predictability is an important value, but so is default performance.  To some degree there is a natural tension between them, but I think it can be mitigated.<br>&gt; <br>&gt; Swift relies so heavily on the optimizer for performance that I don’t think the default performance is ever going to be perfectly predictable.  But that’s actually a good thing because, as this allows the compiler to provide *better* performance for unannotated code than it would otherwise be able to do.  We should strive to make the default characteristics, behaviors, heuristics, etc as predictable as possible without compromising the goal of good performance by default.  We’re already pretty fair down this path.  It’s not clear to me why indirect value types would be treated any differently.  I don’t think anyone will complain as long as it is very rare for performance to be *worse* than the 100% predictable choice (always inline in this case).<br>&gt; <br>&gt; It seems reasonable to me to expect developers who are reasoning about relatively low level performance details (i.e. not Big-O performance) to understand some lower level details of the language defaults.  It is also important to offer tools for developers to take direct, manual control when desired to make performance and behavior as predictable as possible.<br>&gt; <br>&gt; For example, if we commit to and document the size of the inline existential buffer it is possible to reason about whether or not a value type is small enough to fit.  If the indirection heuristic is relatively simple - such as exceeding the inline buffer size, having more than one ref counted field (including types implemented with CoW), etc the default behavior will still be reasonably predictable.  These commitments don’t necessarily need to cover *every* case and don’t necessarily need to happen immediately, but hopefully the language will reach a stage of maturity where the core team feels confident in committing to some of the details that are relevant to common use cases.<br>&gt; <br>&gt; We just need to also support users that want / need complete predictability and optimal performance for their specific use case by allowing opt-in annotations that offer more precise control.<br></p><p>I agree with this. First: IMHO indirect *should be* CoW, but currently it is not. If a value does not fit into the value buffer of an existential container, the value will be put onto the heap. If you store the same value into a second existential container (via an assignment to a variable of protocol type), it will be copied and put *as a second indirectly stored value* onto the heap, although no write has happened at all. Arnold Schwaighofer explained that in his talk at WWDC2016 very good (if you need a link, just ask me).<br></p><p>If there will be an automatic mechanism for indirect storage *and* CoW (which I would love), of course there have to be „tradeoff heuristics“ for when to store a value directly and when to use indirect storage. Further on, there should be a *unique value pool* for each value type where all (currently used) values of that type are stored (uniquely). I would even prefer, that the „tradeoff heuristics“ are done upfront by the compiler for a type, not for a variable. That means, Swift would use always a container for value types, but there are two types of containers: the value container and the existential container. The existential container stays like it is. The value container is as big as it needs to be to store the value of the given type, for small values (at most as big as the value buffer). If the value is bigger than the value buffer (or has more than one association to a reference type) the value container for this type is only as big as a reference, because these type will then stored on the heap with CoW **always**. This way I can always assign a value to a variable typed with a protocol, since value (or reference) will fit into the value buffer of the existential container. Additionally, CoW is available automatically for all types for which it „makes sense“ (of course annotations should be available to turn to the current „behavior“ if someone does not like this automatism. Last but not least, using the *unique value pool* for all value types, that fall into the category CoW-abonga this will be very space efficient.<br></p><p>Of course, if you create a new value of such a CoW-type, you need an *atomic lookup and set operation* in the value pool first checking whether it is already there (therefore a good (default) implementation of equality and hashable is a prerequisite) and either use the available value or in the other case add the new value to the pool.<br></p><p>Such a value pool could even be used system-wide (some languages do this for Strings, Ints and other value types). These values have to be evicted if their reference count drops to `0`. For some values permanent storage or storage for some time even if they are currently not referenced like in a cache could be implemented in order to reduce heap allocations (e.g. Java does this for primitive type wrapper instances for boxing and unboxing).<br></p><p>I would really love this. It would affect ABI, so it is a (potential) candidate for Swift 4 Phase 1 right?<br></p><p>All the best<br>Johannes<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160804/0c128b13/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>August  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Aug 4, 2016, at 11:20 AM, Johannes Neubauer &lt;neubauer at kingsware.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 04.08.2016 um 17:26 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Aug 4, 2016, at 9:39 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 3, 2016, at 8:46 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 3, 2016, at 7:57 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a. We indirect automatically based on some heuristic, as an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; optimization.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I weakly disagree with this, because it is important that we provide a predictable model.  I’d rather the user get what they write, and tell people to write ‘indirect’ as a performance tuning option.  “Too magic” is bad.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think &#39;indirect&#39; structs with a heuristic default are important to the way people are writing Swift in practice. We&#39;ve seen many users fully invest in value semantics types, because they wants the benefits of isolated state, without appreciating the code size and performance impacts. Furthermore, implementing &#39;indirect&#39; by hand is a lot of boilerplate. Putting indirectness entirely in users&#39; hands feels to me a lot like the &quot;value if word sized, const&amp; if struct&quot; heuristics C++ makes you internalize, since there are similar heuristics where &#39;indirect&#39; is almost always a win in Swift too.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I understand with much of your motivation, but I still disagree with your conclusion.  I see this as exactly analogous to the situation and discussion when we added indirect to enums.  At the time, some argued for a magic model where the compiler figured out what to do in the most common “obvious” cases.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We agreed to use our current model though because:<br>&gt;&gt;&gt;&gt; 1) Better to be explicit about allocations &amp; indirection that implicit.<br>&gt;&gt;&gt;&gt; 2) The compiler can guide the user in the “obvious” case to add the keyword with a fixit, preserving the discoverability / ease of use.<br>&gt;&gt;&gt;&gt; 3) When indirection is necessary, there are choices to make about where the best place to do it is.<br>&gt;&gt;&gt;&gt; 4) In the most common case, the “boilerplate” is a single “indirect” keyword added to the enum decl itself.  In the less common case, you want the “boilerplate” so that you know where the indirections are happening.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Overall, I think this model has worked well for enums and I’m still very happy with it.  If you generalize it to structs, you also have to consider that this should be part of a larger model that includes better support for COW.  I think it would be really unfortunate to “magically indirect” struct, when the right answer may actually be to COW them instead.  I’d rather have a model where someone can use:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // simple, predictable, always inline, slow in some cases.<br>&gt;&gt;&gt;&gt; struct S1 { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And then upgrade to one of:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; indirect struct S2 {…}<br>&gt;&gt;&gt;&gt; cow struct S3 { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Depending on the structure of their data.  In any case, to reiterate, this really isn’t the time to have this debate, since it is clearly outside of stage 1.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my mind, indirect *is* cow. An indirect struct without value semantics is a class, so there would be no reason to implement &#39;indirect&#39; for structs without providing copy-on-write behavior.<br>&gt;&gt; <br>&gt;&gt; This is my view as well.  Chris, what is the distinction in your mind?<br>&gt;&gt; <br>&gt;&gt;&gt; I believe that the situation with structs and enums is also different. Indirecting enums has a bigger impact on interface because they enable recursive data structures, and while there are places where indirecting a struct may make new recursion possible, that&#39;s much rarer of a reason to introduce indirectness for structs. Performance and code size are the more common reasons, and we&#39;ve described how to build COW boxes manually to work around performance problems at the last two years&#39; WWDC. There are pretty good heuristics for when indirection almost always beats inline storage: once you have more than one refcounted field, passing around a box and retaining once becomes cheaper than retaining the fields individually. Once you exceed the fixed-sized buffer threshold of three words, indirecting some or all of your fields becomes necessary to avoid falling off a cliff in unspecialized generic or protocol-type-based code.  Considering that we hope to explore other layout optimizations, such as automatically reordering fields to minimize padding, and that, as with padding, there are simple rules for indirecting that can be mechanically followed to get good results in the 99% case, it seems perfectly reasonable to me to automate this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; I think everyone is making good points in this discussion.  Predictability is an important value, but so is default performance.  To some degree there is a natural tension between them, but I think it can be mitigated.<br>&gt;&gt; <br>&gt;&gt; Swift relies so heavily on the optimizer for performance that I don’t think the default performance is ever going to be perfectly predictable.  But that’s actually a good thing because, as this allows the compiler to provide *better* performance for unannotated code than it would otherwise be able to do.  We should strive to make the default characteristics, behaviors, heuristics, etc as predictable as possible without compromising the goal of good performance by default.  We’re already pretty fair down this path.  It’s not clear to me why indirect value types would be treated any differently.  I don’t think anyone will complain as long as it is very rare for performance to be *worse* than the 100% predictable choice (always inline in this case).<br>&gt;&gt; <br>&gt;&gt; It seems reasonable to me to expect developers who are reasoning about relatively low level performance details (i.e. not Big-O performance) to understand some lower level details of the language defaults.  It is also important to offer tools for developers to take direct, manual control when desired to make performance and behavior as predictable as possible.<br>&gt;&gt; <br>&gt;&gt; For example, if we commit to and document the size of the inline existential buffer it is possible to reason about whether or not a value type is small enough to fit.  If the indirection heuristic is relatively simple - such as exceeding the inline buffer size, having more than one ref counted field (including types implemented with CoW), etc the default behavior will still be reasonably predictable.  These commitments don’t necessarily need to cover *every* case and don’t necessarily need to happen immediately, but hopefully the language will reach a stage of maturity where the core team feels confident in committing to some of the details that are relevant to common use cases.<br>&gt;&gt; <br>&gt;&gt; We just need to also support users that want / need complete predictability and optimal performance for their specific use case by allowing opt-in annotations that offer more precise control.<br>&gt; <br>&gt; I agree with this. First: IMHO indirect *should be* CoW, but currently it is not. If a value does not fit into the value buffer of an existential container, the value will be put onto the heap. If you store the same value into a second existential container (via an assignment to a variable of protocol type), it will be copied and put *as a second indirectly stored value* onto the heap, although no write has happened at all. Arnold Schwaighofer explained that in his talk at WWDC2016 very good (if you need a link, just ask me).<br>&gt; <br>&gt; If there will be an automatic mechanism for indirect storage *and* CoW (which I would love), of course there have to be „tradeoff heuristics“ for when to store a value directly and when to use indirect storage. Further on, there should be a *unique value pool* for each value type where all (currently used) values of that type are stored (uniquely). I would even prefer, that the „tradeoff heuristics“ are done upfront by the compiler for a type, not for a variable. That means, Swift would use always a container for value types, but there are two types of containers: the value container and the existential container. The existential container stays like it is. The value container is as big as it needs to be to store the value of the given type, for small values (at most as big as the value buffer). If the value is bigger than the value buffer (or has more than one association to a reference type) the value container for this type is only as big as a reference, because these type will then stored on the heap with CoW **always**. This way I can always assign a value to a variable typed with a protocol, since value (or reference) will fit into the value buffer of the existential container. Additionally, CoW is available automatically for all types for which it „makes sense“ (of course annotations should be available to turn to the current „behavior“ if someone does not like this automatism. Last but not least, using the *unique value pool* for all value types, that fall into the category CoW-abonga this will be very space efficient.<br>&gt; <br>&gt; Of course, if you create a new value of such a CoW-type, you need an *atomic lookup and set operation* in the value pool first checking whether it is already there (therefore a good (default) implementation of equality and hashable is a prerequisite) and either use the available value or in the other case add the new value to the pool.<br>&gt; <br>&gt; Such a value pool could even be used system-wide (some languages do this for Strings, Ints and other value types). These values have to be evicted if their reference count drops to `0`. For some values permanent storage or storage for some time even if they are currently not referenced like in a cache could be implemented in order to reduce heap allocations (e.g. Java does this for primitive type wrapper instances for boxing and unboxing).<br>&gt; <br>&gt; I would really love this. It would affect ABI, so it is a (potential) candidate for Swift 4 Phase 1 right?<br></p><p>I know some Java VM implementations have attempted global uniquing of strings, but from what I&#39;ve heard, nobody has done it in a way that&#39;s worth the performance and complexity tradeoffs.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>August  4, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Am 04.08.2016 um 20:21 schrieb Joe Groff &lt;jgroff at apple.com&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 4, 2016, at 11:20 AM, Johannes Neubauer &lt;neubauer at kingsware.de&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 04.08.2016 um 17:26 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 4, 2016, at 9:39 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 3, 2016, at 8:46 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 3, 2016, at 7:57 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a. We indirect automatically based on some heuristic, as an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; optimization.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I weakly disagree with this, because it is important that we provide a predictable model.  I’d rather the user get what they write, and tell people to write ‘indirect’ as a performance tuning option.  “Too magic” is bad.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think &#39;indirect&#39; structs with a heuristic default are important to the way people are writing Swift in practice. We&#39;ve seen many users fully invest in value semantics types, because they wants the benefits of isolated state, without appreciating the code size and performance impacts. Furthermore, implementing &#39;indirect&#39; by hand is a lot of boilerplate. Putting indirectness entirely in users&#39; hands feels to me a lot like the &quot;value if word sized, const&amp; if struct&quot; heuristics C++ makes you internalize, since there are similar heuristics where &#39;indirect&#39; is almost always a win in Swift too.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I understand with much of your motivation, but I still disagree with your conclusion.  I see this as exactly analogous to the situation and discussion when we added indirect to enums.  At the time, some argued for a magic model where the compiler figured out what to do in the most common “obvious” cases.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We agreed to use our current model though because:<br>&gt;&gt;&gt;&gt;&gt; 1) Better to be explicit about allocations &amp; indirection that implicit.<br>&gt;&gt;&gt;&gt;&gt; 2) The compiler can guide the user in the “obvious” case to add the keyword with a fixit, preserving the discoverability / ease of use.<br>&gt;&gt;&gt;&gt;&gt; 3) When indirection is necessary, there are choices to make about where the best place to do it is.<br>&gt;&gt;&gt;&gt;&gt; 4) In the most common case, the “boilerplate” is a single “indirect” keyword added to the enum decl itself.  In the less common case, you want the “boilerplate” so that you know where the indirections are happening.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Overall, I think this model has worked well for enums and I’m still very happy with it.  If you generalize it to structs, you also have to consider that this should be part of a larger model that includes better support for COW.  I think it would be really unfortunate to “magically indirect” struct, when the right answer may actually be to COW them instead.  I’d rather have a model where someone can use:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // simple, predictable, always inline, slow in some cases.<br>&gt;&gt;&gt;&gt;&gt; struct S1 { … }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And then upgrade to one of:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; indirect struct S2 {…}<br>&gt;&gt;&gt;&gt;&gt; cow struct S3 { … }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Depending on the structure of their data.  In any case, to reiterate, this really isn’t the time to have this debate, since it is clearly outside of stage 1.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my mind, indirect *is* cow. An indirect struct without value semantics is a class, so there would be no reason to implement &#39;indirect&#39; for structs without providing copy-on-write behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is my view as well.  Chris, what is the distinction in your mind?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I believe that the situation with structs and enums is also different. Indirecting enums has a bigger impact on interface because they enable recursive data structures, and while there are places where indirecting a struct may make new recursion possible, that&#39;s much rarer of a reason to introduce indirectness for structs. Performance and code size are the more common reasons, and we&#39;ve described how to build COW boxes manually to work around performance problems at the last two years&#39; WWDC. There are pretty good heuristics for when indirection almost always beats inline storage: once you have more than one refcounted field, passing around a box and retaining once becomes cheaper than retaining the fields individually. Once you exceed the fixed-sized buffer threshold of three words, indirecting some or all of your fields becomes necessary to avoid falling off a cliff in unspecialized generic or protocol-type-based code.  Considering that we hope to explore other layout optimizations, such as automatically reordering fields to minimize padding, and that, as with padding, there are simple rules for indirecting that can be mechanically followed to get good results in the 99% case, it seems perfectly reasonable to me to automate this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think everyone is making good points in this discussion.  Predictability is an important value, but so is default performance.  To some degree there is a natural tension between them, but I think it can be mitigated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift relies so heavily on the optimizer for performance that I don’t think the default performance is ever going to be perfectly predictable.  But that’s actually a good thing because, as this allows the compiler to provide *better* performance for unannotated code than it would otherwise be able to do.  We should strive to make the default characteristics, behaviors, heuristics, etc as predictable as possible without compromising the goal of good performance by default.  We’re already pretty fair down this path.  It’s not clear to me why indirect value types would be treated any differently.  I don’t think anyone will complain as long as it is very rare for performance to be *worse* than the 100% predictable choice (always inline in this case).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems reasonable to me to expect developers who are reasoning about relatively low level performance details (i.e. not Big-O performance) to understand some lower level details of the language defaults.  It is also important to offer tools for developers to take direct, manual control when desired to make performance and behavior as predictable as possible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, if we commit to and document the size of the inline existential buffer it is possible to reason about whether or not a value type is small enough to fit.  If the indirection heuristic is relatively simple - such as exceeding the inline buffer size, having more than one ref counted field (including types implemented with CoW), etc the default behavior will still be reasonably predictable.  These commitments don’t necessarily need to cover *every* case and don’t necessarily need to happen immediately, but hopefully the language will reach a stage of maturity where the core team feels confident in committing to some of the details that are relevant to common use cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We just need to also support users that want / need complete predictability and optimal performance for their specific use case by allowing opt-in annotations that offer more precise control.<br>&gt;&gt; <br>&gt;&gt; I agree with this. First: IMHO indirect *should be* CoW, but currently it is not. If a value does not fit into the value buffer of an existential container, the value will be put onto the heap. If you store the same value into a second existential container (via an assignment to a variable of protocol type), it will be copied and put *as a second indirectly stored value* onto the heap, although no write has happened at all. Arnold Schwaighofer explained that in his talk at WWDC2016 very good (if you need a link, just ask me).<br>&gt;&gt; <br>&gt;&gt; If there will be an automatic mechanism for indirect storage *and* CoW (which I would love), of course there have to be „tradeoff heuristics“ for when to store a value directly and when to use indirect storage. Further on, there should be a *unique value pool* for each value type where all (currently used) values of that type are stored (uniquely). I would even prefer, that the „tradeoff heuristics“ are done upfront by the compiler for a type, not for a variable. That means, Swift would use always a container for value types, but there are two types of containers: the value container and the existential container. The existential container stays like it is. The value container is as big as it needs to be to store the value of the given type, for small values (at most as big as the value buffer). If the value is bigger than the value buffer (or has more than one association to a reference type) the value container for this type is only as big as a reference, because these type will then stored on the heap with CoW **always**. This way I can always assign a value to a variable typed with a protocol, since value (or reference) will fit into the value buffer of the existential container. Additionally, CoW is available automatically for all types for which it „makes sense“ (of course annotations should be available to turn to the current „behavior“ if someone does not like this automatism. Last but not least, using the *unique value pool* for all value types, that fall into the category CoW-abonga this will be very space efficient.<br>&gt;&gt; <br>&gt;&gt; Of course, if you create a new value of such a CoW-type, you need an *atomic lookup and set operation* in the value pool first checking whether it is already there (therefore a good (default) implementation of equality and hashable is a prerequisite) and either use the available value or in the other case add the new value to the pool.<br>&gt;&gt; <br>&gt;&gt; Such a value pool could even be used system-wide (some languages do this for Strings, Ints and other value types). These values have to be evicted if their reference count drops to `0`. For some values permanent storage or storage for some time even if they are currently not referenced like in a cache could be implemented in order to reduce heap allocations (e.g. Java does this for primitive type wrapper instances for boxing and unboxing).<br>&gt;&gt; <br>&gt;&gt; I would really love this. It would affect ABI, so it is a (potential) candidate for Swift 4 Phase 1 right?<br>&gt; <br>&gt; I know some Java VM implementations have attempted global uniquing of strings, but from what I&#39;ve heard, nobody has done it in a way that&#39;s worth the performance and complexity tradeoffs.<br></p><p>To my knowledge no other language than Swift offers this form of custom value types, that can implement protocols, and the need for CoW for &quot;big values&quot; is apparent. So why do you think, that only because the tradeoff in other languages (like Java) which have only a limited set of fixed value types (and a completely different memory model and with a virtual machine instead of LLVM) did not pay off, should not be worth evaluating in Swift?<br></p><p>I think this is comparing apples to oranges (and the people from Apple don’t like this ;) ). Further on, the Java pals are working on custom value types too (the Valhalla project)…<br></p><p>All the best<br>Johannes<br></p><p><br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160804/dc55775f/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>August  5, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Aug 4, 2016, at 11:31 AM, Johannes Neubauer &lt;neubauer at kingsware.de&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 04.08.2016 um 20:21 schrieb Joe Groff &lt;jgroff at apple.com&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Aug 4, 2016, at 11:20 AM, Johannes Neubauer &lt;neubauer at kingsware.de&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 04.08.2016 um 17:26 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 4, 2016, at 9:39 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Aug 3, 2016, at 8:46 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Aug 3, 2016, at 7:57 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a. We indirect automatically based on some heuristic, as an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; optimization.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I weakly disagree with this, because it is important that we provide a predictable model.  I’d rather the user get what they write, and tell people to write ‘indirect’ as a performance tuning option.  “Too magic” is bad.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think &#39;indirect&#39; structs with a heuristic default are important to the way people are writing Swift in practice. We&#39;ve seen many users fully invest in value semantics types, because they wants the benefits of isolated state, without appreciating the code size and performance impacts. Furthermore, implementing &#39;indirect&#39; by hand is a lot of boilerplate. Putting indirectness entirely in users&#39; hands feels to me a lot like the &quot;value if word sized, const&amp; if struct&quot; heuristics C++ makes you internalize, since there are similar heuristics where &#39;indirect&#39; is almost always a win in Swift too.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I understand with much of your motivation, but I still disagree with your conclusion.  I see this as exactly analogous to the situation and discussion when we added indirect to enums.  At the time, some argued for a magic model where the compiler figured out what to do in the most common “obvious” cases.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We agreed to use our current model though because:<br>&gt;&gt;&gt;&gt;&gt;&gt; 1) Better to be explicit about allocations &amp; indirection that implicit.<br>&gt;&gt;&gt;&gt;&gt;&gt; 2) The compiler can guide the user in the “obvious” case to add the keyword with a fixit, preserving the discoverability / ease of use.<br>&gt;&gt;&gt;&gt;&gt;&gt; 3) When indirection is necessary, there are choices to make about where the best place to do it is.<br>&gt;&gt;&gt;&gt;&gt;&gt; 4) In the most common case, the “boilerplate” is a single “indirect” keyword added to the enum decl itself.  In the less common case, you want the “boilerplate” so that you know where the indirections are happening.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Overall, I think this model has worked well for enums and I’m still very happy with it.  If you generalize it to structs, you also have to consider that this should be part of a larger model that includes better support for COW.  I think it would be really unfortunate to “magically indirect” struct, when the right answer may actually be to COW them instead.  I’d rather have a model where someone can use:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // simple, predictable, always inline, slow in some cases.<br>&gt;&gt;&gt;&gt;&gt;&gt; struct S1 { … }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And then upgrade to one of:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; indirect struct S2 {…}<br>&gt;&gt;&gt;&gt;&gt;&gt; cow struct S3 { … }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Depending on the structure of their data.  In any case, to reiterate, this really isn’t the time to have this debate, since it is clearly outside of stage 1.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In my mind, indirect *is* cow. An indirect struct without value semantics is a class, so there would be no reason to implement &#39;indirect&#39; for structs without providing copy-on-write behavior.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is my view as well.  Chris, what is the distinction in your mind?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I believe that the situation with structs and enums is also different. Indirecting enums has a bigger impact on interface because they enable recursive data structures, and while there are places where indirecting a struct may make new recursion possible, that&#39;s much rarer of a reason to introduce indirectness for structs. Performance and code size are the more common reasons, and we&#39;ve described how to build COW boxes manually to work around performance problems at the last two years&#39; WWDC. There are pretty good heuristics for when indirection almost always beats inline storage: once you have more than one refcounted field, passing around a box and retaining once becomes cheaper than retaining the fields individually. Once you exceed the fixed-sized buffer threshold of three words, indirecting some or all of your fields becomes necessary to avoid falling off a cliff in unspecialized generic or protocol-type-based code.  Considering that we hope to explore other layout optimizations, such as automatically reordering fields to minimize padding, and that, as with padding, there are simple rules for indirecting that can be mechanically followed to get good results in the 99% case, it seems perfectly reasonable to me to automate this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think everyone is making good points in this discussion.  Predictability is an important value, but so is default performance.  To some degree there is a natural tension between them, but I think it can be mitigated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift relies so heavily on the optimizer for performance that I don’t think the default performance is ever going to be perfectly predictable.  But that’s actually a good thing because, as this allows the compiler to provide *better* performance for unannotated code than it would otherwise be able to do.  We should strive to make the default characteristics, behaviors, heuristics, etc as predictable as possible without compromising the goal of good performance by default.  We’re already pretty fair down this path.  It’s not clear to me why indirect value types would be treated any differently.  I don’t think anyone will complain as long as it is very rare for performance to be *worse* than the 100% predictable choice (always inline in this case).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems reasonable to me to expect developers who are reasoning about relatively low level performance details (i.e. not Big-O performance) to understand some lower level details of the language defaults.  It is also important to offer tools for developers to take direct, manual control when desired to make performance and behavior as predictable as possible.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example, if we commit to and document the size of the inline existential buffer it is possible to reason about whether or not a value type is small enough to fit. If the indirection heuristic is relatively simple - such as exceeding the inline buffer size, having more than one ref counted field (including types implemented with CoW), etc the default behavior will still be reasonably predictable.  These commitments don’t necessarily need to cover *every* case and don’t necessarily need to happen immediately, but hopefully the language will reach a stage of maturity where the core team feels confident in committing to some of the details that are relevant to common use cases.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We just need to also support users that want / need complete predictability and optimal performance for their specific use case by allowing opt-in annotations that offer more precise control.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with this. First: IMHO indirect *should be* CoW, but currently it is not. If a value does not fit into the value buffer of an existential container, the value will be put onto the heap. If you store the same value into a second existential container (via an assignment to a variable of protocol type), it will be copied and put *as a second indirectly stored value* onto the heap, although no write has happened at all. Arnold Schwaighofer explained that in his talk at WWDC2016 very good (if you need a link, just ask me).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If there will be an automatic mechanism for indirect storage *and* CoW (which I would love), of course there have to be „tradeoff heuristics“ for when to store a value directly and when to use indirect storage. Further on, there should be a *unique value pool* for each value type where all (currently used) values of that type are stored (uniquely). I would even prefer, that the „tradeoff heuristics“ are done upfront by the compiler for a type, not for a variable. That means, Swift would use always a container for value types, but there are two types of containers: the value container and the existential container. The existential container stays like it is. The value container is as big as it needs to be to store the value of the given type, for small values (at most as big as the value buffer). If the value is bigger than the value buffer (or has more than one association to a reference type) the value container for this type is only as big as a reference, because these type will then stored on the heap with CoW **always**. This way I can always assign a value to a variable typed with a protocol, since value (or reference) will fit into the value buffer of the existential container. Additionally, CoW is available automatically for all types for which it „makes sense“ (of course annotations should be available to turn to the current „behavior“ if someone does not like this automatism. Last but not least, using the *unique value pool* for all value types, that fall into the category CoW-abonga this will be very space efficient.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course, if you create a new value of such a CoW-type, you need an *atomic lookup and set operation* in the value pool first checking whether it is already there (therefore a good (default) implementation of equality and hashable is a prerequisite) and either use the available value or in the other case add the new value to the pool.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Such a value pool could even be used system-wide (some languages do this for Strings, Ints and other value types). These values have to be evicted if their reference count drops to `0`. For some values permanent storage or storage for some time even if they are currently not referenced like in a cache could be implemented in order to reduce heap allocations (e.g. Java does this for primitive type wrapper instances for boxing and unboxing).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would really love this. It would affect ABI, so it is a (potential) candidate for Swift 4 Phase 1 right?<br>&gt;&gt; <br>&gt;&gt; I know some Java VM implementations have attempted global uniquing of strings, but from what I&#39;ve heard, nobody has done it in a way that&#39;s worth the performance and complexity tradeoffs.<br>&gt; <br>&gt; To my knowledge no other language than Swift offers this form of custom value types, that can implement protocols, and the need for CoW for &quot;big values&quot; is apparent. So why do you think, that only because the tradeoff in other languages (like Java) which have only a limited set of fixed value types (and a completely different memory model and with a virtual machine instead of LLVM) did not pay off, should not be worth evaluating in Swift?<br></p><p>Strings are immutable in Java, so they are effectively value types (if not for their identity, which you can&#39;t rely on anyway).<br></p><p>-Joe<br></p><p>&gt; I think this is comparing apples to oranges (and the people from Apple don’t like this ;) ). Further on, the Java pals are working on custom value types too (the Valhalla project)…<br>&gt; <br>&gt; All the best<br>&gt; Johannes<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>August  5, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 05.08.2016 um 17:17 schrieb Joe Groff &lt;jgroff at apple.com&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 4, 2016, at 11:31 AM, Johannes Neubauer &lt;neubauer at kingsware.de&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 04.08.2016 um 20:21 schrieb Joe Groff &lt;jgroff at apple.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 4, 2016, at 11:20 AM, Johannes Neubauer &lt;neubauer at kingsware.de&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 04.08.2016 um 17:26 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Aug 4, 2016, at 9:39 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 3, 2016, at 8:46 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 3, 2016, at 7:57 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a. We indirect automatically based on some heuristic, as an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; optimization.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I weakly disagree with this, because it is important that we provide a predictable model.  I’d rather the user get what they write, and tell people to write ‘indirect’ as a performance tuning option.  “Too magic” is bad.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think &#39;indirect&#39; structs with a heuristic default are important to the way people are writing Swift in practice. We&#39;ve seen many users fully invest in value semantics types, because they wants the benefits of isolated state, without appreciating the code size and performance impacts. Furthermore, implementing &#39;indirect&#39; by hand is a lot of boilerplate. Putting indirectness entirely in users&#39; hands feels to me a lot like the &quot;value if word sized, const&amp; if struct&quot; heuristics C++ makes you internalize, since there are similar heuristics where &#39;indirect&#39; is almost always a win in Swift too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I understand with much of your motivation, but I still disagree with your conclusion.  I see this as exactly analogous to the situation and discussion when we added indirect to enums.  At the time, some argued for a magic model where the compiler figured out what to do in the most common “obvious” cases.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We agreed to use our current model though because:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) Better to be explicit about allocations &amp; indirection that implicit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) The compiler can guide the user in the “obvious” case to add the keyword with a fixit, preserving the discoverability / ease of use.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) When indirection is necessary, there are choices to make about where the best place to do it is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4) In the most common case, the “boilerplate” is a single “indirect” keyword added to the enum decl itself.  In the less common case, you want the “boilerplate” so that you know where the indirections are happening.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Overall, I think this model has worked well for enums and I’m still very happy with it.  If you generalize it to structs, you also have to consider that this should be part of a larger model that includes better support for COW.  I think it would be really unfortunate to “magically indirect” struct, when the right answer may actually be to COW them instead.  I’d rather have a model where someone can use:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // simple, predictable, always inline, slow in some cases.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; struct S1 { … }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then upgrade to one of:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; indirect struct S2 {…}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; cow struct S3 { … }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Depending on the structure of their data.  In any case, to reiterate, this really isn’t the time to have this debate, since it is clearly outside of stage 1.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In my mind, indirect *is* cow. An indirect struct without value semantics is a class, so there would be no reason to implement &#39;indirect&#39; for structs without providing copy-on-write behavior.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is my view as well.  Chris, what is the distinction in your mind?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I believe that the situation with structs and enums is also different. Indirecting enums has a bigger impact on interface because they enable recursive data structures, and while there are places where indirecting a struct may make new recursion possible, that&#39;s much rarer of a reason to introduce indirectness for structs. Performance and code size are the more common reasons, and we&#39;ve described how to build COW boxes manually to work around performance problems at the last two years&#39; WWDC. There are pretty good heuristics for when indirection almost always beats inline storage: once you have more than one refcounted field, passing around a box and retaining once becomes cheaper than retaining the fields individually. Once you exceed the fixed-sized buffer threshold of three words, indirecting some or all of your fields becomes necessary to avoid falling off a cliff in unspecialized generic or protocol-type-based code.  Considering that we hope to explore other layout optimizations, such as automatically reordering fields to minimize padding, and that, as with padding, there are simple rules for indirecting that can be mechanically followed to get good results in the 99% case, it seems perfectly reasonable to me to automate this.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think everyone is making good points in this discussion.  Predictability is an important value, but so is default performance.  To some degree there is a natural tension between them, but I think it can be mitigated.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift relies so heavily on the optimizer for performance that I don’t think the default performance is ever going to be perfectly predictable.  But that’s actually a good thing because, as this allows the compiler to provide *better* performance for unannotated code than it would otherwise be able to do.  We should strive to make the default characteristics, behaviors, heuristics, etc as predictable as possible without compromising the goal of good performance by default.  We’re already pretty fair down this path.  It’s not clear to me why indirect value types would be treated any differently.  I don’t think anyone will complain as long as it is very rare for performance to be *worse* than the 100% predictable choice (always inline in this case).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It seems reasonable to me to expect developers who are reasoning about relatively low level performance details (i.e. not Big-O performance) to understand some lower level details of the language defaults.  It is also important to offer tools for developers to take direct, manual control when desired to make performance and behavior as predictable as possible.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For example, if we commit to and document the size of the inline existential buffer it is possible to reason about whether or not a value type is small enough to fit. If the indirection heuristic is relatively simple - such as exceeding the inline buffer size, having more than one ref counted field (including types implemented with CoW), etc the default behavior will still be reasonably predictable.  These commitments don’t necessarily need to cover *every* case and don’t necessarily need to happen immediately, but hopefully the language will reach a stage of maturity where the core team feels confident in committing to some of the details that are relevant to common use cases.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We just need to also support users that want / need complete predictability and optimal performance for their specific use case by allowing opt-in annotations that offer more precise control.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with this. First: IMHO indirect *should be* CoW, but currently it is not. If a value does not fit into the value buffer of an existential container, the value will be put onto the heap. If you store the same value into a second existential container (via an assignment to a variable of protocol type), it will be copied and put *as a second indirectly stored value* onto the heap, although no write has happened at all. Arnold Schwaighofer explained that in his talk at WWDC2016 very good (if you need a link, just ask me).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If there will be an automatic mechanism for indirect storage *and* CoW (which I would love), of course there have to be „tradeoff heuristics“ for when to store a value directly and when to use indirect storage. Further on, there should be a *unique value pool* for each value type where all (currently used) values of that type are stored (uniquely). I would even prefer, that the „tradeoff heuristics“ are done upfront by the compiler for a type, not for a variable. That means, Swift would use always a container for value types, but there are two types of containers: the value container and the existential container. The existential container stays like it is. The value container is as big as it needs to be to store the value of the given type, for small values (at most as big as the value buffer). If the value is bigger than the value buffer (or has more than one association to a reference type) the value container for this type is only as big as a reference, because these type will then stored on the heap with CoW **always**. This way I can always assign a value to a variable typed with a protocol, since value (or reference) will fit into the value buffer of the existential container. Additionally, CoW is available automatically for all types for which it „makes sense“ (of course annotations should be available to turn to the current „behavior“ if someone does not like this automatism. Last but not least, using the *unique value pool* for all value types, that fall into the category CoW-abonga this will be very space efficient.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Of course, if you create a new value of such a CoW-type, you need an *atomic lookup and set operation* in the value pool first checking whether it is already there (therefore a good (default) implementation of equality and hashable is a prerequisite) and either use the available value or in the other case add the new value to the pool.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Such a value pool could even be used system-wide (some languages do this for Strings, Ints and other value types). These values have to be evicted if their reference count drops to `0`. For some values permanent storage or storage for some time even if they are currently not referenced like in a cache could be implemented in order to reduce heap allocations (e.g. Java does this for primitive type wrapper instances for boxing and unboxing).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would really love this. It would affect ABI, so it is a (potential) candidate for Swift 4 Phase 1 right?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know some Java VM implementations have attempted global uniquing of strings, but from what I&#39;ve heard, nobody has done it in a way that&#39;s worth the performance and complexity tradeoffs.<br>&gt;&gt; <br>&gt;&gt; To my knowledge no other language than Swift offers this form of custom value types, that can implement protocols, and the need for CoW for &quot;big values&quot; is apparent. So why do you think, that only because the tradeoff in other languages (like Java) which have only a limited set of fixed value types (and a completely different memory model and with a virtual machine instead of LLVM) did not pay off, should not be worth evaluating in Swift?<br>&gt; <br>&gt; Strings are immutable in Java, so they are effectively value types (if not for their identity, which you can&#39;t rely on anyway).<br></p><p>Yes, I agree. But the  argumentation still holds.<br></p><p><br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160805/1a216175/attachment.sig&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>August  7, 2016 at 09:00:00pm</p></header><div class="content"><p>On Aug 4, 2016, at 8:26 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; Depending on the structure of their data.  In any case, to reiterate, this really isn’t the time to have this debate, since it is clearly outside of stage 1.<br>&gt;&gt; <br>&gt;&gt; In my mind, indirect *is* cow. An indirect struct without value semantics is a class, so there would be no reason to implement &#39;indirect&#39; for structs without providing copy-on-write behavior.<br>&gt; <br>&gt; This is my view as well.  Chris, what is the distinction in your mind?<br></p><p>Yes, this is correct, my mistake.  Artifact of it not being in scope for Swift 4s1 so I can’t keep it in-core right now. :-)<br></p><p><br>&gt;&gt; I believe that the situation with structs and enums is also different. Indirecting enums has a bigger impact on interface because they enable recursive data structures, and while there are places where indirecting a struct may make new recursion possible, that&#39;s much rarer of a <br></p><p>I really don’t want to draw out this discussion, but I’ll observe that indirect on enums “cheat” in their implementation, because there is no way to get an internal reference with writeback semantics.  Because of that, all mutations are effectively overwrites of the entire enum value.<br></p><p>If you could pattern match an in-place mutable reference to the payload of an enum case then our implementation model would have to change.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160807/8c6a924b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
