<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>Type based reference cycle detection</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>February 28, 2016 at 05:00:00pm</p></header><div class="content"><p>Darko Damjanovic via swift-evolution &lt;swift-evolution at ...&gt; writes:<br></p><p>&gt; most basic form:<br>&gt; <br>&gt;     class A {<br>&gt;     	let myB: B?<br>&gt;     }<br>&gt; <br>&gt;     class B {<br>&gt;        let myA: A?<br>&gt;     }    <br>&gt; <br></p><p>One workaround available today is the replace classes with structs. Due to<br>struct&#39;s value semantics, the complier have to (and does) ban the relationship<br>in this example. (I understand this is not very practical when it comes to<br>    UIKit components).<br></p><p>For reference types such as class, a warning about retain cycle seems<br>reasonable. But there should also be a way to silence the warning. I can see<br>deliberate use cases for this example, such as abandoning weak references to<br>avoid performance hit.<br></p><p>Implementing this feature would be…interesting. Example:<br></p><p>     class A { let myP: P?  }<br> <br>     class P { let myX: AnyObject?  }<br></p><p>Should this code generate a cycle warning? What if myP&#39;s type is<br>GreatGreatGreatGrandParentOfP? Should any two class with a strong reference to<br>AnyObject generate a warning? We have to answer these questions before even<br>talking about how to implement it.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b281e721f8cbea65ab93ef72bd034a70?s=50"></div><header><strong>Type based reference cycle detection</strong> from <string>Darko Damjanovic</string> &lt;darkodamjanovic at me.com&gt;<p>February 28, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt;     class A { let myP: P?  }<br>&gt; <br>&gt;     class P { let myX: AnyObject?  }<br>&gt; <br>&gt; Should this code generate a cycle warning? What if myP&#39;s type is<br>&gt; GreatGreatGreatGrandParentOfP? Should any two class with a strong reference to<br>&gt; AnyObject generate a warning?<br></p><p>Of course not. Extending the attempt to solve reference cycles in all special cases like inherited types, protocols, generics (is an Array&lt;P&gt; a P?) etc... would lead immediately to the thought &quot;this is not possible to solve in a clean way“. And I think it would be true.<br></p><p>In my experience in app development almost 100% of all reference cycles where caused by the most simple form. And I don&#39;t have hard statistical data about it, just my own experience. But let&#39;s assume that 80% of all strong reference cycles during app development are in this simple form. Or just 50%. Wouldn&#39;t it still be great to have a warning in 50% of all possible strong reference cycles even if not all other cases are considered?<br></p><p>- Darko<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>Type based reference cycle detection</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>February 28, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 28, 2016, at 10:26 AM, Darko Damjanovic &lt;darkodamjanovic at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;    class A { let myP: P?  }<br>&gt;&gt; <br>&gt;&gt;    class P { let myX: AnyObject?  }<br>&gt;&gt; <br>&gt;&gt; Should this code generate a cycle warning? What if myP&#39;s type is<br>&gt;&gt; GreatGreatGreatGrandParentOfP? Should any two class with a strong reference to<br>&gt;&gt; AnyObject generate a warning?<br>&gt; <br>&gt; Of course not. Extending the attempt to solve reference cycles in all special cases like inherited types, protocols, generics (is an Array&lt;P&gt; a P?) etc... would lead immediately to the thought &quot;this is not possible to solve in a clean way“. And I think it would be true.<br>&gt; <br>&gt; In my experience in app development almost 100% of all reference cycles where caused by the most simple form. And I don&#39;t have hard statistical data about it, just my own experience. But let&#39;s assume that 80% of all strong reference cycles during app development are in this simple form. Or just 50%. Wouldn&#39;t it still be great to have a warning in 50% of all possible strong reference cycles even if not all other cases are considered?<br>&gt; <br>&gt; - Darko<br>&gt; <br>&gt; <br></p><p><br>Note I agree that a warning about retain cycle is a good idea. Otherwise<br>I would not bring up how to implement it at all.  (I happened to have<br>implemented the cycle detection for value types in swiftc. During that process<br>I thought about this very issue, a lot.)<br></p><p>The key phrase here is “simple form”. We need to translate this into code at<br>some point, no?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b281e721f8cbea65ab93ef72bd034a70?s=50"></div><header><strong>Type based reference cycle detection</strong> from <string>Darko Damjanovic</string> &lt;darkodamjanovic at me.com&gt;<p>February 28, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Note I agree that a warning about retain cycle is a good idea. Otherwise<br>&gt; I would not bring up how to implement it at all.  (I happened to have<br>&gt; implemented the cycle detection for value types in swiftc. During that process<br>&gt; I thought about this very issue, a lot.)<br>&gt; <br>&gt; The key phrase here is “simple form”. We need to translate this into code at<br>&gt; some point, no?<br></p><p>Sorry, I did not want to sound offending. It’s just that the discussion in the developer forums ended soon because of too high expectations.<br></p><p>Regarding the implementation: I really have no idea. I am an application developer for 28 years but I do not have any experience in compiler development. From my point of view the compiler just should issue a warning about a reference cycle so I can mark the reference weak or unowned. This would be enough for me.<br></p><p> - Darko<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/b4fd9f0c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b281e721f8cbea65ab93ef72bd034a70?s=50"></div><header><strong>Type based reference cycle detection</strong> from <string>Darko Damjanovic</string> &lt;darkodamjanovic at me.com&gt;<p>February 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; The key phrase here is “simple form”. We need to translate this into code at<br>&gt; some point, no?<br></p><p>With „simple form“ I really mean the simplest possible form:<br></p><p>    class A {<br>       	var myB: B?<br>    }<br></p><p>    class B {<br>        var myA: A?<br>    }<br></p><p>So exactly class A and exactly class B. If I understand it correct then the detection of inherited or derived types (or Protocols) would only be possible during runtime.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/361e272d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
