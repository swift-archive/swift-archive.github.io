<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 22, 2016 at 12:00:00am</p></header><div class="content"><p>https://github.com/DevAndArtist/swift-evolution/blob/rename_t_dot_type/proposals/0126-rename-t-dot-type.md<br></p><p>Rename T.Type<br></p><p>Proposal: SE–0126<br>Authors: Adrian Zubarev, Anton Zhilin<br>Status: Revision<br>Review manager: Chris Lattner<br>Revision: 2<br>Previous Revisions: 1<br>Introduction<br></p><p>This proposal renames the current metatype T.Type notation and the global function from SE–0096 to match the changes.<br></p><p>Swift-evolution threads:<br></p><p>[Pitch] Rename T.Type<br>[Review] SE–0126: Refactor Metatypes, repurpose T[dot]self and Mirror<br>[Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror<br>[Discussion] Seal T.Type into Type&lt;T&gt;<br>Motivation<br></p><p>In Swift metatypes have the following notation: T.Type<br></p><p>As already showed in SE–0096 and SE–0090 the Swift community strongly is in favor of (re)moving magical intstance or type properties.<br></p><p>SE–0096 moves instanceOfT.dynamicType to type&lt;T&gt;(of: T) -&gt; T.Type.<br></p><p>SE–0090 aims to remove .self completely.<br></p><p>We propose to rename T.Type to a generic-like notation Metatype&lt;T&gt;. To be able to achieve this notation we have to resolve a few issues first.<br></p><p>Known issues of metatypes:<br></p><p>Assume this function that checks if an Int type conforms to a specific protocol. This check uses current model of metatypes combined in a generic context:<br></p><p>func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>   return Int.self is T.Type<br>}<br></p><p>intConforms(to: CustomStringConvertible.self) //=&gt; false<br></p><p>Int.self is CustomStringConvertible.Type      //=&gt; true<br>[1] When T is a protocol P, T.Type is the metatype of the protocol type itself, P.Protocol. Int.self is not P.self.<br></p><p>[2] There isn’t a way to generically expression P.Type yet.<br></p><p>[3] The syntax would have to be changed in the compiler to get something that behaves like .Type today.<br></p><p>Written by Joe Groff: [1] [2] [3]<br>A possible workaround might look like the example below, but does not allow to decompose P.Type:<br></p><p>func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>  return Int.self is T<br>}<br></p><p>intConforms(to: CustomStringConvertible.Type.self) //=&gt; true<br>We can extend this issue and find the second problem by checking against the metatype of Any:<br></p><p>func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>    return Int.self is T<br>}<br></p><p>intConforms(to: Any.Type.self) //=&gt; true<br></p><p>intConforms(to: Any.self)      //=&gt; true<br></p><p>Int.self is Any.Type           //=&gt; Always true<br>When using Any the compiler does not require .Type at all and returns true for both variations.<br></p><p>The third issue will show itself whenever we would try to check protocol relationship with another protocol. Currently there is no way (that we know of) to solve this problem:<br></p><p>protocol P {}<br>protocol R : P {}<br></p><p>func rIsSubtype&lt;T&gt;(of _: T.Type) -&gt; Bool {<br>    return R.self is T<br>}<br></p><p>rIsSubtype(of: P.Type.self) //=&gt; false<br></p><p>R.self is Any.Type //=&gt; Always true<br>R.self is P.Type   //=&gt; true<br>R.self is R.Type   //=&gt; true<br>We also believe that this issue is the reason why the current global functions sizeof, strideof and alignof make use of generic &lt;T&gt;(_: T.Type) declaration notation instead of (_: Any.Type).<br></p><p>Proposed solution<br></p><p>Rename any occurrence of T.Type and T.Protocol to Metatype&lt;T&gt;.<br></p><p>Revise metatypes internally.<br></p><p>When T is a protocol, T.self should always return an instance of Metatype&lt;T&gt; (old T.Type) and never a T.Protocol. Furthermore, metatypes should reflect the same type relationship behavior like the actual types themselves.<br></p><p>To match the correct meaning and usage of the noun ‘Metatype’ from this proposal, we also propose to rename the global function from SE–0096:<br></p><p>before: public func type&lt;T&gt;(of instance: T) -&gt; T.Type<br>after: public func metatype&lt;T&gt;(of instance: T) -&gt; Metatype&lt;T&gt;<br>Examples:<br></p><p>protocol P {}<br>protocol R : P {}<br>class A : P {}<br>class B : A, R {}<br></p><p>func `is`&lt;T&gt;(metatype: Metatype&lt;Any&gt;, also _: Metatype&lt;T&gt; ) -&gt; Bool {<br>    return metatype is Metatype&lt;T&gt;<br>}<br></p><p>`is`(metatype: R.self, also: Any.self) //=&gt; true | Currently: false<br>`is`(metatype: R.self, also: P.self)   //=&gt; true | Currently: false<br>`is`(metatype: R.self, also: R.self)   //=&gt; true<br></p><p>`is`(metatype: B.self, also: Any.self) //=&gt; true | Currently: false<br>`is`(metatype: B.self, also: P.self)   //=&gt; true | Currently: false<br>`is`(metatype: B.self, also: R.self)   //=&gt; true | Currently: false<br>`is`(metatype: B.self, also: A.self)   //=&gt; true<br>`is`(metatype: B.self, also: B.self)   //=&gt; true<br></p><p>func cast&lt;T&gt;(metatype: Metatype&lt;Any&gt;, to _: Metatype&lt;T&gt;) -&gt; Metatype&lt;T&gt;? {<br>    return metatype as? Metatype&lt;T&gt;<br>}<br></p><p>cast(metatype: R.self, to: Any.self)     //=&gt; an Optional&lt;Metatype&lt;Any&gt;&gt; | Currently: nil<br>cast(metatype: R.self, to: P.self)       //=&gt; an Optional&lt;Metatype&lt;P&gt;&gt;   | Currently: nil<br>cast(metatype: R.self, to: R.self)       //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: an Optional&lt;R.Protocol&gt;<br></p><p>let anyR: Any.Type = R.self<br>let r = cast(metatype: anyR, to: R.self) //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: an Optional&lt;R.Protocol&gt;<br></p><p>cast(metatype: B.self, to: Any.self)     //=&gt; an Optional&lt;Metatype&lt;Any&gt;&gt; | Currently: nil<br>cast(metatype: B.self, to: P.self)       //=&gt; an Optional&lt;Metatype&lt;P&gt;&gt;   | Currently: nil<br>cast(metatype: B.self, to: R.self)       //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: nil<br>cast(metatype: B.self, to: A.self)       //=&gt; an Optional&lt;Metatype&lt;A&gt;&gt;<br>cast(metatype: B.self, to: B.self)       //=&gt; an Optional&lt;Metatype&lt;B&gt;&gt;<br></p><p>let pB: P.Type = B.self<br>let b = cast(metatype: pB, to: B.self)   //=&gt; an Optional&lt;Metatype&lt;B&gt;&gt;<br>Impact on existing code<br></p><p>This is a source-breaking change that can be automated by a migrator. Any occurrence of T.Type or T.Protocol will be simply renamed to Metatype&lt;T&gt;.<br></p><p>Alternatives considered<br></p><p>Alternatively it’s reasonable to consider to rename T.self to T.metatype.<br>It was considered to reserve Type&lt;T&gt; for different usage in the future.<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/bdfd553c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 22, 2016 at 01:00:00am</p></header><div class="content"><p>As unfocussed as original<br>Regards<br>(From mobile)<br></p><p>&gt; On Jul 22, 2016, at 12:40 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; https://github.com/DevAndArtist/swift-evolution/blob/rename_t_dot_type/proposals/0126-rename-t-dot-type.md<br>&gt; <br>&gt; Rename T.Type<br>&gt; <br>&gt; Proposal: SE–0126<br>&gt; Authors: Adrian Zubarev, Anton Zhilin<br>&gt; Status: Revision<br>&gt; Review manager: Chris Lattner<br>&gt; Revision: 2<br>&gt; Previous Revisions: 1<br>&gt; Introduction<br>&gt; <br>&gt; This proposal renames the current metatype T.Type notation and the global function from SE–0096 to match the changes.<br>&gt; <br>&gt; Swift-evolution threads:<br>&gt; <br>&gt; [Pitch] Rename T.Type<br>&gt; [Review] SE–0126: Refactor Metatypes, repurpose T[dot]self and Mirror<br>&gt; [Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror<br>&gt; [Discussion] Seal T.Type into Type&lt;T&gt;<br>&gt; Motivation<br>&gt; <br>&gt; In Swift metatypes have the following notation: T.Type<br>&gt; <br>&gt; As already showed in SE–0096 and SE–0090 the Swift community strongly is in favor of (re)moving magical intstance or type properties.<br>&gt; <br>&gt; SE–0096 moves instanceOfT.dynamicType to type&lt;T&gt;(of: T) -&gt; T.Type.<br>&gt; <br>&gt; SE–0090 aims to remove .self completely.<br>&gt; <br>&gt; We propose to rename T.Type to a generic-like notation Metatype&lt;T&gt;. To be able to achieve this notation we have to resolve a few issues first.<br>&gt; <br>&gt; Known issues of metatypes:<br>&gt; <br>&gt; Assume this function that checks if an Int type conforms to a specific protocol. This check uses current model of metatypes combined in a generic context:<br>&gt; <br>&gt; func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>&gt;    return Int.self is T.Type<br>&gt; }<br>&gt; <br>&gt; intConforms(to: CustomStringConvertible.self) //=&gt; false<br>&gt; <br>&gt; Int.self is CustomStringConvertible.Type      //=&gt; true<br>&gt; [1] When T is a protocol P, T.Type is the metatype of the protocol type itself, P.Protocol. Int.self is not P.self.<br>&gt; <br>&gt; [2] There isn’t a way to generically expression P.Type yet.<br>&gt; <br>&gt; [3] The syntax would have to be changed in the compiler to get something that behaves like .Type today.<br>&gt; <br>&gt; Written by Joe Groff: [1] [2] [3]<br>&gt; A possible workaround might look like the example below, but does not allow to decompose P.Type:<br>&gt; <br>&gt; func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>&gt;   return Int.self is T<br>&gt; }<br>&gt; <br>&gt; intConforms(to: CustomStringConvertible.Type.self) //=&gt; true<br>&gt; We can extend this issue and find the second problem by checking against the metatype of Any:<br>&gt; <br>&gt; func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>&gt;     return Int.self is T<br>&gt; }<br>&gt; <br>&gt; intConforms(to: Any.Type.self) //=&gt; true<br>&gt; <br>&gt; intConforms(to: Any.self)      //=&gt; true<br>&gt; <br>&gt; Int.self is Any.Type           //=&gt; Always true<br>&gt; When using Any the compiler does not require .Type at all and returns true for both variations.<br>&gt; <br>&gt; The third issue will show itself whenever we would try to check protocol relationship with another protocol. Currently there is no way (that we know of) to solve this problem:<br>&gt; <br>&gt; protocol P {}<br>&gt; protocol R : P {}<br>&gt; <br>&gt; func rIsSubtype&lt;T&gt;(of _: T.Type) -&gt; Bool {<br>&gt;     return R.self is T<br>&gt; }<br>&gt; <br>&gt; rIsSubtype(of: P.Type.self) //=&gt; false<br>&gt; <br>&gt; R.self is Any.Type //=&gt; Always true<br>&gt; R.self is P.Type   //=&gt; true<br>&gt; R.self is R.Type   //=&gt; true<br>&gt; We also believe that this issue is the reason why the current global functions sizeof, strideof and alignof make use of generic &lt;T&gt;(_: T.Type) declaration notation instead of (_: Any.Type).<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Rename any occurrence of T.Type and T.Protocol to Metatype&lt;T&gt;.<br>&gt; <br>&gt; Revise metatypes internally.<br>&gt; <br>&gt; When T is a protocol, T.self should always return an instance of Metatype&lt;T&gt; (old T.Type) and never a T.Protocol. Furthermore, metatypes should reflect the same type relationship behavior like the actual types themselves.<br>&gt; <br>&gt; To match the correct meaning and usage of the noun ‘Metatype’ from this proposal, we also propose to rename the global function from SE–0096:<br>&gt; <br>&gt; before: public func type&lt;T&gt;(of instance: T) -&gt; T.Type<br>&gt; after: public func metatype&lt;T&gt;(of instance: T) -&gt; Metatype&lt;T&gt;<br>&gt; Examples:<br>&gt; <br>&gt; protocol P {}<br>&gt; protocol R : P {}<br>&gt; class A : P {}<br>&gt; class B : A, R {}<br>&gt; <br>&gt; func `is`&lt;T&gt;(metatype: Metatype&lt;Any&gt;, also _: Metatype&lt;T&gt; ) -&gt; Bool {<br>&gt;     return metatype is Metatype&lt;T&gt;<br>&gt; }<br>&gt; <br>&gt; `is`(metatype: R.self, also: Any.self) //=&gt; true | Currently: false<br>&gt; `is`(metatype: R.self, also: P.self)   //=&gt; true | Currently: false<br>&gt; `is`(metatype: R.self, also: R.self)   //=&gt; true<br>&gt; <br>&gt; `is`(metatype: B.self, also: Any.self) //=&gt; true | Currently: false<br>&gt; `is`(metatype: B.self, also: P.self)   //=&gt; true | Currently: false<br>&gt; `is`(metatype: B.self, also: R.self)   //=&gt; true | Currently: false<br>&gt; `is`(metatype: B.self, also: A.self)   //=&gt; true<br>&gt; `is`(metatype: B.self, also: B.self)   //=&gt; true<br>&gt; <br>&gt; func cast&lt;T&gt;(metatype: Metatype&lt;Any&gt;, to _: Metatype&lt;T&gt;) -&gt; Metatype&lt;T&gt;? {<br>&gt;     return metatype as? Metatype&lt;T&gt;<br>&gt; }<br>&gt; <br>&gt; cast(metatype: R.self, to: Any.self)     //=&gt; an Optional&lt;Metatype&lt;Any&gt;&gt; | Currently: nil<br>&gt; cast(metatype: R.self, to: P.self)       //=&gt; an Optional&lt;Metatype&lt;P&gt;&gt;   | Currently: nil<br>&gt; cast(metatype: R.self, to: R.self)       //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: an Optional&lt;R.Protocol&gt;<br>&gt; <br>&gt; let anyR: Any.Type = R.self<br>&gt; let r = cast(metatype: anyR, to: R.self) //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: an Optional&lt;R.Protocol&gt;<br>&gt; <br>&gt; cast(metatype: B.self, to: Any.self)     //=&gt; an Optional&lt;Metatype&lt;Any&gt;&gt; | Currently: nil<br>&gt; cast(metatype: B.self, to: P.self)       //=&gt; an Optional&lt;Metatype&lt;P&gt;&gt;   | Currently: nil<br>&gt; cast(metatype: B.self, to: R.self)       //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: nil<br>&gt; cast(metatype: B.self, to: A.self)       //=&gt; an Optional&lt;Metatype&lt;A&gt;&gt;<br>&gt; cast(metatype: B.self, to: B.self)       //=&gt; an Optional&lt;Metatype&lt;B&gt;&gt;<br>&gt; <br>&gt; let pB: P.Type = B.self<br>&gt; let b = cast(metatype: pB, to: B.self)   //=&gt; an Optional&lt;Metatype&lt;B&gt;&gt;<br>&gt; Impact on existing code<br>&gt; <br>&gt; This is a source-breaking change that can be automated by a migrator. Any occurrence of T.Type or T.Protocol will be simply renamed to Metatype&lt;T&gt;.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Alternatively it’s reasonable to consider to rename T.self to T.metatype.<br>&gt; It was considered to reserve Type&lt;T&gt; for different usage in the future.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/5710aaa6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 21, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 21, 2016, at 4:07 PM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As unfocussed as original<br></p><p>Please keep comments *constructive* on this list.<br></p><p>-Chris<br></p><p><br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt; On Jul 22, 2016, at 12:40 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; https://github.com/DevAndArtist/swift-evolution/blob/rename_t_dot_type/proposals/0126-rename-t-dot-type.md &lt;https://github.com/DevAndArtist/swift-evolution/blob/rename_t_dot_type/proposals/0126-rename-t-dot-type.md&gt;<br>&gt;&gt; Rename T.Type<br>&gt;&gt; <br>&gt;&gt; Proposal: SE–0126 &lt;x-msg://594/0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.md&gt;<br>&gt;&gt; Authors: Adrian Zubarev &lt;https://github.com/DevAndArtist&gt;, Anton Zhilin &lt;https://github.com/Anton3&gt;<br>&gt;&gt; Status: Revision<br>&gt;&gt; Review manager: Chris Lattner &lt;http://github.com/lattner&gt;<br>&gt;&gt; Revision: 2<br>&gt;&gt; Previous Revisions: 1 &lt;https://github.com/apple/swift-evolution/blob/83707b0879c83dcde778f8163f5768212736fdc2/proposals/0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.md&gt;<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal renames the current metatype T.Type notation and the global function from SE–0096 to match the changes.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution threads: <br>&gt;&gt; <br>&gt;&gt; [Pitch] Rename T.Type &lt;applewebdata://1A857E6E-5ECA-433A-9669-6DB2B5E23BD0&gt;<br>&gt;&gt; [Review] SE–0126: Refactor Metatypes, repurpose T[dot]self and Mirror &lt;applewebdata://1A857E6E-5ECA-433A-9669-6DB2B5E23BD0&gt;<br>&gt;&gt; [Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160718/024772.html&gt;<br>&gt;&gt; [Discussion] Seal T.Type into Type&lt;T&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160704/023818.html&gt;<br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; In Swift metatypes have the following notation: T.Type<br>&gt;&gt; <br>&gt;&gt; As already showed in SE–0096 and SE–0090 the Swift community strongly is in favor of (re)moving magical intstance or type properties.<br>&gt;&gt; <br>&gt;&gt; SE–0096 moves instanceOfT.dynamicType to type&lt;T&gt;(of: T) -&gt; T.Type.<br>&gt;&gt; <br>&gt;&gt; SE–0090 aims to remove .self completely.<br>&gt;&gt; <br>&gt;&gt; We propose to rename T.Type to a generic-like notation Metatype&lt;T&gt;. To be able to achieve this notation we have to resolve a few issues first.<br>&gt;&gt; <br>&gt;&gt; Known issues of metatypes:<br>&gt;&gt; <br>&gt;&gt; Assume this function that checks if an Int type conforms to a specific protocol. This check uses current model of metatypes combined in a generic context:<br>&gt;&gt; <br>&gt;&gt; func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>&gt;&gt;    return Int.self is T.Type<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; intConforms(to: CustomStringConvertible.self) //=&gt; false<br>&gt;&gt; <br>&gt;&gt; Int.self is CustomStringConvertible.Type      //=&gt; true<br>&gt;&gt; [1] When T is a protocol P, T.Type is the metatype of the protocol type itself, P.Protocol. Int.self is not P.self.<br>&gt;&gt; <br>&gt;&gt; [2] There isn’t a way to generically expression P.Type yet.<br>&gt;&gt; <br>&gt;&gt; [3] The syntax would have to be changed in the compiler to get something that behaves like .Type today.<br>&gt;&gt; <br>&gt;&gt; Written by Joe Groff: [1] &lt;https://twitter.com/jckarter/status/754420461404958721&gt; [2] &lt;https://twitter.com/jckarter/status/754420624261472256&gt; [3] &lt;https://twitter.com/jckarter/status/754425573762478080&gt;<br>&gt;&gt; A possible workaround might look like the example below, but does not allow to decompose P.Type:<br>&gt;&gt; <br>&gt;&gt; func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>&gt;&gt;   return Int.self is T<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; intConforms(to: CustomStringConvertible.Type.self) //=&gt; true<br>&gt;&gt; We can extend this issue and find the second problem by checking against the metatype of Any:<br>&gt;&gt; <br>&gt;&gt; func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>&gt;&gt;     return Int.self is T<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; intConforms(to: Any.Type.self) //=&gt; true<br>&gt;&gt; <br>&gt;&gt; intConforms(to: Any.self)      //=&gt; true<br>&gt;&gt; <br>&gt;&gt; Int.self is Any.Type           //=&gt; Always true<br>&gt;&gt; When using Any the compiler does not require .Type at all and returns true for both variations.<br>&gt;&gt; <br>&gt;&gt; The third issue will show itself whenever we would try to check protocol relationship with another protocol. Currently there is no way (that we know of) to solve this problem:<br>&gt;&gt; <br>&gt;&gt; protocol P {}<br>&gt;&gt; protocol R : P {}<br>&gt;&gt; <br>&gt;&gt; func rIsSubtype&lt;T&gt;(of _: T.Type) -&gt; Bool {<br>&gt;&gt;     return R.self is T<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; rIsSubtype(of: P.Type.self) //=&gt; false<br>&gt;&gt; <br>&gt;&gt; R.self is Any.Type //=&gt; Always true<br>&gt;&gt; R.self is P.Type   //=&gt; true<br>&gt;&gt; R.self is R.Type   //=&gt; true<br>&gt;&gt; We also believe that this issue is the reason why the current global functions sizeof, strideof and alignof make use of generic &lt;T&gt;(_: T.Type) declaration notation instead of (_: Any.Type).<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; Rename any occurrence of T.Type and T.Protocol to Metatype&lt;T&gt;.<br>&gt;&gt; <br>&gt;&gt; Revise metatypes internally. <br>&gt;&gt; <br>&gt;&gt; When T is a protocol, T.self should always return an instance of Metatype&lt;T&gt; (old T.Type) and never a T.Protocol. Furthermore, metatypes should reflect the same type relationship behavior like the actual types themselves. <br>&gt;&gt; <br>&gt;&gt; To match the correct meaning and usage of the noun ‘Metatype’ from this proposal, we also propose to rename the global function from SE–0096:<br>&gt;&gt; <br>&gt;&gt; before: public func type&lt;T&gt;(of instance: T) -&gt; T.Type<br>&gt;&gt; after: public func metatype&lt;T&gt;(of instance: T) -&gt; Metatype&lt;T&gt;<br>&gt;&gt; Examples:<br>&gt;&gt; <br>&gt;&gt; protocol P {}<br>&gt;&gt; protocol R : P {}<br>&gt;&gt; class A : P {}<br>&gt;&gt; class B : A, R {}<br>&gt;&gt; <br>&gt;&gt; func `is`&lt;T&gt;(metatype: Metatype&lt;Any&gt;, also _: Metatype&lt;T&gt; ) -&gt; Bool {<br>&gt;&gt;     return metatype is Metatype&lt;T&gt;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; `is`(metatype: R.self, also: Any.self) //=&gt; true | Currently: false<br>&gt;&gt; `is`(metatype: R.self, also: P.self)   //=&gt; true | Currently: false<br>&gt;&gt; `is`(metatype: R.self, also: R.self)   //=&gt; true<br>&gt;&gt; <br>&gt;&gt; `is`(metatype: B.self, also: Any.self) //=&gt; true | Currently: false<br>&gt;&gt; `is`(metatype: B.self, also: P.self)   //=&gt; true | Currently: false<br>&gt;&gt; `is`(metatype: B.self, also: R.self)   //=&gt; true | Currently: false<br>&gt;&gt; `is`(metatype: B.self, also: A.self)   //=&gt; true<br>&gt;&gt; `is`(metatype: B.self, also: B.self)   //=&gt; true<br>&gt;&gt; <br>&gt;&gt; func cast&lt;T&gt;(metatype: Metatype&lt;Any&gt;, to _: Metatype&lt;T&gt;) -&gt; Metatype&lt;T&gt;? {<br>&gt;&gt;     return metatype as? Metatype&lt;T&gt;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; cast(metatype: R.self, to: Any.self)     //=&gt; an Optional&lt;Metatype&lt;Any&gt;&gt; | Currently: nil<br>&gt;&gt; cast(metatype: R.self, to: P.self)       //=&gt; an Optional&lt;Metatype&lt;P&gt;&gt;   | Currently: nil<br>&gt;&gt; cast(metatype: R.self, to: R.self)       //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: an Optional&lt;R.Protocol&gt;<br>&gt;&gt; <br>&gt;&gt; let anyR: Any.Type = R.self<br>&gt;&gt; let r = cast(metatype: anyR, to: R.self) //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: an Optional&lt;R.Protocol&gt;<br>&gt;&gt; <br>&gt;&gt; cast(metatype: B.self, to: Any.self)     //=&gt; an Optional&lt;Metatype&lt;Any&gt;&gt; | Currently: nil<br>&gt;&gt; cast(metatype: B.self, to: P.self)       //=&gt; an Optional&lt;Metatype&lt;P&gt;&gt;   | Currently: nil<br>&gt;&gt; cast(metatype: B.self, to: R.self)       //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: nil<br>&gt;&gt; cast(metatype: B.self, to: A.self)       //=&gt; an Optional&lt;Metatype&lt;A&gt;&gt;<br>&gt;&gt; cast(metatype: B.self, to: B.self)       //=&gt; an Optional&lt;Metatype&lt;B&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; let pB: P.Type = B.self<br>&gt;&gt; let b = cast(metatype: pB, to: B.self)   //=&gt; an Optional&lt;Metatype&lt;B&gt;&gt;<br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a source-breaking change that can be automated by a migrator. Any occurrence of T.Type or T.Protocol will be simply renamed to Metatype&lt;T&gt;.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Alternatively it’s reasonable to consider to rename T.self to T.metatype.<br>&gt;&gt; It was considered to reserve Type&lt;T&gt; for different usage in the future.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/b90990fe/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 21, 2016 at 06:00:00pm</p></header><div class="content"><p>On Thu, Jul 21, 2016 at 5:40 PM, Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; https://github.com/DevAndArtist/swift-evolution/blob/rename_t_dot_type/proposals/0126-rename-t-dot-type.md<br>&gt; ------------------------------<br>&gt; Rename T.Type<br>&gt;<br>&gt;    - Proposal: SE–0126<br>&gt;    &lt;http://0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.md&gt;<br>&gt;    - Authors: Adrian Zubarev &lt;https://github.com/DevAndArtist&gt;, Anton<br>&gt;    Zhilin &lt;https://github.com/Anton3&gt;<br>&gt;    - Status: *Revision*<br>&gt;    - Review manager: Chris Lattner &lt;http://github.com/lattner&gt;<br>&gt;    - Revision: 2<br>&gt;    - Previous Revisions: 1<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/83707b0879c83dcde778f8163f5768212736fdc2/proposals/0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.md&gt;<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal renames the current metatype T.Type notation and the global<br>&gt; function from *SE–0096* to match the changes.<br>&gt;<br>&gt; Swift-evolution threads:<br>&gt;<br>&gt;    - [Pitch] Rename T.Type<br>&gt;    - [Review] SE–0126: Refactor Metatypes, repurpose T[dot]self and Mirror<br>&gt;    - [Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160718/024772.html&gt;<br>&gt;    - [Discussion] Seal T.Type into Type&lt;T&gt;<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160704/023818.html&gt;<br>&gt;<br>&gt; Motivation<br>&gt;<br></p><p>For improved reader comprehension, this section could use some more<br>information and reorganization. Specifically, the structure should (IMO) be<br>refactored to have:<br></p><p>1. A consolidated section--which can be on the brief side--on the current<br>art (i.e., how do things currently work?). Some information is already<br>present, but the prose is not possible to follow unless one is already an<br>expert in the area. Please start each paragraph with a topic sentence<br>leading into an explanation in English, not just code, of the current<br>behavior. Perhaps you could used (attributed) quotations from existing<br>Swift documentation if necessary.<br></p><p>2. Subsequent to (1), a concise explanation in English (in addition to<br>Swift code, if desired, but the key is to have it also in English)<br>outlining the defects present in the current art. I know, for instance,<br>that type(of:) as approved can&#39;t quite be expressed in Swift code due to<br>issues related to existential metatypes. Could you elaborate on these<br>issues in a way that would set up your proposed solution?<br></p><p><br>&gt; In Swift metatypes have the following notation: *T.Type*<br>&gt;<br>&gt; As already showed in *SE–0096* and *SE–0090* the Swift community strongly<br>&gt; is in favor of (re)moving magical intstance or type properties.<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    *SE–0096* moves instanceOfT.dynamicType to type&lt;T&gt;(of: T) -&gt; T.Type.<br>&gt;    -<br>&gt;<br>&gt;    *SE–0090* aims to remove .self completely.<br>&gt;<br>&gt; We propose to rename T.Type to a generic-like notation Metatype&lt;T&gt;. To be<br>&gt; able to achieve this notation we have to resolve a few issues first.<br>&gt; Known issues of metatypes:<br>&gt;<br>&gt; Assume this function that checks if an Int type conforms to a specific<br>&gt; protocol. This check uses current model of metatypes combined in a generic<br>&gt; context:<br>&gt;<br>&gt; func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>&gt;    return Int.self is T.Type<br>&gt; }<br>&gt;<br>&gt; intConforms(to: CustomStringConvertible.self) //=&gt; false<br>&gt;<br>&gt; Int.self is CustomStringConvertible.Type      //=&gt; true<br>&gt;<br>&gt; [1] When T is a protocol P, T.Type is the metatype of the protocol type<br>&gt; itself, P.Protocol. Int.self is not P.self.<br>&gt;<br>&gt; [2] There isn’t a way to generically expression P.Type *yet*.<br>&gt;<br>&gt; [3] The syntax would have to be changed in the compiler to get something<br>&gt; that behaves like .Type today.<br>&gt;<br>&gt; Written by Joe Groff: [1]<br>&gt; &lt;https://twitter.com/jckarter/status/754420461404958721&gt; [2]<br>&gt; &lt;https://twitter.com/jckarter/status/754420624261472256&gt; [3]<br>&gt; &lt;https://twitter.com/jckarter/status/754425573762478080&gt;<br>&gt;<br>&gt; A possible workaround might look like the example below, but does not<br>&gt; allow to decompose P.Type:<br>&gt;<br>&gt; func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>&gt;   return Int.self is T<br>&gt; }<br>&gt;<br>&gt; intConforms(to: CustomStringConvertible.Type.self) //=&gt; true<br>&gt;<br>&gt; We can extend this issue and find the second problem by checking against<br>&gt; the metatype of Any:<br>&gt;<br>&gt; func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>&gt;     return Int.self is T<br>&gt; }<br>&gt;<br>&gt; intConforms(to: Any.Type.self) //=&gt; true<br>&gt;<br>&gt; intConforms(to: Any.self)      //=&gt; true<br>&gt;<br>&gt; Int.self is Any.Type           //=&gt; Always true<br>&gt;<br>&gt; When using Any the compiler does not require .Type at all and returns true<br>&gt; for both variations.<br>&gt;<br>&gt; The third issue will show itself whenever we would try to check protocol<br>&gt; relationship with another protocol. Currently there is no way (that we know<br>&gt; of) to solve this problem:<br>&gt;<br>&gt; protocol P {}<br>&gt; protocol R : P {}<br>&gt;<br>&gt; func rIsSubtype&lt;T&gt;(of _: T.Type) -&gt; Bool {<br>&gt;     return R.self is T<br>&gt; }<br>&gt;<br>&gt; rIsSubtype(of: P.Type.self) //=&gt; false<br>&gt;<br>&gt; R.self is Any.Type //=&gt; Always true<br>&gt; R.self is P.Type   //=&gt; true<br>&gt; R.self is R.Type   //=&gt; true<br>&gt;<br>&gt; We also believe that this issue is the reason why the current global<br>&gt; functions sizeof, strideof and alignof make use of generic &lt;T&gt;(_: T.Type)<br>&gt; declaration notation instead of (_: Any.Type).<br>&gt; Proposed solution<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Rename any occurrence of T.Type and T.Protocol to Metatype&lt;T&gt;.<br>&gt;<br>&gt;<br>Why is this necessary? It is not clear from what you wrote in the<br>Motivation section. Naively, it would seem like the most straightforward<br>ways to remove the &quot;magic&quot; properties would be to repaint them `Type&lt;T&gt;`<br>and `Protocol&lt;T&gt;`. If you considered that most obvious choice and discarded<br>it (as I&#39;m sure you have), what is the reasoning for suggesting<br>`Metatype&lt;T&gt;` instead?<br></p><p><br>&gt;    -<br>&gt;<br>&gt;    Revise metatypes internally.<br>&gt;<br>&gt;<br>In what way? How would you want an implementer to tackle this bullet point?<br>What are the user-observable changes that will result, if any? If there<br>will be none, why is it part of the proposed solution?<br></p><p><br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    When T is a protocol, T.self should always return an instance of<br>&gt;    Metatype&lt;T&gt; (old T.Type) and never a T.Protocol. Furthermore,<br>&gt;    metatypes should reflect the same type relationship behavior like the<br>&gt;    actual types themselves.<br>&gt;<br>&gt;<br>If this is implemented, how will I then access the value currently returned<br>by `T.self`? Are you asserting that an instance of `T.Protocol` is never<br>useful, or are you providing an alternative way to get the same instance?<br></p><p><br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    To match the correct meaning and usage of the noun ‘Metatype’ from<br>&gt;    this proposal, we also propose to rename the global function from<br>&gt;    *SE–0096*:<br>&gt;    - before: public func type&lt;T&gt;(of instance: T) -&gt; T.Type<br>&gt;       - after: public func metatype&lt;T&gt;(of instance: T) -&gt; Metatype&lt;T&gt;<br>&gt;<br>&gt; Examples:<br>&gt;<br>&gt; protocol P {}<br>&gt; protocol R : P {}<br>&gt; class A : P {}<br>&gt; class B : A, R {}<br>&gt;<br>&gt; func `is`&lt;T&gt;(metatype: Metatype&lt;Any&gt;, also _: Metatype&lt;T&gt; ) -&gt; Bool {<br>&gt;     return metatype is Metatype&lt;T&gt;<br>&gt; }<br>&gt;<br>&gt; `is`(metatype: R.self, also: Any.self) //=&gt; true | Currently: false<br>&gt; `is`(metatype: R.self, also: P.self)   //=&gt; true | Currently: false<br>&gt; `is`(metatype: R.self, also: R.self)   //=&gt; true<br>&gt;<br>&gt; `is`(metatype: B.self, also: Any.self) //=&gt; true | Currently: false<br>&gt; `is`(metatype: B.self, also: P.self)   //=&gt; true | Currently: false<br>&gt; `is`(metatype: B.self, also: R.self)   //=&gt; true | Currently: false<br>&gt; `is`(metatype: B.self, also: A.self)   //=&gt; true<br>&gt; `is`(metatype: B.self, also: B.self)   //=&gt; true<br>&gt;<br>&gt; func cast&lt;T&gt;(metatype: Metatype&lt;Any&gt;, to _: Metatype&lt;T&gt;) -&gt; Metatype&lt;T&gt;? {<br>&gt;     return metatype as? Metatype&lt;T&gt;<br>&gt; }<br>&gt;<br>&gt; cast(metatype: R.self, to: Any.self)     //=&gt; an Optional&lt;Metatype&lt;Any&gt;&gt; | Currently: nil<br>&gt; cast(metatype: R.self, to: P.self)       //=&gt; an Optional&lt;Metatype&lt;P&gt;&gt;   | Currently: nil<br>&gt; cast(metatype: R.self, to: R.self)       //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: an Optional&lt;R.Protocol&gt;<br>&gt;<br>&gt; let anyR: Any.Type = R.self<br>&gt; let r = cast(metatype: anyR, to: R.self) //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: an Optional&lt;R.Protocol&gt;<br>&gt;<br>&gt; cast(metatype: B.self, to: Any.self)     //=&gt; an Optional&lt;Metatype&lt;Any&gt;&gt; | Currently: nil<br>&gt; cast(metatype: B.self, to: P.self)       //=&gt; an Optional&lt;Metatype&lt;P&gt;&gt;   | Currently: nil<br>&gt; cast(metatype: B.self, to: R.self)       //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: nil<br>&gt; cast(metatype: B.self, to: A.self)       //=&gt; an Optional&lt;Metatype&lt;A&gt;&gt;<br>&gt; cast(metatype: B.self, to: B.self)       //=&gt; an Optional&lt;Metatype&lt;B&gt;&gt;<br>&gt;<br>&gt; let pB: P.Type = B.self<br>&gt; let b = cast(metatype: pB, to: B.self)   //=&gt; an Optional&lt;Metatype&lt;B&gt;&gt;<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; This is a source-breaking change that can be automated by a migrator. Any<br>&gt; occurrence of T.Type or T.Protocol will be simply renamed to Metatype&lt;T&gt;.<br>&gt; Alternatives considered<br>&gt;<br>&gt;    - Alternatively it’s reasonable to consider to rename T.self to<br>&gt;    T.metatype.<br>&gt;    - It was considered to reserve Type&lt;T&gt; for different usage in the<br>&gt;    future.<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/df635cb0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>July 22, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 22 Jul 2016, at 01:41, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 1. A consolidated section--which can be on the brief side--on the current art (i.e., how do things currently work?). Some information is already present, but the prose is not possible to follow unless one is already an expert in the area. Please start each paragraph with a topic sentence leading into an explanation in English, not just code, of the current behavior. Perhaps you could used (attributed) quotations from existing Swift documentation if necessary.<br></p><p>I specifically agree with this point. I regard myself as a knowledgable Swift developer, but metatypes have always been a bit fuzzy for me, which refrained me from commenting on the proposal. If instead, the proposal tried to explain as succinctly as possible the current situation and its defects, I’m sure I’d have a higher chance of understand the problem at hand and commenting on it.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/541eead3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July 22, 2016 at 02:00:00pm</p></header><div class="content"><p>For everyone who doesn&#39;t understand metatypes and our problem, please see:<br></p><p>https://gist.github.com/Anton3/25a66751812f14f76cacc5e382339522<br></p><p>Read it from beginning to ending and ask if you don&#39;t understand something!<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/61789ef7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>July 22, 2016 at 03:00:00pm</p></header><div class="content"><p>Thank you for the article. Very informative.<br></p><p>So, I believe core team can answer the question : &quot;..why P.Protocol is <br>needed&quot; and if we can remove it without problems.<br></p><p><br>Small fix - A&amp;B should have &#39;: HasStatic&#39; and closing bracket here:<br></p><p>protocol HasStatic { static func staticMethod() }<br>struct A { static func staticMethod() -&gt; String { return &quot;A&quot; }<br>struct B { static func staticMethod() -&gt; String { return &quot;B&quot; }<br></p><p><br>On 22.07.2016 14:40, Anton Zhilin via swift-evolution wrote:<br>&gt; For everyone who doesn&#39;t understand metatypes and our problem, please see:<br>&gt;<br>&gt; https://gist.github.com/Anton3/25a66751812f14f76cacc5e382339522<br>&gt;<br>&gt; Read it from beginning to ending and ask if you don&#39;t understand something!<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 22, 2016 at 03:00:00pm</p></header><div class="content"><p>Hello everyone,<br></p><p>recently I was pinged on twitter to a conversation between Jacob Bandes-Storch, Joe Groff and Slava Pestov.<br></p><p>Here is the conversation covering a few more facts about the mysterious .Protocol:<br></p><p>[Jacob Bandes-Storch] Was hoping to just define type&lt;T&gt;(of x: T) -&gt; T.Type and move impl of emitMetatypeOfValue() there.<br></p><p>[Joe Groff] Yeah, that won’t do the right thing for existentials compared to x.dynamicType.<br></p><p>[Jacob Bandes-Storch] When you say “do the right thing” you mean the return type? Shouldn’t type(of x: Proto) -&gt; Proto.Type?<br></p><p>[Slava Pestov] Right, but if T := P, then T.Type is P.Protocol, not P.Type<br></p><p>[Jacob Bandes-Storch] Mind bending… Suppose T : P, x : P = T(), then type(of: x) returns T, and T: P.Type. What am I missing?<br></p><p>[Joe Groff] P.Type is really Any&lt;P.Type&gt;, and P.Protocol is really (Any&lt;P&gt;).Type. If T == Any&lt;P&gt;, T.Type == latter<br></p><p>[Joe Groff] dynamicType is different for existentials: open existential, take opened metatype, erase to e.metatype<br></p><p>[Jacob Bandes-Storch] Now I’m confused by current behavior: GIST … isn’t dynamicType’s job to return T.self?<br></p><p>[Joe Groff] invokes `foo() on the opened type, then re-closes an existential around the result if Self is involved<br></p><p>[Jacob Bandes-Storch] But this does what I’d expect: GIST<br></p><p>[Joe Groff] Right, member lookup also implicitly opens an existential.<br></p><p>[Jacob Bandes-Storch] Point being that there’s no way to do this for generic params?<br></p><p>[Joe Groff] Not in argument position. Only ‘self’ gets this magic behavior.<br></p><p>[Jacob Bandes-Storch] Is that a bug or feature? Seems to me dynamicType should always be able to get the actual runtime type.<br></p><p>[Joe Groff] Consider this situation:<br></p><p>func foo&lt;T&gt;(x:T) -&gt; (T.Type, T.Type) {<br>   return (T.self, x.dynamicType)<br>}<br>[Jacob Bandes-Storch] Still struggling to see what’s wrong with returning “real” type. What can be subst. for `T that breaks it?<br></p><p>[Joe Groff] Consider T == P with x.dynamicType trying to produce the existential dynamic type.<br></p><p>[Jacob Bandes-Storch] I think I’m mostly confused because P.Type vs. P.Protocol is really non-obvious. Has renaming been discussed?<br></p><p>[Joe Groff] The gotcha mainly comes up if you try to replicate the builtin behavior. Most people don’t try to do that.<br></p><p>[Jacob Bandes-Storch] Would it make sense to disallow x.dynamicType in such cases? Gotcha would be less confusing if forced to say `T.self.<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 22. Juli 2016 um 14:47:08, Vladimir.S via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Thank you for the article. Very informative.<br></p><p>So, I believe core team can answer the question : &quot;..why P.Protocol is  <br>needed&quot; and if we can remove it without problems.<br></p><p><br>Small fix - A&amp;B should have &#39;: HasStatic&#39; and closing bracket here:<br></p><p>protocol HasStatic { static func staticMethod() }<br>struct A { static func staticMethod() -&gt; String { return &quot;A&quot; }<br>struct B { static func staticMethod() -&gt; String { return &quot;B&quot; }<br></p><p><br>On 22.07.2016 14:40, Anton Zhilin via swift-evolution wrote:<br>&gt; For everyone who doesn&#39;t understand metatypes and our problem, please see:<br>&gt;<br>&gt; https://gist.github.com/Anton3/25a66751812f14f76cacc5e382339522<br>&gt;<br>&gt; Read it from beginning to ending and ask if you don&#39;t understand something!<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/d6acc54d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July 22, 2016 at 04:00:00pm</p></header><div class="content"><p>Interesting, it looks like only Joe Groff understands what .Protocol means<br>and considers it important. And a couple others, maybe.<br></p><p>Copying my metatypes explanation link:<br>For everyone who doesn&#39;t understand metatypes and our problem, please see<br>https://gist.github.com/Anton3/25a66751812f14f76cacc5e382339522<br></p><p>2016-07-22 16:07 GMT+03:00 Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; Hello everyone,<br>&gt;<br>&gt; recently I was pinged on twitter to a conversation between Jacob<br>&gt; Bandes-Storch, Joe Groff and Slava Pestov.<br>&gt;<br>&gt; Here is the conversation covering a few more facts about the mysterious<br>&gt; .Protocol:<br>&gt;<br>&gt; *[Jacob Bandes-Storch]* Was hoping to just define type&lt;T&gt;(of x: T) -&gt;<br>&gt; T.Type and move impl of emitMetatypeOfValue() there.<br>&gt;<br>&gt; *[Joe Groff]* Yeah, that won’t do the right thing for existentials<br>&gt; compared to x.dynamicType.<br>&gt;<br>&gt; *[Jacob Bandes-Storch]* When you say “do the right thing” you mean the<br>&gt; return type? Shouldn’t type(of x: Proto) -&gt; Proto.Type?<br>&gt;<br>&gt; *[Slava Pestov]* Right, but if T := P, then T.Type is P.Protocol, not<br>&gt; P.Type<br>&gt;<br>&gt; *[Jacob Bandes-Storch]* Mind bending… Suppose T : P, x : P = T(), then type(of:<br>&gt; x) returns T, and T: P.Type. What am I missing?<br>&gt;<br>&gt; *[Joe Groff]* P.Type is really Any&lt;P.Type&gt;, and P.Protocol is really<br>&gt; (Any&lt;P&gt;).Type. If T == Any&lt;P&gt;, T.Type == latter<br>&gt;<br>&gt; *[Joe Groff]* dynamicType is different for existentials: open<br>&gt; existential, take opened metatype, erase to e.metatype<br>&gt;<br>&gt; *[Jacob Bandes-Storch]* Now I’m confused by current behavior: GIST<br>&gt; &lt;https://gist.github.com/jtbandes/7624fef93eb23010c032b2d1fd3674be#file-dynamictype-swift-L12&gt;<br>&gt; … isn’t dynamicType’s job to return T.self?<br>&gt;<br>&gt; *[Joe Groff]* invokes `foo() on the opened type, then re-closes an<br>&gt; existential around the result if Self is involved<br>&gt;<br>&gt; *[Jacob Bandes-Storch]* But this does what I’d expect: GIST<br>&gt; &lt;https://gist.github.com/jtbandes/7624fef93eb23010c032b2d1fd3674be#file-dynamictype-swift-L23&gt;<br>&gt;<br>&gt; *[Joe Groff]* Right, member lookup also implicitly opens an existential.<br>&gt;<br>&gt; *[Jacob Bandes-Storch]* Point being that there’s no way to do this for<br>&gt; generic params?<br>&gt;<br>&gt; *[Joe Groff]* Not in argument position. Only ‘self’ gets this magic<br>&gt; behavior.<br>&gt;<br>&gt; *[Jacob Bandes-Storch]* Is that a bug or feature? Seems to me dynamicType<br>&gt; should always be able to get the actual runtime type.<br>&gt;<br>&gt; *[Joe Groff]* Consider this situation:<br>&gt;<br>&gt; func foo&lt;T&gt;(x:T) -&gt; (T.Type, T.Type) {<br>&gt;    return (T.self, x.dynamicType)<br>&gt; }<br>&gt;<br>&gt; *[Jacob Bandes-Storch]* Still struggling to see what’s wrong with<br>&gt; returning “real” type. What can be subst. for `T that breaks it?<br>&gt;<br>&gt; *[Joe Groff]* Consider T == P with x.dynamicType trying to produce the<br>&gt; existential dynamic type.<br>&gt;<br>&gt; *[Jacob Bandes-Storch]* I think I’m mostly confused because P.Type vs.<br>&gt; P.Protocol is really non-obvious. Has renaming been discussed?<br>&gt;<br>&gt; *[Joe Groff]* The gotcha mainly comes up if you try to replicate the<br>&gt; builtin behavior. Most people don’t try to do that.<br>&gt;<br>&gt; *[Jacob Bandes-Storch]* Would it make sense to disallow x.dynamicType in<br>&gt; such cases? Gotcha would be less confusing if forced to say `T.self.<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 22. Juli 2016 um 14:47:08, Vladimir.S via swift-evolution (<br>&gt; swift-evolution at swift.org) schrieb:<br>&gt;<br>&gt; Thank you for the article. Very informative.<br>&gt;<br>&gt; So, I believe core team can answer the question : &quot;..why P.Protocol is<br>&gt; needed&quot; and if we can remove it without problems.<br>&gt;<br>&gt;<br>&gt; Small fix - A&amp;B should have &#39;: HasStatic&#39; and closing bracket here:<br>&gt;<br>&gt; protocol HasStatic { static func staticMethod() }<br>&gt; struct A { static func staticMethod() -&gt; String { return &quot;A&quot; }<br>&gt; struct B { static func staticMethod() -&gt; String { return &quot;B&quot; }<br>&gt;<br>&gt;<br>&gt; On 22.07.2016 14:40, Anton Zhilin via swift-evolution wrote:<br>&gt; &gt; For everyone who doesn&#39;t understand metatypes and our problem, please<br>&gt; see:<br>&gt; &gt;<br>&gt; &gt; https://gist.github.com/Anton3/25a66751812f14f76cacc5e382339522<br>&gt; &gt;<br>&gt; &gt; Read it from beginning to ending and ask if you don&#39;t understand<br>&gt; something!<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/a71d7ae1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 22, 2016 at 04:00:00pm</p></header><div class="content"><p>I wouldn’t be surprised if there are less than a handful of people outside of the Swift team who understand what .Protocol means. <br></p><p>Most of us just want to create generic objects based on their conformance to an initialiser in a protocol:<br></p><p>protocol Constructable {<br>	init()<br>}<br></p><p>func construct&lt;C:Constructable&gt;() -&gt; C {<br>	return C()                                               // ERROR<br>}<br></p><p>Karl<br></p><p>&gt; On 22 Jul 2016, at 15:19, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Interesting, it looks like only Joe Groff understands what .Protocol means and considers it important. And a couple others, maybe.<br>&gt; <br>&gt; Copying my metatypes explanation link:<br>&gt; For everyone who doesn&#39;t understand metatypes and our problem, please see<br>&gt; https://gist.github.com/Anton3/25a66751812f14f76cacc5e382339522 &lt;https://gist.github.com/Anton3/25a66751812f14f76cacc5e382339522&gt;<br>&gt; <br>&gt; 2016-07-22 16:07 GMT+03:00 Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; Hello everyone,<br>&gt; <br>&gt; recently I was pinged on twitter to a conversation between Jacob Bandes-Storch, Joe Groff and Slava Pestov.<br>&gt; <br>&gt; Here is the conversation covering a few more facts about the mysterious .Protocol:<br>&gt; <br>&gt; [Jacob Bandes-Storch] Was hoping to just define type&lt;T&gt;(of x: T) -&gt; T.Type and move impl of emitMetatypeOfValue() there.<br>&gt; <br>&gt; [Joe Groff] Yeah, that won’t do the right thing for existentials compared to x.dynamicType.<br>&gt; <br>&gt; [Jacob Bandes-Storch] When you say “do the right thing” you mean the return type? Shouldn’t type(of x: Proto) -&gt; Proto.Type?<br>&gt; <br>&gt; [Slava Pestov] Right, but if T := P, then T.Type is P.Protocol, not P.Type<br>&gt; <br>&gt; [Jacob Bandes-Storch] Mind bending… Suppose T : P, x : P = T(), then type(of: x) returns T, and T: P.Type. What am I missing?<br>&gt; <br>&gt; [Joe Groff] P.Type is really Any&lt;P.Type&gt;, and P.Protocol is really (Any&lt;P&gt;).Type. If T == Any&lt;P&gt;, T.Type == latter<br>&gt; <br>&gt; [Joe Groff] dynamicType is different for existentials: open existential, take opened metatype, erase to e.metatype<br>&gt; <br>&gt; [Jacob Bandes-Storch] Now I’m confused by current behavior: GIST &lt;https://gist.github.com/jtbandes/7624fef93eb23010c032b2d1fd3674be#file-dynamictype-swift-L12&gt; … isn’t dynamicType’s job to return T.self?<br>&gt; <br>&gt; [Joe Groff] invokes `foo() on the opened type, then re-closes an existential around the result if Self is involved<br>&gt; <br>&gt; [Jacob Bandes-Storch] But this does what I’d expect: GIST &lt;https://gist.github.com/jtbandes/7624fef93eb23010c032b2d1fd3674be#file-dynamictype-swift-L23&gt;<br>&gt; [Joe Groff] Right, member lookup also implicitly opens an existential.<br>&gt; <br>&gt; [Jacob Bandes-Storch] Point being that there’s no way to do this for generic params?<br>&gt; <br>&gt; [Joe Groff] Not in argument position. Only ‘self’ gets this magic behavior.<br>&gt; <br>&gt; [Jacob Bandes-Storch] Is that a bug or feature? Seems to me dynamicType should always be able to get the actual runtime type.<br>&gt; <br>&gt; [Joe Groff] Consider this situation:<br>&gt; <br>&gt; func foo&lt;T&gt;(x:T) -&gt; (T.Type, T.Type) {<br>&gt;    return (T.self, x.dynamicType)<br>&gt; }<br>&gt; [Jacob Bandes-Storch] Still struggling to see what’s wrong with returning “real” type. What can be subst. for `T that breaks it?<br>&gt; <br>&gt; [Joe Groff] Consider T == P with x.dynamicType trying to produce the existential dynamic type.<br>&gt; <br>&gt; [Jacob Bandes-Storch] I think I’m mostly confused because P.Type vs. P.Protocol is really non-obvious. Has renaming been discussed?<br>&gt; <br>&gt; [Joe Groff] The gotcha mainly comes up if you try to replicate the builtin behavior. Most people don’t try to do that.<br>&gt; <br>&gt; [Jacob Bandes-Storch] Would it make sense to disallow x.dynamicType in such cases? Gotcha would be less confusing if forced to say `T.self.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 22. Juli 2016 um 14:47:08, Vladimir.S via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt; <br>&gt;&gt; Thank you for the article. Very informative.<br>&gt;&gt; <br>&gt;&gt; So, I believe core team can answer the question : &quot;..why P.Protocol is <br>&gt;&gt; needed&quot; and if we can remove it without problems.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Small fix - A&amp;B should have &#39;: HasStatic&#39; and closing bracket here:<br>&gt;&gt; <br>&gt;&gt; protocol HasStatic { static func staticMethod() }<br>&gt;&gt; struct A { static func staticMethod() -&gt; String { return &quot;A&quot; }<br>&gt;&gt; struct B { static func staticMethod() -&gt; String { return &quot;B&quot; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On 22.07.2016 14:40, Anton Zhilin via swift-evolution wrote:<br>&gt;&gt; &gt; For everyone who doesn&#39;t understand metatypes and our problem, please see:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; https://gist.github.com/Anton3/25a66751812f14f76cacc5e382339522 &lt;https://gist.github.com/Anton3/25a66751812f14f76cacc5e382339522&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Read it from beginning to ending and ask if you don&#39;t understand something!<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/cfaadea5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July 22, 2016 at 06:00:00pm</p></header><div class="content"><p>2016-07-22 17:32 GMT+03:00 Karl &lt;razielim at gmail.com&gt;:<br></p><p>&gt; I wouldn’t be surprised if there are less than a handful of people outside<br>&gt; of the Swift team who understand what .Protocol means.<br>&gt;<br>&gt; Most of us just want to create generic objects based on their conformance<br>&gt; to an initialiser in a protocol:<br>&gt;<br>&gt; protocol Constructable {<br>&gt; init()<br>&gt; }<br>&gt;<br>&gt; func construct&lt;C:Constructable&gt;() -&gt; C {<br>&gt; return C()                                               // ERROR<br>&gt; }<br>&gt;<br>&gt;<br>In your example, there is no problem, because we can disambiguate based on<br>return type:<br></p><p>let c = construct() as SomeConstrictible<br></p><p>Metatypes are only really needed, when target type would not appear in the<br>signature otherwise.<br>And I kind-of understand the decision of not adding explicit generic<br>function specialization, because otherwise there would be double<br>specialization in generic constructors, like this:<br></p><p>struct Example&lt;T&gt; {<br>    init&lt;U&gt;()<br>}<br>Example&lt;Int&gt;&lt;Double&gt;<br></p><p>And that would look awful. If I&#39;m not mistaken, such initializers exist in<br>the standard library.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/9bac0144/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>July 22, 2016 at 05:00:00pm</p></header><div class="content"><p>Isn&#39;t the solution to a lot of these issues allowing explicit generalization instead of this meta type business?<br></p><p>&gt; On 22 Jul 2016, at 17:03, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 2016-07-22 17:32 GMT+03:00 Karl &lt;razielim at gmail.com&gt;:<br>&gt;&gt; I wouldn’t be surprised if there are less than a handful of people outside of the Swift team who understand what .Protocol means. <br>&gt;&gt; <br>&gt;&gt; Most of us just want to create generic objects based on their conformance to an initialiser in a protocol:<br>&gt;&gt; <br>&gt;&gt; protocol Constructable {<br>&gt;&gt; 	init()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func construct&lt;C:Constructable&gt;() -&gt; C {<br>&gt;&gt; 	return C()                                               // ERROR<br>&gt;&gt; }<br>&gt; <br>&gt; In your example, there is no problem, because we can disambiguate based on return type:<br>&gt; <br>&gt; let c = construct() as SomeConstrictible<br>&gt; <br>&gt; Metatypes are only really needed, when target type would not appear in the signature otherwise.<br>&gt; And I kind-of understand the decision of not adding explicit generic function specialization, because otherwise there would be double specialization in generic constructors, like this:<br>&gt; <br>&gt; struct Example&lt;T&gt; {<br>&gt;     init&lt;U&gt;()<br>&gt; }<br>&gt; Example&lt;Int&gt;&lt;Double&gt;<br>&gt; <br>&gt; And that would look awful. If I&#39;m not mistaken, such initializers exist in the standard library.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/721686fc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July 22, 2016 at 06:00:00pm</p></header><div class="content"><p>2016-07-22 18:51 GMT+03:00 David Hart &lt;david at hartbit.com&gt;:<br></p><p>&gt; Isn&#39;t the solution to a lot of these issues allowing explicit<br>&gt; generalization instead of this meta type business?<br>&gt;<br></p><p>And what would you suggest for &quot;double generics&quot; in initializers?<br>ExampleType&lt;Int&gt;&lt;Double&gt;()  // not good<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/e9cd82c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>July 23, 2016 at 12:00:00am</p></header><div class="content"><p>Where do these double generics come from? Never saw them...<br></p><p>&gt; On 22 Jul 2016, at 17:54, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt; <br>&gt; 2016-07-22 18:51 GMT+03:00 David Hart &lt;david at hartbit.com&gt;:<br>&gt;&gt; Isn&#39;t the solution to a lot of these issues allowing explicit generalization instead of this meta type business?<br>&gt; <br>&gt; And what would you suggest for &quot;double generics&quot; in initializers?<br>&gt; ExampleType&lt;Int&gt;&lt;Double&gt;()  // not good<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160723/69bb2833/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 23, 2016 at 03:00:00pm</p></header><div class="content"><p>Updated with changes written by Anton: https://github.com/DevAndArtist/swift-evolution/blob/rename_t_dot_type/proposals/0126-rename-t-dot-type.md<br></p><p>Introduction<br></p><p>This proposal renames T.Type to Metatype&lt;T&gt;, renames type(of:) to metatype(of:) and removes P.Protocol metatypes.<br></p><p>Swift-evolution threads:<br></p><p>[Revision] [Pitch] Rename T.Type<br>[Review] SE–0126: Refactor Metatypes, repurpose T[dot]self and Mirror<br>[Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror<br>[Discussion] Seal T.Type into Type&lt;T&gt;<br>Motivation<br></p><p>Explanation of metatypes<br>Current behavior of .Protocol<br></p><p>For protocols P, besides normal P.Type, there is also a “restricting metatype” P.Protocol that is the same as P.Type, except that it can only reflect P itself and not any of its subtypes:<br></p><p>Int.self is CustomStringConvertible.Type      //=&gt; true<br>Int.self is CustomStringConvertible.Protocol  //=&gt; false<br>Even without P.Protocol, we can test for equality:<br></p><p>Int.self is CustomStringConvertible.Type  //=&gt; true<br>Int.self == CustomStringConvertible.self  //=&gt; false<br>For protocols P, P.self returns a P.Protocol, not P.Type:<br></p><p>let metatype = CustomStringConvertible.self<br>print(type(of: metatype))  //=&gt; CustomStringConvertible.Protocol<br>In practise, the existence of P.Protocol creates problems. If T is a generic parameter, then T.Type turns into P.Protocol if a protocol P is passed:<br></p><p>func printMetatype&lt;T&gt;(_ meta: T.Type) {<br>    print(dynamicType(meta))<br>    let copy = T.self<br>    print(dynamicType(copy))<br>}<br></p><p>printMetatype(CustomStringConvertible.self)  //=&gt; CustomStringConvertible.Protocol x2<br>Lets review the following situation:<br></p><p>func isIntSubtype&lt;T&gt;(of: T.Type) -&gt; Bool {<br>    return Int.self is T.Type<br>}<br></p><p>isIntSubtype(of: CustomStringConvertible.self)  //=&gt; false<br>Now we understand that because T is a protocol P, T.Type turns into a P.Protocol, and we get the confusing behaviour.<br></p><p>Summing up issues with P.Protocol, it does not bring any additional functionality (we can test .Types for is and for ==), but tends to appear unexpectedly and break subtyping with metatypes.<br></p><p>Even more issues with .Protocol<br></p><p>[1] When T is a protocol P, T.Type is the metatype of the protocol type itself, P.Protocol. Int.self is not P.self.<br></p><p>[2] There isn’t a way to generically expression P.Type yet.<br></p><p>[3] The syntax would have to be changed in the compiler to get something that behaves like .Type today.<br></p><p>Written by Joe Groff: [1] [2] [3]<br>There is a workaround for isIntSubtype example above. If we pass a P.Type.Type, then it turns into P.Type.Protocol, but it is still represented with .Type in generic contexts. If we manage to drop outer .Type, then we get P.Type:<br></p><p>func isIntSubtype&lt;T&gt;(of _: T.Type) -&gt; Bool {<br>  return Int.self is T   // not T.Type here anymore<br>}<br></p><p>isIntSubtype(of: CustomStringConvertible.Type.self) //=&gt; true<br>In this call, T = CustomStringConvertible.Type. We can extend this issue and find the second problem by checking against the metatype of Any:<br></p><p>func isIntSubtype&lt;T&gt;(of _: T.Type) -&gt; Bool {<br>    return Int.self is T<br>}<br></p><p>isIntSubtype(of: Any.Type.self) //=&gt; true<br></p><p>isIntSubtype(of: Any.self)      //=&gt; true<br>When using Any, the compiler does not require .Type and returns true for both variations.<br></p><p>The third issue shows itself when we try to check protocol relationship with another protocol. Currently, there is no way (that we know of) to solve this problem:<br></p><p>protocol Parent {}<br>protocol Child : Parent {}<br></p><p>func isChildSubtype&lt;T&gt;(of _: T.Type) -&gt; Bool {<br>    return Child.self is T<br>}<br></p><p>isChildSubtype(of: Parent.Type.self) //=&gt; false<br>We also believe that this issue is the reason why the current global functions sizeof, strideof and alignof make use of generic &lt;T&gt;(_: T.Type) declaration notation instead of (_: Any.Type).<br></p><p>Magical members<br></p><p>There were the following “magical” members of all types/instances:<br></p><p>.dynamicType, which was replaced with type(of:) function by SE–0096.<br>.Type and .Protocol, which we propose to remove, see below.<br>.Self, which acts like an associatedtype.<br>.self, which will be reviewed in a separate proposal.<br>The tendency is to remove “magical” members: with this proposal there will only be .Self (does not count) and .self.<br></p><p>Also, .Type notation works like a generic type, and giving it generic syntax seems to be a good idea (unification).<br></p><p>Proposed solution<br></p><p>Remove P.Protocol type without a replacement. P.self will never return a P.Protocol.<br>Rename T.Type to Metatype&lt;T&gt;.<br>Rename type(of:) function from SE–0096 to metatype(of:).<br>Impact on existing code<br></p><p>This is a source-breaking change that can be automated by a migrator. All occurrences of T.Type and T.Protocol will be changed to Metatype&lt;T&gt;. All usages of type(of:) will be changed to metatype(of:)<br></p><p>Alternatives considered<br></p><p>Rename T.self to T.metatype. However, this can be proposed separately.<br>Use Type&lt;T&gt; instead of Metatype&lt;T&gt;. However, Metatype is more precise here.<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160723/e1b55961/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July 23, 2016 at 11:00:00pm</p></header><div class="content"><p>Is noone interested? We are going to go for the second round of review with<br>this version of proposal.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160723/27dafdf6/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>July 23, 2016 at 01:00:00pm</p></header><div class="content"><p>I&#39;m finding it really hard to see the advantage of this proposal with out reconciling the possibility of .self going away. I think this should be postponed after .self is reviewed in swift 4. Premature optimization imo. <br></p><p>&gt; On Jul 22, 2016, at 3:20 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Where do these double generics come from? Never saw them...<br>&gt; <br>&gt;&gt; On 22 Jul 2016, at 17:54, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 2016-07-22 18:51 GMT+03:00 David Hart &lt;david at hartbit.com&gt;:<br>&gt;&gt;&gt; Isn&#39;t the solution to a lot of these issues allowing explicit generalization instead of this meta type business?<br>&gt;&gt; <br>&gt;&gt; And what would you suggest for &quot;double generics&quot; in initializers?<br>&gt;&gt; ExampleType&lt;Int&gt;&lt;Double&gt;()  // not good<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160723/a8707690/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/242e18b243022bcb7573443e06444423?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Boris Wang</string> &lt;kona.ming at gmail.com&gt;<p>July 24, 2016 at 09:00:00am</p></header><div class="content"><p>just write code in playground：<br>struct MyStruct ｛<br>var t = 0<br>｝<br>sizeof(MyStruct)<br></p><p>Compiler error：<br>Missing &#39;.self&#39; for reference to metatype of type &#39;MyStruct&#39;<br></p><p>The metatype is from swift it self!<br></p><p>What the hell was the .self?<br></p><p><br>Jose Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org&gt;于2016年7月24日<br>周日04:45写道：<br></p><p>&gt; I&#39;m finding it really hard to see the advantage of this proposal with out<br>&gt; reconciling the possibility of .self going away. I think this should be<br>&gt; postponed after .self is reviewed in swift 4. Premature optimization imo.<br>&gt;<br>&gt; On Jul 22, 2016, at 3:20 PM, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Where do these double generics come from? Never saw them...<br>&gt;<br>&gt; On 22 Jul 2016, at 17:54, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt;<br>&gt; 2016-07-22 18:51 GMT+03:00 David Hart &lt;david at hartbit.com&gt;:<br>&gt;<br>&gt;&gt; Isn&#39;t the solution to a lot of these issues allowing explicit<br>&gt;&gt; generalization instead of this meta type business?<br>&gt;&gt;<br>&gt;<br>&gt; And what would you suggest for &quot;double generics&quot; in initializers?<br>&gt; ExampleType&lt;Int&gt;&lt;Double&gt;()  // not good<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160724/3025f949/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July 24, 2016 at 12:00:00pm</p></header><div class="content"><p>2016-07-24 12:21 GMT+03:00 Boris Wang via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; just write code in playground：<br>&gt; struct MyStruct ｛<br>&gt; var t = 0<br>&gt; ｝<br>&gt; sizeof(MyStruct)<br>&gt;<br>&gt; Compiler error：<br>&gt; Missing &#39;.self&#39; for reference to metatype of type &#39;MyStruct&#39;<br>&gt;<br>&gt; The metatype is from swift it self!<br>&gt;<br>&gt; What the hell was the .self?<br>&gt;<br></p><p>Boris, you should write `sizeof(MyStruct.self)` in your example. Removal of<br>`.self` is deferred from Swift 3.<br>SE lists are not the best place to learn about metatypes, but here is some<br>explanation:<br>https://gist.github.com/Anton3/25a66751812f14f76cacc5e382339522<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160724/ec010795/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/242e18b243022bcb7573443e06444423?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Boris Wang</string> &lt;kona.ming at gmail.com&gt;<p>July 24, 2016 at 10:00:00am</p></header><div class="content"><p>Got it, thanks!<br>Anton Zhilin &lt;antonyzhilin at gmail.com&gt;于2016年7月24日 周日17:32写道：<br></p><p>&gt; 2016-07-24 12:21 GMT+03:00 Boris Wang via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;&gt; just write code in playground：<br>&gt;&gt; struct MyStruct ｛<br>&gt;&gt; var t = 0<br>&gt;&gt; ｝<br>&gt;&gt; sizeof(MyStruct)<br>&gt;&gt;<br>&gt;&gt; Compiler error：<br>&gt;&gt; Missing &#39;.self&#39; for reference to metatype of type &#39;MyStruct&#39;<br>&gt;&gt;<br>&gt;&gt; The metatype is from swift it self!<br>&gt;&gt;<br>&gt;&gt; What the hell was the .self?<br>&gt;&gt;<br>&gt;<br>&gt; Boris, you should write `sizeof(MyStruct.self)` in your example. Removal<br>&gt; of `.self` is deferred from Swift 3.<br>&gt; SE lists are not the best place to learn about metatypes, but here is some<br>&gt; explanation:<br>&gt; https://gist.github.com/Anton3/25a66751812f14f76cacc5e382339522<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160724/14015ccc/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>July 24, 2016 at 09:00:00am</p></header><div class="content"><p>https://github.com/apple/swift-evolution/blob/master/proposals/0090-remove-dot-self.md<br></p><p>&gt; On Jul 24, 2016, at 2:21 AM, Boris Wang &lt;kona.ming at gmail.com&gt; wrote:<br>&gt; <br>&gt; just write code in playground：<br>&gt; struct MyStruct ｛<br>&gt; var t = 0<br>&gt; ｝<br>&gt; sizeof(MyStruct)<br>&gt; <br>&gt; Compiler error：<br>&gt; Missing &#39;.self&#39; for reference to metatype of type &#39;MyStruct&#39;<br>&gt; <br>&gt; The metatype is from swift it self!<br>&gt; <br>&gt; What the hell was the .self?<br>&gt; <br>&gt; <br>&gt; Jose Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org&gt;于2016年7月24日 周日04:45写道：<br>&gt;&gt; I&#39;m finding it really hard to see the advantage of this proposal with out reconciling the possibility of .self going away. I think this should be postponed after .self is reviewed in swift 4. Premature optimization imo. <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 22, 2016, at 3:20 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Where do these double generics come from? Never saw them...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 22 Jul 2016, at 17:54, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016-07-22 18:51 GMT+03:00 David Hart &lt;david at hartbit.com&gt;:<br>&gt;&gt;&gt;&gt;&gt; Isn&#39;t the solution to a lot of these issues allowing explicit generalization instead of this meta type business?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And what would you suggest for &quot;double generics&quot; in initializers?<br>&gt;&gt;&gt;&gt; ExampleType&lt;Int&gt;&lt;Double&gt;()  // not good<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160724/a2e39f95/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 25, 2016 at 09:00:00pm</p></header><div class="content"><p>We’ve submitted a PR. https://github.com/apple/swift-evolution/pull/466<br></p><p>The proposal was refactored completely.<br></p><p>Introduction<br></p><p>This proposal removes .Type and .Protocol in favor of two generic-style syntaxes and aligns global type(of:) function (SE–0096) to match the changes.<br></p><p>Swift-evolution threads:<br></p><p>[Revision] [Pitch] Rename T.Type<br>[Review] SE–0126: Refactor Metatypes, repurpose T[dot]self and Mirror<br>[Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror<br>[Discussion] Seal T.Type into Type&lt;T&gt;<br>Motivation<br></p><p>Every type T has an instance, accessible through T.self, which represents the type itself. Like all instances in Swift, this “type instance” itself has a type, which is referred to as its “metatype”. The metatype of T is written T.Type. The instance members of the metatype are the same as the static or class members of the type.<br></p><p>Metatypes have subtype relationships which reflect the types they represent. For instance, given these types:<br></p><p>protocol Proto {}<br>class Base {}<br>class Derived: Base, Proto {}<br>Derived.Type is a subtype of both Base.Type and Proto.Type (and Any.Type). That means that Derived.self can be used anywhere a Derived.Type, Base.Type, Proto.Type, or Any.Type is called for.<br></p><p>Unfortunately, this simple picture is complicated by protocols. Proto.self is actually of type Proto.Protocol, not type Proto.Type. This is necessary because the protocol does not, and cannot, conform to itself; it requires conforming types to provide static members, but it doesn’t actually provide those members itself. Proto.Type still exists, but it is the supertype of all types conforming to the protocol.<br></p><p>Making this worse, a generic type always uses T.Type to refer to the type of T.self. So when Proto is bound to a generic parameter P, P.Type is the same as Proto.Protocol.<br></p><p>This shifting of types is complicated and confusing; we seek to clean up this area.<br></p><p>We also believe that, in the long term, the dot syntax will prevent us from implementing certain future enhancements that might be valuable:<br></p><p>Moving the implementation of metatypes at least partly into the standard library.<br>Adding members available on all type instances for features like read-write reflection or memory layout information.<br>Conforming metatypes to protocols like Hashable or CustomStringConvertible.<br>Offering straightforward syntaxes for dynamic features like looking up types by name.<br>Proposed solution<br></p><p>We abolish .Type and .Protocol in favor of two generic-style syntaxes:<br></p><p>Type&lt;T&gt; is the concrete type of T.self. A Type&lt;T&gt; can only ever accept that one specific type, not any of its subtypes. If T is a protocol P, than the only supertype for Type&lt;P&gt; is Subtype&lt;Any&gt;. To be crystal clear here, Type&lt;P&gt; is not a subtype of Subtype&lt;P&gt;.<br></p><p>Subtype&lt;T&gt; is the supertype of all Types whose instances are subtypes of T. If T is a class, Subtype&lt;T&gt; would accept a Type for any of its subclasses. If T is a protocol, Subtype&lt;T&gt; would accept a Type for any conforming concrete type.<br></p><p>In this new notation, some of our existing standard library functions would have signatures like:<br></p><p>func unsafeBitCast&lt;T, U&gt;(_: T, to type: Type&lt;U&gt;) -&gt; U<br>func sizeof&lt;T&gt;(_: Type&lt;T&gt;) -&gt; Int<br>func ==(t0: Subtype&lt;Any&gt;?, t1: Subtype&lt;Any&gt;?) -&gt; Bool<br>func type&lt;T&gt;(of: T) -&gt; Subtype&lt;T&gt; // SE-0096<br>That last example, type(of:), is rather interesting, because it is actually a magic syntax rather than a function. We propose to align this syntax with Type and Subtype by renaming it to Subtype(of:). We believe this is clearer about both the type and meaning of the operation.<br></p><p>let instance: NSObject = NSString()<br>let class: Subtype&lt;NSObject&gt; = Subtype(of: instance)<br></p><p>print(class) // =&gt; NSString<br>Example: visual metatype relationship<br>Example: generic functions<br>Future Directions<br></p><p>We could allow extensions on Type and perhaps on Subtype to add members or conform them to protocols. This could allow us to remove some standard library hacks, like the non-Equatable-related == operators for types.<br></p><p>It may be possible to implement parts of Type as a fairly ordinary final class, moving code from the runtime into the standard library.<br></p><p>We could offer a Subtype(ofType: Type&lt;T&gt;, named: String) pseudo-initializer which would allow type-safe access to classes by name.<br></p><p>We could offer other reflection and dynamic features on Type and Subtype.<br></p><p>We could move the MemoryLayout members into Type (presumably prefixed), removing the rather artificial MemoryLayout enum.<br></p><p>Along with other generics enhancements, there may be a use for a Subprotocol&lt;T&gt; syntax for any protocol requiring conformance to protocol T.<br></p><p>Impact on existing code<br></p><p>This is a source-breaking change that can be automated by a migrator.<br></p><p>We suggest the following migration process; this can differ from the final migration process implemented by the core team if this proposal will be accepted:<br></p><p>Any.Type is migrated to Subtype&lt;Any&gt;.<br>If T.Type is in function parameter, where T is a generic type parameter, then it’s migrated to Type&lt;T&gt;.<br>Every T.Protocol will be replaced with Type&lt;T&gt;.<br>Every T.Type in a dynamic cast will be replaced with Subtype&lt;T&gt;.<br>If static members are called on a metatype instance, then this instance is migrated to Subtype&lt;T&gt;.<br>Return types of functions are migrated to Subtype&lt;T&gt;.<br>Variable declarations is migrated to Subtype&lt;T&gt;.<br>Alternatives considered<br></p><p>Other names for Type and Subtype were considered:<br></p><p>Type: SpecificType, Metatype or ExactType.<br>Subtype: Supertype, Base, BaseType, ExistentialType or TypeProtocol.<br>Alternatively the pseudo initializer Subtype(of:) could remain as a global function:<br></p><p>public func subtype&lt;T&gt;(of instance: T) -&gt; Subtype&lt;T&gt;<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/39f8ba42/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 25, 2016 at 11:00:00pm</p></header><div class="content"><p>Fixed PR: https://github.com/apple/swift-evolution/pull/468<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 25. Juli 2016 um 21:35:22, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>We’ve submitted a PR. https://github.com/apple/swift-evolution/pull/466<br></p><p>The proposal was refactored completely.<br></p><p>Introduction<br></p><p>This proposal removes .Type and .Protocol in favor of two generic-style syntaxes and aligns global type(of:) function (SE–0096) to match the changes.<br></p><p>Swift-evolution threads:<br></p><p>[Revision] [Pitch] Rename T.Type<br>[Review] SE–0126: Refactor Metatypes, repurpose T[dot]self and Mirror<br>[Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror<br>[Discussion] Seal T.Type into Type&lt;T&gt;<br>Motivation<br></p><p>Every type T has an instance, accessible through T.self, which represents the type itself. Like all instances in Swift, this “type instance” itself has a type, which is referred to as its “metatype”. The metatype of T is written T.Type. The instance members of the metatype are the same as the static or class members of the type.<br></p><p>Metatypes have subtype relationships which reflect the types they represent. For instance, given these types:<br></p><p>protocol Proto {}<br>class Base {}<br>class Derived: Base, Proto {}<br>Derived.Type is a subtype of both Base.Type and Proto.Type (and Any.Type). That means that Derived.self can be used anywhere a Derived.Type, Base.Type, Proto.Type, or Any.Type is called for.<br></p><p>Unfortunately, this simple picture is complicated by protocols. Proto.self is actually of type Proto.Protocol, not type Proto.Type. This is necessary because the protocol does not, and cannot, conform to itself; it requires conforming types to provide static members, but it doesn’t actually provide those members itself. Proto.Type still exists, but it is the supertype of all types conforming to the protocol.<br></p><p>Making this worse, a generic type always uses T.Type to refer to the type of T.self. So when Proto is bound to a generic parameter P, P.Type is the same as Proto.Protocol.<br></p><p>This shifting of types is complicated and confusing; we seek to clean up this area.<br></p><p>We also believe that, in the long term, the dot syntax will prevent us from implementing certain future enhancements that might be valuable:<br></p><p>Moving the implementation of metatypes at least partly into the standard library.<br>Adding members available on all type instances for features like read-write reflection or memory layout information.<br>Conforming metatypes to protocols like Hashable or CustomStringConvertible.<br>Offering straightforward syntaxes for dynamic features like looking up types by name.<br>Proposed solution<br></p><p>We abolish .Type and .Protocol in favor of two generic-style syntaxes:<br></p><p>Type&lt;T&gt; is the concrete type of T.self. A Type&lt;T&gt; can only ever accept that one specific type, not any of its subtypes. If T is a protocol P, than the only supertype for Type&lt;P&gt; is Subtype&lt;Any&gt;. To be crystal clear here, Type&lt;P&gt; is not a subtype of Subtype&lt;P&gt;.<br></p><p>Subtype&lt;T&gt; is the supertype of all Types whose instances are subtypes of T. If T is a class, Subtype&lt;T&gt; would accept a Type for any of its subclasses. If T is a protocol, Subtype&lt;T&gt; would accept a Type for any conforming concrete type.<br></p><p>In this new notation, some of our existing standard library functions would have signatures like:<br></p><p>func unsafeBitCast&lt;T, U&gt;(_: T, to type: Type&lt;U&gt;) -&gt; U<br>func sizeof&lt;T&gt;(_: Type&lt;T&gt;) -&gt; Int<br>func ==(t0: Subtype&lt;Any&gt;?, t1: Subtype&lt;Any&gt;?) -&gt; Bool<br>func type&lt;T&gt;(of: T) -&gt; Subtype&lt;T&gt; // SE-0096<br>That last example, type(of:), is rather interesting, because it is actually a magic syntax rather than a function. We propose to align this syntax with Type and Subtype by renaming it to Subtype(of:). We believe this is clearer about both the type and meaning of the operation.<br></p><p>let instance: NSObject = NSString()<br>let class: Subtype&lt;NSObject&gt; = Subtype(of: instance)<br></p><p>print(class) // =&gt; NSString<br>Example: visual metatype relationship<br>Example: generic functions<br>Future Directions<br></p><p>We could allow extensions on Type and perhaps on Subtype to add members or conform them to protocols. This could allow us to remove some standard library hacks, like the non-Equatable-related == operators for types.<br></p><p>It may be possible to implement parts of Type as a fairly ordinary final class, moving code from the runtime into the standard library.<br></p><p>We could offer a Subtype(ofType: Type&lt;T&gt;, named: String) pseudo-initializer which would allow type-safe access to classes by name.<br></p><p>We could offer other reflection and dynamic features on Type and Subtype.<br></p><p>We could move the MemoryLayout members into Type (presumably prefixed), removing the rather artificial MemoryLayout enum.<br></p><p>Along with other generics enhancements, there may be a use for a Subprotocol&lt;T&gt; syntax for any protocol requiring conformance to protocol T.<br></p><p>Impact on existing code<br></p><p>This is a source-breaking change that can be automated by a migrator.<br></p><p>We suggest the following migration process; this can differ from the final migration process implemented by the core team if this proposal will be accepted:<br></p><p>Any.Type is migrated to Subtype&lt;Any&gt;.<br>If T.Type is in function parameter, where T is a generic type parameter, then it’s migrated to Type&lt;T&gt;.<br>Every T.Protocol will be replaced with Type&lt;T&gt;.<br>Every T.Type in a dynamic cast will be replaced with Subtype&lt;T&gt;.<br>If static members are called on a metatype instance, then this instance is migrated to Subtype&lt;T&gt;.<br>Return types of functions are migrated to Subtype&lt;T&gt;.<br>Variable declarations is migrated to Subtype&lt;T&gt;.<br>Alternatives considered<br></p><p>Other names for Type and Subtype were considered:<br></p><p>Type: SpecificType, Metatype or ExactType.<br>Subtype: Supertype, Base, BaseType, ExistentialType or TypeProtocol.<br>Alternatively the pseudo initializer Subtype(of:) could remain as a global function:<br></p><p>public func subtype&lt;T&gt;(of instance: T) -&gt; Subtype&lt;T&gt;<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/cf2c8938/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 25, 2016 at 11:00:00pm</p></header><div class="content"><p>PR closed, we’ll come back for Swift 3.1. ;)<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 25. Juli 2016 um 23:08:26, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Fixed PR: https://github.com/apple/swift-evolution/pull/468<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 25. Juli 2016 um 21:35:22, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>We’ve submitted a PR. https://github.com/apple/swift-evolution/pull/466<br></p><p>The proposal was refactored completely.<br></p><p>Introduction<br></p><p>This proposal removes .Type and .Protocol in favor of two generic-style syntaxes and aligns global type(of:) function (SE–0096) to match the changes.<br></p><p>Swift-evolution threads:<br></p><p>[Revision] [Pitch] Rename T.Type<br>[Review] SE–0126: Refactor Metatypes, repurpose T[dot]self and Mirror<br>[Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror<br>[Discussion] Seal T.Type into Type&lt;T&gt;<br>Motivation<br></p><p>Every type T has an instance, accessible through T.self, which represents the type itself. Like all instances in Swift, this “type instance” itself has a type, which is referred to as its “metatype”. The metatype of T is written T.Type. The instance members of the metatype are the same as the static or class members of the type.<br></p><p>Metatypes have subtype relationships which reflect the types they represent. For instance, given these types:<br></p><p>protocol Proto {}<br>class Base {}<br>class Derived: Base, Proto {}<br>Derived.Type is a subtype of both Base.Type and Proto.Type (and Any.Type). That means that Derived.self can be used anywhere a Derived.Type, Base.Type, Proto.Type, or Any.Type is called for.<br></p><p>Unfortunately, this simple picture is complicated by protocols. Proto.self is actually of type Proto.Protocol, not type Proto.Type. This is necessary because the protocol does not, and cannot, conform to itself; it requires conforming types to provide static members, but it doesn’t actually provide those members itself. Proto.Type still exists, but it is the supertype of all types conforming to the protocol.<br></p><p>Making this worse, a generic type always uses T.Type to refer to the type of T.self. So when Proto is bound to a generic parameter P, P.Type is the same as Proto.Protocol.<br></p><p>This shifting of types is complicated and confusing; we seek to clean up this area.<br></p><p>We also believe that, in the long term, the dot syntax will prevent us from implementing certain future enhancements that might be valuable:<br></p><p>Moving the implementation of metatypes at least partly into the standard library.<br>Adding members available on all type instances for features like read-write reflection or memory layout information.<br>Conforming metatypes to protocols like Hashable or CustomStringConvertible.<br>Offering straightforward syntaxes for dynamic features like looking up types by name.<br>Proposed solution<br></p><p>We abolish .Type and .Protocol in favor of two generic-style syntaxes:<br></p><p>Type&lt;T&gt; is the concrete type of T.self. A Type&lt;T&gt; can only ever accept that one specific type, not any of its subtypes. If T is a protocol P, than the only supertype for Type&lt;P&gt; is Subtype&lt;Any&gt;. To be crystal clear here, Type&lt;P&gt; is not a subtype of Subtype&lt;P&gt;.<br></p><p>Subtype&lt;T&gt; is the supertype of all Types whose instances are subtypes of T. If T is a class, Subtype&lt;T&gt; would accept a Type for any of its subclasses. If T is a protocol, Subtype&lt;T&gt; would accept a Type for any conforming concrete type.<br></p><p>In this new notation, some of our existing standard library functions would have signatures like:<br></p><p>func unsafeBitCast&lt;T, U&gt;(_: T, to type: Type&lt;U&gt;) -&gt; U<br>func sizeof&lt;T&gt;(_: Type&lt;T&gt;) -&gt; Int<br>func ==(t0: Subtype&lt;Any&gt;?, t1: Subtype&lt;Any&gt;?) -&gt; Bool<br>func type&lt;T&gt;(of: T) -&gt; Subtype&lt;T&gt; // SE-0096<br>That last example, type(of:), is rather interesting, because it is actually a magic syntax rather than a function. We propose to align this syntax with Type and Subtype by renaming it to Subtype(of:). We believe this is clearer about both the type and meaning of the operation.<br></p><p>let instance: NSObject = NSString()<br>let class: Subtype&lt;NSObject&gt; = Subtype(of: instance)<br></p><p>print(class) // =&gt; NSString<br>Example: visual metatype relationship<br>Example: generic functions<br>Future Directions<br></p><p>We could allow extensions on Type and perhaps on Subtype to add members or conform them to protocols. This could allow us to remove some standard library hacks, like the non-Equatable-related == operators for types.<br></p><p>It may be possible to implement parts of Type as a fairly ordinary final class, moving code from the runtime into the standard library.<br></p><p>We could offer a Subtype(ofType: Type&lt;T&gt;, named: String) pseudo-initializer which would allow type-safe access to classes by name.<br></p><p>We could offer other reflection and dynamic features on Type and Subtype.<br></p><p>We could move the MemoryLayout members into Type (presumably prefixed), removing the rather artificial MemoryLayout enum.<br></p><p>Along with other generics enhancements, there may be a use for a Subprotocol&lt;T&gt; syntax for any protocol requiring conformance to protocol T.<br></p><p>Impact on existing code<br></p><p>This is a source-breaking change that can be automated by a migrator.<br></p><p>We suggest the following migration process; this can differ from the final migration process implemented by the core team if this proposal will be accepted:<br></p><p>Any.Type is migrated to Subtype&lt;Any&gt;.<br>If T.Type is in function parameter, where T is a generic type parameter, then it’s migrated to Type&lt;T&gt;.<br>Every T.Protocol will be replaced with Type&lt;T&gt;.<br>Every T.Type in a dynamic cast will be replaced with Subtype&lt;T&gt;.<br>If static members are called on a metatype instance, then this instance is migrated to Subtype&lt;T&gt;.<br>Return types of functions are migrated to Subtype&lt;T&gt;.<br>Variable declarations is migrated to Subtype&lt;T&gt;.<br>Alternatives considered<br></p><p>Other names for Type and Subtype were considered:<br></p><p>Type: SpecificType, Metatype or ExactType.<br>Subtype: Supertype, Base, BaseType, ExistentialType or TypeProtocol.<br>Alternatively the pseudo initializer Subtype(of:) could remain as a global function:<br></p><p>public func subtype&lt;T&gt;(of instance: T) -&gt; Subtype&lt;T&gt;<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/d6d648c4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>July 22, 2016 at 09:00:00am</p></header><div class="content"><p>To be honest, I have difficulty with the terminology here. Why use the term ‚metatype‘ in the first place? Why not just ‚Type&#39;? Or ‚TypeDescriptor‘ (in analogy to ObjectIdentifier)? What do we actually gain by the technical distinction between a type and a type of a type? I would understand it if we had the ability to construct higher-order types, such as custom metatypes or even metatype types in Swift.  <br></p><p>But in general, I am sympathetic with the proposal.Swift type/metatype facilities are very confusing (I still don’t  get how the .Type, .Self, .self etc. stuff works) and bringing some clarity will be most welcome. <br></p><p>— T. <br></p><p><br>&gt; On 22 Jul 2016, at 00:40, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; https://github.com/DevAndArtist/swift-evolution/blob/rename_t_dot_type/proposals/0126-rename-t-dot-type.md &lt;https://github.com/DevAndArtist/swift-evolution/blob/rename_t_dot_type/proposals/0126-rename-t-dot-type.md&gt;<br>&gt; Rename T.Type<br>&gt; <br>&gt; Proposal: SE–0126 &lt;x-msg://35/0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.md&gt;<br>&gt; Authors: Adrian Zubarev &lt;https://github.com/DevAndArtist&gt;, Anton Zhilin &lt;https://github.com/Anton3&gt;<br>&gt; Status: Revision<br>&gt; Review manager: Chris Lattner &lt;http://github.com/lattner&gt;<br>&gt; Revision: 2<br>&gt; Previous Revisions: 1 &lt;https://github.com/apple/swift-evolution/blob/83707b0879c83dcde778f8163f5768212736fdc2/proposals/0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.md&gt;<br>&gt; Introduction<br>&gt; <br>&gt; This proposal renames the current metatype T.Type notation and the global function from SE–0096 to match the changes.<br>&gt; <br>&gt; Swift-evolution threads: <br>&gt; <br>&gt; [Pitch] Rename T.Type &lt;applewebdata://86264528-D120-4E32-9AC9-034995F494C9&gt;<br>&gt; [Review] SE–0126: Refactor Metatypes, repurpose T[dot]self and Mirror &lt;applewebdata://86264528-D120-4E32-9AC9-034995F494C9&gt;<br>&gt; [Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160718/024772.html&gt;<br>&gt; [Discussion] Seal T.Type into Type&lt;T&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160704/023818.html&gt;<br>&gt; Motivation<br>&gt; <br>&gt; In Swift metatypes have the following notation: T.Type<br>&gt; <br>&gt; As already showed in SE–0096 and SE–0090 the Swift community strongly is in favor of (re)moving magical intstance or type properties.<br>&gt; <br>&gt; SE–0096 moves instanceOfT.dynamicType to type&lt;T&gt;(of: T) -&gt; T.Type.<br>&gt; <br>&gt; SE–0090 aims to remove .self completely.<br>&gt; <br>&gt; We propose to rename T.Type to a generic-like notation Metatype&lt;T&gt;. To be able to achieve this notation we have to resolve a few issues first.<br>&gt; <br>&gt; Known issues of metatypes:<br>&gt; <br>&gt; Assume this function that checks if an Int type conforms to a specific protocol. This check uses current model of metatypes combined in a generic context:<br>&gt; <br>&gt; func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>&gt;    return Int.self is T.Type<br>&gt; }<br>&gt; <br>&gt; intConforms(to: CustomStringConvertible.self) //=&gt; false<br>&gt; <br>&gt; Int.self is CustomStringConvertible.Type      //=&gt; true<br>&gt; [1] When T is a protocol P, T.Type is the metatype of the protocol type itself, P.Protocol. Int.self is not P.self.<br>&gt; <br>&gt; [2] There isn’t a way to generically expression P.Type yet.<br>&gt; <br>&gt; [3] The syntax would have to be changed in the compiler to get something that behaves like .Type today.<br>&gt; <br>&gt; Written by Joe Groff: [1] &lt;https://twitter.com/jckarter/status/754420461404958721&gt; [2] &lt;https://twitter.com/jckarter/status/754420624261472256&gt; [3] &lt;https://twitter.com/jckarter/status/754425573762478080&gt;<br>&gt; A possible workaround might look like the example below, but does not allow to decompose P.Type:<br>&gt; <br>&gt; func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>&gt;   return Int.self is T<br>&gt; }<br>&gt; <br>&gt; intConforms(to: CustomStringConvertible.Type.self) //=&gt; true<br>&gt; We can extend this issue and find the second problem by checking against the metatype of Any:<br>&gt; <br>&gt; func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>&gt;     return Int.self is T<br>&gt; }<br>&gt; <br>&gt; intConforms(to: Any.Type.self) //=&gt; true<br>&gt; <br>&gt; intConforms(to: Any.self)      //=&gt; true<br>&gt; <br>&gt; Int.self is Any.Type           //=&gt; Always true<br>&gt; When using Any the compiler does not require .Type at all and returns true for both variations.<br>&gt; <br>&gt; The third issue will show itself whenever we would try to check protocol relationship with another protocol. Currently there is no way (that we know of) to solve this problem:<br>&gt; <br>&gt; protocol P {}<br>&gt; protocol R : P {}<br>&gt; <br>&gt; func rIsSubtype&lt;T&gt;(of _: T.Type) -&gt; Bool {<br>&gt;     return R.self is T<br>&gt; }<br>&gt; <br>&gt; rIsSubtype(of: P.Type.self) //=&gt; false<br>&gt; <br>&gt; R.self is Any.Type //=&gt; Always true<br>&gt; R.self is P.Type   //=&gt; true<br>&gt; R.self is R.Type   //=&gt; true<br>&gt; We also believe that this issue is the reason why the current global functions sizeof, strideof and alignof make use of generic &lt;T&gt;(_: T.Type) declaration notation instead of (_: Any.Type).<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Rename any occurrence of T.Type and T.Protocol to Metatype&lt;T&gt;.<br>&gt; <br>&gt; Revise metatypes internally. <br>&gt; <br>&gt; When T is a protocol, T.self should always return an instance of Metatype&lt;T&gt; (old T.Type) and never a T.Protocol. Furthermore, metatypes should reflect the same type relationship behavior like the actual types themselves. <br>&gt; <br>&gt; To match the correct meaning and usage of the noun ‘Metatype’ from this proposal, we also propose to rename the global function from SE–0096:<br>&gt; <br>&gt; before: public func type&lt;T&gt;(of instance: T) -&gt; T.Type<br>&gt; after: public func metatype&lt;T&gt;(of instance: T) -&gt; Metatype&lt;T&gt;<br>&gt; Examples:<br>&gt; <br>&gt; protocol P {}<br>&gt; protocol R : P {}<br>&gt; class A : P {}<br>&gt; class B : A, R {}<br>&gt; <br>&gt; func `is`&lt;T&gt;(metatype: Metatype&lt;Any&gt;, also _: Metatype&lt;T&gt; ) -&gt; Bool {<br>&gt;     return metatype is Metatype&lt;T&gt;<br>&gt; }<br>&gt; <br>&gt; `is`(metatype: R.self, also: Any.self) //=&gt; true | Currently: false<br>&gt; `is`(metatype: R.self, also: P.self)   //=&gt; true | Currently: false<br>&gt; `is`(metatype: R.self, also: R.self)   //=&gt; true<br>&gt; <br>&gt; `is`(metatype: B.self, also: Any.self) //=&gt; true | Currently: false<br>&gt; `is`(metatype: B.self, also: P.self)   //=&gt; true | Currently: false<br>&gt; `is`(metatype: B.self, also: R.self)   //=&gt; true | Currently: false<br>&gt; `is`(metatype: B.self, also: A.self)   //=&gt; true<br>&gt; `is`(metatype: B.self, also: B.self)   //=&gt; true<br>&gt; <br>&gt; func cast&lt;T&gt;(metatype: Metatype&lt;Any&gt;, to _: Metatype&lt;T&gt;) -&gt; Metatype&lt;T&gt;? {<br>&gt;     return metatype as? Metatype&lt;T&gt;<br>&gt; }<br>&gt; <br>&gt; cast(metatype: R.self, to: Any.self)     //=&gt; an Optional&lt;Metatype&lt;Any&gt;&gt; | Currently: nil<br>&gt; cast(metatype: R.self, to: P.self)       //=&gt; an Optional&lt;Metatype&lt;P&gt;&gt;   | Currently: nil<br>&gt; cast(metatype: R.self, to: R.self)       //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: an Optional&lt;R.Protocol&gt;<br>&gt; <br>&gt; let anyR: Any.Type = R.self<br>&gt; let r = cast(metatype: anyR, to: R.self) //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: an Optional&lt;R.Protocol&gt;<br>&gt; <br>&gt; cast(metatype: B.self, to: Any.self)     //=&gt; an Optional&lt;Metatype&lt;Any&gt;&gt; | Currently: nil<br>&gt; cast(metatype: B.self, to: P.self)       //=&gt; an Optional&lt;Metatype&lt;P&gt;&gt;   | Currently: nil<br>&gt; cast(metatype: B.self, to: R.self)       //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: nil<br>&gt; cast(metatype: B.self, to: A.self)       //=&gt; an Optional&lt;Metatype&lt;A&gt;&gt;<br>&gt; cast(metatype: B.self, to: B.self)       //=&gt; an Optional&lt;Metatype&lt;B&gt;&gt;<br>&gt; <br>&gt; let pB: P.Type = B.self<br>&gt; let b = cast(metatype: pB, to: B.self)   //=&gt; an Optional&lt;Metatype&lt;B&gt;&gt;<br>&gt; Impact on existing code<br>&gt; <br>&gt; This is a source-breaking change that can be automated by a migrator. Any occurrence of T.Type or T.Protocol will be simply renamed to Metatype&lt;T&gt;.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Alternatively it’s reasonable to consider to rename T.self to T.metatype.<br>&gt; It was considered to reserve Type&lt;T&gt; for different usage in the future.<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/e678d2c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 22, 2016 at 12:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 22, 2016, at 9:22 AM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To be honest, I have difficulty with the terminology here. Why use the term ‚metatype‘<br></p><p>It is the literature&#39;s terminology (types about types) and also the compiler&#39;s own naming.<br></p><p>&gt; in the first place? Why not just ‚Type&#39;? Or ‚TypeDescriptor‘ (in analogy to ObjectIdentifier)? What do we actually gain by the technical distinction between a type and a type of a type? I would understand it if we had the ability to construct higher-order types, such as custom metatypes or even metatype types in Swift.  <br>&gt; <br>&gt; But in general, I am sympathetic with the proposal.Swift type/metatype facilities are very confusing (I still don’t  get how the .Type, .Self, .self etc. stuff works) and bringing some clarity will be most welcome. <br>&gt; <br>&gt; — T. <br>&gt; <br>&gt; <br>&gt;&gt; On 22 Jul 2016, at 00:40, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; https://github.com/DevAndArtist/swift-evolution/blob/rename_t_dot_type/proposals/0126-rename-t-dot-type.md<br>&gt;&gt; <br>&gt;&gt; Rename T.Type<br>&gt;&gt; <br>&gt;&gt; Proposal: SE–0126<br>&gt;&gt; Authors: Adrian Zubarev, Anton Zhilin<br>&gt;&gt; Status: Revision<br>&gt;&gt; Review manager: Chris Lattner<br>&gt;&gt; Revision: 2<br>&gt;&gt; Previous Revisions: 1<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal renames the current metatype T.Type notation and the global function from SE–0096 to match the changes.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution threads: <br>&gt;&gt; <br>&gt;&gt; [Pitch] Rename T.Type<br>&gt;&gt; [Review] SE–0126: Refactor Metatypes, repurpose T[dot]self and Mirror<br>&gt;&gt; [Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror<br>&gt;&gt; [Discussion] Seal T.Type into Type&lt;T&gt;<br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; In Swift metatypes have the following notation: T.Type<br>&gt;&gt; <br>&gt;&gt; As already showed in SE–0096 and SE–0090 the Swift community strongly is in favor of (re)moving magical intstance or type properties.<br>&gt;&gt; <br>&gt;&gt; SE–0096 moves instanceOfT.dynamicType to type&lt;T&gt;(of: T) -&gt; T.Type.<br>&gt;&gt; <br>&gt;&gt; SE–0090 aims to remove .self completely.<br>&gt;&gt; <br>&gt;&gt; We propose to rename T.Type to a generic-like notation Metatype&lt;T&gt;. To be able to achieve this notation we have to resolve a few issues first.<br>&gt;&gt; <br>&gt;&gt; Known issues of metatypes:<br>&gt;&gt; <br>&gt;&gt; Assume this function that checks if an Int type conforms to a specific protocol. This check uses current model of metatypes combined in a generic context:<br>&gt;&gt; <br>&gt;&gt; func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>&gt;&gt;    return Int.self is T.Type<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; intConforms(to: CustomStringConvertible.self) //=&gt; false<br>&gt;&gt; <br>&gt;&gt; Int.self is CustomStringConvertible.Type      //=&gt; true<br>&gt;&gt; [1] When T is a protocol P, T.Type is the metatype of the protocol type itself, P.Protocol. Int.self is not P.self.<br>&gt;&gt; <br>&gt;&gt; [2] There isn’t a way to generically expression P.Type yet.<br>&gt;&gt; <br>&gt;&gt; [3] The syntax would have to be changed in the compiler to get something that behaves like .Type today.<br>&gt;&gt; <br>&gt;&gt; Written by Joe Groff: [1] [2] [3]<br>&gt;&gt; A possible workaround might look like the example below, but does not allow to decompose P.Type:<br>&gt;&gt; <br>&gt;&gt; func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>&gt;&gt;   return Int.self is T<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; intConforms(to: CustomStringConvertible.Type.self) //=&gt; true<br>&gt;&gt; We can extend this issue and find the second problem by checking against the metatype of Any:<br>&gt;&gt; <br>&gt;&gt; func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>&gt;&gt;     return Int.self is T<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; intConforms(to: Any.Type.self) //=&gt; true<br>&gt;&gt; <br>&gt;&gt; intConforms(to: Any.self)      //=&gt; true<br>&gt;&gt; <br>&gt;&gt; Int.self is Any.Type           //=&gt; Always true<br>&gt;&gt; When using Any the compiler does not require .Type at all and returns true for both variations.<br>&gt;&gt; <br>&gt;&gt; The third issue will show itself whenever we would try to check protocol relationship with another protocol. Currently there is no way (that we know of) to solve this problem:<br>&gt;&gt; <br>&gt;&gt; protocol P {}<br>&gt;&gt; protocol R : P {}<br>&gt;&gt; <br>&gt;&gt; func rIsSubtype&lt;T&gt;(of _: T.Type) -&gt; Bool {<br>&gt;&gt;     return R.self is T<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; rIsSubtype(of: P.Type.self) //=&gt; false<br>&gt;&gt; <br>&gt;&gt; R.self is Any.Type //=&gt; Always true<br>&gt;&gt; R.self is P.Type   //=&gt; true<br>&gt;&gt; R.self is R.Type   //=&gt; true<br>&gt;&gt; We also believe that this issue is the reason why the current global functions sizeof, strideof and alignof make use of generic &lt;T&gt;(_: T.Type) declaration notation instead of (_: Any.Type).<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; Rename any occurrence of T.Type and T.Protocol to Metatype&lt;T&gt;.<br>&gt;&gt; <br>&gt;&gt; Revise metatypes internally. <br>&gt;&gt; <br>&gt;&gt; When T is a protocol, T.self should always return an instance of Metatype&lt;T&gt; (old T.Type) and never a T.Protocol. Furthermore, metatypes should reflect the same type relationship behavior like the actual types themselves. <br>&gt;&gt; <br>&gt;&gt; To match the correct meaning and usage of the noun ‘Metatype’ from this proposal, we also propose to rename the global function from SE–0096:<br>&gt;&gt; <br>&gt;&gt; before: public func type&lt;T&gt;(of instance: T) -&gt; T.Type<br>&gt;&gt; after: public func metatype&lt;T&gt;(of instance: T) -&gt; Metatype&lt;T&gt;<br>&gt;&gt; Examples:<br>&gt;&gt; <br>&gt;&gt; protocol P {}<br>&gt;&gt; protocol R : P {}<br>&gt;&gt; class A : P {}<br>&gt;&gt; class B : A, R {}<br>&gt;&gt; <br>&gt;&gt; func `is`&lt;T&gt;(metatype: Metatype&lt;Any&gt;, also _: Metatype&lt;T&gt; ) -&gt; Bool {<br>&gt;&gt;     return metatype is Metatype&lt;T&gt;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; `is`(metatype: R.self, also: Any.self) //=&gt; true | Currently: false<br>&gt;&gt; `is`(metatype: R.self, also: P.self)   //=&gt; true | Currently: false<br>&gt;&gt; `is`(metatype: R.self, also: R.self)   //=&gt; true<br>&gt;&gt; <br>&gt;&gt; `is`(metatype: B.self, also: Any.self) //=&gt; true | Currently: false<br>&gt;&gt; `is`(metatype: B.self, also: P.self)   //=&gt; true | Currently: false<br>&gt;&gt; `is`(metatype: B.self, also: R.self)   //=&gt; true | Currently: false<br>&gt;&gt; `is`(metatype: B.self, also: A.self)   //=&gt; true<br>&gt;&gt; `is`(metatype: B.self, also: B.self)   //=&gt; true<br>&gt;&gt; <br>&gt;&gt; func cast&lt;T&gt;(metatype: Metatype&lt;Any&gt;, to _: Metatype&lt;T&gt;) -&gt; Metatype&lt;T&gt;? {<br>&gt;&gt;     return metatype as? Metatype&lt;T&gt;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; cast(metatype: R.self, to: Any.self)     //=&gt; an Optional&lt;Metatype&lt;Any&gt;&gt; | Currently: nil<br>&gt;&gt; cast(metatype: R.self, to: P.self)       //=&gt; an Optional&lt;Metatype&lt;P&gt;&gt;   | Currently: nil<br>&gt;&gt; cast(metatype: R.self, to: R.self)       //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: an Optional&lt;R.Protocol&gt;<br>&gt;&gt; <br>&gt;&gt; let anyR: Any.Type = R.self<br>&gt;&gt; let r = cast(metatype: anyR, to: R.self) //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: an Optional&lt;R.Protocol&gt;<br>&gt;&gt; <br>&gt;&gt; cast(metatype: B.self, to: Any.self)     //=&gt; an Optional&lt;Metatype&lt;Any&gt;&gt; | Currently: nil<br>&gt;&gt; cast(metatype: B.self, to: P.self)       //=&gt; an Optional&lt;Metatype&lt;P&gt;&gt;   | Currently: nil<br>&gt;&gt; cast(metatype: B.self, to: R.self)       //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: nil<br>&gt;&gt; cast(metatype: B.self, to: A.self)       //=&gt; an Optional&lt;Metatype&lt;A&gt;&gt;<br>&gt;&gt; cast(metatype: B.self, to: B.self)       //=&gt; an Optional&lt;Metatype&lt;B&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; let pB: P.Type = B.self<br>&gt;&gt; let b = cast(metatype: pB, to: B.self)   //=&gt; an Optional&lt;Metatype&lt;B&gt;&gt;<br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a source-breaking change that can be automated by a migrator. Any occurrence of T.Type or T.Protocol will be simply renamed to Metatype&lt;T&gt;.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Alternatively it’s reasonable to consider to rename T.self to T.metatype.<br>&gt;&gt; It was considered to reserve Type&lt;T&gt; for different usage in the future.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/ded76f54/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Revision] [Pitch] Rename `T.Type`</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>July 22, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On 22 Jul 2016, at 12:11, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt; On Jul 22, 2016, at 9:22 AM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; To be honest, I have difficulty with the terminology here. Why use the term ‚metatype‘ <br>&gt; <br>&gt; It is the literature&#39;s terminology (types about types) and also the compiler&#39;s own naming.<br></p><p><br>I am certainly not contesting these facts. However, I am not sure how helpful this particular terminology is in the relevant context. After all, we are talking here about operations on types themselves, not types of a type. While it is true that any type variable/parameter itself is of a metatype type, I don’t see any utility gained by making this fact explicit. Something like Type or TypeInfo accomplishes the same and is probably easier to understand. <br></p><p>For instance, I have difficulty understanding why you suggest to rename type(of:) to metatype(of:). Unless I am completely confused, the return value is a type, isn’t it? its just that the type of the return value is a metatype. <br></p><p>This is a different thing in languages like Python, where metatypes have a clear practical purpose (it is possible to directly create and manipulate metatypes).<br></p><p>— T. <br></p><p>P.S. I hope my naive questions are not too inappropriate. I am honestly trying to understand the topic. While I do have some background in higher-order logic and type theory, and I have done a fair share of programming with types and types of types, the way Swift works in this regard eludes me. <br></p><p>&gt; <br>&gt;&gt; in the first place? Why not just ‚Type&#39;? Or ‚TypeDescriptor‘ (in analogy to ObjectIdentifier)? What do we actually gain by the technical distinction between a type and a type of a type? I would understand it if we had the ability to construct higher-order types, such as custom metatypes or even metatype types in Swift.  <br>&gt;&gt; <br>&gt;&gt; But in general, I am sympathetic with the proposal.Swift type/metatype facilities are very confusing (I still don’t  get how the .Type, .Self, .self etc. stuff works) and bringing some clarity will be most welcome. <br>&gt;&gt; <br>&gt;&gt; — T. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 22 Jul 2016, at 00:40, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/DevAndArtist/swift-evolution/blob/rename_t_dot_type/proposals/0126-rename-t-dot-type.md &lt;https://github.com/DevAndArtist/swift-evolution/blob/rename_t_dot_type/proposals/0126-rename-t-dot-type.md&gt;<br>&gt;&gt;&gt; Rename T.Type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE–0126 &lt;x-msg://35/0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.md&gt;<br>&gt;&gt;&gt; Authors: Adrian Zubarev &lt;https://github.com/DevAndArtist&gt;, Anton Zhilin &lt;https://github.com/Anton3&gt;<br>&gt;&gt;&gt; Status: Revision<br>&gt;&gt;&gt; Review manager: Chris Lattner &lt;http://github.com/lattner&gt;<br>&gt;&gt;&gt; Revision: 2<br>&gt;&gt;&gt; Previous Revisions: 1 &lt;https://github.com/apple/swift-evolution/blob/83707b0879c83dcde778f8163f5768212736fdc2/proposals/0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.md&gt;<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal renames the current metatype T.Type notation and the global function from SE–0096 to match the changes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution threads: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [Pitch] Rename T.Type &lt;applewebdata://5920FB3D-680D-42A4-A834-AF48FAFD667D&gt;<br>&gt;&gt;&gt; [Review] SE–0126: Refactor Metatypes, repurpose T[dot]self and Mirror &lt;applewebdata://5920FB3D-680D-42A4-A834-AF48FAFD667D&gt;<br>&gt;&gt;&gt; [Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160718/024772.html&gt;<br>&gt;&gt;&gt; [Discussion] Seal T.Type into Type&lt;T&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160704/023818.html&gt;<br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Swift metatypes have the following notation: T.Type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As already showed in SE–0096 and SE–0090 the Swift community strongly is in favor of (re)moving magical intstance or type properties.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SE–0096 moves instanceOfT.dynamicType to type&lt;T&gt;(of: T) -&gt; T.Type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SE–0090 aims to remove .self completely.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We propose to rename T.Type to a generic-like notation Metatype&lt;T&gt;. To be able to achieve this notation we have to resolve a few issues first.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Known issues of metatypes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Assume this function that checks if an Int type conforms to a specific protocol. This check uses current model of metatypes combined in a generic context:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>&gt;&gt;&gt;    return Int.self is T.Type<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; intConforms(to: CustomStringConvertible.self) //=&gt; false<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Int.self is CustomStringConvertible.Type      //=&gt; true<br>&gt;&gt;&gt; [1] When T is a protocol P, T.Type is the metatype of the protocol type itself, P.Protocol. Int.self is not P.self.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [2] There isn’t a way to generically expression P.Type yet.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [3] The syntax would have to be changed in the compiler to get something that behaves like .Type today.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Written by Joe Groff: [1] &lt;https://twitter.com/jckarter/status/754420461404958721&gt; [2] &lt;https://twitter.com/jckarter/status/754420624261472256&gt; [3] &lt;https://twitter.com/jckarter/status/754425573762478080&gt;<br>&gt;&gt;&gt; A possible workaround might look like the example below, but does not allow to decompose P.Type:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>&gt;&gt;&gt;   return Int.self is T<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; intConforms(to: CustomStringConvertible.Type.self) //=&gt; true<br>&gt;&gt;&gt; We can extend this issue and find the second problem by checking against the metatype of Any:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>&gt;&gt;&gt;     return Int.self is T<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; intConforms(to: Any.Type.self) //=&gt; true<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; intConforms(to: Any.self)      //=&gt; true<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Int.self is Any.Type           //=&gt; Always true<br>&gt;&gt;&gt; When using Any the compiler does not require .Type at all and returns true for both variations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The third issue will show itself whenever we would try to check protocol relationship with another protocol. Currently there is no way (that we know of) to solve this problem:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {}<br>&gt;&gt;&gt; protocol R : P {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func rIsSubtype&lt;T&gt;(of _: T.Type) -&gt; Bool {<br>&gt;&gt;&gt;     return R.self is T<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; rIsSubtype(of: P.Type.self) //=&gt; false<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; R.self is Any.Type //=&gt; Always true<br>&gt;&gt;&gt; R.self is P.Type   //=&gt; true<br>&gt;&gt;&gt; R.self is R.Type   //=&gt; true<br>&gt;&gt;&gt; We also believe that this issue is the reason why the current global functions sizeof, strideof and alignof make use of generic &lt;T&gt;(_: T.Type) declaration notation instead of (_: Any.Type).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Rename any occurrence of T.Type and T.Protocol to Metatype&lt;T&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Revise metatypes internally. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When T is a protocol, T.self should always return an instance of Metatype&lt;T&gt; (old T.Type) and never a T.Protocol. Furthermore, metatypes should reflect the same type relationship behavior like the actual types themselves. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To match the correct meaning and usage of the noun ‘Metatype’ from this proposal, we also propose to rename the global function from SE–0096:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; before: public func type&lt;T&gt;(of instance: T) -&gt; T.Type<br>&gt;&gt;&gt; after: public func metatype&lt;T&gt;(of instance: T) -&gt; Metatype&lt;T&gt;<br>&gt;&gt;&gt; Examples:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {}<br>&gt;&gt;&gt; protocol R : P {}<br>&gt;&gt;&gt; class A : P {}<br>&gt;&gt;&gt; class B : A, R {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func `is`&lt;T&gt;(metatype: Metatype&lt;Any&gt;, also _: Metatype&lt;T&gt; ) -&gt; Bool {<br>&gt;&gt;&gt;     return metatype is Metatype&lt;T&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `is`(metatype: R.self, also: Any.self) //=&gt; true | Currently: false<br>&gt;&gt;&gt; `is`(metatype: R.self, also: P.self)   //=&gt; true | Currently: false<br>&gt;&gt;&gt; `is`(metatype: R.self, also: R.self)   //=&gt; true<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `is`(metatype: B.self, also: Any.self) //=&gt; true | Currently: false<br>&gt;&gt;&gt; `is`(metatype: B.self, also: P.self)   //=&gt; true | Currently: false<br>&gt;&gt;&gt; `is`(metatype: B.self, also: R.self)   //=&gt; true | Currently: false<br>&gt;&gt;&gt; `is`(metatype: B.self, also: A.self)   //=&gt; true<br>&gt;&gt;&gt; `is`(metatype: B.self, also: B.self)   //=&gt; true<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func cast&lt;T&gt;(metatype: Metatype&lt;Any&gt;, to _: Metatype&lt;T&gt;) -&gt; Metatype&lt;T&gt;? {<br>&gt;&gt;&gt;     return metatype as? Metatype&lt;T&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; cast(metatype: R.self, to: Any.self)     //=&gt; an Optional&lt;Metatype&lt;Any&gt;&gt; | Currently: nil<br>&gt;&gt;&gt; cast(metatype: R.self, to: P.self)       //=&gt; an Optional&lt;Metatype&lt;P&gt;&gt;   | Currently: nil<br>&gt;&gt;&gt; cast(metatype: R.self, to: R.self)       //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: an Optional&lt;R.Protocol&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let anyR: Any.Type = R.self<br>&gt;&gt;&gt; let r = cast(metatype: anyR, to: R.self) //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: an Optional&lt;R.Protocol&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; cast(metatype: B.self, to: Any.self)     //=&gt; an Optional&lt;Metatype&lt;Any&gt;&gt; | Currently: nil<br>&gt;&gt;&gt; cast(metatype: B.self, to: P.self)       //=&gt; an Optional&lt;Metatype&lt;P&gt;&gt;   | Currently: nil<br>&gt;&gt;&gt; cast(metatype: B.self, to: R.self)       //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: nil<br>&gt;&gt;&gt; cast(metatype: B.self, to: A.self)       //=&gt; an Optional&lt;Metatype&lt;A&gt;&gt;<br>&gt;&gt;&gt; cast(metatype: B.self, to: B.self)       //=&gt; an Optional&lt;Metatype&lt;B&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let pB: P.Type = B.self<br>&gt;&gt;&gt; let b = cast(metatype: pB, to: B.self)   //=&gt; an Optional&lt;Metatype&lt;B&gt;&gt;<br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a source-breaking change that can be automated by a migrator. Any occurrence of T.Type or T.Protocol will be simply renamed to Metatype&lt;T&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatively it’s reasonable to consider to rename T.self to T.metatype.<br>&gt;&gt;&gt; It was considered to reserve Type&lt;T&gt; for different usage in the future.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/44c6dff3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
