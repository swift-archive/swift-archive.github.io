<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1b852c5986959201d1f8eca105491072?s=50"></div><header><strong>Could enums have their rawValue type inferred?</strong> from <string>Eric Miller</string> &lt;hi at simple.gy&gt;<p>May 14, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; automatically cast rawValue when assigning an enum value to<br>a variable or argument of the type of the enum&#39;s raw value<br></p><p>That&#39;s exactly what I&#39;m thinking, Leonardo. I was a little bit trying to<br>avoid specifics because I don&#39;t understand the differences between<br>autocasting and inference.<br></p><p>There&#39;s a small miscommunication though--I&#39;ve built api to accept the enum<br>type. Signature:<br></p><p>static func fadeIn(view: UIView?, withSpeed: Animate.transitionSpeed =<br>Animate.transitionSpeed.fast)<br></p><p>The goal was to provide my users with a good default and an easy set of<br>configurable options at the call site like `.fast`, `.normal`, `.slow`.<br></p><p>(unrelated: +1 on inferring type of function params with default values, I<br>hit this all the time)<br></p><p>Calling:<br></p><p>Animate.fadeIn(myView, withSpeed: .slow)<br></p><p>Works great.<br></p><p>This library of methods is a facade for CABasicAnimation or UIView<br>animations which take an NSTimeInterval, and that&#39;s where the &quot;autocasting&quot;<br>would come into play.<br></p><p><br></p><p>------------------------------<br></p><p>Message: 31<br>Date: Fri, 13 May 2016 16:58:06 -0300<br>From: Leonardo Pessoa &lt;me at lmpessoa.com&gt;<br>To: Swift-evolution &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] Could enums have their rawValue type<br>        inferred?<br>Message-ID:<br>        &lt;CANTOS57wksMRzUAMq0ncf1QAd82vhudf21tnea6wHjhBOFr1PA at mail.gmail.com&gt;<br>Content-Type: text/plain; charset=&quot;utf-8&quot;<br></p><p>Eric, I think I understood your proposal. If I may explain in other words<br>it would be &quot;to automatically cast rawValue when assigning an enum value to<br>a variable or argument of the type of the enum&#39;s raw value&quot;, am I right? I<br>think this would imply a little more inference and type checking rules from<br>the compiler and maybe even take a little longer to fully compile code. I&#39;m<br>not sure it&#39;s feasible but from your examples, I can see how it enhances<br>readability of the code, so I&#39;m +1 for it. My only concern is that you<br>would still need to fully declare the enum&#39;s name where the value of the<br>enum is used. Taking from your own example<br></p><p>    Animate.fadeIn(view, withSpeed: .fast)<br></p><p>couldn&#39;t be called that way if withSpeed expects and NSTimeInterval because<br>the compiler won&#39;t know whether you&#39;re refering to transitionSpeed or to<br>ambientAnimationSpeed. You would still have to call it like<br></p><p>    Animate.fadeIn(view, withSpeed: transitionSpeed.fast)<br></p><p>even if you had only one possible enum value over all declared enums<br>because that would still force the compiler to search for each value over<br>all known enums to define where the value you&#39;re using comes from and make<br>sure there are no two enums with the same value.<br></p><p>Aside from that, I good with the idea.<br></p><p><br></p><p>On 13 May 2016 at 15:09, Eric Miller via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This might open a larger can of worms than I imagine, but what do you<br>&gt; folks think about using the `rawValue` of an enum when that rawValue is a<br>&gt; fit for the expected type?<br>&gt;<br>&gt; Use case.<br>&gt;<br>&gt; I&#39;m making an animation facade, and it has some speed presets:<br>&gt;<br>&gt; class Animate {<br>&gt;   enum transitionSpeed: NSTimeInterval {<br>&gt;     case fast = 0.15<br>&gt;     case slow = 0.5<br>&gt;   }<br>&gt;   enum ambientAnimationSpeed: NSTimeInterval {<br>&gt;     case fast = 1.0<br>&gt;     case slow = 5.0<br>&gt;   }<br>&gt;   ...<br>&gt; }<br>&gt;<br>&gt; I did them with static variables at first but that made the call site<br>&gt; verbose. Compare:<br>&gt;<br>&gt; Animate.fadeIn(view, withSpeed: Animate.cfg.transitionFast)<br>&gt; Animate.fadeIn(view, withSpeed: .fast)<br>&gt;<br>&gt; So, I like the enum approach better, but my library code has to use<br>&gt; `rawValue` to do anything with the actual value, of course:<br>&gt;<br>&gt; static func fadeIn(view: UIView?, withSpeed duration:transitionSpeed =<br>&gt; .fast) {<br>&gt;   ...<br>&gt;   UIView.animateWithDuration(duration.rawValue, animations: { })<br>&gt; }<br>&gt;<br>&gt; It&#39;s not a serious issue, but the code is more clear and beautiful if it<br>&gt; has just myIntent, rather than myIntent.rawValue.<br>&gt;<br>&gt; I&#39;ve hit this issue when modeling other things, such as:<br>&gt;<br>&gt; * server fault codes<br>&gt; * HTTP status codes<br>&gt; * Currency codes<br>&gt; * Days of the week<br>&gt;<br>&gt; Would it be appropriate to &quot;autocast&quot; to the rawValue of the enum when the<br>&gt; rawValue&#39;s Type matches the type expectation of the API? Or would this<br>&gt; introduce a bunch of type system uncertainty?<br>&gt;<br>&gt; Maybe this could be implemented as a protocol? It feels almost like the<br>&gt; convenience of `CustomStringConvertible`&#39;s `description` property.<br></p><p>On Fri, May 13, 2016 at 11:24 PM, &lt;swift-evolution-request at swift.org&gt; wrote:<br></p><p>&gt; Send swift-evolution mailing list submissions to<br>&gt;         swift-evolution at swift.org<br>&gt;<br>&gt; To subscribe or unsubscribe via the World Wide Web, visit<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; or, via email, send a message with subject or body &#39;help&#39; to<br>&gt;         swift-evolution-request at swift.org<br>&gt;<br>&gt; You can reach the person managing the list at<br>&gt;         swift-evolution-owner at swift.org<br>&gt;<br>&gt; When replying, please edit your Subject line so it is more specific<br>&gt; than &quot;Re: Contents of swift-evolution digest...&quot;<br>&gt;<br>&gt;<br>&gt; Today&#39;s Topics:<br>&gt;<br>&gt;    1. Re: [Pitch] merge types and protocols back together with<br>&gt;       type&lt;Type, Protocol, ...&gt; (Vladimir.S)<br>&gt;    2. Re: [Pitch] merge types and protocols back together with<br>&gt;       type&lt;Type, Protocol, ...&gt; (Vladimir.S)<br>&gt;    3. Re: [Pitch] merge types and protocols back together with<br>&gt;       type&lt;Type, Protocol, ...&gt; (Ross O&#39;Brien)<br>&gt;    4. Re: Removing &quot;_ in&quot; from empty closures (Cole Campbell)<br>&gt;    5. Re: [Review] SE-0084: Allow trailing commas in parameter<br>&gt;       lists and tuples (Joe Groff)<br>&gt;    6. Re: [Pitch] merge types and protocols back together with<br>&gt;       type&lt;Type, Protocol, ...&gt; (Adrian Zubarev)<br>&gt;    7. Re: [Review] SE-0084: Allow trailing commas in parameter<br>&gt;       lists and tuples (Joe Groff)<br>&gt;    8. Re: [Review] SE-0084: Allow trailing commas in parameter<br>&gt;       lists and tuples (Vladimir.S)<br>&gt;    9. Re: [Review] SE-0084: Allow trailing commas in    parameter<br>&gt;       lists and tuples (Erica Sadun)<br>&gt;   10. Re: [Pitch] merge types and protocols back together with<br>&gt;       type&lt;Type, Protocol, ...&gt; (Adrian Zubarev)<br>&gt;   11. Re: Removing &quot;_ in&quot; from empty closures (Erica Sadun)<br>&gt;   12. Re: [swift-evolution-announce] [Review] SE-0041:  Updating<br>&gt;       Protocol  Naming Conventions for Conversions (Pyry Jahkola)<br>&gt;   13. Could enums have their rawValue type inferred? (Eric Miller)<br>&gt;   14. Re: [Draft] Introducing StaticSelf,       an Invariant Self<br>&gt;       (Nicola Salmoria)<br>&gt;   15. Re: [Review] SE-0045: Add scan, prefix(while:),   drop(while:),<br>&gt;       and iterate to the stdlib (Erica Sadun)<br>&gt;   16. Re: [Review] SE-0075: Adding a Build      Configuration Import<br>&gt;       Test (Pyry Jahkola)<br>&gt;   17. [draft-proposal] allow access to the underlying   collection of<br>&gt;       a slice (Max Moiseev)<br>&gt;   18. Re: [Review] SE-0084: Allow trailing commas in parameter<br>&gt;       lists and tuples (Joe Groff)<br>&gt;   19. Interspersing guard let with guard boolean (Erica Sadun)<br>&gt;   20. Re: Interspersing guard let with guard boolean (Joe Groff)<br>&gt;   21. Re: Interspersing guard let with guard boolean (Erica Sadun)<br>&gt;   22. Re: [Pitch] merge types and protocols back together with<br>&gt;       type&lt;Type, Protocol, ...&gt; (Vladimir.S)<br>&gt;   23. Re: [Review] SE-0088: Modernize libdispatch for   Swift 3<br>&gt;       naming conventions (Matt Wright)<br>&gt;   24. Re: [Draft] Introducing StaticSelf,       an Invariant Self<br>&gt;       (Matthew Johnson)<br>&gt;   25. Re: [Review] SE-0045: Add scan, prefix(while:), drop(while:),<br>&gt;       and iterate to the stdlib (Kevin Ballard)<br>&gt;   26. Re: [Pitch] merge types and protocols back together with<br>&gt;       type&lt;Type, Protocol, ...&gt; (Adrian Zubarev)<br>&gt;   27. Re: [Review] SE-0088: Modernize libdispatch for Swift 3<br>&gt;       naming conventions (Jacob Bandes-Storch)<br>&gt;   28. Re: [Review] SE-0088: Modernize libdispatch for Swift 3<br>&gt;       naming conventions (Xiaodi Wu)<br>&gt;   29. Re: [Review] SE-0088: Modernize libdispatch for   Swift 3<br>&gt;       naming conventions (Matt Wright)<br>&gt;   30. Re: [Review] SE-0088: Modernize libdispatch for   Swift 3<br>&gt;       naming conventions (Matt Wright)<br>&gt;   31. Re: Could enums have their rawValue type inferred?<br>&gt;       (Leonardo Pessoa)<br>&gt;   32. Re: Removing &quot;_ in&quot; from empty closures (Jacob Bandes-Storch)<br>&gt;   33. Re: Removing &quot;_ in&quot; from empty closures (Matthew Johnson)<br>&gt;   34. Re: [Draft] Introducing StaticSelf,       an Invariant Self (Joe<br>&gt; Groff)<br>&gt;   35. Re: Removing &quot;_ in&quot; from empty closures (Joe Groff)<br>&gt;   36. Re: [Review] SE-0084: Allow trailing commas in parameter<br>&gt;       lists and tuples (John Siracusa)<br>&gt;   37. Re: [Pitch] merge types and protocols back together with<br>&gt;       type&lt;Type, Protocol, ...&gt; (Vladimir.S)<br>&gt;   38. Re: [Draft] Introducing StaticSelf, an Invariant Self (Vladimir.S)<br>&gt;   39. Re: Removing &quot;_ in&quot; from empty closures (Matthew Johnson)<br>&gt;   40. Re: [Review] SE-0088: Modernize libdispatch for   Swift   3<br>&gt;       naming conventions (Matt Wright)<br>&gt;   41. Re: [Pitch] merge types and protocols back together with<br>&gt;       type&lt;Type, Protocol, ...&gt; (Adrian Zubarev)<br>&gt;   42. Re: [Pitch] merge types and protocols back        together with<br>&gt;       type&lt;Type, Protocol, ...&gt; (Matthew Johnson)<br>&gt;   43. Re: [Draft] Introducing StaticSelf,       an Invariant Self<br>&gt;       (Matthew Johnson)<br>&gt;   44. Re: [Pitch] merge types and protocols back together with<br>&gt;       type&lt;Type, Protocol, ...&gt; (Austin Zheng)<br>&gt;   45. Re: [Review] SE-0081: Move where clause to end of declaration<br>&gt;       (Jon Shier)<br>&gt;   46. Re: [Pitch] Consistent bridging for NSErrors at   the language<br>&gt;       boundary (Jon Shier)<br>&gt;   47. Re: [Review] SE-0045: Add scan, prefix(while:),   drop(while:),<br>&gt;       and iterate to the stdlib (Patrick Smith)<br>&gt;<br>&gt;<br>&gt; ----------------------------------------------------------------------<br>&gt;<br>&gt; Message: 1<br>&gt; Date: Fri, 13 May 2016 20:04:46 +0300<br>&gt; From: &quot;Vladimir.S&quot; &lt;svabox at gmail.com&gt;<br>&gt; To: Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt;<br>&gt; Cc: swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Pitch] merge types and protocols back<br>&gt;         together with type&lt;Type, Protocol, ...&gt;<br>&gt; Message-ID: &lt;2f3fbb45-173f-15b4-492d-c059899d5482 at gmail.com&gt;<br>&gt; Content-Type: text/plain; charset=utf-8; format=flowed<br>&gt;<br>&gt; On 13.05.2016 19:38, Adrian Zubarev via swift-evolution wrote:<br>&gt; &gt; Why would you want to add all of these different formats where only one<br>&gt; &gt; could serve them all. This is redundant in my opinion.<br>&gt; &gt;<br>&gt; &gt; `struct&lt;&gt;` and `enum&lt;&gt;` would have same rules, only the first element<br>&gt; would<br>&gt; &gt; be a different value-type. I might consider this as an alternative.<br>&gt; &gt;<br>&gt;<br>&gt; Actually, I fully support your idea and strongly +1 for `type&lt;&gt;` keyword. I<br>&gt; don&#39;t believe it will confuse anyone as protocol&lt;&gt; does not confuse<br>&gt; currently.<br>&gt;<br>&gt; But as I can see, the community(or core team) is strongly against of using<br>&gt; `type` keyword.<br>&gt; So, we have situation : protocol&lt;&gt; and .. all&lt;&gt; ? Will all&lt;&gt; include<br>&gt; protocols also? Probably I&#39;d support to remove protocol&lt;&gt; and introduce<br>&gt; just all&lt;&gt; for all :-) But if we have protocol&lt;&gt; and can&#39;t have type&lt;&gt; - I<br>&gt; asked why we can&#39;t for clarity and consistency have class&lt;&gt; struct&lt;&gt;<br>&gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 2<br>&gt; Date: Fri, 13 May 2016 20:08:57 +0300<br>&gt; From: &quot;Vladimir.S&quot; &lt;svabox at gmail.com&gt;<br>&gt; To: Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt;<br>&gt; Cc: swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Pitch] merge types and protocols back<br>&gt;         together with type&lt;Type, Protocol, ...&gt;<br>&gt; Message-ID: &lt;b8fdfea7-e174-718e-5b28-6ec373f1d8b4 at gmail.com&gt;<br>&gt; Content-Type: text/plain; charset=utf-8; format=flowed<br>&gt;<br>&gt; Btw, if we&#39;d have separate class&lt;&gt; and struct&lt;&gt; - we&#39;d be able to have<br>&gt; method to separate reference type from value type.<br>&gt;<br>&gt; We can write now : print(c is protocol&lt;&gt;)<br>&gt;<br>&gt; and we&#39;d can:<br>&gt;<br>&gt; print(c is class&lt;&gt;)<br>&gt; print(c is struct&lt;&gt;)<br>&gt;<br>&gt; Just thoughts..<br>&gt;<br>&gt; On 13.05.2016 20:04, Vladimir.S wrote:<br>&gt; &gt; On 13.05.2016 19:38, Adrian Zubarev via swift-evolution wrote:<br>&gt; &gt;&gt; Why would you want to add all of these different formats where only one<br>&gt; &gt;&gt; could serve them all. This is redundant in my opinion.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; `struct&lt;&gt;` and `enum&lt;&gt;` would have same rules, only the first element<br>&gt; would<br>&gt; &gt;&gt; be a different value-type. I might consider this as an alternative.<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; Actually, I fully support your idea and strongly +1 for `type&lt;&gt;`<br>&gt; keyword. I<br>&gt; &gt; don&#39;t believe it will confuse anyone as protocol&lt;&gt; does not confuse<br>&gt; currently.<br>&gt; &gt;<br>&gt; &gt; But as I can see, the community(or core team) is strongly against of<br>&gt; using<br>&gt; &gt; `type` keyword.<br>&gt; &gt; So, we have situation : protocol&lt;&gt; and .. all&lt;&gt; ? Will all&lt;&gt; include<br>&gt; &gt; protocols also? Probably I&#39;d support to remove protocol&lt;&gt; and introduce<br>&gt; &gt; just all&lt;&gt; for all :-) But if we have protocol&lt;&gt; and can&#39;t have type&lt;&gt; -<br>&gt; I<br>&gt; &gt; asked why we can&#39;t for clarity and consistency have class&lt;&gt; struct&lt;&gt;<br>&gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 3<br>&gt; Date: Fri, 13 May 2016 18:11:11 +0100<br>&gt; From: &quot;Ross O&#39;Brien&quot; &lt;narrativium+swift at gmail.com&gt;<br>&gt; To: Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt;<br>&gt; Cc: swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Pitch] merge types and protocols back<br>&gt;         together with type&lt;Type, Protocol, ...&gt;<br>&gt; Message-ID:<br>&gt;         &lt;<br>&gt; CAPUwzK55PQYDT4j1UBS69KSo410xKWR3js9dY1W8cBsjJshU6g at mail.gmail.com&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; In reply to:<br>&gt;<br>&gt; Why would you want to add all of these different formats where only one<br>&gt; could serve them all. This is redundant in my opinion.<br>&gt;<br>&gt; `struct&lt;&gt;` and `enum&lt;&gt;` would have same rules, only the first element would<br>&gt; be a different value-type. I might consider this as an alternative.<br>&gt;<br>&gt; Correct me if I’m wrong with the redundancy.<br>&gt;<br>&gt;<br>&gt; &#39;enum&lt;&gt;&#39; might be valid, unless their functions (e.g. for &#39;init(rawValue:<br>&gt; Int)&#39; or &#39;allCases&#39;) are declared in explicit protocols which would<br>&gt; implicitly cover enums and which other types could declare conformance to.<br>&gt;<br>&gt; &#39;struct&lt;&gt;&#39; does seem redundant unless it becomes subtypeable. If you want a<br>&gt; struct which conforms to several protocols, protocol&lt;&gt; already covers this.<br>&gt; I know there&#39;s a discussion at the moment regarding the equivalent of an<br>&gt; &#39;AnyObject&#39; for value types, which might apply to this discussion, but I&#39;m<br>&gt; not sure how.<br>&gt;<br>&gt; A class in general would also a protocol&lt;AnyObject, ...&gt;. The benefit of<br>&gt; &#39;type&lt;&gt;&#39; is in its ability to extend the behaviours of several subclasses<br>&gt; at once, e.g. type&lt;UIViewController, UIScrollViewDelegate&gt; covers all view<br>&gt; controllers with scroll views, not just UITableViewController,<br>&gt; UICollectionViewController, etc..<br>&gt;<br>&gt;<br>&gt;<br>&gt; ​<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/4ace2772/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 4<br>&gt; Date: Fri, 13 May 2016 12:14:23 -0500<br>&gt; From: Cole Campbell &lt;cole.m.campbell at icloud.com&gt;<br>&gt; To: Joe Groff &lt;jgroff at apple.com&gt;<br>&gt; Cc: Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] Removing &quot;_ in&quot; from empty closures<br>&gt; Message-ID: &lt;4FC7FC81-FDF2-471D-8C0E-DA5A037AA6D3 at icloud.com&gt;<br>&gt; Content-Type: text/plain; charset=us-ascii<br>&gt;<br>&gt;<br>&gt; &gt; +1. In general, I think we should allow implicit arguments, without<br>&gt; requiring the closure to use all the implicit $n variables like we do<br>&gt; today. These should all be valid:<br>&gt; &gt;<br>&gt; &gt; let _: () -&gt; () = {}<br>&gt; &gt; let _: (Int) -&gt; () = {}<br>&gt; &gt; let _: (Int, Int) -&gt; Int = { 5 }<br>&gt; &gt; let _: (Int, Int) -&gt; Int = { $0 }<br>&gt; &gt; let _: (Int, Int) -&gt; Int = { $1 }<br>&gt;<br>&gt; +1. This would be excellent.<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 5<br>&gt; Date: Fri, 13 May 2016 10:29:01 -0700<br>&gt; From: Joe Groff &lt;jgroff at apple.com&gt;<br>&gt; To: Erica Sadun &lt;erica at ericasadun.com&gt;<br>&gt; Cc: Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0084: Allow trailing commas<br>&gt;         in parameter lists and tuples<br>&gt; Message-ID: &lt;304E28A1-D8D0-43A2-BF7A-FBAEF8828F6D at apple.com&gt;<br>&gt; Content-Type: text/plain; charset=utf-8<br>&gt;<br>&gt;<br>&gt; &gt; On May 13, 2016, at 7:04 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On May 12, 2016, at 11:01 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; On May 12, 2016, at 4:50 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt; You’re arguing that you want to read Swift code written like this?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I wouldn&#39;t mind it.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I personally find that style repulsive :-) and I haven’t seen swift<br>&gt; code commonly doing it.  I’m not sure that we want to encourage it either.<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; No. Tell us what you *really* think of the style. Don&#39;t hold back.[1]<br>&gt; &gt;<br>&gt; &gt;&gt; If we were really concerned about this, a narrower way to solve the<br>&gt; same problem would be to allow a comma before the ), but *only* when there<br>&gt; is a newline between them.  I still don’t see why we’d want to encourage<br>&gt; this though.<br>&gt; &gt;<br>&gt; &gt; I wouldn&#39;t object to this restriction. I cannot think of a situation<br>&gt; where using &quot;,)&quot; -- that is the comma adjacent to a closing parenthesis --<br>&gt; makes sense for any reason previously enumerated in support of this<br>&gt; proposal.<br>&gt;<br>&gt; I don&#39;t see why we need to micromanage the situations where trailing<br>&gt; commas are allowed. That&#39;s just unnecessarily increasing the fractal<br>&gt; complexity of the language. We&#39;ve delegated other style choices like<br>&gt; requiring `self.` or brace formatting to linters; why does this one need to<br>&gt; be legislated by the compiler?<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 6<br>&gt; Date: Fri, 13 May 2016 19:32:34 +0200<br>&gt; From: Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt;<br>&gt; To: swift-evolution at swift.org<br>&gt; Subject: Re: [swift-evolution] [Pitch] merge types and protocols back<br>&gt;         together with type&lt;Type, Protocol, ...&gt;<br>&gt; Message-ID: &lt;etPan.57360fb2.5ed02b43.6ab2 at DevAndArtist.fritz.box&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; &#39;struct&lt;&gt;&#39; does seem redundant unless it becomes subtypeable. If you want<br>&gt; a struct which conforms to several protocols, protocol&lt;&gt; already covers<br>&gt; this.<br>&gt; I think this is not correct. Lets check this example:<br>&gt;<br>&gt; func foo(value: SomeProtocol) {<br>&gt;<br>&gt;     if let a = value as? struct&lt;StructA, SomeProtocol&gt; { /* do something<br>&gt; with a */ }<br>&gt;<br>&gt;     else if let b = value as? struct&lt;StructB, SomeProtocol&gt; { /* do<br>&gt; something with b */ }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; In this scenario you’ll be able to access properties and functions from<br>&gt; `StructA` or `StructB` which might not be covered by `SomeProtocol`.<br>&gt; Everything is merged nicely into one instance. But you are right it depends<br>&gt; on the use-case.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Btw, if we&#39;d have separate class&lt;&gt; and struct&lt;&gt; - we&#39;d be able to<br>&gt; have method to separate reference type from value type.<br>&gt; We can write now : print(c is protocol&lt;&gt;)<br>&gt; and we&#39;d can:<br>&gt; print(c is class&lt;&gt;)<br>&gt; print(c is struct&lt;&gt;)<br>&gt;<br>&gt; True, I didn’t thought about that effect at the first glance, thank you<br>&gt; for the hint. I will add this to the draft proposal tomorrow.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/4a9f75e9/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 7<br>&gt; Date: Fri, 13 May 2016 10:32:34 -0700<br>&gt; From: Joe Groff &lt;jgroff at apple.com&gt;<br>&gt; To: Matthew Johnson &lt;matthew at anandabits.com&gt;,   Matthew Johnson via<br>&gt;         swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0084: Allow trailing commas<br>&gt;         in parameter lists and tuples<br>&gt; Message-ID: &lt;76E430C3-01EF-45B3-B00E-01490E75DCAA at apple.com&gt;<br>&gt; Content-Type: text/plain; charset=utf-8<br>&gt;<br>&gt;<br>&gt; &gt; On May 13, 2016, at 7:32 AM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Sent from my iPad<br>&gt; &gt;<br>&gt; &gt;&gt; On May 13, 2016, at 9:19 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On 13.05.2016 16:32, Matthew Johnson wrote:<br>&gt; &gt;&gt;&gt; I am, +1 on allowing new lines instead of commas.  I suggest you<br>&gt; pursue a proposal on that.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Unfortunately I have no ability for this right now, so someone who is<br>&gt; interested in this could take the idea and create a &#39;formal&#39; proposal.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I am also +1 on the current proposal because it exists and will be<br>&gt; pretty useful in some cases and I can&#39;t predict how long it might be until<br>&gt; such a new line proposal would be approved.  I also think that the choice<br>&gt; between them should be a style choice, not one made by the language (as<br>&gt; with semicolon) and if anyone chooses commas they should have the utility<br>&gt; of the current proposal available to them.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Don&#39;t you feel like this proposal(SE-0084) should be extended to list<br>&gt; of generic types at least, or even to allow trailing comma in any<br>&gt; comma-separated list in Swift? I.e. you are saying +1, but probably the<br>&gt; exact proposal should be improved to have your +1.<br>&gt; &gt;<br>&gt; &gt; I have no opinion on that.  I don&#39;t object to it being done in the name<br>&gt; of consistency but can&#39;t think of any actual use cases either.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Probably (if this is allowed) the author of this proposal (SE-0084) can<br>&gt; add &#39;line-break separator feature&#39; to his/her proposal and generalize the<br>&gt; rule of trailing comma/line-breaks for any comma-separated list in Swift?<br>&gt; &gt;<br>&gt; &gt; That feels like a separate proposal to me.<br>&gt;<br>&gt; I agree, allowing commas to be elided at line breaks is an interesting<br>&gt; direction that deserves its own discussion. One problem that immediately<br>&gt; comes to my mind is commas in generic parameter lists. If commas aren&#39;t<br>&gt; required in generic parameter lists, it becomes even more challenging to<br>&gt; disambiguate with less-than/greater-than expressions at top level,<br>&gt; compromising our ability to shed `.self` for this purpose.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; As I can see, the proposal SE-0084 &#39;per se&#39; has more negative comments<br>&gt; than positive(even if some from @apple.com supports it) and I feel like<br>&gt; extended proposal can have more support.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Sent from my iPad<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On May 13, 2016, at 1:24 AM, Vladimir.S via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; IMO If we were *really* concerned about this, we should just allow<br>&gt; line-break as separator in comma-separated lists.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On 13.05.2016 8:01, Chris Lattner via swift-evolution wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt; If we were really concerned about this, a narrower way to solve the<br>&gt; same problem would be to allow a comma before the ), but *only* when there<br>&gt; is a newline between them.  I still don’t see why we’d want to encourage<br>&gt; this though.<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 8<br>&gt; Date: Fri, 13 May 2016 20:42:10 +0300<br>&gt; From: &quot;Vladimir.S&quot; &lt;svabox at gmail.com&gt;<br>&gt; To: Joe Groff &lt;jgroff at apple.com&gt;<br>&gt; Cc: swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0084: Allow trailing commas<br>&gt;         in parameter lists and tuples<br>&gt; Message-ID: &lt;d487fba4-581b-2c76-145e-b7b79477b395 at gmail.com&gt;<br>&gt; Content-Type: text/plain; charset=utf-8; format=flowed<br>&gt;<br>&gt; Support. *all or nothing* :-)<br>&gt;<br>&gt; On 13.05.2016 20:29, Joe Groff via swift-evolution wrote:<br>&gt; &gt; I don&#39;t see why we need to micromanage the situations where trailing<br>&gt; commas are allowed. That&#39;s just unnecessarily increasing the fractal<br>&gt; complexity of the language. We&#39;ve delegated other style choices like<br>&gt; requiring `self.` or brace formatting to linters; why does this one need to<br>&gt; be legislated by the compiler?<br>&gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 9<br>&gt; Date: Fri, 13 May 2016 11:46:39 -0600<br>&gt; From: Erica Sadun &lt;erica at ericasadun.com&gt;<br>&gt; To: Joe Groff &lt;jgroff at apple.com&gt;<br>&gt; Cc: Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0084: Allow trailing commas<br>&gt;         in      parameter lists and tuples<br>&gt; Message-ID: &lt;A9ADA97C-DB1F-4556-A290-36BBE2357975 at ericasadun.com&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt;<br>&gt; &gt; On May 13, 2016, at 11:29 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On May 13, 2016, at 7:04 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On May 12, 2016, at 11:01 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt; On May 12, 2016, at 4:50 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt; You’re arguing that you want to read Swift code written like this?<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I wouldn&#39;t mind it.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I personally find that style repulsive :-) and I haven’t seen swift<br>&gt; code commonly doing it.  I’m not sure that we want to encourage it either.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; No. Tell us what you *really* think of the style. Don&#39;t hold back.[1]<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; If we were really concerned about this, a narrower way to solve the<br>&gt; same problem would be to allow a comma before the ), but *only* when there<br>&gt; is a newline between them.  I still don’t see why we’d want to encourage<br>&gt; this though.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I wouldn&#39;t object to this restriction. I cannot think of a situation<br>&gt; where using &quot;,)&quot; -- that is the comma adjacent to a closing parenthesis --<br>&gt; makes sense for any reason previously enumerated in support of this<br>&gt; proposal.<br>&gt; &gt;<br>&gt; &gt; I don&#39;t see why we need to micromanage the situations where trailing<br>&gt; commas are allowed. That&#39;s just unnecessarily increasing the fractal<br>&gt; complexity of the language. We&#39;ve delegated other style choices like<br>&gt; requiring `self.` or brace formatting to linters; why does this one need to<br>&gt; be legislated by the compiler?<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt;<br>&gt; Mostly because I&#39;m trying to play nice and get Chris to reconsider. I&#39;d<br>&gt; like to get the feature, I&#39;m willing to compromise on the technicalities.<br>&gt; Having it would make my coding life significantly easier and if a little<br>&gt; micromanagement is involved, I&#39;m not terribly fussed. When I need trailing<br>&gt; commas, it&#39;s always at the ends of lines anyway.<br>&gt;<br>&gt; But since I don&#39;t want to undercut you, so I&#39;d much prefer to step back<br>&gt; and defer to your judgement on this.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/5fa7ba20/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 10<br>&gt; Date: Fri, 13 May 2016 19:50:38 +0200<br>&gt; From: Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt;<br>&gt; To: swift-evolution at swift.org<br>&gt; Subject: Re: [swift-evolution] [Pitch] merge types and protocols back<br>&gt;         together with type&lt;Type, Protocol, ...&gt;<br>&gt; Message-ID: &lt;etPan.573613ee.5477cc5d.6ab2 at DevAndArtist.fritz.box&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; &#39;struct&lt;&gt;&#39; does seem redundant unless it becomes subtypeable. If you want<br>&gt; a struct which conforms to several protocols, protocol&lt;&gt; already covers<br>&gt; this.<br>&gt; I think this is not correct. Lets check this example:<br>&gt;<br>&gt; func foo(value: SomeProtocol) {<br>&gt;<br>&gt;     if let a = value as? struct&lt;StructA, SomeProtocol&gt; { /* do something<br>&gt; with a */ }<br>&gt;<br>&gt;     else if let b = value as? struct&lt;StructB, SomeProtocol&gt; { /* do<br>&gt; something with b */ }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; In this scenario you’ll be able to access properties and functions from<br>&gt; `StructA` or `StructB` which might not be covered by `SomeProtocol`.<br>&gt; Everything is merged nicely into one instance. But you are right it depends<br>&gt; on the use-case.<br>&gt;<br>&gt;<br>&gt; There is no need to include the protocol here.   Just do this:<br>&gt;<br>&gt; if let a = value as? StructA { use a }<br>&gt;<br>&gt; Whoops, I forgot that this will do the trick. I apologize for any<br>&gt; confusion here, you are totally right.<br>&gt;<br>&gt; That been said, do we really need `type&lt;&gt;` aka. `all&lt;&gt;` for value types? I<br>&gt; need to rethink this part of the proposal. Is there any use-case where we<br>&gt; would need this (any scenario for the future Swift version also counts)?<br>&gt;<br>&gt; If we had `all&lt;&gt;` in Swift already for extendable reference types and one<br>&gt; day structs would become subtypeable, this wouldn’t be a huge problem to<br>&gt; upgrade `all&lt;&gt;` for structs I guess.<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/b51d2c61/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 11<br>&gt; Date: Fri, 13 May 2016 11:48:30 -0600<br>&gt; From: Erica Sadun &lt;erica at ericasadun.com&gt;<br>&gt; To: Cole Campbell &lt;cole.m.campbell at icloud.com&gt;<br>&gt; Cc: Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] Removing &quot;_ in&quot; from empty closures<br>&gt; Message-ID: &lt;2F3D83D2-2785-4778-B7C1-91B0EF2381D1 at ericasadun.com&gt;<br>&gt; Content-Type: text/plain; charset=us-ascii<br>&gt;<br>&gt; On May 13, 2016, at 11:14 AM, Cole Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; +1. In general, I think we should allow implicit arguments, without<br>&gt; requiring the closure to use all the implicit $n variables like we do<br>&gt; today. These should all be valid:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; let _: () -&gt; () = {}<br>&gt; &gt;&gt; let _: (Int) -&gt; () = {}<br>&gt; &gt;&gt; let _: (Int, Int) -&gt; Int = { 5 }<br>&gt; &gt;&gt; let _: (Int, Int) -&gt; Int = { $0 }<br>&gt; &gt;&gt; let _: (Int, Int) -&gt; Int = { $1 }<br>&gt; &gt;<br>&gt; &gt; +1. This would be excellent.<br>&gt;<br>&gt; +1. Good riddance to bad code baggage.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 12<br>&gt; Date: Fri, 13 May 2016 21:03:19 +0300<br>&gt; From: Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt;<br>&gt; To: Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; Cc: swift-evolution at swift.org<br>&gt; Subject: Re: [swift-evolution] [swift-evolution-announce] [Review]<br>&gt;         SE-0041:        Updating Protocol       Naming Conventions for<br>&gt; Conversions<br>&gt; Message-ID: &lt;1AAA5C78-073C-4515-80E6-AC64888FC725 at iki.fi&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; Taking the suggested changes into account, here&#39;s my review.<br>&gt;<br>&gt; 1) +1, I think this is a reasonable way for naming this family of<br>&gt; protocols.<br>&gt;<br>&gt; 2) The problem isn&#39;t huge, but I think it&#39;s worth fixing. So far, the<br>&gt; naming of stdlib protocols has been somewhat inconsistent in this regard.<br>&gt;<br>&gt; 3) I&#39;ve used other languages &amp; stdlibs with similar naming schemes,<br>&gt; although none of them used the words &quot;initializable&quot; and &quot;representable&quot;.<br>&gt; Common alternatives have been word compositions involving expressions such<br>&gt; as &quot;convertible&quot;, &quot;from&quot;, &quot;to&quot;, &quot;bi(jective)&quot;, &quot;can build&quot;. However, I<br>&gt; think &quot;init&quot; is so central in Swift that the use of &quot;Initializable&quot; is well<br>&gt; justified. &quot;Representable&quot; is slightly less so but self-explanatory IMO,<br>&gt; and more so than &quot;convertible&quot; which could be understood either or both<br>&gt; ways.<br>&gt;<br>&gt; 4) Quick reading.<br>&gt;<br>&gt; — Pyry<br>&gt;<br>&gt; &gt; On 13 May 2016, Matthew Johnson wrote:<br>&gt; &gt;<br>&gt; &gt; While the community feedback on our SE-0041 proposal &quot;Updating Protocol<br>&gt; Naming Conventions for Conversions&quot; (<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt; &lt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt;)<br>&gt; has been positive about the need to establish conventions, feedback has<br>&gt; been mixed to negative with regard to the specific conventions suggested in<br>&gt; the proposal.<br>&gt; &gt;<br>&gt; &gt; With that in mind, Erica and I have been working on refactoring those<br>&gt; recommendations. We put together the following update and invite the<br>&gt; community to bikeshed further with us. We hope this offers the Swift core<br>&gt; team the flexibility to accept our proposal &quot;with revision&quot; if an<br>&gt; alternative garners more support. With luck, we&#39;ll reach a naming consensus<br>&gt; during the review period.<br>&gt; &gt;<br>&gt; &gt; UPDATED APPROACH<br>&gt; &gt;<br>&gt; &gt; Our updated approach focuses on the two most important conventions: one<br>&gt; for initialization and one for representation.<br>&gt; &gt;<br>&gt; &gt; 1. `Initializable`<br>&gt; &gt;<br>&gt; &gt; `Initializable` designates protocols that convert *from* a type or from<br>&gt; an associated type mentioned in the protocol name, such as the current<br>&gt; `&lt;Type&gt;LiteralConvertible` protocols.  This convention would include member<br>&gt; requirements for initializers, factory methods, and any other way an<br>&gt; instance can be imported to establish a new instance of the conforming type.<br>&gt; &gt;<br>&gt; &gt; For example, conforming to `ArrayLiteralInitializable` would allow a set<br>&gt; to be created with `Set(arrayLiteral: &lt;some array&gt;)` and `var set: Set&lt;T&gt; =<br>&gt; []`.<br>&gt; &gt;<br>&gt; &gt; This phrase replaces the `Creatable` form from our original proposal.<br>&gt; &gt;<br>&gt; &gt; 2. `Representable`<br>&gt; &gt;<br>&gt; &gt; `Representable` designates protocols whose primary purpose is to project<br>&gt; *to* a type or associated type mentioned in the protocol name.  Items in<br>&gt; the standard library that would be subsumed into this naming include<br>&gt; `CustomStringConvertible`, `CustomDebugStringConvertible`, and<br>&gt; `RawRepresentable`, which we imagine would become<br>&gt; `CustomStringRepresentable`, `CustomDebugStringRepresentable`, and (as<br>&gt; current) `RawRepresentable`.<br>&gt; &gt;<br>&gt; &gt; This second category groups together the `Convertible` and<br>&gt; `Representable` categories from our original proposal and is predicated on<br>&gt; the feedback from the design team review. The `Representable` designation<br>&gt; does not promise bidirectional conversion although some `Representable`<br>&gt; protocols may include requirements to allow attempted initialization *from*<br>&gt; the type of the representation. Doing so falls outside the naming contract<br>&gt; we are proposing.<br>&gt; &gt;<br>&gt; &gt; FUTURE DIRECTIONS<br>&gt; &gt;<br>&gt; &gt; We did not include a third category for bidirectional conversion in this<br>&gt; update. We recognize that style of contract is rare in Swift. Lossless<br>&gt; conversion does not appear in the standard library outside of<br>&gt; `RawRepresentable`, which we agreed was better covered by `Representable`.<br>&gt; If such a convention is needed or adopted, we reserve the `Isomorphic`<br>&gt; designation for future use.<br>&gt; &gt;<br>&gt; &gt; Sent from my iPad<br>&gt;<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/b88c8136/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 13<br>&gt; Date: Fri, 13 May 2016 12:09:01 -0600<br>&gt; From: Eric Miller &lt;hi at simple.gy&gt;<br>&gt; To: swift-evolution at swift.org<br>&gt; Subject: [swift-evolution] Could enums have their rawValue type<br>&gt;         inferred?<br>&gt; Message-ID:<br>&gt;         &lt;CAJaDgbjTQMo8keEa=<br>&gt; 4+neJp_yPgRpi3rdsSnrAMmwJbonLQEKQ at mail.gmail.com&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; This might open a larger can of worms than I imagine, but what do you folks<br>&gt; think about using the `rawValue` of an enum when that rawValue is a fit for<br>&gt; the expected type?<br>&gt;<br>&gt; Use case.<br>&gt;<br>&gt; I&#39;m making an animation facade, and it has some speed presets:<br>&gt;<br>&gt; class Animate {<br>&gt;   enum transitionSpeed: NSTimeInterval {<br>&gt;     case fast = 0.15<br>&gt;     case slow = 0.5<br>&gt;   }<br>&gt;   enum ambientAnimationSpeed: NSTimeInterval {<br>&gt;     case fast = 1.0<br>&gt;     case slow = 5.0<br>&gt;   }<br>&gt;   ...<br>&gt; }<br>&gt;<br>&gt; I did them with static variables at first but that made the call site<br>&gt; verbose. Compare:<br>&gt;<br>&gt; Animate.fadeIn(view, withSpeed: Animate.cfg.transitionFast)<br>&gt; Animate.fadeIn(view, withSpeed: .fast)<br>&gt;<br>&gt; So, I like the enum approach better, but my library code has to use<br>&gt; `rawValue` to do anything with the actual value, of course:<br>&gt;<br>&gt; static func fadeIn(view: UIView?, withSpeed duration:transitionSpeed =<br>&gt; .fast) {<br>&gt;   ...<br>&gt;   UIView.animateWithDuration(duration.rawValue, animations: { })<br>&gt; }<br>&gt;<br>&gt; It&#39;s not a serious issue, but the code is more clear and beautiful if it<br>&gt; has just myIntent, rather than myIntent.rawValue.<br>&gt;<br>&gt; I&#39;ve hit this issue when modeling other things, such as:<br>&gt;<br>&gt; * server fault codes<br>&gt; * HTTP status codes<br>&gt; * Currency codes<br>&gt; * Days of the week<br>&gt;<br>&gt; Would it be appropriate to &quot;autocast&quot; to the rawValue of the enum when the<br>&gt; rawValue&#39;s Type matches the type expectation of the API? Or would this<br>&gt; introduce a bunch of type system uncertainty?<br>&gt;<br>&gt; Maybe this could be implemented as a protocol? It feels almost like the<br>&gt; convenience of `CustomStringConvertible`&#39;s `description` property.<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/c7c83773/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 14<br>&gt; Date: Fri, 13 May 2016 20:11:12 +0200<br>&gt; From: Nicola Salmoria &lt;nicola.salmoria at gmail.com&gt;<br>&gt; To: &quot;Vladimir.S&quot; &lt;svabox at gmail.com&gt;<br>&gt; Cc: swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Draft] Introducing StaticSelf,  an<br>&gt;         Invariant Self<br>&gt; Message-ID:<br>&gt;         &lt;CAMZYVZgE+gLH4w=xOaLa6DDP3KW3S6rggU8V5W=<br>&gt; Ts93izu6T8g at mail.gmail.com&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; On Fri, May 13, 2016 at 12:55 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; &gt; I&#39;m not convinced by this example.<br>&gt; &gt;<br>&gt; &gt; Probably my &amp; Matthew&#39;s previous discussion in `[swift-evolution] [RFC]<br>&gt; &gt; #Self` topic will help you. I was trying there to find out (in primitive<br>&gt; &gt; examples) what Matthew is trying to achive with this `-&gt;StaticSelf` in<br>&gt; &gt; protocol.<br>&gt; &gt;<br>&gt; &gt; In two words - he wants to achieve requirement &#39;return Self class or any<br>&gt; &gt; of base classes&#39;, as current `-&gt;Self` requires &#39;strictly return Self<br>&gt; class&#39;<br>&gt; &gt;<br>&gt;<br>&gt; I think I understand what the request is, but I&#39;m not sure if it&#39;s a<br>&gt; problem worth solving, and if this would be the right solution.<br>&gt;<br>&gt; Going back to the example, let&#39;s say you have the requested<br>&gt;<br>&gt; protocol Fooable {<br>&gt;     func foo() -&gt; StaticSelf<br>&gt; }<br>&gt;<br>&gt; class A: Fooable {<br>&gt;     func foo() -&gt; A { return A() }<br>&gt; }<br>&gt;<br>&gt; class B: A {<br>&gt; }<br>&gt;<br>&gt; How would you use foo() in generic code?<br>&gt;<br>&gt; func bar&lt;T: Fooable&gt;(_ x: T) -&gt; X {<br>&gt;     return x.foo()<br>&gt; }<br>&gt;<br>&gt; What does bar() return? What do you put in place of X in its declaration?<br>&gt; You can&#39;t use T, you can&#39;t use T.StaticSelf. So what&#39;s the purpose of<br>&gt; having a protocol if you can&#39;t use it in generic code?<br>&gt;<br>&gt;<br>&gt; Nicola<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/f33b31ad/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 15<br>&gt; Date: Fri, 13 May 2016 12:08:22 -0600<br>&gt; From: Erica Sadun &lt;erica at ericasadun.com&gt;<br>&gt; To: Brent Royal-Gordon &lt;brent at architechies.com&gt;,        Chris Lattner<br>&gt;         &lt;clattner at apple.com&gt;<br>&gt; Cc: swift-evolution at swift.org<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0045: Add scan,<br>&gt;         prefix(while:), drop(while:), and iterate to the stdlib<br>&gt; Message-ID: &lt;1FC733A8-6BE7-45A0-9579-841AE52B5BA9 at ericasadun.com&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; On May 1, 2016, at 5:13 AM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; The proposal has been updated as per feedback from the core team (<br>&gt; https://github.com/apple/swift-evolution/pull/275). This includes<br>&gt; removing some last vestiges of Swift 2 naming as well as replacing<br>&gt; `iterate(_:apply:)` with an overloaded function `unfold(_:applying:)`.<br>&gt; &gt;<br>&gt; &gt; The proposal says this:<br>&gt; &gt;<br>&gt; &gt;       public func unfold&lt;T, State&gt;(_ initialState: State, applying:<br>&gt; State -&gt; (T, State)?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt; &gt;       public func unfold&lt;T&gt;(_ initialElement: T, apply: T -&gt; T) -&gt;<br>&gt; UnfoldSequence&lt;T&gt;<br>&gt; &gt;<br>&gt; &gt; However, the comment implies that the second one should instead be this:<br>&gt; &gt;<br>&gt; &gt;       public func unfold&lt;T&gt;(_ initialElement: T, applying: T -&gt; T?) -&gt;<br>&gt; UnfoldSequence&lt;T&gt;<br>&gt; &gt;<br>&gt; &gt; I&#39;m not sure I like having these be overloaded on only the return type<br>&gt; of the closure. Maybe we could do something like this?<br>&gt; &gt;<br>&gt; &gt;       public func unfold&lt;T, State&gt;(fromState initialState: State,<br>&gt; applying: State -&gt; (T, State)?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt; &gt;       public func unfold&lt;T&gt;(fromFirst initialElement: T, apply: T -&gt; T)<br>&gt; -&gt; UnfoldSequence&lt;T&gt;<br>&gt; &gt;<br>&gt; &gt; That way you&#39;re calling either `unfold(fromState:applying:)` or<br>&gt; `unfold(fromFirst:applying:)`. (Some further bikeshedding might be needed<br>&gt; here—it&#39;s late and I&#39;m tired.)<br>&gt;<br>&gt; I really don&#39;t want to see this discussion die as I have a vested interest<br>&gt; in getting this functionality into<br>&gt; Swift 3. So let me suggest that<br>&gt;<br>&gt; `sequence(_:, next:) -&gt; AdHocSequence`<br>&gt;<br>&gt; might be a Swift acceptable solution.  We&#39;re not going to see fold/unfold<br>&gt; pair happen. It&#39;s a given that<br>&gt; `reduce` is a fixed point in Swift space and `sequence` well describes<br>&gt; what this should be doing.<br>&gt;<br>&gt; So is it possible to push forward with `sequence`, whose only negative<br>&gt; seems to be that it&#39;s not as well<br>&gt; loved as `unfold`?<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/07e13f7a/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 16<br>&gt; Date: Fri, 13 May 2016 21:16:03 +0300<br>&gt; From: Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt;<br>&gt; To: Erica Sadun &lt;erica at ericasadun.com&gt;<br>&gt; Cc: swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0075: Adding a Build<br>&gt;         Configuration Import Test<br>&gt; Message-ID: &lt;95C947FC-C523-41C3-A385-44AFC469124E at iki.fi&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; &gt; On 13 May 2016, Erica Sadun wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; As per Pyry’s feedback, you could add a version:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; #if import Frobnication(&lt;1.7.3) // &lt;- Only added version constraint<br>&gt; here.<br>&gt; &gt;&gt; extension Knob : Frobnicatable { ... }<br>&gt; &gt;&gt; #endif<br>&gt; &gt;<br>&gt; &gt; I have no problem with this but would need to defer to the build and<br>&gt; language people to determine whether that&#39;s practical in today&#39;s Swift.<br>&gt; Right now, there&#39;s a major-version mention in build packages but I&#39;m not<br>&gt; sure whether that information then propagates in a usable way. If it&#39;s<br>&gt; possible, then yes, I&#39;d rather add it in the initial design than as a later<br>&gt; addition and I can extend Pyry&#39;s suggestion in &quot;Future Directions&quot;.<br>&gt;<br>&gt; I already gave my +1 on the original proposal and if `canImport` is indeed<br>&gt; easiest to implement we should get it going now.<br>&gt;<br>&gt; The `#if import Foo` blocks and conditional imports with version checks<br>&gt; can easily be added at a later time without much complication or breakage,<br>&gt; AFAICT. Good if you can include those in the &quot;Future Directions&quot; section.<br>&gt;<br>&gt; &gt; p.s. Also on my Swift Bucket list: &quot;import as&quot;.<br>&gt;<br>&gt; Splendid! I&#39;d already forgotten about qualified imports and renaming!<br>&gt; Those would be welcome additions too.<br>&gt;<br>&gt; — Pyry<br>&gt;<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/9e170f04/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 17<br>&gt; Date: Fri, 13 May 2016 11:19:08 -0700<br>&gt; From: Max Moiseev &lt;moiseev at apple.com&gt;<br>&gt; To: swift-evolution at swift.org<br>&gt; Subject: [swift-evolution] [draft-proposal] allow access to the<br>&gt;         underlying      collection of a slice<br>&gt; Message-ID: &lt;D32AAB4D-D21D-428D-AE52-BF0566DD825D at apple.com&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; Hi everyone!<br>&gt;<br>&gt; Here is the proposal to allow access to the underlying collections of<br>&gt; slices. Existing API of slice types is very minimal and as such prevents<br>&gt; possible optimizations. Exposing the base collection via a public readonly<br>&gt; property will make such optimizations possible.<br>&gt;<br>&gt; Max<br>&gt;<br>&gt; Adding a public base property to slices<br>&gt;<br>&gt; Proposal: SE-NNNN<br>&gt; Author(s): Max Moiseev &lt;https://github.com/moiseev&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt;<br>&gt; Slice types provided by the standard library &lt;<br>&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/Slice.swift.gyb&gt;<br>&gt; should allow public readonly access to their base collections to make<br>&gt; efficient implementations of protocol requirements possible in conforming<br>&gt; types.<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; The MutableCollection protocol conformance requires providing an<br>&gt; implementation of the following subscript:<br>&gt;<br>&gt; subscript(bounds: Range&lt;Index&gt;) -&gt; SubSequence { get set }<br>&gt; If the collection chooses to use one of a variety of slice types from the<br>&gt; standard library as its SubSequence, the default implementation of a setter<br>&gt; for this subscript will use the algorithm provided by the<br>&gt; _writeBackMutableSlice &lt;<br>&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/WriteBackMutableSlice.swift&gt;<br>&gt; function. This approach is fine for forward collections. It is quite<br>&gt; possible, however, that the most efficient implementation of this setter<br>&gt; would be to simply call the memcpy function. Unfortunately, slice API does<br>&gt; not provide any way to reach to the underlying base collection, even though<br>&gt; reference to it is stored in an internal property.<br>&gt;<br>&gt; Proposed solution<br>&gt;<br>&gt; We propose to export a public readonly property base, that will enable<br>&gt; optimizations mentioned above. Here is how MutableRandomAccessSlice<br>&gt; definition would look like:<br>&gt;<br>&gt; public struct MutableRandomAccessSlice&lt;<br>&gt;   Base : protocol&lt;RandomAccessIndexable, MutableIndexable&gt;<br>&gt; &gt; : RandomAccessCollection, MutableCollection {<br>&gt;<br>&gt;   /// The underlying collection of the slice<br>&gt;   public var base: Base { get }<br>&gt; }<br>&gt; The same change is applicable to both mutable and immutable slice types.<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; The proposed change is purely additive and does not affect existing code.<br>&gt;<br>&gt; Alternatives considered<br>&gt;<br>&gt; Alternative for immutable slices would be to simply rename the already<br>&gt; read-only _base property to base and make it public, but this way the<br>&gt; change is not purely additive and might cause some damage inside the<br>&gt; standard library code.<br>&gt;<br>&gt;<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/13768551/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 18<br>&gt; Date: Fri, 13 May 2016 11:19:23 -0700<br>&gt; From: Joe Groff &lt;jgroff at apple.com&gt;<br>&gt; To: Erica Sadun &lt;erica at ericasadun.com&gt;<br>&gt; Cc: Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0084: Allow trailing commas<br>&gt;         in parameter lists and tuples<br>&gt; Message-ID: &lt;B61AB4F9-B20C-4B6E-A205-9D465ABB2C2A at apple.com&gt;<br>&gt; Content-Type: text/plain; charset=utf-8<br>&gt;<br>&gt;<br>&gt; &gt; On May 13, 2016, at 10:46 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On May 13, 2016, at 11:29 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On May 13, 2016, at 7:04 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On May 12, 2016, at 11:01 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt; On May 12, 2016, at 4:50 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; You’re arguing that you want to read Swift code written like this?<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I wouldn&#39;t mind it.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I personally find that style repulsive :-) and I haven’t seen swift<br>&gt; code commonly doing it.  I’m not sure that we want to encourage it either.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; No. Tell us what you *really* think of the style. Don&#39;t hold back.[1]<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; If we were really concerned about this, a narrower way to solve the<br>&gt; same problem would be to allow a comma before the ), but *only* when there<br>&gt; is a newline between them.  I still don’t see why we’d want to encourage<br>&gt; this though.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I wouldn&#39;t object to this restriction. I cannot think of a situation<br>&gt; where using &quot;,)&quot; -- that is the comma adjacent to a closing parenthesis --<br>&gt; makes sense for any reason previously enumerated in support of this<br>&gt; proposal.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I don&#39;t see why we need to micromanage the situations where trailing<br>&gt; commas are allowed. That&#39;s just unnecessarily increasing the fractal<br>&gt; complexity of the language. We&#39;ve delegated other style choices like<br>&gt; requiring `self.` or brace formatting to linters; why does this one need to<br>&gt; be legislated by the compiler?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Joe<br>&gt; &gt;<br>&gt; &gt; Mostly because I&#39;m trying to play nice and get Chris to reconsider. I&#39;d<br>&gt; like to get the feature, I&#39;m willing to compromise on the technicalities.<br>&gt;<br>&gt; Sorry, I replied to you, but my comments were more directed toward Chris.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 19<br>&gt; Date: Fri, 13 May 2016 12:15:38 -0600<br>&gt; From: Erica Sadun &lt;erica at ericasadun.com&gt;<br>&gt; To: Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;,<br>&gt;         alex at kempgen.de<br>&gt; Subject: [swift-evolution] Interspersing guard let with guard boolean<br>&gt; Message-ID: &lt;A0645FEA-B666-4E3D-8DDC-8406CE86E813 at ericasadun.com&gt;<br>&gt; Content-Type: text/plain; charset=us-ascii<br>&gt;<br>&gt; Is there a technical reason that Swift cannot be expanded to allow<br>&gt; arbitrary mixes of conditional binding and boolean assertions within a<br>&gt; single compound guard statement?<br>&gt;<br>&gt; Thanks, -- E<br>&gt;<br>&gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 20<br>&gt; Date: Fri, 13 May 2016 11:23:44 -0700<br>&gt; From: Joe Groff &lt;jgroff at apple.com&gt;<br>&gt; To: Erica Sadun &lt;erica at ericasadun.com&gt;<br>&gt; Cc: Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;,<br>&gt;         alex at kempgen.de<br>&gt; Subject: Re: [swift-evolution] Interspersing guard let with guard<br>&gt;         boolean<br>&gt; Message-ID: &lt;2F004069-682D-4C14-B9C4-158ACA735D0F at apple.com&gt;<br>&gt; Content-Type: text/plain; charset=us-ascii<br>&gt;<br>&gt;<br>&gt; &gt; On May 13, 2016, at 11:15 AM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Is there a technical reason that Swift cannot be expanded to allow<br>&gt; arbitrary mixes of conditional binding and boolean assertions within a<br>&gt; single compound guard statement?<br>&gt;<br>&gt; No. You already can, we just have the somewhat strange rule that to<br>&gt; separate `guard` conditions uses `,` before optional or pattern conditions,<br>&gt; but `where` before boolean conditions:<br>&gt;<br>&gt;         guard x == 0,<br>&gt;           let y = optional where<br>&gt;           z == 2 {<br>&gt;         }<br>&gt;<br>&gt; There&#39;s no technical reason we couldn&#39;t accept either &#39;where&#39; or &#39;,&#39;<br>&gt; consistently.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 21<br>&gt; Date: Fri, 13 May 2016 12:27:16 -0600<br>&gt; From: Erica Sadun &lt;erica at ericasadun.com&gt;<br>&gt; To: Joe Groff &lt;jgroff at apple.com&gt;, mike at mikeash.com<br>&gt; Cc: Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;,<br>&gt;         alex at kempgen.de<br>&gt; Subject: Re: [swift-evolution] Interspersing guard let with guard<br>&gt;         boolean<br>&gt; Message-ID: &lt;9E13E3A9-3FAC-4D14-B3E6-B0D4054069B0 at ericasadun.com&gt;<br>&gt; Content-Type: text/plain; charset=us-ascii<br>&gt;<br>&gt;<br>&gt; &gt; On May 13, 2016, at 12:23 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On May 13, 2016, at 11:15 AM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Is there a technical reason that Swift cannot be expanded to allow<br>&gt; arbitrary mixes of conditional binding and boolean assertions within a<br>&gt; single compound guard statement?<br>&gt; &gt;<br>&gt; &gt; No. You already can, we just have the somewhat strange rule that to<br>&gt; separate `guard` conditions uses `,` before optional or pattern conditions,<br>&gt; but `where` before boolean conditions:<br>&gt; &gt;<br>&gt; &gt;       guard x == 0,<br>&gt; &gt;         let y = optional where<br>&gt; &gt;         z == 2 {<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt; There&#39;s no technical reason we couldn&#39;t accept either &#39;where&#39; or &#39;,&#39;<br>&gt; consistently.<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt;<br>&gt; Is it worth a proposal to allow both, for when the where clauses don&#39;t<br>&gt; have to be semantically tied to the conditional binding?<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; /ccing  in Mike Ash so he can gloat<br>&gt;<br>&gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 22<br>&gt; Date: Fri, 13 May 2016 21:34:58 +0300<br>&gt; From: &quot;Vladimir.S&quot; &lt;svabox at gmail.com&gt;<br>&gt; To: Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt;<br>&gt; Cc: swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Pitch] merge types and protocols back<br>&gt;         together with type&lt;Type, Protocol, ...&gt;<br>&gt; Message-ID: &lt;66427699-ae82-5140-ac5f-7f97ce14cc4a at gmail.com&gt;<br>&gt; Content-Type: text/plain; charset=utf-8; format=flowed<br>&gt;<br>&gt; Hmm..<br>&gt;<br>&gt; What about such synthetic scenario:<br>&gt;<br>&gt; at the moment of writing our code we have:<br>&gt;<br>&gt; public protocol MyProtocol {<br>&gt;    func foo()<br>&gt; }<br>&gt;<br>&gt; public struct StructA:MyProtocol {<br>&gt;    func foo()<br>&gt; }<br>&gt;<br>&gt; public struct StructB:MyProtocol {<br>&gt;    func foo()<br>&gt; }<br>&gt;<br>&gt; and have<br>&gt;<br>&gt; public protocol ExtraProtocol1 {<br>&gt;    func bar()<br>&gt; }<br>&gt;<br>&gt; public protocol ExtraProtocol2 {<br>&gt;    func blort()<br>&gt; }<br>&gt;<br>&gt; then we actually can have such code:<br>&gt;<br>&gt; func f(p: MyProtocol) {<br>&gt;    if let a = p as? struct&lt;StructA, ExtraProtocol1&gt; {<br>&gt;       a.foo()<br>&gt;       a.bar()<br>&gt;    }<br>&gt;    else<br>&gt;    if let b = p as? struct&lt;StructB, ExtraProtocol2&gt; {<br>&gt;       b.foo()<br>&gt;       b.blort()<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; as we can(as example) expect that in 3rd party code someone will do:<br>&gt;<br>&gt; extension StructA: ExtraProtocol1 {<br>&gt;    func bar() {}<br>&gt; }<br>&gt;<br>&gt; extension StructB: ExtraProtocol2 {<br>&gt;    func blort() {}<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 13.05.2016 20:50, Adrian Zubarev via swift-evolution wrote:<br>&gt; &gt;&gt;         &#39;struct&lt;&gt;&#39; does seem redundant unless it becomes subtypeable. If<br>&gt; &gt;&gt;         you want a struct which conforms to several protocols,<br>&gt; protocol&lt;&gt;<br>&gt; &gt;&gt;         already covers this.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;     I think this is not correct. Lets check this example:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;     func foo(value: SomeProtocol) {<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;         if let a = value as? struct&lt;StructA, SomeProtocol&gt; { /* do<br>&gt; &gt;&gt;     something with a */ }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;         else if let b = value as? struct&lt;StructB, SomeProtocol&gt; { /* do<br>&gt; &gt;&gt;     something with b */ }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;     }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;     In this scenario you’ll be able to access properties and functions<br>&gt; &gt;&gt;     from `StructA` or `StructB` which might not be covered by<br>&gt; &gt;&gt;     `SomeProtocol`. Everything is merged nicely into one instance. But<br>&gt; &gt;&gt;     you are right it depends on the use-case.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; There is no need to include the protocol here.   Just do this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; if let a = value as? StructA { use a }<br>&gt; &gt;&gt;<br>&gt; &gt; Whoops, I forgot that this will do the trick. I apologize for any<br>&gt; confusion<br>&gt; &gt; here, you are totally right.<br>&gt; &gt;<br>&gt; &gt; That been said, do we really need `type&lt;&gt;` aka. `all&lt;&gt;` for value types?<br>&gt; I<br>&gt; &gt; need to rethink this part of the proposal. Is there any use-case where we<br>&gt; &gt; would need this (any scenario for the future Swift version also counts)?<br>&gt; &gt;<br>&gt; &gt; If we had `all&lt;&gt;` in Swift already for extendable reference types and one<br>&gt; &gt; day structs would become subtypeable, this wouldn’t be a huge problem to<br>&gt; &gt; upgrade `all&lt;&gt;` for structs I guess.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Adrian Zubarev<br>&gt; &gt; Sent with Airmail<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 23<br>&gt; Date: Fri, 13 May 2016 11:36:55 -0700<br>&gt; From: Matt Wright &lt;mww at apple.com&gt;<br>&gt; To: swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0088: Modernize libdispatch<br>&gt;         for     Swift 3 naming conventions<br>&gt; Message-ID: &lt;178CA219-60D2-4A43-96F3-86BA02DB7CBA at apple.com&gt;<br>&gt; Content-Type: text/plain; charset=utf-8<br>&gt;<br>&gt; [Apologies for the weird threading, I missed the original email to the<br>&gt; list so I can’t reply to it directly]<br>&gt;<br>&gt; I just wanted to let the list know that I updated proposal SE-0088 to fix<br>&gt; the typos and include a more complete listing of the Dispatch module after<br>&gt; the transformations in the proposal have been applied. Additionally, I’ve<br>&gt; been keeping up with some of the feedback in this review thread and looking<br>&gt; to see which ones would be best applied to the proposal. Though it should<br>&gt; be made clear, this particular update only covers fixing the<br>&gt; inconsistencies in my original proposal and providing a more complete<br>&gt; overview of the module layout.<br>&gt;<br>&gt; Similar to the changes in Foundation that are proposed on swift-evolution,<br>&gt; I don’t expect all of the changes in libdispatch will be able to go through<br>&gt; this process. As this is a large change (and, hopefully, a step forwards)<br>&gt; to libdispatch I believe it is important to bring it to the swift-evolution<br>&gt; list and take away your feedback for inclusion in future iterations of the<br>&gt; module.<br>&gt;<br>&gt; Thanks again for your continued feedback,<br>&gt; Matt<br>&gt;<br>&gt; &gt; On Tue, May 10, 2016 at 9:39 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Hello Swift community,<br>&gt; &gt;<br>&gt; &gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming<br>&gt; conventions&quot; begins now and runs through May 17. The proposal is available<br>&gt; here:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt; &gt;<br>&gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt; &gt;<br>&gt; &gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt; &gt;<br>&gt; &gt; What goes into a review?<br>&gt; &gt;<br>&gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt; &gt;<br>&gt; &gt;         * What is your evaluation of the proposal?<br>&gt; &gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt; &gt;         * Does this proposal fit well with the feel and direction of<br>&gt; Swift?<br>&gt; &gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt; &gt;         * How much effort did you put into your review? A glance, a<br>&gt; quick reading, or an in-depth study?<br>&gt; &gt;<br>&gt; &gt; More information about the Swift evolution process is available at<br>&gt; &gt;<br>&gt; &gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; &gt;<br>&gt; &gt; Thank you,<br>&gt; &gt;<br>&gt; &gt; -Chris Lattner<br>&gt; &gt; Review Manager<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 24<br>&gt; Date: Fri, 13 May 2016 14:06:23 -0500<br>&gt; From: Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; To: Nicola Salmoria &lt;nicola.salmoria at gmail.com&gt;<br>&gt; Cc: swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Draft] Introducing StaticSelf,  an<br>&gt;         Invariant Self<br>&gt; Message-ID: &lt;6A1CC61D-1AB6-48C9-88E8-210DB4B85C89 at anandabits.com&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt;<br>&gt; &gt; On May 13, 2016, at 1:11 PM, Nicola Salmoria via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Fri, May 13, 2016 at 12:55 PM, Vladimir.S &lt;svabox at gmail.com &lt;mailto:<br>&gt; svabox at gmail.com&gt;&gt; wrote:<br>&gt; &gt; &gt; I&#39;m not convinced by this example.<br>&gt; &gt;<br>&gt; &gt; Probably my &amp; Matthew&#39;s previous discussion in `[swift-evolution] [RFC]<br>&gt; #Self` topic will help you. I was trying there to find out (in primitive<br>&gt; examples) what Matthew is trying to achive with this `-&gt;StaticSelf` in<br>&gt; protocol.<br>&gt; &gt;<br>&gt; &gt; In two words - he wants to achieve requirement &#39;return Self class or any<br>&gt; of base classes&#39;, as current `-&gt;Self` requires &#39;strictly return Self class&#39;<br>&gt; &gt;<br>&gt; &gt; I think I understand what the request is, but I&#39;m not sure if it&#39;s a<br>&gt; problem worth solving, and if this would be the right solution.<br>&gt; &gt;<br>&gt; &gt; Going back to the example, let&#39;s say you have the requested<br>&gt; &gt;<br>&gt; &gt; protocol Fooable {<br>&gt; &gt;     func foo() -&gt; StaticSelf<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; class A: Fooable {<br>&gt; &gt;     func foo() -&gt; A { return A() }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; class B: A {<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; How would you use foo() in generic code?<br>&gt; &gt;<br>&gt; &gt; func bar&lt;T: Fooable&gt;(_ x: T) -&gt; X {<br>&gt; &gt;     return x.foo()<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; What does bar() return? What do you put in place of X in its declaration?<br>&gt; &gt; You can&#39;t use T, you can&#39;t use T.StaticSelf. So what&#39;s the purpose of<br>&gt; having a protocol if you can&#39;t use it in generic code?<br>&gt;<br>&gt; This is a good question.  Thank you very much for providing a concrete<br>&gt; example along with the question.<br>&gt;<br>&gt; Let’s look at an example of what some of us have in mind:<br>&gt;<br>&gt; protocol StringCreatable {<br>&gt;     static func createWithString(s: String) -&gt; StaticSelf<br>&gt; }<br>&gt;<br>&gt; extension NSURL: StringCreatable {<br>&gt;     static func createWithString(s: String) -&gt; StaticSelf {<br>&gt;         // ...<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; func foo&lt;Result: StringCreatable&gt;(s: String) -&gt; Result {<br>&gt;     return Result.createWithString(s: s)<br>&gt; }<br>&gt;<br>&gt; Obviously this will not work properly because we are not guaranteed that<br>&gt; `createWithString` returns Result (that is only possible if the return type<br>&gt; is Self).  We would have to do the following:<br>&gt;<br>&gt; protocol StringCreatable {<br>&gt;     typealias ConformingType = StaticSelf<br>&gt;     static func createWithString(s: String) -&gt; StaticSelf<br>&gt; }<br>&gt;<br>&gt; func foo&lt;Result: StringCreatable where Result.ConformingType == Result&gt;(s:<br>&gt; String) -&gt; Result {<br>&gt;     return Result.createWithString(s: s)<br>&gt; }<br>&gt;<br>&gt; This requires same type constraints.  I believe that is coming as part of<br>&gt; “completing generics”.<br>&gt;<br>&gt; However, it also raises a question: if the conformance afforded to<br>&gt; subclasses can’t actually be used in a useful manner they probably<br>&gt; shouldn’t have that conformance in the first place.  If the conformance<br>&gt; isn’t inherited then we don’t need StaticSelf at all (we can just use Self<br>&gt; and still conform the visible class of a class cluster).  This is the point<br>&gt; Joe has been making all along.  Working through the example has helped me<br>&gt; understand this point of view better.<br>&gt;<br>&gt; I wonder if anyone has any other examples where subclass conformance would<br>&gt; actually be useful.  If so, please share.  Those who are supporting this<br>&gt; proposal: how do you envision using StaticSelf in your code?  What are some<br>&gt; examples where you have had trouble due to the current limitations of the<br>&gt; language?<br>&gt;<br>&gt; -Matthew<br>&gt;<br>&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Nicola<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/faddc0a1/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 25<br>&gt; Date: Fri, 13 May 2016 12:07:29 -0700<br>&gt; From: Kevin Ballard &lt;kevin at sb.org&gt;<br>&gt; To: Erica Sadun &lt;erica at ericasadun.com&gt;, &quot;Brent Royal-Gordon&quot;<br>&gt;         &lt;brent at architechies.com&gt;,       Chris Lattner &lt;clattner at apple.com&gt;<br>&gt; Cc: swift-evolution at swift.org<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0045: Add scan,<br>&gt;         prefix(while:), drop(while:), and iterate to the stdlib<br>&gt; Message-ID:<br>&gt;         &lt;1463166449.928503.607214225.00CC8144 at webmail.messagingengine.com&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; On Fri, May 13, 2016, at 11:08 AM, Erica Sadun wrote:<br>&gt; &gt; On May 1, 2016, at 5:13 AM, Brent Royal-Gordon via swift-evolution<br>&gt; &lt;swift-<br>&gt; &gt; evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; The proposal has been updated as per feedback from the core team<br>&gt; &gt;&gt;&gt; (https://github.com/apple/swift-evolution/pull/275). This includes<br>&gt; &gt;&gt;&gt; removing some last vestiges of Swift 2 naming as well as replacing<br>&gt; &gt;&gt;&gt; `iterate(_:apply:)` with an overloaded function<br>&gt; &gt;&gt;&gt; `unfold(_:applying:)`.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The proposal says this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;  public func unfold&lt;T, State&gt;(_ initialState: State, applying: State<br>&gt; &gt;&gt;  -&gt; (T, State)?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt; &gt;&gt;  public func unfold&lt;T&gt;(_ initialElement: T, apply: T -&gt; T) -&gt;<br>&gt; &gt;&gt;  UnfoldSequence&lt;T&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; However, the comment implies that the second one should instead<br>&gt; &gt;&gt; be this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;  public func unfold&lt;T&gt;(_ initialElement: T, applying: T -&gt; T?) -&gt;<br>&gt; &gt;&gt;  UnfoldSequence&lt;T&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;m not sure I like having these be overloaded on only the return<br>&gt; &gt;&gt; type of the closure. Maybe we could do something like this?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;  public func unfold&lt;T, State&gt;(fromState initialState: State,<br>&gt; &gt;&gt;  applying: State -&gt; (T, State)?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt; &gt;&gt;  public func unfold&lt;T&gt;(fromFirst initialElement: T, apply: T -&gt; T) -&gt;<br>&gt; &gt;&gt;  UnfoldSequence&lt;T&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; That way you&#39;re calling either `unfold(fromState:applying:)` or<br>&gt; &gt;&gt; `unfold(fromFirst:applying:)`. (Some further bikeshedding might be<br>&gt; &gt;&gt; needed here—it&#39;s late and I&#39;m tired.)<br>&gt; &gt;<br>&gt; &gt; I really don&#39;t want to see this discussion die as I have a vested<br>&gt; &gt; interest in getting this functionality into<br>&gt; &gt; Swift 3. So let me suggest that<br>&gt; &gt;<br>&gt; &gt; `sequence(_:, next:) -&gt; AdHocSequence`<br>&gt; &gt;<br>&gt; &gt; might be a Swift acceptable solution.  We&#39;re not going to see<br>&gt; &gt; fold/unfold pair happen. It&#39;s a given that<br>&gt; &gt; `reduce` is a fixed point in Swift space and `sequence` well describes<br>&gt; &gt; what this should be doing.<br>&gt; &gt;<br>&gt; &gt; So is it possible to push forward with `sequence`, whose only negative<br>&gt; &gt; seems to be that it&#39;s not as well<br>&gt; &gt; loved as `unfold`?<br>&gt;<br>&gt; I do like `sequence`, though I&#39;m not sold on the name AdHocSequence<br>&gt; (just from that name it&#39;s hard to figure out what it does). An<br>&gt; alternative is `expand`, which is nice because it pairs with `reduce`,<br>&gt; but it&#39;s less obvious that it produces a sequence and the name isn&#39;t as<br>&gt; good with the stateful version.<br>&gt;<br>&gt; As for return type name, we could go ahead and use UnfoldSequence&lt;T&gt;<br>&gt; anyway even though the function isn&#39;t named `unfold`, because this name<br>&gt; will make sense to people who do know what unfold is, and I&#39;m not<br>&gt; convinced we can have a meaningful name for people who don&#39;t (since<br>&gt; SequenceSequence is too silly).<br>&gt;<br>&gt; So given that, I&#39;ll suggest the following:<br>&gt;<br>&gt; func sequence&lt;T&gt;(initial: T, next: T -&gt; T?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt; func sequence&lt;T, State&gt;(state: State, next: (inout State) -&gt; T?) -&gt;<br>&gt; UnfoldSequence&lt;T&gt;<br>&gt;<br>&gt; I&#39;m suggesting `sequence(initial:next:)` instead of the previously-<br>&gt; suggested `sequence(from:applying:)` because the term &quot;from&quot; could<br>&gt; equally well mean the first element or the state, whereas &quot;initial&quot;<br>&gt; should make it more obvious that this value is the first element of the<br>&gt; resulting sequence. And I&#39;m using &quot;next&quot; as suggested by Erica because<br>&gt; the function does return the next element, and it&#39;s similar to the<br>&gt; IteratorProtocol method. I&#39;ve also chosen to change the stateful version<br>&gt; to use an inout parameter, as previously suggested, because it&#39;s<br>&gt; equivalent to the State -&gt; (T, State)? in functionality but is less<br>&gt; likely to produce unwanted COW copies.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/6087ca3b/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 26<br>&gt; Date: Fri, 13 May 2016 21:14:44 +0200<br>&gt; From: Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt;<br>&gt; To: swift-evolution at swift.org<br>&gt; Subject: Re: [swift-evolution] [Pitch] merge types and protocols back<br>&gt;         together with type&lt;Type, Protocol, ...&gt;<br>&gt; Message-ID: &lt;etPan.573627a4.578126f6.6ab2 at DevAndArtist.fritz.box&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; As we can(as example) expect that in 3rd party code someone will do:<br>&gt;<br>&gt; extension StructA: ExtraProtocol1 {<br>&gt; func bar() {}<br>&gt; }<br>&gt;<br>&gt; extension StructB: ExtraProtocol2 {<br>&gt; func blort() {}<br>&gt; }<br>&gt;<br>&gt; Can we really do that? I mean, I thought about that myself but I came to<br>&gt; the conclusion that this scenario is like: I was to lazy to couple this<br>&gt; structs to my library protocols, will you do that for me?<br>&gt;<br>&gt; Sure one could think that this protocols might be optional but the `f(p:<br>&gt; MyProtocol)` function will cover this scenario.<br>&gt;<br>&gt; Another interesting side-effect `struct&lt;&gt;`, `class&lt;&gt;` and `enum&lt;&gt;` will<br>&gt; allow us to do is to distinguish between value and reference types for<br>&gt; generics. I tried this differentiation types with protocols like<br>&gt; `AnyReference` and `AnyValue` in another topic before (Should we rename<br>&gt; &quot;class&quot; when referring to protocol conformance?), but I kinda like this new<br>&gt; approach.<br>&gt;<br>&gt; Here is what I mean in detail:<br>&gt;<br>&gt; protocol SomeProtocol /* we can’t constraint it to value types at the<br>&gt; moment, only `class`es works */ {}<br>&gt;<br>&gt; func foo&lt;T&gt;(value: struct&lt;T, SomeProtocol&gt;) { /* do some work */ }<br>&gt;<br>&gt; This function is pretty neat. (1) You can force the library user to create<br>&gt; a struct with conformance to `SomeProtocol`. (2) This approach will accept<br>&gt; any struct which conforms to that protocol.<br>&gt;<br>&gt; As I said in the protocol comment above protocols can only be constrained<br>&gt; to classes at the moment, and this might change in the future. If we also<br>&gt; had some sort of things for generics so the function from above might have<br>&gt; looked like this:<br>&gt;<br>&gt; func foo&lt;T: struct where T: SomeProtocol&gt;(value: T) {}<br>&gt;<br>&gt; But it seems that such a thing won’t ever happen to Swift.<br>&gt;<br>&gt; Basically `struct&lt;&gt;`, `class&lt;&gt;` and `enum&lt;&gt;` will just enable this for us.<br>&gt; `all&lt;&gt;` would accept any type at its first element.<br>&gt;<br>&gt; func foo&lt;T /* add more constraints here */ &gt;(value: all&lt;T, SomeProtocol&gt;)<br>&gt; { /* T could be a reference type or value type */ }<br>&gt;<br>&gt; That been said, `all&lt;&gt;` could replace `protocol&lt;&gt;` where it is composed<br>&gt; from protocols. `all&lt;&gt;` can only be used as a generic constraints if the<br>&gt; first element is a protocol or a reference type.<br>&gt;<br>&gt; @Matthew: isn’t this somehow a step towards (generic) `PureValue` types?<br>&gt;<br>&gt; struct A&lt;T&gt; {<br>&gt;<br>&gt;     var value: struct&lt;T&gt; // if we drop the strict rule of at least one<br>&gt; protocols<br>&gt; }<br>&gt;<br>&gt; How does it sound to you?<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 13. Mai 2016 bei 20:34:59, Vladimir.S (svabox at gmail.com) schrieb:<br>&gt;<br>&gt; Hmm..<br>&gt;<br>&gt; What about such synthetic scenario:<br>&gt;<br>&gt; at the moment of writing our code we have:<br>&gt;<br>&gt; public protocol MyProtocol {<br>&gt; func foo()<br>&gt; }<br>&gt;<br>&gt; public struct StructA:MyProtocol {<br>&gt; func foo()<br>&gt; }<br>&gt;<br>&gt; public struct StructB:MyProtocol {<br>&gt; func foo()<br>&gt; }<br>&gt;<br>&gt; and have<br>&gt;<br>&gt; public protocol ExtraProtocol1 {<br>&gt; func bar()<br>&gt; }<br>&gt;<br>&gt; public protocol ExtraProtocol2 {<br>&gt; func blort()<br>&gt; }<br>&gt;<br>&gt; then we actually can have such code:<br>&gt;<br>&gt; func f(p: MyProtocol) {<br>&gt; if let a = p as? struct&lt;StructA, ExtraProtocol1&gt; {<br>&gt; a.foo()<br>&gt; a.bar()<br>&gt; }<br>&gt; else<br>&gt; if let b = p as? struct&lt;StructB, ExtraProtocol2&gt; {<br>&gt; b.foo()<br>&gt; b.blort()<br>&gt; }<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 13.05.2016 20:50, Adrian Zubarev via swift-evolution wrote:<br>&gt; &gt;&gt; &#39;struct&lt;&gt;&#39; does seem redundant unless it becomes subtypeable. If<br>&gt; &gt;&gt; you want a struct which conforms to several protocols, protocol&lt;&gt;<br>&gt; &gt;&gt; already covers this.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I think this is not correct. Lets check this example:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func foo(value: SomeProtocol) {<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; if let a = value as? struct&lt;StructA, SomeProtocol&gt; { /* do<br>&gt; &gt;&gt; something with a */ }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; else if let b = value as? struct&lt;StructB, SomeProtocol&gt; { /* do<br>&gt; &gt;&gt; something with b */ }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; In this scenario you’ll be able to access properties and functions<br>&gt; &gt;&gt; from `StructA` or `StructB` which might not be covered by<br>&gt; &gt;&gt; `SomeProtocol`. Everything is merged nicely into one instance. But<br>&gt; &gt;&gt; you are right it depends on the use-case.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; There is no need to include the protocol here. Just do this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; if let a = value as? StructA { use a }<br>&gt; &gt;&gt;<br>&gt; &gt; Whoops, I forgot that this will do the trick. I apologize for any<br>&gt; confusion<br>&gt; &gt; here, you are totally right.<br>&gt; &gt;<br>&gt; &gt; That been said, do we really need `type&lt;&gt;` aka. `all&lt;&gt;` for value types?<br>&gt; I<br>&gt; &gt; need to rethink this part of the proposal. Is there any use-case where we<br>&gt; &gt; would need this (any scenario for the future Swift version also counts)?<br>&gt; &gt;<br>&gt; &gt; If we had `all&lt;&gt;` in Swift already for extendable reference types and one<br>&gt; &gt; day structs would become subtypeable, this wouldn’t be a huge problem to<br>&gt; &gt; upgrade `all&lt;&gt;` for structs I guess.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Adrian Zubarev<br>&gt; &gt; Sent with Airmail<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/167979a4/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 27<br>&gt; Date: Fri, 13 May 2016 19:24:31 +0000<br>&gt; From: Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; To: Matt Wright &lt;mww at apple.com&gt;<br>&gt; Cc: swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0088: Modernize libdispatch<br>&gt;         for Swift 3 naming conventions<br>&gt; Message-ID:<br>&gt;         &lt;<br>&gt; CADcs6kNjyOgbBWs-4Ho8Mc2882DRKHJbAhOrvk1sggb-_7audA at mail.gmail.com&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; This looks great. Thanks for revising. I&#39;m now a +1 on this.<br>&gt;<br>&gt; A couple more minor suggestions:<br>&gt;<br>&gt; - Consider renaming setTimer(...) to resetTimer() or just reset(), or<br>&gt; something similar?<br>&gt;<br>&gt; - Consider making Semaphore&#39;s wait() throw an error, rather than returning<br>&gt; non-zero, in the event of a timeout. Most common uses will be &quot;try!<br>&gt; wait()&quot;. Or you could have waitForever() be a separate, non-throwing<br>&gt; function.<br>&gt;<br>&gt; Jacob Bandes-Storch<br>&gt;<br>&gt; On Fri, May 13, 2016 at 11:36 AM, Matt Wright via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; [Apologies for the weird threading, I missed the original email to the<br>&gt; &gt; list so I can’t reply to it directly]<br>&gt; &gt;<br>&gt; &gt; I just wanted to let the list know that I updated proposal SE-0088 to fix<br>&gt; &gt; the typos and include a more complete listing of the Dispatch module<br>&gt; after<br>&gt; &gt; the transformations in the proposal have been applied. Additionally, I’ve<br>&gt; &gt; been keeping up with some of the feedback in this review thread and<br>&gt; looking<br>&gt; &gt; to see which ones would be best applied to the proposal. Though it should<br>&gt; &gt; be made clear, this particular update only covers fixing the<br>&gt; &gt; inconsistencies in my original proposal and providing a more complete<br>&gt; &gt; overview of the module layout.<br>&gt; &gt;<br>&gt; &gt; Similar to the changes in Foundation that are proposed on<br>&gt; swift-evolution,<br>&gt; &gt; I don’t expect all of the changes in libdispatch will be able to go<br>&gt; through<br>&gt; &gt; this process. As this is a large change (and, hopefully, a step forwards)<br>&gt; &gt; to libdispatch I believe it is important to bring it to the<br>&gt; swift-evolution<br>&gt; &gt; list and take away your feedback for inclusion in future iterations of<br>&gt; the<br>&gt; &gt; module.<br>&gt; &gt;<br>&gt; &gt; Thanks again for your continued feedback,<br>&gt; &gt; Matt<br>&gt; &gt;<br>&gt; &gt; &gt; On Tue, May 10, 2016 at 9:39 PM, Chris Lattner via swift-evolution &lt;<br>&gt; &gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; &gt; Hello Swift community,<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming<br>&gt; &gt; conventions&quot; begins now and runs through May 17. The proposal is<br>&gt; available<br>&gt; &gt; here:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt; &gt; reviews should be sent to the swift-evolution mailing list at<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt; &gt; review manager.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; What goes into a review?<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt; &gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; &gt; When writing your review, here are some questions you might want to<br>&gt; answer<br>&gt; &gt; in your review:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;         * What is your evaluation of the proposal?<br>&gt; &gt; &gt;         * Is the problem being addressed significant enough to warrant<br>&gt; a<br>&gt; &gt; change to Swift?<br>&gt; &gt; &gt;         * Does this proposal fit well with the feel and direction of<br>&gt; &gt; Swift?<br>&gt; &gt; &gt;         * If you have used other languages or libraries with a similar<br>&gt; &gt; feature, how do you feel that this proposal compares to those?<br>&gt; &gt; &gt;         * How much effort did you put into your review? A glance, a<br>&gt; &gt; quick reading, or an in-depth study?<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; More information about the Swift evolution process is available at<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Thank you,<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; -Chris Lattner<br>&gt; &gt; &gt; Review Manager<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/25063811/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 28<br>&gt; Date: Fri, 13 May 2016 19:29:06 +0000<br>&gt; From: Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;<br>&gt; To: Matt Wright &lt;mww at apple.com&gt;, swift-evolution<br>&gt;         &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0088: Modernize libdispatch<br>&gt;         for Swift 3 naming conventions<br>&gt; Message-ID:<br>&gt;         &lt;<br>&gt; CAGY80umC-paivBJ3Ci3MPp_j+Ex_QrYe7LFNmN+2TYMB4J53wQ at mail.gmail.com&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; More nits:<br>&gt;<br>&gt; setHighWater(highWater:) and its ilk should should probably be<br>&gt; setHighWater(_:) and so on (I include among these setInterval(interval:),<br>&gt; setTargetQueue(queue:), etc.)<br>&gt;<br>&gt; Similarly, in terms of conforming to Swift guidelines, I notice many<br>&gt; instances where labels repeat the parameter type, especially<br>&gt; DispatchWalltime. For instance, setTimer(walltime: DispatchWalltime,<br>&gt; leeway: DispatchTimeInterval)--not sure what to suggest here other than<br>&gt; point out that the first label is redundant.<br>&gt; On Fri, May 13, 2016 at 11:36 Matt Wright via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; [Apologies for the weird threading, I missed the original email to the<br>&gt; &gt; list so I can’t reply to it directly]<br>&gt; &gt;<br>&gt; &gt; I just wanted to let the list know that I updated proposal SE-0088 to fix<br>&gt; &gt; the typos and include a more complete listing of the Dispatch module<br>&gt; after<br>&gt; &gt; the transformations in the proposal have been applied. Additionally, I’ve<br>&gt; &gt; been keeping up with some of the feedback in this review thread and<br>&gt; looking<br>&gt; &gt; to see which ones would be best applied to the proposal. Though it should<br>&gt; &gt; be made clear, this particular update only covers fixing the<br>&gt; &gt; inconsistencies in my original proposal and providing a more complete<br>&gt; &gt; overview of the module layout.<br>&gt; &gt;<br>&gt; &gt; Similar to the changes in Foundation that are proposed on<br>&gt; swift-evolution,<br>&gt; &gt; I don’t expect all of the changes in libdispatch will be able to go<br>&gt; through<br>&gt; &gt; this process. As this is a large change (and, hopefully, a step forwards)<br>&gt; &gt; to libdispatch I believe it is important to bring it to the<br>&gt; swift-evolution<br>&gt; &gt; list and take away your feedback for inclusion in future iterations of<br>&gt; the<br>&gt; &gt; module.<br>&gt; &gt;<br>&gt; &gt; Thanks again for your continued feedback,<br>&gt; &gt; Matt<br>&gt; &gt;<br>&gt; &gt; &gt; On Tue, May 10, 2016 at 9:39 PM, Chris Lattner via swift-evolution &lt;<br>&gt; &gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; &gt; Hello Swift community,<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming<br>&gt; &gt; conventions&quot; begins now and runs through May 17. The proposal is<br>&gt; available<br>&gt; &gt; here:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt; &gt; reviews should be sent to the swift-evolution mailing list at<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt; &gt; review manager.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; What goes into a review?<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt; &gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; &gt; When writing your review, here are some questions you might want to<br>&gt; answer<br>&gt; &gt; in your review:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;         * What is your evaluation of the proposal?<br>&gt; &gt; &gt;         * Is the problem being addressed significant enough to warrant<br>&gt; a<br>&gt; &gt; change to Swift?<br>&gt; &gt; &gt;         * Does this proposal fit well with the feel and direction of<br>&gt; &gt; Swift?<br>&gt; &gt; &gt;         * If you have used other languages or libraries with a similar<br>&gt; &gt; feature, how do you feel that this proposal compares to those?<br>&gt; &gt; &gt;         * How much effort did you put into your review? A glance, a<br>&gt; &gt; quick reading, or an in-depth study?<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; More information about the Swift evolution process is available at<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Thank you,<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; -Chris Lattner<br>&gt; &gt; &gt; Review Manager<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/4644df43/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 29<br>&gt; Date: Fri, 13 May 2016 12:44:59 -0700<br>&gt; From: Matt Wright &lt;mww at apple.com&gt;<br>&gt; To: Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;<br>&gt; Cc: swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0088: Modernize libdispatch<br>&gt;         for     Swift 3 naming conventions<br>&gt; Message-ID: &lt;96D2038A-FB04-47FF-B7CF-85923D50AD2A at apple.com&gt;<br>&gt; Content-Type: text/plain; charset=utf-8<br>&gt;<br>&gt;<br>&gt; &gt; On May 13, 2016, at 12:29 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; More nits:<br>&gt; &gt;<br>&gt; &gt; setHighWater(highWater:) and its ilk should should probably be<br>&gt; setHighWater(_:) and so on (I include among these setInterval(interval:),<br>&gt; setTargetQueue(queue:), etc.)<br>&gt;<br>&gt; I suspect setHighWater and setLowWater can probably become<br>&gt; setLimit(highWater:) setLimit(lowWater:). setTargetQueue -&gt;<br>&gt; setTarget(queue:) seems like an obvious change but something about it<br>&gt; doesn’t sit particularly right with me. I will think about this further.<br>&gt; There were both very useful bits feedback on these names though, thank you!<br>&gt;<br>&gt; &gt; Similarly, in terms of conforming to Swift guidelines, I notice many<br>&gt; instances where labels repeat the parameter type, especially<br>&gt; DispatchWalltime. For instance, setTimer(walltime: DispatchWalltime,<br>&gt; leeway: DispatchTimeInterval)--not sure what to suggest here other than<br>&gt; point out that the first label is redundant.<br>&gt;<br>&gt; setTimer() in particular has a setTimer(start:,…) and<br>&gt; setTimer(walltime:,…) that are distinct, perhaps the latter could be<br>&gt; `walltimeStart:`. While there was an earlier argument for removing Walltime<br>&gt; as a typed concept, we believe it is advantageous to keep different “types”<br>&gt; of time as separate distinct Swift types in the module.<br>&gt;<br>&gt; &gt; On Fri, May 13, 2016 at 11:36 Matt Wright via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; [Apologies for the weird threading, I missed the original email to the<br>&gt; list so I can’t reply to it directly]<br>&gt; &gt;<br>&gt; &gt; I just wanted to let the list know that I updated proposal SE-0088 to<br>&gt; fix the typos and include a more complete listing of the Dispatch module<br>&gt; after the transformations in the proposal have been applied. Additionally,<br>&gt; I’ve been keeping up with some of the feedback in this review thread and<br>&gt; looking to see which ones would be best applied to the proposal. Though it<br>&gt; should be made clear, this particular update only covers fixing the<br>&gt; inconsistencies in my original proposal and providing a more complete<br>&gt; overview of the module layout.<br>&gt; &gt;<br>&gt; &gt; Similar to the changes in Foundation that are proposed on<br>&gt; swift-evolution, I don’t expect all of the changes in libdispatch will be<br>&gt; able to go through this process. As this is a large change (and, hopefully,<br>&gt; a step forwards) to libdispatch I believe it is important to bring it to<br>&gt; the swift-evolution list and take away your feedback for inclusion in<br>&gt; future iterations of the module.<br>&gt; &gt;<br>&gt; &gt; Thanks again for your continued feedback,<br>&gt; &gt; Matt<br>&gt; &gt;<br>&gt; &gt; &gt; On Tue, May 10, 2016 at 9:39 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; &gt; Hello Swift community,<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming<br>&gt; conventions&quot; begins now and runs through May 17. The proposal is available<br>&gt; here:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; What goes into a review?<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;         * What is your evaluation of the proposal?<br>&gt; &gt; &gt;         * Is the problem being addressed significant enough to warrant<br>&gt; a change to Swift?<br>&gt; &gt; &gt;         * Does this proposal fit well with the feel and direction of<br>&gt; Swift?<br>&gt; &gt; &gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt; &gt; &gt;         * How much effort did you put into your review? A glance, a<br>&gt; quick reading, or an in-depth study?<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; More information about the Swift evolution process is available at<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Thank you,<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; -Chris Lattner<br>&gt; &gt; &gt; Review Manager<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 30<br>&gt; Date: Fri, 13 May 2016 12:51:34 -0700<br>&gt; From: Matt Wright &lt;mww at apple.com&gt;<br>&gt; To: Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; Cc: swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0088: Modernize libdispatch<br>&gt;         for     Swift 3 naming conventions<br>&gt; Message-ID: &lt;82629D20-E9E7-4B06-8E13-3ADBDB225099 at apple.com&gt;<br>&gt; Content-Type: text/plain; charset=utf-8<br>&gt;<br>&gt;<br>&gt; &gt; On May 13, 2016, at 12:24 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; This looks great. Thanks for revising. I&#39;m now a +1 on this.<br>&gt; &gt;<br>&gt; &gt; A couple more minor suggestions:<br>&gt; &gt;<br>&gt; &gt; - Consider renaming setTimer(...) to resetTimer() or just reset(), or<br>&gt; something similar?<br>&gt;<br>&gt; setTimer addresses both the initial setup as well as setting it again. I’m<br>&gt; not sure reset is a good name for it.<br>&gt;<br>&gt; &gt; - Consider making Semaphore&#39;s wait() throw an error, rather than<br>&gt; returning non-zero, in the event of a timeout. Most common uses will be<br>&gt; &quot;try! wait()&quot;. Or you could have waitForever() be a separate, non-throwing<br>&gt; function.<br>&gt;<br>&gt; Throwing an error here seems like a sensible improvement.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; Jacob Bandes-Storch<br>&gt; &gt;<br>&gt; &gt; On Fri, May 13, 2016 at 11:36 AM, Matt Wright via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; [Apologies for the weird threading, I missed the original email to the<br>&gt; list so I can’t reply to it directly]<br>&gt; &gt;<br>&gt; &gt; I just wanted to let the list know that I updated proposal SE-0088 to<br>&gt; fix the typos and include a more complete listing of the Dispatch module<br>&gt; after the transformations in the proposal have been applied. Additionally,<br>&gt; I’ve been keeping up with some of the feedback in this review thread and<br>&gt; looking to see which ones would be best applied to the proposal. Though it<br>&gt; should be made clear, this particular update only covers fixing the<br>&gt; inconsistencies in my original proposal and providing a more complete<br>&gt; overview of the module layout.<br>&gt; &gt;<br>&gt; &gt; Similar to the changes in Foundation that are proposed on<br>&gt; swift-evolution, I don’t expect all of the changes in libdispatch will be<br>&gt; able to go through this process. As this is a large change (and, hopefully,<br>&gt; a step forwards) to libdispatch I believe it is important to bring it to<br>&gt; the swift-evolution list and take away your feedback for inclusion in<br>&gt; future iterations of the module.<br>&gt; &gt;<br>&gt; &gt; Thanks again for your continued feedback,<br>&gt; &gt; Matt<br>&gt; &gt;<br>&gt; &gt; &gt; On Tue, May 10, 2016 at 9:39 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; &gt; Hello Swift community,<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming<br>&gt; conventions&quot; begins now and runs through May 17. The proposal is available<br>&gt; here:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; What goes into a review?<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;         * What is your evaluation of the proposal?<br>&gt; &gt; &gt;         * Is the problem being addressed significant enough to warrant<br>&gt; a change to Swift?<br>&gt; &gt; &gt;         * Does this proposal fit well with the feel and direction of<br>&gt; Swift?<br>&gt; &gt; &gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt; &gt; &gt;         * How much effort did you put into your review? A glance, a<br>&gt; quick reading, or an in-depth study?<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; More information about the Swift evolution process is available at<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Thank you,<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; -Chris Lattner<br>&gt; &gt; &gt; Review Manager<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 31<br>&gt; Date: Fri, 13 May 2016 16:58:06 -0300<br>&gt; From: Leonardo Pessoa &lt;me at lmpessoa.com&gt;<br>&gt; To: Swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] Could enums have their rawValue type<br>&gt;         inferred?<br>&gt; Message-ID:<br>&gt;         &lt;<br>&gt; CANTOS57wksMRzUAMq0ncf1QAd82vhudf21tnea6wHjhBOFr1PA at mail.gmail.com&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; Eric, I think I understood your proposal. If I may explain in other words<br>&gt; it would be &quot;to automatically cast rawValue when assigning an enum value to<br>&gt; a variable or argument of the type of the enum&#39;s raw value&quot;, am I right? I<br>&gt; think this would imply a little more inference and type checking rules from<br>&gt; the compiler and maybe even take a little longer to fully compile code. I&#39;m<br>&gt; not sure it&#39;s feasible but from your examples, I can see how it enhances<br>&gt; readability of the code, so I&#39;m +1 for it. My only concern is that you<br>&gt; would still need to fully declare the enum&#39;s name where the value of the<br>&gt; enum is used. Taking from your own example<br>&gt;<br>&gt;     Animate.fadeIn(view, withSpeed: .fast)<br>&gt;<br>&gt; couldn&#39;t be called that way if withSpeed expects and NSTimeInterval because<br>&gt; the compiler won&#39;t know whether you&#39;re refering to transitionSpeed or to<br>&gt; ambientAnimationSpeed. You would still have to call it like<br>&gt;<br>&gt;     Animate.fadeIn(view, withSpeed: transitionSpeed.fast)<br>&gt;<br>&gt; even if you had only one possible enum value over all declared enums<br>&gt; because that would still force the compiler to search for each value over<br>&gt; all known enums to define where the value you&#39;re using comes from and make<br>&gt; sure there are no two enums with the same value.<br>&gt;<br>&gt; Aside from that, I good with the idea.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 13 May 2016 at 15:09, Eric Miller via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; This might open a larger can of worms than I imagine, but what do you<br>&gt; &gt; folks think about using the `rawValue` of an enum when that rawValue is a<br>&gt; &gt; fit for the expected type?<br>&gt; &gt;<br>&gt; &gt; Use case.<br>&gt; &gt;<br>&gt; &gt; I&#39;m making an animation facade, and it has some speed presets:<br>&gt; &gt;<br>&gt; &gt; class Animate {<br>&gt; &gt;   enum transitionSpeed: NSTimeInterval {<br>&gt; &gt;     case fast = 0.15<br>&gt; &gt;     case slow = 0.5<br>&gt; &gt;   }<br>&gt; &gt;   enum ambientAnimationSpeed: NSTimeInterval {<br>&gt; &gt;     case fast = 1.0<br>&gt; &gt;     case slow = 5.0<br>&gt; &gt;   }<br>&gt; &gt;   ...<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; I did them with static variables at first but that made the call site<br>&gt; &gt; verbose. Compare:<br>&gt; &gt;<br>&gt; &gt; Animate.fadeIn(view, withSpeed: Animate.cfg.transitionFast)<br>&gt; &gt; Animate.fadeIn(view, withSpeed: .fast)<br>&gt; &gt;<br>&gt; &gt; So, I like the enum approach better, but my library code has to use<br>&gt; &gt; `rawValue` to do anything with the actual value, of course:<br>&gt; &gt;<br>&gt; &gt; static func fadeIn(view: UIView?, withSpeed duration:transitionSpeed =<br>&gt; &gt; .fast) {<br>&gt; &gt;   ...<br>&gt; &gt;   UIView.animateWithDuration(duration.rawValue, animations: { })<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; It&#39;s not a serious issue, but the code is more clear and beautiful if it<br>&gt; &gt; has just myIntent, rather than myIntent.rawValue.<br>&gt; &gt;<br>&gt; &gt; I&#39;ve hit this issue when modeling other things, such as:<br>&gt; &gt;<br>&gt; &gt; * server fault codes<br>&gt; &gt; * HTTP status codes<br>&gt; &gt; * Currency codes<br>&gt; &gt; * Days of the week<br>&gt; &gt;<br>&gt; &gt; Would it be appropriate to &quot;autocast&quot; to the rawValue of the enum when<br>&gt; the<br>&gt; &gt; rawValue&#39;s Type matches the type expectation of the API? Or would this<br>&gt; &gt; introduce a bunch of type system uncertainty?<br>&gt; &gt;<br>&gt; &gt; Maybe this could be implemented as a protocol? It feels almost like the<br>&gt; &gt; convenience of `CustomStringConvertible`&#39;s `description` property.<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/05a1d4c2/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 32<br>&gt; Date: Fri, 13 May 2016 13:02:44 -0700<br>&gt; From: Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; To: Erica Sadun &lt;erica at ericasadun.com&gt;<br>&gt; Cc: Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] Removing &quot;_ in&quot; from empty closures<br>&gt; Message-ID:<br>&gt;         &lt;CADcs6kPHDONJd_1zVkrEuLBJUT8QsxU_kDcdY=<br>&gt; hDf6EVOvEvnw at mail.gmail.com&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; +1, seems logical to me:<br>&gt;<br>&gt;     let x: [T] = []<br>&gt;     let x: [T:U] = [:]<br>&gt;     let x: T-&gt;() = {}<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; On Fri, May 13, 2016 at 10:48 AM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; On May 13, 2016, at 11:14 AM, Cole Campbell via swift-evolution &lt;<br>&gt; &gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;&gt; +1. In general, I think we should allow implicit arguments, without<br>&gt; &gt; requiring the closure to use all the implicit $n variables like we do<br>&gt; &gt; today. These should all be valid:<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; let _: () -&gt; () = {}<br>&gt; &gt; &gt;&gt; let _: (Int) -&gt; () = {}<br>&gt; &gt; &gt;&gt; let _: (Int, Int) -&gt; Int = { 5 }<br>&gt; &gt; &gt;&gt; let _: (Int, Int) -&gt; Int = { $0 }<br>&gt; &gt; &gt;&gt; let _: (Int, Int) -&gt; Int = { $1 }<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; +1. This would be excellent.<br>&gt; &gt;<br>&gt; &gt; +1. Good riddance to bad code baggage.<br>&gt; &gt;<br>&gt; &gt; -- E<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/1fc15c26/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 33<br>&gt; Date: Fri, 13 May 2016 15:06:18 -0500<br>&gt; From: Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; To: Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; Cc: Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] Removing &quot;_ in&quot; from empty closures<br>&gt; Message-ID: &lt;5F3F407C-B624-4596-9850-C8E059D5EE9A at anandabits.com&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; Is anyone planning to write a proposal for this?<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; &gt; On May 13, 2016, at 3:02 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; +1, seems logical to me:<br>&gt; &gt;<br>&gt; &gt;     let x: [T] = []<br>&gt; &gt;     let x: [T:U] = [:]<br>&gt; &gt;     let x: T-&gt;() = {}<br>&gt; &gt;<br>&gt; &gt; Jacob<br>&gt; &gt;<br>&gt; &gt;&gt; On Fri, May 13, 2016 at 10:48 AM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; On May 13, 2016, at 11:14 AM, Cole Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt; +1. In general, I think we should allow implicit arguments, without<br>&gt; requiring the closure to use all the implicit $n variables like we do<br>&gt; today. These should all be valid:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; let _: () -&gt; () = {}<br>&gt; &gt;&gt; &gt;&gt; let _: (Int) -&gt; () = {}<br>&gt; &gt;&gt; &gt;&gt; let _: (Int, Int) -&gt; Int = { 5 }<br>&gt; &gt;&gt; &gt;&gt; let _: (Int, Int) -&gt; Int = { $0 }<br>&gt; &gt;&gt; &gt;&gt; let _: (Int, Int) -&gt; Int = { $1 }<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; +1. This would be excellent.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; +1. Good riddance to bad code baggage.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -- E<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/edf1fd63/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 34<br>&gt; Date: Fri, 13 May 2016 13:12:10 -0700<br>&gt; From: Joe Groff &lt;jgroff at apple.com&gt;<br>&gt; To: Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; Cc: Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Draft] Introducing StaticSelf,  an<br>&gt;         Invariant Self<br>&gt; Message-ID: &lt;DA7FECEA-2E3D-45D9-BE6A-E95C859F5794 at apple.com&gt;<br>&gt; Content-Type: text/plain; charset=us-ascii<br>&gt;<br>&gt;<br>&gt; &gt; On May 13, 2016, at 9:06 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On May 13, 2016, at 10:55 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On May 13, 2016, at 8:18 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; When I write a class Base with non-final methods that return instances<br>&gt; of Base I can choose whether to state the return type as Self (covariant)<br>&gt; or Base (invariant, under this proposal StaticSelf would also be an<br>&gt; alternative way to state this).  If I choose to specify Base as the return<br>&gt; type derived classes *may* override the method but are not required to.<br>&gt; Further, if they *do* override the method they are allowed to choose<br>&gt; whether their implementation returns Base or Derived.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; `StaticSelf` requirements by themselves don&#39;t even save you from<br>&gt; covariance. If Base conforms to a protocol (with Self == Base), Derived<br>&gt; inherits that conformance and also conforms (with Self == Derived). If<br>&gt; `StaticSelf` always refers to the conforming type, then it must also be<br>&gt; bindable to Base and Derived, so a base class must still use a<br>&gt; covariant-returning method to satisfy the `StaticSelf` requirement.<br>&gt; &gt;<br>&gt; &gt; We are specifying that `StaticSelf` refers to the type that explicitly<br>&gt; declares conformance.  If a class inherits conformance it refers to the<br>&gt; base class which explicitly declared the conformance it is inheriting.<br>&gt;<br>&gt; That makes `StaticSelf` tricky to use in generic code. This would be<br>&gt; invalid:<br>&gt;<br>&gt; protocol Makable {<br>&gt;         static func make(value: Int) -&gt; StaticSelf<br>&gt; }<br>&gt;<br>&gt; func makeWithZero&lt;T: Fooable&gt;(x: Int) -&gt; T {<br>&gt;         return T.make(value: 0) // ERROR: T.StaticSelf may be a supertype<br>&gt; of T so isn&#39;t convertible to T<br>&gt; }<br>&gt;<br>&gt; `StaticSelf` in this model is effectively an associated type of the<br>&gt; protocol, with a `Self: StaticSelf` constraint (if that were supported).<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 35<br>&gt; Date: Fri, 13 May 2016 13:16:31 -0700<br>&gt; From: Joe Groff &lt;jgroff at apple.com&gt;<br>&gt; To: Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; Cc: Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] Removing &quot;_ in&quot; from empty closures<br>&gt; Message-ID: &lt;4D375D91-F148-4B2A-9E14-DE8FBBC41384 at apple.com&gt;<br>&gt; Content-Type: text/plain; charset=us-ascii<br>&gt;<br>&gt;<br>&gt; &gt; On May 13, 2016, at 1:06 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Is anyone planning to write a proposal for this?<br>&gt;<br>&gt; Sounds like you just signed up!<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; &gt; Sent from my iPhone<br>&gt; &gt;<br>&gt; &gt; On May 13, 2016, at 3:02 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; +1, seems logical to me:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;     let x: [T] = []<br>&gt; &gt;&gt;     let x: [T:U] = [:]<br>&gt; &gt;&gt;     let x: T-&gt;() = {}<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Jacob<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Fri, May 13, 2016 at 10:48 AM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; On May 13, 2016, at 11:14 AM, Cole Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt; +1. In general, I think we should allow implicit arguments, without<br>&gt; requiring the closure to use all the implicit $n variables like we do<br>&gt; today. These should all be valid:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; let _: () -&gt; () = {}<br>&gt; &gt;&gt; &gt;&gt; let _: (Int) -&gt; () = {}<br>&gt; &gt;&gt; &gt;&gt; let _: (Int, Int) -&gt; Int = { 5 }<br>&gt; &gt;&gt; &gt;&gt; let _: (Int, Int) -&gt; Int = { $0 }<br>&gt; &gt;&gt; &gt;&gt; let _: (Int, Int) -&gt; Int = { $1 }<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; +1. This would be excellent.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; +1. Good riddance to bad code baggage.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -- E<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 36<br>&gt; Date: Fri, 13 May 2016 17:07:44 -0400<br>&gt; From: John Siracusa &lt;siracusa at gmail.com&gt;<br>&gt; To: swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0084: Allow trailing commas<br>&gt;         in parameter lists and tuples<br>&gt; Message-ID:<br>&gt;         &lt;CAJu6bqtOxv6FFoZVuynvJjTdzQimv+gSc9ZNDJZWOjwzGKvd=<br>&gt; A at mail.gmail.com&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; Having used, more or less continuously for my 20 years as a professional<br>&gt; programmer, both a language that allows trailing commas and one that does<br>&gt; not, I come down pretty strongly on the side of allowing trailing commas<br>&gt; (for all the reasons already stated in this thread). If it means requiring<br>&gt; a newline after the last comma to make some people feel better about it, so<br>&gt; be it.<br>&gt;<br>&gt; -John<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Fri, May 13, 2016 at 1:46 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt;<br>&gt; &gt; On May 13, 2016, at 11:29 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On May 13, 2016, at 7:04 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On May 12, 2016, at 11:01 PM, Chris Lattner via swift-evolution &lt;<br>&gt; &gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On May 12, 2016, at 4:50 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; You’re arguing that you want to read Swift code written like this?<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; I wouldn&#39;t mind it.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; I personally find that style repulsive :-) and I haven’t seen swift code<br>&gt; &gt; commonly doing it.  I’m not sure that we want to encourage it either.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; No. Tell us what you *really* think of the style. Don&#39;t hold back.[1]<br>&gt; &gt;<br>&gt; &gt; If we were really concerned about this, a narrower way to solve the same<br>&gt; &gt; problem would be to allow a comma before the ), but *only* when there is<br>&gt; a<br>&gt; &gt; newline between them.  I still don’t see why we’d want to encourage this<br>&gt; &gt; though.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; I wouldn&#39;t object to this restriction. I cannot think of a situation<br>&gt; where<br>&gt; &gt; using &quot;,)&quot; -- that is the comma adjacent to a closing parenthesis --<br>&gt; makes<br>&gt; &gt; sense for any reason previously enumerated in support of this proposal.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; I don&#39;t see why we need to micromanage the situations where trailing<br>&gt; &gt; commas are allowed. That&#39;s just unnecessarily increasing the fractal<br>&gt; &gt; complexity of the language. We&#39;ve delegated other style choices like<br>&gt; &gt; requiring `self.` or brace formatting to linters; why does this one need<br>&gt; to<br>&gt; &gt; be legislated by the compiler?<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Mostly because I&#39;m trying to play nice and get Chris to reconsider. I&#39;d<br>&gt; &gt; like to get the feature, I&#39;m willing to compromise on the technicalities.<br>&gt; &gt; Having it would make my coding life significantly easier and if a little<br>&gt; &gt; micromanagement is involved, I&#39;m not terribly fussed. When I need<br>&gt; trailing<br>&gt; &gt; commas, it&#39;s always at the ends of lines anyway.<br>&gt; &gt;<br>&gt; &gt; But since I don&#39;t want to undercut you, so I&#39;d much prefer to step back<br>&gt; &gt; and defer to your judgement on this.<br>&gt; &gt;<br>&gt; &gt; -- E<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/ef8148fe/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 37<br>&gt; Date: Sat, 14 May 2016 00:16:16 +0300<br>&gt; From: &quot;Vladimir.S&quot; &lt;svabox at gmail.com&gt;<br>&gt; To: Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt;<br>&gt; Cc: swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Pitch] merge types and protocols back<br>&gt;         together with type&lt;Type, Protocol, ...&gt;<br>&gt; Message-ID: &lt;e4a00c9d-d327-1015-ab01-0ac4a689a114 at gmail.com&gt;<br>&gt; Content-Type: text/plain; charset=utf-8; format=flowed<br>&gt;<br>&gt; You asked for any example, I give it to you ;-)<br>&gt; (as I said, it is syntactical, just to show that such struct&lt;&gt; can be used<br>&gt; to test some struct for conforming to protocol, that was not conformed at<br>&gt; writing time)<br>&gt; Probably we can invent useful examples for this struct&lt;&gt; - but I don&#39;t<br>&gt; believe it will be introduced in Swift ;-)<br>&gt;<br>&gt; On 13.05.2016 22:14, Adrian Zubarev via swift-evolution wrote:<br>&gt; &gt; Can we really do that? I mean, I thought about that myself but I came to<br>&gt; &gt; the conclusion that this scenario is like: I was to lazy to couple this<br>&gt; &gt; structs to my library protocols, will you do that for me?<br>&gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 38<br>&gt; Date: Sat, 14 May 2016 00:46:23 +0300<br>&gt; From: &quot;Vladimir.S&quot; &lt;svabox at gmail.com&gt;<br>&gt; To: Joe Groff &lt;jgroff at apple.com&gt;<br>&gt; Cc: swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Draft] Introducing StaticSelf, an<br>&gt;         Invariant Self<br>&gt; Message-ID: &lt;cbc94f19-4c47-3859-fc27-05116dec50ae at gmail.com&gt;<br>&gt; Content-Type: text/plain; charset=utf-8; format=flowed<br>&gt;<br>&gt; Seems like -&gt;StaticSelf can actually only means returns the class for which<br>&gt; protocol conformance was applied first(in hierarchy). I.e. some<br>&gt; `-&gt;BaseSelf`.<br>&gt; But in this case we need a method to get this &#39;base&#39; class from protocol..<br>&gt;<br>&gt; something like(just pseudo code!):<br>&gt;<br>&gt; func makeWithZero&lt;T: Makable &gt;(x: Int) -&gt; Makable(T).FirstConformedClass {<br>&gt;         return T.make(value: 0)<br>&gt; }<br>&gt;<br>&gt; or<br>&gt;<br>&gt; func makeWithZero&lt;T: Makable &gt;(x: Int) -&gt; type&lt;T.make(value:)&gt; {<br>&gt;         return T.make(value: 0)<br>&gt; }<br>&gt;<br>&gt; I don&#39;t know if all of this makes sense at all ;-)<br>&gt;<br>&gt; On 13.05.2016 23:12, Joe Groff via swift-evolution wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On May 13, 2016, at 9:06 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On May 13, 2016, at 10:55 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On May 13, 2016, at 8:18 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; When I write a class Base with non-final methods that return<br>&gt; instances of Base I can choose whether to state the return type as Self<br>&gt; (covariant) or Base (invariant, under this proposal StaticSelf would also<br>&gt; be an alternative way to state this).  If I choose to specify Base as the<br>&gt; return type derived classes *may* override the method but are not required<br>&gt; to.  Further, if they *do* override the method they are allowed to choose<br>&gt; whether their implementation returns Base or Derived.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; `StaticSelf` requirements by themselves don&#39;t even save you from<br>&gt; covariance. If Base conforms to a protocol (with Self == Base), Derived<br>&gt; inherits that conformance and also conforms (with Self == Derived). If<br>&gt; `StaticSelf` always refers to the conforming type, then it must also be<br>&gt; bindable to Base and Derived, so a base class must still use a<br>&gt; covariant-returning method to satisfy the `StaticSelf` requirement.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; We are specifying that `StaticSelf` refers to the type that explicitly<br>&gt; declares conformance.  If a class inherits conformance it refers to the<br>&gt; base class which explicitly declared the conformance it is inheriting.<br>&gt; &gt;<br>&gt; &gt; That makes `StaticSelf` tricky to use in generic code. This would be<br>&gt; invalid:<br>&gt; &gt;<br>&gt; &gt; protocol Makable {<br>&gt; &gt;       static func make(value: Int) -&gt; StaticSelf<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; func makeWithZero&lt;T: Fooable&gt;(x: Int) -&gt; T {<br>&gt; &gt;       return T.make(value: 0) // ERROR: T.StaticSelf may be a supertype<br>&gt; of T so isn&#39;t convertible to T<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; `StaticSelf` in this model is effectively an associated type of the<br>&gt; protocol, with a `Self: StaticSelf` constraint (if that were supported).<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 39<br>&gt; Date: Fri, 13 May 2016 17:21:02 -0500<br>&gt; From: Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; To: Joe Groff &lt;jgroff at apple.com&gt;<br>&gt; Cc: Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] Removing &quot;_ in&quot; from empty closures<br>&gt; Message-ID: &lt;86DB53E1-6567-411B-8350-5C9794EEF39E at anandabits.com&gt;<br>&gt; Content-Type: text/plain;       charset=us-ascii<br>&gt;<br>&gt;<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; &gt; On May 13, 2016, at 3:16 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On May 13, 2016, at 1:06 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Is anyone planning to write a proposal for this?<br>&gt; &gt;<br>&gt; &gt; Sounds like you just signed up!<br>&gt;<br>&gt; Lol, sounds good.  Just don&#39;t want to duplicate efforts! :)<br>&gt;<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt;<br>&gt; &gt;&gt; Sent from my iPhone<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On May 13, 2016, at 3:02 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; +1, seems logical to me:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;    let x: [T] = []<br>&gt; &gt;&gt;&gt;    let x: [T:U] = [:]<br>&gt; &gt;&gt;&gt;    let x: T-&gt;() = {}<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Jacob<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Fri, May 13, 2016 at 10:48 AM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt; On May 13, 2016, at 11:14 AM, Cole Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; +1. In general, I think we should allow implicit arguments, without<br>&gt; requiring the closure to use all the implicit $n variables like we do<br>&gt; today. These should all be valid:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; let _: () -&gt; () = {}<br>&gt; &gt;&gt;&gt;&gt;&gt; let _: (Int) -&gt; () = {}<br>&gt; &gt;&gt;&gt;&gt;&gt; let _: (Int, Int) -&gt; Int = { 5 }<br>&gt; &gt;&gt;&gt;&gt;&gt; let _: (Int, Int) -&gt; Int = { $0 }<br>&gt; &gt;&gt;&gt;&gt;&gt; let _: (Int, Int) -&gt; Int = { $1 }<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; +1. This would be excellent.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; +1. Good riddance to bad code baggage.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; -- E<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 40<br>&gt; Date: Fri, 13 May 2016 16:46:31 -0700<br>&gt; From: Matt Wright &lt;mww at apple.com&gt;<br>&gt; To: plx &lt;plxswift at icloud.com&gt;<br>&gt; Cc: &quot;swift-evolution at swift.org&quot; &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0088: Modernize libdispatch<br>&gt;         for     Swift   3 naming conventions<br>&gt; Message-ID: &lt;7662E01E-8594-45E2-8ABE-2B9B22DA99F5 at apple.com&gt;<br>&gt; Content-Type: text/plain; charset=utf-8<br>&gt;<br>&gt;<br>&gt; &gt; On May 13, 2016, at 9:29 AM, plx via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt;      * What is your evaluation of the proposal?<br>&gt; &gt;<br>&gt; &gt; +1 conceptually, some quibbles.<br>&gt; &gt;<br>&gt; &gt; I agree with a few others that `synchronously` and `asynchronously`<br>&gt; aren’t ideal; `dispatchSynchronously` or `dispatchSync` (or `performSync`<br>&gt; or `performSynchronously`) all seem more-appropriate.<br>&gt; &gt;<br>&gt; &gt; I understand the impetus behind having fewer core methods, but IMHO the<br>&gt; `dispatch_barrier_sync` and `dispatch_barrier_async` calls ought to have<br>&gt; direct equivalents here (even if they are just sodlib-supplied conveniences<br>&gt; that call through to the unified method).<br>&gt;<br>&gt; I don’t see having barrier as separate methods as a particularly good fit<br>&gt; for Swift. Given that there are other options surrounding how a block<br>&gt; operates when it is executed, it makes more sense as default parameters to<br>&gt; the same methods. This avoids having to have variants of the block<br>&gt; submission methods for both barrier, QoS, both, etc.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; I also don’t see `dispatch_apply` here anywhere; intentional? Ideally<br>&gt; it’d be @noescape, but handling `throw` / `rethrow` for that function in<br>&gt; this case seems complicated.<br>&gt;<br>&gt; This is here in the updated version, though I agree it’s not simple to<br>&gt; handle throwing out of the block as multiple threads are executing the same<br>&gt; code at once.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; This next one is subjective, but I find the placement of the<br>&gt; group-related methods somewhat backwards vis-a-vis how I think of them in<br>&gt; terms of the C-API.<br>&gt;<br>&gt; I suspect this can go either way but the block is still being executed on<br>&gt; a given queue, you’re just associating the execution of that block with a<br>&gt; given group. In my mind that lives on the queue, as the execution will<br>&gt; still occur there. Contrasting this to notify, which requests that the<br>&gt; group itself submits the notify block to the queue when the group itself is<br>&gt; empty.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; EG: I think of `dispatch_group_async` as a “method” on a<br>&gt; `dispatch_group`, so would’ve expected this:<br>&gt; &gt;<br>&gt; &gt; class DispatchGroup : DispatchObject {<br>&gt; &gt;<br>&gt; &gt;  // (actual name should match chosen name convention)<br>&gt; &gt;  func asynchronouslyDispatch(to queue: DispatchQueue, work:<br>&gt; @convention(block) () -&gt; Void)<br>&gt; &gt;<br>&gt; &gt;  // (actual name should match chosen name convention)<br>&gt; &gt;  func notify(on queue: DispatchQueue, using block: @convention(block) ()<br>&gt; -&gt; Void)<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; …(and presumably the API would have manual enter/leave/wait methods and<br>&gt; so on exposed).<br>&gt; &gt;<br>&gt; &gt; I don’t feel strongly here but bring it up in case others feel similarly.<br>&gt; &gt;<br>&gt; &gt; I’m a little confused about the `DispatchSpecificKey&lt;T&gt;` class; is it<br>&gt; anything more than a way to &quot;smuggle in” a generic type parameter for the<br>&gt; associated value?<br>&gt;<br>&gt; I think it’s a little stronger than “smuggle in” here, it allows the<br>&gt; compiler to enforce that you have the same type going into setSpecific that<br>&gt; you get out of getSpecific (or DispatchQueue.getSpecific) for a given key.<br>&gt; The C API here forces you to cast away from void* and I think this is a<br>&gt; good example of how the Swift equivalent API is helping make things safer.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; Also on queue-specifics, what is our expected story if we have custom<br>&gt; destructors? Subclass `DispatchSpecificKey`?<br>&gt;<br>&gt; The value supplied to setSpecific is boxed inside a class that’s then<br>&gt; retained. When the queue is deallocated, or the value is replaced then the<br>&gt; box is released and normal Swift semantics for memory management will kick<br>&gt; in on your boxed value. That way the API is still flexible enough to<br>&gt; consume non-objects, like Ints, but also capable of taking references to<br>&gt; classes too.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; For things like `Int` specifics, I assume this API is storing auto-boxed<br>&gt; values…? Is there any way to side-step if we use want to store an unsafe<br>&gt; pointer? It’s not a big deal for me if we can’t under this API, TBH, but<br>&gt; I’d at least like to see this API’s implementation and costs spelled-out<br>&gt; more explicitly.<br>&gt; &gt;<br>&gt; &gt; For `DispatchData`, is there a principled reason there isn’t something<br>&gt; like this defined:<br>&gt; &gt;<br>&gt; &gt; struct DispatchDataSegment {<br>&gt; &gt;  let bytes: UnsafeBufferPointer&lt;UInt8&gt;<br>&gt; &gt;  let byteIndex: Int<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; extension DispatchData {<br>&gt; &gt;<br>&gt; &gt;  /// Returns a sequence that enumerates the contiguous chunks,<br>&gt; &gt;  /// e.g. a sequence with elements of type `DispatchDataSegment`.<br>&gt; &gt;  ///<br>&gt; &gt;  /// Sequence-based eplacement-for `enumerateBytes(_:)`<br>&gt; &gt;  var segmentSequence: DispatchDataSegmentSequence { get }<br>&gt; &gt;<br>&gt; &gt; }<br>&gt;<br>&gt; This is a good path to investigate in future improvements here.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; …or something analogous (instead of the proposed use<br>&gt; dispatch_data_apply?)?<br>&gt; &gt;<br>&gt; &gt; I don’t see any API yet for setting target queues, or getting queue<br>&gt; labels. I know the proposal isn’t documenting the APIs in full but it’s<br>&gt; hard to evaluate in that absence.<br>&gt; &gt;<br>&gt; &gt; I don’t see basic API on dispatch sources yet for things like setting<br>&gt; event handlers, (etc.); again I know the APIs aren’t fully specified here<br>&gt; but it’s hard to evaluate something that’s not fully specified.<br>&gt;<br>&gt; These should be present in today’s updated module listing.<br>&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt;      * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt; &gt;&gt;      * Does this proposal fit well with the feel and direction of Swift?<br>&gt; &gt;&gt;      * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt; &gt;&gt;      * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; More information about the Swift evolution process is available at<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;      https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thank you,<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Chris Lattner<br>&gt; &gt;&gt; Review Manager<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 41<br>&gt; Date: Sat, 14 May 2016 01:50:37 +0200<br>&gt; From: Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt;<br>&gt; To: swift-evolution at swift.org<br>&gt; Subject: Re: [swift-evolution] [Pitch] merge types and protocols back<br>&gt;         together with type&lt;Type, Protocol, ...&gt;<br>&gt; Message-ID: &lt;etPan.5736684d.50456560.6ab2 at DevAndArtist.fritz.box&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; If anyone is interested, I started a draft proposal with detailed design<br>&gt; here:<br>&gt; https://github.com/DevAndArtist/swift-evolution/blob/master/proposals/nnnn-merging-types-with-protocols.md<br>&gt;<br>&gt; I didn’t post it here, because it is a bit huge and could lose its<br>&gt; markdown formats. `all&lt;&gt;` is always bold, because this is what we are<br>&gt; interested in, but I provided all possible combinations if the other<br>&gt; formats would exists (at least all combinations I could think of, anything<br>&gt; else is derived from these).<br>&gt;<br>&gt; `class&lt;&gt;` etc. can be seen as a future direction (I would say), otherwise<br>&gt; this would easily become out of scope for Swift 3. (I will  move `class&lt;&gt;`<br>&gt; etc. from detailed design to future direction later.)<br>&gt;<br>&gt; I’d love to hear your feedback and strong arguments for the motivation<br>&gt; part I could include into this proposal.<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 13. Mai 2016 bei 23:16:20, Vladimir.S (svabox at gmail.com) schrieb:<br>&gt;<br>&gt; You asked for any example, I give it to you ;-)<br>&gt; (as I said, it is syntactical, just to show that such struct&lt;&gt; can be used<br>&gt; to test some struct for conforming to protocol, that was not conformed at<br>&gt; writing time)<br>&gt; Probably we can invent useful examples for this struct&lt;&gt; - but I don&#39;t<br>&gt; believe it will be introduced in Swift ;-)<br>&gt;<br>&gt; On 13.05.2016 22:14, Adrian Zubarev via swift-evolution wrote:<br>&gt; &gt; Can we really do that? I mean, I thought about that myself but I came to<br>&gt; &gt; the conclusion that this scenario is like: I was to lazy to couple this<br>&gt; &gt; structs to my library protocols, will you do that for me?<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/8100916d/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 42<br>&gt; Date: Fri, 13 May 2016 19:16:50 -0500<br>&gt; From: Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; To: Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt;<br>&gt; Cc: swift-evolution at swift.org<br>&gt; Subject: Re: [swift-evolution] [Pitch] merge types and protocols back<br>&gt;         together with type&lt;Type, Protocol, ...&gt;<br>&gt; Message-ID: &lt;99488013-D61B-4CD2-9671-3848838FCC8C at anandabits.com&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt;<br>&gt; &gt; On May 13, 2016, at 2:14 PM, Adrian Zubarev via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; As we can(as example) expect that in 3rd party code someone will do:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; extension StructA: ExtraProtocol1 {<br>&gt; &gt;&gt; func bar() {}<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; extension StructB: ExtraProtocol2 {<br>&gt; &gt;&gt; func blort() {}<br>&gt; &gt;&gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Can we really do that? I mean, I thought about that myself but I came to<br>&gt; the conclusion that this scenario is like: I was to lazy to couple this<br>&gt; structs to my library protocols, will you do that for me?<br>&gt; &gt;<br>&gt; &gt; Sure one could think that this protocols might be optional but the `f(p:<br>&gt; MyProtocol)` function will cover this scenario.<br>&gt; &gt;<br>&gt; &gt; Another interesting side-effect `struct&lt;&gt;`, `class&lt;&gt;` and `enum&lt;&gt;` will<br>&gt; allow us to do is to distinguish between value and reference types for<br>&gt; generics. I tried this differentiation types with protocols like<br>&gt; `AnyReference` and `AnyValue` in another topic before (Should we rename<br>&gt; &quot;class&quot; when referring to protocol conformance? &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016286.html&gt;),<br>&gt; but I kinda like this new approach.<br>&gt; &gt;<br>&gt; &gt; Here is what I mean in detail:<br>&gt; &gt;<br>&gt; &gt; protocol SomeProtocol /* we can’t constraint it to value types at the<br>&gt; moment, only `class`es works */ {}<br>&gt; &gt;<br>&gt; &gt; func foo&lt;T&gt;(value: struct&lt;T, SomeProtocol&gt;) { /* do some work */ }<br>&gt; &gt;<br>&gt; &gt; This function is pretty neat. (1) You can force the library user to<br>&gt; create a struct with conformance to `SomeProtocol`. (2) This approach will<br>&gt; accept any struct which conforms to that protocol.<br>&gt; &gt;<br>&gt; &gt; As I said in the protocol comment above protocols can only be<br>&gt; constrained to classes at the moment, and this might change in the future.<br>&gt; If we also had some sort of things for generics so the function from above<br>&gt; might have looked like this:<br>&gt; &gt;<br>&gt; &gt; func foo&lt;T: struct where T: SomeProtocol&gt;(value: T) {}<br>&gt; &gt;<br>&gt; &gt; But it seems that such a thing won’t ever happen to Swift.<br>&gt; &gt;<br>&gt; &gt; Basically `struct&lt;&gt;`, `class&lt;&gt;` and `enum&lt;&gt;` will just enable this for<br>&gt; us. `all&lt;&gt;` would accept any type at its first element.<br>&gt; &gt;<br>&gt; &gt; func foo&lt;T /* add more constraints here */ &gt;(value: all&lt;T,<br>&gt; SomeProtocol&gt;) { /* T could be a reference type or value type */ }<br>&gt; &gt;<br>&gt; &gt; That been said, `all&lt;&gt;` could replace `protocol&lt;&gt;` where it is composed<br>&gt; from protocols. `all&lt;&gt;` can only be used as a generic constraints if the<br>&gt; first element is a protocol or a reference type.<br>&gt; &gt;<br>&gt; &gt; @Matthew: isn’t this somehow a step towards (generic) `PureValue` types?<br>&gt;<br>&gt; No.  These say nothing about semantics.  PureValue is all about the<br>&gt; semantics of a type and has nothing to do with what mechanism is used to<br>&gt; implement the type.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; struct A&lt;T&gt; {<br>&gt; &gt;<br>&gt; &gt;     var value: struct&lt;T&gt; // if we drop the strict rule of at least one<br>&gt; protocols<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; How does it sound to you?<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Adrian Zubarev<br>&gt; &gt; Sent with Airmail<br>&gt; &gt;<br>&gt; &gt; Am 13. Mai 2016 bei 20:34:59, Vladimir.S (svabox at gmail.com &lt;mailto:<br>&gt; svabox at gmail.com&gt;) schrieb:<br>&gt; &gt;<br>&gt; &gt;&gt; Hmm..<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; What about such synthetic scenario:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; at the moment of writing our code we have:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; public protocol MyProtocol {<br>&gt; &gt;&gt; func foo()<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; public struct StructA:MyProtocol {<br>&gt; &gt;&gt; func foo()<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; public struct StructB:MyProtocol {<br>&gt; &gt;&gt; func foo()<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; and have<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; public protocol ExtraProtocol1 {<br>&gt; &gt;&gt; func bar()<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; public protocol ExtraProtocol2 {<br>&gt; &gt;&gt; func blort()<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; then we actually can have such code:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func f(p: MyProtocol) {<br>&gt; &gt;&gt; if let a = p as? struct&lt;StructA, ExtraProtocol1&gt; {<br>&gt; &gt;&gt; a.foo()<br>&gt; &gt;&gt; a.bar()<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; else<br>&gt; &gt;&gt; if let b = p as? struct&lt;StructB, ExtraProtocol2&gt; {<br>&gt; &gt;&gt; b.foo()<br>&gt; &gt;&gt; b.blort()<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On 13.05.2016 20:50, Adrian Zubarev via swift-evolution wrote:<br>&gt; &gt;&gt; &gt;&gt; &#39;struct&lt;&gt;&#39; does seem redundant unless it becomes subtypeable. If<br>&gt; &gt;&gt; &gt;&gt; you want a struct which conforms to several protocols, protocol&lt;&gt;<br>&gt; &gt;&gt; &gt;&gt; already covers this.<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; I think this is not correct. Lets check this example:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; func foo(value: SomeProtocol) {<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; if let a = value as? struct&lt;StructA, SomeProtocol&gt; { /* do<br>&gt; &gt;&gt; &gt;&gt; something with a */ }<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; else if let b = value as? struct&lt;StructB, SomeProtocol&gt; { /* do<br>&gt; &gt;&gt; &gt;&gt; something with b */ }<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; }<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; In this scenario you’ll be able to access properties and functions<br>&gt; &gt;&gt; &gt;&gt; from `StructA` or `StructB` which might not be covered by<br>&gt; &gt;&gt; &gt;&gt; `SomeProtocol`. Everything is merged nicely into one instance. But<br>&gt; &gt;&gt; &gt;&gt; you are right it depends on the use-case.<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; There is no need to include the protocol here. Just do this:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; if let a = value as? StructA { use a }<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; Whoops, I forgot that this will do the trick. I apologize for any<br>&gt; confusion<br>&gt; &gt;&gt; &gt; here, you are totally right.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; That been said, do we really need `type&lt;&gt;` aka. `all&lt;&gt;` for value<br>&gt; types? I<br>&gt; &gt;&gt; &gt; need to rethink this part of the proposal. Is there any use-case<br>&gt; where we<br>&gt; &gt;&gt; &gt; would need this (any scenario for the future Swift version also<br>&gt; counts)?<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; If we had `all&lt;&gt;` in Swift already for extendable reference types and<br>&gt; one<br>&gt; &gt;&gt; &gt; day structs would become subtypeable, this wouldn’t be a huge problem<br>&gt; to<br>&gt; &gt;&gt; &gt; upgrade `all&lt;&gt;` for structs I guess.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; --<br>&gt; &gt;&gt; &gt; Adrian Zubarev<br>&gt; &gt;&gt; &gt; Sent with Airmail<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; _______________________________________________<br>&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt; &gt;&gt; &gt; swift-evolution at swift.org<br>&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/0d832263/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 43<br>&gt; Date: Fri, 13 May 2016 19:33:04 -0500<br>&gt; From: Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; To: Joe Groff &lt;jgroff at apple.com&gt;<br>&gt; Cc: Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Draft] Introducing StaticSelf,  an<br>&gt;         Invariant Self<br>&gt; Message-ID: &lt;E5E5D42D-5E98-4FD0-A29A-A4F228B4D558 at anandabits.com&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt;<br>&gt; &gt; On May 13, 2016, at 3:12 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On May 13, 2016, at 9:06 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On May 13, 2016, at 10:55 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On May 13, 2016, at 8:18 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; When I write a class Base with non-final methods that return<br>&gt; instances of Base I can choose whether to state the return type as Self<br>&gt; (covariant) or Base (invariant, under this proposal StaticSelf would also<br>&gt; be an alternative way to state this).  If I choose to specify Base as the<br>&gt; return type derived classes *may* override the method but are not required<br>&gt; to.  Further, if they *do* override the method they are allowed to choose<br>&gt; whether their implementation returns Base or Derived.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; `StaticSelf` requirements by themselves don&#39;t even save you from<br>&gt; covariance. If Base conforms to a protocol (with Self == Base), Derived<br>&gt; inherits that conformance and also conforms (with Self == Derived). If<br>&gt; `StaticSelf` always refers to the conforming type, then it must also be<br>&gt; bindable to Base and Derived, so a base class must still use a<br>&gt; covariant-returning method to satisfy the `StaticSelf` requirement.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; We are specifying that `StaticSelf` refers to the type that explicitly<br>&gt; declares conformance.  If a class inherits conformance it refers to the<br>&gt; base class which explicitly declared the conformance it is inheriting.<br>&gt; &gt;<br>&gt; &gt; That makes `StaticSelf` tricky to use in generic code. This would be<br>&gt; invalid:<br>&gt; &gt;<br>&gt; &gt; protocol Makable {<br>&gt; &gt;       static func make(value: Int) -&gt; StaticSelf<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; func makeWithZero&lt;T: Fooable&gt;(x: Int) -&gt; T {<br>&gt; &gt;       return T.make(value: 0) // ERROR: T.StaticSelf may be a supertype<br>&gt; of T so isn&#39;t convertible to T<br>&gt; &gt; }<br>&gt;<br>&gt; I agree it’s a bit tricky.  But that’s better than not possible at all.<br>&gt; You just need a typealias and a same type constraint to make this work as<br>&gt; expected / desired:<br>&gt;<br>&gt; protocol Makable {<br>&gt;         typealias RootMakable = StaticSelf<br>&gt;         static func make(value: Int) -&gt; StaticSelf<br>&gt; }<br>&gt;<br>&gt; func makeWithZero&lt;T: Makable where T == T.RootMakable&gt;(x: Int) -&gt; T {<br>&gt;         return T.make(value: 0) // works now<br>&gt; }<br>&gt;<br>&gt; Now that we have a typealias we can refer to the binding of StaticSelf and<br>&gt; constrain it as necessary for whatever purpose we have in mind.  In some<br>&gt; cases that will be a same type constraint so that our code works properly<br>&gt; with class clusters.  I don’t have concrete examples of other use cases but<br>&gt; can imagine use cases constraining the typealias to a protocol, for example.<br>&gt;<br>&gt; If we had control over inheritance of conformance at the point of<br>&gt; conformance we probably wouldn’t be talking about StaticSelf.  But we don’t<br>&gt; and this is a problem that has caused enough people trouble that it is<br>&gt; worth solving.  StaticSelf does that in a general way that is also as a<br>&gt; shorthand in types themselves and has consistent semantics in both use<br>&gt; cases.<br>&gt;<br>&gt; IIRC the design of point-of-conformance control over inheritance of<br>&gt; conformance is pretty thorny.  I wouldn’t mind seeing that feature<br>&gt; eventually but don’t have any confidence that it will come soon.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; `StaticSelf` in this model is effectively an associated type of the<br>&gt; protocol, with a `Self: StaticSelf` constraint (if that were supported).<br>&gt;<br>&gt; If you add that the associated type is automatically bound with the<br>&gt; initial conformance (and cannot be modified by subclass conformances) then<br>&gt; yes, you can look at it this way.<br>&gt;<br>&gt;<br>&gt;<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt;<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/3276330a/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 44<br>&gt; Date: Fri, 13 May 2016 21:06:11 -0700<br>&gt; From: Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt; To: Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; Cc: swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Pitch] merge types and protocols back<br>&gt;         together with type&lt;Type, Protocol, ...&gt;<br>&gt; Message-ID:<br>&gt;         &lt;<br>&gt; CANGnqV14+BLVHx7CZgoHfTKnQfpxDXFzp4mTWO4MFCFtZfKCAg at mail.gmail.com&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; This is certainly a detailed and well-considered proposal.<br>&gt;<br>&gt; I don&#39;t think the struct functionality makes much sense. There are two ways<br>&gt; you can use the struct&lt;...&gt; construct:<br>&gt;<br>&gt; 1. struct&lt;SomeConcreteStruct, Protocol1, Protocol2&gt;. In this case the<br>&gt; struct&lt;...&gt; representation is unnecessary; the protocols that are available<br>&gt; to the user are known at compile-time, and structs can&#39;t have subtypes that<br>&gt; conform to additional protocols like classes can. There is an example<br>&gt; marked &quot;func boo(value: struct&lt;SomeStruct&gt;) /* equivalent to */ func<br>&gt; boo(value: SomeStruct)&quot;; my question is why having more than two ways to<br>&gt; express the same idea makes the language better, easier to use, etc.<br>&gt;<br>&gt; 2. struct&lt;T, Protocol1, Protocol2&gt;. In this case struct&lt;...&gt; is being used<br>&gt; as an add-on to the generics system to denote a &#39;must be value type&#39;<br>&gt; constraint. However, I think a &#39;T : class&#39;-like &#39;struct&#39; constraint makes<br>&gt; more sense, both because it fits better with the existing &#39;class&#39;<br>&gt; constraint and because it can be used anywhere the generic system allows a<br>&gt; type parameter to be constrained. A generic &#39;struct&#39; constraint would give<br>&gt; the currently generics system as much expressive power as struct&lt;...&gt;.<br>&gt;<br>&gt; Overall, rather than having this be a separate feature I think it should be<br>&gt; developed as part of the &quot;Generalized Existentials&quot; feature that is already<br>&gt; on the roadmap for Swift 3. The cases where adding class&lt;...&gt;, struct&lt;...&gt;,<br>&gt; etc can improve expressive power are covered by allowing variables to take<br>&gt; existential types with constraints. The one big feature that Generalized<br>&gt; Existentials should absorb from this proposal is allowing the<br>&gt; representation of a concrete class type with protocol constraints<br>&gt; (&lt;MyClass, SomeProtocol, AnotherProtocol&gt;).<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Fri, May 13, 2016 at 5:16 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt;<br>&gt; &gt; On May 13, 2016, at 2:14 PM, Adrian Zubarev via swift-evolution &lt;<br>&gt; &gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; As we can(as example) expect that in 3rd party code someone will do:<br>&gt; &gt;<br>&gt; &gt; extension StructA: ExtraProtocol1 {<br>&gt; &gt; func bar() {}<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; extension StructB: ExtraProtocol2 {<br>&gt; &gt; func blort() {}<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Can we really do that? I mean, I thought about that myself but I came to<br>&gt; &gt; the conclusion that this scenario is like: I was to lazy to couple this<br>&gt; &gt; structs to my library protocols, will you do that for me?<br>&gt; &gt;<br>&gt; &gt; Sure one could think that this protocols might be optional but the `f(p:<br>&gt; &gt; MyProtocol)` function will cover this scenario.<br>&gt; &gt;<br>&gt; &gt; Another interesting side-effect `struct&lt;&gt;`, `class&lt;&gt;` and `enum&lt;&gt;` will<br>&gt; &gt; allow us to do is to distinguish between value and reference types for<br>&gt; &gt; generics. I tried this differentiation types with protocols like<br>&gt; &gt; `AnyReference` and `AnyValue` in another topic before (Should we rename<br>&gt; &gt; &quot;class&quot; when referring to protocol conformance?<br>&gt; &gt; &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016286.html<br>&gt; &gt;),<br>&gt; &gt; but I kinda like this new approach.<br>&gt; &gt;<br>&gt; &gt; Here is what I mean in detail:<br>&gt; &gt;<br>&gt; &gt; protocol SomeProtocol /* we can’t constraint it to value types at the<br>&gt; &gt; moment, only `class`es works */ {}<br>&gt; &gt;<br>&gt; &gt; func foo&lt;T&gt;(value: struct&lt;T, SomeProtocol&gt;) { /* do some work */ }<br>&gt; &gt;<br>&gt; &gt; This function is pretty neat. (1) You can force the library user to<br>&gt; create<br>&gt; &gt; a struct with conformance to `SomeProtocol`. (2) This approach will<br>&gt; accept<br>&gt; &gt; any struct which conforms to that protocol.<br>&gt; &gt;<br>&gt; &gt; As I said in the protocol comment above protocols can only be constrained<br>&gt; &gt; to classes at the moment, and this might change in the future. If we also<br>&gt; &gt; had some sort of things for generics so the function from above might<br>&gt; have<br>&gt; &gt; looked like this:<br>&gt; &gt;<br>&gt; &gt; func foo&lt;T: struct where T: SomeProtocol&gt;(value: T) {}<br>&gt; &gt;<br>&gt; &gt; But it seems that such a thing won’t ever happen to Swift.<br>&gt; &gt;<br>&gt; &gt; Basically `struct&lt;&gt;`, `class&lt;&gt;` and `enum&lt;&gt;` will just enable this for<br>&gt; us.<br>&gt; &gt; `all&lt;&gt;` would accept any type at its first element.<br>&gt; &gt;<br>&gt; &gt; func foo&lt;T /* add more constraints here */ &gt;(value: all&lt;T, SomeProtocol&gt;)<br>&gt; &gt; { /* T could be a reference type or value type */ }<br>&gt; &gt;<br>&gt; &gt; That been said, `all&lt;&gt;` could replace `protocol&lt;&gt;` where it is composed<br>&gt; &gt; from protocols. `all&lt;&gt;` can only be used as a generic constraints if the<br>&gt; &gt; first element is a protocol or a reference type.<br>&gt; &gt;<br>&gt; &gt; @Matthew: isn’t this somehow a step towards (generic) `PureValue` types?<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; No.  These say nothing about semantics.  PureValue is all about the<br>&gt; &gt; semantics of a type and has nothing to do with what mechanism is used to<br>&gt; &gt; implement the type.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; struct A&lt;T&gt; {<br>&gt; &gt;<br>&gt; &gt;     var value: struct&lt;T&gt; // if we drop the strict rule of at least one<br>&gt; &gt; protocols<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; How does it sound to you?<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Adrian Zubarev<br>&gt; &gt; Sent with Airmail<br>&gt; &gt;<br>&gt; &gt; Am 13. Mai 2016 bei 20:34:59, Vladimir.S (svabox at gmail.com) schrieb:<br>&gt; &gt;<br>&gt; &gt; Hmm..<br>&gt; &gt;<br>&gt; &gt; What about such synthetic scenario:<br>&gt; &gt;<br>&gt; &gt; at the moment of writing our code we have:<br>&gt; &gt;<br>&gt; &gt; public protocol MyProtocol {<br>&gt; &gt; func foo()<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; public struct StructA:MyProtocol {<br>&gt; &gt; func foo()<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; public struct StructB:MyProtocol {<br>&gt; &gt; func foo()<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; and have<br>&gt; &gt;<br>&gt; &gt; public protocol ExtraProtocol1 {<br>&gt; &gt; func bar()<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; public protocol ExtraProtocol2 {<br>&gt; &gt; func blort()<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; then we actually can have such code:<br>&gt; &gt;<br>&gt; &gt; func f(p: MyProtocol) {<br>&gt; &gt; if let a = p as? struct&lt;StructA, ExtraProtocol1&gt; {<br>&gt; &gt; a.foo()<br>&gt; &gt; a.bar()<br>&gt; &gt; }<br>&gt; &gt; else<br>&gt; &gt; if let b = p as? struct&lt;StructB, ExtraProtocol2&gt; {<br>&gt; &gt; b.foo()<br>&gt; &gt; b.blort()<br>&gt; &gt; }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On 13.05.2016 20:50, Adrian Zubarev via swift-evolution wrote:<br>&gt; &gt; &gt;&gt; &#39;struct&lt;&gt;&#39; does seem redundant unless it becomes subtypeable. If<br>&gt; &gt; &gt;&gt; you want a struct which conforms to several protocols, protocol&lt;&gt;<br>&gt; &gt; &gt;&gt; already covers this.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; I think this is not correct. Lets check this example:<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; func foo(value: SomeProtocol) {<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; if let a = value as? struct&lt;StructA, SomeProtocol&gt; { /* do<br>&gt; &gt; &gt;&gt; something with a */ }<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; else if let b = value as? struct&lt;StructB, SomeProtocol&gt; { /* do<br>&gt; &gt; &gt;&gt; something with b */ }<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; }<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; In this scenario you’ll be able to access properties and functions<br>&gt; &gt; &gt;&gt; from `StructA` or `StructB` which might not be covered by<br>&gt; &gt; &gt;&gt; `SomeProtocol`. Everything is merged nicely into one instance. But<br>&gt; &gt; &gt;&gt; you are right it depends on the use-case.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; There is no need to include the protocol here. Just do this:<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; if let a = value as? StructA { use a }<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; Whoops, I forgot that this will do the trick. I apologize for any<br>&gt; &gt; confusion<br>&gt; &gt; &gt; here, you are totally right.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; That been said, do we really need `type&lt;&gt;` aka. `all&lt;&gt;` for value<br>&gt; types?<br>&gt; &gt; I<br>&gt; &gt; &gt; need to rethink this part of the proposal. Is there any use-case where<br>&gt; we<br>&gt; &gt;<br>&gt; &gt; &gt; would need this (any scenario for the future Swift version also<br>&gt; counts)?<br>&gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; If we had `all&lt;&gt;` in Swift already for extendable reference types and<br>&gt; one<br>&gt; &gt;<br>&gt; &gt; &gt; day structs would become subtypeable, this wouldn’t be a huge problem<br>&gt; to<br>&gt; &gt;<br>&gt; &gt; &gt; upgrade `all&lt;&gt;` for structs I guess.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; --<br>&gt; &gt; &gt; Adrian Zubarev<br>&gt; &gt; &gt; Sent with Airmail<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/350b0db2/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 45<br>&gt; Date: Sat, 14 May 2016 01:05:32 -0400<br>&gt; From: Jon Shier &lt;jon at jonshier.com&gt;<br>&gt; To: swift-evolution at swift.org<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0081: Move where clause to<br>&gt;         end of  declaration<br>&gt; Message-ID: &lt;DC2A000A-6322-43A5-BD6D-2C405C745C89 at jonshier.com&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; &gt; * What is your evaluation of the proposal?<br>&gt;<br>&gt; -1<br>&gt;<br>&gt; No one has been able to explain how this change improves readability, it<br>&gt; just seems like it’s supposed to be self evident. I would argue that it<br>&gt; makes the generic definitions less readable by separating declarations and<br>&gt; their relevant where clauses. At best this change just moves the already<br>&gt; unreadable mass of text elsewhere, where it’s still unreadable.<br>&gt; Furthermore, it trades this supposed readability of generic parameters for<br>&gt; decreased readability of the actual function signature, since that<br>&gt; signature’s now buried between the generic definitions and the where<br>&gt; clauses. This is especially bad when declaring a single generic type that<br>&gt; can easily fit on a single line, such as:<br>&gt;<br>&gt; func something&lt;T: Decodable where T == T.DecodedType&gt;(with something: T)<br>&gt; -&gt; String<br>&gt;<br>&gt; turns into this, which is less readable to me, as it hides important<br>&gt; information between the generic information:<br>&gt;<br>&gt; func something&lt;T: Decodable&gt;(with something: T) -&gt; String where T ==<br>&gt; T.DecodedType<br>&gt;<br>&gt; Also, this proposal doesn’t explain how the definitions for generic types<br>&gt; would change. Using the proposed grammar would be even worse on types. From:<br>&gt;<br>&gt; final class NetworkOperation&lt;T: Decodable where T == T.DecodedType&gt;:<br>&gt; Operation,… {<br>&gt;<br>&gt; to:<br>&gt;<br>&gt; final class NetworkOperation&lt;T: Decodable&gt;: Operation,… where T ==<br>&gt; T.DecodedType {<br>&gt;<br>&gt; The additional conformances types can have make this an especially bad use<br>&gt; case for this proposal.<br>&gt;<br>&gt; &gt;       * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br>&gt; It can be a problem, but I don’t see how this proposal fixes it.<br>&gt; Appropriate code styling, whether manual or provided by an IDE, could<br>&gt; provide much better readability than this proposal ever could.<br>&gt;<br>&gt; &gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; Changes proposed for “readability” need to be closely scrutinized, as one<br>&gt; programmer’s readable and another’s Perl. I don’t think this proposal meets<br>&gt; the high standard this list has tried to set for things to the language.<br>&gt;<br>&gt; &gt;       * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br>&gt; Java and C++’s generics, which are rather different. And despite what they<br>&gt; may have intended, I don’t think generics in either language are used as<br>&gt; much as in Swift.<br>&gt;<br>&gt; &gt;       * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; Read the proposal, the thread thus far, and considered my response.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Jon<br>&gt;<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/a80f432d/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 46<br>&gt; Date: Sat, 14 May 2016 01:19:49 -0400<br>&gt; From: Jon Shier &lt;jon at jonshier.com&gt;<br>&gt; To: swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Pitch] Consistent bridging for<br>&gt;         NSErrors at     the language boundary<br>&gt; Message-ID: &lt;C1FE5542-1469-4ECB-B422-D4C7F013CA58 at jonshier.com&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; Charles:<br>&gt;         I appreciate the attempt to minimize a current pain point and I<br>&gt; agree on most of your analysis of the current NSError bridging but I think<br>&gt; your proposal is fundamentally flawed. By forcing the core error type to<br>&gt; have properties from NSError, you’re essentially finalizing what all error<br>&gt; types in Swift should look like. Error domains, codes, and info<br>&gt; dictionaries are not Swift, and forcing every error produced in Swift to<br>&gt; have those properties is a regression from the freedom ErrorType has given<br>&gt; us. No native Swift error type I’ve seen so far has chosen to replicate<br>&gt; those properties, and for good reason: they are a relic of C which have no<br>&gt; place in Swift. There are far better error designs out there. If you want<br>&gt; to propose a strong type of error for Swift, go ahead, but it should be<br>&gt; thoroughly inspired by Swift, not driven by a desire to ease bridging to<br>&gt; NSError.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Jon Shier<br>&gt;<br>&gt;<br>&gt; &gt; On May 5, 2016, at 3:06 PM, Charles Srstka via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I formerly posted a less-fleshed-out version of this in the “Reducing<br>&gt; bridging magic” thread, but I thought this might warrant its own pitch.<br>&gt; What do you all think?<br>&gt; &gt;<br>&gt; &gt; MOTIVATION:<br>&gt; &gt;<br>&gt; &gt; Over the past couple of years, Swift has made great strides toward<br>&gt; seamless interoperability with existing Objective-C APIs, and with SE-0005,<br>&gt; SE-0033, SE-0057, SE-0062, SE-0064, and SE-0070, seems poised to become<br>&gt; even better in that regard. However, there still exists one major pain<br>&gt; point when going back and forth between Swift and Objective-C, and that<br>&gt; lies in the area of error reporting. Passing errors between Objective-C and<br>&gt; Swift APIs is currently quite awkward, for several reasons:<br>&gt; &gt;<br>&gt; &gt; - The Swift-approved mechanism for reporting errors is a protocol named<br>&gt; ErrorType (ErrorProtocol in the latest sources). However, Objective-C<br>&gt; represent errors using a class named NSError. In addition to being a<br>&gt; reference type, which feels quite unnatural for an error object by Swift’s<br>&gt; conventions, NSError follows a completely paradigm from what most<br>&gt; ErrorProtocol objects use to store errors, using a string-based domain and<br>&gt; and integer code, along with a userInfo dictionary to store information to<br>&gt; be presented to the user. While the domain and code are available as<br>&gt; methods on ErrorProtocol, they are prefixed with underscores, and there is<br>&gt; no direct equivalent to userInfo.<br>&gt; &gt;<br>&gt; &gt; - Unlike other Objective-C classes like NSString and NSArray which are<br>&gt; consistently bridged to value types when presenting Objective-C interfaces<br>&gt; to Swift, the handling of NSError objects is inconsistent. Objective-C APIs<br>&gt; which return an error by reference using an autoreleasing NSError **<br>&gt; pointer are converted to use the Swift try/catch mechanism, presenting the<br>&gt; returned error as an ErrorProtocol (which is actually an NSError).<br>&gt; Similarly, Swift APIs using try/catch are presented to Objective-C as<br>&gt; autoreleasing NSError ** pointers, and the ErrorProtocol-conforming error<br>&gt; is converted to an NSError when it is called by Objective-C. However, when<br>&gt; passing around error objects in any way other than these, the errors are<br>&gt; not bridged. An Objective-C API that takes an NSError, such as NSApp’s<br>&gt; -presentError: method, still leaves NSError as the type in the interface<br>&gt; presented to Swift, as do the many asynchronous APIs in Cocoa that return<br>&gt; an NSError as one of the arguments to a completion handler. Swift APIs that<br>&gt; accept ErrorProtocols, on the other hand, are not presented to Objective-C<br>&gt; at all, necessitating any such APIs also be declared to take NSErrors.<br>&gt; &gt;<br>&gt; &gt; - To convert ErrorProtocols to NSErrors, Swift provides a bridging<br>&gt; mechanism, invoked via “as NSError”, which wraps the error in a private<br>&gt; NSError subclass class called _SwiftNativeNSError. This subclass can be<br>&gt; cast back to the original error type, thus returning the original wrapped<br>&gt; error. When a Swift API that is marked “throws” is called from Objective-C<br>&gt; and then throws an error, the same bridging mechanism is invoked. However,<br>&gt; this bridging is not very useful, since Cocoa tends to use NSError’s<br>&gt; userInfo dictionary to present error information to the user, and<br>&gt; ErrorProtocol contains no equivalent to the userInfo dictionary. The result<br>&gt; of this is that when a Swift API throws an error, and this error is passed<br>&gt; to Cocoa, the user tends to get a generic error message instead of<br>&gt; something actually useful.<br>&gt; &gt;<br>&gt; &gt; - The above problem means that a Swift developer must be very careful<br>&gt; never to use “as NSError”, and to be sure to construct an NSError when<br>&gt; throwing an error in an API that may be called from Objective-C, rather<br>&gt; than simply throwing the error directly, or else the error will not be<br>&gt; properly presented. If the developer makes a mistake here, it will not be<br>&gt; known until runtime. I have personally wasted quite a bit of time trying to<br>&gt; hunt down points in a complicated program where an error was accidentally<br>&gt; converted to NSError via the bridge rather than explicitly.<br>&gt; &gt;<br>&gt; &gt; - The same problem also puts the Swift developer between a rock and a<br>&gt; hard place, if they have other code that wants to check these errors. In a<br>&gt; pure-Swift program, checking against a particular error can often be done<br>&gt; simply via an equality check. If the error has been converted to NSError<br>&gt; via the bridge, this also works, since the bridge will return the original<br>&gt; Swift error when casted. However, if the API that threw the error has been<br>&gt; conscientious about constructing an NSError to avoid the userInfo issue,<br>&gt; the NSError will not be easily castable back to the original Swift error<br>&gt; type. Instead, the developer will have to compare the NSError’s error<br>&gt; domain and code. The code itself will have to have been assigned by the<br>&gt; throwing API. As the domain is stringly-typed and the code will often be<br>&gt; extraneous to the actual error definition, this is all very<br>&gt; runtime-dependent and can easily become incorrect or out of sync, which<br>&gt; will break the program’s error reporting.<br>&gt; &gt;<br>&gt; &gt; - The UI for creating NSError objects is extremely verbose, and<br>&gt; eminently un-Swift-like, usually requiring two lines of code: one to<br>&gt; construct a dictionary, with an extremely verbose<br>&gt; key—NSLocalizedFailureReasonErrorKey—to indicate the actual error message<br>&gt; text to the user, and one to construct the NSError object. The latter is<br>&gt; itself quite verbose, requiring the developer to enter values for a domain<br>&gt; and code which she typically does not care about, since ErrorProtocol<br>&gt; provides decent enough default implementations for those values in most<br>&gt; cases.<br>&gt; &gt;<br>&gt; &gt; - Due to bugs in the bridging mechanism, it is possible for a<br>&gt; _SwiftNativeNSError to get run a second time through the bridge, which<br>&gt; removes the userInfo dictionary altogether, once again result in incorrect<br>&gt; error reporting.<br>&gt; &gt;<br>&gt; &gt; - The need for the “as NSError” bridging mechanism makes it more<br>&gt; difficult to implement otherwise positive changes such as Joe Groff’s<br>&gt; proposal to simplify the “as?” keyword (<br>&gt; https://github.com/apple/swift-evolution/pull/289 &lt;<br>&gt; https://github.com/apple/swift-evolution/pull/289&gt;).<br>&gt; &gt;<br>&gt; &gt; - Finally, the fact that Swift code that deals with errors must always<br>&gt; be filled with either “as NSError” statements or explicit NSError<br>&gt; initializations sprinkled through results in code that is quite a bit<br>&gt; uglier than it needs to be.<br>&gt; &gt;<br>&gt; &gt; PROPOSED APPROACH:<br>&gt; &gt;<br>&gt; &gt; I propose consistently bridging NSError to a value type whenever it is<br>&gt; exposed to Swift code via an API signature, and doing the equivalent in the<br>&gt; opposite direction, similarly to how NSStrings and Strings are bridged to<br>&gt; and from each other in API signatures.<br>&gt; &gt;<br>&gt; &gt; The benefits of this approach are many:<br>&gt; &gt;<br>&gt; &gt; 1. This is very similar to the bridging that already exists for<br>&gt; String&lt;-&gt;NSString, Array&lt;-&gt;NSArray, when crossing the language boundary, so<br>&gt; this improves the consistency of the language.<br>&gt; &gt;<br>&gt; &gt; 2. Special-case type checks would be mostly restricted to the special<br>&gt; magic that the compiler inserts when crossing the boundary, thus reducing<br>&gt; the potential for bugs.<br>&gt; &gt;<br>&gt; &gt; 3. NSError is no longer required to conform to ErrorProtocol, reducing<br>&gt; the type checking that has to go on during the bridging process, also<br>&gt; reducing the potential for bugs.<br>&gt; &gt;<br>&gt; &gt; 4. Since the is, as, as?, and as! operators would no longer be needed to<br>&gt; bridge NSErrors to native errors and back, improvements to that mechanism<br>&gt; such as (https://github.com/apple/swift-evolution/pull/289 &lt;<br>&gt; https://github.com/apple/swift-evolution/pull/289&gt;) become viable, and<br>&gt; the casting operators can be made to no longer act in ways that are often<br>&gt; surprising and confusing.<br>&gt; &gt;<br>&gt; &gt; 5. The programmer never has to deal with NSError objects in Swift code<br>&gt; again.<br>&gt; &gt;<br>&gt; &gt; DETAILED DESIGN:<br>&gt; &gt;<br>&gt; &gt; 1. Extend ErrorProtocol such that it has public, non-underscored methods<br>&gt; for the domain, code, and userInfo. The first two of these retain their<br>&gt; existing default implementations, whereas the last of these will have a<br>&gt; default implementation that just returns an empty dictionary. The user can<br>&gt; override any of these to provide more information as needed.<br>&gt; &gt;<br>&gt; &gt; 2. NSError’s conformance to ErrorProtocol is removed, since Swift code<br>&gt; will generally no longer need to work directly with NSErrors.<br>&gt; &gt;<br>&gt; &gt; 3. A new private error value type is introduced that conforms to<br>&gt; ErrorProtocol. Since this type will be private, its specific name is up to<br>&gt; the implementers, but for the purpose of this example we will assume that<br>&gt; it is named _ObjCErrorType. This type wraps an NSError, and forwards its<br>&gt; domain, code, and userInfo properties to it.<br>&gt; &gt;<br>&gt; &gt; 4. The existing _SwiftNativeNSError class remains, and continues to work<br>&gt; as it does currently, although it is extended to forward the userInfo<br>&gt; property to the wrapped Swift error. Thus, this class now wraps a native<br>&gt; Swift error and forwards the domain, code, and userInfo properties to it.<br>&gt; &gt;<br>&gt; &gt; 5. Objective-C APIs that return an NSError object present it as<br>&gt; ErrorProtocol in the signature. When called by Swift, the type of the<br>&gt; NSError is checked. If the type is _SwiftNativeNSError, the original Swift<br>&gt; error is unwrapped and returned. Otherwise, the NSError is wrapped in an<br>&gt; instance of _ObjCErrorType and returned as an ErrorProtocol.<br>&gt; &gt;<br>&gt; &gt; 6. Objective-C APIs that take NSError objects now show ErrorProtocol in<br>&gt; their signatures as well. If an _ObjCErrorType is passed to one of these<br>&gt; APIs, its wrapped NSError is unwrapped and passed to the API. Otherwise,<br>&gt; the error is wrapped in a _SwiftNativeNSError and passed through to the API.<br>&gt; &gt;<br>&gt; &gt; 7. Swift errors would still be convertible to NSError, if the developer<br>&gt; needed to do so manually. This could be done either via the current “as<br>&gt; NSError” bridge, or via initializers and/or accessors on NSError.<br>&gt; &gt;<br>&gt; &gt; IMPACT ON EXISTING CODE:<br>&gt; &gt;<br>&gt; &gt; Required changes to existing code will mostly involve removing “as<br>&gt; NSError” statements. Workarounds to the problem being addressed by this<br>&gt; change will probably also want to be removed, as they will no longer be<br>&gt; needed.<br>&gt; &gt;<br>&gt; &gt; ALTERNATIVES CONSIDERED:<br>&gt; &gt;<br>&gt; &gt; Do nothing, and let the terrorists win.<br>&gt; &gt;<br>&gt; &gt; Charles<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/480f784a/attachment-0001.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; Message: 47<br>&gt; Date: Sat, 14 May 2016 15:20:05 +1000<br>&gt; From: Patrick Smith &lt;pgwsmith at gmail.com&gt;<br>&gt; To: Kevin Ballard &lt;kevin at sb.org&gt;<br>&gt; Cc: swift-evolution at swift.org<br>&gt; Subject: Re: [swift-evolution] [Review] SE-0045: Add scan,<br>&gt;         prefix(while:), drop(while:), and iterate to the stdlib<br>&gt; Message-ID: &lt;9264E8FF-0A0E-4CC9-BF8E-51E0B67B5752 at gmail.com&gt;<br>&gt; Content-Type: text/plain; charset=&quot;utf-8&quot;<br>&gt;<br>&gt; Would there be any issue with the return type being AnySequence? It’s used<br>&gt; in other areas:<br>&gt;<br>&gt; LazySequence &amp; FlattenSequence’s<br>&gt; dropFirst(n: Int) -&gt; AnySequence&lt;Generator.Element&gt;<br>&gt; dropLast(n: Int) -&gt; AnySequence&lt;Generator.Element&gt;<br>&gt;<br>&gt; No need to introduce another type, and it’s straight forward to implement<br>&gt; with AnySequence.<br>&gt;<br>&gt;<br>&gt; &gt; On 14 May 2016, at 5:07 AM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On Fri, May 13, 2016, at 11:08 AM, Erica Sadun wrote:<br>&gt; &gt;&gt; On May 1, 2016, at 5:13 AM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; The proposal has been updated as per feedback from the core team (<br>&gt; https://github.com/apple/swift-evolution/pull/275 &lt;<br>&gt; https://github.com/apple/swift-evolution/pull/275&gt;). This includes<br>&gt; removing some last vestiges of Swift 2 naming as well as replacing<br>&gt; `iterate(_:apply:)` with an overloaded function `unfold(_:applying:)`.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The proposal says this:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;  public func unfold&lt;T, State&gt;(_ initialState: State, applying: State<br>&gt; -&gt; (T, State)?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt; &gt;&gt;&gt;  public func unfold&lt;T&gt;(_ initialElement: T, apply: T -&gt; T) -&gt;<br>&gt; UnfoldSequence&lt;T&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; However, the comment implies that the second one should instead be<br>&gt; this:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;  public func unfold&lt;T&gt;(_ initialElement: T, applying: T -&gt; T?) -&gt;<br>&gt; UnfoldSequence&lt;T&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I&#39;m not sure I like having these be overloaded on only the return type<br>&gt; of the closure. Maybe we could do something like this?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;  public func unfold&lt;T, State&gt;(fromState initialState: State, applying:<br>&gt; State -&gt; (T, State)?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt; &gt;&gt;&gt;  public func unfold&lt;T&gt;(fromFirst initialElement: T, apply: T -&gt; T) -&gt;<br>&gt; UnfoldSequence&lt;T&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; That way you&#39;re calling either `unfold(fromState:applying:)` or<br>&gt; `unfold(fromFirst:applying:)`. (Some further bikeshedding might be needed<br>&gt; here—it&#39;s late and I&#39;m tired.)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I really don&#39;t want to see this discussion die as I have a vested<br>&gt; interest in getting this functionality into<br>&gt; &gt;&gt; Swift 3. So let me suggest that<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; `sequence(_:, next:) -&gt; AdHocSequence`<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; might be a Swift acceptable solution.  We&#39;re not going to see<br>&gt; fold/unfold pair happen. It&#39;s a given that<br>&gt; &gt;&gt; `reduce` is a fixed point in Swift space and `sequence` well describes<br>&gt; what this should be doing.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; So is it possible to push forward with `sequence`, whose only negative<br>&gt; seems to be that it&#39;s not as well<br>&gt; &gt;&gt; loved as `unfold`?<br>&gt; &gt;<br>&gt; &gt; I do like `sequence`, though I&#39;m not sold on the name AdHocSequence<br>&gt; (just from that name it&#39;s hard to figure out what it does). An alternative<br>&gt; is `expand`, which is nice because it pairs with `reduce`, but it&#39;s less<br>&gt; obvious that it produces a sequence and the name isn&#39;t as good with the<br>&gt; stateful version.<br>&gt; &gt;<br>&gt; &gt; As for return type name, we could go ahead and use UnfoldSequence&lt;T&gt;<br>&gt; anyway even though the function isn&#39;t named `unfold`, because this name<br>&gt; will make sense to people who do know what unfold is, and I&#39;m not convinced<br>&gt; we can have a meaningful name for people who don&#39;t (since SequenceSequence<br>&gt; is too silly).<br>&gt; &gt;<br>&gt; &gt; So given that, I&#39;ll suggest the following:<br>&gt; &gt;<br>&gt; &gt;   func sequence&lt;T&gt;(initial: T, next: T -&gt; T?) -&gt; UnfoldSequence&lt;T&gt;<br>&gt; &gt;   func sequence&lt;T, State&gt;(state: State, next: (inout State) -&gt; T?) -&gt;<br>&gt; UnfoldSequence&lt;T&gt;<br>&gt; &gt;<br>&gt; &gt; I&#39;m suggesting `sequence(initial:next:)` instead of the<br>&gt; previously-suggested `sequence(from:applying:)` because the term &quot;from&quot;<br>&gt; could equally well mean the first element or the state, whereas &quot;initial&quot;<br>&gt; should make it more obvious that this value is the first element of the<br>&gt; resulting sequence. And I&#39;m using &quot;next&quot; as suggested by Erica because the<br>&gt; function does return the next element, and it&#39;s similar to the<br>&gt; IteratorProtocol method. I&#39;ve also chosen to change the stateful version to<br>&gt; use an inout parameter, as previously suggested, because it&#39;s equivalent to<br>&gt; the State -&gt; (T, State)? in functionality but is less likely to produce<br>&gt; unwanted COW copies.<br>&gt; &gt;<br>&gt; &gt; -Kevin Ballard<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/760d1ed4/attachment.html<br>&gt; &gt;<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; End of swift-evolution Digest, Vol 6, Issue 45<br>&gt; **********************************************<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/6c406fec/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
