<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>relationship of CF</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>January  2, 2016 at 05:00:00am</p></header><div class="content"><p>I had a question about something I saw in the docs:<br></p><p>&gt; A significant portion of the implementation of Foundation on Apple platforms is provided by another framework called CoreFoundation (a.k.a. CF). CF is written primarily in C and is very portable. Therefore we have chosen to use it for the internal implementation of Swift Foundation where possible. As CF is present on all platforms, we can use it to provide a common implementation everywhere.<br></p><p>(emphasis added)<br></p><p>Is the intent of this paragraph to suggest that most PRs to swift-corelibs-foundation should be a C-language implementation to CF with a light Swift wrapper?  That goes against my intuition, but it &quot;seems to be&quot; a plain reading of the paragraph.<br></p><p>its justification about &quot;all platforms&quot; is also strange–I know CF &quot;kind of&quot; builds for Windows, but is anyone actually testing it there?  To make sure we aren&#39;t breaking it?  Or does &quot;all platforms&quot; mean something else here?<br></p><p>I feel like this paragraph is an opportunity to explain to a patch author how to structure their patch between use/maintenance/contributions to the CF layer vs the Swift layer.  I feel like it could do a much better job, but I don&#39;t understand what the design guidance actually is, so I can&#39;t fix it.<br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160102/7c48778f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>relationship of CF</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>January  2, 2016 at 12:00:00pm</p></header><div class="content"><p>Responses inline:<br></p><p>&gt; On Jan 2, 2016, at 3:58 AM, Drew Crawford via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I had a question about something I saw in the docs:<br>&gt; <br>&gt;&gt; A significant portion of the implementation of Foundation on Apple platforms is provided by another framework called CoreFoundation (a.k.a. CF). CF is written primarily in C and is very portable. Therefore we have chosen to use it for the internal implementation of Swift Foundation where possible. As CF is present on all platforms, we can use it to provide a common implementation everywhere.<br>&gt; <br>&gt; (emphasis added)<br>&gt; <br>&gt; Is the intent of this paragraph to suggest that most PRs to swift-corelibs-foundation should be a C-language implementation to CF with a light Swift wrapper?  That goes against my intuition, but it &quot;seems to be&quot; a plain reading of the paragraph.<br></p><p>I think the underlying intent is that we should use the right tools for the job; where it makes sense, even the standard library uses C++. Similarly some of the interfaces for ICU for example make much more sense to encapsulate with CF (and re-use some of the existing cross platform abstractions). Some classes will be a thin veneer on top of CF, where-as others will be a completely swift implementation. Take the two cases of NSCalendar and NSThread. CF provides some very hard to write (and hard to get right) implementations of calendrical math, even though I wrote a good portion of the NSCalendar swift implementation; I am definitely glad that there was an implementation I could fall back upon to deal with that logic. The counterpoint of NSThread; we could have wrapped up a CFThreadRef type object and bridged it across but It made sense to keep NSThread in the realm of Swift not only for a potential example of dealing with posix APIs for the community but also it just worked out more cleanly in my opinion.<br></p><p>I have not crunched the numbers but I have a gut feeling that a large majority of the pull requests have been mostly Swift implementations and only a few of them have been thin veneers on-top-of CF and even fewer have been changes to CF itself.<br></p><p>&gt; <br>&gt; its justification about &quot;all platforms&quot; is also strange–I know CF &quot;kind of&quot; builds for Windows, but is anyone actually testing it there?  To make sure we aren&#39;t breaking it?  Or does &quot;all platforms&quot; mean something else here?<br></p><p>I know there have been efforts to port swift to FreeBSD and to new architectures like ARM-elf for things like Raspberry Pi, I would not be surprised that there are efforts to port to Android or Windows out there. Granted we do not have any CI provided by Apple to ensure not breaking these efforts but I think that the community will be interested in keeping these things running since a cross platform framework and language are really appealing (even Apple makes a few products for Android and Windows…)<br></p><p>As of current the Windows target is not held directly from the point at which this CF was cut from; so I would probably say “trust but verify” and I would not be surprised that there may be a few breaking points there that need to be re-looked at for that platform. I am certain that if someone took up a new target like Windows that would be met with great enthusiasm from all of the swift community. I was ecstatic when I saw that there was a FreeBSD port.<br></p><p>I think the one major thing to take under consideration is that alternate platforms than Mac OS X and Ubuntu 14/15 don’t have integration into the CI that the swift project maintains. I think however if there is strong desire out there it would be interesting to have externally maintained build servers provided by the community to verify these targets. I am not in charge of that type of decision but I would definitely think that it would be an amiable goal and I would think that it would be worthwhile to discuss further.<br></p><p>&gt; <br>&gt; I feel like this paragraph is an opportunity to explain to a patch author how to structure their patch between use/maintenance/contributions to the CF layer vs the Swift layer.  I feel like it could do a much better job, but I don&#39;t understand what the design guidance actually is, so I can&#39;t fix it.<br>&gt; <br></p><p>Things that enter into CF territory will be things that we will consider with a very close eye on them because they will likely move up-stream into the CoreFoundation that ships with our current platforms so that the lifecycle completes back out to the exported version in the open-source side of it.  The Foundation part of the story is a bit more mutable since we have the Objective-C version that will still be maintained. That being said there is a very strong desire to keep these in parity; we may use some of the interfaces in the swift version to try out what people think of these APIs (most of these are marked with experimental, and if they are not we should either correct them to be the same or mark them as such). Furthermore the swift version will sometimes drive internal efforts to improve Foundation as a whole not just it’s swift exposition. We have already had a few proposals that are making their ways to the component owners and teams that will improve the state of affairs for not just swift but objc too as externally authored proposals. <br></p><p>I agree that some of this intent should be a bit more clearly laid out; I will discuss about this when I get back into the office Monday and see what we can come up with to more clearly illustrate what is expected, what types of fallout patches have, and how the process will work for each potential layer and interaction.<br></p><p><br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160102/0b0f27e7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d925583c31aac9732e2993c42f648380?s=50"></div><header><strong>relationship of CF</strong> from <string>Dave Fenton</string> &lt;sirdavidfenton at gmail.com&gt;<p>January  2, 2016 at 04:00:00pm</p></header><div class="content"><p>Given the educational angle that seems to be part of the mission of Swift, I was hoping that the Raspberry Pi port would be something the Swift project would directly integrate  and distribute <br></p><p>-david<br></p><p>&gt; On Jan 2, 2016, at 3:00 PM, Philippe Hausler via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Responses inline:<br>&gt; <br>&gt;&gt; On Jan 2, 2016, at 3:58 AM, Drew Crawford via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I had a question about something I saw in the docs:<br>&gt;&gt; <br>&gt;&gt;&gt; A significant portion of the implementation of Foundation on Apple platforms is provided by another framework called CoreFoundation (a.k.a. CF). CF is written primarily in C and is very portable. Therefore we have chosen to use it for the internal implementation of Swift Foundation where possible. As CF is present on all platforms, we can use it to provide a common implementation everywhere.<br>&gt;&gt; <br>&gt;&gt; (emphasis added)<br>&gt;&gt; <br>&gt;&gt; Is the intent of this paragraph to suggest that most PRs to swift-corelibs-foundation should be a C-language implementation to CF with a light Swift wrapper?  That goes against my intuition, but it &quot;seems to be&quot; a plain reading of the paragraph.<br>&gt; <br>&gt; I think the underlying intent is that we should use the right tools for the job; where it makes sense, even the standard library uses C++. Similarly some of the interfaces for ICU for example make much more sense to encapsulate with CF (and re-use some of the existing cross platform abstractions). Some classes will be a thin veneer on top of CF, where-as others will be a completely swift implementation. Take the two cases of NSCalendar and NSThread. CF provides some very hard to write (and hard to get right) implementations of calendrical math, even though I wrote a good portion of the NSCalendar swift implementation; I am definitely glad that there was an implementation I could fall back upon to deal with that logic. The counterpoint of NSThread; we could have wrapped up a CFThreadRef type object and bridged it across but It made sense to keep NSThread in the realm of Swift not only for a potential example of dealing with posix APIs for the community but also it just worked out more cleanly in my opinion.<br>&gt; <br>&gt; I have not crunched the numbers but I have a gut feeling that a large majority of the pull requests have been mostly Swift implementations and only a few of them have been thin veneers on-top-of CF and even fewer have been changes to CF itself.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; its justification about &quot;all platforms&quot; is also strange–I know CF &quot;kind of&quot; builds for Windows, but is anyone actually testing it there?  To make sure we aren&#39;t breaking it?  Or does &quot;all platforms&quot; mean something else here?<br>&gt; <br>&gt; I know there have been efforts to port swift to FreeBSD and to new architectures like ARM-elf for things like Raspberry Pi, I would not be surprised that there are efforts to port to Android or Windows out there. Granted we do not have any CI provided by Apple to ensure not breaking these efforts but I think that the community will be interested in keeping these things running since a cross platform framework and language are really appealing (even Apple makes a few products for Android and Windows…)<br>&gt; <br>&gt; As of current the Windows target is not held directly from the point at which this CF was cut from; so I would probably say “trust but verify” and I would not be surprised that there may be a few breaking points there that need to be re-looked at for that platform. I am certain that if someone took up a new target like Windows that would be met with great enthusiasm from all of the swift community. I was ecstatic when I saw that there was a FreeBSD port.<br>&gt; <br>&gt; I think the one major thing to take under consideration is that alternate platforms than Mac OS X and Ubuntu 14/15 don’t have integration into the CI that the swift project maintains. I think however if there is strong desire out there it would be interesting to have externally maintained build servers provided by the community to verify these targets. I am not in charge of that type of decision but I would definitely think that it would be an amiable goal and I would think that it would be worthwhile to discuss further.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I feel like this paragraph is an opportunity to explain to a patch author how to structure their patch between use/maintenance/contributions to the CF layer vs the Swift layer.  I feel like it could do a much better job, but I don&#39;t understand what the design guidance actually is, so I can&#39;t fix it.<br>&gt; <br>&gt; Things that enter into CF territory will be things that we will consider with a very close eye on them because they will likely move up-stream into the CoreFoundation that ships with our current platforms so that the lifecycle completes back out to the exported version in the open-source side of it.  The Foundation part of the story is a bit more mutable since we have the Objective-C version that will still be maintained. That being said there is a very strong desire to keep these in parity; we may use some of the interfaces in the swift version to try out what people think of these APIs (most of these are marked with experimental, and if they are not we should either correct them to be the same or mark them as such). Furthermore the swift version will sometimes drive internal efforts to improve Foundation as a whole not just it’s swift exposition. We have already had a few proposals that are making their ways to the component owners and teams that will improve the state of affairs for not just swift but objc too as externally authored proposals. <br>&gt; <br>&gt; I agree that some of this intent should be a bit more clearly laid out; I will discuss about this when I get back into the office Monday and see what we can come up with to more clearly illustrate what is expected, what types of fallout patches have, and how the process will work for each potential layer and interaction.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt; swift-corelibs-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160102/915722a8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>relationship of CF</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>January  2, 2016 at 04:00:00pm</p></header><div class="content"><p>I think perhaps it might be worth something to investigate on what it would take to get these extra platforms integrated into CI as nodes to the Swift primary builders. As a note since we do target ARM as a primary platform for Darwin and we do target Linux as a primary platform, ARM linux is not a far stretch so the Pi is much more “supported” than other targets like the initial question of Windows code paths at the current moment.<br></p><p>Perhaps one of the compiler team can chime in since the packaging and automatic builds are their domain and not per-se mine.<br></p><p>&gt; On Jan 2, 2016, at 1:57 PM, Dave Fenton via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Given the educational angle that seems to be part of the mission of Swift, I was hoping that the Raspberry Pi port would be something the Swift project would directly integrate  and distribute <br>&gt; <br>&gt; -david<br>&gt; <br>&gt; On Jan 2, 2016, at 3:00 PM, Philippe Hausler via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Responses inline:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 2, 2016, at 3:58 AM, Drew Crawford via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I had a question about something I saw in the docs:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A significant portion of the implementation of Foundation on Apple platforms is provided by another framework called CoreFoundation (a.k.a. CF). CF is written primarily in C and is very portable. Therefore we have chosen to use it for the internal implementation of Swift Foundation where possible. As CF is present on all platforms, we can use it to provide a common implementation everywhere.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (emphasis added)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is the intent of this paragraph to suggest that most PRs to swift-corelibs-foundation should be a C-language implementation to CF with a light Swift wrapper?  That goes against my intuition, but it &quot;seems to be&quot; a plain reading of the paragraph.<br>&gt;&gt; <br>&gt;&gt; I think the underlying intent is that we should use the right tools for the job; where it makes sense, even the standard library uses C++. Similarly some of the interfaces for ICU for example make much more sense to encapsulate with CF (and re-use some of the existing cross platform abstractions). Some classes will be a thin veneer on top of CF, where-as others will be a completely swift implementation. Take the two cases of NSCalendar and NSThread. CF provides some very hard to write (and hard to get right) implementations of calendrical math, even though I wrote a good portion of the NSCalendar swift implementation; I am definitely glad that there was an implementation I could fall back upon to deal with that logic. The counterpoint of NSThread; we could have wrapped up a CFThreadRef type object and bridged it across but It made sense to keep NSThread in the realm of Swift not only for a potential example of dealing with posix APIs for the community but also it just worked out more cleanly in my opinion.<br>&gt;&gt; <br>&gt;&gt; I have not crunched the numbers but I have a gut feeling that a large majority of the pull requests have been mostly Swift implementations and only a few of them have been thin veneers on-top-of CF and even fewer have been changes to CF itself.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; its justification about &quot;all platforms&quot; is also strange–I know CF &quot;kind of&quot; builds for Windows, but is anyone actually testing it there?  To make sure we aren&#39;t breaking it?  Or does &quot;all platforms&quot; mean something else here?<br>&gt;&gt; <br>&gt;&gt; I know there have been efforts to port swift to FreeBSD and to new architectures like ARM-elf for things like Raspberry Pi, I would not be surprised that there are efforts to port to Android or Windows out there. Granted we do not have any CI provided by Apple to ensure not breaking these efforts but I think that the community will be interested in keeping these things running since a cross platform framework and language are really appealing (even Apple makes a few products for Android and Windows…)<br>&gt;&gt; <br>&gt;&gt; As of current the Windows target is not held directly from the point at which this CF was cut from; so I would probably say “trust but verify” and I would not be surprised that there may be a few breaking points there that need to be re-looked at for that platform. I am certain that if someone took up a new target like Windows that would be met with great enthusiasm from all of the swift community. I was ecstatic when I saw that there was a FreeBSD port.<br>&gt;&gt; <br>&gt;&gt; I think the one major thing to take under consideration is that alternate platforms than Mac OS X and Ubuntu 14/15 don’t have integration into the CI that the swift project maintains. I think however if there is strong desire out there it would be interesting to have externally maintained build servers provided by the community to verify these targets. I am not in charge of that type of decision but I would definitely think that it would be an amiable goal and I would think that it would be worthwhile to discuss further.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I feel like this paragraph is an opportunity to explain to a patch author how to structure their patch between use/maintenance/contributions to the CF layer vs the Swift layer.  I feel like it could do a much better job, but I don&#39;t understand what the design guidance actually is, so I can&#39;t fix it.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Things that enter into CF territory will be things that we will consider with a very close eye on them because they will likely move up-stream into the CoreFoundation that ships with our current platforms so that the lifecycle completes back out to the exported version in the open-source side of it.  The Foundation part of the story is a bit more mutable since we have the Objective-C version that will still be maintained. That being said there is a very strong desire to keep these in parity; we may use some of the interfaces in the swift version to try out what people think of these APIs (most of these are marked with experimental, and if they are not we should either correct them to be the same or mark them as such). Furthermore the swift version will sometimes drive internal efforts to improve Foundation as a whole not just it’s swift exposition. We have already had a few proposals that are making their ways to the component owners and teams that will improve the state of affairs for not just swift but objc too as externally authored proposals. <br>&gt;&gt; <br>&gt;&gt; I agree that some of this intent should be a bit more clearly laid out; I will discuss about this when I get back into the office Monday and see what we can come up with to more clearly illustrate what is expected, what types of fallout patches have, and how the process will work for each potential layer and interaction.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt;&gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br>&gt;  _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160102/7fe480c3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
