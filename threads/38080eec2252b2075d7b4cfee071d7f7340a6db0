<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>November 15, 2016 at 09:00:00am</p></header><div class="content"><p>on Tue Nov 15 2016, Shawn Erickson &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This has been discussed somewhat heavily in the past and nothing yet has<br>&gt; really moved forward on it. I do think a good way of doing something like<br>&gt; this would be helpful. I have resulted to defining an interface with an<br>&gt; extension that provides empty defaults and for each function a match bool<br>&gt; var exists to imply if it exists or not. The code accepting a delegate can<br>&gt; probe these bool vars to configure itself to efficiently operate based on<br>&gt; knowledge about what the delegate expects (some missing from most proposed<br>&gt; solutions other then @objc optional).<br></p><p>If there are truly programming problems that don&#39;t have a clean solution<br>without introducing optional requirements, I&#39;d really like to see them.<br></p><p>Speaking for myself: I think “probe-a-type” programming is in general a<br>bad idea, and I&#39;m opposed to adding features that encourage it.  It&#39;s<br>almost always better to design entry points into supertypes (protocols,<br>or base classes if you must ;-&gt;) with default implementations that can<br>be overridden to do the work you need based on the characteristics of a<br>subtype, rather than trying to make decisions in the caller based on the<br>shape of the type.  When you *do* need probing, it&#39;s a good idea to make<br>the set of possible subtypes a closed set, so the compiler can ensure<br>you handle all cases—i.e., use an enum.<br></p><p>&gt; On Tue, Nov 15, 2016 at 6:59 AM Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On 15 Nov 2016, at 12:22, Haravikk via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 15 Nov 2016, at 07:53, Rick Mann via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Nov 14, 2016, at 22:51 , Charlie Monroe via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; One major example is the NS/UITableViewDataSource or Delegate - there are<br>&gt;&gt; many many methods that you don&#39;t need to implement, hence are optional.<br>&gt;&gt;<br>&gt;&gt; But I think that this was partially solved by default implementation of<br>&gt;&gt; protocol methods, which pretty much does what you want...<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I just realized I only responded to someone else, and not the whole list.<br>&gt;&gt; It does, but it forces me to make the return value of the protocol method<br>&gt;&gt; optional, so that the default implementation can return nil.<br>&gt;&gt;<br>&gt;&gt; In the end, I guess that&#39;s not so bad, since I&#39;m not happy with the entire<br>&gt;&gt; approach, but it&#39;ll do for now.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; What&#39;s different about having the method return nil vs being optional?<br>&gt;&gt; You&#39;re attempting to call it either way, and presumably need some means of<br>&gt;&gt; handling the return value, except in Swift it&#39;s all nice and explicit and<br>&gt;&gt; easy to put in a conditional like:<br>&gt;&gt;<br>&gt;&gt; if let result = myObject.someOptionalMethod() { /* Do some stuff */ }<br>&gt;&gt; print(myObject.someOptionalStringMethod() ?? &quot;&quot;)<br>&gt;&gt;<br>&gt;&gt; And so-on. If you need a method to be both optional, and return a nilable<br>&gt;&gt; result then you can use a double optional like so:<br>&gt;&gt;<br>&gt;&gt; if let result = myObject.someDoubleOptionalMethod() { // Method was<br>&gt;&gt; implemented<br>&gt;&gt; if let value = result { // Method returned a value<br>&gt;&gt; /* Do some stuff */<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; By defining the methods as returning an Optional and throwing in default<br>&gt;&gt; implementations you can specify fewer, bigger protocols and make clear what<br>&gt;&gt; the requirements really are, though personally given the choice I&#39;d prefer<br>&gt;&gt; a dozen smaller protocols that are absolutely explicit in what they do.<br>&gt;&gt;<br>&gt;&gt; But yeah, I think the tools you need are all there already; maybe there&#39;s<br>&gt;&gt; an argument to be made for allowing default return values on protocol<br>&gt;&gt; methods, to reduce the boiler-plate?<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think there is a difference between:<br>&gt;&gt;<br>&gt;&gt; - A method which returns an optional result, and<br>&gt;&gt; - An optional method which, if present, always returns a result<br>&gt;&gt;<br>&gt;&gt; Perhaps not so much of a difference at the usage site (it’s just a<br>&gt;&gt; question of placing a ? for optional chaining), but semantically and when<br>&gt;&gt; conforming to the protocol, they mean different things.<br>&gt;&gt;<br>&gt;&gt; - Karl<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Will Swift ever support optional methods without @objc?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>November 15, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Nov 15, 2016, at 09:24 , Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Speaking for myself: I think “probe-a-type” programming is in general a<br>&gt; bad idea, and I&#39;m opposed to adding features that encourage it.  It&#39;s<br>&gt; almost always better to design entry points into supertypes (protocols,<br>&gt; or base classes if you must ;-&gt;) with default implementations that can<br>&gt; be overridden to do the work you need based on the characteristics of a<br>&gt; subtype, rather than trying to make decisions in the caller based on the<br>&gt; shape of the type.  When you *do* need probing, it&#39;s a good idea to make<br>&gt; the set of possible subtypes a closed set, so the compiler can ensure<br>&gt; you handle all cases—i.e., use an enum.<br></p><p>(I&#39;m re-watching your WWDC 2105 talk about protocol-oriented programming, so I may end up with answers to the issues below.)<br></p><p>The thing that prompted my original post on this subject was an exploration of how to best implement a CAD program. In this case, something like Illustrator, where you can create, manipulate, and draw various shape types. I wanted to separate, as much as possible, the mathematical representation of the shape from the drawing and manipulating, and ideally have only one set of objects permanently instantiated (the mathematical representations of the shapes, i.e. the model).<br></p><p>So, I have a CanvasView that has a list of these shapes (a simple array). I have a set of tools (generally, a single instance of each, although when each gets instantiated can be changed in the design). The CanvasView triggers the drawing and the mouse handling for the set of shapes (CanvasObjects).<br></p><p>I&#39;ve got something like this:<br></p><p>protocol Renderable { func renderer() -&gt; Renderer? }<br>extension Renderable { func renderer() -&gt; Renderer? { return nil } }<br></p><p>protocol Selectable { var selectionState: enum SelectionState }<br>protocol HitTestable { func hitTest(_ inPt: CGPoitn) }<br></p><p>protocol CanvasObject : HitTestable, Selectable {}<br>class Path : CanvasObject { }<br></p><p>protocol Renderer { func draw(in inCTX: CGContext) }<br>class PathRenderer : Renderer { }<br></p><p>You get the idea. Stop me if I&#39;m way off base here.<br></p><p>I initially wanted Renderable.renderer() to be optional. I think I&#39;m convinced returning an optional Renderer is equivalent.<br></p><p>Drawing<br>-------<br>CanvasView visits each CanvasObject in turn, instantiates an appropriate Renderer for the object (by calling Renderable.renderer()), calls Renderer.draw().<br></p><p>Mouse Handling<br>--------------<br>The currently-selected Tool is handed the mouse hit and the view. It iterates the objects, calling hitTest(). It then instantiates a handler based on the hit object type and current tool (might just be the current tool).<br></p><p>Problems<br>--------<br>The CanvasView has a list of CanvasObjects, forcing all objects to conform to all the protocols (e.g. Renderable, Selectable, HitTestable.) That is the CanvasView has a view onto the set of objects as complete objects, rather than a view of all Renderable objects, all HitTestable objects, etc. In this app, it may not be meaningful to talk about objects that are only renderable, but then again, it might (a grid could be renderable, but not selectable or hit testable; in practice it&#39;ll be implemented as a completely different entity, not part of the set of objects).<br></p><p>There is a problem of state management. Shapes are drawn differently depending on their state (e.g. normal, hovered, selected, sub-selected, being-snapped-to, etc.). I see no good way to store that state, except in the core object (e.g. Path). Alternatively, a parallel data structure that holds that state, but now I have to ensure instances of associated objects can be mapped back and forth. In fact, as I think about this more, I think it&#39;s a better solution, because it&#39;s conceivable there would be multiple views of the same model data, and the various states might be independent per view.<br></p><p>And performance will probably be okay, but needs to be considered.<br></p><p>I&#39;m probably just making a mountain out of a molehill, but I want to make sure I&#39;m understanding Swift thoroughly.<br></p><p><br>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
